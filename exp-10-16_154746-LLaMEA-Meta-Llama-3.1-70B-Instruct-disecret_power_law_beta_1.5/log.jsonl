{"id": "416f9291-bc02-4d60-a6be-4b95516b90ef", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 1.4\n        self.c2 = 1.4\n        self.w = 0.9\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_fitness = np.inf * np.ones(self.population_size)\n        self.gbest = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.gbest_fitness = np.inf\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.pbest_fitness[i]:\n                    self.pbest_fitness[i] = fitness\n                    self.pbest[i] = self.population[i]\n                if fitness < self.gbest_fitness:\n                    self.gbest_fitness = fitness\n                    self.gbest = self.population[i]\n                self.velocities[i] = self.w * self.velocities[i] + self.c1 * np.random.uniform(0, 1, self.dim) * (self.pbest[i] - self.population[i]) + self.c2 * np.random.uniform(0, 1, self.dim) * (self.gbest - self.population[i])\n                levy_flight = np.random.normal(0, 1, self.dim) / np.random.normal(0, 1, self.dim)\n                levy_flight = self.population[i] + levy_flight\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n        return self.gbest", "name": "HybridPSO_SA", "description": "A novel metaheuristic algorithm called \"Hybrid Particle Swarm Optimization with Levy Flight and Simulated Annealing\" that combines the exploration capabilities of particle swarm optimization with the exploitation capabilities of simulated annealing and the long-range search of Levy flight to efficiently optimize black box functions.", "configspace": "", "generation": 0, "fitness": 0.11631964961265773, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.18.", "error": "", "parent_id": null, "metadata": {"aucs": [0.19269135073577837, 0.17728538206327904, 0.1685155950838807, 0.18247513741777888, 0.1854084879799286, 0.16740012022205553, 0.161818862947832, 0.18096521604426274, 0.18216406514229588, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.034300898228614485, 0.03943492780967606, 0.054482906396298825, 0.03884071026918268, 0.03957945909880567, 0.042832971987026625, 0.04695154857315631, 0.039736486223272194, 0.037670663139556915, 0.03363745376354277, 0.029494100125404876, 0.05191183428296042, 0.031859780770813306, 0.04151478600198155, 0.0383543817360773, 0.04573232110280445, 0.02843216762669143, 0.021555927478207337, 0.9430874998691021, 0.9245829509113168, 0.9231515428494226, 0.851065618940353, 0.9185480365363952, 0.9596300076641583, 0.9331106889351711, 0.87995898036, 0.8753706420219746, 0.09359163353718236, 0.04751416805239461, 0.06223245309141112, 0.07502535841689784, 0.05276527691781263, 0.0810739597321386, 0.052764932114300445, 0.05237822198919184, 0.056187662567819596, 0.11330399178013795, 0.13802858086138658, 0.10424500046452811, 0.12634884475409858, 0.12088422267975152, 0.11728623106290792, 0.11703716940335418, 0.11731661108618996, 0.10958234350246254, 0.03420907458618894, 0.021418602465661407, 0.05812381524070043, 0.02406666991700146, 0.05771721575214739, 0.01877279063053705, 0.04092938728322604, 0.00044886217070672085, 0.029655139561305943, 0.05310970610619281, 0.010572480999152645, 0.023503505528408075, 0.02832715573638178, 0.026861519769965536, 0.04453431412143949, 0.01144736103779287, 0.001542847299032979, 0.030361089855649337, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.047766631116526126, 0.02949993580818211, 0.0324305374858721, 0.018341094269622604, 0.03268127527808096, 0.04941903357758859, 0.00037492369735048214, 0.052347807145941117, 0.019826869361314836, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0039154314164857595, 9.999999999998899e-05, 0.001283200701175491, 0.000663177316451713, 0.000109747335243493, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.19245042060094775, 0.19476698564805173, 0.18351515107526317, 0.1652677504567851, 0.169797227272804, 0.18316870604862023, 0.20227819885672038, 0.2290542406313073, 0.20340226747659107, 0.03860350268224988, 0.04310479068107309, 0.034859786324835884, 0.042577036720870653, 0.04258064586437471, 0.03767516687652439, 0.03498938830576803, 0.03784589018225326, 0.0410573682047678, 0.10100428603784462, 0.13952876708136042, 0.12024855866985851, 0.11918498112226794, 0.10847910920321024, 0.12834246226041757, 0.09819331728613268, 0.10834787516770716, 0.1049170304866468, 0.16421629677071248, 0.14598534706219413, 0.16821962941333568, 0.15211041399871572, 0.14639108388262612, 0.16579991037704056, 0.15826784027368723, 0.17365418936972254, 0.1605437163074661, 0.09167581322498186, 0.08995220155715145, 0.09996687895791578, 0.10797094608693258, 0.10567033097563905, 0.0963104617386954, 0.106378356712445, 0.10426801039591482, 0.09789421059451364, 0.14739481441166413, 0.1303089121101264, 0.15315751382434606, 0.14789588347807114, 0.13615578195561429, 0.1386622934331806, 0.15917917559975192, 0.149157835418542, 0.16256362864727703, 0.13760332654047636, 0.14631537681900442, 0.14811140697218483, 0.1377848774472974, 0.13913303047047776, 0.13590138698815157, 0.15219734250495365, 0.15125087135751347, 0.13627557627322462, 0.11901306350047747, 0.17542555319606368, 0.12711973490921225, 0.13688737417037777, 0.14783489405198635, 0.1036185940634492, 0.13585636314248295, 0.12970462744773414, 0.10454809864611647, 0.1290470844409165, 0.13897732235285098, 0.11791454001896129, 0.11808859268834226, 0.13476485526435555, 0.10586854160542447, 0.108709776901316, 0.1296461328412315, 0.11483659385778444, 0.16500709457073903, 0.15393829111738977, 0.1522882501255023, 0.14477614573216047, 0.1644997044044072, 0.1626248673327838, 0.1572560912063451, 0.14593175184685114, 0.1510484150060618, 0.04407026832022598, 0.04042238224826955, 0.046156441577538176, 0.05688381264163744, 0.054670859778020886, 0.05121162828498094, 0.050547538965251215, 0.05614835510866922, 0.051553716867001054]}, "mutation_prompt": null}
{"id": "aa328208-5ed2-49a6-b930-b249fa5beb32", "solution": "import numpy as np\n\nclass HybridPSO_SA_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 1.4\n        self.c2 = 1.4\n        self.w = 0.9\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_fitness = np.inf * np.ones(self.population_size)\n        self.gbest = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.gbest_fitness = np.inf\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.pbest_fitness[i]:\n                    self.pbest_fitness[i] = fitness\n                    self.pbest[i] = self.population[i]\n                if fitness < self.gbest_fitness:\n                    self.gbest_fitness = fitness\n                    self.gbest = self.population[i]\n                self.velocities[i] = self.w * self.velocities[i] + self.c1 * np.random.uniform(0, 1, self.dim) * (self.pbest[i] - self.population[i]) + self.c2 * np.random.uniform(0, 1, self.dim) * (self.gbest - self.population[i])\n                levy_flight = np.random.normal(0, 1, self.dim) / np.random.normal(0, 1, self.dim)\n                levy_flight = self.population[i] + levy_flight\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                # Apply opposition-based learning with a probability of 0.2\n                if np.random.uniform(0, 1) < 0.2:\n                    opposite_individual = self.opposition_based_learning(self.population[i])\n                    opposite_fitness = func(opposite_individual)\n                    evaluations += 1\n                    if opposite_fitness < fitness:\n                        self.population[i] = opposite_individual\n        return self.gbest", "name": "HybridPSO_SA_OBL", "description": "A novel metaheuristic algorithm called \"Hybrid Particle Swarm Optimization with Levy Flight, Simulated Annealing, and Opposition-Based Learning\" that combines the exploration capabilities of particle swarm optimization with the exploitation capabilities of simulated annealing, the long-range search of Levy flight, and the opposition-based learning to efficiently optimize black box functions.", "configspace": "", "generation": 1, "fitness": 0.11867487662937327, "feedback": "The algorithm HybridPSO_SA_OBL got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.18.", "error": "", "parent_id": "416f9291-bc02-4d60-a6be-4b95516b90ef", "metadata": {"aucs": [0.20903858644959605, 0.17800752442717327, 0.19396838303052655, 0.16541995548127475, 0.15886012853480735, 0.16240395794462092, 0.1861282604997866, 0.18903349208796727, 0.1781856703646859, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05017987937812396, 0.039977521122830706, 0.03931153034432733, 0.043800690461994196, 0.03716482210549288, 0.03808981059821781, 0.039081381207065724, 0.047604784534288624, 0.04360482992787296, 0.03412091418651875, 0.03651097829190708, 0.04222284025237566, 0.03213560867233012, 0.03453324372586286, 0.03276779516607564, 0.03359325700670124, 0.04390971087988782, 0.032928788654519536, 0.8837978476921967, 0.9551485112276772, 0.9668265783258901, 0.9492491973053172, 0.913501599739147, 0.9058279112664984, 0.9035715326411162, 0.9514470995392211, 0.904550679091355, 0.10043495778529465, 0.06971949689067403, 0.07287298043469059, 0.06440461791346497, 0.07047923987726312, 0.07153150705235656, 0.05575248897060048, 0.08843857802396105, 0.057020027357678416, 0.1372792674764738, 0.11748019265710741, 0.12468870844627511, 0.15242585387225827, 0.11657333783725732, 0.09342332888836047, 0.13257085310416006, 0.1342659275745114, 0.10102723613221609, 0.0012310946864217964, 0.011824511187514708, 0.0244333060572548, 0.0034109244881543876, 0.0040191304699684904, 0.03460455191101719, 0.039195437847772574, 0.01921173932553011, 0.041795497179579644, 0.0559553563047086, 0.06809431258913268, 0.024873438511473944, 0.011646186101071043, 0.05614089048103088, 0.016460846018049424, 0.01916871544482457, 0.011677800542672756, 0.029882364437854858, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.043493205307701066, 0.06672936758073611, 0.009052590317138343, 0.03742229399197383, 9.999999999998899e-05, 0.03129293168810343, 0.028856395601606355, 0.008401271848892278, 0.03908320092811468, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00503737633841006, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0009223212645680379, 9.999999999998899e-05, 0.00045462043246025097, 0.19928258230699658, 0.18144772525419495, 0.17930449814009097, 0.17680022281290653, 0.1672738051707896, 0.18173763394460574, 0.19285290793276777, 0.1770721960715096, 0.16196397400371298, 0.041486290741624354, 0.03493778152280924, 0.03336492898322008, 0.050110733402064955, 0.03739483658891973, 0.05123960976043129, 0.03973586492253056, 0.04743410710816265, 0.04658100765559481, 0.1433212031910367, 0.10769774293211809, 0.1182673223559817, 0.1225296242883609, 0.12323274647414251, 0.16136620437015115, 0.1232668120593442, 0.10204638245083819, 0.13308417676023532, 0.16259266959162688, 0.15777546237496498, 0.161613609863398, 0.16109773885152667, 0.153047959473664, 0.16135254486168082, 0.15433805251636, 0.17404229409962868, 0.14906422720645918, 0.12384512033365247, 0.09833955798152094, 0.1026725574349826, 0.10440033949625216, 0.11032134027283558, 0.12027731768636118, 0.11951082907769306, 0.1168407698781353, 0.12274546992634883, 0.15334541875599683, 0.14338457390960935, 0.14697223042388974, 0.15782548342057767, 0.14271265955564283, 0.15708802399415522, 0.14031552650423018, 0.14913371067384218, 0.15964513848345452, 0.14370369279887674, 0.15061666685389175, 0.14803019503906545, 0.13254331718670453, 0.15723866779678608, 0.12942221996943915, 0.13488115611635454, 0.15148085476257434, 0.14669034783879664, 0.1765569374277327, 0.10693573110779908, 0.1822414941185888, 0.14781440953915148, 0.13750181502807068, 0.1494545162906723, 0.13074977532905763, 0.1432931570944993, 0.11221867821034082, 0.16482891881393136, 0.14690280902951436, 0.131186180572209, 0.12663828565459223, 0.08305223248109939, 0.08984314228074963, 0.09865050182040125, 0.08912214382573436, 0.1260672630966324, 0.15284899057828238, 0.16195525004689715, 0.15713636865692027, 0.1402090090824829, 0.15543284906341992, 0.1575987899839285, 0.16561669610018503, 0.16562992259808362, 0.14872859459187515, 0.04893103458657955, 0.06383020368880665, 0.04927706403951271, 0.06520858869401525, 0.05100504500940317, 0.04348636245928306, 0.05422662181256965, 0.059520462999521406, 0.05166725867236999]}, "mutation_prompt": null}
{"id": "e543553b-bd1c-4d78-bbd1-dc12feae1e66", "solution": "import numpy as np\n\nclass HybridPSO_SA_OBL_CT:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 1.4\n        self.c2 = 1.4\n        self.w = 0.9\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.zeros((self.population_size, self.dim))\n        self.pbest = self.population.copy()\n        self.pbest_fitness = np.inf * np.ones(self.population_size)\n        self.gbest = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.gbest_fitness = np.inf\n        self.chaos_map = np.random.uniform(0, 1, self.population_size)\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def chaotic_search(self, individual):\n        for i in range(self.dim):\n            self.chaos_map[i] = self.logistic_map(self.chaos_map[i])\n            if np.random.uniform(0, 1) < self.chaos_map[i]:\n                individual[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.pbest_fitness[i]:\n                    self.pbest_fitness[i] = fitness\n                    self.pbest[i] = self.population[i]\n                if fitness < self.gbest_fitness:\n                    self.gbest_fitness = fitness\n                    self.gbest = self.population[i]\n                self.velocities[i] = self.w * self.velocities[i] + self.c1 * np.random.uniform(0, 1, self.dim) * (self.pbest[i] - self.population[i]) + self.c2 * np.random.uniform(0, 1, self.dim) * (self.gbest - self.population[i])\n                levy_flight = np.random.normal(0, 1, self.dim) / np.random.normal(0, 1, self.dim)\n                levy_flight = self.population[i] + levy_flight\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                # Apply opposition-based learning with a probability of 0.2\n                if np.random.uniform(0, 1) < 0.2:\n                    opposite_individual = self.opposition_based_learning(self.population[i])\n                    opposite_fitness = func(opposite_individual)\n                    evaluations += 1\n                    if opposite_fitness < fitness:\n                        self.population[i] = opposite_individual\n                # Apply chaotic search with a probability of 0.1\n                if np.random.uniform(0, 1) < 0.1:\n                    chaotic_individual = self.chaotic_search(self.population[i])\n                    chaotic_fitness = func(chaotic_individual)\n                    evaluations += 1\n                    if chaotic_fitness < fitness:\n                        self.population[i] = chaotic_individual\n        return self.gbest", "name": "HybridPSO_SA_OBL_CT", "description": "A novel metaheuristic algorithm called \"Hybrid Particle Swarm Optimization with Levy Flight, Simulated Annealing, Opposition-Based Learning, and Chaos Theory\" that combines the exploration capabilities of particle swarm optimization with the exploitation capabilities of simulated annealing, the long-range search of Levy flight, the opposition-based learning, and the chaotic search to efficiently optimize black box functions.", "configspace": "", "generation": 2, "fitness": 0.11457496476938372, "feedback": "The algorithm HybridPSO_SA_OBL_CT got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.18.", "error": "", "parent_id": "aa328208-5ed2-49a6-b930-b249fa5beb32", "metadata": {"aucs": [0.15513285142669808, 0.18095459411421944, 0.16730555557891935, 0.1747326910660797, 0.1741797417362484, 0.1678098989749044, 0.19343089913656697, 0.1587409586518579, 0.16625727548979208, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04558572097322522, 0.04220290842083685, 0.03521541106285864, 0.04553264948681102, 0.05290377313806016, 0.03132074449371869, 0.04685927962905223, 0.03202568224895863, 0.05308208343089993, 0.034151520481932485, 0.023637154241502922, 0.02867862681553046, 0.05165693557804385, 0.022108846572420182, 0.029357979266145362, 0.03624169983756642, 0.022365047886093503, 0.022090695961888063, 0.933050296533289, 0.8160865396483487, 0.8629240680495824, 0.9205860509247534, 0.9629329426031502, 0.8954595210936682, 0.9159194827853829, 0.8966596063982429, 0.902024349046337, 0.08024742649469863, 0.0762210779992969, 0.05611713498553783, 0.0772709574467848, 0.051942461683489816, 0.07213782102038202, 0.08781131463051772, 0.07242590997989451, 0.06202997771413643, 0.1625465126906923, 0.11377979121805892, 0.10384660475964991, 0.1159994704745404, 0.10385511818145954, 0.11537336750693084, 0.09034632898587547, 0.12035280969727535, 0.12938925504221555, 9.999999999998899e-05, 0.0006881414473595138, 0.019341923101457215, 0.006136691969688246, 9.999999999998899e-05, 0.01055302443205186, 0.012155787512630689, 9.999999999998899e-05, 0.0012009005578625942, 0.029033195864708095, 0.002066679128793658, 0.01968205959383762, 9.999999999998899e-05, 0.003959900082677992, 0.010544268182150374, 0.022249532163417407, 0.009288740734683998, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006990862635586903, 0.019453150427296007, 0.04030229811012631, 0.012115186880140572, 0.05319548063747259, 0.025375733003874523, 0.012191676511161487, 0.007582184757993438, 0.0012954205774577954, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01265763870359915, 9.999999999998899e-05, 0.18828682255060059, 0.16302685295499175, 0.1853420274248504, 0.15482997387397823, 0.19296980028213762, 0.17810439761384822, 0.18095183537637916, 0.17337119492395414, 0.17515721425759256, 0.04004343075464678, 0.04022549376792428, 0.03403542753035549, 0.04194209881629629, 0.030905756805734153, 0.03753599458590484, 0.03186344829607335, 0.03731899933911209, 0.043928189889922975, 0.12357836634070607, 0.11745106417405027, 0.1421935113031444, 0.12225206830650515, 0.12174022448609545, 0.11223770152542711, 0.1335462604468901, 0.11299826783457156, 0.12013317548424951, 0.15296311368301996, 0.15962756996753147, 0.16629863894492558, 0.16572887665862668, 0.14786985753791104, 0.15137948703644155, 0.16063326858968285, 0.17359696460271856, 0.14343689404779758, 0.0937349839325643, 0.11946749847691807, 0.08941857399772357, 0.10673889630912547, 0.1110767740361509, 0.1018160662347618, 0.10408193853006886, 0.10367417135045887, 0.10789796558341802, 0.14639804499720432, 0.147148309911174, 0.15146487386440166, 0.15322452523984997, 0.14199619916272188, 0.13740479069301603, 0.15029696433612139, 0.15089681975991898, 0.14085487231185378, 0.14097735257311084, 0.14865551733481186, 0.1294970641174512, 0.13891383851370231, 0.13116982386567888, 0.12543413344141496, 0.1405163189025791, 0.1292450671814087, 0.1521318092243178, 0.1443923924440934, 0.14442396366499088, 0.13609667874339704, 0.13102396274182282, 0.16562045118566204, 0.12206963890177502, 0.20548162839611328, 0.1781277091909631, 0.12343058994340284, 0.1301610456875535, 0.14002107739496028, 0.11173847808129522, 0.10455499797064127, 0.11628820082508207, 0.15262631346911637, 0.12299486890750488, 0.14887824975222852, 0.10750330618727388, 0.16658224555219425, 0.18001444531166455, 0.15782920422047741, 0.1769946694479455, 0.16646311633933564, 0.1678571421635655, 0.1764791236213834, 0.180881630874682, 0.17331475793948248, 0.047199883963782496, 0.044470685732672766, 0.048874079293571016, 0.05289655691493078, 0.05185993388759458, 0.047820011273815854, 0.04183295907064144, 0.044379140965679964, 0.05241388591801244]}, "mutation_prompt": null}
{"id": "28e97af1-cead-4780-ae26-ac0e985811d6", "solution": "import numpy as np\n\nclass HybridGWO_SA_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.alpha_wolf = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.beta_wolf = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.delta_wolf = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.alpha_fitness = np.inf\n        self.beta_fitness = np.inf\n        self.delta_fitness = np.inf\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def levy_flight(self, individual):\n        levy_flight = np.random.normal(0, 1, self.dim) / np.random.normal(0, 1, self.dim)\n        levy_flight = individual + levy_flight\n        return levy_flight\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.alpha_fitness:\n                    self.delta_fitness = self.beta_fitness\n                    self.delta_wolf = self.beta_wolf\n                    self.beta_fitness = self.alpha_fitness\n                    self.beta_wolf = self.alpha_wolf\n                    self.alpha_fitness = fitness\n                    self.alpha_wolf = self.population[i]\n                elif fitness < self.beta_fitness:\n                    self.delta_fitness = self.beta_fitness\n                    self.delta_wolf = self.beta_wolf\n                    self.beta_fitness = fitness\n                    self.beta_wolf = self.population[i]\n                elif fitness < self.delta_fitness:\n                    self.delta_fitness = fitness\n                    self.delta_wolf = self.population[i]\n                a = 2 - evaluations / self.budget\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                A = 2 * a * r1 - a\n                C = 2 * r2\n                D = np.abs(C * self.alpha_wolf - self.population[i])\n                X1 = self.alpha_wolf - A * D\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                A = 2 * a * r1 - a\n                C = 2 * r2\n                D = np.abs(C * self.beta_wolf - self.population[i])\n                X2 = self.beta_wolf - A * D\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                A = 2 * a * r1 - a\n                C = 2 * r2\n                D = np.abs(C * self.delta_wolf - self.population[i])\n                X3 = self.delta_wolf - A * D\n                self.population[i] = (X1 + X2 + X3) / 3\n                levy_flight = self.levy_flight(self.population[i])\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                # Apply opposition-based learning with a probability of 0.2\n                if np.random.uniform(0, 1) < 0.2:\n                    opposite_individual = self.opposition_based_learning(self.population[i])\n                    opposite_fitness = func(opposite_individual)\n                    evaluations += 1\n                    if opposite_fitness < fitness:\n                        self.population[i] = opposite_individual\n        return self.alpha_wolf", "name": "HybridGWO_SA_OBL", "description": "A novel metaheuristic algorithm called \"Hybrid Grey Wolf Optimizer with Levy Flight, Simulated Annealing, and Opposition-Based Learning\" that combines the exploration capabilities of grey wolf optimizer with the exploitation capabilities of simulated annealing, the long-range search of Levy flight, and the opposition-based learning to efficiently optimize black box functions.", "configspace": "", "generation": 3, "fitness": 0.12688729905451254, "feedback": "The algorithm HybridGWO_SA_OBL got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "aa328208-5ed2-49a6-b930-b249fa5beb32", "metadata": {"aucs": [0.20413214284887382, 0.183643249737522, 0.21903905964830583, 0.13750215459467563, 0.14525448698097387, 0.16656613333829173, 0.15009174847644446, 0.15095635150218023, 0.18372260846620925, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.041603157140344016, 0.035179546249379356, 0.06246434253725963, 0.05286203190654737, 0.018521997226598197, 0.018906842491178244, 0.031923267323933247, 0.04105164961433205, 0.06629145278162718, 0.030893090233032883, 0.04508230141423719, 0.049331109659892736, 0.042360602274112535, 0.03263230299574682, 0.03778859673263413, 0.028204433865099077, 0.023895274928059762, 0.0504150206445384, 0.9809592554873323, 0.9903371886736261, 0.9622521422929512, 0.9199957499145835, 0.9402832180810096, 0.9112903722226489, 0.9735295552968498, 0.9906102193342559, 0.9385400325866408, 0.10087441495939509, 0.06145502999747621, 0.07650401509366789, 0.0653966918947213, 0.05264591837790067, 0.05619042548200048, 0.031754246218586246, 0.0843458173723497, 0.0588076516935675, 0.16412551413747367, 0.10306523866073147, 0.16081918180031918, 0.09098038745681292, 0.1374145471468179, 0.14777917726129364, 0.1311989799021379, 0.08400099800597105, 0.0930661465537953, 0.05158580410968916, 0.027287948519634897, 0.04399942884474728, 0.00017256693917955257, 0.004455855200558689, 0.010647100558839107, 0.05124042267476747, 0.02682471475584791, 0.0003793517441883498, 0.08773995809499324, 0.07833130839603053, 0.1425226569224074, 0.11479589937995971, 0.10892217378572056, 0.14004457785344693, 0.1310951691859642, 0.1037145224094369, 0.143570504989047, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016664178724690504, 0.027199070341258236, 0.03765902941404875, 0.09820385816512367, 0.003901633955699757, 0.013550610294935761, 0.07945207525093123, 0.0030632524725610066, 0.03908183614386185, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004998010808757503, 0.005390811876697432, 0.0020750617665870053, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004367736158623625, 9.999999999998899e-05, 0.20510193247915776, 0.21618797398524858, 0.22013861988635686, 0.18614155431369506, 0.17562332442037365, 0.13146404873997675, 0.20628875619881004, 0.22088355724489905, 0.18155953443436423, 0.0327899568751282, 0.0001838877143700568, 0.03472349452034229, 0.057675437387036066, 0.06074735043246726, 0.037907205700510205, 0.05988137931648474, 0.048390710520354485, 0.05566168413580053, 0.13261338175810888, 0.12263022547601099, 0.11831793940490332, 0.13980421949045851, 0.12221645510660639, 0.12638956745461305, 0.10513352999614145, 0.10677073439938778, 0.13571937180812033, 0.16256198481018835, 0.15113235962131788, 0.1711397637078993, 0.19605015312554575, 0.19638924709596284, 0.20998148706299424, 0.1793973214544785, 0.1736288913603946, 0.16444503935088228, 0.08877523594009962, 0.09361026908579151, 0.09319566598475171, 0.10164771584261978, 0.12683768323335953, 0.14408496697493756, 0.10036161178485759, 0.10122067231473941, 0.11119889807137007, 0.18538672253381983, 0.17221469228519926, 0.20795762148478925, 0.17318005979086915, 0.20163550467798508, 0.1844941028048921, 0.164895173136543, 0.1517107994577569, 0.17869852911501716, 0.15194222449581407, 0.1293194933951256, 0.15304510739937904, 0.16174891587847817, 0.13426147412917055, 0.159473591631904, 0.161965788796674, 0.15023187255524606, 0.16046649475738883, 0.1579283451777168, 0.12625924195960347, 0.12874263605463965, 0.1443448847936244, 0.12559184245384036, 0.1450922179566585, 0.187743942644791, 0.19657405659542193, 0.1186549277537935, 0.16298225268046262, 0.15533573045904436, 0.1415909241069998, 0.17471176412213174, 0.10183372370751453, 0.12290624774243986, 0.1145633540281984, 0.08835584507353322, 0.11522430366525549, 0.1602578671874615, 0.16529274598406196, 0.16700812307912105, 0.14815592356883933, 0.16516618650935166, 0.16264380978488768, 0.16568964601172242, 0.16455619541604938, 0.1584323426325931, 0.06281329766218369, 0.047691528506645264, 0.057702185720173826, 0.05182230287291545, 0.04437853100156208, 0.046351340888037496, 0.06331081249250614, 0.06652464200961661, 0.04751570386816051]}, "mutation_prompt": null}
{"id": "2baf2c32-9ac3-4c39-bd25-009cc7d4e6ed", "solution": "import numpy as np\n\nclass HybridSCA_SA_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.best_fitness = np.inf\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def levy_flight(self, individual):\n        levy_flight = np.random.normal(0, 1, self.dim) / np.random.normal(0, 1, self.dim)\n        levy_flight = individual + levy_flight\n        return levy_flight\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_position = self.population[i]\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                r3 = np.random.uniform(0, 1, self.dim)\n                r4 = np.random.uniform(0, 1, self.dim)\n                if r3 < 0.5:\n                    self.population[i] = self.best_position + r1 * np.abs(r2 * self.best_position - self.population[i])\n                else:\n                    self.population[i] = self.best_position - r1 * np.abs(r2 * self.best_position - self.population[i])\n                levy_flight = self.levy_flight(self.population[i])\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                # Apply opposition-based learning with a probability of 0.2\n                if np.random.uniform(0, 1) < 0.2:\n                    opposite_individual = self.opposition_based_learning(self.population[i])\n                    opposite_fitness = func(opposite_individual)\n                    evaluations += 1\n                    if opposite_fitness < fitness:\n                        self.population[i] = opposite_individual\n        return self.best_position", "name": "HybridSCA_SA_OBL", "description": "A novel metaheuristic algorithm called \"Hybrid Sine Cosine Algorithm with Levy Flight, Simulated Annealing, and Opposition-Based Learning\" that combines the exploration capabilities of sine cosine algorithm with the exploitation capabilities of simulated annealing, the long-range search of Levy flight, and the opposition-based learning to efficiently optimize black box functions.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "28e97af1-cead-4780-ae26-ac0e985811d6", "metadata": {}, "mutation_prompt": null}
{"id": "b861dd41-ed12-4f7c-a109-9940416caa74", "solution": "import numpy as np\n\nclass HybridDFO_SA_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.best_fitness = np.inf\n        self.worst_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.worst_fitness = -np.inf\n        self.food_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.food_fitness = np.inf\n        self.enemy_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.enemy_fitness = -np.inf\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def levy_flight(self, individual):\n        levy_flight = np.random.normal(0, 1, self.dim) / np.random.normal(0, 1, self.dim)\n        levy_flight = individual + levy_flight\n        return levy_flight\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.best_fitness:\n                    self.worst_fitness = self.best_fitness\n                    self.worst_position = self.best_position\n                    self.best_fitness = fitness\n                    self.best_position = self.population[i]\n                elif fitness > self.worst_fitness:\n                    self.worst_fitness = fitness\n                    self.worst_position = self.population[i]\n                s = np.random.uniform(0, 1, self.dim)\n                a = 0.1 * s\n                c = 0.1 * s\n                f = np.random.uniform(-1, 1, self.dim)\n                x = self.population[i]\n                step = (self.best_position - x) * a + (self.food_position - x) * c + f * np.abs(self.enemy_position - x)\n                self.population[i] = x + step\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n                levy_flight = self.levy_flight(self.population[i])\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                # Apply opposition-based learning with a probability of 0.2\n                if np.random.uniform(0, 1) < 0.2:\n                    opposite_individual = self.opposition_based_learning(self.population[i])\n                    opposite_fitness = func(opposite_individual)\n                    evaluations += 1\n                    if opposite_fitness < fitness:\n                        self.population[i] = opposite_individual\n        return self.best_position", "name": "HybridDFO_SA_OBL", "description": "A novel metaheuristic algorithm called \"Hybrid Dragonfly Optimizer with Levy Flight, Simulated Annealing, and Opposition-Based Learning\" that combines the exploration capabilities of dragonfly optimizer with the exploitation capabilities of simulated annealing, the long-range search of Levy flight, and the opposition-based learning to efficiently optimize black box functions.", "configspace": "", "generation": 5, "fitness": 0.10078352882297478, "feedback": "The algorithm HybridDFO_SA_OBL got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.11.", "error": "", "parent_id": "28e97af1-cead-4780-ae26-ac0e985811d6", "metadata": {"aucs": [0.18727522820997144, 0.20544182810672118, 0.13892040470182399, 0.15912577513173287, 0.1360373738419618, 0.14315950911875752, 0.14948529769869567, 0.13766239710445882, 0.1395718542451665, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03376717528171724, 0.05924773247693682, 0.05778168810243023, 0.044102658091205726, 0.04397106200488066, 0.028981907009962726, 0.03006662919012182, 0.03075760248642123, 0.03658753073510468, 0.023539525971161712, 0.03456864617433353, 0.03103597456102647, 0.03326580780246424, 0.02591853331072458, 0.024861273425679564, 0.03439530030597415, 0.036562257998663306, 0.01415320749346427, 0.17874084321589, 0.7117719613665524, 0.6974160875093953, 0.3441543778943591, 0.12475144041294772, 0.9107218628161142, 0.19904482673964807, 0.21088672362985705, 0.10044405206809748, 0.0674069831884968, 0.05514667845833521, 0.06560465034390672, 0.04143001095071053, 0.06947617075474222, 0.07577868767498253, 0.05082673054146036, 0.07537425566286327, 0.052563073701657026, 0.12245491742543524, 0.12848328769796535, 0.10106003546338638, 0.10006233225924754, 0.13298126788370324, 0.18933185818571707, 0.1421183672587496, 0.11389381104719065, 0.13437367094165342, 0.0269342809088835, 0.0022235229411394775, 9.999999999998899e-05, 0.011003166440740508, 9.999999999998899e-05, 9.999999999998899e-05, 0.0375670274821972, 9.999999999998899e-05, 0.003619217045091716, 0.012209322084479779, 0.048695705326996186, 0.0037173566390380497, 9.999999999998899e-05, 0.055111266087092936, 0.0005502163331744248, 0.019218621185143947, 0.04716870039014154, 0.0003630371579632641, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04172360392930219, 0.027315775330431613, 0.08563620289887042, 0.045874234892751, 0.032447279884282976, 0.036482507015082044, 0.07719985081287872, 0.0855551208391413, 0.09121085823780228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0019140668123087679, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.19349641610358193, 0.19612258545371564, 0.1984794977521337, 0.15323764738731516, 0.17246054171650882, 0.1658108624182678, 0.22379982878598126, 0.18560802359418127, 0.16956380365818569, 0.02782039469150166, 0.04769393931763333, 0.035721943994338146, 0.05350273148174478, 0.036822978830551856, 0.05514120440876391, 0.04634894856634275, 0.03982992075029068, 0.0484620623388351, 0.12529268530170035, 0.15158739249971132, 0.15397422021598517, 0.13719998301637537, 0.16095155534942607, 0.13672427479253368, 0.12664171342714248, 0.17697756421993438, 0.1710015197872482, 0.14617467319099509, 0.1583987307031468, 0.16825152569169355, 0.1836470482202448, 0.19620503999548733, 0.16810021611000925, 0.16353682491936106, 0.17363943747895505, 0.14374910903315397, 0.09950871737906686, 0.1019245078616694, 0.09611149298833477, 0.10621796790892224, 0.1344752697450624, 0.1380743751687321, 0.11047178035451999, 0.11316138256085251, 0.1020234215184932, 0.16799352760155994, 0.17208134832411215, 0.17225959833763405, 0.17180518028036362, 0.19158153117869892, 0.1673385532183338, 0.1622571174525077, 0.19242647368068888, 0.16418814275274285, 0.14243879277418525, 0.16852710540932603, 0.1496861832641, 0.12986404732863688, 0.15251484038062935, 0.14494782626447655, 0.14382771636557523, 0.14991866409245935, 0.1335454723381303, 0.15114700589675556, 0.15543539280761975, 0.12021637059108048, 0.2022816536634654, 0.20966156118069612, 0.14352321723286043, 0.1687476428141912, 0.13689460674624265, 0.17026394314517856, 0.15439967734506044, 0.17972475030943114, 0.2009084348436616, 0.1140312893625609, 0.13170926278366202, 0.165522449054189, 0.1239301414687074, 0.17473085796448884, 0.16337083719739898, 0.17661605541307257, 0.17056336548449103, 0.1686242277200256, 0.19186567876750826, 0.17425589089551707, 0.18568950103356052, 0.1686208177991061, 0.16397845596515404, 0.20353027878316465, 0.05403989086768746, 0.05651149870618899, 0.0611241739086259, 0.0515119424361854, 0.05537084138227233, 0.04943693502959956, 0.056987284052836706, 0.06732923255767642, 0.06125509247027716]}, "mutation_prompt": null}
{"id": "7fc880ea-13fc-491d-96ef-2da1fa46aa73", "solution": "import numpy as np\n\nclass HybridSSA_SA_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.leader = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.leader_fitness = np.inf\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def levy_flight(self, individual):\n        levy_flight = np.random.normal(0, 1, self.dim) / np.random.normal(0, 1, self.dim)\n        levy_flight = individual + levy_flight\n        return levy_flight\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.leader_fitness:\n                    self.leader_fitness = fitness\n                    self.leader = self.population[i]\n                c1 = 2 * np.random.uniform(0, 1, self.dim) - 1\n                c2 = 2 * np.random.uniform(0, 1, self.dim) - 1\n                c3 = 2 * np.random.uniform(0, 1, self.dim) - 1\n                A = 2 * c1 * self.leader - c2 * self.population[i]\n                B = c3 * self.leader\n                self.population[i] = A + B\n                levy_flight = self.levy_flight(self.population[i])\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                # Apply opposition-based learning with a probability of 0.2\n                if np.random.uniform(0, 1) < 0.2:\n                    opposite_individual = self.opposition_based_learning(self.population[i])\n                    opposite_fitness = func(opposite_individual)\n                    evaluations += 1\n                    if opposite_fitness < fitness:\n                        self.population[i] = opposite_individual\n        return self.leader", "name": "HybridSSA_SA_OBL", "description": "A novel metaheuristic algorithm called \"Hybrid Salp Swarm Algorithm with Levy Flight, Simulated Annealing, and Opposition-Based Learning\" that combines the exploration capabilities of salp swarm algorithm with the exploitation capabilities of simulated annealing, the long-range search of Levy flight, and the opposition-based learning to efficiently optimize black box functions.", "configspace": "", "generation": 6, "fitness": 0.10336735664009532, "feedback": "The algorithm HybridSSA_SA_OBL got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.18.", "error": "", "parent_id": "28e97af1-cead-4780-ae26-ac0e985811d6", "metadata": {"aucs": [0.11851834356968616, 0.12020942065748763, 0.11000709955489907, 0.09689505214948113, 0.10722680907220095, 0.11019710495080703, 0.12420123592834897, 0.13115993319906738, 0.07211560804125527, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0321431298675352, 0.04622513294097841, 0.03152707061323656, 0.03060033478105817, 0.045491292467846556, 0.02309838240058415, 0.027863304927119636, 0.026576335109601668, 0.0275129299970166, 0.029076813285289105, 0.023431954946563027, 0.022117506062046766, 0.022989689151154402, 0.015133116776296585, 0.026512143381382747, 0.02511182093355968, 9.999999999998899e-05, 0.0313898073915756, 0.9509069088370403, 0.9462970114723372, 0.9684585664230387, 0.9784426670137744, 0.9367665694405731, 0.9444726057486841, 0.9414268565623242, 0.8993896580485881, 0.9379088200561037, 0.06247753042966686, 0.017586605565214852, 0.01851631738056081, 0.036381513179949976, 0.0497883120824365, 9.999999999998899e-05, 0.0019990654931949514, 0.027850306295431282, 0.039214543787653766, 0.10026707873980667, 0.12048045643125638, 0.1276646187380608, 0.06651100122306675, 0.07259928848715591, 0.039654180047126286, 0.09695905722458176, 0.0905160041626707, 0.13576307798733156, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0219682897634097, 0.031213267183821558, 0.11500884090144958, 0.10069659591695512, 0.14667346101288037, 0.022990765678959413, 0.0803757934841447, 0.13291271015998518, 0.13130534922308434, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04281008076500403, 9.999999999998899e-05, 9.999999999998899e-05, 0.03972833518754926, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005194317413813598, 0.052688248507759994, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.17367996950166487, 0.17333589448111886, 0.1679745572768354, 0.129038404270436, 0.1041946933675858, 0.11780716721385942, 0.16097976772042044, 0.14057374580313275, 0.17354888582421246, 0.022202152069752845, 0.009977714142654803, 0.021887447829315843, 0.032528926634834754, 0.02453925046592098, 0.03319405299372413, 0.025656455427361835, 0.014276081668591956, 0.02675766679738989, 0.12223758189486322, 0.08602768822876294, 0.11815143560868213, 0.09873536738082656, 0.10846628096601707, 0.1077161153439864, 0.08798387150956, 0.0808669455433827, 0.09703801988482197, 0.10772070454456151, 0.13280630879432997, 0.161187066285013, 0.14567056727407468, 0.14362472124928516, 0.14587227372454148, 0.12785490022623158, 0.17369064840547255, 0.11683723411237756, 0.08234074085982934, 0.06066067419193133, 0.0837697869420525, 0.0757573957427754, 0.0769344693068369, 0.11978549349959156, 0.10831226422196838, 0.09966113241394492, 0.07331062299341051, 0.15377456639686826, 0.12602615827658414, 0.13339903595280533, 0.1664050221335045, 0.14459325421916747, 0.16289578675800387, 0.12245976138762271, 0.13717166716954632, 0.1261689754075176, 0.13454862505767995, 0.14147074234123558, 0.13059455618528193, 0.1429351635443169, 0.13275262824950773, 0.14753433017449546, 0.14364393686568366, 0.08597489061217167, 9.999999999998899e-05, 0.11469411829450349, 0.11381350477386021, 0.10494227558925251, 0.07325054113234963, 0.12078042349888451, 0.09711402041856831, 0.10681912634600943, 0.10498449341878491, 0.09962853438879937, 0.1101455540176004, 0.10253762352618345, 0.09726569315308775, 0.09713469002062824, 0.12162866149218843, 0.0739017572506897, 0.09221032797305939, 0.09740629299870085, 0.05214628340452132, 0.1462717167551304, 0.14057596357693858, 0.1476274820999004, 0.14944071867105757, 0.1307204877378637, 0.17129540733533832, 0.14957912851645028, 0.13035789839846135, 0.14687927467103823, 0.04231277332522898, 0.050605908396205046, 0.0389128267028942, 0.058403252587994725, 0.03418725267057943, 0.03481516948557406, 0.045064555189538114, 0.04883281911973936, 0.04371906941295489]}, "mutation_prompt": null}
{"id": "486cc728-a913-444c-a82f-69deef08ccf2", "solution": "import numpy as np\n\nclass HybridSCA_SA_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.best_fitness = np.inf\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def levy_flight(self, individual):\n        levy_flight = np.random.normal(0, 1, self.dim) / np.random.normal(0, 1, self.dim)\n        levy_flight = individual + levy_flight\n        return levy_flight\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_individual = self.population[i]\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                r3 = np.random.uniform(0, 1, self.dim)\n                r4 = np.random.uniform(0, 1, self.dim)\n                A = 2 * r1 - 1\n                B = np.abs(r2)\n                C = 2 * r3 - 1\n                D = np.abs(r4)\n                if r1 < 0.5:\n                    X1 = self.best_individual + r1 * np.abs(C * self.best_individual - self.population[i]) * np.sin(np.pi * r2)\n                else:\n                    X1 = self.best_individual - r1 * np.abs(C * self.best_individual - self.population[i]) * np.sin(np.pi * r2)\n                if r3 < 0.5:\n                    X2 = self.best_individual + r3 * np.abs(D * self.best_individual - self.population[i]) * np.cos(np.pi * r4)\n                else:\n                    X2 = self.best_individual - r3 * np.abs(D * self.best_individual - self.population[i]) * np.cos(np.pi * r4)\n                self.population[i] = (X1 + X2) / 2\n                levy_flight = self.levy_flight(self.population[i])\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                # Apply opposition-based learning with a probability of 0.2\n                if np.random.uniform(0, 1) < 0.2:\n                    opposite_individual = self.opposition_based_learning(self.population[i])\n                    opposite_fitness = func(opposite_individual)\n                    evaluations += 1\n                    if opposite_fitness < fitness:\n                        self.population[i] = opposite_individual\n        return self.best_individual", "name": "HybridSCA_SA_OBL", "description": "A novel metaheuristic algorithm called \"Hybrid Sine Cosine Algorithm with Levy Flight, Simulated Annealing, and Opposition-Based Learning\" that combines the exploration capabilities of sine cosine algorithm with the exploitation capabilities of simulated annealing, the long-range search of Levy flight, and the opposition-based learning to efficiently optimize black box functions.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "28e97af1-cead-4780-ae26-ac0e985811d6", "metadata": {}, "mutation_prompt": null}
{"id": "9a74920b-f12b-46c8-90bf-061b1ec09087", "solution": "import numpy as np\n\nclass HybridSCA_SA_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.best_fitness = np.inf\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def levy_flight(self, individual):\n        levy_flight = np.random.normal(0, 1, self.dim) / np.random.normal(0, 1, self.dim)\n        levy_flight = individual + levy_flight\n        return levy_flight\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_individual = self.population[i]\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                r3 = np.random.uniform(0, 1, self.dim)\n                r4 = np.random.uniform(0, 1, self.dim)\n                A = 2 * r1 - 1\n                B = np.abs(r2)\n                C = 2 * r3 - 1\n                D = np.abs(r4)\n                sine = np.abs(self.best_individual - self.population[i]) * np.sin(np.abs(r1) * np.pi)\n                cosine = np.abs(self.best_individual - self.population[i]) * np.cos(np.abs(r1) * np.pi)\n                if np.random.uniform(0, 1) < 0.5:\n                    self.population[i] = self.best_individual - (A * sine + B * cosine) * C * D\n                else:\n                    self.population[i] = self.best_individual + (A * sine + B * cosine) * C * D\n                levy_flight = self.levy_flight(self.population[i])\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                # Apply opposition-based learning with a probability of 0.2\n                if np.random.uniform(0, 1) < 0.2:\n                    opposite_individual = self.opposition_based_learning(self.population[i])\n                    opposite_fitness = func(opposite_individual)\n                    evaluations += 1\n                    if opposite_fitness < fitness:\n                        self.population[i] = opposite_individual\n        return self.best_individual", "name": "HybridSCA_SA_OBL", "description": "A novel metaheuristic algorithm called \"Hybrid Sine Cosine Algorithm with Levy Flight, Simulated Annealing, and Opposition-Based Learning\" that combines the exploration capabilities of sine cosine algorithm with the exploitation capabilities of simulated annealing, the long-range search of Levy flight, and the opposition-based learning to efficiently optimize black box functions.", "configspace": "", "generation": 8, "fitness": 0.1390544373836832, "feedback": "The algorithm HybridSCA_SA_OBL got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.19.", "error": "", "parent_id": "28e97af1-cead-4780-ae26-ac0e985811d6", "metadata": {"aucs": [0.23022302283963236, 0.23701190229060143, 0.22516504494048972, 0.1723017914054622, 0.24344670125955403, 0.24153639325737564, 0.2431587551982275, 0.17411818371632348, 0.17809294574400703, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11286068613022182, 0.051590694036729445, 0.03657520452247043, 0.06861941961376128, 0.07249345140976382, 0.06880887756130283, 0.0753195961037636, 0.08061014371290953, 0.08278058620580431, 0.054765953785779864, 0.060026091093295486, 0.04480033666595884, 0.07124646794021883, 0.05289208701191639, 0.054803511521574144, 0.061983998278962504, 0.07030862124330539, 0.03187436905806185, 0.982674938787074, 0.968860120201735, 0.9673980553283434, 0.964818042136243, 0.9793131862582104, 0.9614312717485037, 0.9706851772471167, 0.9726531651932794, 0.9881735162334772, 0.14126923572212546, 0.12072768712171711, 0.12379826615196421, 0.13387371731149345, 0.18994223077036354, 0.13697253863412062, 0.1160839409027794, 0.12487458834666709, 0.16343889006797419, 0.15001457282382158, 0.1308937419925118, 0.12378307906368846, 0.16644546779161606, 0.20894789297150562, 0.11354440013157796, 0.1036617245717305, 0.09581324179972706, 0.1731635219467047, 0.0810915844531348, 0.03042630367311905, 0.06692275035324036, 0.012262539713687848, 0.02912013589741924, 0.03021208736880432, 0.08521811604783869, 0.06420298968870808, 0.05995723563885946, 0.06561830477773778, 0.039104094492970365, 0.07270048588091171, 0.11403132171284502, 0.0984960504076704, 0.13373626865855637, 0.061807351485197226, 0.04295857411391679, 0.09082159432980474, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08819494744930922, 0.036426843688804555, 0.06403695377155749, 0.07775418180277505, 0.008820998048377104, 0.023192962422784014, 0.11731645252844969, 0.04742889877883916, 0.0011804914435575853, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02879371811444309, 0.04762192111855945, 0.029679186428307358, 0.020247859926271095, 0.05620859175138593, 0.008478837007231177, 0.016051035692239424, 0.013632522290225824, 0.035426768057529645, 0.24050519667814452, 0.23427985662547357, 0.2106798219599394, 0.15467560162454375, 0.17408064532740342, 0.25289746938560453, 0.16101246843450956, 0.23679039812455638, 0.24128525352225294, 0.05697205624966173, 0.04159657446878662, 0.07074150733477158, 0.05519469232089502, 0.025556583738816196, 0.06376378448042619, 0.05831859588990884, 0.07777905948211661, 0.09037113816808362, 0.14189895256434504, 0.15452899102405737, 0.13079398629733874, 0.09852463226307118, 0.11796494502675703, 0.11010629849423748, 0.12080224822707819, 0.12208444958274212, 0.1069088708339645, 0.14839629284814837, 0.18138659167363436, 0.2042863865770974, 0.13795634204355134, 0.21741722209664505, 0.17523416639253842, 0.20700062931350371, 0.17364681342433885, 0.16088514717061642, 0.1269272356739931, 0.07419930929865237, 0.13832174392679664, 0.10761814907729095, 0.13720593404887027, 0.17560408796070404, 0.116910882914668, 0.15051684294626755, 0.16569254507046738, 0.17101023288763262, 0.159675669889914, 0.1489692148302083, 0.20625784661749325, 0.20384009965771077, 0.13223239066783066, 0.14060249334440156, 0.18724692990051994, 0.18780569720956286, 0.17535795129646958, 0.16448573101834696, 0.17061569107796526, 0.18585864129355878, 0.19359355861211047, 0.19264629233559538, 0.18006139133962096, 0.16016099870498635, 0.17236398991662316, 0.11057346810336877, 0.14743257693741985, 0.11142296314636391, 0.12144331093684746, 0.12076337156869488, 0.14567830039062613, 0.1129958366413486, 0.10500081898637759, 0.1653577149605886, 0.20337748578744952, 0.10254810954180682, 0.09573236243800143, 0.13242722609047564, 0.11574314658455709, 0.16673597785734018, 0.09808009030730136, 0.08307854471762222, 0.06104304137766903, 0.14347899652791052, 0.16891862277251402, 0.17412961411304273, 0.15870431254302841, 0.16880121381917434, 0.17526027124193477, 0.15898697956827967, 0.1708752248319637, 0.17882696533114562, 0.058238911394085324, 0.06255502976071825, 0.07249794578277213, 0.06599071277325952, 0.06605464329386157, 0.06731625396390795, 0.05845329024050827, 0.059806879418841885, 0.07277103311832778]}, "mutation_prompt": null}
{"id": "d219a4fb-ec3e-40f0-8847-917c40ab326c", "solution": "import numpy as np\n\nclass HybridSCA_SA_COBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.best_fitness = np.inf\n        self.chaotic_map = np.random.uniform(0, 1, self.dim)\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def chaotic_opposition_based_learning(self, individual):\n        chaotic_individual = self.lower_bound + (self.upper_bound - self.lower_bound) * self.chaotic_map\n        self.chaotic_map = 4 * self.chaotic_map * (1 - self.chaotic_map)\n        return chaotic_individual\n\n    def levy_flight(self, individual):\n        levy_flight = np.random.normal(0, 1, self.dim) / np.random.normal(0, 1, self.dim)\n        levy_flight = individual + levy_flight\n        return levy_flight\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_individual = self.population[i]\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                r3 = np.random.uniform(0, 1, self.dim)\n                r4 = np.random.uniform(0, 1, self.dim)\n                A = 2 * r1 - 1\n                B = np.abs(r2)\n                C = 2 * r3 - 1\n                D = np.abs(r4)\n                sine = np.abs(self.best_individual - self.population[i]) * np.sin(np.abs(r1) * np.pi)\n                cosine = np.abs(self.best_individual - self.population[i]) * np.cos(np.abs(r1) * np.pi)\n                if np.random.uniform(0, 1) < 0.5:\n                    self.population[i] = self.best_individual - (A * sine + B * cosine) * C * D\n                else:\n                    self.population[i] = self.best_individual + (A * sine + B * cosine) * C * D\n                levy_flight = self.levy_flight(self.population[i])\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                # Apply chaotic opposition-based learning with a probability of 0.2\n                if np.random.uniform(0, 1) < 0.2:\n                    chaotic_individual = self.chaotic_opposition_based_learning(self.population[i])\n                    chaotic_fitness = func(chaotic_individual)\n                    evaluations += 1\n                    if chaotic_fitness < fitness:\n                        self.population[i] = chaotic_individual\n        return self.best_individual", "name": "HybridSCA_SA_COBL", "description": "A novel metaheuristic algorithm called \"Hybrid Sine Cosine Algorithm with Levy Flight, Simulated Annealing, and Chaotic Opposition-Based Learning\" that combines the exploration capabilities of sine cosine algorithm with the exploitation capabilities of simulated annealing, the long-range search of Levy flight, and the chaotic opposition-based learning to efficiently optimize black box functions.", "configspace": "", "generation": 9, "fitness": 0.14729597899624586, "feedback": "The algorithm HybridSCA_SA_COBL got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.19.", "error": "", "parent_id": "9a74920b-f12b-46c8-90bf-061b1ec09087", "metadata": {"aucs": [0.26520552433174993, 0.2298131926950826, 0.28590040310353804, 0.25325904039675784, 0.20765398190698114, 0.19705464046671717, 0.2351661724626859, 0.261033952418799, 0.18772088970396683, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07137618362802789, 0.095847504208464, 0.074301494787688, 0.05430299184339715, 0.06950733677232113, 0.053268728195024595, 0.09293878944032097, 0.07260123447119371, 0.08624586802871725, 0.10200919221647287, 0.04438507192843355, 0.04670375429963114, 0.08913866149028704, 0.05056572798347747, 0.0423686451933023, 0.10213458933031616, 0.049658673995923164, 0.07796462417691963, 0.9788850735408443, 0.9721563960117282, 0.9800667663093168, 0.960148877377201, 0.9418668256806481, 0.9852389187115778, 0.985958200360827, 0.9772666087450941, 0.9861084299652423, 0.17692549238083977, 0.12711265881663436, 0.13054743042139694, 0.13736509148164455, 0.14003315684640893, 0.06585146345338422, 0.1139965245693978, 0.16458579425982733, 0.12030048096922197, 0.10021571555565112, 0.211139168251963, 0.09824738448928783, 0.2291814375782878, 0.20849008766754762, 0.22756542895492538, 0.13059462667655586, 0.13322780392884304, 0.09408710161357758, 0.02846647709051342, 0.036339131745279474, 0.07282206939806657, 0.06839997531725261, 0.08642425203832083, 0.07622579009121677, 0.08570030322917832, 0.06360959517436493, 0.04097426588491104, 0.08231491813020297, 0.026520635641776202, 0.08720338261797567, 0.0596244961378094, 0.06804648801629287, 0.0722411024045676, 0.07881923393847134, 9.999999999998899e-05, 0.05539608931687967, 9.999999999998899e-05, 9.999999999998899e-05, 0.016915217469260835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0624900417340537, 0.02522038515100833, 0.06428684638568105, 0.062462782491987445, 0.008531988813096136, 0.023136523522543362, 0.15144359526732365, 0.05235733547756505, 0.04782436715797789, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.029155088907883542, 0.037381457860747314, 0.029672897168215417, 0.02348536057499695, 0.003927706915668794, 0.015828642851943187, 0.03389647865766332, 0.009954989003105985, 0.02464859204065417, 0.22956704416088136, 0.3041379663029322, 0.2391635114659445, 0.21972776033653785, 0.26812999082545697, 0.19494137881452778, 0.3455415795615492, 0.3027784068344025, 0.23647199886561987, 0.06684254410623747, 0.06759731034321104, 0.11112189846241904, 0.054376136244942974, 0.07335482546620697, 0.049217510497270855, 0.07784141682633128, 0.031951856095042586, 0.05920975861851274, 0.14204919946653827, 0.14832937681544045, 0.14456000551618597, 0.153726840200352, 0.17324372765620133, 0.13181270896756947, 0.17562342976750278, 0.19261464685838348, 0.139215013678184, 0.19884185179515812, 0.19195711626246414, 0.16422628631122593, 0.16181023912717407, 0.17327130873491392, 0.17579607284925391, 0.20747369479743638, 0.17365171347949038, 0.16985816821455013, 0.10328037902156229, 0.11868244781111403, 0.11719316808482727, 0.09737011571891285, 0.13035023103985988, 0.1427507110217362, 0.08579084039857243, 0.11091479898734047, 0.15567511075973928, 0.15538497440876597, 0.1615557708601122, 0.16489730039174044, 0.1483017212661938, 0.16609478900982666, 0.11520181396618212, 0.14398858377318136, 0.15884187988103027, 0.157622027153678, 0.16440654889285033, 0.18401155039148487, 0.18566679293277566, 0.18589641047039362, 0.16429364101607968, 0.1690030423423896, 0.1885779215804625, 0.1702264291381882, 0.18120886987845175, 0.1564089906405416, 0.17366719058292224, 0.2146313646702267, 0.16891153238425305, 0.15507362060275243, 0.18217966686599163, 0.14603580180620268, 0.16150956638194547, 0.14816688638810394, 0.172410897463652, 0.10256794198586117, 0.2596961237348989, 0.16523085663223136, 0.11726877637450239, 0.24394477697531713, 0.1356645892820152, 0.13537966920552558, 0.10860679768277237, 0.19051649185637665, 0.19444128119098525, 0.16921239716409386, 0.2094602002405499, 0.1720136202092255, 0.2375327908635979, 0.1654047110589112, 0.18879334487308774, 0.1719603342845154, 0.057613772529714335, 0.0741521326392438, 0.09847216109530288, 0.06705546455869404, 0.07280711266188589, 0.06974004662841038, 0.05797469997177851, 0.044087229638316794, 0.06037813982266471]}, "mutation_prompt": null}
{"id": "e3445107-8db4-4467-a1cb-96ecd2aaead1", "solution": "import numpy as np\n\nclass HybridSCA_SA_ACOBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.best_fitness = np.inf\n        self.chaotic_map = np.random.uniform(0, 1, self.dim)\n        self.adaptive_prob = 0.2\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def chaotic_opposition_based_learning(self, individual):\n        chaotic_individual = self.lower_bound + (self.upper_bound - self.lower_bound) * self.chaotic_map\n        self.chaotic_map = 4 * self.chaotic_map * (1 - self.chaotic_map)\n        return chaotic_individual\n\n    def levy_flight(self, individual):\n        levy_flight = np.random.normal(0, 1, self.dim) / np.random.normal(0, 1, self.dim)\n        levy_flight = individual + levy_flight\n        return levy_flight\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_individual = self.population[i]\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                r3 = np.random.uniform(0, 1, self.dim)\n                r4 = np.random.uniform(0, 1, self.dim)\n                A = 2 * r1 - 1\n                B = np.abs(r2)\n                C = 2 * r3 - 1\n                D = np.abs(r4)\n                sine = np.abs(self.best_individual - self.population[i]) * np.sin(np.abs(r1) * np.pi)\n                cosine = np.abs(self.best_individual - self.population[i]) * np.cos(np.abs(r1) * np.pi)\n                if np.random.uniform(0, 1) < 0.5:\n                    self.population[i] = self.best_individual - (A * sine + B * cosine) * C * D\n                else:\n                    self.population[i] = self.best_individual + (A * sine + B * cosine) * C * D\n                levy_flight = self.levy_flight(self.population[i])\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                # Apply adaptive chaotic opposition-based learning with a probability that adapts to the convergence speed\n                if np.random.uniform(0, 1) < self.adaptive_prob:\n                    chaotic_individual = self.chaotic_opposition_based_learning(self.population[i])\n                    chaotic_fitness = func(chaotic_individual)\n                    evaluations += 1\n                    if chaotic_fitness < fitness:\n                        self.population[i] = chaotic_individual\n                        self.adaptive_prob *= 1.1  # Increase the probability if the chaotic opposition-based learning improves the fitness\n                    else:\n                        self.adaptive_prob *= 0.9  # Decrease the probability if the chaotic opposition-based learning does not improve the fitness\n                    self.adaptive_prob = np.clip(self.adaptive_prob, 0.1, 0.9)  # Clip the probability to a reasonable range\n        return self.best_individual", "name": "HybridSCA_SA_ACOBL", "description": "A novel metaheuristic algorithm called \"Hybrid Sine Cosine Algorithm with Levy Flight, Simulated Annealing, and Adaptive Chaotic Opposition-Based Learning\" that combines the exploration capabilities of sine cosine algorithm with the exploitation capabilities of simulated annealing, the long-range search of Levy flight, and the adaptive chaotic opposition-based learning to efficiently optimize black box functions.", "configspace": "", "generation": 10, "fitness": 0.14856813564922883, "feedback": "The algorithm HybridSCA_SA_ACOBL got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.19.", "error": "", "parent_id": "d219a4fb-ec3e-40f0-8847-917c40ab326c", "metadata": {"aucs": [0.1869616016086555, 0.24912034108824144, 0.23129897097195629, 0.21241215835551774, 0.2115761784894713, 0.22574899919695213, 0.2196893973722387, 0.26429403434503373, 0.23090379343631307, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07317416738781635, 0.0987224399176494, 0.07446585193885624, 0.06962572843890125, 0.06441161172626086, 0.05352806501148022, 0.1076099314887129, 0.07454044860701958, 0.059646007849994964, 0.11326615606685042, 0.061318094438655546, 0.052303263468300054, 0.051218694321274794, 0.05132928661314651, 0.04516847614787567, 0.10245675890912842, 0.06011509823667438, 0.08056179593054369, 0.9795688053534114, 0.9726872816979861, 0.980293676576337, 0.9613666888570547, 0.9633792450110051, 0.9852389187115778, 0.986227237365996, 0.9776121686476983, 0.9861934696527943, 0.1771707232950166, 0.12849290731952367, 0.12537934883741364, 0.13902938733714876, 0.13357009036604284, 0.06872940927075921, 0.1450273336923965, 0.1653114084853312, 0.13624130460782324, 0.15820921420209832, 0.2135163932273869, 0.1820178455263285, 0.15111922877405026, 0.2089344392199921, 0.15615613070117507, 0.13224595808279027, 0.12274540034364878, 0.14439527433158106, 0.02859053207744422, 0.05372615706456618, 0.08239616426700469, 0.005816164844980487, 0.08543630863165563, 0.07808235038688216, 0.09710976240566815, 0.07972621920893874, 0.06250948207306539, 0.08453733635424154, 0.015254216346578087, 0.08279009904799894, 0.07835118221886184, 0.06864195380966176, 0.07238961353490736, 0.09410364074424471, 9.999999999998899e-05, 0.05553074032597782, 9.999999999998899e-05, 9.999999999998899e-05, 0.012562914334909858, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0625686462654721, 0.02306417022009588, 0.06428658379901409, 0.07791090582940363, 0.008865127947108697, 0.02321045620510198, 0.15815254675064339, 0.053208223730838666, 0.04803841193271641, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012154953158589166, 0.04687462466113068, 0.02975629546703984, 0.01678966707201235, 0.017153091433788403, 0.03681693602036118, 0.034799425301273224, 0.011562212283829254, 0.004955489788208034, 0.2296646566512649, 0.23402200374920779, 0.24516548306660257, 0.27493466667002997, 0.31191066429552106, 0.204827370997837, 0.20140984155861907, 0.22284687077190846, 0.25694146868964673, 0.05977000302201141, 0.06736385310898263, 0.05240810297380172, 0.03712925800864619, 0.06270446109634797, 0.07426197008962077, 0.07950727623008957, 0.05760417371177262, 0.07335793119672218, 0.12870787625866997, 0.15492420834481346, 0.15218630664194244, 0.1459875799826772, 0.16048302050362762, 0.13527363033552176, 0.16350682125764016, 0.14405205904944707, 0.13683475412685953, 0.20242582077274474, 0.18117185912924316, 0.16997313167912287, 0.16181574732295445, 0.16147300669340492, 0.25857586862100257, 0.1691662816492222, 0.18798058448779298, 0.204234694431761, 0.11693377232024105, 0.11783206048163009, 0.1283232240995552, 0.13219268757867808, 0.11326445196231094, 0.1376299197694114, 0.14687975358197125, 0.130599585508834, 0.16059694831594773, 0.16347091173647, 0.1615785177964344, 0.15918195140630775, 0.1736446208799718, 0.16801033096320828, 0.18594910937775444, 0.12245976138762271, 0.16465224751074925, 0.1955897674447422, 0.17561527277488354, 0.18411029997660489, 0.18575838080846174, 0.18601355015157817, 0.17973249238405586, 0.17049072064015058, 0.17758915491397187, 0.17062494360179536, 0.18135631368607985, 0.2678712609639662, 0.12051114253911432, 0.15592139700316476, 0.1337389458608753, 0.1609164196049484, 0.1523238726633992, 0.15689891882874396, 0.14769509098161815, 0.126053924889311, 0.23965547514729446, 0.2339789450213674, 0.11399238989994176, 0.15735628047835404, 0.1562660606833024, 0.10365750649420713, 0.2249820905401484, 0.13859935327171258, 0.15178981434256567, 0.1933216255582545, 0.20330290064362022, 0.182033888000255, 0.21332236981614328, 0.1714812478277381, 0.19464779421395817, 0.25873756429384953, 0.2107836923723273, 0.16248085779604948, 0.0565483656192135, 0.0715749314160814, 0.06261079365109368, 0.07652703674250971, 0.07288473746270863, 0.07387427176885852, 0.07097368170515705, 0.07969291850475835, 0.062276428988216836]}, "mutation_prompt": null}
{"id": "d18ab196-4856-45c3-99d4-3fe65f64dfc7", "solution": "import numpy as np\n\nclass HybridSCA_SA_ACOBL_GM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.best_fitness = np.inf\n        self.chaotic_map = np.random.uniform(0, 1, self.dim)\n        self.adaptive_prob = 0.2\n        self.mutation_prob = 0.1\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def chaotic_opposition_based_learning(self, individual):\n        chaotic_individual = self.lower_bound + (self.upper_bound - self.lower_bound) * self.chaotic_map\n        self.chaotic_map = 4 * self.chaotic_map * (1 - self.chaotic_map)\n        return chaotic_individual\n\n    def levy_flight(self, individual):\n        levy_flight = np.random.normal(0, 1, self.dim) / np.random.normal(0, 1, self.dim)\n        levy_flight = individual + levy_flight\n        return levy_flight\n\n    def gaussian_mutation(self, individual):\n        gaussian_mutation = individual + np.random.normal(0, 0.1, self.dim)\n        return gaussian_mutation\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_individual = self.population[i]\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                r3 = np.random.uniform(0, 1, self.dim)\n                r4 = np.random.uniform(0, 1, self.dim)\n                A = 2 * r1 - 1\n                B = np.abs(r2)\n                C = 2 * r3 - 1\n                D = np.abs(r4)\n                sine = np.abs(self.best_individual - self.population[i]) * np.sin(np.abs(r1) * np.pi)\n                cosine = np.abs(self.best_individual - self.population[i]) * np.cos(np.abs(r1) * np.pi)\n                if np.random.uniform(0, 1) < 0.5:\n                    self.population[i] = self.best_individual - (A * sine + B * cosine) * C * D\n                else:\n                    self.population[i] = self.best_individual + (A * sine + B * cosine) * C * D\n                levy_flight = self.levy_flight(self.population[i])\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                # Apply adaptive chaotic opposition-based learning with a probability that adapts to the convergence speed\n                if np.random.uniform(0, 1) < self.adaptive_prob:\n                    chaotic_individual = self.chaotic_opposition_based_learning(self.population[i])\n                    chaotic_fitness = func(chaotic_individual)\n                    evaluations += 1\n                    if chaotic_fitness < fitness:\n                        self.population[i] = chaotic_individual\n                        self.adaptive_prob *= 1.1  # Increase the probability if the chaotic opposition-based learning improves the fitness\n                    else:\n                        self.adaptive_prob *= 0.9  # Decrease the probability if the chaotic opposition-based learning does not improve the fitness\n                    self.adaptive_prob = np.clip(self.adaptive_prob, 0.1, 0.9)  # Clip the probability to a reasonable range\n                # Apply Gaussian mutation with a fixed probability\n                if np.random.uniform(0, 1) < self.mutation_prob:\n                    gaussian_individual = self.gaussian_mutation(self.population[i])\n                    gaussian_fitness = func(gaussian_individual)\n                    evaluations += 1\n                    if gaussian_fitness < fitness:\n                        self.population[i] = gaussian_individual\n        return self.best_individual", "name": "HybridSCA_SA_ACOBL_GM", "description": "A novel metaheuristic algorithm called \"Hybrid Sine Cosine Algorithm with Levy Flight, Simulated Annealing, Adaptive Chaotic Opposition-Based Learning, and Gaussian Mutation\" that combines the exploration capabilities of sine cosine algorithm with the exploitation capabilities of simulated annealing, the long-range search of Levy flight, the adaptive chaotic opposition-based learning, and the Gaussian mutation to efficiently optimize black box functions.", "configspace": "", "generation": 11, "fitness": 0.1685735060107666, "feedback": "The algorithm HybridSCA_SA_ACOBL_GM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.19.", "error": "", "parent_id": "e3445107-8db4-4467-a1cb-96ecd2aaead1", "metadata": {"aucs": [0.3082423090127593, 0.3580791101471036, 0.28780860585550416, 0.3150362675750832, 0.23372226644866345, 0.2854810422759462, 0.26616810840965177, 0.36763362108926656, 0.336756465368115, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05149971574690515, 0.058326384955730615, 0.08778848957817631, 0.10201490876244756, 0.0746374787714269, 0.07392601874277638, 0.10842273831332094, 0.11936543513130915, 0.04562404210166637, 0.05889016092074384, 0.034792553891883626, 0.06481754762300129, 0.07682587921754602, 0.07265110545847475, 0.055344717456082826, 0.11035738002805795, 0.05545664262133909, 0.054398429112113234, 0.9729131994330921, 0.9355598659651903, 0.9708255080134108, 0.9687053251327972, 0.9362541272480196, 0.8545695170871572, 0.9813512885382379, 0.9451751803830409, 0.9635114824123093, 0.062427220898117586, 0.2713448089345416, 0.19878663941129726, 0.21853696643509601, 0.1129756626599725, 0.2378802720771801, 0.2357826321496349, 0.2531961673509282, 0.21588885065580932, 0.19717624314224658, 0.15015631820238706, 0.18558139230640103, 0.15928552678002705, 0.2089824516054467, 0.14136882795050298, 0.18370402349791992, 0.2846309707431117, 0.1688686517387945, 0.10987129437646659, 0.12512664777921467, 0.15162299883630348, 0.1235735011045419, 0.11756491741317676, 0.05765014462080731, 0.11863904426872574, 0.18383837892239308, 0.1354675615897557, 0.12554284575165142, 0.0999253076997837, 0.13871353817384258, 0.11880349718782013, 0.10189779112792663, 0.12947454460559416, 0.169209113825884, 0.1786457152069859, 0.15166533102758062, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004264174261996545, 0.03381784803304122, 9.999999999998899e-05, 0.00015594583311817622, 9.999999999998899e-05, 0.001145816860257387, 0.059476800891223536, 0.09205525402253045, 0.04232191853802614, 0.07802425457109352, 0.009549956377067792, 0.0036020724496813594, 0.038839658853612846, 0.06898385718772626, 0.026843979233234894, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0064851120703666165, 9.999999999998899e-05, 0.10136658756587313, 0.0670086396672801, 0.07985817892372216, 0.09990847198283648, 0.046352163557810466, 0.07563070850221465, 9.999999999998899e-05, 0.08839257060124295, 0.06643096825216432, 0.33326744862799795, 0.33222517867559065, 0.32216163913283413, 0.38215840870032547, 0.19505468979748397, 0.31172499706849177, 0.2574407745154763, 0.2174632685010489, 0.2228784812488086, 0.04595869889549864, 0.061905784625024385, 0.0676886463013725, 0.08338020241067567, 0.08886540018471623, 0.08298578608142504, 0.06351234107303316, 0.0541680461141556, 0.04988306783014829, 0.14808929886466027, 0.14146878212355407, 0.13054599252255228, 0.211382657068654, 0.2808558680434563, 0.11774125992225526, 0.121288551937478, 0.16309123601192166, 0.13839935687585858, 0.2339474850855635, 0.1781674637799988, 0.1612120560128063, 0.1912233213320268, 0.20988297693156777, 0.22064641459197498, 0.19399058027387361, 0.18860826266620856, 0.24013903594391894, 0.17255772784900725, 0.18759218299799996, 0.1812751975490936, 0.17323788587596378, 0.12818318613031243, 0.15132457028521928, 0.22567701473163493, 0.15208529229831425, 0.19324139136283014, 0.1843003082943695, 0.12695518262820893, 0.15891059756024895, 0.18571952052656904, 0.15884019409511474, 0.15083780384163747, 0.19534469746339356, 0.1786866547707907, 0.1782979742730444, 0.18539071807659346, 0.1713916334622918, 0.16753309975670905, 0.1717891728974239, 0.18428891106846546, 0.17592817545300254, 0.18014505290780347, 0.17983043993748016, 0.17954629945453104, 0.15518710294557658, 0.1580291262975344, 0.19756484121928963, 0.19710767962574927, 0.12075796824106433, 0.20108527327334347, 0.46954806695366247, 0.157616219741175, 0.13825081212366908, 0.40080853260498206, 0.1351103771923401, 0.10564713392581038, 0.12991037992532384, 0.11262885065977135, 0.3938290898115796, 0.22684506166469753, 0.1131268368732945, 0.10886684437147565, 0.17994437674687347, 0.20052004163995085, 0.18075590458289958, 0.1695801625341955, 0.17281156887649507, 0.20165843237486591, 0.1723858786060135, 0.2032240419636241, 0.18969575356341806, 0.055900969372777776, 0.05547347687244186, 0.0674385868886711, 0.04049388586949498, 0.07213961670631974, 0.08082310129953074, 0.07900446406525319, 0.0690491558432208, 0.06718968062636799]}, "mutation_prompt": null}
{"id": "393aacf2-890b-4703-a259-810647f165d4", "solution": "import numpy as np\n\nclass HybridSCA_SA_ACOBL_GM_DPS_ALF:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.best_fitness = np.inf\n        self.chaotic_map = np.random.uniform(0, 1, self.dim)\n        self.adaptive_prob = 0.2\n        self.mutation_prob = 0.1\n        self.levy_flight_scale = 1.0\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def chaotic_opposition_based_learning(self, individual):\n        chaotic_individual = self.lower_bound + (self.upper_bound - self.lower_bound) * self.chaotic_map\n        self.chaotic_map = 4 * self.chaotic_map * (1 - self.chaotic_map)\n        return chaotic_individual\n\n    def levy_flight(self, individual):\n        levy_flight = np.random.normal(0, self.levy_flight_scale, self.dim) / np.random.normal(0, self.levy_flight_scale, self.dim)\n        levy_flight = individual + levy_flight\n        return levy_flight\n\n    def gaussian_mutation(self, individual):\n        gaussian_mutation = individual + np.random.normal(0, 0.1, self.dim)\n        return gaussian_mutation\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_individual = self.population[i]\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                r3 = np.random.uniform(0, 1, self.dim)\n                r4 = np.random.uniform(0, 1, self.dim)\n                A = 2 * r1 - 1\n                B = np.abs(r2)\n                C = 2 * r3 - 1\n                D = np.abs(r4)\n                sine = np.abs(self.best_individual - self.population[i]) * np.sin(np.abs(r1) * np.pi)\n                cosine = np.abs(self.best_individual - self.population[i]) * np.cos(np.abs(r1) * np.pi)\n                if np.random.uniform(0, 1) < 0.5:\n                    self.population[i] = self.best_individual - (A * sine + B * cosine) * C * D\n                else:\n                    self.population[i] = self.best_individual + (A * sine + B * cosine) * C * D\n                levy_flight = self.levy_flight(self.population[i])\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                    self.levy_flight_scale *= 1.1  # Increase the Levy flight scale if the Levy flight improves the fitness\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                        self.levy_flight_scale *= 0.9  # Decrease the Levy flight scale if the Levy flight does not improve the fitness\n                self.levy_flight_scale = np.clip(self.levy_flight_scale, 0.1, 10.0)  # Clip the Levy flight scale to a reasonable range\n                # Apply adaptive chaotic opposition-based learning with a probability that adapts to the convergence speed\n                if np.random.uniform(0, 1) < self.adaptive_prob:\n                    chaotic_individual = self.chaotic_opposition_based_learning(self.population[i])\n                    chaotic_fitness = func(chaotic_individual)\n                    evaluations += 1\n                    if chaotic_fitness < fitness:\n                        self.population[i] = chaotic_individual\n                        self.adaptive_prob *= 1.1  # Increase the probability if the chaotic opposition-based learning improves the fitness\n                    else:\n                        self.adaptive_prob *= 0.9  # Decrease the probability if the chaotic opposition-based learning does not improve the fitness\n                    self.adaptive_prob = np.clip(self.adaptive_prob, 0.1, 0.9)  # Clip the probability to a reasonable range\n                # Apply Gaussian mutation with a fixed probability\n                if np.random.uniform(0, 1) < self.mutation_prob:\n                    gaussian_individual = self.gaussian_mutation(self.population[i])\n                    gaussian_fitness = func(gaussian_individual)\n                    evaluations += 1\n                    if gaussian_fitness < fitness:\n                        self.population[i] = gaussian_individual\n            # Dynamically adjust the population size based on the convergence speed\n            if evaluations > self.budget / 2 and self.population_size < self.initial_population_size * 2:\n                self.population_size *= 2\n                self.population = np.vstack((self.population, np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size // 2, self.dim))))\n        return self.best_individual", "name": "HybridSCA_SA_ACOBL_GM_DPS_ALF", "description": "A novel metaheuristic algorithm called \"Hybrid Sine Cosine Algorithm with Levy Flight, Simulated Annealing, Adaptive Chaotic Opposition-Based Learning, and Gaussian Mutation with Dynamic Population Size and Adaptive Levy Flight\" that combines the exploration capabilities of sine cosine algorithm with the exploitation capabilities of simulated annealing, the long-range search of Levy flight, the adaptive chaotic opposition-based learning, and the Gaussian mutation to efficiently optimize black box functions, with a dynamic population size and an adaptive Levy flight to improve the convergence speed.", "configspace": "", "generation": 12, "fitness": 0.17159014056414476, "feedback": "The algorithm HybridSCA_SA_ACOBL_GM_DPS_ALF got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.19.", "error": "", "parent_id": "d18ab196-4856-45c3-99d4-3fe65f64dfc7", "metadata": {"aucs": [0.3186694723140636, 0.3820781783103522, 0.28810475159550575, 0.31415964694112886, 0.20292007479462892, 0.2767308659242944, 0.29082040807787135, 0.3842496674176836, 0.3523103898909282, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007964820746105605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07539503491668909, 0.05914927594934383, 0.09622197091685414, 0.10469854831717385, 0.0745676913563893, 0.07426222030335539, 0.1127362386410441, 0.12091024612739654, 0.04167804409298026, 0.06151719268234068, 0.034792553891883626, 0.06596954941025379, 0.07850572760700669, 0.0732440644365131, 0.05592768552866001, 0.11413532920745662, 0.056619604663185386, 0.040006174926300986, 0.9729131994330921, 0.9355598659651903, 0.9708255080134108, 0.9687053251327972, 0.9362541272480196, 0.8545695170871572, 0.9813512885382379, 0.9451751803830409, 0.9635114824123093, 0.10483679904386756, 0.27765465124739785, 0.18823091090991795, 0.18706972742929395, 0.07109797685381891, 0.24830858509719678, 0.2374997138935161, 0.25329829792404235, 0.1967947727755338, 0.19814654127044218, 0.15058883339342488, 0.16887889334792272, 0.1547776491117373, 0.21222731231023628, 0.12719129650830963, 0.12338682535306145, 0.2846309707431117, 0.1679850903177279, 0.1107959142512478, 0.12458134902598683, 0.15521371660373184, 0.13127347307182702, 0.11849892991255584, 0.06023822326092598, 0.11901339012678747, 0.20980720540647357, 0.13571481511319594, 0.12699173921280638, 0.10358844358060382, 0.14271546811355418, 0.12056856758484247, 0.10359897446835054, 0.1282320050061877, 0.17322734871622592, 0.17958483657939173, 0.14995699527311013, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007600961126526085, 0.03394758949782917, 9.999999999998899e-05, 0.002141335189951521, 9.999999999998899e-05, 0.0012235782653501337, 0.059499450250249386, 0.09220281669693176, 0.04265088425430241, 0.06993976967434279, 0.0027620665903917985, 0.03456706808261911, 0.0309613937162192, 0.06897684924265013, 0.026629373410131718, 9.999999999998899e-05, 9.999999999998899e-05, 0.011453562500868375, 9.999999999998899e-05, 0.044927073479124724, 0.030351265048468634, 9.999999999998899e-05, 9.999999999998899e-05, 0.01864575527923895, 0.10757864289318964, 0.0731955745917463, 0.08384269444676251, 0.10279361453884162, 0.04719308439121761, 0.11777199312377085, 9.999999999998899e-05, 0.10805357930340165, 0.06762036973174712, 0.3344224442178946, 0.3488404809865967, 0.3227162118488368, 0.39194839035677864, 0.2514205127841641, 0.32723705315536955, 0.2733191399308187, 0.25612563698578417, 0.2228784812488086, 0.029635626923513736, 0.062431679211848334, 0.06802181441761967, 0.08601448945883405, 0.08973718903671268, 0.08298578608142504, 0.06507495644856975, 0.05422749871705035, 0.05697253580135242, 0.1494919275563641, 0.15120899375598584, 0.13169413169819322, 0.21173431003092702, 0.30569343168298824, 0.1280268578923759, 0.12129159436251646, 0.16490761512708718, 0.1395924337566885, 0.22402997757343024, 0.1783873507485707, 0.1612120560128063, 0.1912233213320268, 0.21347672624063707, 0.20990688043261174, 0.1925946491403644, 0.18068566612085102, 0.24111975213387482, 0.1688803464593056, 0.18794005276292314, 0.18365298654592332, 0.17341626200727056, 0.13286866612408665, 0.16043015523994741, 0.23101445465721038, 0.15365026907016432, 0.19492895890432882, 0.18433926919424093, 0.12593944371169197, 0.18022914361806175, 0.20333306398008855, 0.15854026074474536, 0.15470781189550853, 0.1839002064012667, 0.16514349817336949, 0.17764646040227616, 0.18552665841903027, 0.17176321801098515, 0.16802123271336344, 0.17850121429156174, 0.18428891106846546, 0.17618418020371318, 0.1791832778709015, 0.17904222139450265, 0.18039171479945815, 0.1569706289032089, 0.1580435935488902, 0.19602467469013152, 0.19716094801542627, 0.12075796824106433, 0.2010061672602126, 0.47886777395951574, 0.15683499553139102, 0.13828222528233003, 0.40097787522213724, 0.14315617136494652, 0.10560829367397806, 0.13139073024583237, 0.11397913395990567, 0.4111774793592359, 0.22013957895405478, 0.2551355275407302, 0.13727232823609337, 0.17781275389193563, 0.2013097634403893, 0.18158735557869998, 0.1740086072742132, 0.17432519095901589, 0.20206548485670328, 0.1723858786060135, 0.21705691186365095, 0.19010681080825675, 0.07055748395819805, 0.05247541518763488, 0.057952897842227125, 0.036395170244572395, 0.07213961670631974, 0.08082310129953074, 0.07974020722455966, 0.06960823833590002, 0.06473432654880795]}, "mutation_prompt": null}
{"id": "868d7518-9d5e-4d0b-952f-4949a2966e1d", "solution": "import numpy as np\n\nclass HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.best_fitness = np.inf\n        self.chaotic_map = np.random.uniform(0, 1, self.dim)\n        self.adaptive_prob = 0.2\n        self.mutation_prob = 0.1\n        self.levy_flight_scale = 1.0\n        self.convergence_speed = 0.0\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def chaotic_opposition_based_learning(self, individual):\n        chaotic_individual = self.lower_bound + (self.upper_bound - self.lower_bound) * self.chaotic_map\n        self.chaotic_map = 4 * self.chaotic_map * (1 - self.chaotic_map)\n        return chaotic_individual\n\n    def levy_flight(self, individual):\n        levy_flight = np.random.normal(0, self.levy_flight_scale, self.dim) / np.random.normal(0, self.levy_flight_scale, self.dim)\n        levy_flight = individual + levy_flight\n        return levy_flight\n\n    def gaussian_mutation(self, individual):\n        gaussian_mutation = individual + np.random.normal(0, 0.1, self.dim)\n        return gaussian_mutation\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_individual = self.population[i]\n                    self.convergence_speed = 1.0 - (evaluations / self.budget)\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                r3 = np.random.uniform(0, 1, self.dim)\n                r4 = np.random.uniform(0, 1, self.dim)\n                A = 2 * r1 - 1\n                B = np.abs(r2)\n                C = 2 * r3 - 1\n                D = np.abs(r4)\n                sine = np.abs(self.best_individual - self.population[i]) * np.sin(np.abs(r1) * np.pi)\n                cosine = np.abs(self.best_individual - self.population[i]) * np.cos(np.abs(r1) * np.pi)\n                if np.random.uniform(0, 1) < 0.5:\n                    self.population[i] = self.best_individual - (A * sine + B * cosine) * C * D\n                else:\n                    self.population[i] = self.best_individual + (A * sine + B * cosine) * C * D\n                levy_flight = self.levy_flight(self.population[i])\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                    self.levy_flight_scale *= 1.1  # Increase the Levy flight scale if the Levy flight improves the fitness\n                    self.convergence_speed = 1.0 - (evaluations / self.budget)\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                        self.levy_flight_scale *= 0.9  # Decrease the Levy flight scale if the Levy flight does not improve the fitness\n                self.levy_flight_scale = np.clip(self.levy_flight_scale, 0.1, 10.0)  # Clip the Levy flight scale to a reasonable range\n                # Apply adaptive chaotic opposition-based learning with a probability that adapts to the convergence speed\n                if np.random.uniform(0, 1) < self.adaptive_prob * self.convergence_speed:\n                    chaotic_individual = self.chaotic_opposition_based_learning(self.population[i])\n                    chaotic_fitness = func(chaotic_individual)\n                    evaluations += 1\n                    if chaotic_fitness < fitness:\n                        self.population[i] = chaotic_individual\n                        self.adaptive_prob *= 1.1  # Increase the probability if the chaotic opposition-based learning improves the fitness\n                    else:\n                        self.adaptive_prob *= 0.9  # Decrease the probability if the chaotic opposition-based learning does not improve the fitness\n                    self.adaptive_prob = np.clip(self.adaptive_prob, 0.1, 0.9)  # Clip the probability to a reasonable range\n                # Apply Gaussian mutation with a fixed probability\n                if np.random.uniform(0, 1) < self.mutation_prob:\n                    gaussian_individual = self.gaussian_mutation(self.population[i])\n                    gaussian_fitness = func(gaussian_individual)\n                    evaluations += 1\n                    if gaussian_fitness < fitness:\n                        self.population[i] = gaussian_individual\n            # Dynamically adjust the population size based on the convergence speed\n            if evaluations > self.budget / 2 and self.population_size < self.initial_population_size * 2 and self.convergence_speed > 0.5:\n                self.population_size *= 2\n                self.population = np.vstack((self.population, np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size // 2, self.dim))))\n            elif evaluations > self.budget / 2 and self.population_size > self.initial_population_size and self.convergence_speed < 0.5:\n                self.population_size //= 2\n                self.population = self.population[:self.population_size]\n        return self.best_individual", "name": "HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined", "description": "A novel metaheuristic algorithm called \"Hybrid Sine Cosine Algorithm with Levy Flight, Simulated Annealing, Adaptive Chaotic Opposition-Based Learning, and Gaussian Mutation with Dynamic Population Size and Adaptive Levy Flight\" that combines the exploration capabilities of sine cosine algorithm with the exploitation capabilities of simulated annealing, the long-range search of Levy flight, the adaptive chaotic opposition-based learning, and the Gaussian mutation to efficiently optimize black box functions, with a dynamic population size and an adaptive Levy flight to improve the convergence speed, and with refined strategies to adaptively adjust the population size, Levy flight scale, and chaotic opposition-based learning probability based on the convergence speed.", "configspace": "", "generation": 13, "fitness": 0.16769315714654154, "feedback": "The algorithm HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.19.", "error": "", "parent_id": "393aacf2-890b-4703-a259-810647f165d4", "metadata": {"aucs": [0.323278257239616, 0.34579782372645496, 0.28904213125224965, 0.29861955424130393, 0.22576578496998478, 0.3644575212014406, 0.3579196035729879, 0.2329629710553922, 0.19388987971360627, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07245005839149032, 0.07402513214126649, 0.08779059146618362, 0.1020679408886257, 0.07484813652401878, 0.09165131779905933, 0.10853157566610805, 0.06933154891365045, 0.06086260634594931, 0.05892599956146294, 0.03479290778947253, 0.06481786297073144, 0.07687421523415383, 0.07272330897361967, 0.05543360434761513, 0.11035892278943793, 0.05545782132708188, 0.05485270648422158, 0.9732437299035261, 0.9356476162352485, 0.9708255080134108, 0.9687053251327972, 0.9248907805849887, 0.9648247788137918, 0.9813512885382379, 0.9455213650951189, 0.9635114824123093, 0.09838918828246535, 0.2717892812071818, 0.16255508697384358, 0.22673443754148825, 0.07678642011295289, 0.2384144420835329, 0.23739627496167015, 0.25398407255144084, 0.217360618750974, 0.19835219284475103, 0.13800175279808757, 0.18940060925851465, 0.1887022256354659, 0.2488251304068011, 0.12719129650830963, 0.10757311835124705, 0.21590339113952206, 0.16959170510480415, 0.10987756345169619, 0.12546288016216967, 0.15177481398464987, 0.12359947210555078, 0.1176060721169433, 0.05806920524196979, 0.11868669851874769, 0.18185540420332147, 0.13561341243225067, 0.12558952026856218, 0.10013022347599143, 0.13881259551544411, 0.1189532632396284, 0.10268571116344116, 0.12966955037167371, 0.16863759057153815, 0.17910630087549906, 0.14882923888205624, 0.000654874830524399, 9.999999999998899e-05, 9.999999999998899e-05, 0.004311742675954355, 0.03383700121373112, 9.999999999998899e-05, 0.00030142717106207417, 9.999999999998899e-05, 0.0011510452046117337, 0.062779953295648, 0.09208342069078901, 0.04233339722112528, 0.05090854903728037, 0.011896549838310011, 0.034784471712946075, 0.03935767399408796, 0.06910358366468539, 0.02693151195389132, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006584506213422769, 9.999999999998899e-05, 0.10136676950022572, 0.06719535368537455, 0.07997278298104915, 0.10037856282592383, 0.046448262896868764, 0.07462887512765337, 9.999999999998899e-05, 0.08845489623890301, 0.06650739710525799, 0.2692376244061161, 0.23765806291367886, 0.3884215388720087, 0.15783818252704007, 0.2607143167446033, 0.38004645051209784, 0.2695511322771774, 0.1718188156471735, 0.2228784812488086, 0.11638480890707381, 0.06194667077377092, 0.06769025524281091, 0.07519063504119927, 0.048948170727176166, 0.08298578608142504, 0.05542333175064962, 0.05423464311302417, 0.05485079200290399, 0.16141550922696224, 0.1566746870187612, 0.11820548431589117, 0.18034520660005215, 0.24369323528974063, 0.10786860428306355, 0.1468556249997004, 0.1310140386474251, 0.18436375990431686, 0.17557302623946125, 0.15425023635123092, 0.1612120560128063, 0.19114912552739038, 0.20996285609148424, 0.2424710723682032, 0.21762916957878664, 0.18057960642154047, 0.16979982937232418, 0.17075717662126533, 0.14413797259159677, 0.1894981593071955, 0.14016583133388016, 0.0668129045314676, 0.1186209113901403, 0.09632469894367879, 0.10566464956673027, 0.1932541618353213, 0.2306289108757602, 0.16202538543033207, 0.17314613330485296, 0.196417583448242, 0.16843885902066102, 0.15367828196921896, 0.16388339809614194, 0.17654481907602748, 0.1813294751668535, 0.18539309371746326, 0.17139170287304573, 0.16756585612763553, 0.1718075958102374, 0.18429278093885337, 0.17593991170114476, 0.18029739930976052, 0.1803628197441861, 0.17955421182412123, 0.15490627613524488, 0.4139207986721839, 0.17450581596614412, 0.19884298909024245, 0.1494568523747385, 0.15582496073389007, 0.14949741854812604, 0.5180887661565114, 0.17958956812677973, 0.3080980753270093, 0.1351103771923401, 0.24387196604406192, 0.19816862713364014, 0.12105414319003416, 0.14762526309917245, 0.11268236397773512, 0.43643746075077783, 0.18455647854829083, 0.21376242307995452, 0.1736629995723561, 0.16205782810084834, 0.16338954065984201, 0.22108682060550533, 0.20868504239856256, 0.17988084706910812, 0.19600004201921384, 0.1900363405921648, 0.061057412565571734, 0.07071165499463405, 0.06821801977064856, 0.036395170244572395, 0.07214214216859294, 0.08082310129953074, 0.07898898981199509, 0.0693098758394608, 0.06432295070966776]}, "mutation_prompt": null}
{"id": "3ea232b3-5f3e-4eaf-9276-a7c85d1d2cfa", "solution": "import numpy as np\n\nclass HybridSCA_SA_ACOBL_GM_DPS_ALF_OBLM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.best_fitness = np.inf\n        self.chaotic_map = np.random.uniform(0, 1, self.dim)\n        self.adaptive_prob = 0.2\n        self.mutation_prob = 0.1\n        self.levy_flight_scale = 1.0\n        self.memory = []\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def chaotic_opposition_based_learning(self, individual):\n        chaotic_individual = self.lower_bound + (self.upper_bound - self.lower_bound) * self.chaotic_map\n        self.chaotic_map = 4 * self.chaotic_map * (1 - self.chaotic_map)\n        return chaotic_individual\n\n    def levy_flight(self, individual):\n        levy_flight = np.random.normal(0, self.levy_flight_scale, self.dim) / np.random.normal(0, self.levy_flight_scale, self.dim)\n        levy_flight = individual + levy_flight\n        return levy_flight\n\n    def gaussian_mutation(self, individual):\n        gaussian_mutation = individual + np.random.normal(0, 0.1, self.dim)\n        return gaussian_mutation\n\n    def opposition_based_learning_with_memory(self, individual):\n        if len(self.memory) == 0:\n            opposite_individual = self.opposition_based_learning(individual)\n        else:\n            opposite_individual = self.memory[np.random.randint(0, len(self.memory))]\n        self.memory.append(individual)\n        if len(self.memory) > 10:\n            self.memory.pop(0)\n        return opposite_individual\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_individual = self.population[i]\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                r3 = np.random.uniform(0, 1, self.dim)\n                r4 = np.random.uniform(0, 1, self.dim)\n                A = 2 * r1 - 1\n                B = np.abs(r2)\n                C = 2 * r3 - 1\n                D = np.abs(r4)\n                sine = np.abs(self.best_individual - self.population[i]) * np.sin(np.abs(r1) * np.pi)\n                cosine = np.abs(self.best_individual - self.population[i]) * np.cos(np.abs(r1) * np.pi)\n                if np.random.uniform(0, 1) < 0.5:\n                    self.population[i] = self.best_individual - (A * sine + B * cosine) * C * D\n                else:\n                    self.population[i] = self.best_individual + (A * sine + B * cosine) * C * D\n                levy_flight = self.levy_flight(self.population[i])\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                    self.levy_flight_scale *= 1.1  # Increase the Levy flight scale if the Levy flight improves the fitness\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                        self.levy_flight_scale *= 0.9  # Decrease the Levy flight scale if the Levy flight does not improve the fitness\n                self.levy_flight_scale = np.clip(self.levy_flight_scale, 0.1, 10.0)  # Clip the Levy flight scale to a reasonable range\n                # Apply adaptive chaotic opposition-based learning with a probability that adapts to the convergence speed\n                if np.random.uniform(0, 1) < self.adaptive_prob:\n                    chaotic_individual = self.chaotic_opposition_based_learning(self.population[i])\n                    chaotic_fitness = func(chaotic_individual)\n                    evaluations += 1\n                    if chaotic_fitness < fitness:\n                        self.population[i] = chaotic_individual\n                        self.adaptive_prob *= 1.1  # Increase the probability if the chaotic opposition-based learning improves the fitness\n                    else:\n                        self.adaptive_prob *= 0.9  # Decrease the probability if the chaotic opposition-based learning does not improve the fitness\n                    self.adaptive_prob = np.clip(self.adaptive_prob, 0.1, 0.9)  # Clip the probability to a reasonable range\n                # Apply opposition-based learning with memory with a fixed probability\n                if np.random.uniform(0, 1) < 0.1:\n                    oblm_individual = self.opposition_based_learning_with_memory(self.population[i])\n                    oblm_fitness = func(oblm_individual)\n                    evaluations += 1\n                    if oblm_fitness < fitness:\n                        self.population[i] = oblm_individual\n                # Apply Gaussian mutation with a fixed probability\n                if np.random.uniform(0, 1) < self.mutation_prob:\n                    gaussian_individual = self.gaussian_mutation(self.population[i])\n                    gaussian_fitness = func(gaussian_individual)\n                    evaluations += 1\n                    if gaussian_fitness < fitness:\n                        self.population[i] = gaussian_individual\n            # Dynamically adjust the population size based on the convergence speed\n            if evaluations > self.budget / 2 and self.population_size < self.initial_population_size * 2:\n                self.population_size *= 2\n                self.population = np.vstack((self.population, np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size // 2, self.dim))))\n        return self.best_individual", "name": "HybridSCA_SA_ACOBL_GM_DPS_ALF_OBLM", "description": "A novel metaheuristic algorithm called \"Hybrid Sine Cosine Algorithm with Levy Flight, Simulated Annealing, Adaptive Chaotic Opposition-Based Learning, and Gaussian Mutation with Dynamic Population Size and Adaptive Levy Flight, and Opposition-Based Learning with Memory\" that combines the exploration capabilities of sine cosine algorithm with the exploitation capabilities of simulated annealing, the long-range search of Levy flight, the adaptive chaotic opposition-based learning, the Gaussian mutation, and the opposition-based learning with memory to efficiently optimize black box functions, with a dynamic population size and an adaptive Levy flight to improve the convergence speed.", "configspace": "", "generation": 14, "fitness": 0.16781414758906923, "feedback": "The algorithm HybridSCA_SA_ACOBL_GM_DPS_ALF_OBLM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.19.", "error": "", "parent_id": "393aacf2-890b-4703-a259-810647f165d4", "metadata": {"aucs": [0.3256445632519126, 0.3000739071066907, 0.3669709783979701, 0.36152472176359995, 0.3748789271497429, 0.3246953865899035, 0.35735387144187425, 0.18156909137788457, 0.3585131976346736, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015058748844018366, 0.06558933852371551, 0.024283032026817475, 0.11449344402861183, 0.06740287758362262, 0.07480929478522436, 0.0783704665045527, 0.07380157921416608, 0.07846108884307645, 0.11210396127542588, 0.05623931332865273, 0.06579925917371543, 0.05261018068902745, 0.08024746111401859, 0.04534495080769685, 0.04424550455354315, 0.05163448182944286, 0.05370256461613554, 0.04913239142014281, 0.9834953601653462, 0.9618876846632726, 0.9531555143137864, 0.9672009336421348, 0.9290552088996286, 0.9805858786929936, 0.9656082853361109, 0.9408398471033098, 0.9806505386598738, 0.22555011538715652, 0.26173689490151086, 0.06134453032311449, 0.20158342059386636, 0.28203944404005565, 0.20923237904429826, 0.22320069844716273, 0.30426886122103325, 0.24915992656035124, 0.21539457103404036, 0.20861257274374756, 0.0938845344235909, 0.19122550026735075, 0.13319966260328453, 0.1661890843235604, 0.15233626447035276, 0.12656629852011247, 0.14101135589092295, 0.10821510612121854, 0.1047978161434372, 0.006865490770082916, 0.11239140762137756, 0.17469805037340225, 9.999999999998899e-05, 0.1329636009845686, 0.13966746060060453, 0.11880956638789375, 0.10503057525624604, 0.08709940383993275, 0.12333398102064419, 0.1269288958513185, 0.10681168506178584, 0.11558891093384938, 0.15040049577415282, 9.999999999998899e-05, 0.1099223465063478, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009492207555806043, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05412382459229825, 0.02714508951391892, 0.07766650186759294, 0.06166392298092527, 0.006904418487087449, 0.03375796095156858, 0.08905181908910031, 0.04302368263873668, 0.044203433467045805, 9.999999999998899e-05, 0.028675599691796005, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016882897013539733, 9.999999999998899e-05, 9.999999999998899e-05, 0.0431350328291592, 0.09953950856524318, 0.10008267475817612, 0.06335277552418084, 0.0999217812228993, 0.06714807380161836, 0.09234827861912909, 0.0443413765293732, 0.04082698088705672, 0.32870663634379893, 0.25599290108072714, 0.2000336738725742, 0.20270598824143327, 0.2973351815338867, 0.29656150250767155, 0.25598073117327735, 0.23700316618701744, 0.2228784812488086, 0.07587148512375774, 0.1092128697926904, 0.07136774311400862, 0.1326223004571926, 0.04568335496741782, 0.06152232552448389, 0.06232341299780497, 0.08238444663529731, 0.05802521938712857, 0.2238921358521747, 0.22414610973799132, 0.14088868980045177, 0.23911371450874064, 0.16417778799219251, 0.14714102079278069, 0.15777714261504516, 0.1411593675165297, 0.14796830825341623, 0.21670622501739478, 0.15006872944752248, 0.16141634376366598, 0.17411404820314869, 0.18136713528001625, 0.17144209274701627, 0.18324166142048604, 0.20458882082387841, 0.19152648647258297, 0.18713484765847865, 0.09229840894579444, 0.13986085501264078, 0.1623135017028513, 0.15004037353552668, 0.08298080743089342, 0.11113877402184136, 0.20170305718752457, 0.16969625326652327, 0.17345657820164195, 0.19921900571365647, 0.17766774087357895, 0.1880786590108262, 0.21214988615796926, 0.18718094946597308, 0.1623469826287075, 0.16641725992466072, 0.1666733193493446, 0.1687301236317721, 0.16974340454278647, 0.20096015813282775, 0.195608612684385, 0.17151130436829076, 0.17001824963081058, 0.1846484007777749, 0.16960803835684235, 0.16698554879519523, 0.39680760642783264, 0.1669807954508855, 0.4015369220742553, 0.23201900550172028, 0.3131805542825272, 0.19469538447618928, 0.15654962630834868, 0.26529984268214635, 0.2313114149356491, 0.12731960890395444, 0.17835105518448313, 0.13818625468641543, 0.2179143309438939, 0.1609493871343609, 0.11597486428752402, 0.13686542251260747, 0.157162122618687, 0.39738915836817856, 0.2135360968816512, 0.17445781797330673, 0.16466608445837116, 0.17249653568654033, 0.18428748771502046, 0.1956726140691435, 0.16608084072253693, 0.2108208423623894, 0.2001003216598216, 0.06151083885617503, 0.06652172320223493, 0.05320630540016158, 0.0640932873076625, 0.07458830400953498, 0.07659041873141448, 0.06830220039745072, 0.0476525767772924, 0.08677730082451818]}, "mutation_prompt": null}
{"id": "e9d02ae1-3d99-4b43-8bac-d8c62df695e0", "solution": "import numpy as np\n\nclass HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.best_fitness = np.inf\n        self.chaotic_map = np.random.uniform(0, 1, self.dim)\n        self.adaptive_prob = 0.2\n        self.mutation_prob = 0.1\n        self.levy_flight_scale = 1.0\n        self.opposition_weight = 0.5\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def chaotic_opposition_based_learning(self, individual):\n        chaotic_individual = self.lower_bound + (self.upper_bound - self.lower_bound) * self.chaotic_map\n        self.chaotic_map = 4 * self.chaotic_map * (1 - self.chaotic_map)\n        return chaotic_individual\n\n    def levy_flight(self, individual):\n        levy_flight = np.random.normal(0, self.levy_flight_scale, self.dim) / np.random.normal(0, self.levy_flight_scale, self.dim)\n        levy_flight = individual + levy_flight\n        return levy_flight\n\n    def gaussian_mutation(self, individual):\n        gaussian_mutation = individual + np.random.normal(0, 0.1, self.dim)\n        return gaussian_mutation\n\n    def weighted_opposition_based_learning(self, individual):\n        opposite_individual = self.opposition_based_learning(individual)\n        weighted_individual = self.opposition_weight * individual + (1 - self.opposition_weight) * opposite_individual\n        return weighted_individual\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_individual = self.population[i]\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                r3 = np.random.uniform(0, 1, self.dim)\n                r4 = np.random.uniform(0, 1, self.dim)\n                A = 2 * r1 - 1\n                B = np.abs(r2)\n                C = 2 * r3 - 1\n                D = np.abs(r4)\n                sine = np.abs(self.best_individual - self.population[i]) * np.sin(np.abs(r1) * np.pi)\n                cosine = np.abs(self.best_individual - self.population[i]) * np.cos(np.abs(r1) * np.pi)\n                if np.random.uniform(0, 1) < 0.5:\n                    self.population[i] = self.best_individual - (A * sine + B * cosine) * C * D\n                else:\n                    self.population[i] = self.best_individual + (A * sine + B * cosine) * C * D\n                levy_flight = self.levy_flight(self.population[i])\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                    self.levy_flight_scale *= 1.1  # Increase the Levy flight scale if the Levy flight improves the fitness\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                        self.levy_flight_scale *= 0.9  # Decrease the Levy flight scale if the Levy flight does not improve the fitness\n                self.levy_flight_scale = np.clip(self.levy_flight_scale, 0.1, 10.0)  # Clip the Levy flight scale to a reasonable range\n                # Apply adaptive chaotic opposition-based learning with a probability that adapts to the convergence speed\n                if np.random.uniform(0, 1) < self.adaptive_prob:\n                    chaotic_individual = self.chaotic_opposition_based_learning(self.population[i])\n                    chaotic_fitness = func(chaotic_individual)\n                    evaluations += 1\n                    if chaotic_fitness < fitness:\n                        self.population[i] = chaotic_individual\n                        self.adaptive_prob *= 1.1  # Increase the probability if the chaotic opposition-based learning improves the fitness\n                    else:\n                        self.adaptive_prob *= 0.9  # Decrease the probability if the chaotic opposition-based learning does not improve the fitness\n                    self.adaptive_prob = np.clip(self.adaptive_prob, 0.1, 0.9)  # Clip the probability to a reasonable range\n                # Apply weighted opposition-based learning with a fixed probability\n                if np.random.uniform(0, 1) < 0.1:\n                    weighted_individual = self.weighted_opposition_based_learning(self.population[i])\n                    weighted_fitness = func(weighted_individual)\n                    evaluations += 1\n                    if weighted_fitness < fitness:\n                        self.population[i] = weighted_individual\n                # Apply Gaussian mutation with a fixed probability\n                if np.random.uniform(0, 1) < self.mutation_prob:\n                    gaussian_individual = self.gaussian_mutation(self.population[i])\n                    gaussian_fitness = func(gaussian_individual)\n                    evaluations += 1\n                    if gaussian_fitness < fitness:\n                        self.population[i] = gaussian_individual\n            # Dynamically adjust the population size based on the convergence speed\n            if evaluations > self.budget / 2 and self.population_size < self.initial_population_size * 2:\n                self.population_size *= 2\n                self.population = np.vstack((self.population, np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size // 2, self.dim))))\n        return self.best_individual", "name": "HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined", "description": "A novel metaheuristic algorithm called \"Hybrid Sine Cosine Algorithm with Levy Flight, Simulated Annealing, Adaptive Chaotic Opposition-Based Learning, and Gaussian Mutation with Dynamic Population Size and Adaptive Levy Flight\" that combines the exploration capabilities of sine cosine algorithm with the exploitation capabilities of simulated annealing, the long-range search of Levy flight, the adaptive chaotic opposition-based learning, and the Gaussian mutation to efficiently optimize black box functions, with a dynamic population size and an adaptive Levy flight to improve the convergence speed, and incorporates a new opposition-based learning strategy that uses a weighted average of the current individual and its opposite to generate a new individual.", "configspace": "", "generation": 15, "fitness": 0.17958535339270545, "feedback": "The algorithm HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": "393aacf2-890b-4703-a259-810647f165d4", "metadata": {"aucs": [0.30735420179905715, 0.3341544839480025, 0.3200655091442498, 0.30941139252316474, 0.29131739093750153, 0.3418125634101684, 0.20466372168425018, 0.20531347407366562, 0.41554531408369944, 0.019286238174476944, 0.011144576284099816, 9.999999999998899e-05, 0.06486374668461625, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05480224514218479, 0.05136585621030698, 0.06078910233779666, 0.04800855669903814, 0.0963025731674012, 0.04321427282975143, 0.08660294393097445, 0.06808359579236145, 0.08574526487801681, 0.050836159191755215, 0.12962538709391103, 0.08465087800870619, 0.08422697785962285, 0.057408942713101374, 0.07517569330559926, 0.12261469371868894, 0.03599453922539486, 0.06492740496398197, 0.9633880233723959, 0.9336367854163096, 0.9670381051429943, 0.9577595856878112, 0.9318507006009582, 0.9804976366954902, 0.9782939365187215, 0.9323509697589858, 0.9782930831897904, 0.2680856287729294, 0.21844698004474716, 0.22498918947143876, 0.12025294544798726, 0.23174346362956322, 0.2191502086903354, 0.1850788827476445, 0.16355250728344128, 0.22276874560979099, 0.1658628558385017, 0.17585367325353696, 0.2050781903818012, 0.199552945850902, 0.09130231456582982, 0.16700908766803624, 0.15338463730454877, 0.11323136819665958, 0.16617529412299425, 0.18603734248813153, 0.09874792152476763, 0.11929333978271683, 0.12810314770446307, 0.11705445093444344, 0.13475522327256695, 0.11750541136793669, 0.10671187281134376, 0.12280726191593838, 0.20744015239581715, 0.18470621890550054, 0.16971505611517534, 0.1794323212427995, 0.17472523983535704, 0.16658168584330413, 0.21182125954926345, 0.17959310289732477, 0.18890598241287737, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.038829373615970275, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04853856717090943, 0.026745617625547835, 0.06102222776052735, 0.06837454309945368, 0.011742682152085626, 0.00432188594809868, 0.08841393860400426, 0.014942233930978044, 0.041259347014473535, 0.011752015394429827, 9.999999999998899e-05, 0.01563969772471696, 9.999999999998899e-05, 0.013609235418828525, 0.01990340796194101, 0.037958519492635956, 9.999999999998899e-05, 9.999999999998899e-05, 0.1097860776471753, 0.02959119586544079, 0.04955843319246811, 0.0421504038784446, 0.06827886678643902, 0.10636349281464386, 0.007173504560456068, 0.052371513988973106, 0.03298220855570566, 0.3344966330082051, 0.24287221777454027, 0.33727157757043313, 0.3734611474323044, 0.3112809820392186, 0.3287769645547629, 0.31409481511913984, 0.27840963540938624, 0.24038664030194346, 0.04959595676563899, 0.12664500719089244, 0.07418595186781263, 0.0853352950973083, 0.13063016464723964, 0.08522730941742285, 0.06403412570289602, 0.06638669597234459, 0.05300162072202508, 0.18743491963234915, 0.21355045045375232, 0.22525236352730948, 0.14011341702335978, 0.17092007044353363, 0.1328345112035615, 0.1483314525018724, 0.1433743475158783, 0.12612405913775948, 0.1830797084339525, 0.25752996041732257, 0.16119474549333868, 0.20853663560591362, 0.2127016528652078, 0.22094831381801583, 0.18759677070827252, 0.2134077507138512, 0.18280380484284875, 0.10841865017473196, 0.1910966077270534, 0.11847526087001248, 0.17007929929672283, 0.1406243280738637, 0.1711069412703009, 0.14955479929864246, 0.11391996970673612, 0.11872680146348302, 0.2794556374938064, 0.27729213226884875, 0.3047458678511985, 0.2727616486901836, 0.2749349594968755, 0.2696041674597274, 0.27088564698906525, 0.28475827652081254, 0.27696485475765986, 0.18541127887281228, 0.18340398121717594, 0.17769181544109214, 0.18854280567026405, 0.1939197694591731, 0.1770162250067162, 0.16467166179571213, 0.17444292023550856, 0.1684780886808539, 0.5592669115804884, 0.18844924960756626, 0.16103521719295588, 0.12997464635513534, 0.4220638466213189, 0.49899400580020625, 0.14298118976735985, 0.15839801998004155, 0.15601633028690431, 0.20287163265417607, 0.12238391723580322, 0.24627480794848444, 0.2756296990176972, 0.17239570766490453, 0.19445740218628982, 0.21140071081566236, 0.3456951476020238, 0.18975342092291136, 0.20202610011274214, 0.16593917736745822, 0.22429690516391654, 0.18167824900640184, 0.1923612234164912, 0.2030049108859473, 0.17142405194257937, 0.21235522306961108, 0.18375361625985887, 0.07246415457692779, 0.07940506171407813, 0.06577466008380617, 0.06632509688637711, 0.07902519941602182, 0.0889708966955226, 0.06734880474832994, 0.04462688660292091, 0.05582075463104086]}, "mutation_prompt": null}
{"id": "88040778-0134-4bee-99fc-5eb79555c95d", "solution": "import numpy as np\n\nclass HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.best_fitness = np.inf\n        self.chaotic_map = np.random.uniform(0, 1, self.dim)\n        self.adaptive_prob = 0.2\n        self.mutation_prob = 0.1\n        self.levy_flight_scale = 1.0\n        self.opposition_weight = 0.5\n        self.convergence_speed = 0.0\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def chaotic_opposition_based_learning(self, individual):\n        chaotic_individual = self.lower_bound + (self.upper_bound - self.lower_bound) * self.chaotic_map\n        self.chaotic_map = 4 * self.chaotic_map * (1 - self.chaotic_map)\n        return chaotic_individual\n\n    def levy_flight(self, individual):\n        levy_flight = np.random.normal(0, self.levy_flight_scale, self.dim) / np.random.normal(0, self.levy_flight_scale, self.dim)\n        levy_flight = individual + levy_flight\n        return levy_flight\n\n    def gaussian_mutation(self, individual):\n        gaussian_mutation = individual + np.random.normal(0, 0.1, self.dim)\n        return gaussian_mutation\n\n    def weighted_opposition_based_learning(self, individual):\n        opposite_individual = self.opposition_based_learning(individual)\n        weighted_individual = self.opposition_weight * individual + (1 - self.opposition_weight) * opposite_individual\n        return weighted_individual\n\n    def adaptive_chaotic_opposition_based_learning(self, individual, fitness):\n        chaotic_individual = self.chaotic_opposition_based_learning(individual)\n        chaotic_fitness = fitness\n        if chaotic_fitness < fitness:\n            self.convergence_speed += 0.1\n            self.adaptive_prob *= 1.1\n        else:\n            self.convergence_speed -= 0.1\n            self.adaptive_prob *= 0.9\n        self.adaptive_prob = np.clip(self.adaptive_prob, 0.1, 0.9)\n        self.convergence_speed = np.clip(self.convergence_speed, -1.0, 1.0)\n        return chaotic_individual, chaotic_fitness\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_individual = self.population[i]\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                r3 = np.random.uniform(0, 1, self.dim)\n                r4 = np.random.uniform(0, 1, self.dim)\n                A = 2 * r1 - 1\n                B = np.abs(r2)\n                C = 2 * r3 - 1\n                D = np.abs(r4)\n                sine = np.abs(self.best_individual - self.population[i]) * np.sin(np.abs(r1) * np.pi)\n                cosine = np.abs(self.best_individual - self.population[i]) * np.cos(np.abs(r1) * np.pi)\n                if np.random.uniform(0, 1) < 0.5:\n                    self.population[i] = self.best_individual - (A * sine + B * cosine) * C * D\n                else:\n                    self.population[i] = self.best_individual + (A * sine + B * cosine) * C * D\n                levy_flight = self.levy_flight(self.population[i])\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                    self.levy_flight_scale *= 1.1\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                        self.levy_flight_scale *= 0.9\n                self.levy_flight_scale = np.clip(self.levy_flight_scale, 0.1, 10.0)\n                if np.random.uniform(0, 1) < self.adaptive_prob:\n                    chaotic_individual, chaotic_fitness = self.adaptive_chaotic_opposition_based_learning(self.population[i], fitness)\n                    evaluations += 1\n                    if chaotic_fitness < fitness:\n                        self.population[i] = chaotic_individual\n                if np.random.uniform(0, 1) < 0.1:\n                    weighted_individual = self.weighted_opposition_based_learning(self.population[i])\n                    weighted_fitness = func(weighted_individual)\n                    evaluations += 1\n                    if weighted_fitness < fitness:\n                        self.population[i] = weighted_individual\n                if np.random.uniform(0, 1) < self.mutation_prob:\n                    gaussian_individual = self.gaussian_mutation(self.population[i])\n                    gaussian_fitness = func(gaussian_individual)\n                    evaluations += 1\n                    if gaussian_fitness < fitness:\n                        self.population[i] = gaussian_individual\n            if evaluations > self.budget / 2 and self.population_size < self.initial_population_size * 2:\n                self.population_size *= 2\n                self.population = np.vstack((self.population, np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size // 2, self.dim))))\n        return self.best_individual", "name": "HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v2", "description": "A novel metaheuristic algorithm called \"Hybrid Sine Cosine Algorithm with Levy Flight, Simulated Annealing, Adaptive Chaotic Opposition-Based Learning, and Gaussian Mutation with Dynamic Population Size and Adaptive Levy Flight\" that combines the exploration capabilities of sine cosine algorithm with the exploitation capabilities of simulated annealing, the long-range search of Levy flight, the adaptive chaotic opposition-based learning, and the Gaussian mutation to efficiently optimize black box functions, with a dynamic population size and an adaptive Levy flight to improve the convergence speed, and incorporates a new opposition-based learning strategy that uses a weighted average of the current individual and its opposite to generate a new individual, and uses a novel adaptive chaotic opposition-based learning strategy that adapts the chaotic map to the convergence speed.", "configspace": "", "generation": 16, "fitness": 0.17778248487184112, "feedback": "The algorithm HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": "e9d02ae1-3d99-4b43-8bac-d8c62df695e0", "metadata": {"aucs": [0.36096405883270444, 0.31857850662940856, 0.3689459806983105, 0.30503153011727935, 0.31932712646786665, 0.41228776800210387, 0.20474455534401959, 0.21085406289683184, 0.36992560876752734, 0.0, 0.011861448736831148, 0.0, 0.0034963745549871916, 0.0, 0.0, 0.0, 0.0, 0.0, 0.054822559118014036, 0.1129404204288963, 0.05186091744854926, 0.0981640678649417, 0.08700056880677842, 0.0789917352623748, 0.033318408546774814, 0.04492707466646839, 0.08163777729467014, 0.05927044952190663, 0.0648555064841344, 0.05656647344553234, 0.10745382413843341, 0.05745374448754259, 0.04065295845055428, 0.12403581021410282, 0.0627806689838386, 0.08845533725921817, 0.9793532529426358, 0.9122231395540004, 0.9753210531196046, 0.96006775077137, 0.9363540866321844, 0.9783003383154898, 0.9824117828936095, 0.9355632689034431, 0.9828908427124403, 0.27877723917933794, 0.18094842734461347, 0.24206561119457615, 0.19558926590157544, 0.15575842471238577, 0.2261716007882245, 0.28494269765618996, 0.2467305047062679, 0.19494612817641266, 0.13879223211108638, 0.19487588080267737, 0.1319628834950145, 0.2230263553965407, 0.25787996239382494, 0.1678092784260713, 0.12659808828160335, 0.11599843074484906, 0.15650730575922467, 0.11271931519765133, 0.17528976187595968, 0.11980331626964158, 0.1228961884289238, 0.12300413502863217, 0.11869911240001907, 0.11922300410720366, 0.10752780504477466, 0.18175958960399052, 0.20905407708195411, 0.17367734990768025, 0.1802030611413762, 0.1805504974541422, 0.1846302534016877, 0.16731892664292558, 0.18641379786997092, 0.20577814460275756, 0.17888706333550541, 0.0, 0.0, 0.0, 0.04056016658908812, 0.0, 0.023186727259706275, 0.0, 0.019782870485005488, 0.0, 0.04916248969195025, 0.04485468530391934, 0.0629024435534613, 0.06849892735797547, 0.007110157326989386, 0.023657310891603944, 0.1576627283461579, 0.017300704662010502, 0.04186133898048616, 0.0, 0.0, 0.0, 0.0, 0.031147796134564643, 0.0, 0.027960940974351756, 0.0, 0.01514475981347363, 0.11448109579706356, 0.0017887633910522727, 0.08341090486370906, 0.07646060358545381, 0.06948007892174046, 0.10846284359995229, 0.007460697456799226, 0.07343630035552706, 0.08699246789073145, 0.30042938932741836, 0.2148999041636015, 0.23050626975212662, 0.17651667267990412, 0.23119537667326107, 0.3225394071464629, 0.25596041052439167, 0.4509379316728156, 0.30907771024399444, 0.049560433334248644, 0.07412037470169786, 0.059374841464079564, 0.04477695601096565, 0.07706512822089151, 0.08538435253400822, 0.09311906386426194, 0.05708245904650322, 0.06612778369112005, 0.12104823654027841, 0.14400526123290658, 0.11809186751914635, 0.23721700952491043, 0.17681497652575184, 0.16991642836917764, 0.12836997557637475, 0.18630045805500106, 0.19758749001708753, 0.17033837041746325, 0.16441612825265073, 0.16372491208123652, 0.2224091656438406, 0.1925348268210172, 0.17724323118314622, 0.20164492014412638, 0.1827865154852264, 0.15663296624596001, 0.1231872121826163, 0.12783474322987298, 0.18347711933140176, 0.161527272935015, 0.14013510551408614, 0.16388923957011614, 0.10818109405611886, 0.14602425319887313, 0.1304382546460856, 0.29586017750179494, 0.2855014320628093, 0.3017510142883111, 0.28103346051673594, 0.287967239285574, 0.2729845306525319, 0.3294529587354349, 0.2869411436182129, 0.29383942748161695, 0.18051289486275768, 0.1765324127217759, 0.19503522687737385, 0.19581743513409322, 0.1939774378529765, 0.17799639815498813, 0.16502751475982347, 0.17647526890931586, 0.17284416575183537, 0.1688737326485712, 0.17870616565419917, 0.17188960805823827, 0.1796401007085231, 0.14683613119956007, 0.5116323684720925, 0.20460208233897392, 0.6184464771645144, 0.1674906411952779, 0.11007107807599181, 0.16474099556025845, 0.3149654476074293, 0.224464510507422, 0.10894343452220112, 0.11567385657950258, 0.15613407938119594, 0.15245507892595123, 0.14649119748789452, 0.19363738644925865, 0.17188011710412354, 0.20595542635995756, 0.1921116548597549, 0.19294721094891487, 0.18396297622555136, 0.20174254496954147, 0.17942239958122863, 0.19633493259264834, 0.07427447521057606, 0.08517650914871322, 0.0606681088205947, 0.057678231907283606, 0.061685776083322374, 0.0889757230950019, 0.07498791714144393, 0.06385500047523218, 0.056387357724105414]}, "mutation_prompt": null}
{"id": "e730d97f-120c-47e7-b4c6-eecca13bc64a", "solution": "import numpy as np\n\nclass HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.best_fitness = np.inf\n        self.chaotic_map = np.random.uniform(0, 1, self.dim)\n        self.adaptive_prob = 0.2\n        self.adaptive_mutation_prob = 0.1\n        self.levy_flight_scale = 1.0\n        self.opposition_weight = 0.5\n        self.convergence_speed = 0.0\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def chaotic_opposition_based_learning(self, individual):\n        chaotic_individual = self.lower_bound + (self.upper_bound - self.lower_bound) * self.chaotic_map\n        self.chaotic_map = 4 * self.chaotic_map * (1 - self.chaotic_map)\n        return chaotic_individual\n\n    def levy_flight(self, individual):\n        levy_flight = np.random.normal(0, self.levy_flight_scale, self.dim) / np.random.normal(0, self.levy_flight_scale, self.dim)\n        levy_flight = individual + levy_flight\n        return levy_flight\n\n    def gaussian_mutation(self, individual):\n        gaussian_mutation = individual + np.random.normal(0, 0.1, self.dim)\n        return gaussian_mutation\n\n    def weighted_opposition_based_learning(self, individual):\n        opposite_individual = self.opposition_based_learning(individual)\n        weighted_individual = self.opposition_weight * individual + (1 - self.opposition_weight) * opposite_individual\n        return weighted_individual\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_individual = self.population[i]\n                    self.convergence_speed = 1.0 - (fitness / self.best_fitness)\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                r3 = np.random.uniform(0, 1, self.dim)\n                r4 = np.random.uniform(0, 1, self.dim)\n                A = 2 * r1 - 1\n                B = np.abs(r2)\n                C = 2 * r3 - 1\n                D = np.abs(r4)\n                sine = np.abs(self.best_individual - self.population[i]) * np.sin(np.abs(r1) * np.pi)\n                cosine = np.abs(self.best_individual - self.population[i]) * np.cos(np.abs(r1) * np.pi)\n                if np.random.uniform(0, 1) < 0.5:\n                    self.population[i] = self.best_individual - (A * sine + B * cosine) * C * D\n                else:\n                    self.population[i] = self.best_individual + (A * sine + B * cosine) * C * D\n                levy_flight = self.levy_flight(self.population[i])\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                    self.levy_flight_scale *= 1.1  # Increase the Levy flight scale if the Levy flight improves the fitness\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                        self.levy_flight_scale *= 0.9  # Decrease the Levy flight scale if the Levy flight does not improve the fitness\n                self.levy_flight_scale = np.clip(self.levy_flight_scale, 0.1, 10.0)  # Clip the Levy flight scale to a reasonable range\n                # Apply adaptive chaotic opposition-based learning with a probability that adapts to the convergence speed\n                if np.random.uniform(0, 1) < self.adaptive_prob * self.convergence_speed:\n                    chaotic_individual = self.chaotic_opposition_based_learning(self.population[i])\n                    chaotic_fitness = func(chaotic_individual)\n                    evaluations += 1\n                    if chaotic_fitness < fitness:\n                        self.population[i] = chaotic_individual\n                        self.adaptive_prob *= 1.1  # Increase the probability if the chaotic opposition-based learning improves the fitness\n                    else:\n                        self.adaptive_prob *= 0.9  # Decrease the probability if the chaotic opposition-based learning does not improve the fitness\n                    self.adaptive_prob = np.clip(self.adaptive_prob, 0.1, 0.9)  # Clip the probability to a reasonable range\n                # Apply weighted opposition-based learning with a fixed probability\n                if np.random.uniform(0, 1) < 0.1:\n                    weighted_individual = self.weighted_opposition_based_learning(self.population[i])\n                    weighted_fitness = func(weighted_individual)\n                    evaluations += 1\n                    if weighted_fitness < fitness:\n                        self.population[i] = weighted_individual\n                # Apply Gaussian mutation with an adaptive probability that adapts to the convergence speed\n                if np.random.uniform(0, 1) < self.adaptive_mutation_prob * self.convergence_speed:\n                    gaussian_individual = self.gaussian_mutation(self.population[i])\n                    gaussian_fitness = func(gaussian_individual)\n                    evaluations += 1\n                    if gaussian_fitness < fitness:\n                        self.population[i] = gaussian_individual\n                        self.adaptive_mutation_prob *= 1.1  # Increase the probability if the Gaussian mutation improves the fitness\n                    else:\n                        self.adaptive_mutation_prob *= 0.9  # Decrease the probability if the Gaussian mutation does not improve the fitness\n                    self.adaptive_mutation_prob = np.clip(self.adaptive_mutation_prob, 0.01, 0.5)  # Clip the probability to a reasonable range\n            # Dynamically adjust the population size based on the convergence speed\n            if evaluations > self.budget / 2 and self.population_size < self.initial_population_size * 2:\n                self.population_size *= 2\n                self.population = np.vstack((self.population, np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size // 2, self.dim))))\n        return self.best_individual", "name": "HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v2", "description": "A novel metaheuristic algorithm called \"Hybrid Sine Cosine Algorithm with Levy Flight, Simulated Annealing, Adaptive Chaotic Opposition-Based Learning, and Gaussian Mutation with Dynamic Population Size and Adaptive Levy Flight\" that combines the exploration capabilities of sine cosine algorithm with the exploitation capabilities of simulated annealing, the long-range search of Levy flight, the adaptive chaotic opposition-based learning, and the Gaussian mutation to efficiently optimize black box functions, with a dynamic population size and an adaptive Levy flight to improve the convergence speed, and incorporates a new opposition-based learning strategy that uses a weighted average of the current individual and its opposite to generate a new individual, and also utilizes a new adaptive probability for chaotic opposition-based learning that adapts to the convergence speed, and a new adaptive mutation probability that adapts to the convergence speed.", "configspace": "", "generation": 17, "fitness": 0.16462404352527787, "feedback": "The algorithm HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.19.", "error": "", "parent_id": "e9d02ae1-3d99-4b43-8bac-d8c62df695e0", "metadata": {"aucs": [0.24175645296627046, 0.2615688216005915, 0.3053120253001671, 0.2946510015889148, 0.17381571212506064, 0.2630470040865157, 0.22432573521045518, 0.2839783616448254, 0.16564435498597307, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.021900738668981234, 9.999999999998899e-05, 0.10198069568951074, 0.05096246792044079, 0.06702649283157569, 0.09280846532490994, 0.06637906138287508, 0.08164480231853977, 0.0452705758940779, 0.0751422114619551, 0.04100674371791524, 0.07322388402476188, 0.08762381151627052, 0.0723250365875785, 0.08808070680767066, 0.08191255082569682, 0.04485440530121343, 0.0239432111468304, 0.060097280990715984, 0.07209598064120526, 0.9786716055220088, 0.9646730722007947, 0.9365127094197958, 0.977591987394429, 0.9691969181651208, 0.9673730744749061, 0.9776663444394731, 0.9752505971159718, 0.9766389300835576, 0.1645029192028694, 0.17428917546837563, 0.1471542360153122, 0.16809267833937025, 0.11378551496963973, 0.16090080827019504, 0.13601348162831128, 0.15565065903240227, 0.09357339276657073, 0.14102613329854974, 0.19318259139053617, 0.19955940806255368, 0.17357537460177153, 0.17720121813038114, 0.11925799610757282, 0.14720252552426083, 0.11656067855361885, 0.15563108864998, 0.047942321917971986, 0.06927721695280742, 0.08511741579522536, 0.08234302930847992, 0.08223958211909832, 0.04904267184490074, 0.07573270190040471, 0.08770481312784217, 0.08598467482902472, 0.15117978847187552, 0.08680316987124115, 0.16572287797693497, 0.12833074677694656, 0.13948635662969933, 0.12006651387238221, 0.16383032875263237, 0.10389027151096575, 0.14935111625498088, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.025876204592582552, 0.04201599197229877, 0.09096318210053744, 0.06282527472514432, 0.0045564008109136855, 9.999999999998899e-05, 0.1600681778894788, 0.06970270277575707, 0.04702562690933809, 0.032515037109439815, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.039258123116633015, 0.02118925380624348, 0.030477508518922503, 0.029346300433546246, 0.03789202593286989, 0.03139670413215867, 0.022640081368758724, 0.03412459093319253, 0.03659333809700216, 0.23767913789210504, 0.24959829670259592, 0.19691551752032022, 0.18063656866372713, 0.2698762667547515, 0.23728149005300447, 0.2695544736756219, 0.27766947043634393, 0.2228784812488086, 0.053444969077819815, 0.05157090481429927, 0.04836568340347969, 0.06032868384503742, 0.07498273969691305, 0.05333919752838978, 0.05564243592592688, 0.07503108272336867, 0.07627587140067393, 0.16874235158237372, 0.0948522209888677, 0.11817155682339597, 0.20843733703321898, 0.10847483312414585, 0.12287490575413451, 0.20667699210548252, 0.15124365362937875, 0.17196107738028754, 0.1595083568436776, 0.18730999911118207, 0.16122185548649814, 0.20951410440846574, 0.20820502933273055, 0.22531293982596845, 0.187501365552751, 0.24539940328518361, 0.1688837593622855, 0.11758597035291263, 0.12629366679087273, 0.12321934390164568, 0.17555987986104737, 0.14418756533688015, 0.17208498935364647, 0.12591971518078593, 0.18693275742838356, 0.12590308887968238, 0.27646134476098216, 0.27639485945020004, 0.28654908624122766, 0.29848779539588444, 0.27607975913183036, 0.27411715476174137, 0.3096552003680585, 0.295690891200426, 0.2887375290844426, 0.17298615792370586, 0.20106344917645258, 0.17979882894915222, 0.18546600451309014, 0.17592946085188854, 0.17251366229478715, 0.16602739975769532, 0.1943409398860675, 0.1866718974877688, 0.3444532783293158, 0.38241038446466824, 0.1469225176087957, 0.40611733707121667, 0.24691918439241012, 0.36020237459796633, 0.1513718385196875, 0.19937230291590946, 0.16440031005031475, 0.22864380157898845, 0.2389723152997747, 0.36569134085803123, 0.1564257536828334, 0.27523789253223063, 0.11699075098406087, 0.11918468131510196, 0.15799461583531882, 0.18248256402116247, 0.1968110932901198, 0.1761195970408913, 0.1803132955050607, 0.21526715727413703, 0.1645311069955112, 0.16615926822445704, 0.18782527500090096, 0.2270510527451417, 0.14685829740029244, 0.135628675266676, 0.06255889789814517, 0.06950355558467869, 0.05686088668870104, 0.10804088395765943, 0.06516211235776026, 0.0705099132658139, 0.0753531338029716, 0.08219870926079098]}, "mutation_prompt": null}
{"id": "4e1bc297-6148-498a-8c55-a78d4745e9f4", "solution": "import numpy as np\n\nclass HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.best_fitness = np.inf\n        self.chaotic_map = np.random.uniform(0, 1, self.dim)\n        self.adaptive_prob = 0.2\n        self.mutation_prob = 0.1\n        self.levy_flight_scale = 1.0\n        self.opposition_weight = 0.5\n        self.exploration_phase = True\n        self.convergence_speed = 0.0\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def chaotic_opposition_based_learning(self, individual):\n        chaotic_individual = self.lower_bound + (self.upper_bound - self.lower_bound) * self.chaotic_map\n        self.chaotic_map = 4 * self.chaotic_map * (1 - self.chaotic_map)\n        return chaotic_individual\n\n    def levy_flight(self, individual):\n        levy_flight = np.random.normal(0, self.levy_flight_scale, self.dim) / np.random.normal(0, self.levy_flight_scale, self.dim)\n        levy_flight = individual + levy_flight\n        return levy_flight\n\n    def gaussian_mutation(self, individual):\n        gaussian_mutation = individual + np.random.normal(0, 0.1, self.dim)\n        return gaussian_mutation\n\n    def weighted_opposition_based_learning(self, individual):\n        opposite_individual = self.opposition_based_learning(individual)\n        weighted_individual = self.opposition_weight * individual + (1 - self.opposition_weight) * opposite_individual\n        return weighted_individual\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_individual = self.population[i]\n                    self.convergence_speed = (self.convergence_speed * 0.9) + (1 - (fitness / self.best_fitness)) * 0.1\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                r3 = np.random.uniform(0, 1, self.dim)\n                r4 = np.random.uniform(0, 1, self.dim)\n                A = 2 * r1 - 1\n                B = np.abs(r2)\n                C = 2 * r3 - 1\n                D = np.abs(r4)\n                sine = np.abs(self.best_individual - self.population[i]) * np.sin(np.abs(r1) * np.pi)\n                cosine = np.abs(self.best_individual - self.population[i]) * np.cos(np.abs(r1) * np.pi)\n                if np.random.uniform(0, 1) < 0.5:\n                    self.population[i] = self.best_individual - (A * sine + B * cosine) * C * D\n                else:\n                    self.population[i] = self.best_individual + (A * sine + B * cosine) * C * D\n                levy_flight = self.levy_flight(self.population[i])\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                    self.levy_flight_scale *= 1.1  # Increase the Levy flight scale if the Levy flight improves the fitness\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                        self.levy_flight_scale *= 0.9  # Decrease the Levy flight scale if the Levy flight does not improve the fitness\n                self.levy_flight_scale = np.clip(self.levy_flight_scale, 0.1, 10.0)  # Clip the Levy flight scale to a reasonable range\n                # Adaptively adjust the population size and the Levy flight scale based on the convergence speed\n                if evaluations > self.budget / 2 and self.population_size < self.initial_population_size * 2:\n                    if self.convergence_speed > 0.5:\n                        self.population_size *= 2\n                        self.population = np.vstack((self.population, np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size // 2, self.dim))))\n                    else:\n                        self.levy_flight_scale *= 1.1\n                # Apply adaptive chaotic opposition-based learning with a probability that adapts to the convergence speed\n                if np.random.uniform(0, 1) < self.adaptive_prob:\n                    chaotic_individual = self.chaotic_opposition_based_learning(self.population[i])\n                    chaotic_fitness = func(chaotic_individual)\n                    evaluations += 1\n                    if chaotic_fitness < fitness:\n                        self.population[i] = chaotic_individual\n                        self.adaptive_prob *= 1.1  # Increase the probability if the chaotic opposition-based learning improves the fitness\n                    else:\n                        self.adaptive_prob *= 0.9  # Decrease the probability if the chaotic opposition-based learning does not improve the fitness\n                    self.adaptive_prob = np.clip(self.adaptive_prob, 0.1, 0.9)  # Clip the probability to a reasonable range\n                # Apply weighted opposition-based learning with a fixed probability\n                if np.random.uniform(0, 1) < 0.1:\n                    weighted_individual = self.weighted_opposition_based_learning(self.population[i])\n                    weighted_fitness = func(weighted_individual)\n                    evaluations += 1\n                    if weighted_fitness < fitness:\n                        self.population[i] = weighted_individual\n                # Apply Gaussian mutation with a fixed probability\n                if np.random.uniform(0, 1) < self.mutation_prob:\n                    gaussian_individual = self.gaussian_mutation(self.population[i])\n                    gaussian_fitness = func(gaussian_individual)\n                    evaluations += 1\n                    if gaussian_fitness < fitness:\n                        self.population[i] = gaussian_individual\n        return self.best_individual", "name": "HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_Enhanced", "description": "A novel metaheuristic algorithm called \"Hybrid Sine Cosine Algorithm with Levy Flight, Simulated Annealing, Adaptive Chaotic Opposition-Based Learning, and Gaussian Mutation with Dynamic Population Size, Adaptive Levy Flight, and Enhanced Exploration-Exploitation Balance\" that combines the exploration capabilities of sine cosine algorithm with the exploitation capabilities of simulated annealing, the long-range search of Levy flight, the adaptive chaotic opposition-based learning, and the Gaussian mutation to efficiently optimize black box functions, with a dynamic population size and an adaptive Levy flight to improve the convergence speed, and incorporates a new opposition-based learning strategy that uses a weighted average of the current individual and its opposite to generate a new individual, and enhances the exploration-exploitation balance by adaptively adjusting the population size and the Levy flight scale based on the convergence speed.", "configspace": "", "generation": 18, "fitness": 0.1775577997474476, "feedback": "The algorithm HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": "e9d02ae1-3d99-4b43-8bac-d8c62df695e0", "metadata": {"aucs": [0.3085700212179576, 0.3069940412954535, 0.33924702466155265, 0.31115974715496786, 0.28616927345517673, 0.3424201359911113, 0.26913566973875447, 0.1971151707926716, 0.40154404112174846, 0.005580562992760996, 9.999999999998899e-05, 9.999999999998899e-05, 0.057764696918716996, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06398181914560497, 0.05514439225398915, 0.06037021900196082, 0.051628141146427886, 0.09316630590766761, 0.06713531645813442, 0.08084044788733136, 0.06465561056063995, 0.08521328010490015, 0.05081527506640937, 0.1175001618420165, 0.06342296480837106, 0.08331407349283704, 0.05605964355897286, 0.0695989840320772, 0.11926542190297262, 0.04585028709977601, 0.06495065151009038, 0.9633880233723959, 0.9336367854163096, 0.9670381051429943, 0.9577595856878112, 0.9318507006009582, 0.9804976366954902, 0.9782939365187215, 0.9323509697589858, 0.9782930831897904, 0.256136160907378, 0.22172643316413487, 0.22973427017405224, 0.12582856823103306, 0.2404766775052345, 0.21983683487561467, 0.19141826178723387, 0.17201435406281473, 0.23454191636534905, 0.1665635686534397, 0.19044405812765597, 0.2050781903818012, 0.16194481122581017, 0.10713847133609089, 0.18247922950007822, 0.15212797868191097, 0.11323136819665958, 0.16617529412299425, 0.18351597080436566, 0.09531095478697449, 0.11749481731592337, 0.1268936325446599, 0.11657790206200114, 0.1343508757872296, 0.12524556811364396, 0.10350763065024016, 0.12275229294896761, 0.20293675923192778, 0.18087966472146477, 0.1683708145827355, 0.1829892255620189, 0.1719175406473451, 0.16187434140234092, 0.20676842883250102, 0.18224292983316503, 0.1860635399648597, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03801180587420583, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04894291191715838, 0.02672912540933725, 0.06088255517428065, 0.068371307760409, 0.006203776229144031, 0.004238053833553801, 0.08765322607358594, 0.014912237732196076, 0.041158532670144465, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09798757661899526, 0.028499272303709744, 0.04745602801730131, 0.042550160478301735, 0.061458025251386106, 0.08894558603835923, 0.007003422791295066, 0.047469514973619176, 0.03318195109173938, 0.3328024724758776, 0.2601237721513251, 0.32450673622884996, 0.3547708244606357, 0.3192142543577725, 0.324674584122407, 0.31317166661984397, 0.24496657910693875, 0.24577300155345816, 0.04959595676563899, 0.12640139059279432, 0.07418595186781263, 0.08991171593889069, 0.1298956719368174, 0.08431356961698078, 0.0635814533542276, 0.06742251343913508, 0.05245792351529399, 0.1872300882557204, 0.2320888561259984, 0.21143890411178012, 0.14183169760501257, 0.1418868533712192, 0.11466493487904428, 0.1483314525018724, 0.14329787683715622, 0.14881389747821028, 0.18012038335888303, 0.25499160085193506, 0.16119474549333868, 0.20819721723338303, 0.20630439117596033, 0.22374098776973783, 0.18770568049858138, 0.21211750408997243, 0.21501240567219426, 0.11233544484722391, 0.19038564183337792, 0.11847526087001248, 0.17345385293445748, 0.1402761274831793, 0.16758046594408638, 0.1415141519598765, 0.1128644196148273, 0.11872680146348302, 0.2691102728309235, 0.27003749606488614, 0.29095536793572696, 0.2693771202293802, 0.2672822711790156, 0.31518011768114407, 0.2662190294950252, 0.2729569260373491, 0.2648359622080023, 0.1847602995461246, 0.1698410334804763, 0.17752291593449754, 0.18854280567026405, 0.19391008143048416, 0.1770162250067162, 0.164653895830689, 0.1699205554513763, 0.16813816897895284, 0.5160222707868576, 0.1946436672676949, 0.16103698115982734, 0.13613052906789103, 0.41368258294629534, 0.4960864005694542, 0.14309765327431578, 0.15837421655353534, 0.15601308562507965, 0.20759724535925006, 0.1221818341015174, 0.16771687428623938, 0.27814804124896664, 0.17229436409685095, 0.19123039266088326, 0.21618067882834713, 0.34678597820082846, 0.11108121462961718, 0.19881596738330953, 0.16593917736745822, 0.224296354444948, 0.17910291135613132, 0.19230448056191884, 0.19957330304692955, 0.1774557880619736, 0.20156680913836444, 0.1790488851396116, 0.07148632287002732, 0.0788952273359258, 0.062095012406840566, 0.06613671924824216, 0.07612802564927301, 0.08893445722638771, 0.06734880474832994, 0.04513709119394427, 0.054936555414473176]}, "mutation_prompt": null}
{"id": "22e3da69-2087-41fc-a640-8af8824eae69", "solution": "import numpy as np\n\nclass HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.best_fitness = np.inf\n        self.chaotic_map = np.random.uniform(0, 1, self.dim)\n        self.adaptive_prob = 0.2\n        self.mutation_prob = 0.1\n        self.levy_flight_scale = 1.0\n        self.opposition_weight = 0.5\n        self.convergence_speed = 0.0\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def chaotic_opposition_based_learning(self, individual):\n        chaotic_individual = self.lower_bound + (self.upper_bound - self.lower_bound) * self.chaotic_map\n        self.chaotic_map = 4 * self.chaotic_map * (1 - self.chaotic_map)\n        return chaotic_individual\n\n    def levy_flight(self, individual):\n        levy_flight = np.random.normal(0, self.levy_flight_scale, self.dim) / np.random.normal(0, self.levy_flight_scale, self.dim)\n        levy_flight = individual + levy_flight\n        return levy_flight\n\n    def gaussian_mutation(self, individual):\n        gaussian_mutation = individual + np.random.normal(0, 0.1, self.dim)\n        return gaussian_mutation\n\n    def weighted_opposition_based_learning(self, individual):\n        opposite_individual = self.opposition_based_learning(individual)\n        weighted_individual = self.opposition_weight * individual + (1 - self.opposition_weight) * opposite_individual\n        return weighted_individual\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_individual = self.population[i]\n                    self.convergence_speed = 1.0 / (1.0 + evaluations / self.budget)\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                r3 = np.random.uniform(0, 1, self.dim)\n                r4 = np.random.uniform(0, 1, self.dim)\n                A = 2 * r1 - 1\n                B = np.abs(r2)\n                C = 2 * r3 - 1\n                D = np.abs(r4)\n                sine = np.abs(self.best_individual - self.population[i]) * np.sin(np.abs(r1) * np.pi)\n                cosine = np.abs(self.best_individual - self.population[i]) * np.cos(np.abs(r1) * np.pi)\n                if np.random.uniform(0, 1) < 0.5:\n                    self.population[i] = self.best_individual - (A * sine + B * cosine) * C * D\n                else:\n                    self.population[i] = self.best_individual + (A * sine + B * cosine) * C * D\n                levy_flight = self.levy_flight(self.population[i])\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                    self.levy_flight_scale *= 1.1 * (1.0 + self.convergence_speed)  # Increase the Levy flight scale if the Levy flight improves the fitness\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                        self.levy_flight_scale *= 0.9 / (1.0 + self.convergence_speed)  # Decrease the Levy flight scale if the Levy flight does not improve the fitness\n                self.levy_flight_scale = np.clip(self.levy_flight_scale, 0.1, 10.0)  # Clip the Levy flight scale to a reasonable range\n                # Apply adaptive chaotic opposition-based learning with a probability that adapts to the convergence speed\n                if np.random.uniform(0, 1) < self.adaptive_prob * (1.0 + self.convergence_speed):\n                    chaotic_individual = self.chaotic_opposition_based_learning(self.population[i])\n                    chaotic_fitness = func(chaotic_individual)\n                    evaluations += 1\n                    if chaotic_fitness < fitness:\n                        self.population[i] = chaotic_individual\n                        self.adaptive_prob *= 1.1  # Increase the probability if the chaotic opposition-based learning improves the fitness\n                    else:\n                        self.adaptive_prob *= 0.9  # Decrease the probability if the chaotic opposition-based learning does not improve the fitness\n                    self.adaptive_prob = np.clip(self.adaptive_prob, 0.1, 0.9)  # Clip the probability to a reasonable range\n                # Apply weighted opposition-based learning with a fixed probability\n                if np.random.uniform(0, 1) < 0.1:\n                    weighted_individual = self.weighted_opposition_based_learning(self.population[i])\n                    weighted_fitness = func(weighted_individual)\n                    evaluations += 1\n                    if weighted_fitness < fitness:\n                        self.population[i] = weighted_individual\n                # Apply Gaussian mutation with a fixed probability\n                if np.random.uniform(0, 1) < self.mutation_prob:\n                    gaussian_individual = self.gaussian_mutation(self.population[i])\n                    gaussian_fitness = func(gaussian_individual)\n                    evaluations += 1\n                    if gaussian_fitness < fitness:\n                        self.population[i] = gaussian_individual\n            # Dynamically adjust the population size based on the convergence speed\n            if evaluations > self.budget / 2 and self.population_size < self.initial_population_size * 2:\n                self.population_size *= 2\n                self.population = np.vstack((self.population, np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size // 2, self.dim))))\n        return self.best_individual", "name": "HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v2", "description": "Hybrid Sine Cosine Algorithm with Levy Flight, Simulated Annealing, Adaptive Chaotic Opposition-Based Learning, Gaussian Mutation, and Dynamic Population Size, incorporating a new weighted opposition-based learning strategy and an adaptive Levy flight scale that adjusts based on the convergence speed.", "configspace": "", "generation": 19, "fitness": 0.18109163399172928, "feedback": "The algorithm HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": "e9d02ae1-3d99-4b43-8bac-d8c62df695e0", "metadata": {"aucs": [0.32022717836029646, 0.37154040714199166, 0.30469628009295235, 0.3006817718446537, 0.291581971938194, 0.2037138830577928, 0.20457905596980486, 0.26956626986329935, 0.35978666139748716, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017059953534549588, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1296150355229374, 0.0754664840396928, 0.07109751846118795, 0.04812472337343299, 0.07475798393102817, 0.04659773060062977, 0.07735485207935111, 0.07924158731531628, 0.07022468573311236, 0.11235165525389545, 0.05953881382754078, 0.07557925728415626, 0.07996052322873415, 0.059382055979059434, 0.06737314314724085, 0.048132206860949545, 0.03595338260321512, 0.056247624606085234, 0.9776291666466989, 0.9666757027924954, 0.964005580457114, 0.9694808424230447, 0.9346893160917074, 0.9797817399553435, 0.9701596045651263, 0.9229068668184005, 0.9774149612312324, 0.25181206545899204, 0.2491358523710675, 0.2807797549469928, 0.23645059154827364, 0.19691688913449756, 0.1271697381875425, 0.2484293889804302, 0.1679583077869553, 0.2172600869191198, 0.21217309106363924, 0.17249109056441558, 0.16611993101226763, 0.18886182737352075, 0.09125905995801764, 0.14054930973570567, 0.22179055597757336, 0.15724955540438335, 0.20775048518428196, 0.11082202026143695, 0.13578500044452124, 0.11722148280255895, 0.11553763747608914, 0.12319525973579071, 0.11364890792385918, 0.11781739630621946, 0.14481120626385346, 0.11699274935940118, 0.20037789500125613, 0.16786331625155326, 0.18604102400934674, 0.18625160850465428, 0.18367648775217327, 0.16406686890697542, 0.18742275820825605, 0.20043926760976083, 0.18350114401922957, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03853663916580807, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04839946187502464, 0.026520206815032754, 0.06110078436869426, 0.07121246972505979, 0.022278761556958626, 0.011612240231562265, 0.08816859486809703, 0.08072260773622986, 0.06287249037781473, 0.002311981975180455, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.001281914000771378, 9.999999999998899e-05, 9.999999999998899e-05, 0.06192627848026455, 0.006202226635344421, 0.08546085963360206, 0.08033300582334502, 0.024705522732422325, 0.04691525764777338, 0.09478467078189823, 0.07890230543498344, 0.055412348308887305, 0.25882994959191963, 0.20743543758061178, 0.29307448083003595, 0.19325105923320407, 0.35605985369751325, 0.36701387168498567, 0.290720543965006, 0.2920068365183005, 0.31554745112157156, 0.09351459752631486, 0.10858816562445084, 0.06583333096210386, 0.10983738920070896, 0.07507536530543513, 0.07367974841908342, 0.07488768805004298, 0.10168710645851586, 0.06414928354381588, 0.143605646200909, 0.1553971333364521, 0.18552136010306297, 0.1664869188522956, 0.18216429144755808, 0.14265086762620427, 0.15705966975241403, 0.14987254972085462, 0.173125791345643, 0.1937752722864845, 0.21367899602315843, 0.22070620435916355, 0.18890752768346464, 0.18605958554069635, 0.1865719151410934, 0.1682007630710718, 0.21417055440557498, 0.19303760788085234, 0.12556905480381086, 0.1738001713691799, 0.12398953039277982, 0.1611394619515759, 0.20277209403861862, 0.14515536959422204, 0.10817139832328904, 0.09961258435752274, 0.11617857572791523, 0.295907967504335, 0.29419365540012465, 0.31824898028775617, 0.2874759399943816, 0.29659907787759976, 0.28265335577563244, 0.28438478507956855, 0.26998167382766936, 0.29845911263833713, 0.17235316827071945, 0.1798828764055641, 0.17326216592249877, 0.20230120837602583, 0.17691971058812161, 0.16504709214729318, 0.16064258901104, 0.1772516047818593, 0.17064380560636805, 0.6472229648808425, 0.42740953767362144, 0.27172211528507273, 0.16244320150202152, 0.14803039152367548, 0.40280361670657194, 0.5063878749685122, 0.18517993655447362, 0.14661876535338247, 0.18394487164675233, 0.22967580396240483, 0.13267734866159475, 0.1760200228807668, 0.19118641932108993, 0.14834371056844953, 0.1452063787803669, 0.25488493172477833, 0.4116878956784026, 0.19086086017383308, 0.18947339342441605, 0.17056181156263373, 0.19086464319981022, 0.17985013517273352, 0.20612645914228767, 0.180911051780152, 0.19414927125626613, 0.1783095116785991, 0.08042453733943389, 0.08137277218683958, 0.10431215364803881, 0.07106830162020761, 0.07186017418265345, 0.0722548685684673, 0.06726571145179727, 0.09373792454456431, 0.08139503081450916]}, "mutation_prompt": null}
{"id": "fc5295e3-660f-4a92-a2b0-5bd3af2db470", "solution": "import numpy as np\n\nclass HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.best_fitness = np.inf\n        self.chaotic_map = np.random.uniform(0, 1, self.dim)\n        self.adaptive_prob = 0.2\n        self.mutation_prob = 0.1\n        self.levy_flight_scale = 1.0\n        self.opposition_weight = 0.5\n        self.convergence_speed = 0.0\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def chaotic_opposition_based_learning(self, individual):\n        chaotic_individual = self.lower_bound + (self.upper_bound - self.lower_bound) * self.chaotic_map\n        self.chaotic_map = 4 * self.chaotic_map * (1 - self.chaotic_map)\n        return chaotic_individual\n\n    def levy_flight(self, individual):\n        levy_flight = np.random.normal(0, self.levy_flight_scale, self.dim) / np.random.normal(0, self.levy_flight_scale, self.dim)\n        levy_flight = individual + levy_flight\n        return levy_flight\n\n    def gaussian_mutation(self, individual):\n        gaussian_mutation = individual + np.random.normal(0, 0.1, self.dim)\n        return gaussian_mutation\n\n    def weighted_opposition_based_learning(self, individual):\n        opposite_individual = self.opposition_based_learning(individual)\n        weighted_individual = self.opposition_weight * individual + (1 - self.opposition_weight) * opposite_individual\n        return weighted_individual\n\n    def refine_strategy(self, individual):\n        if np.random.uniform(0, 1) < 0.05:\n            # 5% chance to change the individual lines of the strategy\n            if np.random.uniform(0, 1) < 0.5:\n                # 50% chance to use a different opposition-based learning strategy\n                individual = self.chaotic_opposition_based_learning(individual)\n            else:\n                # 50% chance to use a different mutation strategy\n                individual = self.gaussian_mutation(individual)\n        return individual\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_individual = self.population[i]\n                    self.convergence_speed = 1.0 / (1.0 + evaluations / self.budget)\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                r3 = np.random.uniform(0, 1, self.dim)\n                r4 = np.random.uniform(0, 1, self.dim)\n                A = 2 * r1 - 1\n                B = np.abs(r2)\n                C = 2 * r3 - 1\n                D = np.abs(r4)\n                sine = np.abs(self.best_individual - self.population[i]) * np.sin(np.abs(r1) * np.pi)\n                cosine = np.abs(self.best_individual - self.population[i]) * np.cos(np.abs(r1) * np.pi)\n                if np.random.uniform(0, 1) < 0.5:\n                    self.population[i] = self.best_individual - (A * sine + B * cosine) * C * D\n                else:\n                    self.population[i] = self.best_individual + (A * sine + B * cosine) * C * D\n                levy_flight = self.levy_flight(self.population[i])\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                    self.levy_flight_scale *= 1.1 * (1.0 + self.convergence_speed)  # Increase the Levy flight scale if the Levy flight improves the fitness\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                        self.levy_flight_scale *= 0.9 / (1.0 + self.convergence_speed)  # Decrease the Levy flight scale if the Levy flight does not improve the fitness\n                self.levy_flight_scale = np.clip(self.levy_flight_scale, 0.1, 10.0)  # Clip the Levy flight scale to a reasonable range\n                # Apply adaptive chaotic opposition-based learning with a probability that adapts to the convergence speed\n                if np.random.uniform(0, 1) < self.adaptive_prob * (1.0 + self.convergence_speed):\n                    chaotic_individual = self.chaotic_opposition_based_learning(self.population[i])\n                    chaotic_fitness = func(chaotic_individual)\n                    evaluations += 1\n                    if chaotic_fitness < fitness:\n                        self.population[i] = chaotic_individual\n                        self.adaptive_prob *= 1.1  # Increase the probability if the chaotic opposition-based learning improves the fitness\n                    else:\n                        self.adaptive_prob *= 0.9  # Decrease the probability if the chaotic opposition-based learning does not improve the fitness\n                    self.adaptive_prob = np.clip(self.adaptive_prob, 0.1, 0.9)  # Clip the probability to a reasonable range\n                # Apply weighted opposition-based learning with a fixed probability\n                if np.random.uniform(0, 1) < 0.1:\n                    weighted_individual = self.weighted_opposition_based_learning(self.population[i])\n                    weighted_fitness = func(weighted_individual)\n                    evaluations += 1\n                    if weighted_fitness < fitness:\n                        self.population[i] = weighted_individual\n                # Apply Gaussian mutation with a fixed probability\n                if np.random.uniform(0, 1) < self.mutation_prob:\n                    gaussian_individual = self.gaussian_mutation(self.population[i])\n                    gaussian_fitness = func(gaussian_individual)\n                    evaluations += 1\n                    if gaussian_fitness < fitness:\n                        self.population[i] = gaussian_individual\n                # Refine the strategy with a 5% chance\n                self.population[i] = self.refine_strategy(self.population[i])\n            # Dynamically adjust the population size based on the convergence speed\n            if evaluations > self.budget / 2 and self.population_size < self.initial_population_size * 2:\n                self.population_size *= 2\n                self.population = np.vstack((self.population, np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size // 2, self.dim))))\n        return self.best_individual", "name": "HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v3", "description": "Hybrid Sine Cosine Algorithm with Levy Flight, Simulated Annealing, Adaptive Chaotic Opposition-Based Learning, Gaussian Mutation, and Dynamic Population Size, incorporating a new weighted opposition-based learning strategy and an adaptive Levy flight scale that adjusts based on the convergence speed, with a probability of 5% to change the individual lines of the strategy.", "configspace": "", "generation": 20, "fitness": 0.1725762119975887, "feedback": "The algorithm HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.19.", "error": "", "parent_id": "22e3da69-2087-41fc-a640-8af8824eae69", "metadata": {"aucs": [0.2264016786427776, 0.4950478891161445, 0.29374079666041086, 0.29842876540862473, 0.4028812004893223, 0.277600978001588, 0.284182167178469, 0.3559128356349588, 0.16172635774363475, 0.04619283832263876, 9.999999999998899e-05, 0.0003342597767900246, 0.039594704715207985, 0.020687984816600835, 0.01277484671148521, 9.999999999998899e-05, 0.03284922007433455, 9.999999999998899e-05, 0.109817912722736, 0.05062431977434967, 0.062459209291048534, 0.053086502317690076, 0.050648682326246086, 0.03231974183489328, 0.10097302116337636, 0.07213177829535233, 0.05485349348318669, 0.14998635727599452, 0.03924324195104745, 0.08876783311663416, 0.10832585801521033, 0.04518891084349941, 0.08435336150064598, 0.08053071366749442, 0.041248621529643814, 0.06767774875076937, 0.9702639408771295, 0.9717188012638169, 0.9680120954738987, 0.989336210525933, 0.9180158573481785, 0.9465352100541282, 0.9737468005295085, 0.9433735681636093, 0.9740717038516373, 0.1555754419722052, 0.06332267774880185, 0.09275778745911067, 0.18547145338829285, 0.17541147987702965, 0.18718884042379325, 0.06079605364585272, 0.233517384884114, 0.16711712269902912, 0.20259466389187808, 0.138306735571866, 0.15377981988158063, 0.15288474887232384, 0.08035502238468473, 0.18138798267565504, 0.155690059808277, 0.10965850555739776, 0.17113416306334928, 0.11879961623159674, 0.2514376124293449, 0.0856326929220026, 0.06925269526661437, 0.20165496438188146, 0.13467311903543266, 0.12386106697767685, 0.11292339218594494, 0.0610660888153538, 0.17053479636608593, 0.1500254324251742, 0.19451531872198913, 0.14957397282678553, 0.17939993884028005, 0.10983509581907003, 0.17574500471062637, 0.21167418740924981, 0.17966971557468003, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003270875554693853, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05249586456653199, 0.047930889246987296, 0.10540269442118477, 0.06362860973981277, 0.02813401588148501, 0.024175213333493817, 0.16685434433055302, 0.050706010473047125, 0.04448468570108943, 9.999999999998899e-05, 9.999999999998899e-05, 0.0415935153529392, 0.1888730521045553, 0.08342673907190057, 0.038692863503333674, 0.03156494856969605, 9.999999999998899e-05, 0.07587018430978076, 0.0757169915456436, 0.10926036294281438, 0.09331672174030314, 0.05078844209476485, 0.054186332986455144, 0.04790651377120869, 0.14442142968040628, 0.06490790211391906, 0.06961918684876, 0.16880576968941952, 0.3593812766196578, 0.2747491347596962, 0.26099426814362603, 0.3339786910955461, 0.24992485066226933, 0.2868253624332271, 0.3293539597946711, 0.2343544837980699, 0.04820106582701067, 0.07260351755658834, 0.04934379438806935, 0.05944593133413856, 0.04721346771843271, 0.06244678325140629, 0.08866455739565082, 0.052502143806139046, 0.10822878665048574, 0.12882373130233937, 0.15521668859217497, 0.12685077215466467, 0.13631258982624295, 0.11963021975109311, 0.14198744077937553, 0.1884463951848806, 0.15707715935116284, 0.14428696536945462, 0.18767839471464487, 0.1648871629847194, 0.1772486605267295, 0.22345653852978475, 0.20085786187474608, 0.23634875082293105, 0.2284210350338226, 0.20442360954123528, 0.18186545462102433, 0.14494029543340115, 0.10519731474646998, 0.10248143938280407, 0.15414262551551838, 0.1495603526752156, 0.15753533156199506, 0.12702279729038368, 0.09977761987478062, 0.14035251210035626, 0.2712069296629356, 0.3040013866002722, 0.27727957785578106, 0.3099146740165025, 0.2758908493113241, 0.3081885353657048, 0.31634686531685574, 0.30278327014564477, 0.3377426924180934, 0.1760472302781596, 0.17004981797893692, 0.21441310142483072, 0.19035004675221057, 0.1741151673738741, 0.19257492704098567, 0.18072560259841552, 0.18688829589339973, 0.1607472199215817, 0.14920546130912948, 0.1763607556362935, 0.16220606250571323, 0.15352897459529358, 0.1270225013474836, 0.44215005788607287, 0.1758505851198603, 0.15755678353653635, 0.13870790521746168, 0.16721781109989986, 0.32034384147380246, 0.14679101805151518, 0.13619447232071458, 0.12618855689928277, 0.1392387585652487, 0.13312851971017647, 0.11676918383806756, 0.13278919254113697, 0.19476239880962876, 0.17881840264025106, 0.19358819384226067, 0.2044508927477524, 0.22978499141327702, 0.23984313576599525, 0.1995808196577632, 0.18796496413794195, 0.20529559052269775, 0.06269921334241513, 0.0772068511452495, 0.06439283546228491, 0.06142308033846877, 0.08287435393593756, 0.05514386244760794, 0.06954374133068486, 0.08979860291605801, 0.05540460107660239]}, "mutation_prompt": null}
{"id": "0687844e-91ca-453d-99dc-19f3cfc74f9d", "solution": "import numpy as np\n\nclass HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.best_fitness = np.inf\n        self.chaotic_map = np.random.uniform(0, 1, self.dim)\n        self.adaptive_prob = 0.2\n        self.mutation_prob = 0.1\n        self.levy_flight_scale = 1.0\n        self.opposition_weight = 0.5\n        self.convergence_speed = 0.0\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def chaotic_opposition_based_learning(self, individual):\n        chaotic_individual = self.lower_bound + (self.upper_bound - self.lower_bound) * self.chaotic_map\n        self.chaotic_map = 4 * self.chaotic_map * (1 - self.chaotic_map)\n        return chaotic_individual\n\n    def levy_flight(self, individual):\n        levy_flight = np.random.normal(0, self.levy_flight_scale, self.dim) / np.random.normal(0, self.levy_flight_scale, self.dim)\n        levy_flight = individual + levy_flight\n        return levy_flight\n\n    def gaussian_mutation(self, individual):\n        gaussian_mutation = individual + np.random.normal(0, 0.1, self.dim)\n        return gaussian_mutation\n\n    def weighted_opposition_based_learning(self, individual):\n        opposite_individual = self.opposition_based_learning(individual)\n        weighted_individual = self.opposition_weight * individual + (1 - self.opposition_weight) * opposite_individual\n        return weighted_individual\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_individual = self.population[i]\n                    self.convergence_speed = 1.0 / (1.0 + evaluations / self.budget)\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                r3 = np.random.uniform(0, 1, self.dim)\n                r4 = np.random.uniform(0, 1, self.dim)\n                A = 2 * r1 - 1\n                B = np.abs(r2)\n                C = 2 * r3 - 1\n                D = np.abs(r4)\n                sine = np.abs(self.best_individual - self.population[i]) * np.sin(np.abs(r1) * np.pi)\n                cosine = np.abs(self.best_individual - self.population[i]) * np.cos(np.abs(r1) * np.pi)\n                if np.random.uniform(0, 1) < 0.5:\n                    self.population[i] = self.best_individual - (A * sine + B * cosine) * C * D\n                else:\n                    self.population[i] = self.best_individual + (A * sine + B * cosine) * C * D\n                levy_flight = self.levy_flight(self.population[i])\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                    self.levy_flight_scale *= 1.1 * (1.0 + self.convergence_speed)  # Increase the Levy flight scale if the Levy flight improves the fitness\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                        self.levy_flight_scale *= 0.9 / (1.0 + self.convergence_speed)  # Decrease the Levy flight scale if the Levy flight does not improve the fitness\n                self.levy_flight_scale = np.clip(self.levy_flight_scale, 0.1, 10.0)  # Clip the Levy flight scale to a reasonable range\n                # Apply adaptive chaotic opposition-based learning with a probability that adapts to the convergence speed\n                if np.random.uniform(0, 1) < self.adaptive_prob * (1.0 + self.convergence_speed):\n                    chaotic_individual = self.chaotic_opposition_based_learning(self.population[i])\n                    chaotic_fitness = func(chaotic_individual)\n                    evaluations += 1\n                    if chaotic_fitness < fitness:\n                        self.population[i] = chaotic_individual\n                        self.adaptive_prob *= 1.1  # Increase the probability if the chaotic opposition-based learning improves the fitness\n                    else:\n                        self.adaptive_prob *= 0.9  # Decrease the probability if the chaotic opposition-based learning does not improve the fitness\n                    self.adaptive_prob = np.clip(self.adaptive_prob, 0.1, 0.9)  # Clip the probability to a reasonable range\n                # Apply weighted opposition-based learning with a fixed probability\n                if np.random.uniform(0, 1) < 0.1:\n                    weighted_individual = self.weighted_opposition_based_learning(self.population[i])\n                    weighted_fitness = func(weighted_individual)\n                    evaluations += 1\n                    if weighted_fitness < fitness:\n                        self.population[i] = weighted_individual\n                # Apply Gaussian mutation with a fixed probability\n                if np.random.uniform(0, 1) < self.mutation_prob:\n                    gaussian_individual = self.gaussian_mutation(self.population[i])\n                    gaussian_fitness = func(gaussian_individual)\n                    evaluations += 1\n                    if gaussian_fitness < fitness:\n                        self.population[i] = gaussian_individual\n            # Dynamically adjust the population size based on the convergence speed\n            if evaluations > self.budget / 2 and self.population_size < self.initial_population_size * 2:\n                self.population_size = int(self.population_size * (1 + self.convergence_speed))\n                self.population = np.vstack((self.population, np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(self.population), self.dim))))\n        return self.best_individual", "name": "HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v3", "description": "Hybrid Sine Cosine Algorithm with Levy Flight, Simulated Annealing, Adaptive Chaotic Opposition-Based Learning, Gaussian Mutation, and Dynamic Population Size, incorporating a new weighted opposition-based learning strategy, an adaptive Levy flight scale, and a novel convergence speed-based dynamic population size adjustment.", "configspace": "", "generation": 21, "fitness": 0.18303885746162257, "feedback": "The algorithm HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": "22e3da69-2087-41fc-a640-8af8824eae69", "metadata": {"aucs": [0.3516571202745594, 0.377200409834765, 0.31616156583499, 0.31084752980138053, 0.3218877796911438, 0.2044006681242333, 0.20457905596980486, 0.28094143493798673, 0.3673913281871487, 0.0038660102015961595, 9.999999999998899e-05, 0.009662487881093695, 9.999999999998899e-05, 9.999999999998899e-05, 0.022059125681539227, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13124559648640266, 0.07569219833190222, 0.07115973236750706, 0.052830585353126125, 0.07451599295978617, 0.04659773060062977, 0.08592031932949162, 0.07972044695143832, 0.06974658272588274, 0.11230812165931747, 0.05953881382754078, 0.07482931331982201, 0.07650451622010934, 0.059714070592374435, 0.06792210565092627, 0.061331799047409596, 0.04893296498359234, 0.05614227271335781, 0.9776291666466989, 0.9666757027924954, 0.964005580457114, 0.9694808424230447, 0.9346893160917074, 0.9797817399553435, 0.9701596045651263, 0.9229068668184005, 0.9774149612312324, 0.26323335073279275, 0.2511098552139196, 0.26310166221222486, 0.22950605040237737, 0.2025015281815966, 0.12302513336219212, 0.24799905253727306, 0.1616786301885189, 0.22374777174502714, 0.21217309106363924, 0.17249109056441558, 0.18497145167480067, 0.18886182737352075, 0.09125905995801764, 0.1405512182882287, 0.23625844312587874, 0.15724955540438335, 0.20775048518428196, 0.1106835340147263, 0.13772515505480187, 0.11829166203051023, 0.11568954470192927, 0.12424589701999955, 0.11373202465016308, 0.11694164921902139, 0.14448346726662553, 0.11671692181736215, 0.20319011562958644, 0.17274345718015682, 0.19407225455288557, 0.18578490902977618, 0.18645889535932803, 0.16659978044933976, 0.18853067473585683, 0.20615099016463934, 0.18355416177390815, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03855191412258152, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.051257293514774926, 0.027943773039116993, 0.061939225284665556, 0.07122887963235858, 0.0452941628863075, 0.013056699433146468, 0.08873925851887765, 0.05049466249365908, 0.08366917946158414, 0.008345534612016814, 0.015369104006413226, 9.999999999998899e-05, 9.999999999998899e-05, 0.011630282661735492, 0.013547727429551792, 0.0003359016545633198, 9.999999999998899e-05, 9.999999999998899e-05, 0.06221730251256341, 0.003587842350854631, 0.09418521337572328, 0.08435713177456872, 0.025000935529598478, 0.046866320694373687, 0.10031839826028621, 0.09311956009635414, 0.05619400049718892, 0.24535491229441164, 0.20743543758061178, 0.30244365585004573, 0.19325105923320407, 0.36645981234156466, 0.36503159924166884, 0.290720543965006, 0.30304266274023606, 0.31494467881348664, 0.09666487909709975, 0.1079004895815604, 0.06655190424878843, 0.10995390428435281, 0.07518865106552752, 0.07367974841908342, 0.07855967713045353, 0.10301763480270365, 0.06433626980679508, 0.16334064408747107, 0.1554059676174664, 0.2169003670429246, 0.1729528007210025, 0.18216321096651977, 0.15074494699037133, 0.15707732004131536, 0.150161545672701, 0.1734041570202538, 0.19424774030001457, 0.1991923029657502, 0.2100987123086302, 0.2218954627544265, 0.18874914931550957, 0.1777476228284326, 0.16189747210474648, 0.21417055440557498, 0.19303760788085234, 0.12752191516358868, 0.1781727649251258, 0.12398953039277982, 0.15052013395552044, 0.1948632291788004, 0.14540709558788567, 0.10817139832328904, 0.09961258435752274, 0.11617857572791523, 0.29524089418943844, 0.2810570948250989, 0.3226859830748151, 0.302572666933113, 0.28794100017049207, 0.2831434474691339, 0.2863401650578914, 0.27207525077699124, 0.29943735941885175, 0.16641085889226703, 0.1801332434605123, 0.17576199379888235, 0.2026743232019108, 0.17795824498665513, 0.16453455866117017, 0.17196498549434158, 0.1771390887264842, 0.17034216710715777, 0.6526295697915376, 0.4182504040259587, 0.2573508155650356, 0.15320049762414534, 0.14803487580961316, 0.38404254816730576, 0.5683911948514588, 0.18555428208867297, 0.14661876535338247, 0.18363558657781442, 0.22767786319272432, 0.13352647915681615, 0.1760570481907695, 0.19093261498986613, 0.14834371056844953, 0.14523338742597136, 0.27630738187890647, 0.4111843876442708, 0.1924853722643627, 0.18910133934183204, 0.17149155922880543, 0.1934480509154226, 0.179863832423229, 0.20585252701605883, 0.1811081588528557, 0.1944770859075956, 0.1683502104729565, 0.07160003920988223, 0.07746134690748951, 0.10214170873016426, 0.07125255577757128, 0.07269064289207239, 0.07255373789238806, 0.06726571145179727, 0.09725239658302365, 0.08128374733347488]}, "mutation_prompt": null}
{"id": "3577fc40-06df-4c42-be7b-bdcd2d2386b4", "solution": "import numpy as np\n\nclass HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.best_fitness = np.inf\n        self.chaotic_map = np.random.uniform(0, 1, self.dim)\n        self.adaptive_prob = 0.2\n        self.mutation_prob = 0.1\n        self.levy_flight_scale = 1.0\n        self.opposition_weight = 0.5\n        self.convergence_speed = 0.0\n        self.mutation_prob_history = [self.mutation_prob]\n        self.mutation_prob_learning_rate = 0.1\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def chaotic_opposition_based_learning(self, individual):\n        chaotic_individual = self.lower_bound + (self.upper_bound - self.lower_bound) * self.chaotic_map\n        self.chaotic_map = 4 * self.chaotic_map * (1 - self.chaotic_map)\n        return chaotic_individual\n\n    def levy_flight(self, individual):\n        levy_flight = np.random.normal(0, self.levy_flight_scale, self.dim) / np.random.normal(0, self.levy_flight_scale, self.dim)\n        levy_flight = individual + levy_flight\n        return levy_flight\n\n    def gaussian_mutation(self, individual):\n        gaussian_mutation = individual + np.random.normal(0, 0.1, self.dim)\n        return gaussian_mutation\n\n    def weighted_opposition_based_learning(self, individual):\n        opposite_individual = self.opposition_based_learning(individual)\n        weighted_individual = self.opposition_weight * individual + (1 - self.opposition_weight) * opposite_individual\n        return weighted_individual\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_individual = self.population[i]\n                    self.convergence_speed = 1.0 / (1.0 + evaluations / self.budget)\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                r3 = np.random.uniform(0, 1, self.dim)\n                r4 = np.random.uniform(0, 1, self.dim)\n                A = 2 * r1 - 1\n                B = np.abs(r2)\n                C = 2 * r3 - 1\n                D = np.abs(r4)\n                sine = np.abs(self.best_individual - self.population[i]) * np.sin(np.abs(r1) * np.pi)\n                cosine = np.abs(self.best_individual - self.population[i]) * np.cos(np.abs(r1) * np.pi)\n                if np.random.uniform(0, 1) < 0.5:\n                    self.population[i] = self.best_individual - (A * sine + B * cosine) * C * D\n                else:\n                    self.population[i] = self.best_individual + (A * sine + B * cosine) * C * D\n                levy_flight = self.levy_flight(self.population[i])\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                    self.levy_flight_scale *= 1.1 * (1.0 + self.convergence_speed)  # Increase the Levy flight scale if the Levy flight improves the fitness\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                        self.levy_flight_scale *= 0.9 / (1.0 + self.convergence_speed)  # Decrease the Levy flight scale if the Levy flight does not improve the fitness\n                self.levy_flight_scale = np.clip(self.levy_flight_scale, 0.1, 10.0)  # Clip the Levy flight scale to a reasonable range\n                # Apply adaptive chaotic opposition-based learning with a probability that adapts to the convergence speed\n                if np.random.uniform(0, 1) < self.adaptive_prob * (1.0 + self.convergence_speed):\n                    chaotic_individual = self.chaotic_opposition_based_learning(self.population[i])\n                    chaotic_fitness = func(chaotic_individual)\n                    evaluations += 1\n                    if chaotic_fitness < fitness:\n                        self.population[i] = chaotic_individual\n                        self.adaptive_prob *= 1.1  # Increase the probability if the chaotic opposition-based learning improves the fitness\n                    else:\n                        self.adaptive_prob *= 0.9  # Decrease the probability if the chaotic opposition-based learning does not improve the fitness\n                    self.adaptive_prob = np.clip(self.adaptive_prob, 0.1, 0.9)  # Clip the probability to a reasonable range\n                # Apply weighted opposition-based learning with a fixed probability\n                if np.random.uniform(0, 1) < 0.1:\n                    weighted_individual = self.weighted_opposition_based_learning(self.population[i])\n                    weighted_fitness = func(weighted_individual)\n                    evaluations += 1\n                    if weighted_fitness < fitness:\n                        self.population[i] = weighted_individual\n                # Apply Gaussian mutation with a self-adaptive probability\n                if np.random.uniform(0, 1) < self.mutation_prob:\n                    gaussian_individual = self.gaussian_mutation(self.population[i])\n                    gaussian_fitness = func(gaussian_individual)\n                    evaluations += 1\n                    if gaussian_fitness < fitness:\n                        self.population[i] = gaussian_individual\n                        self.mutation_prob += self.mutation_prob_learning_rate * (1.0 - self.convergence_speed)  # Increase the mutation probability if the Gaussian mutation improves the fitness\n                    else:\n                        self.mutation_prob -= self.mutation_prob_learning_rate * (1.0 - self.convergence_speed)  # Decrease the mutation probability if the Gaussian mutation does not improve the fitness\n                    self.mutation_prob = np.clip(self.mutation_prob, 0.01, 0.5)  # Clip the mutation probability to a reasonable range\n                    self.mutation_prob_history.append(self.mutation_prob)\n            # Dynamically adjust the population size based on the convergence speed\n            if evaluations > self.budget / 2 and self.population_size < self.initial_population_size * 2:\n                self.population_size = int(self.population_size * (1 + self.convergence_speed))\n                self.population = np.vstack((self.population, np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(self.population), self.dim))))\n        return self.best_individual", "name": "HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v4", "description": "Hybrid Sine Cosine Algorithm with Levy Flight, Simulated Annealing, Adaptive Chaotic Opposition-Based Learning, Gaussian Mutation, and Dynamic Population Size, incorporating a new weighted opposition-based learning strategy, an adaptive Levy flight scale, and a novel convergence speed-based dynamic population size adjustment, and an additional self-adaptive Gaussian mutation probability.", "configspace": "", "generation": 22, "fitness": 0.1791256188611275, "feedback": "The algorithm HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": "0687844e-91ca-453d-99dc-19f3cfc74f9d", "metadata": {"aucs": [0.388986908413409, 0.3865564584325384, 0.3639152127329005, 0.2574740298901347, 0.39165919635748414, 0.41135620309596843, 0.3070217284094494, 0.3132670081105774, 0.31466219481431124, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015551227704954762, 9.999999999998899e-05, 0.006450178465572609, 9.999999999998899e-05, 9.999999999998899e-05, 0.03219413567770457, 0.1350165783712468, 0.09487735224646043, 0.06379396855094421, 0.06589003811650995, 0.1030499240579571, 0.0572992029023659, 0.08002647288636366, 0.08493999630520521, 0.09474974631352184, 0.08645170045261352, 0.05919883730152253, 0.05683082527814165, 0.054668421507527265, 0.055489130002859044, 0.05950325766892273, 0.04585180377565934, 0.09279115055738418, 0.07983293200092012, 0.9776291666466989, 0.9464861494234489, 0.9186339268275842, 0.9694808424230447, 0.9354545308894073, 0.9796911678438053, 0.9701596045651263, 0.8582716014974158, 0.9774149612312324, 0.23386186472075998, 0.17368640547010294, 0.1972113669350234, 0.22992998062807968, 0.26061385180631935, 0.15552104218121876, 0.15929125715316694, 0.2267032106879472, 0.22721964864968314, 0.21442557667766893, 0.21799064635239573, 0.1527485717221707, 0.13360487012524247, 0.15200894577080837, 0.1877151811808837, 0.18362262015945263, 0.1666013095688802, 0.1349581756804793, 0.1533162005561831, 0.125336742001817, 0.12165251896832396, 0.10672407445147569, 0.1409832472926299, 0.13584081167184536, 0.09515973345249773, 0.1148326960284437, 0.13651218353989625, 0.18620118923041806, 0.15009898822363388, 0.16900903045305526, 0.18534378137299723, 0.1702915813352467, 0.16968535176639998, 0.1972580100718293, 0.1797773586902267, 0.1782848989948721, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.014622658741199501, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.047981446167935204, 0.04665115304489664, 0.05778147780033982, 0.06893074122042286, 0.022266506183774126, 0.010910854770961653, 0.11437508758478465, 0.06425473964106843, 0.04578546954270135, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03663390226693941, 9.999999999998899e-05, 0.032956049122519815, 0.006636425136920643, 9.999999999998899e-05, 0.001414670722733713, 0.042147685776589006, 0.04387535461654912, 0.11172020257219706, 0.05090374875408599, 0.07680632033357793, 0.04788375795042099, 0.0675890983083638, 0.06871850729001994, 0.03217394614832081, 0.29792639939709675, 0.21854888889065804, 0.32871114168135607, 0.2042004924180617, 0.3607145696180263, 0.2508570761285197, 0.36098687217529346, 0.340041206518895, 0.2985138631543601, 0.08380827646367539, 0.07234995323981075, 0.05452701631444523, 0.10445595177270783, 0.08057874482519178, 0.06952704756249117, 0.08391115212195577, 0.07975515655336307, 0.05303134058745107, 0.13646654987080287, 0.1752118189582914, 0.12741136449410317, 0.14153621013250273, 0.24093970767098538, 0.14420275022987594, 0.22906776519750616, 0.17279055129468668, 0.12472677170049884, 0.1692050776093278, 0.17569006456945302, 0.17468008266084967, 0.1883790798072078, 0.17898496987389723, 0.19460064293923196, 0.17084218399432716, 0.21417055440557498, 0.23418203510764957, 0.1444735839519915, 0.14022779648725137, 0.13195075217455032, 0.1108847659218154, 0.1764591455765845, 0.14335524116555098, 0.1583520558804099, 0.12160929759845696, 0.11634950530785004, 0.2774701325499368, 0.28165866222435343, 0.3017593341107486, 0.27263150820391935, 0.29020503941796183, 0.3311924918386173, 0.33973208820242673, 0.3057262564405242, 0.25940917511953554, 0.17352014128945792, 0.16973130543074144, 0.18822910604308307, 0.20230440765109847, 0.17789879274772868, 0.1914753635370312, 0.19954281228405357, 0.1710626047159347, 0.18044930155738437, 0.2421555682760701, 0.15889786592754995, 0.3342361599502057, 0.2011213535909424, 0.14803922161180105, 0.2963449758900849, 0.4702829145615254, 0.12938962403501952, 0.15893137032862925, 0.18610397801032674, 0.14581000392900312, 0.19626409538560252, 0.18207744589434394, 0.22497403147879558, 0.13097667125015944, 0.19878803655388932, 0.12280209913120144, 0.26540335731113907, 0.18755383067007603, 0.19971517468936006, 0.18901626510451675, 0.20827672836382816, 0.21697241339175388, 0.23296826017032402, 0.1830702848147997, 0.21160099797641185, 0.18513835784122346, 0.1028333589909256, 0.06251086961520536, 0.06068821108511069, 0.07583050567333971, 0.06202373669816874, 0.06575883013170569, 0.06730581455473328, 0.0790375042556869, 0.08351926047266511]}, "mutation_prompt": null}
{"id": "c7aea73e-69f3-4328-b004-195c91f0148e", "solution": "import numpy as np\n\nclass HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.best_fitness = np.inf\n        self.chaotic_map = np.random.uniform(0, 1, self.dim)\n        self.adaptive_prob = 0.2\n        self.mutation_prob = 0.1\n        self.levy_flight_scale = 1.0\n        self.opposition_weight = 0.5\n        self.convergence_speed = 0.0\n        self.adaptive_opposition_weight = 0.5\n        self.adaptive_opposition_weight_step = 0.01\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def chaotic_opposition_based_learning(self, individual):\n        chaotic_individual = self.lower_bound + (self.upper_bound - self.lower_bound) * self.chaotic_map\n        self.chaotic_map = 4 * self.chaotic_map * (1 - self.chaotic_map)\n        return chaotic_individual\n\n    def levy_flight(self, individual):\n        levy_flight = np.random.normal(0, self.levy_flight_scale, self.dim) / np.random.normal(0, self.levy_flight_scale, self.dim)\n        levy_flight = individual + levy_flight\n        return levy_flight\n\n    def gaussian_mutation(self, individual):\n        gaussian_mutation = individual + np.random.normal(0, 0.1, self.dim)\n        return gaussian_mutation\n\n    def weighted_opposition_based_learning(self, individual):\n        opposite_individual = self.opposition_based_learning(individual)\n        weighted_individual = self.adaptive_opposition_weight * individual + (1 - self.adaptive_opposition_weight) * opposite_individual\n        return weighted_individual\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_individual = self.population[i]\n                    self.convergence_speed = 1.0 / (1.0 + evaluations / self.budget)\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                r3 = np.random.uniform(0, 1, self.dim)\n                r4 = np.random.uniform(0, 1, self.dim)\n                A = 2 * r1 - 1\n                B = np.abs(r2)\n                C = 2 * r3 - 1\n                D = np.abs(r4)\n                sine = np.abs(self.best_individual - self.population[i]) * np.sin(np.abs(r1) * np.pi)\n                cosine = np.abs(self.best_individual - self.population[i]) * np.cos(np.abs(r1) * np.pi)\n                if np.random.uniform(0, 1) < 0.5:\n                    self.population[i] = self.best_individual - (A * sine + B * cosine) * C * D\n                else:\n                    self.population[i] = self.best_individual + (A * sine + B * cosine) * C * D\n                levy_flight = self.levy_flight(self.population[i])\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                    self.levy_flight_scale *= 1.1 * (1.0 + self.convergence_speed)  # Increase the Levy flight scale if the Levy flight improves the fitness\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                        self.levy_flight_scale *= 0.9 / (1.0 + self.convergence_speed)  # Decrease the Levy flight scale if the Levy flight does not improve the fitness\n                self.levy_flight_scale = np.clip(self.levy_flight_scale, 0.1, 10.0)  # Clip the Levy flight scale to a reasonable range\n                # Apply adaptive chaotic opposition-based learning with a probability that adapts to the convergence speed\n                if np.random.uniform(0, 1) < self.adaptive_prob * (1.0 + self.convergence_speed):\n                    chaotic_individual = self.chaotic_opposition_based_learning(self.population[i])\n                    chaotic_fitness = func(chaotic_individual)\n                    evaluations += 1\n                    if chaotic_fitness < fitness:\n                        self.population[i] = chaotic_individual\n                        self.adaptive_prob *= 1.1  # Increase the probability if the chaotic opposition-based learning improves the fitness\n                    else:\n                        self.adaptive_prob *= 0.9  # Decrease the probability if the chaotic opposition-based learning does not improve the fitness\n                    self.adaptive_prob = np.clip(self.adaptive_prob, 0.1, 0.9)  # Clip the probability to a reasonable range\n                # Apply adaptive weighted opposition-based learning with a fixed probability\n                if np.random.uniform(0, 1) < 0.1:\n                    weighted_individual = self.weighted_opposition_based_learning(self.population[i])\n                    weighted_fitness = func(weighted_individual)\n                    evaluations += 1\n                    if weighted_fitness < fitness:\n                        self.population[i] = weighted_individual\n                        self.adaptive_opposition_weight += self.adaptive_opposition_weight_step  # Increase the adaptive opposition weight if the weighted opposition-based learning improves the fitness\n                    else:\n                        self.adaptive_opposition_weight -= self.adaptive_opposition_weight_step  # Decrease the adaptive opposition weight if the weighted opposition-based learning does not improve the fitness\n                    self.adaptive_opposition_weight = np.clip(self.adaptive_opposition_weight, 0.1, 0.9)  # Clip the adaptive opposition weight to a reasonable range\n                # Apply Gaussian mutation with a fixed probability\n                if np.random.uniform(0, 1) < self.mutation_prob:\n                    gaussian_individual = self.gaussian_mutation(self.population[i])\n                    gaussian_fitness = func(gaussian_individual)\n                    evaluations += 1\n                    if gaussian_fitness < fitness:\n                        self.population[i] = gaussian_individual\n            # Dynamically adjust the population size based on the convergence speed\n            if evaluations > self.budget / 2 and self.population_size < self.initial_population_size * 2:\n                self.population_size = int(self.population_size * (1 + self.convergence_speed))\n                self.population = np.vstack((self.population, np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(self.population), self.dim))))\n        return self.best_individual", "name": "HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v4", "description": "Hybrid Sine Cosine Algorithm with Levy Flight, Simulated Annealing, Adaptive Chaotic Opposition-Based Learning, Gaussian Mutation, Dynamic Population Size, and Adaptive Levy Flight Scale, incorporating a novel adaptive weighted opposition-based learning strategy and a convergence speed-based dynamic population size adjustment.", "configspace": "", "generation": 23, "fitness": 0.17853345556998523, "feedback": "The algorithm HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": "0687844e-91ca-453d-99dc-19f3cfc74f9d", "metadata": {"aucs": [0.31043862375259534, 0.37497212434787763, 0.3609035583707183, 0.31801456669907646, 0.325221748353108, 0.26658086609264775, 0.42486731905900865, 0.3483409394740342, 0.39772066764598, 0.0038658395695303494, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.033138890742105964, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0744393034143892, 0.08270880476943754, 0.10700012192888175, 0.0711166809915802, 0.06551974803786709, 0.07197545830763152, 0.0869368498996258, 0.07974547654270969, 0.09946111313114037, 0.11079578374036514, 0.05953881382754078, 0.07294591358096836, 0.0833211700585762, 0.14327883382782347, 0.06589548454077576, 0.06807925949577098, 0.052354048803384456, 0.07817076450321203, 0.9776291651118206, 0.9666757027924954, 0.964005580457114, 0.9694808424230447, 0.9354774078370399, 0.9797817399553435, 0.9701596045651263, 0.9259172275732387, 0.9774149612312324, 0.2625221645366236, 0.2367788575438433, 0.22912176403690676, 0.2305598170103228, 0.2033510735898716, 0.12976308995597718, 0.2484889446678893, 0.1331465341384388, 0.2232684459882306, 0.1515701605637505, 0.21735424374018497, 0.20134135390564822, 0.18886182737352075, 0.09125905995801764, 0.1405768070294634, 0.23277163878406426, 0.1643196728316596, 0.20775048518428196, 0.22670462990054918, 0.12533294660455707, 0.1599744040824278, 0.11555332003695462, 0.1234076852927648, 0.12673115274470725, 0.1173775594181723, 0.1448809497614988, 0.11115688977881455, 0.20453975490133836, 0.21347789150277985, 0.17789605107984185, 0.18610104248089931, 0.184713437734651, 0.16466044560630322, 0.20034991571164418, 0.1710435023844804, 0.1838618271382333, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03857785207099618, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04749090701747938, 0.026752340265449703, 0.06157408865626335, 0.07111796798117465, 0.04594094701456708, 0.013048687737713172, 0.08952046914242351, 0.0663913968638914, 0.0836691794619896, 0.01214630745812606, 0.00945520856922033, 0.010374752603347637, 9.999999999998899e-05, 9.999999999998899e-05, 0.027170165055584894, 0.0026597240428398727, 9.999999999998899e-05, 9.999999999998899e-05, 0.06146533338893245, 0.012528866836855945, 0.0679996960096394, 0.0647904952692605, 0.02602134498214126, 0.046829722647681815, 0.10031839826028621, 0.09311956009635636, 0.0561191795841276, 0.17663173000155108, 0.20752770609488835, 0.27936680766568966, 0.35329050788777117, 0.3380246210590795, 0.18891311353809148, 0.2781223909817774, 0.2255521969911689, 0.23216180434765388, 0.0495802283751422, 0.03796821260901184, 0.052921779935553026, 0.06534396245744101, 0.08880634640992524, 0.07367973165309305, 0.08498151790071384, 0.09091581075752053, 0.04371884195250275, 0.13646734588514386, 0.15174844893988026, 0.2483749951117683, 0.15568410518330367, 0.21253157142981416, 0.12900657051474462, 0.15699513414228927, 0.20524413730202307, 0.16487132043167807, 0.13157016276364697, 0.21219734800080947, 0.20180898007503312, 0.16337093808096304, 0.17145764150873344, 0.19253955824421598, 0.17098207472494087, 0.20392949058636445, 0.2457096616464609, 0.1768361597151965, 0.18918065401344375, 0.13106605977665964, 0.1877497741227826, 0.13482422598530097, 0.11412089036093698, 0.16374977514274758, 0.09961258435752274, 0.1090037865657012, 0.26001327203390445, 0.2645575516044548, 0.2884526445093949, 0.26003178371410274, 0.26002959320093677, 0.2600363953095588, 0.26222944122003544, 0.2600199896768747, 0.26676595627578903, 0.1558496364451466, 0.18015463308753477, 0.17581043187755307, 0.20583988685930898, 0.17796329580154013, 0.16441191675428213, 0.17144400844408558, 0.17738414571127703, 0.17061720154021354, 0.3867984969533179, 0.1659872636646531, 0.31821255758320954, 0.3411555935546652, 0.13870366875097373, 0.1527291129228523, 0.4765062510369318, 0.16178545178759396, 0.1462256992605515, 0.18821942543972425, 0.13394053158769015, 0.3234804790821143, 0.15601288108165523, 0.12213370169902049, 0.17891604791445603, 0.16035909260875192, 0.14539388821794197, 0.21077335010034925, 0.19099962584716257, 0.18011023505197776, 0.1814830528847321, 0.19352688744788404, 0.23475161828513924, 0.21094189868145163, 0.18156695668080525, 0.22848398911497214, 0.1921190517467557, 0.04023561543571619, 0.07821963003825727, 0.05829077906171276, 0.058194014056311194, 0.07679664426501309, 0.08693255051286164, 0.0715914557026075, 0.07927707036894649, 0.05117640192089512]}, "mutation_prompt": null}
{"id": "2226aa4a-9123-4f1b-a4b0-a2485891159f", "solution": "import numpy as np\n\nclass HybridSCA_SA_ACOBL_GM_DPS_AEBS_Refined_v4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.best_fitness = np.inf\n        self.chaotic_map = np.random.uniform(0, 1, self.dim)\n        self.adaptive_prob = 0.2\n        self.mutation_prob = 0.1\n        self.levy_flight_scale = 1.0\n        self.opposition_weight = 0.5\n        self.convergence_speed = 0.0\n        self.exploitation_prob = 0.5\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def chaotic_opposition_based_learning(self, individual):\n        chaotic_individual = self.lower_bound + (self.upper_bound - self.lower_bound) * self.chaotic_map\n        self.chaotic_map = 4 * self.chaotic_map * (1 - self.chaotic_map)\n        return chaotic_individual\n\n    def levy_flight(self, individual):\n        levy_flight = np.random.normal(0, self.levy_flight_scale, self.dim) / np.random.normal(0, self.levy_flight_scale, self.dim)\n        levy_flight = individual + levy_flight\n        return levy_flight\n\n    def gaussian_mutation(self, individual):\n        gaussian_mutation = individual + np.random.normal(0, 0.1, self.dim)\n        return gaussian_mutation\n\n    def weighted_opposition_based_learning(self, individual):\n        opposite_individual = self.opposition_based_learning(individual)\n        weighted_individual = self.opposition_weight * individual + (1 - self.opposition_weight) * opposite_individual\n        return weighted_individual\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_individual = self.population[i]\n                    self.convergence_speed = 1.0 / (1.0 + evaluations / self.budget)\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                r3 = np.random.uniform(0, 1, self.dim)\n                r4 = np.random.uniform(0, 1, self.dim)\n                A = 2 * r1 - 1\n                B = np.abs(r2)\n                C = 2 * r3 - 1\n                D = np.abs(r4)\n                sine = np.abs(self.best_individual - self.population[i]) * np.sin(np.abs(r1) * np.pi)\n                cosine = np.abs(self.best_individual - self.population[i]) * np.cos(np.abs(r1) * np.pi)\n                if np.random.uniform(0, 1) < self.exploitation_prob:\n                    self.population[i] = self.best_individual - (A * sine + B * cosine) * C * D\n                else:\n                    self.population[i] = self.best_individual + (A * sine + B * cosine) * C * D\n                levy_flight = self.levy_flight(self.population[i])\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                    self.levy_flight_scale *= 1.1 * (1.0 + self.convergence_speed)  # Increase the Levy flight scale if the Levy flight improves the fitness\n                    self.exploitation_prob *= 0.9  # Decrease the exploitation probability if the Levy flight improves the fitness\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                        self.levy_flight_scale *= 0.9 / (1.0 + self.convergence_speed)  # Decrease the Levy flight scale if the Levy flight does not improve the fitness\n                        self.exploitation_prob *= 1.1  # Increase the exploitation probability if the Levy flight does not improve the fitness\n                self.levy_flight_scale = np.clip(self.levy_flight_scale, 0.1, 10.0)  # Clip the Levy flight scale to a reasonable range\n                self.exploitation_prob = np.clip(self.exploitation_prob, 0.1, 0.9)  # Clip the exploitation probability to a reasonable range\n                # Apply adaptive chaotic opposition-based learning with a probability that adapts to the convergence speed\n                if np.random.uniform(0, 1) < self.adaptive_prob * (1.0 + self.convergence_speed):\n                    chaotic_individual = self.chaotic_opposition_based_learning(self.population[i])\n                    chaotic_fitness = func(chaotic_individual)\n                    evaluations += 1\n                    if chaotic_fitness < fitness:\n                        self.population[i] = chaotic_individual\n                        self.adaptive_prob *= 1.1  # Increase the probability if the chaotic opposition-based learning improves the fitness\n                    else:\n                        self.adaptive_prob *= 0.9  # Decrease the probability if the chaotic opposition-based learning does not improve the fitness\n                    self.adaptive_prob = np.clip(self.adaptive_prob, 0.1, 0.9)  # Clip the probability to a reasonable range\n                # Apply weighted opposition-based learning with a fixed probability\n                if np.random.uniform(0, 1) < 0.1:\n                    weighted_individual = self.weighted_opposition_based_learning(self.population[i])\n                    weighted_fitness = func(weighted_individual)\n                    evaluations += 1\n                    if weighted_fitness < fitness:\n                        self.population[i] = weighted_individual\n                # Apply Gaussian mutation with a fixed probability\n                if np.random.uniform(0, 1) < self.mutation_prob:\n                    gaussian_individual = self.gaussian_mutation(self.population[i])\n                    gaussian_fitness = func(gaussian_individual)\n                    evaluations += 1\n                    if gaussian_fitness < fitness:\n                        self.population[i] = gaussian_individual\n            # Dynamically adjust the population size based on the convergence speed\n            if evaluations > self.budget / 2 and self.population_size < self.initial_population_size * 2:\n                self.population_size = int(self.population_size * (1 + self.convergence_speed))\n                self.population = np.vstack((self.population, np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(self.population), self.dim))))\n        return self.best_individual", "name": "HybridSCA_SA_ACOBL_GM_DPS_AEBS_Refined_v4", "description": "Hybrid Sine Cosine Algorithm with Levy Flight, Simulated Annealing, Adaptive Chaotic Opposition-Based Learning, Gaussian Mutation, Dynamic Population Size, and Novel Adaptive Exploration-Exploitation Balance Strategy.", "configspace": "", "generation": 24, "fitness": 0.18134990943195645, "feedback": "The algorithm HybridSCA_SA_ACOBL_GM_DPS_AEBS_Refined_v4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": "0687844e-91ca-453d-99dc-19f3cfc74f9d", "metadata": {"aucs": [0.39137066777416374, 0.39588599749812015, 0.3767789419404274, 0.2428963075475422, 0.2797026634451719, 0.3727156216994242, 0.20457905596980486, 0.2006952066126486, 0.3099185528448444, 0.1167193866500813, 0.0011944039909800308, 9.999999999998899e-05, 0.03385878148461818, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06309353888074076, 9.999999999998899e-05, 0.14728424094793158, 0.07946656899405458, 0.05350457152520993, 0.08626799723113032, 0.05747510261029942, 0.07760037475772175, 0.07908279302557952, 0.07890281004496136, 0.08618443679337195, 0.04946710927226361, 0.09266943910650749, 0.05497587330172249, 0.08347379848582515, 0.09033586836194973, 0.06363573126759037, 0.05484748918605187, 0.07417631194130392, 0.03870612466478285, 0.976996036527335, 0.965936930533484, 0.9469174457303571, 0.9690338770581913, 0.9386491760563559, 0.9637713344168636, 0.9706143394588505, 0.9120243786743036, 0.9830976557541181, 0.2436230077637539, 0.263363525513303, 0.17210202162103416, 0.27361048484041905, 0.2242135512445399, 0.25213454874716024, 0.20711148371654475, 0.2240323925236044, 0.19666675567754333, 0.20140359807727248, 0.18710590408679373, 0.13523774956722756, 0.14377066092595192, 0.15960729335061152, 0.24373418349848663, 0.19729146721999413, 0.2827411541750029, 0.15486497467713833, 0.12222011782462683, 0.14266248446850072, 0.1241933422097321, 0.11720814306584837, 0.23017983142702458, 0.12875589426781864, 0.11178049599433271, 0.14586261647209176, 0.11977559051233744, 0.1758977061552589, 0.18860847709198147, 0.17491547240906946, 0.1707749966549068, 0.17777792806948023, 0.17865907906047318, 0.1512695162840917, 0.2066974367821376, 0.1939075224163498, 9.999999999998899e-05, 9.999999999998899e-05, 0.014211550714486099, 0.03472423704900407, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0034991997768445415, 0.05918016879442456, 0.02652121353347503, 0.09948469935345716, 0.06681715605995509, 0.00681875071397664, 0.018333786275136488, 0.119925023552229, 0.021086893234757542, 0.0634896975259136, 9.999999999998899e-05, 0.013895918189348766, 0.005206878830621875, 0.033899867061688016, 0.0006077670842788985, 0.02345730480748498, 0.04008001465530486, 0.024777250369473536, 0.002222758855170981, 0.003852144194926632, 0.04879130408097643, 0.06665649376046912, 0.0609416442140317, 0.13861101264198072, 9.999999999998899e-05, 0.09715294031032917, 0.052596821822986195, 0.10528825866430758, 0.35108680250820157, 0.2193004127800272, 0.20383381680266743, 0.3627230246632981, 0.19049425122810448, 0.20978051685880128, 0.2857815172183322, 0.3716899640342852, 0.378912898059067, 0.09391452081150742, 0.06544403763372142, 0.06137686219151128, 0.07377640659115592, 0.11212137122604204, 0.06039463589201988, 0.08810884329786672, 0.07971480492314786, 0.08397871658612988, 0.14641760022848116, 0.17433761735177244, 0.13016778562243303, 0.17497186189774272, 0.18121289554716835, 0.14804642546992997, 0.23667100886246084, 0.16809737498406774, 0.13906884880438009, 0.22149416157513147, 0.23929743384207136, 0.16113934942553843, 0.20476394710356005, 0.226300518227725, 0.1894878575893153, 0.20135080477584666, 0.18353580536645175, 0.1809882905727892, 0.12635766974804885, 0.11125633034945526, 0.1478870837817332, 0.15073741089333104, 0.14244567318972223, 0.17816424452577317, 0.1551421605852623, 0.1025274540676, 0.16846211857609195, 0.2994018452377031, 0.2883899003859214, 0.2758790078951481, 0.27235460313700866, 0.2994101299152605, 0.2931173629422519, 0.3158240782090508, 0.28691395358144867, 0.34208494491394636, 0.19093360610117738, 0.18070339191189122, 0.17230666785609505, 0.22879376442091448, 0.1696497088906015, 0.16833863130180549, 0.17361220816118716, 0.16901999662057732, 0.1695668690537483, 0.17001110628538796, 0.41909929299303894, 0.17754223581733242, 0.33804679229369927, 0.1692974386090571, 0.13047926264071597, 0.16727862490123357, 0.16117242751075478, 0.2195155857638007, 0.1959554376719942, 0.12993735313355392, 0.17607555770282657, 0.15040231416224303, 0.2041837949927603, 0.1754793669984449, 0.113425514227119, 0.20576803183528236, 0.3710764538764877, 0.20501910642026566, 0.20884265134275493, 0.18124194804876592, 0.1997342149661545, 0.19357289659502064, 0.24782780106594782, 0.16967053258169562, 0.20573660482724232, 0.1921307702372862, 0.11611664669076605, 0.06760666755151179, 0.05646453873352164, 0.0697260282742278, 0.06811529193343357, 0.07711042543557545, 0.06601175869364928, 0.07771686052321025, 0.07342618857415417]}, "mutation_prompt": null}
{"id": "951ad953-5f94-4706-bb9e-3d3199dd2e8c", "solution": "import numpy as np\n\nclass HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.best_fitness = np.inf\n        self.chaotic_map = np.random.uniform(0, 1, self.dim)\n        self.adaptive_prob = 0.2\n        self.mutation_prob = 0.1\n        self.levy_flight_scale = 1.0\n        self.opposition_weight = 0.5\n        self.convergence_speed = 0.0\n        self.exploitation_phase = False\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def chaotic_opposition_based_learning(self, individual):\n        chaotic_individual = self.lower_bound + (self.upper_bound - self.lower_bound) * self.chaotic_map\n        self.chaotic_map = 4 * self.chaotic_map * (1 - self.chaotic_map)\n        return chaotic_individual\n\n    def levy_flight(self, individual):\n        levy_flight = np.random.normal(0, self.levy_flight_scale, self.dim) / np.random.normal(0, self.levy_flight_scale, self.dim)\n        levy_flight = individual + levy_flight\n        return levy_flight\n\n    def gaussian_mutation(self, individual):\n        gaussian_mutation = individual + np.random.normal(0, 0.1, self.dim)\n        return gaussian_mutation\n\n    def weighted_opposition_based_learning(self, individual):\n        opposite_individual = self.opposition_based_learning(individual)\n        weighted_individual = self.opposition_weight * individual + (1 - self.opposition_weight) * opposite_individual\n        return weighted_individual\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_individual = self.population[i]\n                    self.convergence_speed = 1.0 / (1.0 + evaluations / self.budget)\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                r3 = np.random.uniform(0, 1, self.dim)\n                r4 = np.random.uniform(0, 1, self.dim)\n                A = 2 * r1 - 1\n                B = np.abs(r2)\n                C = 2 * r3 - 1\n                D = np.abs(r4)\n                sine = np.abs(self.best_individual - self.population[i]) * np.sin(np.abs(r1) * np.pi)\n                cosine = np.abs(self.best_individual - self.population[i]) * np.cos(np.abs(r1) * np.pi)\n                if np.random.uniform(0, 1) < 0.5:\n                    self.population[i] = self.best_individual - (A * sine + B * cosine) * C * D\n                else:\n                    self.population[i] = self.best_individual + (A * sine + B * cosine) * C * D\n                if evaluations > self.budget / 2 and not self.exploitation_phase:\n                    self.exploitation_phase = True\n                if self.exploitation_phase:\n                    self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n                levy_flight = self.levy_flight(self.population[i])\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                    self.levy_flight_scale *= 1.1 * (1.0 + self.convergence_speed)  # Increase the Levy flight scale if the Levy flight improves the fitness\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                        self.levy_flight_scale *= 0.9 / (1.0 + self.convergence_speed)  # Decrease the Levy flight scale if the Levy flight does not improve the fitness\n                self.levy_flight_scale = np.clip(self.levy_flight_scale, 0.1, 10.0)  # Clip the Levy flight scale to a reasonable range\n                # Apply adaptive chaotic opposition-based learning with a probability that adapts to the convergence speed\n                if np.random.uniform(0, 1) < self.adaptive_prob * (1.0 + self.convergence_speed):\n                    chaotic_individual = self.chaotic_opposition_based_learning(self.population[i])\n                    chaotic_fitness = func(chaotic_individual)\n                    evaluations += 1\n                    if chaotic_fitness < fitness:\n                        self.population[i] = chaotic_individual\n                        self.adaptive_prob *= 1.1  # Increase the probability if the chaotic opposition-based learning improves the fitness\n                    else:\n                        self.adaptive_prob *= 0.9  # Decrease the probability if the chaotic opposition-based learning does not improve the fitness\n                    self.adaptive_prob = np.clip(self.adaptive_prob, 0.1, 0.9)  # Clip the probability to a reasonable range\n                # Apply weighted opposition-based learning with a fixed probability\n                if np.random.uniform(0, 1) < 0.1:\n                    weighted_individual = self.weighted_opposition_based_learning(self.population[i])\n                    weighted_fitness = func(weighted_individual)\n                    evaluations += 1\n                    if weighted_fitness < fitness:\n                        self.population[i] = weighted_individual\n                # Apply Gaussian mutation with a fixed probability\n                if np.random.uniform(0, 1) < self.mutation_prob:\n                    gaussian_individual = self.gaussian_mutation(self.population[i])\n                    gaussian_fitness = func(gaussian_individual)\n                    evaluations += 1\n                    if gaussian_fitness < fitness:\n                        self.population[i] = gaussian_individual\n            # Dynamically adjust the population size based on the convergence speed\n            if evaluations > self.budget / 2 and self.population_size < self.initial_population_size * 2:\n                self.population_size = int(self.population_size * (1 + self.convergence_speed))\n                self.population = np.vstack((self.population, np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(self.population), self.dim))))\n        return self.best_individual", "name": "HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v4", "description": "Hybrid Sine Cosine Algorithm with Levy Flight, Simulated Annealing, Adaptive Chaotic Opposition-Based Learning, Gaussian Mutation, and Dynamic Population Size, incorporating a new weighted opposition-based learning strategy, an adaptive Levy flight scale, and a novel convergence speed-based dynamic population size adjustment with enhanced exploration-exploitation balance.", "configspace": "", "generation": 25, "fitness": 0.18298585987094085, "feedback": "The algorithm HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": "0687844e-91ca-453d-99dc-19f3cfc74f9d", "metadata": {"aucs": [0.3516571202745594, 0.377200409834765, 0.31616156583499, 0.3108475257500455, 0.29616785004740864, 0.2044006681242333, 0.20457905596980486, 0.28094212722230416, 0.367382351873771, 0.003922467257685969, 9.999999999998899e-05, 0.009662487881093695, 9.999999999998899e-05, 9.999999999998899e-05, 0.022059125681539227, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13124559648640266, 0.07893546934134865, 0.07115973236750706, 0.052830585353126125, 0.07436018104878417, 0.04659773060062977, 0.0878105945995572, 0.07972044695143832, 0.07054958581465487, 0.11230812165931747, 0.05953881382754078, 0.07482931331982201, 0.07650451622010934, 0.059714070592374435, 0.06792210565092627, 0.061331799047409596, 0.05115398933773507, 0.05614227271335781, 0.9776291666466989, 0.9666757027924954, 0.964005580457114, 0.9694808424230447, 0.9346893160917074, 0.9797817399553435, 0.9701596045651263, 0.9229068668184005, 0.9774149612312324, 0.26323335073279275, 0.2511098552139196, 0.26310166221222486, 0.22950605040237737, 0.19583598001452251, 0.12136575426401419, 0.24799905253727306, 0.1616786301885189, 0.22374777174502714, 0.21217309106363924, 0.17249109056441558, 0.18497145167480067, 0.18886182737352075, 0.1024872738751812, 0.1405512182882287, 0.23625844312587874, 0.15724955540438335, 0.20775048518428196, 0.11068342178960322, 0.13772515505480187, 0.11829166203051023, 0.11503601604811642, 0.12423525450301254, 0.11373125050219479, 0.11694164921902139, 0.14448346726662553, 0.11671692181736215, 0.20319011562958644, 0.17274345718015682, 0.19407225455288557, 0.18578490902977618, 0.18645889535932803, 0.16659978044933976, 0.18853067473585683, 0.20615099016463934, 0.18355416177390815, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03856327038670371, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.048562783377223084, 0.027943773039116993, 0.061939225284665556, 0.07122887963235858, 0.04529427054570001, 0.025678080406254744, 0.08873925851887765, 0.05049466249365908, 0.06299833246707309, 0.01256863006334974, 0.015369104629255892, 9.999999999998899e-05, 9.999999999998899e-05, 0.011697058025559981, 0.013547727429372158, 0.0005051726659314193, 9.999999999998899e-05, 9.999999999998899e-05, 0.06221730251256341, 0.003587842350854631, 0.09418521337572328, 0.08435713177456872, 0.025133359914505715, 0.04686632033907012, 0.10031839826028621, 0.09388228414076727, 0.05060555342385831, 0.24535491229441164, 0.20743543758061178, 0.30244365585004573, 0.22446696157455703, 0.3664598123411712, 0.36503159924166884, 0.290720543965006, 0.30304266274023606, 0.31494467881348664, 0.09666487793956291, 0.1079004895815604, 0.06655154197867308, 0.1099523233698042, 0.07518865106552752, 0.07367974841908342, 0.07850129969764363, 0.10301763480270365, 0.0644216338540935, 0.1613868412202153, 0.15701715543094197, 0.19384638071089633, 0.17379846135385613, 0.18220012247072004, 0.1507447793171416, 0.15707732004131536, 0.15046143346077767, 0.17902503887861854, 0.19424774030001457, 0.1991923029657502, 0.2100987123086302, 0.2218954627544265, 0.18874914931550957, 0.1777476228284326, 0.16237457512253928, 0.21417055440557498, 0.19303760788085234, 0.12752191516358868, 0.1781727649251258, 0.12398953039277982, 0.15052013395552044, 0.1948632291788004, 0.14540709558788567, 0.10817139832328904, 0.12186536796174419, 0.11617857572791523, 0.29524089418943844, 0.2810570948250989, 0.3226859830748151, 0.302572666933113, 0.28794100017049207, 0.2831434474691339, 0.2863401650578914, 0.27207525077699124, 0.29943735941885175, 0.16641085889226703, 0.1801332434605123, 0.17576199379888235, 0.2026743232019108, 0.17795824498665513, 0.16453455866117017, 0.17196498549434158, 0.1771390887264842, 0.17034216710715777, 0.6526295697915393, 0.41825040455946416, 0.24700648298358074, 0.15320049762414534, 0.1480335798455179, 0.38404254816730576, 0.5683911948514588, 0.18555428208867297, 0.14661876535338247, 0.1837825901547756, 0.22767786319272432, 0.13352647915681615, 0.176056981711737, 0.1910952037390926, 0.14834371056844953, 0.14523338742597136, 0.2764251200578771, 0.4108824456294192, 0.19095337389828793, 0.18904597972400194, 0.17056181156263373, 0.18691564054848264, 0.17986477392048295, 0.20566156189049944, 0.1791298257703151, 0.19358212779956185, 0.16825690229944334, 0.07160003920988223, 0.07746134690748951, 0.10214170873016426, 0.07125255577757128, 0.07269064289207239, 0.07255373789238806, 0.06726571145179727, 0.09725239658302365, 0.08128374733084598]}, "mutation_prompt": null}
{"id": "56af45ab-5bad-4159-975f-caabb5736333", "solution": "import numpy as np\n\nclass HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.best_fitness = np.inf\n        self.chaotic_map = np.random.uniform(0, 1, self.dim)\n        self.adaptive_prob = 0.2\n        self.mutation_prob = 0.1\n        self.levy_flight_scale = 1.0\n        self.opposition_weight = 0.5\n        self.convergence_speed = 0.0\n        self.pbest = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.pbest_fitness = np.inf * np.ones(self.population_size)\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def chaotic_opposition_based_learning(self, individual):\n        chaotic_individual = self.lower_bound + (self.upper_bound - self.lower_bound) * self.chaotic_map\n        self.chaotic_map = 4 * self.chaotic_map * (1 - self.chaotic_map)\n        return chaotic_individual\n\n    def levy_flight(self, individual):\n        levy_flight = np.random.normal(0, self.levy_flight_scale, self.dim) / np.random.normal(0, self.levy_flight_scale, self.dim)\n        levy_flight = individual + levy_flight\n        return levy_flight\n\n    def gaussian_mutation(self, individual):\n        gaussian_mutation = individual + np.random.normal(0, 0.1, self.dim)\n        return gaussian_mutation\n\n    def weighted_opposition_based_learning(self, individual):\n        opposite_individual = self.opposition_based_learning(individual)\n        weighted_individual = self.opposition_weight * individual + (1 - self.opposition_weight) * opposite_individual\n        return weighted_individual\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.pbest_fitness[i]:\n                    self.pbest_fitness[i] = fitness\n                    self.pbest[i] = self.population[i]\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_individual = self.population[i]\n                    self.convergence_speed = 1.0 / (1.0 + evaluations / self.budget)\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                r3 = np.random.uniform(0, 1, self.dim)\n                r4 = np.random.uniform(0, 1, self.dim)\n                A = 2 * r1 - 1\n                B = np.abs(r2)\n                C = 2 * r3 - 1\n                D = np.abs(r4)\n                sine = np.abs(self.best_individual - self.population[i]) * np.sin(np.abs(r1) * np.pi)\n                cosine = np.abs(self.best_individual - self.population[i]) * np.cos(np.abs(r1) * np.pi)\n                if np.random.uniform(0, 1) < 0.5:\n                    self.population[i] = self.best_individual - (A * sine + B * cosine) * C * D\n                else:\n                    self.population[i] = self.best_individual + (A * sine + B * cosine) * C * D\n                levy_flight = self.levy_flight(self.population[i])\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                    self.levy_flight_scale *= 1.1 * (1.0 + self.convergence_speed)  # Increase the Levy flight scale if the Levy flight improves the fitness\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                        self.levy_flight_scale *= 0.9 / (1.0 + self.convergence_speed)  # Decrease the Levy flight scale if the Levy flight does not improve the fitness\n                self.levy_flight_scale = np.clip(self.levy_flight_scale, 0.1, 10.0)  # Clip the Levy flight scale to a reasonable range\n                # Apply adaptive chaotic opposition-based learning with a probability that adapts to the convergence speed\n                if np.random.uniform(0, 1) < self.adaptive_prob * (1.0 + self.convergence_speed):\n                    chaotic_individual = self.chaotic_opposition_based_learning(self.population[i])\n                    chaotic_fitness = func(chaotic_individual)\n                    evaluations += 1\n                    if chaotic_fitness < fitness:\n                        self.population[i] = chaotic_individual\n                        self.adaptive_prob *= 1.1  # Increase the probability if the chaotic opposition-based learning improves the fitness\n                    else:\n                        self.adaptive_prob *= 0.9  # Decrease the probability if the chaotic opposition-based learning does not improve the fitness\n                    self.adaptive_prob = np.clip(self.adaptive_prob, 0.1, 0.9)  # Clip the probability to a reasonable range\n                # Apply weighted opposition-based learning with a fixed probability\n                if np.random.uniform(0, 1) < 0.1:\n                    weighted_individual = self.weighted_opposition_based_learning(self.population[i])\n                    weighted_fitness = func(weighted_individual)\n                    evaluations += 1\n                    if weighted_fitness < fitness:\n                        self.population[i] = weighted_individual\n                # Apply Gaussian mutation with a fixed probability\n                if np.random.uniform(0, 1) < self.mutation_prob:\n                    gaussian_individual = self.gaussian_mutation(self.population[i])\n                    gaussian_fitness = func(gaussian_individual)\n                    evaluations += 1\n                    if gaussian_fitness < fitness:\n                        self.population[i] = gaussian_individual\n            # Dynamically adjust the population size based on the convergence speed\n            if evaluations > self.budget / 2 and self.population_size < self.initial_population_size * 2:\n                self.population_size = int(self.population_size * (1 + self.convergence_speed))\n                self.population = np.vstack((self.population, np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(self.population), self.dim))))\n                self.pbest = np.vstack((self.pbest, np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(self.pbest), self.dim))))\n                self.pbest_fitness = np.concatenate((self.pbest_fitness, np.inf * np.ones(self.population_size - len(self.pbest_fitness))))\n        return self.best_individual", "name": "HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v4", "description": "Hybrid Sine Cosine Algorithm with Levy Flight, Simulated Annealing, Adaptive Chaotic Opposition-Based Learning, Gaussian Mutation, Dynamic Population Size, and Adaptive Levy Flight Scale, incorporating a Novel Convergence Speed-Based Dynamic Population Size Adjustment and a New Weighted Opposition-Based Learning Strategy with Adaptive Probability.", "configspace": "", "generation": 26, "fitness": 0.17902695650386655, "feedback": "The algorithm HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": "0687844e-91ca-453d-99dc-19f3cfc74f9d", "metadata": {"aucs": [0.37223553652242547, 0.38071091920259137, 0.39738478983103986, 0.2957166510710849, 0.41216722711142884, 0.40097696650903825, 0.29377264259106695, 0.36440951076841255, 0.28687249213026533, 9.999999999998899e-05, 0.011029331343242799, 0.00010205399409912719, 0.05134394506898465, 0.03837424750183949, 9.999999999998899e-05, 0.015753339104831898, 9.999999999998899e-05, 9.999999999998899e-05, 0.08943199431126381, 0.06205946001722973, 0.05731611108681367, 0.08894067204299316, 0.08371308224823848, 0.06408399016930577, 0.0874981151271802, 0.11068220927287509, 0.09500168642251794, 0.0492516470608223, 0.04473063960500989, 0.06780695967796568, 0.07609096386414238, 0.05599300278440389, 0.05732795053040285, 0.04974033799873501, 0.06736932385488903, 0.14336934370147048, 0.985257933011706, 0.9823692967469984, 0.9766242952920245, 0.9596335383180317, 0.9684963034439541, 0.9722203833183695, 0.968495641735677, 0.9909010201995562, 0.9741323993267932, 0.08900885039668172, 0.22519706340026568, 0.24753091566166563, 0.20658611900015933, 0.2764555720849431, 0.2924498378471342, 0.2243491892014179, 0.16164314644949196, 0.13921473429099152, 0.20834101681591377, 0.16301023088704258, 0.15699943702411656, 0.16288739918348438, 0.18583847441795898, 0.1358472537410389, 0.22999999735677756, 0.17838119570547006, 0.11374234105335401, 0.12021957668684735, 0.10836861447097945, 0.14374604514220246, 0.1213822538409084, 0.1106805866822761, 0.1145245172034387, 0.13184401068798468, 0.1446604762251782, 0.171723237312148, 0.20660138014803364, 0.1617848808132909, 0.17884687819739897, 0.19518463328311575, 0.18430310967699493, 0.1439983209096095, 0.17545271747303182, 0.16521555237592278, 0.1605315801103281, 9.999999999998899e-05, 0.0007413764570454173, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06205966744624525, 0.026742919410502553, 0.10565183251148269, 0.07040386412964039, 0.02558145855660765, 0.03257033338087678, 0.0442033389412374, 0.043520073458366504, 0.06685840205766924, 9.999999999998899e-05, 9.999999999998899e-05, 0.045256774389088594, 0.03620197884241383, 9.999999999998899e-05, 0.030855792207511112, 9.999999999998899e-05, 0.0023708947997863605, 9.999999999998899e-05, 0.05358741603626915, 0.09296168048866238, 0.09897508908470953, 9.999999999998899e-05, 0.056316932089222616, 0.07882217602354646, 0.02276191314236964, 0.11729443900670977, 0.020644157552579423, 0.21833859678887213, 0.32199816712917106, 0.2028734737343132, 0.25031123345421236, 0.21595660790077076, 0.23665251942657495, 0.32543377171596644, 0.31026382580302514, 0.3279663641585435, 0.08308272826984853, 0.11979206359490091, 0.06575046742934665, 0.08422470940872262, 0.07561629144889248, 0.06590109138165412, 0.07354766963499892, 0.06964143398830624, 0.08141579128354315, 0.12865323548226115, 0.19557744534750043, 0.1657825874580482, 0.1733946167557482, 0.2800451937898121, 0.1833466974790059, 0.13472577113003625, 0.15946177251421378, 0.16454553414881667, 0.1984397487661349, 0.19925481456632765, 0.17185441190476958, 0.16969007643401834, 0.19217537404955487, 0.17769246770517388, 0.17337895739990594, 0.17355644745245868, 0.1678232497404859, 0.12755857372299928, 0.17341869386483122, 0.1449082185692696, 0.10444007197969551, 0.17015772921627303, 0.123004987094121, 0.15507352882222536, 0.1468109362232155, 0.1478662690992667, 0.2994903013306588, 0.2851526280502287, 0.3113231449293814, 0.30019509719040705, 0.27307132474538853, 0.2881515126940575, 0.2601875539181707, 0.3092110487906381, 0.29800835639486245, 0.19747314117639359, 0.18773367106985328, 0.20188225850457486, 0.17933500410783487, 0.20137170841008212, 0.1789944333988429, 0.17586686693548492, 0.17128395066906832, 0.1688360699803939, 0.1087231431561666, 0.19318969294536492, 0.2222308967383846, 0.15772255865993678, 0.14858891574434874, 0.14886627707553213, 0.1557303007716222, 0.16236317461875827, 0.13187058852436018, 0.25735525066585296, 0.2246696681343996, 0.3569850845947191, 0.2948667182020187, 0.20993595180644642, 0.22739531752249253, 0.12990200232902094, 0.12191301953238143, 0.3631336309944412, 0.19526408855688215, 0.18657017919079566, 0.1958356431279491, 0.19718137093525878, 0.18935060209068766, 0.22871740397356866, 0.1861950108927275, 0.21267026127141853, 0.17157340661652465, 0.06386418263446414, 0.08970906464670392, 0.07187883439566667, 0.07042687519917867, 0.0660084103562738, 0.07914986796844792, 0.08956126084325788, 0.05516769985330361, 0.06416235101180812]}, "mutation_prompt": null}
{"id": "57a93040-dc4a-4408-9c69-9c31c60bec4e", "solution": "import numpy as np\n\nclass HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.best_fitness = np.inf\n        self.chaotic_map = np.random.uniform(0, 1, self.dim)\n        self.adaptive_prob = 0.2\n        self.mutation_prob = 0.1\n        self.levy_flight_scale = 1.0\n        self.opposition_weight = 0.5\n        self.convergence_speed = 0.0\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def chaotic_opposition_based_learning(self, individual):\n        chaotic_individual = self.lower_bound + (self.upper_bound - self.lower_bound) * self.chaotic_map\n        self.chaotic_map = 4 * self.chaotic_map * (1 - self.chaotic_map)\n        return chaotic_individual\n\n    def levy_flight(self, individual):\n        levy_flight = np.random.normal(0, self.levy_flight_scale, self.dim) / np.random.normal(0, self.levy_flight_scale, self.dim)\n        levy_flight = individual + levy_flight\n        return levy_flight\n\n    def gaussian_mutation(self, individual):\n        gaussian_mutation = individual + np.random.normal(0, 0.1, self.dim)\n        return gaussian_mutation\n\n    def weighted_opposition_based_learning(self, individual):\n        opposite_individual = self.opposition_based_learning(individual)\n        weighted_individual = self.opposition_weight * individual + (1 - self.opposition_weight) * opposite_individual\n        return weighted_individual\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_individual = self.population[i]\n                    self.convergence_speed = 1.0 / (1.0 + evaluations / self.budget)\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                r3 = np.random.uniform(0, 1, self.dim)\n                r4 = np.random.uniform(0, 1, self.dim)\n                A = 2 * r1 - 1\n                B = np.abs(r2)\n                C = 2 * r3 - 1\n                D = np.abs(r4)\n                sine = np.abs(self.best_individual - self.population[i]) * np.sin(np.abs(r1) * np.pi)\n                cosine = np.abs(self.best_individual - self.population[i]) * np.cos(np.abs(r1) * np.pi)\n                if np.random.uniform(0, 1) < 0.5:\n                    self.population[i] = self.best_individual - (A * sine + B * cosine) * C * D\n                else:\n                    self.population[i] = self.best_individual + (A * sine + B * cosine) * C * D\n                levy_flight = self.levy_flight(self.population[i])\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                    self.levy_flight_scale *= 1.1 * (1.0 + self.convergence_speed)  # Increase the Levy flight scale if the Levy flight improves the fitness\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                        self.levy_flight_scale *= 0.9 / (1.0 + self.convergence_speed)  # Decrease the Levy flight scale if the Levy flight does not improve the fitness\n                self.levy_flight_scale = np.clip(self.levy_flight_scale, 0.1, 10.0)  # Clip the Levy flight scale to a reasonable range\n                # Apply adaptive chaotic opposition-based learning with a probability that adapts to the convergence speed and fitness improvement\n                if np.random.uniform(0, 1) < self.adaptive_prob * (1.0 + self.convergence_speed) * (1.0 - fitness / self.best_fitness):\n                    chaotic_individual = self.chaotic_opposition_based_learning(self.population[i])\n                    chaotic_fitness = func(chaotic_individual)\n                    evaluations += 1\n                    if chaotic_fitness < fitness:\n                        self.population[i] = chaotic_individual\n                        self.adaptive_prob *= 1.1  # Increase the probability if the chaotic opposition-based learning improves the fitness\n                    else:\n                        self.adaptive_prob *= 0.9  # Decrease the probability if the chaotic opposition-based learning does not improve the fitness\n                    self.adaptive_prob = np.clip(self.adaptive_prob, 0.1, 0.9)  # Clip the probability to a reasonable range\n                # Apply weighted opposition-based learning with a fixed probability\n                if np.random.uniform(0, 1) < 0.1:\n                    weighted_individual = self.weighted_opposition_based_learning(self.population[i])\n                    weighted_fitness = func(weighted_individual)\n                    evaluations += 1\n                    if weighted_fitness < fitness:\n                        self.population[i] = weighted_individual\n                # Apply Gaussian mutation with a fixed probability\n                if np.random.uniform(0, 1) < self.mutation_prob:\n                    gaussian_individual = self.gaussian_mutation(self.population[i])\n                    gaussian_fitness = func(gaussian_individual)\n                    evaluations += 1\n                    if gaussian_fitness < fitness:\n                        self.population[i] = gaussian_individual\n            # Dynamically adjust the population size based on the convergence speed\n            if evaluations > self.budget / 2 and self.population_size < self.initial_population_size * 2:\n                self.population_size = int(self.population_size * (1 + self.convergence_speed))\n                self.population = np.vstack((self.population, np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(self.population), self.dim))))\n        return self.best_individual", "name": "HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v4", "description": "Hybrid Sine Cosine Algorithm with Levy Flight, Simulated Annealing, Adaptive Chaotic Opposition-Based Learning, Gaussian Mutation, and Dynamic Population Size, incorporating a new weighted opposition-based learning strategy, an adaptive Levy flight scale, a novel convergence speed-based dynamic population size adjustment, and a modified adaptive probability update rule.", "configspace": "", "generation": 27, "fitness": 0.1742360238912246, "feedback": "The algorithm HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.19.", "error": "", "parent_id": "0687844e-91ca-453d-99dc-19f3cfc74f9d", "metadata": {"aucs": [0.39516306969125137, 0.3424755845587991, 0.4108404994748859, 0.3075326568743172, 0.31788034014498145, 0.4592623407108889, 0.20690621730977943, 0.22648354514143487, 0.24532282709311914, 0.00011405624142657445, 0.009282286148687535, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05888678083638754, 0.06004324296116015, 0.057741334342870876, 0.0988749155455988, 0.08487353106484952, 0.08030481538633971, 0.04645287246299101, 0.04502252159474229, 0.08139187983395546, 0.0704119496104606, 0.08290226293697955, 0.06691146012702143, 0.10804068736335704, 0.06410873092171043, 0.04155953349903452, 0.12426514676383815, 0.03603154759869909, 0.08033784543726197, 0.9793532529426358, 0.8787731920822859, 0.9736387221609858, 0.96006775077137, 0.9363540866321844, 0.9783003383154898, 0.9824117828936095, 0.9355632689034431, 0.9828908427124403, 0.28946302464075524, 0.20464547361214536, 0.2730680220569307, 0.19461078656719588, 0.14902684802326327, 0.24279912370844692, 0.10787948751539045, 0.07462590053209583, 0.19045428725661473, 0.14178353779199426, 0.17597571838890036, 0.13204909501820605, 0.2231996634546295, 0.21635856202861592, 0.1678895746670812, 0.1399006841230208, 0.13131498203553837, 0.13240965974569718, 0.11285666474716693, 0.1758864377693422, 0.12445145688637071, 0.12203963312983979, 0.1034642719721991, 0.11835649664674996, 0.12112235734141341, 0.10757182860446923, 0.19167760962220903, 0.2162645765759501, 0.17478605290447635, 0.18035483366222416, 0.18423496759576286, 0.1840855172529532, 0.1639649488559951, 0.18983232407087836, 0.19717448960041706, 0.17884450128780105, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.040736749991085675, 9.999999999998899e-05, 0.021007870101357184, 9.999999999998899e-05, 0.028955905457896502, 0.013890929022568499, 0.06539379894895792, 0.04517053502773338, 0.0643003790491028, 0.07393690601842795, 0.009689969275264776, 9.999999999998899e-05, 0.15884444759741367, 0.038412001644593685, 0.038022442698408265, 0.007190722913640868, 0.008034241926918928, 0.003427356143867466, 0.029282348178533146, 9.999999999998899e-05, 0.012080130823542978, 0.0370324742460294, 0.0072454275110918065, 0.03942424979089376, 0.11315103793140258, 0.0021759174977526996, 0.0788987412864568, 0.07462417656440234, 0.06957657148061169, 0.10737708487139497, 0.007592077851254153, 0.07318981150761794, 0.09952309289522543, 0.15731955451654045, 0.20045979086654353, 0.15751163445556504, 0.22478091848590365, 0.2768616449083817, 0.3230119813001564, 0.256034692169096, 0.460709878194164, 0.3265432140789941, 0.08547732553075693, 0.08037383780280039, 0.059537093874291735, 0.044872434352981716, 0.07725470927383371, 0.08612227548202867, 0.08722062081460247, 0.05540223707120817, 0.06760666530008241, 0.14583213580661814, 0.11023486654428294, 0.1346819871769922, 0.1881088332835178, 0.1744389979201143, 0.12347217140721956, 0.12567876769886355, 0.1913704738978952, 0.1996788793590074, 0.17857980701192377, 0.17384844652092923, 0.2015261240447319, 0.21822968295518652, 0.20082015164886857, 0.2112573381593389, 0.20156488313751475, 0.19996405750833435, 0.15726264740506102, 0.16424835658354708, 0.15994410632299094, 0.11696323685080312, 0.16918157660500388, 0.13958556911513764, 0.16397240297251192, 0.10827015747787083, 0.1435527306752341, 0.13364407350555485, 0.29306850658354755, 0.287896692279179, 0.2857287401322285, 0.2825587298400438, 0.28346194227946997, 0.32278237533404686, 0.3295191238720334, 0.3052211796332176, 0.29606238817170794, 0.178850993228579, 0.1730395922479051, 0.17876741957684572, 0.18739725442307886, 0.1940626194395596, 0.1782509457885615, 0.16536909120783294, 0.17370412355265907, 0.17311160163121075, 0.16898138286217967, 0.17877399506878155, 0.17199816272792212, 0.1969516992159156, 0.1469494681160426, 0.5233878753179051, 0.20188226846110513, 0.1635137072055275, 0.16724840453768197, 0.11016002682975978, 0.19532635130042753, 0.19597199542429844, 0.22341165665306895, 0.10903237538131139, 0.23997258826980294, 0.11760275772534878, 0.12433173042357648, 0.10259558710081196, 0.1937938249495973, 0.1750679987741487, 0.20603199509008552, 0.19140259704704532, 0.19216137271945544, 0.18412887795595811, 0.18562350815082695, 0.17768013478867362, 0.19331393156183307, 0.07334129499967856, 0.08456641766767248, 0.06265536462886079, 0.0595150862105609, 0.06147794949781149, 0.0890903147168528, 0.07514115873522464, 0.06271585142656244, 0.05652664263004625]}, "mutation_prompt": null}
{"id": "5e726055-5e74-444a-bc86-f7e995ccb3c3", "solution": "import numpy as np\n\nclass HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.best_fitness = np.inf\n        self.chaotic_map = np.random.uniform(0, 1, self.dim)\n        self.adaptive_prob = 0.2\n        self.mutation_prob = 0.1\n        self.levy_flight_scale = 1.0\n        self.opposition_weight = 0.5\n        self.convergence_speed = 0.0\n        self.refine_prob = 0.1  # 10% probability of refining individual lines\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def chaotic_opposition_based_learning(self, individual):\n        chaotic_individual = self.lower_bound + (self.upper_bound - self.lower_bound) * self.chaotic_map\n        self.chaotic_map = 4 * self.chaotic_map * (1 - self.chaotic_map)\n        return chaotic_individual\n\n    def levy_flight(self, individual):\n        levy_flight = np.random.normal(0, self.levy_flight_scale, self.dim) / np.random.normal(0, self.levy_flight_scale, self.dim)\n        levy_flight = individual + levy_flight\n        return levy_flight\n\n    def gaussian_mutation(self, individual):\n        gaussian_mutation = individual + np.random.normal(0, 0.1, self.dim)\n        return gaussian_mutation\n\n    def weighted_opposition_based_learning(self, individual):\n        opposite_individual = self.opposition_based_learning(individual)\n        weighted_individual = self.opposition_weight * individual + (1 - self.opposition_weight) * opposite_individual\n        return weighted_individual\n\n    def refine_strategy(self, individual):\n        if np.random.uniform(0, 1) < self.refine_prob:\n            # Refine the individual with a 10% probability\n            refined_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            return refined_individual\n        else:\n            return individual\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_individual = self.population[i]\n                    self.convergence_speed = 1.0 / (1.0 + evaluations / self.budget)\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                r3 = np.random.uniform(0, 1, self.dim)\n                r4 = np.random.uniform(0, 1, self.dim)\n                A = 2 * r1 - 1\n                B = np.abs(r2)\n                C = 2 * r3 - 1\n                D = np.abs(r4)\n                sine = np.abs(self.best_individual - self.population[i]) * np.sin(np.abs(r1) * np.pi)\n                cosine = np.abs(self.best_individual - self.population[i]) * np.cos(np.abs(r1) * np.pi)\n                if np.random.uniform(0, 1) < 0.5:\n                    self.population[i] = self.best_individual - (A * sine + B * cosine) * C * D\n                else:\n                    self.population[i] = self.best_individual + (A * sine + B * cosine) * C * D\n                levy_flight = self.levy_flight(self.population[i])\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                    self.levy_flight_scale *= 1.1 * (1.0 + self.convergence_speed)  # Increase the Levy flight scale if the Levy flight improves the fitness\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                        self.levy_flight_scale *= 0.9 / (1.0 + self.convergence_speed)  # Decrease the Levy flight scale if the Levy flight does not improve the fitness\n                self.levy_flight_scale = np.clip(self.levy_flight_scale, 0.1, 10.0)  # Clip the Levy flight scale to a reasonable range\n                # Apply adaptive chaotic opposition-based learning with a probability that adapts to the convergence speed\n                if np.random.uniform(0, 1) < self.adaptive_prob * (1.0 + self.convergence_speed):\n                    chaotic_individual = self.chaotic_opposition_based_learning(self.population[i])\n                    chaotic_fitness = func(chaotic_individual)\n                    evaluations += 1\n                    if chaotic_fitness < fitness:\n                        self.population[i] = chaotic_individual\n                        self.adaptive_prob *= 1.1  # Increase the probability if the chaotic opposition-based learning improves the fitness\n                    else:\n                        self.adaptive_prob *= 0.9  # Decrease the probability if the chaotic opposition-based learning does not improve the fitness\n                    self.adaptive_prob = np.clip(self.adaptive_prob, 0.1, 0.9)  # Clip the probability to a reasonable range\n                # Apply weighted opposition-based learning with a fixed probability\n                if np.random.uniform(0, 1) < 0.1:\n                    weighted_individual = self.weighted_opposition_based_learning(self.population[i])\n                    weighted_fitness = func(weighted_individual)\n                    evaluations += 1\n                    if weighted_fitness < fitness:\n                        self.population[i] = weighted_individual\n                # Apply Gaussian mutation with a fixed probability\n                if np.random.uniform(0, 1) < self.mutation_prob:\n                    gaussian_individual = self.gaussian_mutation(self.population[i])\n                    gaussian_fitness = func(gaussian_individual)\n                    evaluations += 1\n                    if gaussian_fitness < fitness:\n                        self.population[i] = gaussian_individual\n                # Refine the individual with a 10% probability\n                self.population[i] = self.refine_strategy(self.population[i])\n            # Dynamically adjust the population size based on the convergence speed\n            if evaluations > self.budget / 2 and self.population_size < self.initial_population_size * 2:\n                self.population_size = int(self.population_size * (1 + self.convergence_speed))\n                self.population = np.vstack((self.population, np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(self.population), self.dim))))\n        return self.best_individual", "name": "HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v4", "description": "Hybrid Sine Cosine Algorithm with Levy Flight, Simulated Annealing, Adaptive Chaotic Opposition-Based Learning, Gaussian Mutation, and Dynamic Population Size, incorporating a new weighted opposition-based learning strategy, an adaptive Levy flight scale, and a novel convergence speed-based dynamic population size adjustment, with a 10% probability of changing individual lines to refine its strategy.", "configspace": "", "generation": 28, "fitness": 0.1641196771889797, "feedback": "The algorithm HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.19.", "error": "", "parent_id": "0687844e-91ca-453d-99dc-19f3cfc74f9d", "metadata": {"aucs": [0.46209589474175083, 0.38143260811686075, 0.40419457420716676, 0.30242214194223627, 0.20830457169620553, 0.1833775954359227, 0.20857966306585451, 0.27369544783702526, 0.19330726806746434, 9.999999999998899e-05, 0.04009564710926139, 9.999999999998899e-05, 0.10083341004981106, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04679002691267342, 0.10648833866599439, 0.05565490447042154, 0.05978934617122811, 0.0440761857935269, 0.059627862479357474, 0.0564273149928044, 0.06660400397950528, 0.044489187048849965, 0.046909440471250896, 0.0735613275079855, 0.07703631065230854, 0.08249362289047635, 0.0570696268930565, 0.03465555767381645, 0.017789848024061916, 0.07342908484445221, 0.09329748517684588, 0.9848905721711525, 0.9722156473281551, 0.9873396853303892, 0.9725724168949467, 0.8064987758232489, 0.936152035717102, 0.9485096958620494, 0.9533106995437148, 0.9451222021776026, 0.2013003363740541, 0.15170806205400622, 0.08164971413076749, 0.09389604979160482, 0.1938398351691729, 0.18041542479321648, 0.1956605603875461, 0.07903700375305767, 0.10747958011859193, 0.1532624326410027, 0.1673398380302098, 0.16262333654858774, 0.13757856858558448, 0.12803155526551868, 0.13329801605531755, 0.15296670206494067, 0.15582535961085375, 0.13015254437897605, 0.16790522924980267, 0.13227232309153514, 0.0018401690419286298, 0.0006574697885775027, 0.05229952042513941, 0.06912603191168798, 0.07890029848685387, 0.1227228755440678, 0.15785033683843108, 0.10696993218076678, 0.1753358534758308, 0.17733298041734646, 0.1975329029671008, 0.20546562286354852, 0.21033423554018071, 0.21311897746501163, 0.20517282978675133, 0.24526783078947145, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08212546735315851, 0.03482915973645018, 0.04502176686141224, 0.09520731495597867, 0.052314441536653655, 0.03317962017518006, 0.04786337599073354, 0.05683203695452499, 0.056660013605842496, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08731545714769595, 0.01697751580302498, 9.999999999998899e-05, 9.999999999998899e-05, 0.10498772731533224, 9.999999999998899e-05, 0.019744813979503673, 0.0557366320655186, 0.0893353222271337, 0.22035451735881773, 0.17459536201133596, 0.18131649635975355, 0.18512680800933023, 0.2013259859002443, 0.19536304630932932, 0.3007130221646357, 0.23891568883614278, 0.3743069641394664, 0.047843036741284206, 0.06731566124702626, 0.05313702926281805, 0.051209608052733335, 0.043729907227099685, 0.05138102409040346, 0.06902027677711087, 0.07727975113528085, 0.04456336288104035, 0.12877683820443475, 0.1761201269407493, 0.24411256423192673, 0.14905384748117412, 0.15763466622756184, 0.15562543997050693, 0.1800541299618309, 0.21866557332888192, 0.1946232415791238, 0.15842001007913764, 0.1844424771624955, 0.1610991092249625, 0.20732769990204192, 0.18371392509239026, 0.20785868737561508, 0.17959581127413038, 0.19232919364453704, 0.17615868684150504, 0.1345243085178367, 0.16976683002480664, 0.12369825474600693, 0.12999069992389123, 0.10367112780127863, 0.14068886773814648, 0.1633538255438156, 0.1358124584256224, 0.11511167833079694, 0.3051325497096228, 0.2667075307915199, 0.2888479885570121, 0.28720643843453675, 0.2674461063099175, 0.3307820026645263, 0.3085466864018157, 0.27622872054824177, 0.3333494972529176, 0.16035650932885037, 0.17506943337720948, 0.15915573605973354, 0.19454336793458382, 0.18435827634349944, 0.16816652303302848, 0.20481727782478887, 0.1623001336555766, 0.17944719093213768, 0.17131114244720214, 0.2167581050184435, 0.2125241358467823, 0.3658352966481395, 0.16289193250260237, 0.21445472128334353, 0.13124691925127996, 0.15932085336201984, 0.1485862463404043, 0.1875599421200268, 0.11690389187250838, 0.3077093098394036, 0.1000646543518775, 0.245943697115252, 0.13128856629198127, 0.19511512468571668, 0.19211356151195136, 0.195344671631697, 0.19818212701822602, 0.21250062640763245, 0.19369382393616574, 0.19596878529267558, 0.2138767993204319, 0.2144889106783643, 0.1815656966084499, 0.18508026899245866, 0.1828192249564593, 0.05089776871695317, 0.08095187583743446, 0.060184640542420675, 0.05518994617259454, 0.052640307626106386, 0.044005113644370986, 0.060367915930249594, 0.06353562013222946, 0.07849741855546821]}, "mutation_prompt": null}
{"id": "db1968e3-e968-47dc-845b-87a3b10830ef", "solution": "import numpy as np\n\nclass HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.best_fitness = np.inf\n        self.chaotic_map = np.random.uniform(0, 1, self.dim)\n        self.adaptive_prob = 0.2\n        self.mutation_prob = 0.1\n        self.levy_flight_scale = 1.0\n        self.opposition_weight = 0.5\n        self.convergence_speed = 0.0\n        self.probability = 0.7\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def chaotic_opposition_based_learning(self, individual):\n        chaotic_individual = self.lower_bound + (self.upper_bound - self.lower_bound) * self.chaotic_map\n        self.chaotic_map = 4 * self.chaotic_map * (1 - self.chaotic_map)\n        return chaotic_individual\n\n    def levy_flight(self, individual):\n        levy_flight = np.random.normal(0, self.levy_flight_scale, self.dim) / np.random.normal(0, self.levy_flight_scale, self.dim)\n        levy_flight = individual + levy_flight\n        return levy_flight\n\n    def gaussian_mutation(self, individual):\n        gaussian_mutation = individual + np.random.normal(0, 0.1, self.dim)\n        return gaussian_mutation\n\n    def weighted_opposition_based_learning(self, individual):\n        opposite_individual = self.opposition_based_learning(individual)\n        weighted_individual = self.opposition_weight * individual + (1 - self.opposition_weight) * opposite_individual\n        return weighted_individual\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_individual = self.population[i]\n                    self.convergence_speed = 1.0 / (1.0 + evaluations / self.budget)\n                if np.random.uniform(0, 1) < self.probability:\n                    r1 = np.random.uniform(0, 1, self.dim)\n                    r2 = np.random.uniform(0, 1, self.dim)\n                    r3 = np.random.uniform(0, 1, self.dim)\n                    r4 = np.random.uniform(0, 1, self.dim)\n                    A = 2 * r1 - 1\n                    B = np.abs(r2)\n                    C = 2 * r3 - 1\n                    D = np.abs(r4)\n                    sine = np.abs(self.best_individual - self.population[i]) * np.sin(np.abs(r1) * np.pi)\n                    cosine = np.abs(self.best_individual - self.population[i]) * np.cos(np.abs(r1) * np.pi)\n                    if np.random.uniform(0, 1) < 0.5:\n                        self.population[i] = self.best_individual - (A * sine + B * cosine) * C * D\n                    else:\n                        self.population[i] = self.best_individual + (A * sine + B * cosine) * C * D\n                else:\n                    self.population[i] = self.best_individual + np.random.uniform(-1, 1, self.dim)\n                levy_flight = self.levy_flight(self.population[i])\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                    self.levy_flight_scale *= 1.1 * (1.0 + self.convergence_speed)  # Increase the Levy flight scale if the Levy flight improves the fitness\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                        self.levy_flight_scale *= 0.9 / (1.0 + self.convergence_speed)  # Decrease the Levy flight scale if the Levy flight does not improve the fitness\n                self.levy_flight_scale = np.clip(self.levy_flight_scale, 0.1, 10.0)  # Clip the Levy flight scale to a reasonable range\n                # Apply adaptive chaotic opposition-based learning with a probability that adapts to the convergence speed\n                if np.random.uniform(0, 1) < self.adaptive_prob * (1.0 + self.convergence_speed):\n                    chaotic_individual = self.chaotic_opposition_based_learning(self.population[i])\n                    chaotic_fitness = func(chaotic_individual)\n                    evaluations += 1\n                    if chaotic_fitness < fitness:\n                        self.population[i] = chaotic_individual\n                        self.adaptive_prob *= 1.1  # Increase the probability if the chaotic opposition-based learning improves the fitness\n                    else:\n                        self.adaptive_prob *= 0.9  # Decrease the probability if the chaotic opposition-based learning does not improve the fitness\n                    self.adaptive_prob = np.clip(self.adaptive_prob, 0.1, 0.9)  # Clip the probability to a reasonable range\n                # Apply weighted opposition-based learning with a fixed probability\n                if np.random.uniform(0, 1) < 0.1:\n                    weighted_individual = self.weighted_opposition_based_learning(self.population[i])\n                    weighted_fitness = func(weighted_individual)\n                    evaluations += 1\n                    if weighted_fitness < fitness:\n                        self.population[i] = weighted_individual\n                # Apply Gaussian mutation with a fixed probability\n                if np.random.uniform(0, 1) < self.mutation_prob:\n                    gaussian_individual = self.gaussian_mutation(self.population[i])\n                    gaussian_fitness = func(gaussian_individual)\n                    evaluations += 1\n                    if gaussian_fitness < fitness:\n                        self.population[i] = gaussian_individual\n            # Dynamically adjust the population size based on the convergence speed\n            if evaluations > self.budget / 2 and self.population_size < self.initial_population_size * 2:\n                self.population_size = int(self.population_size * (1 + self.convergence_speed))\n                self.population = np.vstack((self.population, np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(self.population), self.dim))))\n        return self.best_individual", "name": "HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v4", "description": "Hybrid Sine Cosine Algorithm with Levy Flight, Simulated Annealing, Adaptive Chaotic Opposition-Based Learning, Gaussian Mutation, and Dynamic Population Size, incorporating a new weighted opposition-based learning strategy, an adaptive Levy flight scale, a novel convergence speed-based dynamic population size adjustment, and a refined strategy for individual updates based on a probabilistic approach.", "configspace": "", "generation": 29, "fitness": 0.16036315562575748, "feedback": "The algorithm HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.19.", "error": "", "parent_id": "0687844e-91ca-453d-99dc-19f3cfc74f9d", "metadata": {"aucs": [0.1810818545890195, 0.2209870819708235, 0.22817825243158518, 0.2669976806798713, 0.20179616725838667, 0.23040729568147156, 0.28985525208074403, 0.264420973663843, 0.21585828624876002, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04154387105897095, 0.054122002106388956, 0.07267803135466655, 0.06514431111968044, 0.0480441740313996, 0.07087804556596089, 0.06231406092732683, 0.060690435422834366, 0.07896208472522193, 0.07608755685296165, 0.04267871462979489, 0.05729236795229664, 0.04309070363746359, 0.05635757934558405, 0.041415998621061934, 0.08419263176328151, 0.05781610640831991, 0.07971099144226901, 0.9735515487337908, 0.9869204105997552, 0.9661678771431387, 0.9761550622589816, 0.9493961926027038, 0.9806831036047888, 0.9648456866048116, 0.9519567587842047, 0.9748387759161639, 0.1077012510113371, 0.16565119401622364, 0.10012864156195356, 0.1771971335106406, 0.14645680694029595, 0.2096767806380997, 0.16666209620592543, 0.12350283124252559, 0.0626370201462243, 0.20942129907572427, 0.15922227722442317, 0.2785132924856796, 0.1638558719017399, 0.17897409342130555, 0.14704672324435286, 0.18322000519825477, 0.16564968671758584, 0.1388986434842716, 0.1205446105389747, 0.08353228703193849, 0.060070838207209265, 0.10547617367156126, 0.08920524190613888, 0.0771206967377488, 0.08416410173456101, 0.09333178971419742, 0.12336332820836926, 0.2106598134501544, 0.15247130878322823, 0.11411503002961965, 0.17128461254964955, 0.11284868050134389, 0.1326919821818816, 0.12662304783102696, 0.1809503226962934, 0.17932424796162139, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0003036908406635064, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07642185858450357, 0.025969293430251672, 0.09135437670005009, 0.07832709481641431, 0.013681183250907614, 0.02719559529416693, 0.10765452840160872, 0.064975681939071, 0.03563069534330332, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.041276740122866085, 0.03883376174004438, 9.999999999998899e-05, 0.0021774709558889382, 0.004787157597494485, 0.018633310921391644, 0.002233787908674789, 0.08698948483643743, 0.06818965884233386, 0.0004895912184148532, 0.0070649338512582815, 0.052717292496553436, 0.21321709242600617, 0.1574943200162816, 0.23736474436767907, 0.343783707984731, 0.32568483188261266, 0.27822376335613763, 0.24495752113012792, 0.2687702496619019, 0.2925537542840484, 0.05363853173335542, 0.04025484524455647, 0.0555976432279518, 0.03348544122367858, 0.05515554584319893, 0.08322258421915174, 0.06286565804304578, 0.056523810359424664, 0.10697420927400203, 0.12873546518081436, 0.16359649392876985, 0.11819493251829116, 0.1441030950313299, 0.11541162418887307, 0.13007286968924314, 0.13370795119594736, 0.12927888669102472, 0.14796699310257178, 0.22305738127748675, 0.20242029542023665, 0.18527623469254673, 0.20384020071313969, 0.19658313849081854, 0.20468180931664415, 0.19683681031830425, 0.17358544694111333, 0.18393556085288632, 0.1383843624237523, 0.10889830168369063, 0.16994231599523824, 0.13778118658470628, 0.1548434662048105, 0.14534250826794926, 0.09824944474190289, 0.14902100041706767, 0.1594127753948935, 0.3124441836107743, 0.2627277263169784, 0.26017666954069796, 0.2856710347051067, 0.259844623792132, 0.2609396890009765, 0.27988988341612375, 0.25919320717526917, 0.28381880985909813, 0.15781989986195, 0.16190178227614127, 0.1670258781016204, 0.21117362282245444, 0.18141141126319904, 0.16845231401089056, 0.2007885425440754, 0.1765020297054809, 0.15450598288156558, 0.2771326554259873, 0.16266226015152063, 0.22702851329336615, 0.18242388486689598, 0.39596645210515624, 0.1315368175292817, 0.2275571678856344, 0.15822337648991092, 0.16742385705439478, 0.22968489665597336, 0.15629139974514672, 0.10612129648643309, 0.14531623684971418, 0.1700347304591736, 0.11187557315015306, 0.11112943616311044, 0.12608385545559397, 0.1994461610185978, 0.19209708544172177, 0.1857639194768146, 0.17595436323436775, 0.19379188950082393, 0.18345366257198603, 0.18725818187006693, 0.16656453662421355, 0.18653767142210553, 0.1910795633428568, 0.06774311583736925, 0.08806382661074763, 0.0721420821347496, 0.07138170075805139, 0.07259354861378364, 0.0663994937906004, 0.057980644543228266, 0.07639690607243754, 0.05346587743245723]}, "mutation_prompt": null}
{"id": "0e845779-2f6a-4547-bc6c-1deabb458bf0", "solution": "import numpy as np\n\nclass HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.best_fitness = np.inf\n        self.chaotic_map = np.random.uniform(0, 1, self.dim)\n        self.adaptive_prob = 0.2\n        self.mutation_prob = 0.1\n        self.levy_flight_scale = 1.0\n        self.opposition_weight = 0.5\n        self.convergence_speed = 0.0\n        self.successful_adaptations = 0\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def chaotic_opposition_based_learning(self, individual):\n        chaotic_individual = self.lower_bound + (self.upper_bound - self.lower_bound) * self.chaotic_map\n        self.chaotic_map = 4 * self.chaotic_map * (1 - self.chaotic_map)\n        return chaotic_individual\n\n    def levy_flight(self, individual):\n        levy_flight = np.random.normal(0, self.levy_flight_scale, self.dim) / np.random.normal(0, self.levy_flight_scale, self.dim)\n        levy_flight = individual + levy_flight\n        return levy_flight\n\n    def gaussian_mutation(self, individual):\n        gaussian_mutation = individual + np.random.normal(0, 0.1, self.dim)\n        return gaussian_mutation\n\n    def weighted_opposition_based_learning(self, individual):\n        opposite_individual = self.opposition_based_learning(individual)\n        weighted_individual = self.opposition_weight * individual + (1 - self.opposition_weight) * opposite_individual\n        return weighted_individual\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_individual = self.population[i]\n                    self.convergence_speed = 1.0 / (1.0 + evaluations / self.budget)\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                r3 = np.random.uniform(0, 1, self.dim)\n                r4 = np.random.uniform(0, 1, self.dim)\n                A = 2 * r1 - 1\n                B = np.abs(r2)\n                C = 2 * r3 - 1\n                D = np.abs(r4)\n                sine = np.abs(self.best_individual - self.population[i]) * np.sin(np.abs(r1) * np.pi)\n                cosine = np.abs(self.best_individual - self.population[i]) * np.cos(np.abs(r1) * np.pi)\n                if np.random.uniform(0, 1) < 0.5:\n                    self.population[i] = self.best_individual - (A * sine + B * cosine) * C * D\n                else:\n                    self.population[i] = self.best_individual + (A * sine + B * cosine) * C * D\n                levy_flight = self.levy_flight(self.population[i])\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                    self.levy_flight_scale *= 1.1 * (1.0 + self.convergence_speed)  # Increase the Levy flight scale if the Levy flight improves the fitness\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                        self.levy_flight_scale *= 0.9 / (1.0 + self.convergence_speed)  # Decrease the Levy flight scale if the Levy flight does not improve the fitness\n                self.levy_flight_scale = np.clip(self.levy_flight_scale, 0.1, 10.0)  # Clip the Levy flight scale to a reasonable range\n                # Apply adaptive chaotic opposition-based learning with a probability that adapts to the convergence speed\n                if np.random.uniform(0, 1) < self.adaptive_prob * (1.0 + self.convergence_speed):\n                    chaotic_individual = self.chaotic_opposition_based_learning(self.population[i])\n                    chaotic_fitness = func(chaotic_individual)\n                    evaluations += 1\n                    if chaotic_fitness < fitness:\n                        self.population[i] = chaotic_individual\n                        self.successful_adaptations += 1\n                        self.adaptive_prob *= 1.1  # Increase the probability if the chaotic opposition-based learning improves the fitness\n                    else:\n                        self.adaptive_prob *= 0.9  # Decrease the probability if the chaotic opposition-based learning does not improve the fitness\n                    self.adaptive_prob = np.clip(self.adaptive_prob, 0.1, 0.9)  # Clip the probability to a reasonable range\n                    # Adapt the adaptive probability based on the number of successful adaptations\n                    if self.successful_adaptations > self.population_size / 2:\n                        self.adaptive_prob *= 1.1\n                    elif self.successful_adaptations < self.population_size / 4:\n                        self.adaptive_prob *= 0.9\n                # Apply weighted opposition-based learning with a fixed probability\n                if np.random.uniform(0, 1) < 0.1:\n                    weighted_individual = self.weighted_opposition_based_learning(self.population[i])\n                    weighted_fitness = func(weighted_individual)\n                    evaluations += 1\n                    if weighted_fitness < fitness:\n                        self.population[i] = weighted_individual\n                # Apply Gaussian mutation with a fixed probability\n                if np.random.uniform(0, 1) < self.mutation_prob:\n                    gaussian_individual = self.gaussian_mutation(self.population[i])\n                    gaussian_fitness = func(gaussian_individual)\n                    evaluations += 1\n                    if gaussian_fitness < fitness:\n                        self.population[i] = gaussian_individual\n            # Dynamically adjust the population size based on the convergence speed\n            if evaluations > self.budget / 2 and self.population_size < self.initial_population_size * 2:\n                self.population_size = int(self.population_size * (1 + self.convergence_speed))\n                self.population = np.vstack((self.population, np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(self.population), self.dim))))\n        return self.best_individual", "name": "HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v4", "description": "Hybrid Sine Cosine Algorithm with Levy Flight, Simulated Annealing, Adaptive Chaotic Opposition-Based Learning, Gaussian Mutation, and Dynamic Population Size, incorporating a new weighted opposition-based learning strategy, an adaptive Levy flight scale, a novel convergence speed-based dynamic population size adjustment, and a refined adaptive chaotic opposition-based learning probability adaptation.", "configspace": "", "generation": 30, "fitness": 0.1816865921266094, "feedback": "The algorithm HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": "0687844e-91ca-453d-99dc-19f3cfc74f9d", "metadata": {"aucs": [0.3483660695569568, 0.39335299044665806, 0.3830293337698495, 0.35245391148969996, 0.35480734502815225, 0.33599290789056424, 0.20465569011204443, 0.29482959960884636, 0.31012732880991356, 0.006101540826816798, 0.004408645657979271, 9.999999999998899e-05, 0.023731332063787858, 0.035123744989970285, 0.03287237615558203, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10616641496016488, 0.09112460686416668, 0.057244543745695764, 0.07374568175041119, 0.07845253834237353, 0.038933289291747664, 0.09729944136125435, 0.07595618192063047, 0.07256156885616727, 0.13917485663095908, 0.07292809003432354, 0.05276626536205531, 0.04471996661926747, 0.062135209880938236, 0.06436007194196058, 0.11472772412227372, 0.044553202390251845, 0.061797978671427334, 0.9620475263937371, 0.9685159114725519, 0.9663670171603075, 0.957017045825137, 0.9492407953630975, 0.980237222983075, 0.9687685507596977, 0.9380312729234234, 0.9779492012709087, 0.2690610785865558, 0.17685911779436791, 0.21349418796739428, 0.23810414846805428, 0.2717554885444814, 0.17128799226113023, 0.24459243237122863, 0.21087574725800284, 0.25888884423332925, 0.18403098759484715, 0.17581545971223955, 0.1740606247949329, 0.21662206388783456, 0.12480491628106316, 0.14068891999849198, 0.16485468606277331, 0.17184376690266367, 0.1566817974773831, 0.11099402546735182, 0.10642697193757744, 0.11767947591467276, 0.12792347989795982, 0.11873439771755423, 0.12313449187642822, 0.1336169289631871, 0.1051007129271524, 0.14206785192012683, 0.21554596779024793, 0.21771881094038692, 0.1738472068307374, 0.12882761920612773, 0.19484233437993548, 0.16679329665221354, 0.1891575868878932, 0.20002598663814042, 0.19743109561336236, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.038986548826404066, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04758524469800285, 0.026558168419156702, 0.060762139200913445, 0.06828131103255386, 0.005278695162778013, 0.010233977452737797, 0.1568489342183127, 0.02887214690240858, 0.06933817130047881, 9.999999999998899e-05, 0.015456850290480162, 9.999999999998899e-05, 0.0029439979029691754, 9.999999999998899e-05, 0.03287734185106639, 0.01714788215876273, 0.01382599320925093, 0.024688820735513928, 0.06254349086499911, 0.08703788947995139, 0.10018652942153061, 0.09391760200819821, 0.09025907301743485, 0.11747336729092839, 0.006868343101460006, 0.02201907577626483, 0.0848383868363709, 0.23055683598278043, 0.2119268610124424, 0.33336917704079483, 0.3362636776119723, 0.23405549882853027, 0.35225240923505496, 0.25590380713471106, 0.2856302865379525, 0.22533003835013832, 0.1548391989254353, 0.06801286537603068, 0.054237238693998546, 0.08571693422120785, 0.05192085421079007, 0.09099856601218037, 0.08409744068860181, 0.07265324650095484, 0.058325394541602904, 0.2010993428218495, 0.1703963294729035, 0.11836193710181309, 0.21631279550350546, 0.17953718117575268, 0.1563855824614151, 0.1935884137382048, 0.1545450099850747, 0.14280421793187448, 0.23275789301050287, 0.1893548854664513, 0.16479391276209387, 0.2124925772777717, 0.2179529594547801, 0.18000366949218682, 0.17612434427813128, 0.17998779146059418, 0.19601917712541705, 0.1728993174769221, 0.2256523076227478, 0.1733742032932971, 0.18883657662900477, 0.1992178772451051, 0.11535496378905152, 0.13414506373038604, 0.15497113028298515, 0.13482506501084413, 0.28250741639333965, 0.2937042380524192, 0.30275663681709775, 0.27284060909183605, 0.2847008391967736, 0.27824194237754696, 0.300462648349046, 0.2983884270253485, 0.2947366230901074, 0.18709749575113888, 0.17185213162124457, 0.17336569822717773, 0.1884496752417012, 0.2000092936599972, 0.16456005786131167, 0.1610136884987945, 0.21610323264268527, 0.1803850669868089, 0.1798926001710881, 0.2591723108623468, 0.30242551866206036, 0.17392239106200635, 0.4675178161743554, 0.17322648467632462, 0.15575140559752887, 0.45757259501442216, 0.16471457234576103, 0.27964843301951703, 0.15746941287519478, 0.13646072352155347, 0.20100023834250302, 0.15073963860095374, 0.17833268067940022, 0.14863720715270645, 0.19662620545771403, 0.1613579470005423, 0.2014229317592604, 0.18185584219236828, 0.1971469637433204, 0.1790869562096039, 0.18440510365942497, 0.24128652333860745, 0.1850322091227249, 0.20542403456676206, 0.1889248102926333, 0.06415125195577787, 0.07216550696834734, 0.066134889963394, 0.062140466189148036, 0.06399530307327861, 0.08890677732214569, 0.0673159649724896, 0.05658457861668287, 0.05759955057387578]}, "mutation_prompt": null}
{"id": "7f3d60b6-ed78-4d25-8f96-91545b176fcd", "solution": "import numpy as np\n\nclass HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.best_fitness = np.inf\n        self.chaotic_map = np.random.uniform(0, 1, self.dim)\n        self.adaptive_prob = 0.2\n        self.mutation_prob = 0.1\n        self.levy_flight_scale = 1.0\n        self.opposition_weight = 0.5\n        self.convergence_speed = 0.0\n        self.adaptive_opposition_prob = 0.1  # Novel adaptive opposition-based learning probability\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def chaotic_opposition_based_learning(self, individual):\n        chaotic_individual = self.lower_bound + (self.upper_bound - self.lower_bound) * self.chaotic_map\n        self.chaotic_map = 4 * self.chaotic_map * (1 - self.chaotic_map)\n        return chaotic_individual\n\n    def levy_flight(self, individual):\n        levy_flight = np.random.normal(0, self.levy_flight_scale, self.dim) / np.random.normal(0, self.levy_flight_scale, self.dim)\n        levy_flight = individual + levy_flight\n        return levy_flight\n\n    def gaussian_mutation(self, individual):\n        gaussian_mutation = individual + np.random.normal(0, 0.1, self.dim)\n        return gaussian_mutation\n\n    def weighted_opposition_based_learning(self, individual):\n        opposite_individual = self.opposition_based_learning(individual)\n        weighted_individual = self.opposition_weight * individual + (1 - self.opposition_weight) * opposite_individual\n        return weighted_individual\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_individual = self.population[i]\n                    self.convergence_speed = 1.0 / (1.0 + evaluations / self.budget)\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                r3 = np.random.uniform(0, 1, self.dim)\n                r4 = np.random.uniform(0, 1, self.dim)\n                A = 2 * r1 - 1\n                B = np.abs(r2)\n                C = 2 * r3 - 1\n                D = np.abs(r4)\n                sine = np.abs(self.best_individual - self.population[i]) * np.sin(np.abs(r1) * np.pi)\n                cosine = np.abs(self.best_individual - self.population[i]) * np.cos(np.abs(r1) * np.pi)\n                if np.random.uniform(0, 1) < 0.5:\n                    self.population[i] = self.best_individual - (A * sine + B * cosine) * C * D\n                else:\n                    self.population[i] = self.best_individual + (A * sine + B * cosine) * C * D\n                levy_flight = self.levy_flight(self.population[i])\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                    self.levy_flight_scale *= 1.1 * (1.0 + self.convergence_speed)  # Increase the Levy flight scale if the Levy flight improves the fitness\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                        self.levy_flight_scale *= 0.9 / (1.0 + self.convergence_speed)  # Decrease the Levy flight scale if the Levy flight does not improve the fitness\n                self.levy_flight_scale = np.clip(self.levy_flight_scale, 0.1, 10.0)  # Clip the Levy flight scale to a reasonable range\n                # Apply adaptive chaotic opposition-based learning with a probability that adapts to the convergence speed\n                if np.random.uniform(0, 1) < self.adaptive_prob * (1.0 + self.convergence_speed):\n                    chaotic_individual = self.chaotic_opposition_based_learning(self.population[i])\n                    chaotic_fitness = func(chaotic_individual)\n                    evaluations += 1\n                    if chaotic_fitness < fitness:\n                        self.population[i] = chaotic_individual\n                        self.adaptive_prob *= 1.1  # Increase the probability if the chaotic opposition-based learning improves the fitness\n                    else:\n                        self.adaptive_prob *= 0.9  # Decrease the probability if the chaotic opposition-based learning does not improve the fitness\n                    self.adaptive_prob = np.clip(self.adaptive_prob, 0.1, 0.9)  # Clip the probability to a reasonable range\n                # Apply adaptive opposition-based learning with a novel adaptive probability\n                if np.random.uniform(0, 1) < self.adaptive_opposition_prob * (1.0 + self.convergence_speed):\n                    weighted_individual = self.weighted_opposition_based_learning(self.population[i])\n                    weighted_fitness = func(weighted_individual)\n                    evaluations += 1\n                    if weighted_fitness < fitness:\n                        self.population[i] = weighted_individual\n                        self.adaptive_opposition_prob *= 1.1  # Increase the probability if the opposition-based learning improves the fitness\n                    else:\n                        self.adaptive_opposition_prob *= 0.9  # Decrease the probability if the opposition-based learning does not improve the fitness\n                    self.adaptive_opposition_prob = np.clip(self.adaptive_opposition_prob, 0.01, 0.5)  # Clip the probability to a reasonable range\n                # Apply Gaussian mutation with a fixed probability\n                if np.random.uniform(0, 1) < self.mutation_prob:\n                    gaussian_individual = self.gaussian_mutation(self.population[i])\n                    gaussian_fitness = func(gaussian_individual)\n                    evaluations += 1\n                    if gaussian_fitness < fitness:\n                        self.population[i] = gaussian_individual\n            # Dynamically adjust the population size based on the convergence speed\n            if evaluations > self.budget / 2 and self.population_size < self.initial_population_size * 2:\n                self.population_size = int(self.population_size * (1 + self.convergence_speed))\n                self.population = np.vstack((self.population, np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(self.population), self.dim))))\n        return self.best_individual", "name": "HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v4", "description": "Hybrid Sine Cosine Algorithm with Levy Flight, Simulated Annealing, Adaptive Chaotic Opposition-Based Learning, Gaussian Mutation, Dynamic Population Size, and Novel Convergence Speed-Based Adaptive Levy Flight Scale and Opposition-Based Learning Probability Adjustment.", "configspace": "", "generation": 31, "fitness": 0.17690073568924228, "feedback": "The algorithm HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": "0687844e-91ca-453d-99dc-19f3cfc74f9d", "metadata": {"aucs": [0.20554859560204164, 0.4080846216912192, 0.40282516795380285, 0.22637995156571922, 0.37676604000592806, 0.2956065187929585, 0.3666140727445619, 0.2689088940144242, 0.3568917810605372, 9.999999999998899e-05, 0.0002988766798460718, 9.999999999998899e-05, 0.012558376692395345, 0.04430222187557298, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09995308092976918, 0.05957093281699366, 0.05557690479834787, 0.05866588535410322, 0.047653060508945244, 0.09783381733028329, 0.12177815167491568, 0.06811261206520358, 0.07632826616422039, 0.05265001035383321, 0.08899521535244426, 0.0919849577687728, 0.040832246534644234, 0.05048062242742146, 0.10762841002883872, 0.08254395547258664, 0.06691767728976461, 0.04403408975184042, 0.9782098168484321, 0.9656610437552978, 0.9636069609796841, 0.9492709009786553, 0.9379838242472042, 0.9793205641097327, 0.9588830220855863, 0.9212178273350322, 0.9765023427177524, 0.28056760571875106, 0.21998325502022675, 0.2659497275915944, 0.28565499466992617, 0.22973491445488192, 0.27808891907051314, 0.24657808957749017, 0.20704559552793567, 0.25479624096468256, 0.16693025297365072, 0.1495134167209895, 0.22394041885358495, 0.18206817970609823, 0.16499762898228965, 0.1288038143111342, 0.24659915639272312, 0.19046755154470096, 0.2053294864873768, 0.15639673439190815, 0.08660424343789996, 0.08685365780492016, 0.11674224120458332, 0.14998862147590442, 0.10550570554743421, 0.17503802669407542, 0.19125431673997373, 0.09203036607410975, 0.17296280540229514, 0.21896555068138246, 0.17048013835722997, 0.21124943975411836, 0.16571775004778688, 0.16707243313843667, 0.21115803229943197, 0.17535318102343156, 0.16967571127403402, 0.00021490908938448516, 9.999999999998899e-05, 9.999999999998899e-05, 0.012298467902228771, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.048958160857677235, 0.03488306769850802, 0.06216713287523001, 0.07269839258603572, 0.005663814047161764, 0.013895481658661502, 0.0849237851249387, 0.01777907884901997, 0.06425633298579647, 0.005777233083718247, 0.014434702705374503, 9.999999999998899e-05, 0.014528708631828313, 9.999999999998899e-05, 0.028614952074397793, 0.004091790216800506, 0.02073063384085294, 0.01171289009824028, 0.09980081244096362, 0.039164312988896, 0.049076356801394994, 0.01813762183993728, 0.025081623796200603, 0.046736692777987865, 0.0021669467185961855, 0.07696037180354598, 0.055506963356139805, 0.2923687919268694, 0.2006429853182603, 0.3350983827924602, 0.3451187337243051, 0.35478180069072407, 0.2062176544763099, 0.25578208210887354, 0.28836298798811477, 0.2228524022529138, 0.06682699704694406, 0.0673535934459123, 0.04683135455040266, 0.07824369490327421, 0.05810840765631453, 0.0639971037302588, 0.10059438869899207, 0.06423335233556504, 0.04961260155189107, 0.13646575385646198, 0.20663054949598836, 0.11820714530906085, 0.16677943708751153, 0.16783105769737194, 0.12695048392823483, 0.15591145443698773, 0.2464785868644066, 0.16333688085952836, 0.20167611835761656, 0.2917857776273751, 0.18636213958871162, 0.19879740855311123, 0.2175668506381575, 0.21588922589680004, 0.16989285183670744, 0.19309845054482289, 0.17306198216067192, 0.12865163119622214, 0.16298681604374177, 0.12392458987218402, 0.12994714268475205, 0.1621504150442732, 0.18730458866633104, 0.10816128755075138, 0.12658709932067613, 0.10650255871116077, 0.30056527619963036, 0.285450750810038, 0.2889505604289916, 0.2760951655775954, 0.2915795124837607, 0.2757754744486971, 0.29030008165302656, 0.29154328766049986, 0.2905443240970029, 0.1626101434311802, 0.17859988295798013, 0.18281963483263086, 0.1899154819033917, 0.19878602287685876, 0.16816431121497777, 0.15711629564439133, 0.16891353962536393, 0.1728268956907295, 0.17116513609433548, 0.16187428405138293, 0.21449803414503588, 0.15374785018062154, 0.1457227287485484, 0.1492838109677459, 0.17201974896691286, 0.16053254954859042, 0.12717563562379275, 0.32365580367496494, 0.13149496447566256, 0.18662112076890414, 0.1401292137302277, 0.3113384899002114, 0.1073033949691724, 0.10509638463982207, 0.33607976679822116, 0.25421807476658265, 0.19356700093868862, 0.21980334701493298, 0.18645877972713687, 0.1849769970522247, 0.18435491867385567, 0.20118164011333306, 0.1950390181057644, 0.19119141224642022, 0.22037196746873355, 0.11601459784142831, 0.06245095658326627, 0.07390416962445356, 0.06576237212386482, 0.06454797732577844, 0.07158915060657622, 0.07964075101619694, 0.0639970836903081, 0.05438677698154393]}, "mutation_prompt": null}
{"id": "99ec624e-20e3-47af-a5db-1974a78b0e55", "solution": "import numpy as np\n\nclass HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.best_fitness = np.inf\n        self.chaotic_map = np.random.uniform(0, 1, self.dim)\n        self.adaptive_prob = 0.3  # Increased from 0.2\n        self.mutation_prob = 0.2  # Increased from 0.1\n        self.levy_flight_scale = 1.0\n        self.opposition_weight = 0.5\n        self.convergence_speed = 0.0\n        self.gaussian_mutation_stddev = 0.1  # New adaptive Gaussian mutation stddev\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def chaotic_opposition_based_learning(self, individual):\n        chaotic_individual = self.lower_bound + (self.upper_bound - self.lower_bound) * self.chaotic_map\n        self.chaotic_map = 4 * self.chaotic_map * (1 - self.chaotic_map)\n        return chaotic_individual\n\n    def levy_flight(self, individual):\n        levy_flight = np.random.normal(0, self.levy_flight_scale, self.dim) / np.random.normal(0, self.levy_flight_scale, self.dim)\n        levy_flight = individual + levy_flight\n        return levy_flight\n\n    def gaussian_mutation(self, individual):\n        gaussian_mutation = individual + np.random.normal(0, self.gaussian_mutation_stddev, self.dim)\n        return gaussian_mutation\n\n    def weighted_opposition_based_learning(self, individual):\n        opposite_individual = self.opposition_based_learning(individual)\n        weighted_individual = self.opposition_weight * individual + (1 - self.opposition_weight) * opposite_individual\n        return weighted_individual\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_individual = self.population[i]\n                    self.convergence_speed = 1.0 / (1.0 + evaluations / self.budget)\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                r3 = np.random.uniform(0, 1, self.dim)\n                r4 = np.random.uniform(0, 1, self.dim)\n                A = 2 * r1 - 1\n                B = np.abs(r2)\n                C = 2 * r3 - 1\n                D = np.abs(r4)\n                sine = np.abs(self.best_individual - self.population[i]) * np.sin(np.abs(r1) * np.pi)\n                cosine = np.abs(self.best_individual - self.population[i]) * np.cos(np.abs(r1) * np.pi)\n                if np.random.uniform(0, 1) < 0.5:\n                    self.population[i] = self.best_individual - (A * sine + B * cosine) * C * D\n                else:\n                    self.population[i] = self.best_individual + (A * sine + B * cosine) * C * D\n                levy_flight = self.levy_flight(self.population[i])\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                    self.levy_flight_scale *= 1.1 * (1.0 + self.convergence_speed)  # Increase the Levy flight scale if the Levy flight improves the fitness\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                        self.levy_flight_scale *= 0.9 / (1.0 + self.convergence_speed)  # Decrease the Levy flight scale if the Levy flight does not improve the fitness\n                self.levy_flight_scale = np.clip(self.levy_flight_scale, 0.1, 10.0)  # Clip the Levy flight scale to a reasonable range\n                # Apply adaptive chaotic opposition-based learning with a probability that adapts to the convergence speed\n                if np.random.uniform(0, 1) < self.adaptive_prob * (1.0 + self.convergence_speed):\n                    chaotic_individual = self.chaotic_opposition_based_learning(self.population[i])\n                    chaotic_fitness = func(chaotic_individual)\n                    evaluations += 1\n                    if chaotic_fitness < fitness:\n                        self.population[i] = chaotic_individual\n                        self.adaptive_prob *= 1.1  # Increase the probability if the chaotic opposition-based learning improves the fitness\n                    else:\n                        self.adaptive_prob *= 0.9  # Decrease the probability if the chaotic opposition-based learning does not improve the fitness\n                    self.adaptive_prob = np.clip(self.adaptive_prob, 0.1, 0.9)  # Clip the probability to a reasonable range\n                # Apply weighted opposition-based learning with a fixed probability\n                if np.random.uniform(0, 1) < 0.1:\n                    weighted_individual = self.weighted_opposition_based_learning(self.population[i])\n                    weighted_fitness = func(weighted_individual)\n                    evaluations += 1\n                    if weighted_fitness < fitness:\n                        self.population[i] = weighted_individual\n                # Apply adaptive Gaussian mutation with a fixed probability\n                if np.random.uniform(0, 1) < self.mutation_prob:\n                    gaussian_individual = self.gaussian_mutation(self.population[i])\n                    gaussian_fitness = func(gaussian_individual)\n                    evaluations += 1\n                    if gaussian_fitness < fitness:\n                        self.population[i] = gaussian_individual\n                        self.gaussian_mutation_stddev *= 1.1  # Increase the Gaussian mutation stddev if the mutation improves the fitness\n                    else:\n                        self.gaussian_mutation_stddev *= 0.9  # Decrease the Gaussian mutation stddev if the mutation does not improve the fitness\n                    self.gaussian_mutation_stddev = np.clip(self.gaussian_mutation_stddev, 0.01, 1.0)  # Clip the Gaussian mutation stddev to a reasonable range\n            # Dynamically adjust the population size based on the convergence speed\n            if evaluations > self.budget / 2 and self.population_size < self.initial_population_size * 2:\n                self.population_size = int(self.population_size * (1 + self.convergence_speed))\n                self.population = np.vstack((self.population, np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(self.population), self.dim))))\n        return self.best_individual", "name": "HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v4", "description": "Hybrid Sine Cosine Algorithm with Levy Flight, Simulated Annealing, Adaptive Chaotic Opposition-Based Learning, Gaussian Mutation, and Dynamic Population Size, incorporating a new weighted opposition-based learning strategy, an adaptive Levy flight scale, and a novel convergence speed-based dynamic population size adjustment, with refined adaptive probabilities and a new adaptive Gaussian mutation.", "configspace": "", "generation": 32, "fitness": 0.19735365939601066, "feedback": "The algorithm HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.20.", "error": "", "parent_id": "0687844e-91ca-453d-99dc-19f3cfc74f9d", "metadata": {"aucs": [0.4946122463219754, 0.4866317405706134, 0.33634605596290945, 0.43158099483446166, 0.23378359068871246, 0.4829879298809573, 0.5710978004704375, 0.5859091512425121, 0.23249374022656388, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09511861576622938, 0.016376449601867127, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09995079726782663, 0.09961783069083052, 0.08262176231566354, 0.13361887165803288, 0.054212017481125474, 0.0814162853860545, 0.06346577761671524, 0.1288544738290851, 0.05902104789553142, 0.04561381777209095, 0.10155073533284742, 0.05536403420887814, 0.05588855286472083, 0.08221176874514435, 0.09133208001465842, 0.0763414180163412, 0.08813562059691016, 0.10703639190455483, 0.9671840144490472, 0.9691664312756316, 0.9627937811888257, 0.9555262902342743, 0.9529847817081674, 0.977193726469518, 0.9095223301382849, 0.9545166153687217, 0.9609426378464033, 0.26268211307288414, 0.25766822794241906, 0.2564046736645593, 0.32123541256249877, 0.29469329206298467, 0.26721416851252444, 0.26183519283420886, 0.3121677391241324, 0.2182449161435338, 0.17827301850322763, 0.13571926928113975, 0.2602681264919572, 0.1377930753230563, 0.1579922480201863, 0.1871564278033364, 0.144631464031042, 0.16403199943800884, 0.2223343790031861, 0.2565429572858877, 0.08697950647019059, 0.1384944594932762, 0.1360434466901621, 0.15982314879001513, 0.12560499023746907, 0.10779733715100337, 0.09799280472824612, 0.13671793311275282, 0.2330620286872529, 0.18650190471676475, 0.15792884194253343, 0.17366710805240104, 0.19554726640471798, 0.18704139547137955, 0.2010985816515084, 0.16859901496172824, 0.21923897353213506, 9.999999999998899e-05, 9.999999999998899e-05, 0.025033939974040686, 9.999999999998899e-05, 9.999999999998899e-05, 0.015144604559895969, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06406034525864202, 0.04734382224342937, 0.08151601067185599, 0.07493515204095458, 0.016562806571065236, 0.017906539906482277, 0.1302423243733234, 0.0719790252389042, 0.050010076708874474, 0.019205984152800948, 0.03827431945095994, 0.05285902308784085, 0.07174122017538287, 0.08467393654832556, 0.05921195147112268, 0.11679000741383039, 0.12449048611487723, 0.02583025347264467, 0.0691531553958068, 0.049253313209166816, 0.1351751296799253, 0.06772161323319636, 0.06801567322254765, 0.13378372720154152, 0.12804224593730817, 0.054702002052518184, 0.1775334642680556, 0.3671710755382147, 0.26315345477649366, 0.2978583138825879, 0.39245452644052337, 0.3903501548701357, 0.2208531586368302, 0.33983524807106735, 0.3357818257542493, 0.2659471312846923, 0.11431147654088292, 0.09621969243542805, 0.0757914644330453, 0.06759745826374697, 0.06445325524645962, 0.07454422652627823, 0.09829883084385693, 0.07899415763903617, 0.0643455116464503, 0.1287946209746944, 0.1827593434925905, 0.11874038091052885, 0.2700005607409258, 0.21687306510491244, 0.15074888922235674, 0.12813880427557756, 0.16072488453809253, 0.14241091376659964, 0.19412047067996863, 0.19058086250950124, 0.16111394958305503, 0.19726374288959092, 0.2162881358036689, 0.2049278543860068, 0.18241497287179587, 0.1735515361631067, 0.168226378093717, 0.14645883777974555, 0.14773082810741944, 0.17146170607777822, 0.1748917377138106, 0.1474012686442756, 0.16733022295822342, 0.11198748932999292, 0.09958597570152683, 0.19016506637582542, 0.3086313241287638, 0.3295765786310585, 0.3095418210183438, 0.3178418604824774, 0.32223681983981456, 0.3034933073614373, 0.33676425050851844, 0.31190806808725824, 0.34024678427487465, 0.17982271251067217, 0.1708170190595587, 0.18011857630224382, 0.17428642628923696, 0.21236846238601992, 0.18861703670327268, 0.19365836973012174, 0.18199737647787484, 0.17788765881867752, 0.16727849102210857, 0.15856391318181162, 0.25651352526506055, 0.16632730329066325, 0.14134480010691075, 0.15905051695021977, 0.4772320408812699, 0.3481164207470492, 0.7778373164942669, 0.21759134941282587, 0.24774072729763608, 0.15521021887138375, 0.17803272114644808, 0.1930907028689639, 0.1107933022107398, 0.12352009209739923, 0.12337799492465384, 0.2406175179066692, 0.19559960269274623, 0.19270608912908416, 0.19506104495558219, 0.20871692374340223, 0.17886309463871108, 0.24565734303993436, 0.2335272011605477, 0.221614565964945, 0.1819766981028298, 0.06026213022169502, 0.08607365776641673, 0.07104359709336328, 0.07833100497208456, 0.071616913347333, 0.07807589369147427, 0.0740643953946385, 0.09466161702221199, 0.061189983116978874]}, "mutation_prompt": null}
{"id": "3b9ea616-8d11-4cd9-9a55-930899b5bc3c", "solution": "import numpy as np\n\nclass HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        for i in range(self.population_size):\n            if np.random.uniform(0, 1) < 0.32:\n                self.population[i] = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.normal(0, 1, self.dim)\n        self.best_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.best_fitness = np.inf\n        self.chaotic_map = np.random.uniform(0, 1, self.dim)\n        self.adaptive_prob = 0.3  # Increased from 0.2\n        self.mutation_prob = 0.2  # Increased from 0.1\n        self.levy_flight_scale = 1.0\n        self.opposition_weight = 0.5\n        self.convergence_speed = 0.0\n        self.gaussian_mutation_stddev = 0.1  # New adaptive Gaussian mutation stddev\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def chaotic_opposition_based_learning(self, individual):\n        chaotic_individual = self.lower_bound + (self.upper_bound - self.lower_bound) * self.chaotic_map\n        self.chaotic_map = 4 * self.chaotic_map * (1 - self.chaotic_map)\n        return chaotic_individual\n\n    def levy_flight(self, individual):\n        levy_flight = np.random.normal(0, self.levy_flight_scale, self.dim) / np.random.normal(0, self.levy_flight_scale, self.dim)\n        levy_flight = individual + levy_flight\n        return levy_flight\n\n    def gaussian_mutation(self, individual):\n        gaussian_mutation = individual + np.random.normal(0, self.gaussian_mutation_stddev, self.dim)\n        return gaussian_mutation\n\n    def weighted_opposition_based_learning(self, individual):\n        opposite_individual = self.opposition_based_learning(individual)\n        weighted_individual = self.opposition_weight * individual + (1 - self.opposition_weight) * opposite_individual\n        return weighted_individual\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_individual = self.population[i]\n                    self.convergence_speed = 1.0 / (1.0 + evaluations / self.budget)\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                r3 = np.random.uniform(0, 1, self.dim)\n                r4 = np.random.uniform(0, 1, self.dim)\n                A = 2 * r1 - 1\n                B = np.abs(r2)\n                C = 2 * r3 - 1\n                D = np.abs(r4)\n                sine = np.abs(self.best_individual - self.population[i]) * np.sin(np.abs(r1) * np.pi)\n                cosine = np.abs(self.best_individual - self.population[i]) * np.cos(np.abs(r1) * np.pi)\n                if np.random.uniform(0, 1) < 0.5:\n                    self.population[i] = self.best_individual - (A * sine + B * cosine) * C * D\n                else:\n                    self.population[i] = self.best_individual + (A * sine + B * cosine) * C * D\n                levy_flight = self.levy_flight(self.population[i])\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                    self.levy_flight_scale *= 1.1 * (1.0 + self.convergence_speed)  # Increase the Levy flight scale if the Levy flight improves the fitness\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                        self.levy_flight_scale *= 0.9 / (1.0 + self.convergence_speed)  # Decrease the Levy flight scale if the Levy flight does not improve the fitness\n                self.levy_flight_scale = np.clip(self.levy_flight_scale, 0.1, 10.0)  # Clip the Levy flight scale to a reasonable range\n                # Apply adaptive chaotic opposition-based learning with a probability that adapts to the convergence speed\n                if np.random.uniform(0, 1) < self.adaptive_prob * (1.0 + self.convergence_speed):\n                    chaotic_individual = self.chaotic_opposition_based_learning(self.population[i])\n                    chaotic_fitness = func(chaotic_individual)\n                    evaluations += 1\n                    if chaotic_fitness < fitness:\n                        self.population[i] = chaotic_individual\n                        self.adaptive_prob *= 1.1  # Increase the probability if the chaotic opposition-based learning improves the fitness\n                    else:\n                        self.adaptive_prob *= 0.9  # Decrease the probability if the chaotic opposition-based learning does not improve the fitness\n                    self.adaptive_prob = np.clip(self.adaptive_prob, 0.1, 0.9)  # Clip the probability to a reasonable range\n                # Apply weighted opposition-based learning with a fixed probability\n                if np.random.uniform(0, 1) < 0.1:\n                    weighted_individual = self.weighted_opposition_based_learning(self.population[i])\n                    weighted_fitness = func(weighted_individual)\n                    evaluations += 1\n                    if weighted_fitness < fitness:\n                        self.population[i] = weighted_individual\n                # Apply adaptive Gaussian mutation with a fixed probability\n                if np.random.uniform(0, 1) < self.mutation_prob:\n                    gaussian_individual = self.gaussian_mutation(self.population[i])\n                    gaussian_fitness = func(gaussian_individual)\n                    evaluations += 1\n                    if gaussian_fitness < fitness:\n                        self.population[i] = gaussian_individual\n                        self.gaussian_mutation_stddev *= 1.1  # Increase the Gaussian mutation stddev if the mutation improves the fitness\n                    else:\n                        self.gaussian_mutation_stddev *= 0.9  # Decrease the Gaussian mutation stddev if the mutation does not improve the fitness\n                    self.gaussian_mutation_stddev = np.clip(self.gaussian_mutation_stddev, 0.01, 1.0)  # Clip the Gaussian mutation stddev to a reasonable range\n            # Dynamically adjust the population size based on the convergence speed\n            if evaluations > self.budget / 2 and self.population_size < self.initial_population_size * 2:\n                self.population_size = int(self.population_size * (1 + self.convergence_speed))\n                self.population = np.vstack((self.population, np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(self.population), self.dim))))\n                for i in range(self.population_size - len(self.population), self.population_size):\n                    if np.random.uniform(0, 1) < 0.32:\n                        self.population[i] = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.normal(0, 1, self.dim)\n        return self.best_individual", "name": "HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v5", "description": "Hybrid Sine Cosine Algorithm with Levy Flight, Simulated Annealing, Adaptive Chaotic Opposition-Based Learning, Gaussian Mutation, and Dynamic Population Size, incorporating a new weighted opposition-based learning strategy, an adaptive Levy flight scale, and a novel convergence speed-based dynamic population size adjustment, with refined adaptive probabilities and a new adaptive Gaussian mutation, and an improved population initialization strategy with a probability of 0.32 to change the individual lines of the selected solution.", "configspace": "", "generation": 34, "fitness": 0.18865010387356257, "feedback": "The algorithm HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v5 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.20.", "error": "", "parent_id": "99ec624e-20e3-47af-a5db-1974a78b0e55", "metadata": {"aucs": [0.4537969925623796, 0.5487174862215527, 0.3150862314714301, 0.5586109027288116, 0.3464779367510271, 0.4787580789504424, 0.4449434592964586, 0.22725942363049612, 0.21934932428261955, 9.999999999998899e-05, 0.04763196396965086, 9.999999999998899e-05, 0.05029961071336253, 0.005658624197586115, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010032263452519619, 0.1069934908511464, 0.07789672114389945, 0.07377185738350323, 0.0975655487732261, 0.07449018881799696, 0.1039129480040285, 0.08555912854370562, 0.08836258039807943, 0.07536412952126825, 0.08438026608777704, 0.06709178425848694, 0.07613462764587509, 0.0745752888992729, 0.06670348927144765, 0.03738271212916189, 0.06540233453350741, 0.09322959709902734, 0.09138032439235844, 0.9622089818358206, 0.9747841684834627, 0.9743920112942184, 0.9866183493523861, 0.980476477961327, 0.991050623299642, 0.9938227312979305, 0.98701432436376, 0.9853104707980238, 0.29888101737137507, 0.2916252900512114, 0.21555396054794496, 0.14714192998269426, 0.21483039015532435, 0.1768490330649536, 0.16726331897066848, 0.3008950807793631, 0.2134178036199259, 0.2468803581460275, 0.18329873015760378, 0.19036025425684255, 0.1625297312251669, 0.20416701721431707, 0.18581581732482877, 0.17151695969406922, 0.1951103219262602, 0.1466085371934036, 0.14817081326678128, 0.11751149543626926, 0.1259512658219979, 0.08879303187302867, 0.1507466026449905, 0.11559019668644399, 0.12224282352124882, 0.1313739314575485, 0.3318472508904946, 0.200803056550111, 0.16371694411359472, 0.1923444674720819, 0.21983371783026195, 0.17719514828057725, 0.24112822001837297, 0.20794971595540712, 0.1989593277536995, 0.14337640765678294, 9.999999999998899e-05, 0.0700924524743487, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030142981455948625, 0.05905873625338043, 0.08375108170537882, 0.06546661986742042, 0.05117036612421033, 9.999999999998899e-05, 0.00868781658512785, 0.059907054518825276, 0.014695642971932155, 0.02191351231039118, 0.039156698620572805, 0.06457651954586197, 0.06768623901906923, 0.08607255679078551, 0.18905608811938068, 0.043589462488895725, 0.07509412978829755, 0.12436030770168693, 0.10473506736755211, 0.015597312490040371, 0.047708490133049786, 0.13809857375585743, 0.12757752582501458, 0.08859328151670831, 0.11879068480838761, 0.07700339136518874, 0.05583841302450343, 0.17870796740813566, 0.3508205549509602, 0.1799788626592479, 0.3445068163193441, 0.27281883659903083, 0.20099485229652136, 0.39392752120373586, 0.37950438100402495, 0.33177910220128726, 0.041514007509271145, 0.056872792462976385, 0.10590108701986012, 0.05519613410765456, 0.07668546617119043, 0.03338418565332579, 0.08211128810759416, 0.059124768423230334, 0.0742379628285742, 0.23072460047540022, 0.14019291620920227, 0.19187855611756532, 0.19472767122467027, 0.1421268727720746, 0.11527585318860312, 0.13973727523506663, 0.1875217091411152, 0.1640032605389693, 0.2160632052077487, 0.16706792746532662, 0.1644198623378823, 0.17603539179468464, 0.1810786738322332, 0.1918810453541, 0.16127863516748564, 0.1536429588756304, 0.20114471014100077, 0.1474915756902676, 0.1218382076606438, 0.14892863641111997, 0.12263960605911939, 0.20514467865621322, 0.1681569377265787, 0.1018068996796272, 0.22029515909946418, 0.12843788719168936, 0.2980337666847269, 0.33857874286566547, 0.29991815896820206, 0.2975772908187594, 0.28284334532063804, 0.30682375669583795, 0.3170021081033675, 0.3022182315948173, 0.2941319610490579, 0.17367554434383925, 0.20700793831882036, 0.1815500670348289, 0.17066234446429007, 0.222043264971996, 0.19429393585552268, 0.16263683326833256, 0.17518782020868218, 0.19625175286041763, 0.17427841364008834, 0.17203076081095459, 0.14810112604213577, 0.1458800573412805, 0.5608553971519881, 0.21415611178030014, 0.15421013017592722, 0.13546921169406212, 0.15826473918771278, 0.13890139165113558, 0.11983593672406456, 0.14782919646779136, 0.2966739600191842, 0.3144266966888297, 0.15191521981798983, 0.16862028415201546, 0.1685142076035019, 0.1494628679200607, 0.19878572954225682, 0.1627356397680132, 0.18294000176883196, 0.2352722065423294, 0.21822611196046338, 0.19067297929656202, 0.2073149204376432, 0.21876844345207525, 0.20798090326683283, 0.05537569500439454, 0.05260976851929555, 0.06400701734356207, 0.06445626625889656, 0.06205250465320755, 0.07666527627056441, 0.09136005320728458, 0.05883664972103231, 0.06622590780982152]}, "mutation_prompt": null}
{"id": "a258a123-10b8-4472-a4bb-336511c3cd78", "solution": "import numpy as np\n\nclass HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.best_fitness = np.inf\n        self.chaotic_map = np.random.uniform(0, 1, self.dim)\n        self.adaptive_prob = 0.3\n        self.mutation_prob = 0.2\n        self.levy_flight_scale = 1.0\n        self.opposition_weight = 0.5\n        self.convergence_speed = 0.0\n        self.gaussian_mutation_stddev = 0.1\n        self.harmony_memory_size = 10\n        self.harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        self.harmony_memory_fitness = np.inf * np.ones(self.harmony_memory_size)\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def chaotic_opposition_based_learning(self, individual):\n        chaotic_individual = self.lower_bound + (self.upper_bound - self.lower_bound) * self.chaotic_map\n        self.chaotic_map = 4 * self.chaotic_map * (1 - self.chaotic_map)\n        return chaotic_individual\n\n    def levy_flight(self, individual):\n        levy_flight = np.random.normal(0, self.levy_flight_scale, self.dim) / np.random.normal(0, self.levy_flight_scale, self.dim)\n        levy_flight = individual + levy_flight\n        return levy_flight\n\n    def gaussian_mutation(self, individual):\n        gaussian_mutation = individual + np.random.normal(0, self.gaussian_mutation_stddev, self.dim)\n        return gaussian_mutation\n\n    def weighted_opposition_based_learning(self, individual):\n        opposite_individual = self.opposition_based_learning(individual)\n        weighted_individual = self.opposition_weight * individual + (1 - self.opposition_weight) * opposite_individual\n        return weighted_individual\n\n    def harmony_search(self, individual):\n        harmony_individual = individual + np.random.uniform(-1, 1, self.dim) * (self.upper_bound - self.lower_bound)\n        return harmony_individual\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_individual = self.population[i]\n                    self.convergence_speed = 1.0 / (1.0 + evaluations / self.budget)\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                r3 = np.random.uniform(0, 1, self.dim)\n                r4 = np.random.uniform(0, 1, self.dim)\n                A = 2 * r1 - 1\n                B = np.abs(r2)\n                C = 2 * r3 - 1\n                D = np.abs(r4)\n                sine = np.abs(self.best_individual - self.population[i]) * np.sin(np.abs(r1) * np.pi)\n                cosine = np.abs(self.best_individual - self.population[i]) * np.cos(np.abs(r1) * np.pi)\n                if np.random.uniform(0, 1) < 0.5:\n                    self.population[i] = self.best_individual - (A * sine + B * cosine) * C * D\n                else:\n                    self.population[i] = self.best_individual + (A * sine + B * cosine) * C * D\n                levy_flight = self.levy_flight(self.population[i])\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                    self.levy_flight_scale *= 1.1 * (1.0 + self.convergence_speed)\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                        self.levy_flight_scale *= 0.9 / (1.0 + self.convergence_speed)\n                self.levy_flight_scale = np.clip(self.levy_flight_scale, 0.1, 10.0)\n                if np.random.uniform(0, 1) < self.adaptive_prob * (1.0 + self.convergence_speed):\n                    chaotic_individual = self.chaotic_opposition_based_learning(self.population[i])\n                    chaotic_fitness = func(chaotic_individual)\n                    evaluations += 1\n                    if chaotic_fitness < fitness:\n                        self.population[i] = chaotic_individual\n                        self.adaptive_prob *= 1.1\n                    else:\n                        self.adaptive_prob *= 0.9\n                    self.adaptive_prob = np.clip(self.adaptive_prob, 0.1, 0.9)\n                if np.random.uniform(0, 1) < 0.1:\n                    weighted_individual = self.weighted_opposition_based_learning(self.population[i])\n                    weighted_fitness = func(weighted_individual)\n                    evaluations += 1\n                    if weighted_fitness < fitness:\n                        self.population[i] = weighted_individual\n                if np.random.uniform(0, 1) < self.mutation_prob:\n                    gaussian_individual = self.gaussian_mutation(self.population[i])\n                    gaussian_fitness = func(gaussian_individual)\n                    evaluations += 1\n                    if gaussian_fitness < fitness:\n                        self.population[i] = gaussian_individual\n                        self.gaussian_mutation_stddev *= 1.1\n                    else:\n                        self.gaussian_mutation_stddev *= 0.9\n                    self.gaussian_mutation_stddev = np.clip(self.gaussian_mutation_stddev, 0.01, 1.0)\n                if np.random.uniform(0, 1) < 0.1:\n                    harmony_individual = self.harmony_search(self.population[i])\n                    harmony_fitness = func(harmony_individual)\n                    evaluations += 1\n                    if harmony_fitness < fitness:\n                        self.population[i] = harmony_individual\n                        self.harmony_memory_fitness[np.argmax(self.harmony_memory_fitness)] = harmony_fitness\n                        self.harmony_memory[np.argmax(self.harmony_memory_fitness)] = harmony_individual\n            if evaluations > self.budget / 2 and self.population_size < self.initial_population_size * 2:\n                self.population_size = int(self.population_size * (1 + self.convergence_speed))\n                self.population = np.vstack((self.population, np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(self.population), self.dim))))\n        return self.best_individual", "name": "HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v5", "description": "Hybrid Sine Cosine Algorithm with Levy Flight, Simulated Annealing, Adaptive Chaotic Opposition-Based Learning, Gaussian Mutation, and Dynamic Population Size, incorporating a new weighted opposition-based learning strategy, an adaptive Levy flight scale, and a novel convergence speed-based dynamic population size adjustment, with refined adaptive probabilities, a new adaptive Gaussian mutation, and an additional exploration-exploitation phase using a modified Harmony Search algorithm.", "configspace": "", "generation": 35, "fitness": 0.18766757498488656, "feedback": "The algorithm HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v5 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.20.", "error": "", "parent_id": "99ec624e-20e3-47af-a5db-1974a78b0e55", "metadata": {"aucs": [0.4208097296076293, 0.4627563849308234, 0.46939793867142443, 0.20691065800351294, 0.5236273624904277, 0.33428056030442044, 0.2280052795861367, 0.4696976805218731, 0.5192157443515387, 0.03648012557869984, 0.013082922005697606, 0.002156363120997762, 0.02525940171795915, 9.999999999998899e-05, 0.00510716756487839, 9.999999999998899e-05, 0.019077345947338786, 9.999999999998899e-05, 0.08058231377850933, 0.0671861214076469, 0.06246995448118653, 0.06431805273342306, 0.07536110823771902, 0.11946183133141608, 0.08627785119391718, 0.09953153872340881, 0.08024016108617749, 0.05761550728654108, 0.04833069596005557, 0.057654667658024294, 0.08422848929827798, 0.041951048066963814, 0.05717883252011757, 0.043604775822603026, 0.06530299234237158, 0.10894856896657834, 0.9736141575364875, 0.9552792652670458, 0.9690696188627018, 0.9586658410050329, 0.985463212270542, 0.9769822664430716, 0.9814196644748265, 0.9970454612462023, 0.9610888050633968, 0.2862674261328477, 0.2930173566590091, 0.25662931894009544, 0.24143928178513618, 0.3103705109575472, 0.15248986451827662, 0.1167594554758582, 0.17923348055747024, 0.2741686567237067, 0.21349553638980545, 0.15469137887601137, 0.16467884965104018, 0.15730725382309152, 0.1915393632861342, 0.12996953973908998, 0.13592494501036623, 0.15365558102332544, 0.12110127771473, 0.16472857923455808, 0.17281903056622538, 0.12382400240898805, 0.1379231938357962, 0.14382973727790904, 0.13063793158202375, 0.13070225387023582, 0.12442322700555919, 0.13809389194128985, 0.21457429432891972, 0.17416032043091068, 0.170429927303258, 0.20294793879269013, 0.18408443168243516, 0.1941027860376794, 0.144005889902329, 0.18064932099066022, 0.18283580844809777, 9.999999999998899e-05, 9.999999999998899e-05, 0.007913560635598893, 9.999999999998899e-05, 9.999999999998899e-05, 0.0028736449853320467, 9.999999999998899e-05, 9.999999999998899e-05, 0.050659258466311585, 0.06994376019836868, 0.023823694040944088, 0.09098213597878368, 0.06505217541186992, 0.016704201264560625, 0.016187956054496522, 0.0799356190753393, 0.02588115229425625, 0.04440117218643358, 0.034096004040587324, 0.041166278675005774, 0.099326689837137, 0.1086229173109503, 0.016033142837251213, 0.06107430908822464, 0.07938482089516818, 0.07114595861148432, 0.04190791192953913, 0.09709918098782622, 0.10696968758920589, 0.19497113634214847, 9.999999999998899e-05, 0.13152181789793538, 0.03148338064714262, 0.13846309720422234, 0.08805946192959369, 0.07871513279823716, 0.362621241276611, 0.36822984238608325, 0.31702344442304453, 0.21724878956545968, 0.20880758960265344, 0.1941183418632123, 0.31651559519905437, 0.36957413194385647, 0.23948998190355586, 0.07582827995866281, 0.09342346758965159, 0.0555517620786703, 0.06460059500640769, 0.07234057274623862, 0.05225541656567423, 0.10599317474879677, 0.11043404154528014, 0.058760037412992294, 0.14972698624267922, 0.18022600603214944, 0.13373829602891818, 0.1544506550844793, 0.14145055228341719, 0.13473028294717337, 0.1057442406968726, 0.1599393953553614, 0.1321234862628191, 0.1592993661737142, 0.1743581245377449, 0.20441709093457772, 0.2059182862522806, 0.18403487547711983, 0.21013464409964322, 0.19565381781161417, 0.18444666215346084, 0.17553764724487086, 0.16039558055178427, 0.09250712978689302, 0.1474710395388572, 0.13854302947688024, 0.12584304228954202, 0.17779839041581713, 0.14634701292636998, 0.13135800863617697, 0.12981643355585037, 0.33391347421352247, 0.25864294446381386, 0.27854070879994686, 0.3004432206393578, 0.30318820838988636, 0.2897023282593535, 0.3134575865422813, 0.3091514579083827, 0.31573319931663335, 0.17027266870739255, 0.20289111319020436, 0.1725706909124709, 0.1621885857727695, 0.18036704696242867, 0.17323588796440015, 0.17612944257590135, 0.18575378718185787, 0.17145742810020714, 0.29148844393599094, 0.14946282749050765, 0.34339403355243214, 0.12104323643062054, 0.161728366738781, 0.15661199704116358, 0.15555688384078326, 0.16152362186784053, 0.6629764216746991, 0.2794544994969358, 0.21584585550917845, 0.2133517610011879, 0.14947564406975655, 0.27209291505965216, 0.21202927344355094, 0.11709710224157077, 0.29309064991352207, 0.20158899400816677, 0.19356063099892074, 0.18228990472216433, 0.23921682065480177, 0.17085018233594051, 0.17400060877562862, 0.2173390657473948, 0.18715090076609564, 0.21615125931118506, 0.21502519974317558, 0.06931582342733522, 0.05969903729951531, 0.06464154434235658, 0.08855159071483598, 0.07686888890064625, 0.05567261395806722, 0.07394599988702921, 0.06554896299541302, 0.05444009674020167]}, "mutation_prompt": null}
{"id": "9d6a13ae-063f-4777-8961-f6baef0a3448", "solution": "import numpy as np\n\nclass HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.best_fitness = np.inf\n        self.chaotic_map = np.random.uniform(0, 1, self.dim)\n        self.adaptive_prob = 0.3  # Increased from 0.2\n        self.mutation_prob = 0.2  # Increased from 0.1\n        self.levy_flight_scale = 1.0\n        self.opposition_weight = 0.5\n        self.convergence_speed = 0.0\n        self.gaussian_mutation_stddev = 0.1  # New adaptive Gaussian mutation stddev\n        self.chaotic_map_stddev = 0.1  # New adaptive chaotic map stddev\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def chaotic_opposition_based_learning(self, individual):\n        chaotic_individual = self.lower_bound + (self.upper_bound - self.lower_bound) * self.chaotic_map\n        self.chaotic_map = 4 * self.chaotic_map * (1 - self.chaotic_map) + np.random.normal(0, self.chaotic_map_stddev, self.dim)\n        return chaotic_individual\n\n    def levy_flight(self, individual):\n        levy_flight = np.random.normal(0, self.levy_flight_scale, self.dim) / np.random.normal(0, self.levy_flight_scale, self.dim)\n        levy_flight = individual + levy_flight\n        return levy_flight\n\n    def gaussian_mutation(self, individual):\n        gaussian_mutation = individual + np.random.normal(0, self.gaussian_mutation_stddev, self.dim)\n        return gaussian_mutation\n\n    def weighted_opposition_based_learning(self, individual):\n        opposite_individual = self.opposition_based_learning(individual)\n        weighted_individual = self.opposition_weight * individual + (1 - self.opposition_weight) * opposite_individual\n        return weighted_individual\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_individual = self.population[i]\n                    self.convergence_speed = 1.0 / (1.0 + evaluations / self.budget)\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                r3 = np.random.uniform(0, 1, self.dim)\n                r4 = np.random.uniform(0, 1, self.dim)\n                A = 2 * r1 - 1\n                B = np.abs(r2)\n                C = 2 * r3 - 1\n                D = np.abs(r4)\n                sine = np.abs(self.best_individual - self.population[i]) * np.sin(np.abs(r1) * np.pi)\n                cosine = np.abs(self.best_individual - self.population[i]) * np.cos(np.abs(r1) * np.pi)\n                if np.random.uniform(0, 1) < 0.5:\n                    self.population[i] = self.best_individual - (A * sine + B * cosine) * C * D\n                else:\n                    self.population[i] = self.best_individual + (A * sine + B * cosine) * C * D\n                levy_flight = self.levy_flight(self.population[i])\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                    self.levy_flight_scale *= 1.1 * (1.0 + self.convergence_speed)  # Increase the Levy flight scale if the Levy flight improves the fitness\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                        self.levy_flight_scale *= 0.9 / (1.0 + self.convergence_speed)  # Decrease the Levy flight scale if the Levy flight does not improve the fitness\n                self.levy_flight_scale = np.clip(self.levy_flight_scale, 0.1, 10.0)  # Clip the Levy flight scale to a reasonable range\n                # Apply adaptive chaotic opposition-based learning with a probability that adapts to the convergence speed\n                if np.random.uniform(0, 1) < self.adaptive_prob * (1.0 + self.convergence_speed):\n                    chaotic_individual = self.chaotic_opposition_based_learning(self.population[i])\n                    chaotic_fitness = func(chaotic_individual)\n                    evaluations += 1\n                    if chaotic_fitness < fitness:\n                        self.population[i] = chaotic_individual\n                        self.adaptive_prob *= 1.1  # Increase the probability if the chaotic opposition-based learning improves the fitness\n                        self.chaotic_map_stddev *= 0.9  # Decrease the chaotic map stddev if the chaotic opposition-based learning improves the fitness\n                    else:\n                        self.adaptive_prob *= 0.9  # Decrease the probability if the chaotic opposition-based learning does not improve the fitness\n                        self.chaotic_map_stddev *= 1.1  # Increase the chaotic map stddev if the chaotic opposition-based learning does not improve the fitness\n                    self.adaptive_prob = np.clip(self.adaptive_prob, 0.1, 0.9)  # Clip the probability to a reasonable range\n                    self.chaotic_map_stddev = np.clip(self.chaotic_map_stddev, 0.01, 1.0)  # Clip the chaotic map stddev to a reasonable range\n                # Apply weighted opposition-based learning with a fixed probability\n                if np.random.uniform(0, 1) < 0.1:\n                    weighted_individual = self.weighted_opposition_based_learning(self.population[i])\n                    weighted_fitness = func(weighted_individual)\n                    evaluations += 1\n                    if weighted_fitness < fitness:\n                        self.population[i] = weighted_individual\n                # Apply adaptive Gaussian mutation with a fixed probability\n                if np.random.uniform(0, 1) < self.mutation_prob:\n                    gaussian_individual = self.gaussian_mutation(self.population[i])\n                    gaussian_fitness = func(gaussian_individual)\n                    evaluations += 1\n                    if gaussian_fitness < fitness:\n                        self.population[i] = gaussian_individual\n                        self.gaussian_mutation_stddev *= 1.1  # Increase the Gaussian mutation stddev if the mutation improves the fitness\n                    else:\n                        self.gaussian_mutation_stddev *= 0.9  # Decrease the Gaussian mutation stddev if the mutation does not improve the fitness\n                    self.gaussian_mutation_stddev = np.clip(self.gaussian_mutation_stddev, 0.01, 1.0)  # Clip the Gaussian mutation stddev to a reasonable range\n            # Dynamically adjust the population size based on the convergence speed\n            if evaluations > self.budget / 2 and self.population_size < self.initial_population_size * 2:\n                self.population_size = int(self.population_size * (1 + self.convergence_speed))\n                self.population = np.vstack((self.population, np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(self.population), self.dim))))\n        return self.best_individual", "name": "HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v5", "description": "Hybrid Sine Cosine Algorithm with Levy Flight, Simulated Annealing, Adaptive Chaotic Opposition-Based Learning, Gaussian Mutation, and Dynamic Population Size, incorporating a new weighted opposition-based learning strategy, an adaptive Levy flight scale, and a novel convergence speed-based dynamic population size adjustment, with refined adaptive probabilities and a new adaptive Gaussian mutation, and a novel adaptive chaotic map.", "configspace": "", "generation": 36, "fitness": 0.1870883824724443, "feedback": "The algorithm HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v5 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.20.", "error": "", "parent_id": "99ec624e-20e3-47af-a5db-1974a78b0e55", "metadata": {"aucs": [0.5429330706978865, 0.48109022580244476, 0.2909856039575216, 0.20543787259649837, 0.47936623594428185, 0.16224469312120438, 0.2548034837241241, 0.2417859951767224, 0.3542692816666426, 0.02267943528368066, 0.0, 0.0, 0.0, 0.024513259981252977, 0.0, 0.0, 0.0, 0.0, 0.10987134588701153, 0.10455357640141605, 0.062062236593993125, 0.10029220400737215, 0.11643897722654273, 0.049037225061546286, 0.05573970725230715, 0.08452643617441158, 0.07918181867037233, 0.05396305278968572, 0.03171643640391153, 0.07959073158653629, 0.11109650067979038, 0.06822273765456721, 0.03860264813921643, 0.05666189535602517, 0.08208155711660214, 0.059449117514811634, 0.9506840369164656, 0.976766580176392, 0.9632868958767543, 0.9819767517029604, 0.9735259238644781, 0.9584673270585372, 0.9592465464213621, 0.9906227670481766, 0.9805631697703171, 0.28726212976208754, 0.33657790148069033, 0.11116343181899524, 0.34613954303017336, 0.2615742124432855, 0.2316317232046199, 0.16577900627643072, 0.33014594685303056, 0.15569844116960208, 0.13342825361753707, 0.21444350929784428, 0.2137305882859062, 0.20438133226209876, 0.1982135935482071, 0.11754383602449703, 0.15036124741325696, 0.10953973385406812, 0.16255087257454437, 0.341207948167778, 0.11703193993232253, 0.12260924031855558, 0.1719573717479307, 0.11798762549416641, 0.1291550038108804, 0.1212764874115414, 0.17419765309766388, 0.15421255024924085, 0.20340301693956542, 0.2483304940181833, 0.18710071510000315, 0.19176702039456672, 0.22919238473739356, 0.19252260410631228, 0.144975980463542, 0.215238874570296, 0.15137986094029443, 0.0, 0.0, 0.0, 0.0003248407709847134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.029504757555719685, 0.01809682009398461, 0.07407150498115389, 0.06451751983239229, 0.008201528456027507, 0.03768760732293308, 0.16867215625105458, 0.007897824148692778, 0.05164840661233905, 0.08618744898340569, 0.06966522475762083, 0.07684651005957222, 0.11653246885858137, 0.07900178789336243, 0.10273268320606765, 0.05858162185795446, 0.10895420925102972, 0.1624277433995066, 0.04300718460599706, 0.03316697283153758, 0.05246778776815919, 0.1038873542266987, 0.07800767015062937, 0.038141047189344524, 0.03790906857656007, 0.10853801915211392, 0.186142153201458, 0.14724674394117887, 0.4121546401387153, 0.24524487194853195, 0.3417057822580597, 0.3541627752442498, 0.19822029642613348, 0.3507151203649307, 0.34117753790217, 0.3822288173923566, 0.047611194601308804, 0.05673521182005292, 0.09288704475782228, 0.12969174966915653, 0.049944779097704894, 0.0650779194669987, 0.0719297038129143, 0.056529543898311774, 0.07433975538536652, 0.13948062092481128, 0.12816912391381852, 0.12281306827763472, 0.14888924154745364, 0.10835301518760576, 0.19632498007822974, 0.11707592357498064, 0.16063779319266303, 0.1456212921849046, 0.2253947819093901, 0.20515450847868, 0.1610458474587203, 0.24200049770817766, 0.1877447266445883, 0.1676955621664028, 0.17098090237616326, 0.17347609832573474, 0.17967738707299774, 0.1423970330264518, 0.11642114363935108, 0.15284801804215653, 0.0899065260409998, 0.13890800967333894, 0.311482861522444, 0.1674918125530076, 0.1531481032559845, 0.10514523310927726, 0.3255193226873613, 0.31648202262525293, 0.2599608481467851, 0.311889514882149, 0.3334296301806944, 0.3253465854124101, 0.3099790614052379, 0.30835463392128404, 0.3190801638335573, 0.1802488427124963, 0.17956970324573085, 0.19577490377837725, 0.177129410385081, 0.1844684524942669, 0.1977376891667021, 0.16943647311566734, 0.17858951909961818, 0.1699025669826758, 0.17280398853972057, 0.16555340684802777, 0.14273810531382003, 0.5133892018696535, 0.14277538344711216, 0.10053453583601857, 0.49095083688702335, 0.16056433152445226, 0.13883663143148772, 0.1556323122495794, 0.11396789115067418, 0.34640399960297175, 0.15256375429834557, 0.15261035256912614, 0.17587882219061757, 0.14355214577801745, 0.12275196039001512, 0.30403205057459726, 0.21286157804261474, 0.19692217482537544, 0.18154972500871913, 0.18627028010282554, 0.19358857209621883, 0.19850485627105896, 0.2187673722675728, 0.18819552267226913, 0.18953212806037312, 0.059235449812998886, 0.0830737286727834, 0.0863024597748816, 0.0802106047815403, 0.05275644992013062, 0.09833332246337867, 0.06330827301484965, 0.06795481348878907, 0.054527290467231926]}, "mutation_prompt": null}
{"id": "72f28f0f-c34e-4e5b-af10-c054b517db20", "solution": "import numpy as np\n\nclass HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.best_fitness = np.inf\n        self.chaotic_map = np.random.uniform(0, 1, self.dim)\n        self.adaptive_prob = 0.3  \n        self.mutation_prob = 0.2  \n        self.levy_flight_scale = 1.0\n        self.opposition_weight = 0.5\n        self.convergence_speed = 0.0\n        self.gaussian_mutation_stddev = 0.1  \n        self.levy_flight_distribution = np.random.uniform(0, 1, self.dim)\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def chaotic_opposition_based_learning(self, individual):\n        chaotic_individual = self.lower_bound + (self.upper_bound - self.lower_bound) * self.chaotic_map\n        self.chaotic_map = 4 * self.chaotic_map * (1 - self.chaotic_map)\n        return chaotic_individual\n\n    def levy_flight(self, individual):\n        levy_flight = np.random.normal(0, self.levy_flight_scale, self.dim) / np.random.normal(0, self.levy_flight_scale, self.dim)\n        levy_flight = individual + levy_flight * self.levy_flight_distribution\n        return levy_flight\n\n    def gaussian_mutation(self, individual):\n        gaussian_mutation = individual + np.random.normal(0, self.gaussian_mutation_stddev, self.dim)\n        return gaussian_mutation\n\n    def weighted_opposition_based_learning(self, individual):\n        opposite_individual = self.opposition_based_learning(individual)\n        weighted_individual = self.opposition_weight * individual + (1 - self.opposition_weight) * opposite_individual\n        return weighted_individual\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_individual = self.population[i]\n                    self.convergence_speed = 1.0 / (1.0 + evaluations / self.budget)\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                r3 = np.random.uniform(0, 1, self.dim)\n                r4 = np.random.uniform(0, 1, self.dim)\n                A = 2 * r1 - 1\n                B = np.abs(r2)\n                C = 2 * r3 - 1\n                D = np.abs(r4)\n                sine = np.abs(self.best_individual - self.population[i]) * np.sin(np.abs(r1) * np.pi)\n                cosine = np.abs(self.best_individual - self.population[i]) * np.cos(np.abs(r1) * np.pi)\n                if np.random.uniform(0, 1) < 0.5:\n                    self.population[i] = self.best_individual - (A * sine + B * cosine) * C * D\n                else:\n                    self.population[i] = self.best_individual + (A * sine + B * cosine) * C * D\n                levy_flight = self.levy_flight(self.population[i])\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                    self.levy_flight_scale *= 1.1 * (1.0 + self.convergence_speed)  \n                    self.levy_flight_distribution = np.random.uniform(0, 1, self.dim)\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                        self.levy_flight_scale *= 0.9 / (1.0 + self.convergence_speed)  \n                        self.levy_flight_distribution = np.random.uniform(0, 1, self.dim)\n                self.levy_flight_scale = np.clip(self.levy_flight_scale, 0.1, 10.0)  \n                if np.random.uniform(0, 1) < self.adaptive_prob * (1.0 + self.convergence_speed):\n                    chaotic_individual = self.chaotic_opposition_based_learning(self.population[i])\n                    chaotic_fitness = func(chaotic_individual)\n                    evaluations += 1\n                    if chaotic_fitness < fitness:\n                        self.population[i] = chaotic_individual\n                        self.adaptive_prob *= 1.1  \n                    else:\n                        self.adaptive_prob *= 0.9  \n                    self.adaptive_prob = np.clip(self.adaptive_prob, 0.1, 0.9)  \n                if np.random.uniform(0, 1) < 0.1:\n                    weighted_individual = self.weighted_opposition_based_learning(self.population[i])\n                    weighted_fitness = func(weighted_individual)\n                    evaluations += 1\n                    if weighted_fitness < fitness:\n                        self.population[i] = weighted_individual\n                if np.random.uniform(0, 1) < self.mutation_prob:\n                    gaussian_individual = self.gaussian_mutation(self.population[i])\n                    gaussian_fitness = func(gaussian_individual)\n                    evaluations += 1\n                    if gaussian_fitness < fitness:\n                        self.population[i] = gaussian_individual\n                        self.gaussian_mutation_stddev *= 1.1  \n                    else:\n                        self.gaussian_mutation_stddev *= 0.9  \n                    self.gaussian_mutation_stddev = np.clip(self.gaussian_mutation_stddev, 0.01, 1.0)  \n            if evaluations > self.budget / 2 and self.population_size < self.initial_population_size * 2:\n                self.population_size = int(self.population_size * (1 + self.convergence_speed))\n                self.population = np.vstack((self.population, np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(self.population), self.dim))))\n        return self.best_individual", "name": "HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v5", "description": "Hybrid Sine Cosine Algorithm with Levy Flight, Simulated Annealing, Adaptive Chaotic Opposition-Based Learning, Gaussian Mutation, and Dynamic Population Size, incorporating a new weighted opposition-based learning strategy, an adaptive Levy flight scale, and a novel convergence speed-based dynamic population size adjustment, with refined adaptive probabilities and a new adaptive Gaussian mutation, and introducing a novel adaptive Levy flight distribution and a new adaptive chaotic map.", "configspace": "", "generation": 37, "fitness": 0.18403494973331255, "feedback": "The algorithm HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v5 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "99ec624e-20e3-47af-a5db-1974a78b0e55", "metadata": {"aucs": [0.20459710986735002, 0.21537154669041136, 0.223023727605008, 0.38030832825925576, 0.20350301362584478, 0.22204220183406898, 0.28518911667418767, 0.2047584309329188, 0.5255558122663639, 9.999999999998899e-05, 0.01575791122345649, 9.999999999998899e-05, 0.006942902995524469, 0.06429427246420638, 9.999999999998899e-05, 9.999999999998899e-05, 0.00228990101778459, 9.999999999998899e-05, 0.07539012466480421, 0.06674008542929444, 0.06527302144739933, 0.12042590298811517, 0.08946773047103285, 0.061086070431640827, 0.10236806857647751, 0.11135829916383644, 0.06663073484014725, 0.07619377853401421, 0.06607775631757773, 0.09945618193113337, 0.07360058917170986, 0.060449244145437286, 0.08517585357104185, 0.10602719780383218, 0.07349123569485527, 0.10625831183263579, 0.9637141362339424, 0.9801471775654852, 0.9643466704381813, 0.9515565002503813, 0.4593227498117206, 0.9701840159913863, 0.9796136967498701, 0.9727960537981977, 0.9634509321374741, 0.3755243200219417, 0.32235057912645226, 0.20305113361315252, 0.328177698782397, 0.22999439178304903, 0.4219571211685672, 0.3355627019431695, 0.08812011082859039, 0.2758965321647304, 0.2051659541261991, 0.17736627171611274, 0.1976937360381409, 0.14451582782162353, 0.21977457837729708, 0.18848316093525486, 0.15690164642156357, 0.17110699946328078, 0.24412621801493428, 0.32850045506269, 0.10354890507241876, 0.17889158792451232, 0.08090910131743789, 0.10144753240267024, 0.26073704387338037, 0.4070728734375415, 0.18620786473127504, 0.1288215158499364, 0.17561924575767585, 0.1868478118911442, 0.26848438609675307, 0.2125006079438082, 0.1816867549305995, 0.13284531108654407, 0.15757496866905307, 0.20321626870379084, 0.16955168446584357, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.035902835887155704, 0.003579538788708092, 0.01525784700180488, 0.0009709870076834992, 9.999999999998899e-05, 0.014904841112588496, 0.06202908296088949, 0.06820664348528449, 0.04742862726192543, 0.0808229508202668, 0.004302745479461523, 0.014088423932348104, 0.12720801620527522, 0.055830185951961764, 0.055101522880300235, 0.106591487644078, 0.06768336714945034, 0.04296327866805527, 0.13922749239779664, 0.14672981709537125, 0.09284477510840139, 0.07129428559354312, 0.10336279830500594, 0.06805963722316122, 0.05295569037542591, 0.07727789023271836, 0.020175281065822892, 0.14643727409044316, 0.12973509406953, 0.14550334247838814, 0.16369009825081648, 0.06938968474096907, 0.07773202269333401, 0.25808306753695764, 0.19796206614028933, 0.23932343900171438, 0.20961675874727648, 0.2598711146638186, 0.1930348090277615, 0.35597458898189605, 0.3650636560596898, 0.3455790655007015, 0.10437915933800213, 0.06675483967797335, 0.06139442432015496, 0.048202071551797454, 0.04809482101903084, 0.062258775599399296, 0.06864677368614991, 0.0519527744879037, 0.044843649466611346, 0.13358467560246412, 0.18122614518799562, 0.19875909604739472, 0.21059646014372968, 0.1763456322277197, 0.1462266325514502, 0.1475947334320823, 0.13002571354900938, 0.15028695389604674, 0.17725979577720696, 0.16788927083485228, 0.17217064227968204, 0.20175142808728685, 0.2468293400566881, 0.2038173071276912, 0.1837072269060579, 0.1735365182683858, 0.16683617812244977, 0.1428299762024542, 0.1518325810618122, 0.161363417984554, 0.15989910597289914, 0.1897395672062837, 0.1632557142917065, 0.10894919566706684, 0.17708552171412628, 0.11559995155439706, 0.3095241220884416, 0.30108773523555254, 0.29113231179661037, 0.3124745739185941, 0.29391830385531525, 0.31389393066436766, 0.33472024870337125, 0.33537154263873536, 0.3156282791995627, 0.1733080886222701, 0.19381014179249345, 0.17463424361146151, 0.18869883307260893, 0.1883011311192545, 0.191611932318963, 0.16647643211648155, 0.19975449543945922, 0.1722119189959347, 0.1571682964462543, 0.13344385570946582, 0.17971223029612993, 0.167276432496404, 0.16518120052584961, 0.13177275950372658, 0.1419972725731763, 0.15585684835489988, 0.24844017805199325, 0.16774763852952235, 0.1886190893339742, 0.18657311948350708, 0.15546123078813145, 0.11280935058788111, 0.11083104397619792, 0.11961434765227719, 0.1474612456385732, 0.15174635110001178, 0.21659136271158008, 0.1985014643965315, 0.20072240958790977, 0.2023439811485579, 0.22104713391469, 0.2218096679399263, 0.19882475568865465, 0.22492483077045278, 0.19366114951278557, 0.12379310443232461, 0.09655484456092778, 0.07890822213566573, 0.06418394943527239, 0.07465867409834115, 0.09533214634804354, 0.07218843663289864, 0.05651150594362875, 0.09002924736974383]}, "mutation_prompt": null}
{"id": "d16dd186-6e48-4463-a2e6-4a5d85fd96d4", "solution": "import numpy as np\n\nclass HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.T = 1000\n        self.alpha = 0.99\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.best_fitness = np.inf\n        self.chaotic_map = np.random.uniform(0, 1, self.dim)\n        self.adaptive_prob = 0.3  # Increased from 0.2\n        self.mutation_prob = 0.2  # Increased from 0.1\n        self.levy_flight_scale = 1.0\n        self.opposition_weight = 0.5\n        self.convergence_speed = 0.0\n        self.gaussian_mutation_stddev = 0.1  # New adaptive Gaussian mutation stddev\n        self.diversity = np.std(self.population, axis=0)\n\n    def opposition_based_learning(self, individual):\n        opposite_individual = self.lower_bound + self.upper_bound - individual\n        return opposite_individual\n\n    def chaotic_opposition_based_learning(self, individual):\n        chaotic_individual = self.lower_bound + (self.upper_bound - self.lower_bound) * self.chaotic_map\n        self.chaotic_map = 4 * self.chaotic_map * (1 - self.chaotic_map)\n        return chaotic_individual\n\n    def levy_flight(self, individual):\n        levy_flight = np.random.normal(0, self.levy_flight_scale, self.dim) / np.random.normal(0, self.levy_flight_scale, self.dim)\n        levy_flight = individual + levy_flight\n        return levy_flight\n\n    def gaussian_mutation(self, individual):\n        gaussian_mutation = individual + np.random.normal(0, self.gaussian_mutation_stddev, self.dim)\n        return gaussian_mutation\n\n    def weighted_opposition_based_learning(self, individual):\n        opposite_individual = self.opposition_based_learning(individual)\n        weighted_individual = self.opposition_weight * individual + (1 - self.opposition_weight) * opposite_individual\n        return weighted_individual\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(self.population[i])\n                evaluations += 1\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_individual = self.population[i]\n                    self.convergence_speed = 1.0 / (1.0 + evaluations / self.budget)\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                r3 = np.random.uniform(0, 1, self.dim)\n                r4 = np.random.uniform(0, 1, self.dim)\n                A = 2 * r1 - 1\n                B = np.abs(r2)\n                C = 2 * r3 - 1\n                D = np.abs(r4)\n                sine = np.abs(self.best_individual - self.population[i]) * np.sin(np.abs(r1) * np.pi)\n                cosine = np.abs(self.best_individual - self.population[i]) * np.cos(np.abs(r1) * np.pi)\n                if np.random.uniform(0, 1) < 0.5:\n                    self.population[i] = self.best_individual - (A * sine + B * cosine) * C * D\n                else:\n                    self.population[i] = self.best_individual + (A * sine + B * cosine) * C * D\n                levy_flight = self.levy_flight(self.population[i])\n                levy_fitness = func(levy_flight)\n                evaluations += 1\n                if levy_fitness < fitness:\n                    self.population[i] = levy_flight\n                    self.levy_flight_scale *= 1.1 * (1.0 + self.convergence_speed)  # Increase the Levy flight scale if the Levy flight improves the fitness\n                else:\n                    delta = levy_fitness - fitness\n                    prob = np.exp(-delta / self.T)\n                    self.T *= self.alpha\n                    if np.random.uniform(0, 1) < prob:\n                        self.population[i] = levy_flight\n                        self.levy_flight_scale *= 0.9 / (1.0 + self.convergence_speed)  # Decrease the Levy flight scale if the Levy flight does not improve the fitness\n                self.levy_flight_scale = np.clip(self.levy_flight_scale, 0.1, 10.0)  # Clip the Levy flight scale to a reasonable range\n                # Apply adaptive chaotic opposition-based learning with a probability that adapts to the convergence speed and the population diversity\n                if np.random.uniform(0, 1) < self.adaptive_prob * (1.0 + self.convergence_speed) * (1.0 + np.mean(self.diversity)):\n                    chaotic_individual = self.chaotic_opposition_based_learning(self.population[i])\n                    chaotic_fitness = func(chaotic_individual)\n                    evaluations += 1\n                    if chaotic_fitness < fitness:\n                        self.population[i] = chaotic_individual\n                        self.adaptive_prob *= 1.1  # Increase the probability if the chaotic opposition-based learning improves the fitness\n                    else:\n                        self.adaptive_prob *= 0.9  # Decrease the probability if the chaotic opposition-based learning does not improve the fitness\n                    self.adaptive_prob = np.clip(self.adaptive_prob, 0.1, 0.9)  # Clip the probability to a reasonable range\n                # Apply weighted opposition-based learning with a fixed probability\n                if np.random.uniform(0, 1) < 0.1:\n                    weighted_individual = self.weighted_opposition_based_learning(self.population[i])\n                    weighted_fitness = func(weighted_individual)\n                    evaluations += 1\n                    if weighted_fitness < fitness:\n                        self.population[i] = weighted_individual\n                # Apply adaptive Gaussian mutation with a fixed probability\n                if np.random.uniform(0, 1) < self.mutation_prob:\n                    gaussian_individual = self.gaussian_mutation(self.population[i])\n                    gaussian_fitness = func(gaussian_individual)\n                    evaluations += 1\n                    if gaussian_fitness < fitness:\n                        self.population[i] = gaussian_individual\n                        self.gaussian_mutation_stddev *= 1.1  # Increase the Gaussian mutation stddev if the mutation improves the fitness\n                    else:\n                        self.gaussian_mutation_stddev *= 0.9  # Decrease the Gaussian mutation stddev if the mutation does not improve the fitness\n                    self.gaussian_mutation_stddev = np.clip(self.gaussian_mutation_stddev, 0.01, 1.0)  # Clip the Gaussian mutation stddev to a reasonable range\n                self.diversity = np.std(self.population, axis=0)\n            # Dynamically adjust the population size based on the convergence speed\n            if evaluations > self.budget / 2 and self.population_size < self.initial_population_size * 2:\n                self.population_size = int(self.population_size * (1 + self.convergence_speed))\n                self.population = np.vstack((self.population, np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(self.population), self.dim))))\n        return self.best_individual", "name": "HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v5", "description": "Hybrid Sine Cosine Algorithm with Levy Flight, Simulated Annealing, Adaptive Chaotic Opposition-Based Learning, Gaussian Mutation, and Dynamic Population Size, incorporating a new weighted opposition-based learning strategy, an adaptive Levy flight scale, and a novel convergence speed-based dynamic population size adjustment, with refined adaptive probabilities, a new adaptive Gaussian mutation, and an adaptive opposition-based learning probability that adapts to the convergence speed and the population diversity.", "configspace": "", "generation": 38, "fitness": 0.19116343606920794, "feedback": "The algorithm HybridSCA_SA_ACOBL_GM_DPS_ALF_Refined_v5 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.20.", "error": "", "parent_id": "99ec624e-20e3-47af-a5db-1974a78b0e55", "metadata": {"aucs": [0.5348749883701323, 0.4749775053785247, 0.4871569330129025, 0.5128361504089752, 0.47433155868184984, 0.4486502534068951, 0.40340214722245493, 0.500499955546913, 0.4260675876300932, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.057175054615624, 0.02667777705965113, 9.999999999998899e-05, 9.999999999998899e-05, 0.013878448675927801, 9.999999999998899e-05, 0.12085335511645989, 0.07085147435830463, 0.06564621792417114, 0.07652708469040448, 0.06864054711684164, 0.04278941553606952, 0.07427331129405212, 0.0760113773519081, 0.08327605583896525, 0.07680887853129681, 0.04865041114312041, 0.04891653380679595, 0.07193025864405822, 0.09691348747057238, 0.10716445049569678, 0.07718828537008338, 0.05377864119150455, 0.060238014773092985, 0.9690060007459602, 0.9684174543692428, 0.9669211001411412, 0.9268910229058732, 0.897515118887992, 0.9562980078094907, 0.955219502255326, 0.9553159767220115, 0.9677282115897438, 0.3639708279269045, 0.2203656923338303, 0.30685955481066407, 0.1961254154257659, 0.1056868883921952, 0.26216167110086586, 0.19202157742870885, 0.3132752769584707, 0.22454804402357642, 0.17750023832943118, 0.1575172427044299, 0.16894937863298742, 0.2057555434052717, 0.12942683718306724, 0.19851555540268406, 0.1275407980715052, 0.19264797883546958, 0.17822373081336196, 0.21111879392082944, 0.0977061421533002, 0.12701166782116746, 0.07368673631571088, 0.14288919823960988, 0.14210271476829384, 0.14842476411474892, 0.14824320181153783, 0.1295065484892013, 0.14967604466001716, 0.17389136404742622, 0.16205662662383968, 0.21352390080070371, 0.2134592824168271, 0.20429880688509505, 0.10936668415575168, 0.14870004797413927, 0.2507428111733342, 9.999999999998899e-05, 9.999999999998899e-05, 0.0042656655128821, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06822162567273193, 0.0429785331863799, 0.08355266896499403, 0.062395529717801934, 0.02459597662241264, 0.017718911267555315, 0.03653782084261892, 0.06838132857962897, 0.04416501249054128, 0.054721072131099224, 0.05749212369613321, 0.07317214715412301, 0.05835336888115017, 0.02930433568857238, 0.0739575123739018, 0.13368804464169992, 0.073317694749779, 0.0037812190394456158, 0.07610912037386175, 0.08652475960095274, 0.16461677246853235, 0.10373402947961274, 0.06859069131038775, 0.12499620504423581, 0.10866725304366953, 0.023794377966694813, 0.061295133077281516, 0.17357931890660616, 0.3323966849292179, 0.19789670837541362, 0.37160219329313027, 0.26069515937847076, 0.3472804127157394, 0.357647429208919, 0.2410776113330626, 0.3517108807649326, 0.08890915174331238, 0.08111652415537651, 0.0593018870254336, 0.05425386150111755, 0.08403813904792623, 0.04885341144795652, 0.07609583701136102, 0.08178751749134794, 0.050362422072933954, 0.12882386125242917, 0.18276536304284108, 0.1181334358024857, 0.15269505975140618, 0.1899742814215747, 0.13995650829692619, 0.14396919953545695, 0.1510327592240781, 0.13455597530931118, 0.19968047807031952, 0.19472717191031574, 0.17368874939472356, 0.21021398823400195, 0.2029352045549122, 0.21237984873686178, 0.17799479554511277, 0.1735206395425648, 0.1601285826897645, 0.12104179991139952, 0.11855539032227447, 0.12358621338879816, 0.145899347868246, 0.15665213830999947, 0.13335039782388436, 0.15029332568078158, 0.0999444154146708, 0.15502886757392276, 0.31369567353609695, 0.32733527305074817, 0.26623766363449286, 0.3153338058541121, 0.30131944351949735, 0.2600030766493292, 0.34703306558227853, 0.3248031596386485, 0.25987080161555487, 0.18358264495144017, 0.1731199030760323, 0.17623159810864086, 0.2146210427522811, 0.178560273724515, 0.20570009258068833, 0.19252027842862784, 0.18011320774984252, 0.16341892359689902, 0.15360891103700502, 0.3511403203542097, 0.36897211937556773, 0.1661889604427066, 0.5950446349457555, 0.17749337144132293, 0.1637697221924218, 0.1630822910568529, 0.1227870819177097, 0.3970849248405589, 0.15596679083450837, 0.184861053089172, 0.15093619248272894, 0.18330511720863274, 0.30408778644076717, 0.17018115848240045, 0.32726259199636343, 0.10803745952830746, 0.20246280179981935, 0.2004086113450645, 0.18559207738706784, 0.1822245075473834, 0.19505694121804795, 0.2503558467531377, 0.18210383327318092, 0.18613364557043566, 0.17905697549100552, 0.0782328686590319, 0.09099807726431719, 0.11223406247747647, 0.08534985092793212, 0.08544146089796123, 0.06438584976414585, 0.07584567083858806, 0.06502074471698194, 0.09082992246976662]}, "mutation_prompt": null}
