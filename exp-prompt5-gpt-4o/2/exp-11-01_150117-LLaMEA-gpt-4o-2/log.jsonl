{"id": "4f29c02f-71fb-4fbf-a12f-d32b3c1e0a4c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.1)\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.1, self.F - 0.01)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n# Example on how to use the optimizer:\n# optimizer = AdaptiveDifferentialEvolution(budget=10000, dim=10)\n# result = optimizer(your_black_box_function)", "name": "AdaptiveDifferentialEvolution", "description": "The algorithm integrates Differential Evolution with Adaptive Learning Rates to balance exploration and exploitation dynamically during search.", "configspace": "", "generation": 0, "fitness": 0.21577512086868064, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": null, "metadata": {"aucs": [0.4503775616654391, 0.4451005328054377, 0.45917757142676396, 0.49011154311782856, 0.4704601477982432, 0.5069250822494731, 0.5070002802763862, 0.4473566194699351, 0.46972723134186856, 0.21304263445206983, 0.21494863228000838, 0.21970586231459066, 0.23826010416002297, 0.23256178223873059, 0.22149045144445056, 0.2176384440381336, 0.23949424921669393, 0.23473242041240994, 0.16537265233364962, 0.1485036624258217, 0.15459944333353104, 0.15430869154055982, 0.15264866385741638, 0.1781607194314796, 0.19173072281123582, 0.16953412123934541, 0.1506505937979673, 0.1473698010301574, 0.13538061864807405, 0.13377794952017352, 0.12409307031977335, 0.10804650749477074, 0.12631880602682255, 0.13487811333616462, 0.14390429865845233, 0.13083301749950993, 0.9331434078399466, 0.9542316292528648, 0.9228837698955201, 0.9867349287770258, 0.9457803220359129, 0.966866034011611, 0.9471970141816236, 0.9436573152992598, 0.94503145849129, 0.23186739026982928, 0.2313047672468922, 0.22181681623441096, 0.2501641757454406, 0.2512982058609914, 0.26206595730963267, 0.23192307787499666, 0.24002482903519717, 0.26096227560051743, 0.21501448837637205, 0.23271586016455603, 0.26045917687566067, 0.2826972596281374, 0.2681231019332109, 0.2698842207137533, 0.30335985823575606, 0.25900214511765207, 0.45981236283791527, 0.1511983654707767, 0.12476340383144435, 0.12962356830797472, 0.14905564907741442, 0.16456405858355772, 0.15205756600521259, 0.15580638212710385, 0.1556117186053243, 0.16136549415191426, 0.21138857136753453, 0.11392558650841833, 0.15880838871852432, 0.15187637628849804, 0.11976751939448627, 0.15964024148983758, 0.1437799558735443, 0.15872174084124158, 0.16719125944324298, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0003155156353988886, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.060417656922613916, 0.04807040475816704, 0.0413182283968232, 0.06131407955518242, 0.04714580362636411, 0.07584721480196799, 0.09289890654045974, 0.04808514346829884, 0.04671172542152613, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0008685205051731648, 0.0003052565045814637, 9.999999999998899e-05, 0.005763003202997274, 0.005786785518959392, 0.0917874347624178, 0.1093830286351698, 0.10176090905334967, 0.12174365659785691, 0.10495016748943786, 0.12303607148343854, 0.08866554014863592, 0.09372854411292664, 0.09521866740962048, 0.4054377155694109, 0.42181800897686994, 0.3878720047190254, 0.40404608265204933, 0.40783381114878814, 0.40679677748044285, 0.40800016741730916, 0.4216503107379892, 0.41918065276500704, 0.1129216695076719, 0.10849956174832565, 0.08716574942312949, 0.09818752484736215, 0.09856755723726762, 0.09397027538026703, 0.09626083367861027, 0.088061438359891, 0.09441117668256138, 0.139600373711385, 0.17403466307231463, 0.15170751760768686, 0.17274147034511167, 0.1494405677246936, 0.1695224113885493, 0.14554766959972953, 0.158768636611753, 0.1486618271725798, 0.26525848579879463, 0.26463607872806894, 0.27490966028862995, 0.25193105259746784, 0.2652236350855426, 0.25710424254585784, 0.27111672995188274, 0.2837764811346174, 0.28178045180871536, 0.17297737494689192, 0.18222809449847577, 0.20652698243573742, 0.18549204854804136, 0.16676125815478426, 0.16696358907222253, 0.20748404025207956, 0.22599260483367456, 0.19777242307575227, 0.1954706074980891, 0.19969436227760784, 0.18958143555987284, 0.18518124809593095, 0.16318401560138207, 0.18901217076511212, 0.1989256782624219, 0.18831103805932792, 0.17731275468386043, 0.2236862203346246, 0.23065063048736079, 0.2796108693959475, 0.23788878596883, 0.20414383658415192, 0.2261886890518343, 0.2690027493561752, 0.21488641879016435, 0.24263676772842024, 0.1519854154132978, 0.2487300379316162, 0.18849151423563937, 0.165075339426226, 0.296796521898104, 0.2956848862185537, 0.23231712787529613, 0.16562696886096584, 0.2220989148295549, 0.1967760959547119, 0.18745428274780607, 0.17528396295783388, 0.27322998037438073, 0.17474758436703508, 0.16413380466057192, 0.19337801819447642, 0.3582254751159837, 0.20523474939397846, 0.2023011774277661, 0.19780926435407697, 0.1917397088165287, 0.18074081472802717, 0.17814137736146562, 0.18991758589483776, 0.19385391998182222, 0.2004844953685937, 0.17567090986425482, 0.06986321408504825, 0.08168948465130721, 0.0850527983495476, 0.07260518478300837, 0.08234267674351015, 0.07513178968396661, 0.06920759190516401, 0.06688008842563609, 0.08290081343350952]}, "mutation_prompt": null}
{"id": "b00e0da8-384e-4ad9-92ea-d8ced896ce6f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.1)\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.1, self.F - 0.01)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n# Example on how to use the optimizer:\n# optimizer = AdaptiveDifferentialEvolution(budget=10000, dim=10)\n# result = optimizer(your_black_box_function)", "name": "AdaptiveDifferentialEvolution", "description": "The algorithm integrates Differential Evolution with Adaptive Learning Rates to balance exploration and exploitation dynamically during search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4f29c02f-71fb-4fbf-a12f-d32b3c1e0a4c", "metadata": {"aucs": [0.4503775616654391, 0.4451005328054377, 0.45917757142676396, 0.49011154311782856, 0.4704601477982432, 0.5069250822494731, 0.5070002802763862, 0.4473566194699351, 0.46972723134186856, 0.21304263445206983, 0.21494863228000838, 0.21970586231459066, 0.23826010416002297, 0.23256178223873059, 0.22149045144445056, 0.2176384440381336, 0.23949424921669393, 0.23473242041240994, 0.16537265233364962, 0.1485036624258217, 0.15459944333353104, 0.15430869154055982, 0.15264866385741638, 0.1781607194314796, 0.19173072281123582, 0.16953412123934541, 0.1506505937979673, 0.1473698010301574, 0.13538061864807405, 0.13377794952017352, 0.12409307031977335, 0.10804650749477074, 0.12631880602682255, 0.13487811333616462, 0.14390429865845233, 0.13083301749950993, 0.9331434078399466, 0.9542316292528648, 0.9228837698955201, 0.9867349287770258, 0.9457803220359129, 0.966866034011611, 0.9471970141816236, 0.9436573152992598, 0.94503145849129, 0.23186739026982928, 0.2313047672468922, 0.22181681623441096, 0.2501641757454406, 0.2512982058609914, 0.26206595730963267, 0.23192307787499666, 0.24002482903519717, 0.26096227560051743, 0.21501448837637205, 0.23271586016455603, 0.26045917687566067, 0.2826972596281374, 0.2681231019332109, 0.2698842207137533, 0.30335985823575606, 0.25900214511765207, 0.45981236283791527, 0.1511983654707767, 0.12476340383144435, 0.12962356830797472, 0.14905564907741442, 0.16456405858355772, 0.15205756600521259, 0.15580638212710385, 0.1556117186053243, 0.16136549415191426, 0.21138857136753453, 0.11392558650841833, 0.15880838871852432, 0.15187637628849804, 0.11976751939448627, 0.15964024148983758, 0.1437799558735443, 0.15872174084124158, 0.16719125944324298, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0003155156353988886, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.060417656922613916, 0.04807040475816704, 0.0413182283968232, 0.06131407955518242, 0.04714580362636411, 0.07584721480196799, 0.09289890654045974, 0.04808514346829884, 0.04671172542152613, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0008685205051731648, 0.0003052565045814637, 9.999999999998899e-05, 0.005763003202997274, 0.005786785518959392, 0.0917874347624178, 0.1093830286351698, 0.10176090905334967, 0.12174365659785691, 0.10495016748943786, 0.12303607148343854, 0.08866554014863592, 0.09372854411292664, 0.09521866740962048, 0.4054377155694109, 0.42181800897686994, 0.3878720047190254, 0.40404608265204933, 0.40783381114878814, 0.40679677748044285, 0.40800016741730916, 0.4216503107379892, 0.41918065276500704, 0.1129216695076719, 0.10849956174832565, 0.08716574942312949, 0.09818752484736215, 0.09856755723726762, 0.09397027538026703, 0.09626083367861027, 0.088061438359891, 0.09441117668256138, 0.139600373711385, 0.17403466307231463, 0.15170751760768686, 0.17274147034511167, 0.1494405677246936, 0.1695224113885493, 0.14554766959972953, 0.158768636611753, 0.1486618271725798, 0.26525848579879463, 0.26463607872806894, 0.27490966028862995, 0.25193105259746784, 0.2652236350855426, 0.25710424254585784, 0.27111672995188274, 0.2837764811346174, 0.28178045180871536, 0.17297737494689192, 0.18222809449847577, 0.20652698243573742, 0.18549204854804136, 0.16676125815478426, 0.16696358907222253, 0.20748404025207956, 0.22599260483367456, 0.19777242307575227, 0.1954706074980891, 0.19969436227760784, 0.18958143555987284, 0.18518124809593095, 0.16318401560138207, 0.18901217076511212, 0.1989256782624219, 0.18831103805932792, 0.17731275468386043, 0.2236862203346246, 0.23065063048736079, 0.2796108693959475, 0.23788878596883, 0.20414383658415192, 0.2261886890518343, 0.2690027493561752, 0.21488641879016435, 0.24263676772842024, 0.1519854154132978, 0.2487300379316162, 0.18849151423563937, 0.165075339426226, 0.296796521898104, 0.2956848862185537, 0.23231712787529613, 0.16562696886096584, 0.2220989148295549, 0.1967760959547119, 0.18745428274780607, 0.17528396295783388, 0.27322998037438073, 0.17474758436703508, 0.16413380466057192, 0.19337801819447642, 0.3582254751159837, 0.20523474939397846, 0.2023011774277661, 0.19780926435407697, 0.1917397088165287, 0.18074081472802717, 0.17814137736146562, 0.18991758589483776, 0.19385391998182222, 0.2004844953685937, 0.17567090986425482, 0.06986321408504825, 0.08168948465130721, 0.0850527983495476, 0.07260518478300837, 0.08234267674351015, 0.07513178968396661, 0.06920759190516401, 0.06688008842563609, 0.08290081343350952]}, "mutation_prompt": null}
{"id": "999136c3-1aff-483a-b336-1f5d0ee472d0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.1)\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.1, self.F - 0.01)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n# Example on how to use the optimizer:\n# optimizer = AdaptiveDifferentialEvolution(budget=10000, dim=10)\n# result = optimizer(your_black_box_function)", "name": "AdaptiveDifferentialEvolution", "description": "The algorithm integrates Differential Evolution with Adaptive Learning Rates to balance exploration and exploitation dynamically during search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4f29c02f-71fb-4fbf-a12f-d32b3c1e0a4c", "metadata": {"aucs": [0.4503775616654391, 0.4451005328054377, 0.45917757142676396, 0.49011154311782856, 0.4704601477982432, 0.5069250822494731, 0.5070002802763862, 0.4473566194699351, 0.46972723134186856, 0.21304263445206983, 0.21494863228000838, 0.21970586231459066, 0.23826010416002297, 0.23256178223873059, 0.22149045144445056, 0.2176384440381336, 0.23949424921669393, 0.23473242041240994, 0.16537265233364962, 0.1485036624258217, 0.15459944333353104, 0.15430869154055982, 0.15264866385741638, 0.1781607194314796, 0.19173072281123582, 0.16953412123934541, 0.1506505937979673, 0.1473698010301574, 0.13538061864807405, 0.13377794952017352, 0.12409307031977335, 0.10804650749477074, 0.12631880602682255, 0.13487811333616462, 0.14390429865845233, 0.13083301749950993, 0.9331434078399466, 0.9542316292528648, 0.9228837698955201, 0.9867349287770258, 0.9457803220359129, 0.966866034011611, 0.9471970141816236, 0.9436573152992598, 0.94503145849129, 0.23186739026982928, 0.2313047672468922, 0.22181681623441096, 0.2501641757454406, 0.2512982058609914, 0.26206595730963267, 0.23192307787499666, 0.24002482903519717, 0.26096227560051743, 0.21501448837637205, 0.23271586016455603, 0.26045917687566067, 0.2826972596281374, 0.2681231019332109, 0.2698842207137533, 0.30335985823575606, 0.25900214511765207, 0.45981236283791527, 0.1511983654707767, 0.12476340383144435, 0.12962356830797472, 0.14905564907741442, 0.16456405858355772, 0.15205756600521259, 0.15580638212710385, 0.1556117186053243, 0.16136549415191426, 0.21138857136753453, 0.11392558650841833, 0.15880838871852432, 0.15187637628849804, 0.11976751939448627, 0.15964024148983758, 0.1437799558735443, 0.15872174084124158, 0.16719125944324298, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0003155156353988886, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.060417656922613916, 0.04807040475816704, 0.0413182283968232, 0.06131407955518242, 0.04714580362636411, 0.07584721480196799, 0.09289890654045974, 0.04808514346829884, 0.04671172542152613, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0008685205051731648, 0.0003052565045814637, 9.999999999998899e-05, 0.005763003202997274, 0.005786785518959392, 0.0917874347624178, 0.1093830286351698, 0.10176090905334967, 0.12174365659785691, 0.10495016748943786, 0.12303607148343854, 0.08866554014863592, 0.09372854411292664, 0.09521866740962048, 0.4054377155694109, 0.42181800897686994, 0.3878720047190254, 0.40404608265204933, 0.40783381114878814, 0.40679677748044285, 0.40800016741730916, 0.4216503107379892, 0.41918065276500704, 0.1129216695076719, 0.10849956174832565, 0.08716574942312949, 0.09818752484736215, 0.09856755723726762, 0.09397027538026703, 0.09626083367861027, 0.088061438359891, 0.09441117668256138, 0.139600373711385, 0.17403466307231463, 0.15170751760768686, 0.17274147034511167, 0.1494405677246936, 0.1695224113885493, 0.14554766959972953, 0.158768636611753, 0.1486618271725798, 0.26525848579879463, 0.26463607872806894, 0.27490966028862995, 0.25193105259746784, 0.2652236350855426, 0.25710424254585784, 0.27111672995188274, 0.2837764811346174, 0.28178045180871536, 0.17297737494689192, 0.18222809449847577, 0.20652698243573742, 0.18549204854804136, 0.16676125815478426, 0.16696358907222253, 0.20748404025207956, 0.22599260483367456, 0.19777242307575227, 0.1954706074980891, 0.19969436227760784, 0.18958143555987284, 0.18518124809593095, 0.16318401560138207, 0.18901217076511212, 0.1989256782624219, 0.18831103805932792, 0.17731275468386043, 0.2236862203346246, 0.23065063048736079, 0.2796108693959475, 0.23788878596883, 0.20414383658415192, 0.2261886890518343, 0.2690027493561752, 0.21488641879016435, 0.24263676772842024, 0.1519854154132978, 0.2487300379316162, 0.18849151423563937, 0.165075339426226, 0.296796521898104, 0.2956848862185537, 0.23231712787529613, 0.16562696886096584, 0.2220989148295549, 0.1967760959547119, 0.18745428274780607, 0.17528396295783388, 0.27322998037438073, 0.17474758436703508, 0.16413380466057192, 0.19337801819447642, 0.3582254751159837, 0.20523474939397846, 0.2023011774277661, 0.19780926435407697, 0.1917397088165287, 0.18074081472802717, 0.17814137736146562, 0.18991758589483776, 0.19385391998182222, 0.2004844953685937, 0.17567090986425482, 0.06986321408504825, 0.08168948465130721, 0.0850527983495476, 0.07260518478300837, 0.08234267674351015, 0.07513178968396661, 0.06920759190516401, 0.06688008842563609, 0.08290081343350952]}, "mutation_prompt": null}
{"id": "ca263b9a-f712-4201-bf10-fb001acc0a48", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.1)\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.1, self.F - 0.01)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:  # Change line: Adjust population size conditionally\n                self.population_size = max(4, self.population_size // 2)\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n# Example on how to use the optimizer:\n# optimizer = AdaptiveDifferentialEvolution(budget=10000, dim=10)\n# result = optimizer(your_black_box_function)", "name": "AdaptiveDifferentialEvolution", "description": "Integrate a dynamic population size adjustment based on fitness variance to improve convergence stability.", "configspace": "", "generation": 3, "fitness": 0.21851429416234094, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "4f29c02f-71fb-4fbf-a12f-d32b3c1e0a4c", "metadata": {"aucs": [0.494476734876661, 0.45598798745871205, 0.4753654846307268, 0.5170505257646079, 0.5794245164169018, 0.5974983588666245, 0.5866860873131263, 0.4690967589586339, 0.6082492565556056, 0.22087498647215564, 0.21571983330556155, 0.21560158694332376, 0.24442265831584253, 0.2464955206905053, 0.21350182187419908, 0.21677021326246726, 0.2503717487032211, 0.24371967689745577, 0.16537265233364962, 0.1485036624258217, 0.15459944333353104, 0.15430869154055982, 0.15264866385741638, 0.1781607194314796, 0.19173072281123582, 0.16953412123934541, 0.1506505937979673, 0.1473698010301574, 0.13538061864807405, 0.13377794952017352, 0.12409307031977335, 0.10804650749477074, 0.12631880602682255, 0.13487811333616462, 0.14390429865845233, 0.13083301749950993, 0.9331434078399466, 0.9542316292528648, 0.9228837698955201, 0.9867349287770258, 0.9457803220359129, 0.966866034011611, 0.9471970141816236, 0.9436573152992598, 0.94503145849129, 0.23186739026982928, 0.23131626556870621, 0.2213171833400105, 0.2514562239957445, 0.2518561635126313, 0.2631721405956924, 0.2302279858631675, 0.24050114924120802, 0.26056397754330096, 0.21501448837637205, 0.23271586016455603, 0.26045917687566067, 0.2826972596281374, 0.2681231019332109, 0.2698842207137533, 0.30335985823575606, 0.25900214511765207, 0.45981236283791527, 0.1511983654707767, 0.12476340383144435, 0.12962356830797472, 0.14905564907741442, 0.16456405858355772, 0.15205756600521259, 0.15580638212710385, 0.1556117186053243, 0.16136549415191426, 0.21138857136753453, 0.11392551484885194, 0.15880838871852432, 0.15187637628849804, 0.11976751939448627, 0.15964024148983758, 0.1437799558735443, 0.15872174084124158, 0.16719125944324298, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0003155156353988886, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.060417656922613916, 0.04807040475816704, 0.0413182283968232, 0.06131407955518242, 0.04714580362636411, 0.07584721480196799, 0.09289890654045974, 0.04808514346829884, 0.04671172542152613, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0008685205051731648, 0.0003052565045814637, 9.999999999998899e-05, 0.005763003202997274, 0.005786785518959392, 0.0917874347624178, 0.1093830286351698, 0.10176090905334967, 0.12174365659785691, 0.10495016748943786, 0.12303607148343854, 0.08866554014863592, 0.09372854411292664, 0.09521866740962048, 0.4133809903391903, 0.41417326155610124, 0.4773090770017696, 0.396206401289553, 0.3856938232625021, 0.37921436467274816, 0.39943981282476604, 0.4449140015371319, 0.38827520454118625, 0.1129216695076719, 0.10849956174832565, 0.08716574942312949, 0.09818752484736215, 0.09856755723726762, 0.09397027538026703, 0.09626083367861027, 0.088061438359891, 0.09441117668256138, 0.139600373711385, 0.17403466307231463, 0.15170751760768686, 0.17274147034511167, 0.1494405677246936, 0.1695224113885493, 0.14554766959972953, 0.158768636611753, 0.1486618271725798, 0.26525848579879463, 0.26463607872806894, 0.27488475082677744, 0.25193105259746784, 0.2652236350855426, 0.25710424254585784, 0.2727521379496535, 0.2853984987546575, 0.28729325237075554, 0.17297737494689192, 0.18222809449847577, 0.20652698243573742, 0.18549204854804136, 0.16676125815478426, 0.16696358907222253, 0.20748404025207956, 0.22599260483367456, 0.19777242307575227, 0.1954706074980891, 0.19969436227760784, 0.18958143555987284, 0.18518124809593095, 0.16318401560138207, 0.18901217076511212, 0.1989256782624219, 0.18831103805932792, 0.17731275468386043, 0.2236862203346246, 0.23065063048736079, 0.2796108693959475, 0.2378709328248506, 0.20414383658415192, 0.2261886890518343, 0.2709328670028609, 0.21488641879016435, 0.24263676772842024, 0.15198529184890086, 0.2487300379316162, 0.18845232467892425, 0.165075339426226, 0.296796521898104, 0.2956848862185537, 0.23231712787529613, 0.16562696886096584, 0.2220989148295549, 0.1967897958573036, 0.18745631901392967, 0.17528396295783388, 0.27322998037438073, 0.17474758436703508, 0.16413380466057192, 0.19337813201017273, 0.34921780643323685, 0.20524480617462626, 0.2023011774277661, 0.19780926435407697, 0.1917397088165287, 0.18074081472802717, 0.17814137736146562, 0.18991758589483776, 0.19385391998182222, 0.2004844953685937, 0.17567090986425482, 0.06986321408504825, 0.08168948465130721, 0.0850527983495476, 0.07260518478300837, 0.08234267674351015, 0.07513178968396661, 0.06920759190516401, 0.06688008842563609, 0.08290081343350952]}, "mutation_prompt": null}
{"id": "7f2a1f22-0f44-4f9a-bf0e-f837e6d737ff", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.1)\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.1, self.F - 0.01)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-5:  # Change line: Adjust population size conditionally\n                self.population_size = max(4, self.population_size // 2)\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n# Example on how to use the optimizer:\n# optimizer = AdaptiveDifferentialEvolution(budget=10000, dim=10)\n# result = optimizer(your_black_box_function)", "name": "AdaptiveDifferentialEvolution", "description": "Enhance fitness variance threshold to more effectively trigger population size adjustments.", "configspace": "", "generation": 4, "fitness": 0.2180458301522398, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "ca263b9a-f712-4201-bf10-fb001acc0a48", "metadata": {"aucs": [0.443024481362865, 0.5233583623419562, 0.5109820907821002, 0.5895991386418116, 0.4880137409411761, 0.5097244215012705, 0.5065172907161729, 0.5000766199298242, 0.43523870860655944, 0.21451740948549003, 0.21348383187322872, 0.21906855561600547, 0.23881452522627422, 0.2397563071257589, 0.22149045144445056, 0.22045743595475042, 0.24444000069146277, 0.2368012864433905, 0.16537265233364962, 0.1485036624258217, 0.15459944333353104, 0.15430869154055982, 0.15264866385741638, 0.1781607194314796, 0.19173072281123582, 0.16953412123934541, 0.1506505937979673, 0.1473698010301574, 0.13538061864807405, 0.13377794952017352, 0.12409307031977335, 0.10804650749477074, 0.12631880602682255, 0.13487811333616462, 0.14390429865845233, 0.13083301749950993, 0.9331434078399466, 0.9542316292528648, 0.9228837698955201, 0.9867349287770258, 0.9457803220359129, 0.966866034011611, 0.9471970141816236, 0.9436573152992598, 0.94503145849129, 0.23186739026982928, 0.2313047672468922, 0.22181681623441096, 0.2501641757454406, 0.2512982058609914, 0.26206595730963267, 0.23192307787499666, 0.24002482903519717, 0.26096227560051743, 0.21501448837637205, 0.23271586016455603, 0.26045917687566067, 0.2826972596281374, 0.2681231019332109, 0.2698842207137533, 0.30335985823575606, 0.25900214511765207, 0.45981236283791527, 0.1511983654707767, 0.12476340383144435, 0.12962356830797472, 0.14905564907741442, 0.16456405858355772, 0.15205756600521259, 0.15580638212710385, 0.1556117186053243, 0.16136549415191426, 0.21138857136753453, 0.11392537112020817, 0.15880838871852432, 0.15187637628849804, 0.11976751939448627, 0.15964024148983758, 0.1437799558735443, 0.15872174084124158, 0.16719125944324298, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0003155156353988886, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.060417656922613916, 0.04807040475816704, 0.0413182283968232, 0.06131407955518242, 0.04714580362636411, 0.07584721480196799, 0.09289890654045974, 0.04808514346829884, 0.04671172542152613, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0008685205051731648, 0.0003052565045814637, 9.999999999998899e-05, 0.005763003202997274, 0.005786785518959392, 0.0917874347624178, 0.1093830286351698, 0.10176090905334967, 0.12174365659785691, 0.10495016748943786, 0.12303607148343854, 0.08866554014863592, 0.09372854411292664, 0.09521866740962048, 0.4242216744852355, 0.4462318572194185, 0.42115502739649613, 0.4316396671757279, 0.4241625468382927, 0.44227142879075043, 0.47164134737948504, 0.4298473969406247, 0.4046739938909072, 0.1129216695076719, 0.10849956174832565, 0.08716574942312949, 0.09818752484736215, 0.09856755723726762, 0.09397027538026703, 0.09626083367861027, 0.088061438359891, 0.09441117668256138, 0.139600373711385, 0.17403466307231463, 0.15170751760768686, 0.17274147034511167, 0.1494405677246936, 0.1695224113885493, 0.14554766959972953, 0.158768636611753, 0.1486618271725798, 0.26525848579879463, 0.26463607872806894, 0.27490966028862995, 0.25193105259746784, 0.2652236350855426, 0.25710424254585784, 0.27111672995188274, 0.2837764811346174, 0.28178045180871536, 0.17297737494689192, 0.18222809449847577, 0.20652698243573742, 0.18549204854804136, 0.16676125815478426, 0.16696358907222253, 0.20748404025207956, 0.22599260483367456, 0.19777242307575227, 0.1954706074980891, 0.19969436227760784, 0.18958143555987284, 0.18518124809593095, 0.16318401560138207, 0.18901217076511212, 0.1989256782624219, 0.18831103805932792, 0.17731275468386043, 0.2236862203346246, 0.23065063048736079, 0.2796108693959475, 0.23788878596883, 0.20414383658415192, 0.2261886890518343, 0.2690027493561752, 0.21488641879016435, 0.24263676772842024, 0.15198509336570765, 0.2487300379316162, 0.18849280554665082, 0.165075339426226, 0.296796521898104, 0.2956848862185537, 0.23231712787529613, 0.16562696886096584, 0.2220989148295549, 0.19678197298961897, 0.18745604770963187, 0.17528396295783388, 0.27322998037438073, 0.17474758436703508, 0.16413380466057192, 0.19337807656764783, 0.3582254751159837, 0.20523658377153953, 0.2023011774277661, 0.19780926435407697, 0.1917397088165287, 0.18074081472802717, 0.17814137736146562, 0.18991758589483776, 0.19385391998182222, 0.2004844953685937, 0.17567090986425482, 0.06986321408504825, 0.08168948465130721, 0.0850527983495476, 0.07260518478300837, 0.08234267674351015, 0.07513178968396661, 0.06920759190516401, 0.06688008842563609, 0.08290081343350952]}, "mutation_prompt": null}
{"id": "f3ffa907-60ba-4531-b93d-5106557641c0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.1)\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.01)  # Changed line: Lower bound for F is reduced from 0.1 to 0.05\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:  # Change line: Adjust population size conditionally\n                self.population_size = max(4, self.population_size // 2)\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n# Example on how to use the optimizer:\n# optimizer = AdaptiveDifferentialEvolution(budget=10000, dim=10)\n# result = optimizer(your_black_box_function)", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration by slightly reducing the mutation factor's lower bound, improving search diversity.", "configspace": "", "generation": 5, "fitness": 0.22196870485576192, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "ca263b9a-f712-4201-bf10-fb001acc0a48", "metadata": {"aucs": [0.494476734876661, 0.45598798745871205, 0.4753654846307268, 0.5170505257646079, 0.5794245164169018, 0.5974983588666245, 0.5866860873131263, 0.4690967589586339, 0.6082492565556056, 0.22087498647215564, 0.21571983330556155, 0.21560158694332376, 0.24442265831584253, 0.2464955206905053, 0.21350182187419908, 0.21677021326246726, 0.2503717487032211, 0.24371967689745577, 0.16287602985606242, 0.14913287019384802, 0.15661546346057875, 0.15430869154055982, 0.14795387339956434, 0.1619698041930604, 0.19173072281179682, 0.18098384111305743, 0.1506505937980117, 0.1473698010301574, 0.1369947307428625, 0.13377794952017352, 0.12469622257895696, 0.12018468211406597, 0.12631880602682255, 0.12808998097782642, 0.14562049255992138, 0.1319878487303413, 0.9331434078399466, 0.9542316292528648, 0.9228837698955201, 0.9867349287770258, 0.9457803220359129, 0.966866034011611, 0.9471970141816236, 0.9436573152992598, 0.94503145849129, 0.23186739026982928, 0.23131626556870621, 0.2213171833400105, 0.2514562239957445, 0.2518561635126313, 0.2631721405956924, 0.2302279858631675, 0.24050114924120802, 0.26056397754330096, 0.19857697055045498, 0.21363077251041995, 0.2691668313985687, 0.4617887054983938, 0.27512375037059433, 0.27173581760275145, 0.27200987063251136, 0.29399126585842617, 0.30565274654618, 0.1511983654707767, 0.12482840980848542, 0.12962356830797472, 0.15712438992042066, 0.16555296812463893, 0.15678987574174175, 0.15560551535482214, 0.16349810536670106, 0.16136549415191426, 0.20890459101243342, 0.11392551484885194, 0.16627011209280085, 0.15187637628849804, 0.12996609963023642, 0.15550761320382478, 0.1437799558735443, 0.15897665029000896, 0.16719125944324298, 9.999999999998899e-05, 0.02353785744910397, 0.02419974390143176, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05230459270110499, 0.03168238537048729, 0.04463050651660028, 0.07732794017491218, 0.04949145311234915, 0.06245023226086144, 0.07904601768874253, 0.07522458869939341, 0.06731267274245378, 9.999999999998899e-05, 0.001375657386820217, 9.999999999998899e-05, 0.0009075165463314772, 9.999999999998899e-05, 0.0028890863037042136, 9.999999999998899e-05, 0.0006401744892616801, 0.001230142462926631, 0.09995246800248203, 0.11615693763817947, 0.10356943575709154, 0.10036589935209905, 0.10719852298319843, 0.11663353979100033, 0.09284713769198638, 0.09827889397967371, 0.10834467237065126, 0.4133809903391903, 0.41417326155610124, 0.4773090770017696, 0.396206401289553, 0.3856938232625021, 0.37921436467274816, 0.39943981282476604, 0.4449140015371319, 0.38827520454118625, 0.11321492467151706, 0.10784748524709609, 0.11831668245352267, 0.10106794737834934, 0.10256721771722455, 0.1023216724241216, 0.1020923253405861, 0.09613040070047207, 0.10988295023348926, 0.15699356799972886, 0.1888204080915521, 0.1497580566472385, 0.1484841381884211, 0.16184094384740966, 0.1603243164114112, 0.16391563661590736, 0.15773646510495598, 0.14366493238638323, 0.2661141528824341, 0.26851547278593857, 0.27488475082677744, 0.26222089444085805, 0.26341736251695047, 0.255547034632434, 0.2727521379496535, 0.2853984987546575, 0.28729325237075554, 0.1777782066333572, 0.17403428761512985, 0.19132629494082531, 0.18140584801912996, 0.1744878146857598, 0.18352031601157592, 0.21215345375311312, 0.2299015209263282, 0.20135816325707157, 0.17854678098244026, 0.18136633656329793, 0.1793280865150393, 0.18602891616480277, 0.1741105391781944, 0.2021266749940972, 0.19670092557970498, 0.18393817840802174, 0.17922840681801733, 0.2132087141888821, 0.25851621007338244, 0.24268926797630652, 0.24170154524264575, 0.20696388720757863, 0.24472230791350025, 0.265967782544981, 0.2284005877545403, 0.24403835251004735, 0.15198529184890086, 0.35888873480528805, 0.18845232467892425, 0.16954854119172358, 0.34902081456606426, 0.36966535460489014, 0.22866537045414048, 0.1662524124393664, 0.18364183411410584, 0.1967897958573036, 0.18760834560181272, 0.18919359920547363, 0.3581092475523112, 0.2714273584903396, 0.18077739440260376, 0.19337813201017273, 0.4033149992229357, 0.20524480617462626, 0.2023011774277661, 0.19780926435407697, 0.20387805175395135, 0.18322131700044342, 0.1916506860252173, 0.18632473702580277, 0.19263203361683567, 0.2004844953685937, 0.17882530782242478, 0.07720778732902966, 0.08211379303214894, 0.07845451463847708, 0.07942167520305377, 0.08353513174479854, 0.0758796723130255, 0.07458541694904275, 0.07930590762735212, 0.0796247573475779]}, "mutation_prompt": null}
{"id": "0a088634-3bfc-4f73-a272-5efdffcdf703", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.05)  # Reduced increase rate for CR from 0.1 to 0.05\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.01)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, self.population_size // 2)\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n# Example on how to use the optimizer:\n# optimizer = AdaptiveDifferentialEvolution(budget=10000, dim=10)\n# result = optimizer(your_black_box_function)", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a dynamic adjustment to the crossover probability based on recent successes.", "configspace": "", "generation": 6, "fitness": 0.21445633284257287, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "f3ffa907-60ba-4531-b93d-5106557641c0", "metadata": {"aucs": [0.5789343519458356, 0.594082216230096, 0.5341510039498193, 0.5647639046024957, 0.6407724259149583, 0.5236718327626502, 0.5250500997184588, 0.5133660292222226, 0.5885902275320479, 0.3070492135504679, 0.28269169063907074, 0.27186998727318545, 0.2689398955874611, 0.29149175054234744, 0.23856777025615516, 0.28824454104109376, 0.2722411596232056, 0.3397843191453461, 0.2341774946700511, 0.26118233023602, 0.21172653708460965, 0.23451172349149185, 0.2574980013013253, 0.23506748333566785, 0.2635783789302305, 0.27852574189659185, 0.29222396230612846, 0.1832739389655379, 0.19434317918737787, 0.18300326868281802, 0.19394686674695683, 0.1882387974455686, 0.19812398753356408, 0.22168508238087437, 0.17973048159867044, 0.18230540865547862, 0.9331434078399466, 0.9542316292528648, 0.9189935267248271, 0.9867349287770258, 0.9457803220359129, 0.9216592623937161, 0.9513851736197041, 0.9360412544983515, 0.9464874853117089, 0.1701948202201885, 0.1799885329694132, 0.19754608134205542, 0.1986035647555775, 0.16237872149240506, 0.18487390233521772, 0.17405967574494519, 0.1751302851999268, 0.16980190600431855, 0.18236427077181838, 0.18104705791648934, 0.2160799978877711, 0.2076571093437184, 0.20181312665590134, 0.2391992211923687, 0.2475567366569834, 0.20446327678956644, 0.1980641505702594, 0.14538496559858738, 0.12997118733796797, 0.15455621945690778, 0.13348751857291696, 0.12567647107728097, 0.1336636323891346, 0.12704769949148176, 0.11863808716060142, 0.15248453147069851, 0.09985159499998553, 0.11033783003532793, 0.016431815877837264, 0.10915536258661229, 0.12108212323919632, 0.11923209641809351, 0.08529676461093172, 0.060354802111129535, 0.08637527453218663, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0549958634909381, 0.045280658779907945, 0.0664429156544144, 0.09414256553113487, 0.030611006383491568, 0.09246677380758961, 0.08927897557255471, 0.0385930384333395, 0.056283331252694024, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04585060216345915, 0.06641367346989568, 0.0722616255836056, 0.06966843751496798, 0.08312124882835703, 0.06930065355204573, 0.06718107426306508, 0.07238104213369201, 0.07071734442296818, 0.3834192561589189, 0.3739291484006485, 0.417401973682028, 0.4033978892601884, 0.40663563594174545, 0.38723866669058093, 0.3870789640296244, 0.4236779553727775, 0.4246167083710527, 0.09739483734003518, 0.09614699541060234, 0.09061373966651642, 0.09621744063391235, 0.09605317734002439, 0.09342460670817421, 0.09416973028226316, 0.09257991699990775, 0.08704593651862147, 0.1424655598874206, 0.15397975609424908, 0.1395431363570444, 0.1420168001485972, 0.15132035046169512, 0.16054744188148706, 0.15928080378547127, 0.17083064401326864, 0.13145340362269087, 0.23787792890137482, 0.2454998531974838, 0.2494713325348672, 0.23988808645405857, 0.2365125741475389, 0.22740923427797144, 0.2346995075549324, 0.2703946649057911, 0.2632617496240961, 0.15186886686590206, 0.16483025473646717, 0.16138017175416408, 0.1477499498306568, 0.15403038885508213, 0.14803895975671744, 0.15980518211323802, 0.18299646306888528, 0.14726929753584206, 0.17528581556317235, 0.17911439798017492, 0.17555783340854336, 0.17754831121357273, 0.17793787037126352, 0.1835703037565526, 0.18954973402717068, 0.1630367082918891, 0.18622465064112792, 0.20841270858483996, 0.2434251445036396, 0.21919695027147978, 0.22667776067993195, 0.23067610271635497, 0.22612909447741836, 0.2191280034575801, 0.2662097567258136, 0.2250817112315433, 0.16338188484366, 0.24956858114444025, 0.26413630385960774, 0.22849464875944736, 0.36943436907020766, 0.34754326098576516, 0.15740113068188222, 0.16881124404429193, 0.21695641568453838, 0.18914596412960005, 0.16473462333801414, 0.20458963619587334, 0.205222919465343, 0.16630127191482535, 0.23229419875857538, 0.24017623810092337, 0.23145729971272067, 0.2054696294967292, 0.19680909204358976, 0.17972864751561446, 0.1895592343765342, 0.21061844456095424, 0.18074785796820902, 0.18078285667758154, 0.19381050683060452, 0.18595814613402928, 0.1949895558389646, 0.07669598200999339, 0.07389004875894511, 0.08026344869235946, 0.0747133737913398, 0.07872374027137008, 0.07592327732698068, 0.08387767180209083, 0.06990183936741745, 0.07372343067216625]}, "mutation_prompt": null}
{"id": "741bfa9f-aa37-44db-bb60-96b76f937c21", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.2, self.F + 0.1)  # Changed line: Increase upper bound for F from 1.0 to 1.2\n                    self.CR = min(1.0, self.CR + 0.1)\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.01)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, self.population_size // 2)\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n# Example on how to use the optimizer:\n# optimizer = AdaptiveDifferentialEvolution(budget=10000, dim=10)\n# result = optimizer(your_black_box_function)", "name": "AdaptiveDifferentialEvolution", "description": "Slightly increase the mutation factor's upper bound to enhance exploration capabilities.", "configspace": "", "generation": 7, "fitness": 0.19402530263834536, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.19.", "error": "", "parent_id": "f3ffa907-60ba-4531-b93d-5106557641c0", "metadata": {"aucs": [0.3747799350859701, 0.3656372576122445, 0.3854460895611933, 0.4898119896070223, 0.4831577479405612, 0.4558058238635766, 0.45067697745312285, 0.4429574010116557, 0.4418639611520079, 0.1632277540995496, 0.1193392351515038, 0.16753163794013615, 9.999999999998899e-05, 0.04449473277134197, 0.14982964193959525, 0.1423285949291514, 0.1407192517150323, 0.14349132762745653, 0.12829093330382058, 0.1326266494986199, 0.1467106993357502, 0.15605615222983982, 0.1536803272573175, 0.14937374781906942, 0.13678998427167566, 0.14464023521819203, 0.146005971119616, 0.11688294304314784, 0.12239505769916903, 0.09887939054820671, 0.11681997880450912, 0.13363215884901092, 0.12699652832733777, 0.11187446840184234, 0.11114789486237664, 0.11178243233956076, 0.9724698955649693, 0.9541907930234903, 0.9660287579133161, 0.9863132376180106, 0.9222696793648091, 0.9447476651738145, 0.970378334589356, 0.9650416860201264, 0.9817062251785058, 0.20623089280148588, 0.18576942098650673, 0.18817227664288882, 0.19316472250535777, 0.18989647423896094, 0.18374464673340352, 0.20544566332080494, 0.21338915275901382, 0.19890483677312243, 0.2363964232144734, 0.21830224100256923, 0.2270277283139751, 0.2475669387878725, 0.24191718736957324, 0.24943330421899057, 0.23999529275708031, 0.23094032980506896, 0.27108892755099145, 0.11222633675471994, 0.10851422172014047, 0.11270764619756679, 0.1145489624476772, 0.11021061102489238, 0.11090109249463054, 0.11848224683184139, 0.12758115853084762, 0.11452285463940681, 0.1017965213061196, 0.050699655448339986, 0.020662186327507492, 0.11220033110637873, 0.11377316851586039, 0.11312276793889364, 0.11740174238775236, 0.12797446461331363, 0.10269445360332297, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0528749416753721, 0.06175035455848299, 0.056821931871324116, 0.05382884880541805, 0.03586812848171461, 0.04864012354363345, 0.03553756499947103, 0.03771049338164523, 0.03964456730830168, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003937503567519207, 0.004014009736085455, 9.999999999998899e-05, 0.0803351110485302, 0.07942465325137604, 0.08286800807513683, 0.07155802706197667, 0.09452967647133703, 0.08786388603505457, 0.08164996166843574, 0.08151354798610733, 0.09125228952248599, 0.33631697799931404, 0.36617545449701816, 0.3417800816325859, 0.3548019673682494, 0.3459123629794716, 0.34449368649971135, 0.3576088442527371, 0.3198114593734528, 0.356782801997948, 0.10086425696000112, 0.08747033325647302, 0.10098059413103566, 0.09795816196104168, 0.08731655833403673, 0.0891611578018685, 0.08663624523323965, 0.08662752482258074, 0.10435281584781975, 0.15081631904158332, 0.1463559963844535, 0.15222866047100392, 0.1511067378881935, 0.17276264837331146, 0.15115626706638918, 0.14778607292929768, 0.16116063183070528, 0.15831732804307452, 0.24338104479342748, 0.23739593823577354, 0.24419170279804114, 0.2523272103259384, 0.2441444359559839, 0.23150082329517851, 0.24376811242587149, 0.25315545029083364, 0.24509843849937785, 0.18920714890893942, 0.17000816322854317, 0.1901372405436117, 0.17391086371454623, 0.15486014918949564, 0.17495875447013476, 0.20045874997430868, 0.19918236824396085, 0.1946587184434717, 0.1946892497199486, 0.18806357586417932, 0.17561917345489497, 0.1918072012909392, 0.1859123431444567, 0.1812470502463055, 0.17962195640778622, 0.19188056567236011, 0.18420261830179663, 0.1834921094347174, 0.24852908788366435, 0.2233827195201883, 0.20264954177533123, 0.20538174109538854, 0.21977237936409588, 0.21211255791566597, 0.21912205305754573, 0.2264590753953305, 0.16517653068584093, 0.1683066399955353, 0.17337618786325382, 0.456218874414287, 0.28027705842974726, 0.2136071143828523, 0.1814220752942154, 0.1847505851040704, 0.19825227478078955, 0.22200543564108544, 0.18325583768357379, 0.19372164167724937, 0.17834428553081105, 0.20489584459260868, 0.1696097187786414, 0.19290885020771753, 0.20452842788231373, 0.20379593148947028, 0.1944651094746752, 0.18369266030433595, 0.18381566034933106, 0.18263052305024408, 0.17994507605446253, 0.199180145645519, 0.18297264802848046, 0.18538429607537044, 0.17957949168054255, 0.07626103053721633, 0.0757214429720896, 0.07488612375356385, 0.07877664133609019, 0.07199363037727669, 0.07723746430717815, 0.07766857890514822, 0.07156614420616658, 0.07664143097487208]}, "mutation_prompt": null}
{"id": "ec7a4dbc-860a-4cb8-9451-3ce49b56a2a6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.15)  # Changed line: Increased CR adaptation step from 0.1 to 0.15\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.01)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, self.population_size // 2)\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n# Example on how to use the optimizer:\n# optimizer = AdaptiveDifferentialEvolution(budget=10000, dim=10)\n# result = optimizer(your_black_box_function)", "name": "AdaptiveDifferentialEvolution", "description": "Slightly increase the crossover probability adaptation to enhance combinatorial exploration.", "configspace": "", "generation": 8, "fitness": 0.24541241355790314, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.20.", "error": "", "parent_id": "f3ffa907-60ba-4531-b93d-5106557641c0", "metadata": {"aucs": [0.5610585962569885, 0.4858182921006119, 0.5889446802598571, 0.5441104990856367, 0.502551331659151, 0.4324839608740254, 0.5241684055283823, 0.618859322701673, 0.4861190251635996, 0.20790360381351936, 0.25433208677885155, 0.21958704164316345, 0.24285766917410323, 0.228159571994216, 0.22992592502505016, 0.233175876162804, 0.21994891678000106, 0.2643129059786241, 0.1254065239188218, 0.21753100697988625, 0.16336100055776204, 0.14136988142507967, 0.17383515538177907, 0.16340484980390424, 0.18741174744241484, 0.2151917612149682, 0.21183794540559697, 0.12134119743953597, 0.10968244557627427, 0.11653933346042744, 0.1154919870850154, 0.10872647499465637, 0.14795958165296996, 0.11309878230785653, 0.11420180764615961, 0.10574520606227034, 0.9331434078399466, 0.9542316292528648, 0.9228837698955201, 0.9867349287770258, 0.9457803220359129, 0.966866034011611, 0.9471970141816236, 0.9436573152992598, 0.94503145849129, 0.22097372506793356, 0.23283918590182717, 0.2518244144437104, 0.2539687259901039, 0.2587513758591523, 0.25469681145470946, 0.23057802401946448, 0.24787172954063785, 0.2692703868885101, 0.4512338970877535, 0.5140105129095992, 0.45765344991305756, 0.3070649767657354, 0.5183063691305787, 0.5290436147240885, 0.4972553024590627, 0.45065990949394474, 0.32275901722454414, 0.17251354156510557, 0.1593784741383344, 0.17310794302877075, 0.17053297704065917, 0.17510301466673994, 0.16674598240394556, 0.15417378052922226, 0.14928663331566827, 0.17294450350776147, 0.2501133498433453, 0.009798740277100482, 0.21623118953204323, 0.1497036864245811, 0.15542085259951222, 0.19532955775318483, 0.16538645168510957, 0.14776987545978937, 0.18196010291830655, 9.999999999998899e-05, 0.008285915294430346, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031420885582189584, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09252534249717304, 0.07491064369936173, 0.0699733338042855, 0.10649991443093498, 0.0611484327816062, 0.06366318250022018, 0.0843588293715618, 0.12282754874952384, 0.10953403150382546, 0.01792142004351771, 0.0033573823431848338, 0.019802140574065374, 9.999999999998899e-05, 0.009406202090323279, 0.007897276767476091, 0.029493885715400014, 0.015363828394538759, 0.01001131741955874, 0.12617154130571073, 0.11748274592611907, 0.11336388247936213, 0.11766295564971552, 0.13205605360567263, 0.13743155617256309, 0.14623828662041505, 0.1287774332101128, 0.1203374025301529, 0.3640635115273071, 0.47595714057778526, 0.4097759752399919, 0.41231683886612225, 0.4084428824518195, 0.3992585826780143, 0.3905655726081658, 0.3949030687573961, 0.4529391360485956, 0.22679857112980883, 0.1310530251638431, 0.1396727657880661, 0.11154736879842875, 0.13360613756866768, 0.09966595118747335, 0.09850165189971072, 0.10273747356352136, 0.12578509832147844, 0.1942613288894186, 0.143067467523169, 0.15315281885580256, 0.2208464518143397, 0.19496014887739677, 0.1698822286828785, 0.15986944718972917, 0.22609589921917128, 0.16010996075783135, 0.2759563763372569, 0.26264321143500946, 0.27383495637926614, 0.2497607050211511, 0.26225431398171795, 0.27592559473924416, 0.28579924765578, 0.269894037976248, 0.2595896733736244, 0.2160281945632061, 0.20616206019922856, 0.2238693404892126, 0.2176295610253577, 0.22567838598793555, 0.21800346190575204, 0.22689633043149338, 0.24358191103480686, 0.21899748096522897, 0.17497196553118666, 0.20091820735101062, 0.17561674660142546, 0.19390037559183537, 0.17926389129350406, 0.2025306051391209, 0.1886173723607074, 0.2098001580092338, 0.2433864865925911, 0.23784757297791403, 0.19831250086711516, 0.3051462197081867, 0.2616672235409171, 0.26281377786885274, 0.24805148098243557, 0.2945618339579775, 0.24404974502714571, 0.20171260287786208, 0.16793868770558906, 0.6136876870795146, 0.6982921324628336, 0.1735804814794648, 0.5586781171959248, 0.17082703871885374, 0.1743029712423353, 0.5105901642585104, 0.17382421264707482, 0.4868541755624365, 0.4605584189780486, 0.43640370841906795, 0.19636115651716557, 0.46637162345587724, 0.43711911258647485, 0.19337732659629125, 0.1487915932330257, 0.20424220291332484, 0.17629211460798055, 0.19780926435407697, 0.180988670454431, 0.19406668009321515, 0.18424509336187866, 0.18502808534105575, 0.22186308259351917, 0.20771502855086732, 0.19297000177025447, 0.07428426165607194, 0.07274235257931927, 0.08212638041315601, 0.08124327310218504, 0.09583524024338252, 0.07990164078748496, 0.08954775849318886, 0.08468368015626582, 0.0765687361095343]}, "mutation_prompt": null}
{"id": "2dacc241-02e4-4cb5-93ae-5a847fce5676", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.6  # Changed line: Increased initial mutation factor from 0.5 to 0.6\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.15)  # Changed line: Increased CR adaptation step from 0.1 to 0.15\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.01)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, self.population_size // 2)\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n# Example on how to use the optimizer:\n# optimizer = AdaptiveDifferentialEvolution(budget=10000, dim=10)\n# result = optimizer(your_black_box_function)", "name": "AdaptiveDifferentialEvolution", "description": "Increase the initial mutation factor (F) to enhance exploration in early stages of optimization.", "configspace": "", "generation": 9, "fitness": 0.24858255425868273, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "ec7a4dbc-860a-4cb8-9451-3ce49b56a2a6", "metadata": {"aucs": [0.4150036017264186, 0.440246264802285, 0.5561769133530532, 0.5721779832434348, 0.5511297317484913, 0.6088334070697204, 0.48475194043126235, 0.5137607570302338, 0.6295199403058096, 0.2606097834323957, 0.24693065713051265, 0.26801496997532126, 0.27573106200293573, 0.229037402101251, 0.2354364256122532, 0.25216603134570936, 0.2800691513352084, 0.2262268834723672, 0.13299633468190897, 0.2148462796808117, 0.20263747741177407, 0.211703721434653, 0.1737915611614157, 0.15695114693790024, 0.1301829198597907, 0.1339423031755972, 0.13669280352523072, 0.12106908902283064, 0.10091818740436642, 0.10709493640979106, 0.12941577272518845, 0.11402957730636176, 0.12315100928397771, 0.1472171763880339, 0.13570321514541483, 0.13881877657008013, 0.9742454882079842, 0.9616312242708378, 0.9108968039884695, 0.9867688444852779, 0.92665680793019, 0.9467985644381831, 0.9675205238037026, 0.9638340792903607, 0.9528984114295745, 0.25910316611835116, 0.2338370297290534, 0.259853715789954, 0.24726165838112957, 0.24652155129979414, 0.2414106326645531, 0.24093430131235782, 0.25174680252169734, 0.25201087157822566, 0.5195801179289465, 0.5152547270527751, 0.44910999343667046, 0.32458148486918836, 0.31320989994560555, 0.5496469366965926, 0.4825748242663339, 0.4955316658490808, 0.4838470476382527, 0.16609399071068565, 0.15587565726696206, 0.1599100918617853, 0.15597981246844062, 0.15717592434596395, 0.1735267871363887, 0.16125142161072492, 0.17021768888697353, 0.14402018889364177, 0.32480455786527695, 0.2380097922803197, 0.2182008055226342, 0.13665265653255831, 0.14865300518900948, 0.14494806116801284, 0.16151620339134387, 0.1284205806782327, 0.14748690819081822, 9.999999999998899e-05, 0.007486151547282827, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01731842070890366, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06769134304181368, 0.05558620133933578, 0.047030724468534624, 0.04886455515838517, 0.09475977575100536, 0.05783217209335567, 0.09548035294236212, 0.09705274227317662, 0.08826500660504932, 0.018060223241445406, 0.05082408315831999, 0.0066335022114025755, 9.999999999998899e-05, 0.0002175062994580479, 9.999999999998899e-05, 0.026737203327242387, 0.021395108306198174, 0.01891012951568427, 0.11821206714486632, 0.1247767800886368, 0.13271217213069053, 0.12610402423479095, 0.13191393060521628, 0.1241309477496999, 0.12682498000297038, 0.13139837179686342, 0.11254549327107799, 0.40403256150430944, 0.40832557061702845, 0.4122716461542205, 0.4547583190864388, 0.3950252523319998, 0.3867506257737938, 0.395012727160306, 0.3976842744864535, 0.4229665131349759, 0.10200905408953276, 0.11424664751256242, 0.1499337454403712, 0.11388096054081287, 0.10902741057068266, 0.09500929988570939, 0.13495246084370205, 0.11143260254653886, 0.11676038558888435, 0.15270145420204462, 0.14791578792133664, 0.16493027420588224, 0.17961538144346179, 0.17094470649185245, 0.1974888447006249, 0.15393805851739106, 0.1586769782584142, 0.17678960899230312, 0.28231238869942077, 0.27289684708195994, 0.25960128726790244, 0.26654059916107564, 0.25203508918845197, 0.267544796588692, 0.2837893864100083, 0.2797094641441529, 0.2767452143088579, 0.21177844422586656, 0.2147694562279776, 0.21409085975169306, 0.22271883343740884, 0.21420325269462726, 0.20823608525159587, 0.2189511836607878, 0.23377650259124183, 0.2248823308338116, 0.18590384138735094, 0.19844295068612183, 0.1857604165240706, 0.17119377282864967, 0.21215790139127444, 0.18534888506771152, 0.20244155470017855, 0.19006088739518534, 0.177076162815046, 0.26462632788996276, 0.3038250153114914, 0.2022025347063966, 0.27327450440804524, 0.2929996594998079, 0.3130845741883197, 0.2587551633149723, 0.2023818836066582, 0.20684632382202728, 0.16705790596114944, 0.5754886784617923, 0.17232411210898413, 0.19219558887668564, 0.6265090671800764, 0.18140456527008586, 0.5029026447437297, 0.6115652919998619, 0.6038205308314948, 0.5250618896222441, 0.4647998008189378, 0.43904267834058075, 0.3534028886632934, 0.47404898821386443, 0.4079007978257593, 0.20577925274729736, 0.20728970666076374, 0.20751612608600323, 0.19085685422077014, 0.18020077357610642, 0.2048201421853758, 0.19361990086929615, 0.19251572747529888, 0.1899787751793265, 0.1847111102987785, 0.21084223704343863, 0.17521497279232012, 0.09284093959283013, 0.0791390543777929, 0.08075003860427676, 0.08017193474106865, 0.08189019904754968, 0.08281426728892716, 0.0706326507652153, 0.08671047280912902, 0.08330514934445221]}, "mutation_prompt": null}
{"id": "f6d001f4-3315-42c1-b5d3-fff63075d013", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.6  # Changed line: Increased initial mutation factor from 0.5 to 0.6\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.15)  # Changed line: Increased CR adaptation step from 0.1 to 0.15\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.01)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, self.population_size // 2)\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n# Example on how to use the optimizer:\n# optimizer = AdaptiveDifferentialEvolution(budget=10000, dim=10)\n# result = optimizer(your_black_box_function)", "name": "AdaptiveDifferentialEvolution", "description": "Increase the initial mutation factor (F) to enhance exploration in early stages of optimization.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2dacc241-02e4-4cb5-93ae-5a847fce5676", "metadata": {"aucs": [0.4150036017264186, 0.440246264802285, 0.5561769133530532, 0.5721779832434348, 0.5511297317484913, 0.6088334070697204, 0.48475194043126235, 0.5137607570302338, 0.6295199403058096, 0.2606097834323957, 0.24693065713051265, 0.26801496997532126, 0.27573106200293573, 0.229037402101251, 0.2354364256122532, 0.25216603134570936, 0.2800691513352084, 0.2262268834723672, 0.13299633468190897, 0.2148462796808117, 0.20263747741177407, 0.211703721434653, 0.1737915611614157, 0.15695114693790024, 0.1301829198597907, 0.1339423031755972, 0.13669280352523072, 0.12106908902283064, 0.10091818740436642, 0.10709493640979106, 0.12941577272518845, 0.11402957730636176, 0.12315100928397771, 0.1472171763880339, 0.13570321514541483, 0.13881877657008013, 0.9742454882079842, 0.9616312242708378, 0.9108968039884695, 0.9867688444852779, 0.92665680793019, 0.9467985644381831, 0.9675205238037026, 0.9638340792903607, 0.9528984114295745, 0.25910316611835116, 0.2338370297290534, 0.259853715789954, 0.24726165838112957, 0.24652155129979414, 0.2414106326645531, 0.24093430131235782, 0.25174680252169734, 0.25201087157822566, 0.5195801179289465, 0.5152547270527751, 0.44910999343667046, 0.32458148486918836, 0.31320989994560555, 0.5496469366965926, 0.4825748242663339, 0.4955316658490808, 0.4838470476382527, 0.16609399071068565, 0.15587565726696206, 0.1599100918617853, 0.15597981246844062, 0.15717592434596395, 0.1735267871363887, 0.16125142161072492, 0.17021768888697353, 0.14402018889364177, 0.32480455786527695, 0.2380097922803197, 0.2182008055226342, 0.13665265653255831, 0.14865300518900948, 0.14494806116801284, 0.16151620339134387, 0.1284205806782327, 0.14748690819081822, 9.999999999998899e-05, 0.007486151547282827, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01731842070890366, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06769134304181368, 0.05558620133933578, 0.047030724468534624, 0.04886455515838517, 0.09475977575100536, 0.05783217209335567, 0.09548035294236212, 0.09705274227317662, 0.08826500660504932, 0.018060223241445406, 0.05082408315831999, 0.0066335022114025755, 9.999999999998899e-05, 0.0002175062994580479, 9.999999999998899e-05, 0.026737203327242387, 0.021395108306198174, 0.01891012951568427, 0.11821206714486632, 0.1247767800886368, 0.13271217213069053, 0.12610402423479095, 0.13191393060521628, 0.1241309477496999, 0.12682498000297038, 0.13139837179686342, 0.11254549327107799, 0.40403256150430944, 0.40832557061702845, 0.4122716461542205, 0.4547583190864388, 0.3950252523319998, 0.3867506257737938, 0.395012727160306, 0.3976842744864535, 0.4229665131349759, 0.10200905408953276, 0.11424664751256242, 0.1499337454403712, 0.11388096054081287, 0.10902741057068266, 0.09500929988570939, 0.13495246084370205, 0.11143260254653886, 0.11676038558888435, 0.15270145420204462, 0.14791578792133664, 0.16493027420588224, 0.17961538144346179, 0.17094470649185245, 0.1974888447006249, 0.15393805851739106, 0.1586769782584142, 0.17678960899230312, 0.28231238869942077, 0.27289684708195994, 0.25960128726790244, 0.26654059916107564, 0.25203508918845197, 0.267544796588692, 0.2837893864100083, 0.2797094641441529, 0.2767452143088579, 0.21177844422586656, 0.2147694562279776, 0.21409085975169306, 0.22271883343740884, 0.21420325269462726, 0.20823608525159587, 0.2189511836607878, 0.23377650259124183, 0.2248823308338116, 0.18590384138735094, 0.19844295068612183, 0.1857604165240706, 0.17119377282864967, 0.21215790139127444, 0.18534888506771152, 0.20244155470017855, 0.19006088739518534, 0.177076162815046, 0.26462632788996276, 0.3038250153114914, 0.2022025347063966, 0.27327450440804524, 0.2929996594998079, 0.3130845741883197, 0.2587551633149723, 0.2023818836066582, 0.20684632382202728, 0.16705790596114944, 0.5754886784617923, 0.17232411210898413, 0.19219558887668564, 0.6265090671800764, 0.18140456527008586, 0.5029026447437297, 0.6115652919998619, 0.6038205308314948, 0.5250618896222441, 0.4647998008189378, 0.43904267834058075, 0.3534028886632934, 0.47404898821386443, 0.4079007978257593, 0.20577925274729736, 0.20728970666076374, 0.20751612608600323, 0.19085685422077014, 0.18020077357610642, 0.2048201421853758, 0.19361990086929615, 0.19251572747529888, 0.1899787751793265, 0.1847111102987785, 0.21084223704343863, 0.17521497279232012, 0.09284093959283013, 0.0791390543777929, 0.08075003860427676, 0.08017193474106865, 0.08189019904754968, 0.08281426728892716, 0.0706326507652153, 0.08671047280912902, 0.08330514934445221]}, "mutation_prompt": null}
{"id": "39b2e59b-40ba-4e82-af8f-e67fb28ccb81", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.6  # Changed line: Increased initial mutation factor from 0.5 to 0.6\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = max(0.1, self.CR + 0.2)  # Changed line: Increased CR adaptation step from 0.15 to 0.2\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.01)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, self.population_size // 2)\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Increase crossover probability adaptation step for faster convergence.", "configspace": "", "generation": 11, "fitness": 0.2541380562936596, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.19.", "error": "", "parent_id": "2dacc241-02e4-4cb5-93ae-5a847fce5676", "metadata": {"aucs": [0.3489184105103065, 0.36870082086362366, 0.3778195317628439, 0.4020363289317822, 0.40408821533556205, 0.3862639462969101, 0.43255344831983056, 0.42741986611479765, 0.3537063268964825, 0.22416785632310643, 0.235682150254646, 0.23597761626383995, 0.21304620194938595, 0.208816880697838, 0.21942778375631444, 0.2334701176395868, 0.21741022877118776, 0.23464675045766037, 0.12831244471217085, 0.18432478328097868, 0.1394520363277908, 0.15097182613693316, 0.13515827852820772, 0.12902331189615124, 0.13194589408863178, 0.1356203578916435, 0.1184542072012944, 0.09527956652978209, 0.12032916814629768, 0.10446927305305365, 0.1028542210427571, 0.10001888907963985, 0.09371717147750336, 0.09837883466976105, 0.09640412006725452, 0.09281700395995962, 0.9440383829604595, 0.9616312242708378, 0.9356033580090445, 0.9875104415341811, 0.9466184431231511, 0.9657775188319202, 0.9407639005326487, 0.9655707295579696, 0.9403458254214, 0.22578065630695487, 0.26368319579482624, 0.25074596472981303, 0.2512727630222973, 0.23077156900643003, 0.2572315460138296, 0.2457123375990976, 0.2492166417781193, 0.27886451897022946, 0.54976838607196, 0.5517387494930397, 0.5295810003117687, 0.5687821678675855, 0.5521244920033588, 0.5460976097364374, 0.49465045176573286, 0.6058912186428766, 0.5993311139648643, 0.17068626678605248, 0.16616248803730382, 0.16947347697237036, 0.15716499272209694, 0.1257504412480961, 0.18026409575775237, 0.16197857432661045, 0.17262154400860596, 0.19775579907910334, 0.05386973441678222, 0.0160983562484871, 0.05484242936828343, 0.19278146089643644, 0.177493450035893, 0.14711295237052346, 0.17605281587335853, 0.1549456393316776, 0.13410788794785344, 0.15929899995709507, 0.17834450734989893, 0.1726499318914384, 0.16126476905747344, 0.19247255322939916, 0.16926805701566283, 0.16393230161990546, 0.21468877156236876, 0.1800362541706605, 0.2850792013354193, 0.2924898766733438, 0.33498760488742063, 0.27001584263439404, 0.28672723999782646, 0.277673376188316, 0.30621908148773347, 0.3106037824420289, 0.29898733256240506, 0.03411498708612559, 0.05525670867576504, 0.07208178840272106, 0.0567542179409527, 0.059247413964711226, 0.04912121777478884, 0.05960199896259877, 0.061184088658640445, 0.05730950470628182, 0.1311644152428555, 0.13134217452037067, 0.14904108215110567, 0.13140582469838136, 0.15458936551447677, 0.1500201938450093, 0.14435251303552066, 0.17167281723525718, 0.1561593411626081, 0.35691294208803803, 0.38134041221752, 0.36168461597199997, 0.37423134912311096, 0.4683768331130491, 0.38653514526791355, 0.3784651609269417, 0.377981906987665, 0.3468682656462724, 0.12924161491908037, 0.10921051690483585, 0.1286364170149611, 0.12114470481323003, 0.12284308296218893, 0.12419945400681898, 0.13570542063886992, 0.11996497283006069, 0.12462832478040564, 0.1511931064562272, 0.17797831277080345, 0.14033281050539315, 0.2759220021856814, 0.22024246830174243, 0.30414624004431945, 0.24457133443057488, 0.14717999508263635, 0.23075346178224165, 0.2652724814170063, 0.25845120625681073, 0.26253680607851126, 0.26070998356837327, 0.2690204875907445, 0.2675916238950723, 0.2675164860296392, 0.27607660961849556, 0.28089942758742226, 0.2192757708461871, 0.20420295788936715, 0.2062430008829329, 0.21683060803439025, 0.2243150255433346, 0.21002553168406446, 0.20391433923457636, 0.24160253529808007, 0.22434903824466768, 0.19760586062096563, 0.24071393439598865, 0.2037376935425781, 0.24657039571917294, 0.24767864144727159, 0.35002733766920235, 0.22902408581561828, 0.22420321626260864, 0.2034811313557714, 0.27505308023050057, 0.2503316809752796, 0.2042584183563546, 0.2537751401938987, 0.21981021108798826, 0.2200426496399699, 0.28091410312706555, 0.19110883420696023, 0.1862799717027004, 0.1508605147711447, 0.18942696524265235, 0.1942625569913865, 0.17672892464131906, 0.18461881737057306, 0.17185185891740473, 0.4326773168520903, 0.45722012850323956, 0.17741373120673654, 0.4049402115844226, 0.20024576995845034, 0.16365111866693638, 0.46952368281783763, 0.399270904307233, 0.37527089108230516, 0.20248223564421264, 0.5534999279159016, 0.19805485868673545, 0.1892335972144612, 0.1789104723405378, 0.20955869704236507, 0.17638246172394978, 0.20562763486099234, 0.18809241332606275, 0.19234401616892982, 0.2370975640936258, 0.19189117854080162, 0.08880321159757132, 0.08262301753342305, 0.0805521728935622, 0.08740960255546382, 0.09401980481254191, 0.09159166966188181, 0.09277389351346588, 0.0806106794211453, 0.09144685952236464]}, "mutation_prompt": null}
{"id": "ab668c36-2806-40a1-95fb-f66b9d3712e7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.6  # Changed line: Increased initial mutation factor from 0.5 to 0.6\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = max(0.1, self.CR + 0.2)  # Changed line: Increased CR adaptation step from 0.15 to 0.2\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.01)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, self.population_size // 2)\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Increase crossover probability adaptation step for faster convergence.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "39b2e59b-40ba-4e82-af8f-e67fb28ccb81", "metadata": {"aucs": [0.3489184105103065, 0.36870082086362366, 0.3778195317628439, 0.4020363289317822, 0.40408821533556205, 0.3862639462969101, 0.43255344831983056, 0.42741986611479765, 0.3537063268964825, 0.22416785632310643, 0.235682150254646, 0.23597761626383995, 0.21304620194938595, 0.208816880697838, 0.21942778375631444, 0.2334701176395868, 0.21741022877118776, 0.23464675045766037, 0.12831244471217085, 0.18432478328097868, 0.1394520363277908, 0.15097182613693316, 0.13515827852820772, 0.12902331189615124, 0.13194589408863178, 0.1356203578916435, 0.1184542072012944, 0.09527956652978209, 0.12032916814629768, 0.10446927305305365, 0.1028542210427571, 0.10001888907963985, 0.09371717147750336, 0.09837883466976105, 0.09640412006725452, 0.09281700395995962, 0.9440383829604595, 0.9616312242708378, 0.9356033580090445, 0.9875104415341811, 0.9466184431231511, 0.9657775188319202, 0.9407639005326487, 0.9655707295579696, 0.9403458254214, 0.22578065630695487, 0.26368319579482624, 0.25074596472981303, 0.2512727630222973, 0.23077156900643003, 0.2572315460138296, 0.2457123375990976, 0.2492166417781193, 0.27886451897022946, 0.54976838607196, 0.5517387494930397, 0.5295810003117687, 0.5687821678675855, 0.5521244920033588, 0.5460976097364374, 0.49465045176573286, 0.6058912186428766, 0.5993311139648643, 0.17068626678605248, 0.16616248803730382, 0.16947347697237036, 0.15716499272209694, 0.1257504412480961, 0.18026409575775237, 0.16197857432661045, 0.17262154400860596, 0.19775579907910334, 0.05386973441678222, 0.0160983562484871, 0.05484242936828343, 0.19278146089643644, 0.177493450035893, 0.14711295237052346, 0.17605281587335853, 0.1549456393316776, 0.13410788794785344, 0.15929899995709507, 0.17834450734989893, 0.1726499318914384, 0.16126476905747344, 0.19247255322939916, 0.16926805701566283, 0.16393230161990546, 0.21468877156236876, 0.1800362541706605, 0.2850792013354193, 0.2924898766733438, 0.33498760488742063, 0.27001584263439404, 0.28672723999782646, 0.277673376188316, 0.30621908148773347, 0.3106037824420289, 0.29898733256240506, 0.03411498708612559, 0.05525670867576504, 0.07208178840272106, 0.0567542179409527, 0.059247413964711226, 0.04912121777478884, 0.05960199896259877, 0.061184088658640445, 0.05730950470628182, 0.1311644152428555, 0.13134217452037067, 0.14904108215110567, 0.13140582469838136, 0.15458936551447677, 0.1500201938450093, 0.14435251303552066, 0.17167281723525718, 0.1561593411626081, 0.35691294208803803, 0.38134041221752, 0.36168461597199997, 0.37423134912311096, 0.4683768331130491, 0.38653514526791355, 0.3784651609269417, 0.377981906987665, 0.3468682656462724, 0.12924161491908037, 0.10921051690483585, 0.1286364170149611, 0.12114470481323003, 0.12284308296218893, 0.12419945400681898, 0.13570542063886992, 0.11996497283006069, 0.12462832478040564, 0.1511931064562272, 0.17797831277080345, 0.14033281050539315, 0.2759220021856814, 0.22024246830174243, 0.30414624004431945, 0.24457133443057488, 0.14717999508263635, 0.23075346178224165, 0.2652724814170063, 0.25845120625681073, 0.26253680607851126, 0.26070998356837327, 0.2690204875907445, 0.2675916238950723, 0.2675164860296392, 0.27607660961849556, 0.28089942758742226, 0.2192757708461871, 0.20420295788936715, 0.2062430008829329, 0.21683060803439025, 0.2243150255433346, 0.21002553168406446, 0.20391433923457636, 0.24160253529808007, 0.22434903824466768, 0.19760586062096563, 0.24071393439598865, 0.2037376935425781, 0.24657039571917294, 0.24767864144727159, 0.35002733766920235, 0.22902408581561828, 0.22420321626260864, 0.2034811313557714, 0.27505308023050057, 0.2503316809752796, 0.2042584183563546, 0.2537751401938987, 0.21981021108798826, 0.2200426496399699, 0.28091410312706555, 0.19110883420696023, 0.1862799717027004, 0.1508605147711447, 0.18942696524265235, 0.1942625569913865, 0.17672892464131906, 0.18461881737057306, 0.17185185891740473, 0.4326773168520903, 0.45722012850323956, 0.17741373120673654, 0.4049402115844226, 0.20024576995845034, 0.16365111866693638, 0.46952368281783763, 0.399270904307233, 0.37527089108230516, 0.20248223564421264, 0.5534999279159016, 0.19805485868673545, 0.1892335972144612, 0.1789104723405378, 0.20955869704236507, 0.17638246172394978, 0.20562763486099234, 0.18809241332606275, 0.19234401616892982, 0.2370975640936258, 0.19189117854080162, 0.08880321159757132, 0.08262301753342305, 0.0805521728935622, 0.08740960255546382, 0.09401980481254191, 0.09159166966188181, 0.09277389351346588, 0.0806106794211453, 0.09144685952236464]}, "mutation_prompt": null}
{"id": "3de52635-9343-43c1-bf07-2467097753b7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.65  # Changed line: Fine-tuned mutation factor from 0.6 to 0.65\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = max(0.1, self.CR + 0.2)\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.01)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, self.population_size // 2)\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Fine-tune the mutation scaling factor to balance between exploration and exploitation.", "configspace": "", "generation": 13, "fitness": 0.2576670645457504, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.18.", "error": "", "parent_id": "39b2e59b-40ba-4e82-af8f-e67fb28ccb81", "metadata": {"aucs": [0.38018124051395685, 0.3925605507110821, 0.371348748768103, 0.3887528452248826, 0.39705916372614025, 0.4093232337952427, 0.37749473291405367, 0.3822369809733779, 0.388470933316059, 0.21457369276629001, 0.2182816000766138, 0.21330336295443464, 0.20816928109563515, 0.22405467015668235, 0.2135169142957607, 0.21896899591224384, 0.2616233943985715, 0.23571302140619, 0.1037908821898671, 0.10951668177064788, 0.1146843926321004, 0.12938571541543475, 0.13983147071393598, 0.13700618530759712, 0.11762240785563749, 0.11904525029711455, 0.11443638072654194, 0.09764289717860042, 0.10785131257727221, 0.09593283071832559, 0.09066175663766807, 0.08681747520970873, 0.135533088621678, 0.11008343436095747, 0.11651741737011456, 0.12111109674875353, 0.9348596210660768, 0.9057002739444766, 0.7286489144800502, 0.9875102116101531, 0.896127070783372, 0.8851833619748988, 0.9654088680342436, 0.9736633770848973, 0.9591075993115098, 0.2298376756851025, 0.2501994889635615, 0.22249090904949098, 0.24521147565950285, 0.217407392489543, 0.24981962513734746, 0.239236540622896, 0.23206272415651896, 0.24077715636436836, 0.5134801668884528, 0.5505315785147727, 0.5199603855651699, 0.523455895661362, 0.5931659000481743, 0.5224854364753405, 0.5392657887598786, 0.5467448888783402, 0.5835811375367321, 0.18675765867876593, 0.18742883838648972, 0.19235540101165272, 0.18273706986557048, 0.17925243883453368, 0.20969919172677887, 0.20857103261126098, 0.18197496590366857, 0.19624297701490223, 0.021543452090458826, 0.021347352165321576, 0.13737879455483526, 0.15414663194688294, 0.18313092180970147, 0.1850071532041515, 0.1990001249256782, 0.18521333159874653, 0.13209216619036723, 0.1619115950363057, 0.19832214610827892, 0.1600191494733646, 0.20342373468312724, 0.15465382713271303, 0.14815998635078154, 0.14370621019529894, 0.16636111263625042, 0.1608517430679447, 0.2945994260414274, 0.28059796839491447, 0.2717429864476868, 0.27714142101384975, 0.26144808080236537, 0.29949801036090273, 0.31830010023782973, 0.2957259276525791, 0.3233167460439511, 0.04401889957102889, 0.041192934968779626, 0.05052397276966569, 0.05758233316204586, 0.049147002337767254, 0.07353623905325002, 0.05313320478474648, 0.06650418894581833, 0.06588555792579298, 0.13952335128866822, 0.15559925164757682, 0.1570394612806243, 0.14435630541592714, 0.15484593969636207, 0.16074254235246133, 0.16034962898345506, 0.15440865459763786, 0.16845612975057433, 0.3541839224840809, 0.36371465787083856, 0.3669443976130089, 0.37076603597466173, 0.36631896420989474, 0.3881727420150495, 0.40166287874025774, 0.37042017905916613, 0.3676674515678108, 0.13455665585490528, 0.13511911412228017, 0.1221737849860377, 0.13029975672407867, 0.13447781469889197, 0.11191510826272422, 0.11273568991978133, 0.11127187097626434, 0.1262583945983512, 0.19862722584911552, 0.28573282451486615, 0.3036537341280202, 0.33070905232534564, 0.3298729295857563, 0.3265136965392099, 0.2303756324130285, 0.314873399477383, 0.18963345009962795, 0.2819945881646746, 0.25994977858498247, 0.2709847890633751, 0.2733199004837348, 0.27055312597111414, 0.2621041455091423, 0.2739800752290117, 0.2813711012965491, 0.28118720592878277, 0.2156113797397915, 0.21185119535673136, 0.23272707529732994, 0.21012187260119808, 0.20953267097710804, 0.22374732146669463, 0.2354151749624379, 0.22872113069024957, 0.2162688555238147, 0.26262101639376134, 0.21369877169840223, 0.21700113420176126, 0.21829922482022357, 0.20380172477651504, 0.20475074855418995, 0.23769385451693525, 0.20628441784963414, 0.2378192574640362, 0.20160931554232897, 0.2085424706443869, 0.2002015679568958, 0.18419457676605466, 0.19430567358858852, 0.18658118057131845, 0.18975364293013586, 0.18693640345943863, 0.21647071288898456, 0.44730340540656466, 0.44808539107231404, 0.5587638542683742, 0.16954015135015166, 0.18453754181467752, 0.4824029186926342, 0.45421211395971695, 0.4705658550663179, 0.1977078321810527, 0.5842814750610577, 0.19577800248222343, 0.16341819537516789, 0.40946967255143685, 0.3486724187166236, 0.359980833637517, 0.2052742681677593, 0.20612784866991063, 0.2057166276330611, 0.18925840912039327, 0.19187157146683353, 0.177958856042166, 0.23461096843784335, 0.1793586426766911, 0.18442140636904703, 0.18831491898039243, 0.20781412997260673, 0.2327649762157008, 0.08895230442626889, 0.09805040558301992, 0.09362657981850064, 0.09240681513050364, 0.08944242097050059, 0.08521251551105635, 0.0943723979312392, 0.0820184065116335, 0.1056005877153533]}, "mutation_prompt": null}
{"id": "4bc6230a-3edb-401b-9682-0ec26711acf0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = max(0.1, self.CR + 0.2)\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.01)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, self.population_size // 2)\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Slightly increase the mutation factor to enhance exploration capabilities.", "configspace": "", "generation": 14, "fitness": 0.2581468336137479, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.18.", "error": "", "parent_id": "3de52635-9343-43c1-bf07-2467097753b7", "metadata": {"aucs": [0.35308089800540243, 0.39391910122515783, 0.38077688612734606, 0.4137794355040372, 0.3671805655722865, 0.39222145051317703, 0.38072197852482936, 0.4122709630296679, 0.36226817006017276, 0.2388561199471907, 0.2242019996058261, 0.23012467717413898, 0.22513842546275886, 0.2247506688026678, 0.20530583572573424, 0.23181933825759282, 0.22142947440699334, 0.2452027489971027, 0.1708816058401329, 0.12524694922516333, 0.12221493039799936, 0.12642258302752396, 0.1994118883256376, 0.11192982444609056, 0.11105163720836986, 0.12504462757063406, 0.12336610768751655, 0.09047484777811465, 0.1101961192741906, 0.08563560316771124, 0.11058331869120375, 0.12333977801670193, 0.10645954772191579, 0.10093901914600212, 0.09758591850713094, 0.10554216339264144, 0.9483137234033163, 0.9349206592776724, 0.8315035715682915, 0.9875102116101531, 0.8977115291698399, 0.948606405630325, 0.956627707047716, 0.9736633770848973, 0.9279351348539746, 0.2600479635610282, 0.2443102963500322, 0.23617023445806495, 0.23714287332021444, 0.2576240828190335, 0.24036001502389193, 0.24531561160341042, 0.2329137877257611, 0.24544342677659003, 0.5624018458385485, 0.5716488807132163, 0.31949335268733514, 0.5613455278272514, 0.5357249435560536, 0.5858582594592243, 0.5781394712416241, 0.5143463264634646, 0.49973538426662323, 0.16796902936385283, 0.15796683432382685, 0.17830397533199116, 0.2023031828297499, 0.1635502656101795, 0.1998091456402208, 0.21150644745612668, 0.1867434546598028, 0.1632343463910314, 0.2242094492683372, 0.009699179787589163, 0.21524929237006585, 0.1764745015742124, 0.15985731619740273, 0.17184114010363505, 0.18072207044225974, 0.18689295839714493, 0.16972556869619237, 0.1727769829827175, 0.1574844540378113, 0.17835390181345867, 0.17838194865664703, 0.1865114852798172, 0.15505704841891543, 0.18438565529886797, 0.14626777017611026, 0.17267668217416343, 0.26709979874408674, 0.3162684188727959, 0.29674406581747304, 0.27577423467458995, 0.28450635636761856, 0.27499988784621165, 0.3055026680943048, 0.37303028074887623, 0.3272364244881395, 0.04427062100167145, 0.04117698040869566, 0.044475433630240535, 0.06604738301390989, 0.05493350296200983, 0.04046517373615266, 0.05280495806460861, 0.05141460941279585, 0.0528328921694583, 0.15594532691254248, 0.14174720241837657, 0.15583277416687613, 0.1290774357287484, 0.1435688055942259, 0.1450578925692838, 0.14753901796812774, 0.1819990123321903, 0.15175274610271117, 0.3280930546209896, 0.38234394288052953, 0.38289713385379676, 0.3694349706867719, 0.390592304615228, 0.37046621149444203, 0.35880571309748077, 0.3426044093216526, 0.3810727940591102, 0.10225484982844157, 0.14732398124668256, 0.1279543238489208, 0.1422159422774928, 0.13396420801389775, 0.1149882069746504, 0.13128255510488585, 0.12717063800700512, 0.12292720963195503, 0.21173291158778007, 0.2841106300147911, 0.3033929854974099, 0.29458868369701297, 0.35640853300184294, 0.19154292335729373, 0.37727566525084677, 0.25702720340643315, 0.17762850944388808, 0.26667291409871396, 0.26533325817415043, 0.27520341514949254, 0.2537142536207382, 0.27178790835291045, 0.26376054022842954, 0.28843104862603264, 0.2804359484589898, 0.2782052443948999, 0.1973161804504724, 0.22978276912464213, 0.22178444371317296, 0.23017545720821653, 0.20961348816751746, 0.22512851618309437, 0.22221752983016618, 0.22622140763563914, 0.22253117316737503, 0.23208932041222663, 0.2427318794674408, 0.22404770453380418, 0.22423382973929895, 0.20469326895470363, 0.25400344298826527, 0.3240160079726536, 0.25129904682244764, 0.23436379195363732, 0.19274629592545578, 0.17345790424349838, 0.219427414991598, 0.1814346971227544, 0.21170247878184767, 0.21792944803569392, 0.18512806132050508, 0.20160857830083068, 0.19670360079315719, 0.6036544892499223, 0.18603906179019503, 0.1938421709407011, 0.4671780402794605, 0.186027758633885, 0.4539100920214857, 0.1766197815028845, 0.40984426198598867, 0.4378504431362096, 0.4151450211738358, 0.19896146058593978, 0.19347408196034244, 0.34057444615528876, 0.3643767293013781, 0.4484628249071714, 0.20388822978450893, 0.20458749788867348, 0.20438674615632557, 0.17990341648506525, 0.22803032105278986, 0.20098856962369394, 0.19634895604859826, 0.18461225163683703, 0.1886441636487225, 0.18479036344416877, 0.20870939748470552, 0.20286918432900036, 0.10522428701787412, 0.09292145792127426, 0.09854901479505229, 0.09173601424806532, 0.0798533573906901, 0.08415337361358266, 0.08279951923655404, 0.09441937021621838, 0.09205934032358742]}, "mutation_prompt": null}
{"id": "31a4e8f7-6313-4946-a26b-55cb275be336", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = max(0.1, self.CR + 0.2)\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.01)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, self.population_size // 2)\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Slightly increase the mutation factor to enhance exploration capabilities.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4bc6230a-3edb-401b-9682-0ec26711acf0", "metadata": {"aucs": [0.35308089800540243, 0.39391910122515783, 0.38077688612734606, 0.4137794355040372, 0.3671805655722865, 0.39222145051317703, 0.38072197852482936, 0.4122709630296679, 0.36226817006017276, 0.2388561199471907, 0.2242019996058261, 0.23012467717413898, 0.22513842546275886, 0.2247506688026678, 0.20530583572573424, 0.23181933825759282, 0.22142947440699334, 0.2452027489971027, 0.1708816058401329, 0.12524694922516333, 0.12221493039799936, 0.12642258302752396, 0.1994118883256376, 0.11192982444609056, 0.11105163720836986, 0.12504462757063406, 0.12336610768751655, 0.09047484777811465, 0.1101961192741906, 0.08563560316771124, 0.11058331869120375, 0.12333977801670193, 0.10645954772191579, 0.10093901914600212, 0.09758591850713094, 0.10554216339264144, 0.9483137234033163, 0.9349206592776724, 0.8315035715682915, 0.9875102116101531, 0.8977115291698399, 0.948606405630325, 0.956627707047716, 0.9736633770848973, 0.9279351348539746, 0.2600479635610282, 0.2443102963500322, 0.23617023445806495, 0.23714287332021444, 0.2576240828190335, 0.24036001502389193, 0.24531561160341042, 0.2329137877257611, 0.24544342677659003, 0.5624018458385485, 0.5716488807132163, 0.31949335268733514, 0.5613455278272514, 0.5357249435560536, 0.5858582594592243, 0.5781394712416241, 0.5143463264634646, 0.49973538426662323, 0.16796902936385283, 0.15796683432382685, 0.17830397533199116, 0.2023031828297499, 0.1635502656101795, 0.1998091456402208, 0.21150644745612668, 0.1867434546598028, 0.1632343463910314, 0.2242094492683372, 0.009699179787589163, 0.21524929237006585, 0.1764745015742124, 0.15985731619740273, 0.17184114010363505, 0.18072207044225974, 0.18689295839714493, 0.16972556869619237, 0.1727769829827175, 0.1574844540378113, 0.17835390181345867, 0.17838194865664703, 0.1865114852798172, 0.15505704841891543, 0.18438565529886797, 0.14626777017611026, 0.17267668217416343, 0.26709979874408674, 0.3162684188727959, 0.29674406581747304, 0.27577423467458995, 0.28450635636761856, 0.27499988784621165, 0.3055026680943048, 0.37303028074887623, 0.3272364244881395, 0.04427062100167145, 0.04117698040869566, 0.044475433630240535, 0.06604738301390989, 0.05493350296200983, 0.04046517373615266, 0.05280495806460861, 0.05141460941279585, 0.0528328921694583, 0.15594532691254248, 0.14174720241837657, 0.15583277416687613, 0.1290774357287484, 0.1435688055942259, 0.1450578925692838, 0.14753901796812774, 0.1819990123321903, 0.15175274610271117, 0.3280930546209896, 0.38234394288052953, 0.38289713385379676, 0.3694349706867719, 0.390592304615228, 0.37046621149444203, 0.35880571309748077, 0.3426044093216526, 0.3810727940591102, 0.10225484982844157, 0.14732398124668256, 0.1279543238489208, 0.1422159422774928, 0.13396420801389775, 0.1149882069746504, 0.13128255510488585, 0.12717063800700512, 0.12292720963195503, 0.21173291158778007, 0.2841106300147911, 0.3033929854974099, 0.29458868369701297, 0.35640853300184294, 0.19154292335729373, 0.37727566525084677, 0.25702720340643315, 0.17762850944388808, 0.26667291409871396, 0.26533325817415043, 0.27520341514949254, 0.2537142536207382, 0.27178790835291045, 0.26376054022842954, 0.28843104862603264, 0.2804359484589898, 0.2782052443948999, 0.1973161804504724, 0.22978276912464213, 0.22178444371317296, 0.23017545720821653, 0.20961348816751746, 0.22512851618309437, 0.22221752983016618, 0.22622140763563914, 0.22253117316737503, 0.23208932041222663, 0.2427318794674408, 0.22404770453380418, 0.22423382973929895, 0.20469326895470363, 0.25400344298826527, 0.3240160079726536, 0.25129904682244764, 0.23436379195363732, 0.19274629592545578, 0.17345790424349838, 0.219427414991598, 0.1814346971227544, 0.21170247878184767, 0.21792944803569392, 0.18512806132050508, 0.20160857830083068, 0.19670360079315719, 0.6036544892499223, 0.18603906179019503, 0.1938421709407011, 0.4671780402794605, 0.186027758633885, 0.4539100920214857, 0.1766197815028845, 0.40984426198598867, 0.4378504431362096, 0.4151450211738358, 0.19896146058593978, 0.19347408196034244, 0.34057444615528876, 0.3643767293013781, 0.4484628249071714, 0.20388822978450893, 0.20458749788867348, 0.20438674615632557, 0.17990341648506525, 0.22803032105278986, 0.20098856962369394, 0.19634895604859826, 0.18461225163683703, 0.1886441636487225, 0.18479036344416877, 0.20870939748470552, 0.20286918432900036, 0.10522428701787412, 0.09292145792127426, 0.09854901479505229, 0.09173601424806532, 0.0798533573906901, 0.08415337361358266, 0.08279951923655404, 0.09441937021621838, 0.09205934032358742]}, "mutation_prompt": null}
{"id": "50dd0bd9-8a1a-4273-932c-60768dbf383b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.75  # Changed line: Further increased mutation factor from 0.7 to 0.75\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = max(0.1, self.CR + 0.2)\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.01)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, self.population_size // 2)\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Improve exploration by slightly increasing the mutation factor to further enhance performance.", "configspace": "", "generation": 16, "fitness": 0.255659793872637, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.18.", "error": "", "parent_id": "4bc6230a-3edb-401b-9682-0ec26711acf0", "metadata": {"aucs": [0.34703078662635833, 0.39238927338338314, 0.3847077025799108, 0.4020107643465728, 0.3987174077883632, 0.4096731384908179, 0.420653877379647, 0.3650506271346612, 0.3843903777552612, 0.22351643369583674, 0.24526009836554052, 0.23791610077516256, 0.22193544295386902, 0.21451662077754785, 0.2272941282091795, 0.20919670439807603, 0.22332373928785876, 0.23829002297545399, 0.1256848748664905, 0.11978713920296724, 0.14774461209752277, 0.11478208648165056, 0.12624365490043332, 0.12200719480378497, 0.12203763618164198, 0.1301139538520374, 0.13884972634596326, 0.10412031115859788, 0.11586526920174989, 0.11620519733737056, 0.09037946164658028, 0.1043988783840516, 0.15302551793699493, 0.10104510348060591, 0.0955224034958686, 0.10606974055589147, 0.9514432872129781, 0.9293090500912211, 0.8090307775065216, 0.9875102116101531, 0.9048254328179943, 0.9062387704871792, 0.958206893493095, 0.9736633770848973, 0.92849583128362, 0.21873648064496642, 0.24141340671009748, 0.2351096831214401, 0.2692473029186413, 0.25429976847140856, 0.24904025484548153, 0.240047798687134, 0.25988242767111236, 0.26811181912225046, 0.5578443217538751, 0.5353881674660803, 0.5603790202751822, 0.5301186258371364, 0.5547167786224992, 0.547778022641606, 0.30421137102453166, 0.5221645801074455, 0.5230953035100829, 0.1354778851232109, 0.18983615084826544, 0.16621939010192377, 0.19472142780782542, 0.18111909330789355, 0.17347695464187252, 0.16924735167749583, 0.19100641142439, 0.21258039055695221, 0.021339734019665824, 0.01643958523363198, 0.10822252529158416, 0.21510107189300431, 0.15360186343733384, 0.15055852356507515, 0.17426157235969908, 0.16662033103518936, 0.1669482306165272, 0.1640182283917424, 0.19099160876710108, 0.18854845979524504, 0.15172230937936215, 0.17463297145506296, 0.18025795609635065, 0.1531905339918902, 0.16473206306089905, 0.1502663741760072, 0.2902325624951222, 0.29520184978884945, 0.29898131369086145, 0.27362762923703565, 0.2862535620441051, 0.2998464874436616, 0.29676773933169776, 0.2893141891238916, 0.301501055399796, 0.03876869494961699, 0.04101520611438225, 0.045119705755859996, 0.05344835329583819, 0.046301098625645354, 0.03649214552370739, 0.04187747723299362, 0.06314900622359021, 0.05629756934906727, 0.1525066280588111, 0.15151157750701427, 0.1575657194013249, 0.1598319115624114, 0.13232287889094585, 0.1368972621037977, 0.15533635490061137, 0.15300474243581486, 0.1413448747074797, 0.35371471473613325, 0.3653989597948284, 0.36905964725463913, 0.35404539216861974, 0.375527268039725, 0.36878172741957305, 0.4250776703648388, 0.36543961050153484, 0.3961597281322864, 0.12413359317938322, 0.12273444960721336, 0.13043658360022603, 0.1211701187999068, 0.11270650740727561, 0.1386588743263606, 0.11696577325903168, 0.1890571001416611, 0.12445105328437334, 0.21174424737170383, 0.2709146212727154, 0.3338699080993781, 0.3171760600414478, 0.2875579961761243, 0.3556400156668974, 0.2812313642291604, 0.35880415098621565, 0.3232384848820564, 0.2638061354674941, 0.26485872273739064, 0.2878945261058501, 0.2564456699379414, 0.2526796589478466, 0.26547722058408474, 0.27855452272034065, 0.2802701384890892, 0.29318340477630067, 0.21790349920808916, 0.21911142578134657, 0.21886259480823167, 0.22060167669587205, 0.20794795570001245, 0.21370734774533195, 0.24098583955651043, 0.22416579872931552, 0.2257520800203323, 0.22396083371375197, 0.2023250808049305, 0.2109262455237223, 0.19392025707331095, 0.2275862289985009, 0.23916791305676255, 0.2152969051872301, 0.19480179795503716, 0.22399456691308128, 0.18238182683244097, 0.18175206519431897, 0.19460914907895865, 0.2615428563629685, 0.19619317029940864, 0.19988761897637308, 0.21916513050162856, 0.18971546095130087, 0.20460637282301508, 0.5131268763422407, 0.1656381386573068, 0.18823930605853545, 0.17471930621199827, 0.45848701518864066, 0.38499180434466396, 0.1767737682447691, 0.19591781390753882, 0.463333297725645, 0.49310191660627933, 0.191498019985042, 0.19335378284356397, 0.4178392183485957, 0.4148531414090386, 0.4041286666498506, 0.1989212682567828, 0.14922323046686703, 0.20662509645851168, 0.18802675748400344, 0.1898338209189001, 0.19195448448734675, 0.20003336939478766, 0.22862044978167217, 0.21944775916325776, 0.22858394548907846, 0.22815433179249245, 0.18833996043499568, 0.08572281450747798, 0.09620927661597722, 0.09428099013107982, 0.1300738751359749, 0.09213149084834693, 0.08704909136130101, 0.10092471407875714, 0.10829177260134826, 0.08660621843402383]}, "mutation_prompt": null}
{"id": "df24dda2-7105-4669-92ee-f46b839bc18f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = max(0.1, self.CR + 0.2)\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.01)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, self.population_size // 2)\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Slightly increase the mutation factor to enhance exploration capabilities.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4bc6230a-3edb-401b-9682-0ec26711acf0", "metadata": {"aucs": [0.35308089800540243, 0.39391910122515783, 0.38077688612734606, 0.4137794355040372, 0.3671805655722865, 0.39222145051317703, 0.38072197852482936, 0.4122709630296679, 0.36226817006017276, 0.2388561199471907, 0.2242019996058261, 0.23012467717413898, 0.22513842546275886, 0.2247506688026678, 0.20530583572573424, 0.23181933825759282, 0.22142947440699334, 0.2452027489971027, 0.1708816058401329, 0.12524694922516333, 0.12221493039799936, 0.12642258302752396, 0.1994118883256376, 0.11192982444609056, 0.11105163720836986, 0.12504462757063406, 0.12336610768751655, 0.09047484777811465, 0.1101961192741906, 0.08563560316771124, 0.11058331869120375, 0.12333977801670193, 0.10645954772191579, 0.10093901914600212, 0.09758591850713094, 0.10554216339264144, 0.9483137234033163, 0.9349206592776724, 0.8315035715682915, 0.9875102116101531, 0.8977115291698399, 0.948606405630325, 0.956627707047716, 0.9736633770848973, 0.9279351348539746, 0.2600479635610282, 0.2443102963500322, 0.23617023445806495, 0.23714287332021444, 0.2576240828190335, 0.24036001502389193, 0.24531561160341042, 0.2329137877257611, 0.24544342677659003, 0.5624018458385485, 0.5716488807132163, 0.31949335268733514, 0.5613455278272514, 0.5357249435560536, 0.5858582594592243, 0.5781394712416241, 0.5143463264634646, 0.49973538426662323, 0.16796902936385283, 0.15796683432382685, 0.17830397533199116, 0.2023031828297499, 0.1635502656101795, 0.1998091456402208, 0.21150644745612668, 0.1867434546598028, 0.1632343463910314, 0.2242094492683372, 0.009699179787589163, 0.21524929237006585, 0.1764745015742124, 0.15985731619740273, 0.17184114010363505, 0.18072207044225974, 0.18689295839714493, 0.16972556869619237, 0.1727769829827175, 0.1574844540378113, 0.17835390181345867, 0.17838194865664703, 0.1865114852798172, 0.15505704841891543, 0.18438565529886797, 0.14626777017611026, 0.17267668217416343, 0.26709979874408674, 0.3162684188727959, 0.29674406581747304, 0.27577423467458995, 0.28450635636761856, 0.27499988784621165, 0.3055026680943048, 0.37303028074887623, 0.3272364244881395, 0.04427062100167145, 0.04117698040869566, 0.044475433630240535, 0.06604738301390989, 0.05493350296200983, 0.04046517373615266, 0.05280495806460861, 0.05141460941279585, 0.0528328921694583, 0.15594532691254248, 0.14174720241837657, 0.15583277416687613, 0.1290774357287484, 0.1435688055942259, 0.1450578925692838, 0.14753901796812774, 0.1819990123321903, 0.15175274610271117, 0.3280930546209896, 0.38234394288052953, 0.38289713385379676, 0.3694349706867719, 0.390592304615228, 0.37046621149444203, 0.35880571309748077, 0.3426044093216526, 0.3810727940591102, 0.10225484982844157, 0.14732398124668256, 0.1279543238489208, 0.1422159422774928, 0.13396420801389775, 0.1149882069746504, 0.13128255510488585, 0.12717063800700512, 0.12292720963195503, 0.21173291158778007, 0.2841106300147911, 0.3033929854974099, 0.29458868369701297, 0.35640853300184294, 0.19154292335729373, 0.37727566525084677, 0.25702720340643315, 0.17762850944388808, 0.26667291409871396, 0.26533325817415043, 0.27520341514949254, 0.2537142536207382, 0.27178790835291045, 0.26376054022842954, 0.28843104862603264, 0.2804359484589898, 0.2782052443948999, 0.1973161804504724, 0.22978276912464213, 0.22178444371317296, 0.23017545720821653, 0.20961348816751746, 0.22512851618309437, 0.22221752983016618, 0.22622140763563914, 0.22253117316737503, 0.23208932041222663, 0.2427318794674408, 0.22404770453380418, 0.22423382973929895, 0.20469326895470363, 0.25400344298826527, 0.3240160079726536, 0.25129904682244764, 0.23436379195363732, 0.19274629592545578, 0.17345790424349838, 0.219427414991598, 0.1814346971227544, 0.21170247878184767, 0.21792944803569392, 0.18512806132050508, 0.20160857830083068, 0.19670360079315719, 0.6036544892499223, 0.18603906179019503, 0.1938421709407011, 0.4671780402794605, 0.186027758633885, 0.4539100920214857, 0.1766197815028845, 0.40984426198598867, 0.4378504431362096, 0.4151450211738358, 0.19896146058593978, 0.19347408196034244, 0.34057444615528876, 0.3643767293013781, 0.4484628249071714, 0.20388822978450893, 0.20458749788867348, 0.20438674615632557, 0.17990341648506525, 0.22803032105278986, 0.20098856962369394, 0.19634895604859826, 0.18461225163683703, 0.1886441636487225, 0.18479036344416877, 0.20870939748470552, 0.20286918432900036, 0.10522428701787412, 0.09292145792127426, 0.09854901479505229, 0.09173601424806532, 0.0798533573906901, 0.08415337361358266, 0.08279951923655404, 0.09441937021621838, 0.09205934032358742]}, "mutation_prompt": null}
{"id": "d291cae8-644e-465a-b32d-8cbbb12fe61e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.85  # Changed line: Decreased crossover probability from 0.9 to 0.85\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = max(0.1, self.CR + 0.2)\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.01)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, self.population_size // 2)\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Slightly decrease crossover probability to intensify exploration during early stages.", "configspace": "", "generation": 18, "fitness": 0.2575883092638722, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.18.", "error": "", "parent_id": "4bc6230a-3edb-401b-9682-0ec26711acf0", "metadata": {"aucs": [0.35308089800540243, 0.39391910122515783, 0.38606313859441865, 0.4137794355040372, 0.3671805655722865, 0.3974576976439983, 0.38072197852482936, 0.4122709630296679, 0.36226817006017276, 0.2388561199471907, 0.2242019996058261, 0.23012467717413898, 0.22513842546275886, 0.2247506688026678, 0.20530583572573424, 0.23181933825759282, 0.22142947440699334, 0.2452027489971027, 0.1708816058401329, 0.12524694922516333, 0.12221493039799936, 0.12642258302752396, 0.1994118883256376, 0.11192982444609056, 0.11105163720836986, 0.12504462757063406, 0.12336610768751655, 0.09047484777811465, 0.1101961192741906, 0.08563560316771124, 0.11058331869120375, 0.12333977801670193, 0.09552921737843789, 0.10093901914600212, 0.09758591850713094, 0.10554216339264144, 0.9483137234033163, 0.9349206592776724, 0.8315035715682915, 0.9875102116101531, 0.8977115291698399, 0.948606405630325, 0.956627707047716, 0.9736633770848973, 0.9279351348539746, 0.2600479635610282, 0.2443102963500322, 0.23617023445806495, 0.23714287332021444, 0.2576240828190335, 0.24036001502389193, 0.24531561160341042, 0.2329137877257611, 0.24544342677659003, 0.5624018458385485, 0.5716488807132163, 0.31949335268733514, 0.5318597229241865, 0.5357249435560536, 0.5858582594592243, 0.5781394712416241, 0.5143463264634646, 0.49973538426662323, 0.16796902936385283, 0.15796683432382685, 0.17830397533199116, 0.2023031828297499, 0.1635502656101795, 0.1998091456402208, 0.21150644745612668, 0.1867434546598028, 0.1632343463910314, 0.2242094492683372, 0.009699179787589163, 0.21524929237006585, 0.1764745015742124, 0.15985731619740273, 0.17184114010363505, 0.18072207044225974, 0.18689295839714493, 0.16972556869619237, 0.1727769829827175, 0.1574844540378113, 0.18069650801225268, 0.17838194865664703, 0.1865114852798172, 0.15505704841891543, 0.18438565529886797, 0.14626777017611026, 0.17267668217416343, 0.26709979874408674, 0.3162684188727959, 0.29674406581747304, 0.261176071642907, 0.28450635636761856, 0.27499988784621165, 0.3055026680943048, 0.37303028074887623, 0.3272364244881395, 0.04427062100167145, 0.04117698040869566, 0.06825765125951455, 0.06604738301390989, 0.05493350296200983, 0.04046517373615266, 0.05280495806460861, 0.05141460941279585, 0.0528328921694583, 0.15594532691254248, 0.14174720241837657, 0.13851439359519369, 0.1290774357287484, 0.1435688055942259, 0.15679130626105675, 0.14753901796812774, 0.1819990123321903, 0.15175274610271117, 0.3280930546209896, 0.38234394288052953, 0.38289713385379676, 0.3694349706867719, 0.390592304615228, 0.37046621149444203, 0.35880571309748077, 0.3614193657715866, 0.35868487779492086, 0.13041545618478034, 0.14732398124668256, 0.1279543238489208, 0.1422159422774928, 0.13396420801389775, 0.1149882069746504, 0.13128255510488585, 0.12717063800700512, 0.1183994374814209, 0.21173291158778007, 0.2841106300147911, 0.3033929854974099, 0.29458868369701297, 0.35640853300184294, 0.19154292335729373, 0.37727566525084677, 0.25702720340643315, 0.17762850944388808, 0.26667291409871396, 0.26533325817415043, 0.27520341514949254, 0.26603877722958935, 0.27178790835291045, 0.26376054022842954, 0.27737459378807794, 0.2804359484589898, 0.2782052443948999, 0.1973161804504724, 0.22978276912464213, 0.22178444371317296, 0.2192567303427314, 0.20961348816751746, 0.21320325126991857, 0.22221752983016618, 0.22622140763563914, 0.21641693970846443, 0.22291887787455977, 0.2427318794674408, 0.22404770453380418, 0.22423382973929895, 0.20469326895470363, 0.25400344298826527, 0.24558783402349604, 0.25129904682244764, 0.1897913284396433, 0.19274629592545578, 0.17345790424349838, 0.219427414991598, 0.1814346971227544, 0.21170247878184767, 0.21467906958943284, 0.18512806132050508, 0.20160857830083068, 0.19670360079315719, 0.6036544892499223, 0.18603906179019503, 0.1938421709407011, 0.4671780402794605, 0.186027758633885, 0.4539100920214857, 0.1766197815028845, 0.40984426198598867, 0.4378504431362096, 0.4151450211738358, 0.19896146058593978, 0.19347408196034244, 0.34057444615528876, 0.3643767293013781, 0.4484628249071714, 0.20388822978450893, 0.20458749788867348, 0.20438674615632557, 0.17990341648506525, 0.22803032105278986, 0.20098856962369394, 0.19634895604859826, 0.18461225163683703, 0.1886441636487225, 0.18479036344416877, 0.20870939748470552, 0.24702317098404925, 0.10522428701787412, 0.09292145792127426, 0.09829215539296587, 0.09173601424806532, 0.0798533573906901, 0.08661866904184867, 0.08279951923655404, 0.09441937021621838, 0.09205934032358742]}, "mutation_prompt": null}
{"id": "a8274e2d-4a3e-4fcb-980d-211c0ca6abb8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = max(0.1, self.CR + 0.2)\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.02)  # Changed line: Adjust mutation factor decrement\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, self.population_size // 2)\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration by dynamically adjusting mutation factor based on fitness improvement rate.", "configspace": "", "generation": 19, "fitness": 0.3024940707176428, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.18.", "error": "", "parent_id": "4bc6230a-3edb-401b-9682-0ec26711acf0", "metadata": {"aucs": [0.40300366002506716, 0.39791189885842004, 0.39870229110163324, 0.40067500229542286, 0.4324837225252932, 0.41883478486678605, 0.3867514859104826, 0.3869542186827136, 0.40724196799105494, 0.2579836969119177, 0.2669767003121981, 0.2572683734761436, 0.26048469076735425, 0.2744112275464846, 0.27136022101209945, 0.27419382327212893, 0.2596098763855953, 0.26476417659777285, 0.12439346415707953, 0.12885008646853258, 0.14348929719881687, 0.14269747716213443, 0.13985219389229353, 0.11071848972591247, 0.16190650498152193, 0.16511636099487803, 0.13707687877472996, 0.15651896817692468, 0.11659994058951129, 0.10420489243041997, 0.10806296080761002, 0.08592687026245238, 0.11294956178720927, 0.13525575926863675, 0.09965403591842004, 0.11453437561828594, 0.9767511207244706, 0.9063046877715768, 0.7742348616255552, 0.9875058029759567, 0.9202805328740851, 0.9506349841842175, 0.9653931829655078, 0.9731144983644284, 0.9559885922060815, 0.2992633148511761, 0.3075723930939416, 0.2928301070651662, 0.3093573824304362, 0.29257498382879454, 0.28731636634403335, 0.2919454136177264, 0.28483192451294836, 0.29806761901082024, 0.34466182507433696, 0.7118688996754761, 0.3454878662766696, 0.7301486427905635, 0.7212109126984891, 0.7122859133488085, 0.34410491428467416, 0.7161292556978526, 0.6720162417826469, 0.26828840039806245, 0.24089576407677993, 0.27059004179200996, 0.22426881377649843, 0.2713891414528644, 0.21317031444730994, 0.26024001425542864, 0.26623237580967685, 0.25710671707064836, 0.14110705428194414, 0.2994266943517747, 0.3210083274829997, 0.23533921640469535, 0.2849563119353373, 0.23272778495228819, 0.2723449364449513, 0.23738598813850076, 0.2607831712289893, 0.2616346797775937, 0.26475265505869516, 0.24926957142556916, 0.24718925943995285, 0.25511723798935326, 0.23848931567490605, 0.2261445405496625, 0.24759184572810422, 0.24549551761784116, 0.3238331237958326, 0.3482423424765607, 0.31983597282250387, 0.38667456422116386, 0.31310187644740495, 0.3436019902566042, 0.32590750959872006, 0.3560575815032897, 0.3379691135038073, 0.12638296319590703, 0.1409529895528523, 0.15319383566235178, 0.10791011303892806, 0.13739608946203974, 0.1343395966582679, 0.13278396750176147, 0.16409846267157302, 0.14439581958957537, 0.19427900508177987, 0.1944575897410612, 0.19124326765041788, 0.19307199874873326, 0.1887770037679335, 0.1933333713389085, 0.212885303651825, 0.2107372524314518, 0.21842229101488997, 0.4107809910538913, 0.38275893935432026, 0.4117463952467917, 0.36944748311615827, 0.3927173444526415, 0.3617469766688971, 0.411232131428767, 0.36377288737138314, 0.3701683181350818, 0.16702662546577773, 0.11439711831992994, 0.1625446238149516, 0.145524194696509, 0.12081160522399348, 0.1058502745768577, 0.10720274981348343, 0.10969121883573785, 0.13145211213948227, 0.23622378167514302, 0.21981100622260963, 0.2968341798248969, 0.3573946953399446, 0.3687015763784791, 0.1894072002110352, 0.3967733940983229, 0.2548227161746588, 0.21787140626278456, 0.32795978801661363, 0.315837357689269, 0.34178671653961346, 0.3171331785785845, 0.3188822157979083, 0.3175063257524846, 0.3344642979251973, 0.34696813837273077, 0.35023986523955397, 0.2780011459203813, 0.2908405391238639, 0.28353510823977546, 0.3095424124206254, 0.28264416229322475, 0.28381591306377774, 0.30978339238746344, 0.2967864506377135, 0.2833716667836975, 0.2547607786044257, 0.2063779564356597, 0.2576192512278266, 0.2083092676099011, 0.21489411830101213, 0.23874223529864558, 0.2580818253722822, 0.23026242517272544, 0.2663463551204004, 0.1938978222709291, 0.19709126603553373, 0.3161646779510373, 0.21486813171164065, 0.19571109838997258, 0.19043183785899742, 0.17663098086755236, 0.22269568587743538, 0.21903770944897882, 0.5601949008390686, 0.5190993578567331, 0.5299153816570505, 0.4779296904979937, 0.5138196975773341, 0.46624864313532777, 0.500631286500379, 0.4470270667743672, 0.4954478459864251, 0.43393055764901123, 0.49750333750359554, 0.16461472102872832, 0.43438833137503485, 0.44483537947810603, 0.5530223173853679, 0.5791970780883806, 0.2017094979899099, 0.2035705779670256, 0.25573903095578476, 0.18622739432383006, 0.21243235815660677, 0.22436904518429224, 0.20731222146012518, 0.212391639337685, 0.2266448077415153, 0.19526937840261227, 0.25752777073305766, 0.09834501342613944, 0.09314392354798184, 0.1069901667116051, 0.10069995395473941, 0.12367392853207093, 0.10630712589310587, 0.09683401012996551, 0.13264240187515475, 0.08521652733581209]}, "mutation_prompt": null}
{"id": "a521dad7-5c6b-43b2-9fd4-bc1f4a7bb09e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.15)  # Adjusted line: Increase mutation factor increment\n                    self.CR = max(0.1, self.CR + 0.2)\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.02)  # Changed line: Adjust mutation factor decrement\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, self.population_size // 2)\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance population diversity by adjusting the mutation factor increment more aggressively upon success.", "configspace": "", "generation": 20, "fitness": 0.2825326382645887, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.18.", "error": "", "parent_id": "a8274e2d-4a3e-4fcb-980d-211c0ca6abb8", "metadata": {"aucs": [0.39357195596718186, 0.3802406807167026, 0.3938984910463569, 0.39698228485400455, 0.44440596606755967, 0.3992596171810947, 0.42688342271033863, 0.391681005184905, 0.48860096599739977, 0.23510694408217636, 0.24914585255767097, 0.2471685393192522, 0.23564175703768908, 0.28409473975596766, 0.23770949214640114, 0.25874463479168797, 0.23905860742837426, 0.25462852299688843, 0.13125091167453706, 0.12498748923614311, 0.12611564621180638, 0.14148429130804574, 0.1310325522198993, 0.10964894458025432, 0.13603128774591, 0.1507874403750593, 0.12373665178674398, 0.11337788653960779, 0.1086549058838987, 0.10669860854071445, 0.11352682899101596, 0.09263976997274581, 0.11025777731913544, 0.11435419365602861, 0.09500708360845111, 0.11287191939620422, 0.8677430852303398, 0.9219183629847247, 0.5634184213398057, 0.9875058029759567, 0.9071960919875647, 0.9202954351322117, 0.9653948692456235, 0.9731144983644284, 0.9518596164850165, 0.26420776692344794, 0.26957260387490545, 0.2690287569262919, 0.27865124592946267, 0.2612561626583896, 0.26888873511111955, 0.272903912644888, 0.2876568327870819, 0.2836968445108794, 0.6105084385743208, 0.6378266389306175, 0.6109679633102125, 0.6466928940705301, 0.6085186331522554, 0.6733717047892129, 0.634595897339534, 0.6514530469548039, 0.6434179722729327, 0.22475090939208875, 0.2119422402719301, 0.23004068069126415, 0.2213309364820557, 0.21614038935682756, 0.23035437691293048, 0.22131245536905408, 0.23756961701820856, 0.24960211678313127, 0.010046169365542812, 0.11779532440665152, 0.26515861339126445, 0.2138170051497662, 0.21500522289474888, 0.2358156317420016, 0.23029465142135697, 0.23132779534922032, 0.22666813158769106, 0.22409306357758974, 0.21104187650413775, 0.21440186267160677, 0.2386360862589023, 0.23845286217106154, 0.19184584899855472, 0.2297260493867851, 0.21930121430610838, 0.18920442589401, 0.30996709130723654, 0.3278471837185418, 0.3177164047606156, 0.3401402139884664, 0.3228700798744202, 0.30714085157708815, 0.31437997928995853, 0.3270739874708002, 0.30574933600560494, 0.06193436910332517, 0.10286526047968925, 0.07489257464274668, 0.08839204336328077, 0.09390544280785473, 0.130552750869681, 0.08478349210076175, 0.09624557337428796, 0.11548479343451457, 0.16743137223609972, 0.17251379114836018, 0.1670776043430191, 0.18045423979192854, 0.1792406264744132, 0.179194277063062, 0.21006484886092325, 0.1840033758786056, 0.18603703122990378, 0.38831547910618847, 0.3781940219358013, 0.3632422679059798, 0.4672836085981056, 0.36685542831675044, 0.40971689393621336, 0.3908810218332599, 0.382655796832028, 0.39367035909745307, 0.10516346091013618, 0.15814334404091046, 0.13928950509932625, 0.13588101215269566, 0.11944301900906884, 0.14857950553222943, 0.1353717461840399, 0.13122359015014862, 0.13179786879073618, 0.29753198825505167, 0.2910092114585142, 0.23619133112189816, 0.44682488604877235, 0.37634177715792505, 0.37207374031595875, 0.3790213474806433, 0.2600342015113215, 0.16086013687280065, 0.2950304919509985, 0.2915882652184524, 0.3032182847303063, 0.2951592066867227, 0.31036215399429334, 0.29356068069931807, 0.3122144583413514, 0.29712710110010687, 0.3301612460754071, 0.2658145142037711, 0.2437489547482925, 0.2715639231913708, 0.26267265256175065, 0.26431953820001997, 0.2529249393370575, 0.2648555160633138, 0.25794660111123924, 0.25685842314214613, 0.25527682802143026, 0.25169667469454615, 0.23277081601267569, 0.2459549025248854, 0.20875502110281263, 0.1926763989292377, 0.23301336859997268, 0.22696812676005806, 0.2057154223997889, 0.19743092083390368, 0.20274413936764257, 0.21776549998204975, 0.2910952651265618, 0.20480276334369818, 0.31952428531551413, 0.2188473067314216, 0.19969448337252038, 0.1974625331896006, 0.1512156055030871, 0.4969583399302512, 0.18462924288190674, 0.45553725728635863, 0.18886751552419523, 0.1671413784758815, 0.5520117169697315, 0.5191746123771759, 0.18642820365222956, 0.4808429368547418, 0.19583568761542436, 0.4155107195320533, 0.5036280728961929, 0.554984626489557, 0.3912677044354478, 0.20758535185844618, 0.20194030240029148, 0.2048197760043109, 0.2365690408922767, 0.1866866814143382, 0.17974104843460026, 0.235199196107305, 0.24643555329826516, 0.19154740422989802, 0.1827897692433189, 0.235304396667656, 0.2117317745855244, 0.09092031597318273, 0.09138144284988392, 0.09385619688483515, 0.0934191563721608, 0.09418336786007908, 0.08836377199226353, 0.14960952987753184, 0.09937006870611353, 0.10005978581235142]}, "mutation_prompt": null}
{"id": "1f8cba59-2cdb-466b-b15d-b3282def2f94", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = max(0.1, self.CR + 0.2)\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.02)  # Changed line: Adjust mutation factor decrement\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, self.population_size // 2)\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration by dynamically adjusting mutation factor based on fitness improvement rate.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a8274e2d-4a3e-4fcb-980d-211c0ca6abb8", "metadata": {"aucs": [0.40300366002506716, 0.39791189885842004, 0.39870229110163324, 0.40067500229542286, 0.4324837225252932, 0.41883478486678605, 0.3867514859104826, 0.3869542186827136, 0.40724196799105494, 0.2579836969119177, 0.2669767003121981, 0.2572683734761436, 0.26048469076735425, 0.2744112275464846, 0.27136022101209945, 0.27419382327212893, 0.2596098763855953, 0.26476417659777285, 0.12439346415707953, 0.12885008646853258, 0.14348929719881687, 0.14269747716213443, 0.13985219389229353, 0.11071848972591247, 0.16190650498152193, 0.16511636099487803, 0.13707687877472996, 0.15651896817692468, 0.11659994058951129, 0.10420489243041997, 0.10806296080761002, 0.08592687026245238, 0.11294956178720927, 0.13525575926863675, 0.09965403591842004, 0.11453437561828594, 0.9767511207244706, 0.9063046877715768, 0.7742348616255552, 0.9875058029759567, 0.9202805328740851, 0.9506349841842175, 0.9653931829655078, 0.9731144983644284, 0.9559885922060815, 0.2992633148511761, 0.3075723930939416, 0.2928301070651662, 0.3093573824304362, 0.29257498382879454, 0.28731636634403335, 0.2919454136177264, 0.28483192451294836, 0.29806761901082024, 0.34466182507433696, 0.7118688996754761, 0.3454878662766696, 0.7301486427905635, 0.7212109126984891, 0.7122859133488085, 0.34410491428467416, 0.7161292556978526, 0.6720162417826469, 0.26828840039806245, 0.24089576407677993, 0.27059004179200996, 0.22426881377649843, 0.2713891414528644, 0.21317031444730994, 0.26024001425542864, 0.26623237580967685, 0.25710671707064836, 0.14110705428194414, 0.2994266943517747, 0.3210083274829997, 0.23533921640469535, 0.2849563119353373, 0.23272778495228819, 0.2723449364449513, 0.23738598813850076, 0.2607831712289893, 0.2616346797775937, 0.26475265505869516, 0.24926957142556916, 0.24718925943995285, 0.25511723798935326, 0.23848931567490605, 0.2261445405496625, 0.24759184572810422, 0.24549551761784116, 0.3238331237958326, 0.3482423424765607, 0.31983597282250387, 0.38667456422116386, 0.31310187644740495, 0.3436019902566042, 0.32590750959872006, 0.3560575815032897, 0.3379691135038073, 0.12638296319590703, 0.1409529895528523, 0.15319383566235178, 0.10791011303892806, 0.13739608946203974, 0.1343395966582679, 0.13278396750176147, 0.16409846267157302, 0.14439581958957537, 0.19427900508177987, 0.1944575897410612, 0.19124326765041788, 0.19307199874873326, 0.1887770037679335, 0.1933333713389085, 0.212885303651825, 0.2107372524314518, 0.21842229101488997, 0.4107809910538913, 0.38275893935432026, 0.4117463952467917, 0.36944748311615827, 0.3927173444526415, 0.3617469766688971, 0.411232131428767, 0.36377288737138314, 0.3701683181350818, 0.16702662546577773, 0.11439711831992994, 0.1625446238149516, 0.145524194696509, 0.12081160522399348, 0.1058502745768577, 0.10720274981348343, 0.10969121883573785, 0.13145211213948227, 0.23622378167514302, 0.21981100622260963, 0.2968341798248969, 0.3573946953399446, 0.3687015763784791, 0.1894072002110352, 0.3967733940983229, 0.2548227161746588, 0.21787140626278456, 0.32795978801661363, 0.315837357689269, 0.34178671653961346, 0.3171331785785845, 0.3188822157979083, 0.3175063257524846, 0.3344642979251973, 0.34696813837273077, 0.35023986523955397, 0.2780011459203813, 0.2908405391238639, 0.28353510823977546, 0.3095424124206254, 0.28264416229322475, 0.28381591306377774, 0.30978339238746344, 0.2967864506377135, 0.2833716667836975, 0.2547607786044257, 0.2063779564356597, 0.2576192512278266, 0.2083092676099011, 0.21489411830101213, 0.23874223529864558, 0.2580818253722822, 0.23026242517272544, 0.2663463551204004, 0.1938978222709291, 0.19709126603553373, 0.3161646779510373, 0.21486813171164065, 0.19571109838997258, 0.19043183785899742, 0.17663098086755236, 0.22269568587743538, 0.21903770944897882, 0.5601949008390686, 0.5190993578567331, 0.5299153816570505, 0.4779296904979937, 0.5138196975773341, 0.46624864313532777, 0.500631286500379, 0.4470270667743672, 0.4954478459864251, 0.43393055764901123, 0.49750333750359554, 0.16461472102872832, 0.43438833137503485, 0.44483537947810603, 0.5530223173853679, 0.5791970780883806, 0.2017094979899099, 0.2035705779670256, 0.25573903095578476, 0.18622739432383006, 0.21243235815660677, 0.22436904518429224, 0.20731222146012518, 0.212391639337685, 0.2266448077415153, 0.19526937840261227, 0.25752777073305766, 0.09834501342613944, 0.09314392354798184, 0.1069901667116051, 0.10069995395473941, 0.12367392853207093, 0.10630712589310587, 0.09683401012996551, 0.13264240187515475, 0.08521652733581209]}, "mutation_prompt": null}
{"id": "1626a5df-a08b-4156-a99c-3223a69433fb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.15)  # Changed line: Increased mutation factor increment from 0.1 to 0.15\n                    self.CR = max(0.1, self.CR + 0.2)\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.02)  # Changed line: Adjust mutation factor decrement\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, self.population_size // 2)\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Fine-tune exploration and exploitation balance by slightly increasing the adaptive mutation factor's increment.", "configspace": "", "generation": 22, "fitness": 0.2825326382645887, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.18.", "error": "", "parent_id": "a8274e2d-4a3e-4fcb-980d-211c0ca6abb8", "metadata": {"aucs": [0.39357195596718186, 0.3802406807167026, 0.3938984910463569, 0.39698228485400455, 0.44440596606755967, 0.3992596171810947, 0.42688342271033863, 0.391681005184905, 0.48860096599739977, 0.23510694408217636, 0.24914585255767097, 0.2471685393192522, 0.23564175703768908, 0.28409473975596766, 0.23770949214640114, 0.25874463479168797, 0.23905860742837426, 0.25462852299688843, 0.13125091167453706, 0.12498748923614311, 0.12611564621180638, 0.14148429130804574, 0.1310325522198993, 0.10964894458025432, 0.13603128774591, 0.1507874403750593, 0.12373665178674398, 0.11337788653960779, 0.1086549058838987, 0.10669860854071445, 0.11352682899101596, 0.09263976997274581, 0.11025777731913544, 0.11435419365602861, 0.09500708360845111, 0.11287191939620422, 0.8677430852303398, 0.9219183629847247, 0.5634184213398057, 0.9875058029759567, 0.9071960919875647, 0.9202954351322117, 0.9653948692456235, 0.9731144983644284, 0.9518596164850165, 0.26420776692344794, 0.26957260387490545, 0.2690287569262919, 0.27865124592946267, 0.2612561626583896, 0.26888873511111955, 0.272903912644888, 0.2876568327870819, 0.2836968445108794, 0.6105084385743208, 0.6378266389306175, 0.6109679633102125, 0.6466928940705301, 0.6085186331522554, 0.6733717047892129, 0.634595897339534, 0.6514530469548039, 0.6434179722729327, 0.22475090939208875, 0.2119422402719301, 0.23004068069126415, 0.2213309364820557, 0.21614038935682756, 0.23035437691293048, 0.22131245536905408, 0.23756961701820856, 0.24960211678313127, 0.010046169365542812, 0.11779532440665152, 0.26515861339126445, 0.2138170051497662, 0.21500522289474888, 0.2358156317420016, 0.23029465142135697, 0.23132779534922032, 0.22666813158769106, 0.22409306357758974, 0.21104187650413775, 0.21440186267160677, 0.2386360862589023, 0.23845286217106154, 0.19184584899855472, 0.2297260493867851, 0.21930121430610838, 0.18920442589401, 0.30996709130723654, 0.3278471837185418, 0.3177164047606156, 0.3401402139884664, 0.3228700798744202, 0.30714085157708815, 0.31437997928995853, 0.3270739874708002, 0.30574933600560494, 0.06193436910332517, 0.10286526047968925, 0.07489257464274668, 0.08839204336328077, 0.09390544280785473, 0.130552750869681, 0.08478349210076175, 0.09624557337428796, 0.11548479343451457, 0.16743137223609972, 0.17251379114836018, 0.1670776043430191, 0.18045423979192854, 0.1792406264744132, 0.179194277063062, 0.21006484886092325, 0.1840033758786056, 0.18603703122990378, 0.38831547910618847, 0.3781940219358013, 0.3632422679059798, 0.4672836085981056, 0.36685542831675044, 0.40971689393621336, 0.3908810218332599, 0.382655796832028, 0.39367035909745307, 0.10516346091013618, 0.15814334404091046, 0.13928950509932625, 0.13588101215269566, 0.11944301900906884, 0.14857950553222943, 0.1353717461840399, 0.13122359015014862, 0.13179786879073618, 0.29753198825505167, 0.2910092114585142, 0.23619133112189816, 0.44682488604877235, 0.37634177715792505, 0.37207374031595875, 0.3790213474806433, 0.2600342015113215, 0.16086013687280065, 0.2950304919509985, 0.2915882652184524, 0.3032182847303063, 0.2951592066867227, 0.31036215399429334, 0.29356068069931807, 0.3122144583413514, 0.29712710110010687, 0.3301612460754071, 0.2658145142037711, 0.2437489547482925, 0.2715639231913708, 0.26267265256175065, 0.26431953820001997, 0.2529249393370575, 0.2648555160633138, 0.25794660111123924, 0.25685842314214613, 0.25527682802143026, 0.25169667469454615, 0.23277081601267569, 0.2459549025248854, 0.20875502110281263, 0.1926763989292377, 0.23301336859997268, 0.22696812676005806, 0.2057154223997889, 0.19743092083390368, 0.20274413936764257, 0.21776549998204975, 0.2910952651265618, 0.20480276334369818, 0.31952428531551413, 0.2188473067314216, 0.19969448337252038, 0.1974625331896006, 0.1512156055030871, 0.4969583399302512, 0.18462924288190674, 0.45553725728635863, 0.18886751552419523, 0.1671413784758815, 0.5520117169697315, 0.5191746123771759, 0.18642820365222956, 0.4808429368547418, 0.19583568761542436, 0.4155107195320533, 0.5036280728961929, 0.554984626489557, 0.3912677044354478, 0.20758535185844618, 0.20194030240029148, 0.2048197760043109, 0.2365690408922767, 0.1866866814143382, 0.17974104843460026, 0.235199196107305, 0.24643555329826516, 0.19154740422989802, 0.1827897692433189, 0.235304396667656, 0.2117317745855244, 0.09092031597318273, 0.09138144284988392, 0.09385619688483515, 0.0934191563721608, 0.09418336786007908, 0.08836377199226353, 0.14960952987753184, 0.09937006870611353, 0.10005978581235142]}, "mutation_prompt": null}
{"id": "b4548599-82b5-4848-8cd6-358fae28f44a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = max(0.1, self.CR + 0.2)\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.02)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.CR = max(0.1, self.CR - 0.05)  # Changed line: Adjust CR based on fitness variance\n                self.population_size = max(4, self.population_size // 2)\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Increase exploration by dynamically adjusting crossover probability based on fitness variance.", "configspace": "", "generation": 23, "fitness": 0.3024940707176428, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.18.", "error": "", "parent_id": "a8274e2d-4a3e-4fcb-980d-211c0ca6abb8", "metadata": {"aucs": [0.40300366002506716, 0.39791189885842004, 0.39870229110163324, 0.40067500229542286, 0.4324837225252932, 0.41883478486678605, 0.3867514859104826, 0.3869542186827136, 0.40724196799105494, 0.2579836969119177, 0.2669767003121981, 0.2572683734761436, 0.26048469076735425, 0.2744112275464846, 0.27136022101209945, 0.27419382327212893, 0.2596098763855953, 0.26476417659777285, 0.12439346415707953, 0.12885008646853258, 0.14348929719881687, 0.14269747716213443, 0.13985219389229353, 0.11071848972591247, 0.16190650498152193, 0.16511636099487803, 0.13707687877472996, 0.15651896817692468, 0.11659994058951129, 0.10420489243041997, 0.10806296080761002, 0.08592687026245238, 0.11294956178720927, 0.13525575926863675, 0.09965403591842004, 0.11453437561828594, 0.9767511207244706, 0.9063046877715768, 0.7742348616255552, 0.9875058029759567, 0.9202805328740851, 0.9506349841842175, 0.9653931829655078, 0.9731144983644284, 0.9559885922060815, 0.2992633148511761, 0.3075723930939416, 0.2928301070651662, 0.3093573824304362, 0.29257498382879454, 0.28731636634403335, 0.2919454136177264, 0.28483192451294836, 0.29806761901082024, 0.34466182507433696, 0.7118688996754761, 0.3454878662766696, 0.7301486427905635, 0.7212109126984891, 0.7122859133488085, 0.34410491428467416, 0.7161292556978526, 0.6720162417826469, 0.26828840039806245, 0.24089576407677993, 0.27059004179200996, 0.22426881377649843, 0.2713891414528644, 0.21317031444730994, 0.26024001425542864, 0.26623237580967685, 0.25710671707064836, 0.14110705428194414, 0.2994266943517747, 0.3210083274829997, 0.23533921640469535, 0.2849563119353373, 0.23272778495228819, 0.2723449364449513, 0.23738598813850076, 0.2607831712289893, 0.2616346797775937, 0.26475265505869516, 0.24926957142556916, 0.24718925943995285, 0.25511723798935326, 0.23848931567490605, 0.2261445405496625, 0.24759184572810422, 0.24549551761784116, 0.3238331237958326, 0.3482423424765607, 0.31983597282250387, 0.38667456422116386, 0.31310187644740495, 0.3436019902566042, 0.32590750959872006, 0.3560575815032897, 0.3379691135038073, 0.12638296319590703, 0.1409529895528523, 0.15319383566235178, 0.10791011303892806, 0.13739608946203974, 0.1343395966582679, 0.13278396750176147, 0.16409846267157302, 0.14439581958957537, 0.19427900508177987, 0.1944575897410612, 0.19124326765041788, 0.19307199874873326, 0.1887770037679335, 0.1933333713389085, 0.212885303651825, 0.2107372524314518, 0.21842229101488997, 0.4107809910538913, 0.38275893935432026, 0.4117463952467917, 0.36944748311615827, 0.3927173444526415, 0.3617469766688971, 0.411232131428767, 0.36377288737138314, 0.3701683181350818, 0.16702662546577773, 0.11439711831992994, 0.1625446238149516, 0.145524194696509, 0.12081160522399348, 0.1058502745768577, 0.10720274981348343, 0.10969121883573785, 0.13145211213948227, 0.23622378167514302, 0.21981100622260963, 0.2968341798248969, 0.3573946953399446, 0.3687015763784791, 0.1894072002110352, 0.3967733940983229, 0.2548227161746588, 0.21787140626278456, 0.32795978801661363, 0.315837357689269, 0.34178671653961346, 0.3171331785785845, 0.3188822157979083, 0.3175063257524846, 0.3344642979251973, 0.34696813837273077, 0.35023986523955397, 0.2780011459203813, 0.2908405391238639, 0.28353510823977546, 0.3095424124206254, 0.28264416229322475, 0.28381591306377774, 0.30978339238746344, 0.2967864506377135, 0.2833716667836975, 0.2547607786044257, 0.2063779564356597, 0.2576192512278266, 0.2083092676099011, 0.21489411830101213, 0.23874223529864558, 0.2580818253722822, 0.23026242517272544, 0.2663463551204004, 0.1938978222709291, 0.19709126603553373, 0.3161646779510373, 0.21486813171164065, 0.19571109838997258, 0.19043183785899742, 0.17663098086755236, 0.22269568587743538, 0.21903770944897882, 0.5601949008390686, 0.5190993578567331, 0.5299153816570505, 0.4779296904979937, 0.5138196975773341, 0.46624864313532777, 0.500631286500379, 0.4470270667743672, 0.4954478459864251, 0.43393055764901123, 0.49750333750359554, 0.16461472102872832, 0.43438833137503485, 0.44483537947810603, 0.5530223173853679, 0.5791970780883806, 0.2017094979899099, 0.2035705779670256, 0.25573903095578476, 0.18622739432383006, 0.21243235815660677, 0.22436904518429224, 0.20731222146012518, 0.212391639337685, 0.2266448077415153, 0.19526937840261227, 0.25752777073305766, 0.09834501342613944, 0.09314392354798184, 0.1069901667116051, 0.10069995395473941, 0.12367392853207093, 0.10630712589310587, 0.09683401012996551, 0.13264240187515475, 0.08521652733581209]}, "mutation_prompt": null}
{"id": "137552e4-7c5d-45b9-902f-1467cf7cf9fc", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.25)  # Changed line: Increase CR increment from 0.2 to 0.25\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.02)  # Changed line: Adjust mutation factor decrement\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, self.population_size // 2)\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance crossover effectiveness by making crossover probability slightly more responsive to recent successes.", "configspace": "", "generation": 24, "fitness": 0.3084630613303662, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.20.", "error": "", "parent_id": "a8274e2d-4a3e-4fcb-980d-211c0ca6abb8", "metadata": {"aucs": [0.5017633017942862, 0.4476075758393505, 0.4370095656030193, 0.4924094968894803, 0.5111615293119207, 0.609663005502838, 0.5241897256260214, 0.5437382078292186, 0.4547023511787103, 0.28038607627322065, 0.2747057485804826, 0.29013788317642697, 0.33458062219479245, 0.2938889076973683, 0.2579347309891987, 0.2752469959271163, 0.3297938450385849, 0.34454857344297785, 0.1505784968305166, 0.28191306196863986, 0.31444611908155606, 0.16156735013170886, 0.15534584035277388, 0.1358398104872176, 0.3306200036879392, 0.16121190351417614, 0.12555699492141903, 0.1185439077478746, 0.11842254205414915, 0.145825389942163, 0.26225481710569354, 0.12772380882304046, 0.15066867228766134, 0.1422479063911889, 0.12756067159558138, 0.14879239768681107, 0.9837809315340207, 0.9359184800108421, 0.9251846736870178, 0.9867683654543036, 0.9337580417232548, 0.9600822190683223, 0.9574625609981787, 0.9731144983644284, 0.9648427983629211, 0.2862574601276362, 0.29504728778173506, 0.3005227240158561, 0.317574378278798, 0.3397170235615131, 0.29700677460298974, 0.3374159957900704, 0.32091399999850456, 0.3100592772724683, 0.7269612867500774, 0.3512709250802122, 0.6884683740024939, 0.7174976083955042, 0.6909651298655748, 0.7117135044543996, 0.6881006823981022, 0.686931839421548, 0.7084776378288791, 0.26653700052813734, 0.20877481961379885, 0.24491183680801576, 0.27718223687027255, 0.25860409007541363, 0.2757841237285815, 0.25682855390479287, 0.28292510173790575, 0.3484023395048699, 0.30764053466084273, 0.021059049968165544, 0.3608285982784669, 0.21569876612528183, 0.28464290599179753, 0.2549512654672903, 0.2538709690440146, 0.227190814227601, 0.2759133671379722, 0.20210303339050206, 0.20338297347391598, 0.21383379399431202, 0.11163843912098914, 0.1311236077709096, 0.24353380080808062, 0.20204584605149833, 0.07136252346701422, 0.04844033996430175, 0.3386439795901115, 0.24131492634243634, 0.30633286927054404, 0.32903876380128516, 0.22996107289489465, 0.2959116427895724, 0.3094277366265674, 0.3330941401350548, 0.3212426412361743, 0.09149354795911846, 0.1452446068731862, 0.10849348197880715, 0.07345670794542636, 0.12093216533987194, 0.1395903353277772, 0.13860607404548153, 0.13484179443911815, 0.1350213676843841, 0.19468650367926132, 0.1966115995725023, 0.21135364181106453, 0.19948098351823795, 0.1928232533813823, 0.2216937299148818, 0.19384303420210613, 0.2329281805919151, 0.2189860281017969, 0.4514639954721741, 0.41621813085982373, 0.44745796158543716, 0.44923595829426943, 0.4609747118902964, 0.4005729711527698, 0.43123512065270164, 0.4082127190751932, 0.4420112559257686, 0.3343307457656921, 0.14742981101934005, 0.10137016452601078, 0.12712987761278016, 0.3000843587502541, 0.1317013765981423, 0.10287799843971257, 0.12271275468365561, 0.12657163299615182, 0.26414707557674844, 0.24856815875835336, 0.4032429111824529, 0.21889562172725996, 0.3774663126819462, 0.14527153912926039, 0.18264902609846956, 0.2868944054986575, 0.16388450749374406, 0.34314801414324747, 0.32417658500044677, 0.335720850122337, 0.31994229311591593, 0.3123207947488227, 0.3297217966650603, 0.3441871667362507, 0.34164814939981236, 0.36481156972466866, 0.31194387285632563, 0.28594524097980967, 0.2890601299877893, 0.29695121969554117, 0.2857669766195119, 0.30836100209344564, 0.30266735712054926, 0.2822455782657767, 0.30967483299339504, 0.2088219858126774, 0.17284423558638373, 0.20077648216408361, 0.21092163973180533, 0.20145531093037583, 0.20357771780263512, 0.19988141462868203, 0.20958726314444986, 0.2197345567538942, 0.4812192022107282, 0.22314447576248753, 0.2311728976729619, 0.19063377935293913, 0.22177451763747957, 0.32225015805369506, 0.1974828142218783, 0.19619943425262576, 0.17897539707987797, 0.1663617140283481, 0.19993505085815633, 0.15045895048474944, 0.6046361611560431, 0.19078902472244041, 0.7694755669104956, 0.5785062319044451, 0.6383231428010635, 0.19181582792130858, 0.5540268531668734, 0.6050682691890182, 0.48996098528363563, 0.201477772747239, 0.49307459829898537, 0.41153529532574074, 0.572572537935228, 0.2013259268176224, 0.2054957280313222, 0.18654373679009617, 0.19153544764605557, 0.18636369377974227, 0.18566010753724382, 0.18389698745240168, 0.18279657219466539, 0.2059324216516103, 0.17880885047169903, 0.19628599385893086, 0.07868894222347134, 0.08758254189929449, 0.08195311745106826, 0.09088105123021828, 0.0876262223686528, 0.09606075484956178, 0.0905857904367956, 0.08494533237277624, 0.09300837194418277]}, "mutation_prompt": null}
{"id": "ab233691-1ddb-4136-a78c-ce1aed50e595", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.15)  # Changed line: Increase F increment from 0.1 to 0.15\n                    self.CR = min(1.0, self.CR + 0.25)\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.02)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, self.population_size // 2)\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Improved dynamic adaptation by slightly increasing the mutation factor increment to enhance exploration capabilities.", "configspace": "", "generation": 25, "fitness": 0.282200320979743, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.20.", "error": "", "parent_id": "137552e4-7c5d-45b9-902f-1467cf7cf9fc", "metadata": {"aucs": [0.4803166897710064, 0.41844484573927376, 0.4418562712547144, 0.5748572142602164, 0.4684839583372905, 0.5905516073142363, 0.5334585170511146, 0.571987196452634, 0.5249908571654005, 0.335290081288695, 0.24426711979199622, 0.28906562134604274, 0.2709113686883572, 0.2787593677362149, 0.26516387285068854, 0.2529706169635155, 0.32233073773980336, 0.2642761500828157, 0.3052453357959284, 0.2410232347998149, 0.24568144782434376, 0.2483093404847636, 0.15047774332246533, 0.1240160298181523, 0.2808964563755323, 0.15687195613741967, 0.14332763894908584, 0.13464769714514824, 0.13556531600853283, 0.11864231359053479, 0.1152155102441611, 0.14130812522984582, 0.10226398902487277, 0.12563262970870548, 0.09203559684866158, 0.09809050649427298, 0.9821397555214337, 0.925767889246705, 0.9556211520276056, 0.9867683654543036, 0.8867448470065123, 0.9588533164568381, 0.9605729279622569, 0.9731144983644284, 0.9580568424605171, 0.26672238478546517, 0.3042065473364809, 0.2740639845753019, 0.2943316450214337, 0.26343720534338344, 0.26661534562315825, 0.2901360219877015, 0.3046929571430611, 0.2951736761410686, 0.6308721550290335, 0.6199912595997757, 0.6182285322653853, 0.6022677986030613, 0.6448791575707498, 0.6570027945559982, 0.6210467294845723, 0.6200489020604625, 0.5969317699858334, 0.21181858096097828, 0.19504536255032479, 0.23253410340680514, 0.2237725772882092, 0.22195876004845638, 0.23349912961172858, 0.1941771481779292, 0.20182430578922883, 0.2126572561004728, 0.02124998998060601, 0.02180929107229712, 0.46169475966315, 0.22230742869753817, 0.1817620209861157, 0.19777677173450026, 0.23033545868596939, 0.20824213471495123, 0.20757193921698058, 0.09164911674322207, 0.1036904509262524, 0.22244664070046516, 0.19818380953481196, 0.22179850958379588, 0.07965881980104383, 0.19453310062720397, 0.14978384470403672, 0.13795004996690008, 0.30378094882018647, 0.2962015963147352, 0.26944024342955986, 0.13717874764882, 0.06793849012916398, 0.22471750130640955, 0.32676938050106363, 0.34779788626353925, 0.31070210943415355, 0.07144076989015702, 0.04584830586318789, 0.0751675185927172, 0.04200731142917191, 0.0650348412178593, 0.03636662903355792, 0.08147255776001239, 0.06991599035169294, 0.07447441668658594, 0.16235533752520803, 0.1658629892643415, 0.1455442548919338, 0.15923778771221864, 0.1465527934572125, 0.17402192779622294, 0.16547001359004987, 0.16447315905910687, 0.19251906100912297, 0.4077927064830742, 0.4391511709520759, 0.4501837522612797, 0.4373977066412553, 0.415811525972142, 0.4262461452831321, 0.39036099981177874, 0.4028743762574878, 0.4158148996272526, 0.15859811458807582, 0.1445663317000453, 0.11142300913492653, 0.13312488094535602, 0.13318612059003265, 0.130935299404227, 0.10775803072952861, 0.14063357330967696, 0.13420841644223014, 0.3576594560818068, 0.29134480899702053, 0.1908251985006587, 0.3282521884041173, 0.41148098851217674, 0.33819317709990715, 0.20615297712513891, 0.25715549980335217, 0.3383295637030058, 0.2877245828650823, 0.3040686273753408, 0.3018152726398896, 0.2867277952321755, 0.29646184440899337, 0.29511961413714727, 0.3101308171300958, 0.30124142693835254, 0.31920487084599547, 0.27231280971721805, 0.22057974693578197, 0.24685146405321567, 0.24589172666132786, 0.2490331531907285, 0.24181427935722244, 0.2526834955652082, 0.2688364672766844, 0.2509884762128952, 0.18716457209924808, 0.1883198776293602, 0.19343325715582993, 0.22047861425716442, 0.18965746119395066, 0.20957811980256635, 0.19442112173205073, 0.1936409472759857, 0.20615409690517883, 0.22229941977564815, 0.28040044669398234, 0.20475151695727922, 0.3564515603907106, 0.21472633383377715, 0.22002333045395772, 0.37706936780274614, 0.21092881425202248, 0.22229609105907866, 0.6137284676903804, 0.1866127214989115, 0.14808648597583773, 0.17837472781248176, 0.6266440618968472, 0.1841023664588164, 0.6345259816834161, 0.1814729796607888, 0.5518773306869568, 0.6053585170761207, 0.19861853856568956, 0.14995557110340618, 0.18874126689532067, 0.2761117485626301, 0.15764655167798924, 0.20510684396774603, 0.20436528790308917, 0.20845346768556028, 0.19111717241127169, 0.18257197059406094, 0.1876898566740619, 0.17745954092987626, 0.2057955361021383, 0.17762775471840375, 0.18589515782952892, 0.1871766075321597, 0.20637723688356502, 0.08021531077496202, 0.08323786004017908, 0.08642877975232444, 0.08731488392916165, 0.08489055846472948, 0.0791680908383634, 0.08579451731292143, 0.08363750528044078, 0.09280038307893579]}, "mutation_prompt": null}
{"id": "1e2aad89-78e6-46c8-8f01-9937a970cf6b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.25)  # Changed line: Increase CR increment from 0.2 to 0.25\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.02)  # Changed line: Adjust mutation factor decrement\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, self.population_size // 2)\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance crossover effectiveness by making crossover probability slightly more responsive to recent successes.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "137552e4-7c5d-45b9-902f-1467cf7cf9fc", "metadata": {"aucs": [0.5017633017942862, 0.4476075758393505, 0.4370095656030193, 0.4924094968894803, 0.5111615293119207, 0.609663005502838, 0.5241897256260214, 0.5437382078292186, 0.4547023511787103, 0.28038607627322065, 0.2747057485804826, 0.29013788317642697, 0.33458062219479245, 0.2938889076973683, 0.2579347309891987, 0.2752469959271163, 0.3297938450385849, 0.34454857344297785, 0.1505784968305166, 0.28191306196863986, 0.31444611908155606, 0.16156735013170886, 0.15534584035277388, 0.1358398104872176, 0.3306200036879392, 0.16121190351417614, 0.12555699492141903, 0.1185439077478746, 0.11842254205414915, 0.145825389942163, 0.26225481710569354, 0.12772380882304046, 0.15066867228766134, 0.1422479063911889, 0.12756067159558138, 0.14879239768681107, 0.9837809315340207, 0.9359184800108421, 0.9251846736870178, 0.9867683654543036, 0.9337580417232548, 0.9600822190683223, 0.9574625609981787, 0.9731144983644284, 0.9648427983629211, 0.2862574601276362, 0.29504728778173506, 0.3005227240158561, 0.317574378278798, 0.3397170235615131, 0.29700677460298974, 0.3374159957900704, 0.32091399999850456, 0.3100592772724683, 0.7269612867500774, 0.3512709250802122, 0.6884683740024939, 0.7174976083955042, 0.6909651298655748, 0.7117135044543996, 0.6881006823981022, 0.686931839421548, 0.7084776378288791, 0.26653700052813734, 0.20877481961379885, 0.24491183680801576, 0.27718223687027255, 0.25860409007541363, 0.2757841237285815, 0.25682855390479287, 0.28292510173790575, 0.3484023395048699, 0.30764053466084273, 0.021059049968165544, 0.3608285982784669, 0.21569876612528183, 0.28464290599179753, 0.2549512654672903, 0.2538709690440146, 0.227190814227601, 0.2759133671379722, 0.20210303339050206, 0.20338297347391598, 0.21383379399431202, 0.11163843912098914, 0.1311236077709096, 0.24353380080808062, 0.20204584605149833, 0.07136252346701422, 0.04844033996430175, 0.3386439795901115, 0.24131492634243634, 0.30633286927054404, 0.32903876380128516, 0.22996107289489465, 0.2959116427895724, 0.3094277366265674, 0.3330941401350548, 0.3212426412361743, 0.09149354795911846, 0.1452446068731862, 0.10849348197880715, 0.07345670794542636, 0.12093216533987194, 0.1395903353277772, 0.13860607404548153, 0.13484179443911815, 0.1350213676843841, 0.19468650367926132, 0.1966115995725023, 0.21135364181106453, 0.19948098351823795, 0.1928232533813823, 0.2216937299148818, 0.19384303420210613, 0.2329281805919151, 0.2189860281017969, 0.4514639954721741, 0.41621813085982373, 0.44745796158543716, 0.44923595829426943, 0.4609747118902964, 0.4005729711527698, 0.43123512065270164, 0.4082127190751932, 0.4420112559257686, 0.3343307457656921, 0.14742981101934005, 0.10137016452601078, 0.12712987761278016, 0.3000843587502541, 0.1317013765981423, 0.10287799843971257, 0.12271275468365561, 0.12657163299615182, 0.26414707557674844, 0.24856815875835336, 0.4032429111824529, 0.21889562172725996, 0.3774663126819462, 0.14527153912926039, 0.18264902609846956, 0.2868944054986575, 0.16388450749374406, 0.34314801414324747, 0.32417658500044677, 0.335720850122337, 0.31994229311591593, 0.3123207947488227, 0.3297217966650603, 0.3441871667362507, 0.34164814939981236, 0.36481156972466866, 0.31194387285632563, 0.28594524097980967, 0.2890601299877893, 0.29695121969554117, 0.2857669766195119, 0.30836100209344564, 0.30266735712054926, 0.2822455782657767, 0.30967483299339504, 0.2088219858126774, 0.17284423558638373, 0.20077648216408361, 0.21092163973180533, 0.20145531093037583, 0.20357771780263512, 0.19988141462868203, 0.20958726314444986, 0.2197345567538942, 0.4812192022107282, 0.22314447576248753, 0.2311728976729619, 0.19063377935293913, 0.22177451763747957, 0.32225015805369506, 0.1974828142218783, 0.19619943425262576, 0.17897539707987797, 0.1663617140283481, 0.19993505085815633, 0.15045895048474944, 0.6046361611560431, 0.19078902472244041, 0.7694755669104956, 0.5785062319044451, 0.6383231428010635, 0.19181582792130858, 0.5540268531668734, 0.6050682691890182, 0.48996098528363563, 0.201477772747239, 0.49307459829898537, 0.41153529532574074, 0.572572537935228, 0.2013259268176224, 0.2054957280313222, 0.18654373679009617, 0.19153544764605557, 0.18636369377974227, 0.18566010753724382, 0.18389698745240168, 0.18279657219466539, 0.2059324216516103, 0.17880885047169903, 0.19628599385893086, 0.07868894222347134, 0.08758254189929449, 0.08195311745106826, 0.09088105123021828, 0.0876262223686528, 0.09606075484956178, 0.0905857904367956, 0.08494533237277624, 0.09300837194418277]}, "mutation_prompt": null}
{"id": "e52996f0-ab0e-4257-aa10-26e72b7a4ffe", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.25)  # Changed line: Increase CR increment from 0.2 to 0.25\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, self.population_size // 2)\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Improve solution selection by slightly increasing the decrement of mutation factor upon unsuccessful trials.", "configspace": "", "generation": 27, "fitness": 0.3281419352568924, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.20.", "error": "", "parent_id": "137552e4-7c5d-45b9-902f-1467cf7cf9fc", "metadata": {"aucs": [0.4839835789668727, 0.5029002385007879, 0.44449207452046746, 0.53084235089218, 0.4289188791201477, 0.4282206498599972, 0.49840904539881326, 0.5474371056056342, 0.5225955598385083, 0.3389325029836725, 0.3363428774407502, 0.32087882889139374, 0.35568696856103366, 0.3049366247859606, 0.3937139122130723, 0.36865935322930155, 0.3561424771262738, 0.36596579068861956, 0.13334188196258168, 0.1688399822270059, 0.14601746877303745, 0.1455444772567389, 0.3597405702700417, 0.12947659784873744, 0.16404370158148862, 0.14943261368116767, 0.13435636398007267, 0.1264795028383764, 0.12993578231669545, 0.15737160850269416, 0.10695837762234528, 0.11741025005082761, 0.1385735736473538, 0.16382792941162116, 0.13870880507571548, 0.14249694581354766, 0.846261418710645, 0.8873689250847024, 0.917097023242121, 0.9756760631660589, 0.9540851278944535, 0.9390555195616939, 0.9738097338493318, 0.9727931151435046, 0.9599460045947447, 0.3269688029214328, 0.36585198733701707, 0.29156654178334784, 0.3453634584969554, 0.3110588297239095, 0.320685259925929, 0.3579232128354005, 0.33565146333775997, 0.2936293140753422, 0.7849462628489294, 0.7589853193025019, 0.7430794721043432, 0.765249823050244, 0.7633665221914736, 0.7722964694684591, 0.7382477568024708, 0.36220855860246426, 0.7781177664846235, 0.29165427291172663, 0.28440251849028075, 0.36443361854053324, 0.29542257706879094, 0.29803277085388513, 0.2978946427808912, 0.31839418235151395, 0.285979205929877, 0.4103283872402468, 0.3283422010068642, 0.46138671093375916, 0.39884725115474884, 0.29537499459060335, 0.29436488447431686, 0.33673595734460593, 0.27377829730432346, 0.4027379916570437, 0.2765810938254588, 0.3174481020521357, 0.29135684213908253, 0.15197622505461694, 0.3320304808810597, 0.2971839351672475, 0.15157400289988288, 0.32156674856382883, 0.2935761747544573, 0.21114231040996878, 0.41295120421520803, 0.3661827230901292, 0.34398724942384296, 0.35093798683374944, 0.3686799166822837, 0.32354416325958946, 0.42012347241405146, 0.37026683512365766, 0.36062277504330575, 0.19965024913880647, 0.2044025715284492, 0.1587308725417157, 0.22534910584570045, 0.23265013324600525, 0.2242680253536128, 0.1783449602379118, 0.2295586017633554, 0.1410539246306144, 0.26187791690679285, 0.28537854286216147, 0.2713712372301822, 0.2715427522568662, 0.25822172014861444, 0.28109585718248686, 0.2629121147587914, 0.32291258893735375, 0.30259286195126756, 0.4424838362378173, 0.447709594267498, 0.43459757292561385, 0.4479996585817928, 0.48935860691651045, 0.40446043301175505, 0.41750388785324144, 0.4811487186020542, 0.4318103697540804, 0.14634327644373424, 0.15163825032470957, 0.15038325244170025, 0.11137095130978292, 0.13025137960134703, 0.1507913744152034, 0.1455161800951239, 0.10916214298852955, 0.10906747205690659, 0.34963281511683686, 0.21850457245438504, 0.3909056534408246, 0.4481326489983065, 0.23692002875580287, 0.4270526141588128, 0.2300904244131149, 0.2875280020801748, 0.22211429312485342, 0.35141588153229864, 0.3339681780786874, 0.4237509525242731, 0.350507424080889, 0.3535569321818445, 0.34355035047004034, 0.35848463281035103, 0.3409608443578267, 0.336331470890167, 0.31397798867704374, 0.2822296591428314, 0.3450469990913585, 0.3149448934968814, 0.3203290478692524, 0.32563191837663485, 0.3393854382922936, 0.3256650435557844, 0.32655902218638544, 0.1942652501779929, 0.20167140290158792, 0.21591784386723734, 0.19967755756300698, 0.20043466783681096, 0.1996651428118148, 0.19375929395857128, 0.19873372698506975, 0.24280595489333445, 0.2101621722475735, 0.2338220819932707, 0.23278122391409406, 0.2087794556310365, 0.20876557779438643, 0.23705689082391745, 0.23434997752032105, 0.20324943604054624, 0.18497938911447076, 0.16796009204192563, 0.5832577218652562, 0.15254327351980934, 0.18159204745711655, 0.5815743728792518, 0.19495884915643735, 0.18509053545621323, 0.6364815142716764, 0.6502636873015597, 0.5764611077488019, 0.48798331361918224, 0.15199816667289234, 0.203386963250906, 0.5335988859914538, 0.20315083132386202, 0.20690060755977824, 0.5428151624593767, 0.20482631863604372, 0.17407561479187894, 0.2009813661210389, 0.19462589700452215, 0.1957509665898276, 0.1839789739029708, 0.18151315091830178, 0.1793283974286256, 0.18566559930149928, 0.187304169305741, 0.08435359571920176, 0.08501958976615642, 0.09968029659511757, 0.09015217140293263, 0.11275237407040173, 0.08665749537097467, 0.08508056202671921, 0.08918138952531685, 0.08339947336393505]}, "mutation_prompt": null}
{"id": "cba8b005-c5a7-49bf-ab4b-316c8e24bb78", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.25)  # Changed line: Increase CR increment from 0.2 to 0.25\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, self.population_size // 2)\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Improve solution selection by slightly increasing the decrement of mutation factor upon unsuccessful trials.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e52996f0-ab0e-4257-aa10-26e72b7a4ffe", "metadata": {"aucs": [0.4839835789668727, 0.5029002385007879, 0.44449207452046746, 0.53084235089218, 0.4289188791201477, 0.4282206498599972, 0.49840904539881326, 0.5474371056056342, 0.5225955598385083, 0.3389325029836725, 0.3363428774407502, 0.32087882889139374, 0.35568696856103366, 0.3049366247859606, 0.3937139122130723, 0.36865935322930155, 0.3561424771262738, 0.36596579068861956, 0.13334188196258168, 0.1688399822270059, 0.14601746877303745, 0.1455444772567389, 0.3597405702700417, 0.12947659784873744, 0.16404370158148862, 0.14943261368116767, 0.13435636398007267, 0.1264795028383764, 0.12993578231669545, 0.15737160850269416, 0.10695837762234528, 0.11741025005082761, 0.1385735736473538, 0.16382792941162116, 0.13870880507571548, 0.14249694581354766, 0.846261418710645, 0.8873689250847024, 0.917097023242121, 0.9756760631660589, 0.9540851278944535, 0.9390555195616939, 0.9738097338493318, 0.9727931151435046, 0.9599460045947447, 0.3269688029214328, 0.36585198733701707, 0.29156654178334784, 0.3453634584969554, 0.3110588297239095, 0.320685259925929, 0.3579232128354005, 0.33565146333775997, 0.2936293140753422, 0.7849462628489294, 0.7589853193025019, 0.7430794721043432, 0.765249823050244, 0.7633665221914736, 0.7722964694684591, 0.7382477568024708, 0.36220855860246426, 0.7781177664846235, 0.29165427291172663, 0.28440251849028075, 0.36443361854053324, 0.29542257706879094, 0.29803277085388513, 0.2978946427808912, 0.31839418235151395, 0.285979205929877, 0.4103283872402468, 0.3283422010068642, 0.46138671093375916, 0.39884725115474884, 0.29537499459060335, 0.29436488447431686, 0.33673595734460593, 0.27377829730432346, 0.4027379916570437, 0.2765810938254588, 0.3174481020521357, 0.29135684213908253, 0.15197622505461694, 0.3320304808810597, 0.2971839351672475, 0.15157400289988288, 0.32156674856382883, 0.2935761747544573, 0.21114231040996878, 0.41295120421520803, 0.3661827230901292, 0.34398724942384296, 0.35093798683374944, 0.3686799166822837, 0.32354416325958946, 0.42012347241405146, 0.37026683512365766, 0.36062277504330575, 0.19965024913880647, 0.2044025715284492, 0.1587308725417157, 0.22534910584570045, 0.23265013324600525, 0.2242680253536128, 0.1783449602379118, 0.2295586017633554, 0.1410539246306144, 0.26187791690679285, 0.28537854286216147, 0.2713712372301822, 0.2715427522568662, 0.25822172014861444, 0.28109585718248686, 0.2629121147587914, 0.32291258893735375, 0.30259286195126756, 0.4424838362378173, 0.447709594267498, 0.43459757292561385, 0.4479996585817928, 0.48935860691651045, 0.40446043301175505, 0.41750388785324144, 0.4811487186020542, 0.4318103697540804, 0.14634327644373424, 0.15163825032470957, 0.15038325244170025, 0.11137095130978292, 0.13025137960134703, 0.1507913744152034, 0.1455161800951239, 0.10916214298852955, 0.10906747205690659, 0.34963281511683686, 0.21850457245438504, 0.3909056534408246, 0.4481326489983065, 0.23692002875580287, 0.4270526141588128, 0.2300904244131149, 0.2875280020801748, 0.22211429312485342, 0.35141588153229864, 0.3339681780786874, 0.4237509525242731, 0.350507424080889, 0.3535569321818445, 0.34355035047004034, 0.35848463281035103, 0.3409608443578267, 0.336331470890167, 0.31397798867704374, 0.2822296591428314, 0.3450469990913585, 0.3149448934968814, 0.3203290478692524, 0.32563191837663485, 0.3393854382922936, 0.3256650435557844, 0.32655902218638544, 0.1942652501779929, 0.20167140290158792, 0.21591784386723734, 0.19967755756300698, 0.20043466783681096, 0.1996651428118148, 0.19375929395857128, 0.19873372698506975, 0.24280595489333445, 0.2101621722475735, 0.2338220819932707, 0.23278122391409406, 0.2087794556310365, 0.20876557779438643, 0.23705689082391745, 0.23434997752032105, 0.20324943604054624, 0.18497938911447076, 0.16796009204192563, 0.5832577218652562, 0.15254327351980934, 0.18159204745711655, 0.5815743728792518, 0.19495884915643735, 0.18509053545621323, 0.6364815142716764, 0.6502636873015597, 0.5764611077488019, 0.48798331361918224, 0.15199816667289234, 0.203386963250906, 0.5335988859914538, 0.20315083132386202, 0.20690060755977824, 0.5428151624593767, 0.20482631863604372, 0.17407561479187894, 0.2009813661210389, 0.19462589700452215, 0.1957509665898276, 0.1839789739029708, 0.18151315091830178, 0.1793283974286256, 0.18566559930149928, 0.187304169305741, 0.08435359571920176, 0.08501958976615642, 0.09968029659511757, 0.09015217140293263, 0.11275237407040173, 0.08665749537097467, 0.08508056202671921, 0.08918138952531685, 0.08339947336393505]}, "mutation_prompt": null}
{"id": "079d41b7-a7d7-4a58-a05c-d9118c5166f9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.25)  # Changed line: Increase CR increment from 0.2 to 0.25\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, self.population_size // 2)\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Improve solution selection by slightly increasing the decrement of mutation factor upon unsuccessful trials.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e52996f0-ab0e-4257-aa10-26e72b7a4ffe", "metadata": {"aucs": [0.4839835789668727, 0.5029002385007879, 0.44449207452046746, 0.53084235089218, 0.4289188791201477, 0.4282206498599972, 0.49840904539881326, 0.5474371056056342, 0.5225955598385083, 0.3389325029836725, 0.3363428774407502, 0.32087882889139374, 0.35568696856103366, 0.3049366247859606, 0.3937139122130723, 0.36865935322930155, 0.3561424771262738, 0.36596579068861956, 0.13334188196258168, 0.1688399822270059, 0.14601746877303745, 0.1455444772567389, 0.3597405702700417, 0.12947659784873744, 0.16404370158148862, 0.14943261368116767, 0.13435636398007267, 0.1264795028383764, 0.12993578231669545, 0.15737160850269416, 0.10695837762234528, 0.11741025005082761, 0.1385735736473538, 0.16382792941162116, 0.13870880507571548, 0.14249694581354766, 0.846261418710645, 0.8873689250847024, 0.917097023242121, 0.9756760631660589, 0.9540851278944535, 0.9390555195616939, 0.9738097338493318, 0.9727931151435046, 0.9599460045947447, 0.3269688029214328, 0.36585198733701707, 0.29156654178334784, 0.3453634584969554, 0.3110588297239095, 0.320685259925929, 0.3579232128354005, 0.33565146333775997, 0.2936293140753422, 0.7849462628489294, 0.7589853193025019, 0.7430794721043432, 0.765249823050244, 0.7633665221914736, 0.7722964694684591, 0.7382477568024708, 0.36220855860246426, 0.7781177664846235, 0.29165427291172663, 0.28440251849028075, 0.36443361854053324, 0.29542257706879094, 0.29803277085388513, 0.2978946427808912, 0.31839418235151395, 0.285979205929877, 0.4103283872402468, 0.3283422010068642, 0.46138671093375916, 0.39884725115474884, 0.29537499459060335, 0.29436488447431686, 0.33673595734460593, 0.27377829730432346, 0.4027379916570437, 0.2765810938254588, 0.3174481020521357, 0.29135684213908253, 0.15197622505461694, 0.3320304808810597, 0.2971839351672475, 0.15157400289988288, 0.32156674856382883, 0.2935761747544573, 0.21114231040996878, 0.41295120421520803, 0.3661827230901292, 0.34398724942384296, 0.35093798683374944, 0.3686799166822837, 0.32354416325958946, 0.42012347241405146, 0.37026683512365766, 0.36062277504330575, 0.19965024913880647, 0.2044025715284492, 0.1587308725417157, 0.22534910584570045, 0.23265013324600525, 0.2242680253536128, 0.1783449602379118, 0.2295586017633554, 0.1410539246306144, 0.26187791690679285, 0.28537854286216147, 0.2713712372301822, 0.2715427522568662, 0.25822172014861444, 0.28109585718248686, 0.2629121147587914, 0.32291258893735375, 0.30259286195126756, 0.4424838362378173, 0.447709594267498, 0.43459757292561385, 0.4479996585817928, 0.48935860691651045, 0.40446043301175505, 0.41750388785324144, 0.4811487186020542, 0.4318103697540804, 0.14634327644373424, 0.15163825032470957, 0.15038325244170025, 0.11137095130978292, 0.13025137960134703, 0.1507913744152034, 0.1455161800951239, 0.10916214298852955, 0.10906747205690659, 0.34963281511683686, 0.21850457245438504, 0.3909056534408246, 0.4481326489983065, 0.23692002875580287, 0.4270526141588128, 0.2300904244131149, 0.2875280020801748, 0.22211429312485342, 0.35141588153229864, 0.3339681780786874, 0.4237509525242731, 0.350507424080889, 0.3535569321818445, 0.34355035047004034, 0.35848463281035103, 0.3409608443578267, 0.336331470890167, 0.31397798867704374, 0.2822296591428314, 0.3450469990913585, 0.3149448934968814, 0.3203290478692524, 0.32563191837663485, 0.3393854382922936, 0.3256650435557844, 0.32655902218638544, 0.1942652501779929, 0.20167140290158792, 0.21591784386723734, 0.19967755756300698, 0.20043466783681096, 0.1996651428118148, 0.19375929395857128, 0.19873372698506975, 0.24280595489333445, 0.2101621722475735, 0.2338220819932707, 0.23278122391409406, 0.2087794556310365, 0.20876557779438643, 0.23705689082391745, 0.23434997752032105, 0.20324943604054624, 0.18497938911447076, 0.16796009204192563, 0.5832577218652562, 0.15254327351980934, 0.18159204745711655, 0.5815743728792518, 0.19495884915643735, 0.18509053545621323, 0.6364815142716764, 0.6502636873015597, 0.5764611077488019, 0.48798331361918224, 0.15199816667289234, 0.203386963250906, 0.5335988859914538, 0.20315083132386202, 0.20690060755977824, 0.5428151624593767, 0.20482631863604372, 0.17407561479187894, 0.2009813661210389, 0.19462589700452215, 0.1957509665898276, 0.1839789739029708, 0.18151315091830178, 0.1793283974286256, 0.18566559930149928, 0.187304169305741, 0.08435359571920176, 0.08501958976615642, 0.09968029659511757, 0.09015217140293263, 0.11275237407040173, 0.08665749537097467, 0.08508056202671921, 0.08918138952531685, 0.08339947336393505]}, "mutation_prompt": null}
{"id": "ea4d3a66-cb43-4353-bd80-443ef0525247", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.25)  \n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.03 to 0.01)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, self.population_size // 2)\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Fine-tune control parameters dynamically to enhance solution diversity and convergence stability.", "configspace": "", "generation": 30, "fitness": 0.3281419352568924, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.20.", "error": "", "parent_id": "e52996f0-ab0e-4257-aa10-26e72b7a4ffe", "metadata": {"aucs": [0.4839835789668727, 0.5029002385007879, 0.44449207452046746, 0.53084235089218, 0.4289188791201477, 0.4282206498599972, 0.49840904539881326, 0.5474371056056342, 0.5225955598385083, 0.3389325029836725, 0.3363428774407502, 0.32087882889139374, 0.35568696856103366, 0.3049366247859606, 0.3937139122130723, 0.36865935322930155, 0.3561424771262738, 0.36596579068861956, 0.13334188196258168, 0.1688399822270059, 0.14601746877303745, 0.1455444772567389, 0.3597405702700417, 0.12947659784873744, 0.16404370158148862, 0.14943261368116767, 0.13435636398007267, 0.1264795028383764, 0.12993578231669545, 0.15737160850269416, 0.10695837762234528, 0.11741025005082761, 0.1385735736473538, 0.16382792941162116, 0.13870880507571548, 0.14249694581354766, 0.846261418710645, 0.8873689250847024, 0.917097023242121, 0.9756760631660589, 0.9540851278944535, 0.9390555195616939, 0.9738097338493318, 0.9727931151435046, 0.9599460045947447, 0.3269688029214328, 0.36585198733701707, 0.29156654178334784, 0.3453634584969554, 0.3110588297239095, 0.320685259925929, 0.3579232128354005, 0.33565146333775997, 0.2936293140753422, 0.7849462628489294, 0.7589853193025019, 0.7430794721043432, 0.765249823050244, 0.7633665221914736, 0.7722964694684591, 0.7382477568024708, 0.36220855860246426, 0.7781177664846235, 0.29165427291172663, 0.28440251849028075, 0.36443361854053324, 0.29542257706879094, 0.29803277085388513, 0.2978946427808912, 0.31839418235151395, 0.285979205929877, 0.4103283872402468, 0.3283422010068642, 0.46138671093375916, 0.39884725115474884, 0.29537499459060335, 0.29436488447431686, 0.33673595734460593, 0.27377829730432346, 0.4027379916570437, 0.2765810938254588, 0.3174481020521357, 0.29135684213908253, 0.15197622505461694, 0.3320304808810597, 0.2971839351672475, 0.15157400289988288, 0.32156674856382883, 0.2935761747544573, 0.21114231040996878, 0.41295120421520803, 0.3661827230901292, 0.34398724942384296, 0.35093798683374944, 0.3686799166822837, 0.32354416325958946, 0.42012347241405146, 0.37026683512365766, 0.36062277504330575, 0.19965024913880647, 0.2044025715284492, 0.1587308725417157, 0.22534910584570045, 0.23265013324600525, 0.2242680253536128, 0.1783449602379118, 0.2295586017633554, 0.1410539246306144, 0.26187791690679285, 0.28537854286216147, 0.2713712372301822, 0.2715427522568662, 0.25822172014861444, 0.28109585718248686, 0.2629121147587914, 0.32291258893735375, 0.30259286195126756, 0.4424838362378173, 0.447709594267498, 0.43459757292561385, 0.4479996585817928, 0.48935860691651045, 0.40446043301175505, 0.41750388785324144, 0.4811487186020542, 0.4318103697540804, 0.14634327644373424, 0.15163825032470957, 0.15038325244170025, 0.11137095130978292, 0.13025137960134703, 0.1507913744152034, 0.1455161800951239, 0.10916214298852955, 0.10906747205690659, 0.34963281511683686, 0.21850457245438504, 0.3909056534408246, 0.4481326489983065, 0.23692002875580287, 0.4270526141588128, 0.2300904244131149, 0.2875280020801748, 0.22211429312485342, 0.35141588153229864, 0.3339681780786874, 0.4237509525242731, 0.350507424080889, 0.3535569321818445, 0.34355035047004034, 0.35848463281035103, 0.3409608443578267, 0.336331470890167, 0.31397798867704374, 0.2822296591428314, 0.3450469990913585, 0.3149448934968814, 0.3203290478692524, 0.32563191837663485, 0.3393854382922936, 0.3256650435557844, 0.32655902218638544, 0.1942652501779929, 0.20167140290158792, 0.21591784386723734, 0.19967755756300698, 0.20043466783681096, 0.1996651428118148, 0.19375929395857128, 0.19873372698506975, 0.24280595489333445, 0.2101621722475735, 0.2338220819932707, 0.23278122391409406, 0.2087794556310365, 0.20876557779438643, 0.23705689082391745, 0.23434997752032105, 0.20324943604054624, 0.18497938911447076, 0.16796009204192563, 0.5832577218652562, 0.15254327351980934, 0.18159204745711655, 0.5815743728792518, 0.19495884915643735, 0.18509053545621323, 0.6364815142716764, 0.6502636873015597, 0.5764611077488019, 0.48798331361918224, 0.15199816667289234, 0.203386963250906, 0.5335988859914538, 0.20315083132386202, 0.20690060755977824, 0.5428151624593767, 0.20482631863604372, 0.17407561479187894, 0.2009813661210389, 0.19462589700452215, 0.1957509665898276, 0.1839789739029708, 0.18151315091830178, 0.1793283974286256, 0.18566559930149928, 0.187304169305741, 0.08435359571920176, 0.08501958976615642, 0.09968029659511757, 0.09015217140293263, 0.11275237407040173, 0.08665749537097467, 0.08508056202671921, 0.08918138952531685, 0.08339947336393505]}, "mutation_prompt": null}
{"id": "55096e65-6df4-44c6-8305-18e369929d31", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.25)  # Changed line: Increase CR increment from 0.2 to 0.25\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, self.population_size // 2)\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Improve solution selection by slightly increasing the decrement of mutation factor upon unsuccessful trials.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e52996f0-ab0e-4257-aa10-26e72b7a4ffe", "metadata": {"aucs": [0.4839835789668727, 0.5029002385007879, 0.44449207452046746, 0.53084235089218, 0.4289188791201477, 0.4282206498599972, 0.49840904539881326, 0.5474371056056342, 0.5225955598385083, 0.3389325029836725, 0.3363428774407502, 0.32087882889139374, 0.35568696856103366, 0.3049366247859606, 0.3937139122130723, 0.36865935322930155, 0.3561424771262738, 0.36596579068861956, 0.13334188196258168, 0.1688399822270059, 0.14601746877303745, 0.1455444772567389, 0.3597405702700417, 0.12947659784873744, 0.16404370158148862, 0.14943261368116767, 0.13435636398007267, 0.1264795028383764, 0.12993578231669545, 0.15737160850269416, 0.10695837762234528, 0.11741025005082761, 0.1385735736473538, 0.16382792941162116, 0.13870880507571548, 0.14249694581354766, 0.846261418710645, 0.8873689250847024, 0.917097023242121, 0.9756760631660589, 0.9540851278944535, 0.9390555195616939, 0.9738097338493318, 0.9727931151435046, 0.9599460045947447, 0.3269688029214328, 0.36585198733701707, 0.29156654178334784, 0.3453634584969554, 0.3110588297239095, 0.320685259925929, 0.3579232128354005, 0.33565146333775997, 0.2936293140753422, 0.7849462628489294, 0.7589853193025019, 0.7430794721043432, 0.765249823050244, 0.7633665221914736, 0.7722964694684591, 0.7382477568024708, 0.36220855860246426, 0.7781177664846235, 0.29165427291172663, 0.28440251849028075, 0.36443361854053324, 0.29542257706879094, 0.29803277085388513, 0.2978946427808912, 0.31839418235151395, 0.285979205929877, 0.4103283872402468, 0.3283422010068642, 0.46138671093375916, 0.39884725115474884, 0.29537499459060335, 0.29436488447431686, 0.33673595734460593, 0.27377829730432346, 0.4027379916570437, 0.2765810938254588, 0.3174481020521357, 0.29135684213908253, 0.15197622505461694, 0.3320304808810597, 0.2971839351672475, 0.15157400289988288, 0.32156674856382883, 0.2935761747544573, 0.21114231040996878, 0.41295120421520803, 0.3661827230901292, 0.34398724942384296, 0.35093798683374944, 0.3686799166822837, 0.32354416325958946, 0.42012347241405146, 0.37026683512365766, 0.36062277504330575, 0.19965024913880647, 0.2044025715284492, 0.1587308725417157, 0.22534910584570045, 0.23265013324600525, 0.2242680253536128, 0.1783449602379118, 0.2295586017633554, 0.1410539246306144, 0.26187791690679285, 0.28537854286216147, 0.2713712372301822, 0.2715427522568662, 0.25822172014861444, 0.28109585718248686, 0.2629121147587914, 0.32291258893735375, 0.30259286195126756, 0.4424838362378173, 0.447709594267498, 0.43459757292561385, 0.4479996585817928, 0.48935860691651045, 0.40446043301175505, 0.41750388785324144, 0.4811487186020542, 0.4318103697540804, 0.14634327644373424, 0.15163825032470957, 0.15038325244170025, 0.11137095130978292, 0.13025137960134703, 0.1507913744152034, 0.1455161800951239, 0.10916214298852955, 0.10906747205690659, 0.34963281511683686, 0.21850457245438504, 0.3909056534408246, 0.4481326489983065, 0.23692002875580287, 0.4270526141588128, 0.2300904244131149, 0.2875280020801748, 0.22211429312485342, 0.35141588153229864, 0.3339681780786874, 0.4237509525242731, 0.350507424080889, 0.3535569321818445, 0.34355035047004034, 0.35848463281035103, 0.3409608443578267, 0.336331470890167, 0.31397798867704374, 0.2822296591428314, 0.3450469990913585, 0.3149448934968814, 0.3203290478692524, 0.32563191837663485, 0.3393854382922936, 0.3256650435557844, 0.32655902218638544, 0.1942652501779929, 0.20167140290158792, 0.21591784386723734, 0.19967755756300698, 0.20043466783681096, 0.1996651428118148, 0.19375929395857128, 0.19873372698506975, 0.24280595489333445, 0.2101621722475735, 0.2338220819932707, 0.23278122391409406, 0.2087794556310365, 0.20876557779438643, 0.23705689082391745, 0.23434997752032105, 0.20324943604054624, 0.18497938911447076, 0.16796009204192563, 0.5832577218652562, 0.15254327351980934, 0.18159204745711655, 0.5815743728792518, 0.19495884915643735, 0.18509053545621323, 0.6364815142716764, 0.6502636873015597, 0.5764611077488019, 0.48798331361918224, 0.15199816667289234, 0.203386963250906, 0.5335988859914538, 0.20315083132386202, 0.20690060755977824, 0.5428151624593767, 0.20482631863604372, 0.17407561479187894, 0.2009813661210389, 0.19462589700452215, 0.1957509665898276, 0.1839789739029708, 0.18151315091830178, 0.1793283974286256, 0.18566559930149928, 0.187304169305741, 0.08435359571920176, 0.08501958976615642, 0.09968029659511757, 0.09015217140293263, 0.11275237407040173, 0.08665749537097467, 0.08508056202671921, 0.08918138952531685, 0.08339947336393505]}, "mutation_prompt": null}
{"id": "9b5f4d45-f92b-4c92-9ab7-648a6bdc9ea8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.25)  # Changed line: Increase CR increment from 0.2 to 0.25\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, self.population_size // 2)\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Improve solution selection by slightly increasing the decrement of mutation factor upon unsuccessful trials.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e52996f0-ab0e-4257-aa10-26e72b7a4ffe", "metadata": {"aucs": [0.4839835789668727, 0.5029002385007879, 0.44449207452046746, 0.53084235089218, 0.4289188791201477, 0.4282206498599972, 0.49840904539881326, 0.5474371056056342, 0.5225955598385083, 0.3389325029836725, 0.3363428774407502, 0.32087882889139374, 0.35568696856103366, 0.3049366247859606, 0.3937139122130723, 0.36865935322930155, 0.3561424771262738, 0.36596579068861956, 0.13334188196258168, 0.1688399822270059, 0.14601746877303745, 0.1455444772567389, 0.3597405702700417, 0.12947659784873744, 0.16404370158148862, 0.14943261368116767, 0.13435636398007267, 0.1264795028383764, 0.12993578231669545, 0.15737160850269416, 0.10695837762234528, 0.11741025005082761, 0.1385735736473538, 0.16382792941162116, 0.13870880507571548, 0.14249694581354766, 0.846261418710645, 0.8873689250847024, 0.917097023242121, 0.9756760631660589, 0.9540851278944535, 0.9390555195616939, 0.9738097338493318, 0.9727931151435046, 0.9599460045947447, 0.3269688029214328, 0.36585198733701707, 0.29156654178334784, 0.3453634584969554, 0.3110588297239095, 0.320685259925929, 0.3579232128354005, 0.33565146333775997, 0.2936293140753422, 0.7849462628489294, 0.7589853193025019, 0.7430794721043432, 0.765249823050244, 0.7633665221914736, 0.7722964694684591, 0.7382477568024708, 0.36220855860246426, 0.7781177664846235, 0.29165427291172663, 0.28440251849028075, 0.36443361854053324, 0.29542257706879094, 0.29803277085388513, 0.2978946427808912, 0.31839418235151395, 0.285979205929877, 0.4103283872402468, 0.3283422010068642, 0.46138671093375916, 0.39884725115474884, 0.29537499459060335, 0.29436488447431686, 0.33673595734460593, 0.27377829730432346, 0.4027379916570437, 0.2765810938254588, 0.3174481020521357, 0.29135684213908253, 0.15197622505461694, 0.3320304808810597, 0.2971839351672475, 0.15157400289988288, 0.32156674856382883, 0.2935761747544573, 0.21114231040996878, 0.41295120421520803, 0.3661827230901292, 0.34398724942384296, 0.35093798683374944, 0.3686799166822837, 0.32354416325958946, 0.42012347241405146, 0.37026683512365766, 0.36062277504330575, 0.19965024913880647, 0.2044025715284492, 0.1587308725417157, 0.22534910584570045, 0.23265013324600525, 0.2242680253536128, 0.1783449602379118, 0.2295586017633554, 0.1410539246306144, 0.26187791690679285, 0.28537854286216147, 0.2713712372301822, 0.2715427522568662, 0.25822172014861444, 0.28109585718248686, 0.2629121147587914, 0.32291258893735375, 0.30259286195126756, 0.4424838362378173, 0.447709594267498, 0.43459757292561385, 0.4479996585817928, 0.48935860691651045, 0.40446043301175505, 0.41750388785324144, 0.4811487186020542, 0.4318103697540804, 0.14634327644373424, 0.15163825032470957, 0.15038325244170025, 0.11137095130978292, 0.13025137960134703, 0.1507913744152034, 0.1455161800951239, 0.10916214298852955, 0.10906747205690659, 0.34963281511683686, 0.21850457245438504, 0.3909056534408246, 0.4481326489983065, 0.23692002875580287, 0.4270526141588128, 0.2300904244131149, 0.2875280020801748, 0.22211429312485342, 0.35141588153229864, 0.3339681780786874, 0.4237509525242731, 0.350507424080889, 0.3535569321818445, 0.34355035047004034, 0.35848463281035103, 0.3409608443578267, 0.336331470890167, 0.31397798867704374, 0.2822296591428314, 0.3450469990913585, 0.3149448934968814, 0.3203290478692524, 0.32563191837663485, 0.3393854382922936, 0.3256650435557844, 0.32655902218638544, 0.1942652501779929, 0.20167140290158792, 0.21591784386723734, 0.19967755756300698, 0.20043466783681096, 0.1996651428118148, 0.19375929395857128, 0.19873372698506975, 0.24280595489333445, 0.2101621722475735, 0.2338220819932707, 0.23278122391409406, 0.2087794556310365, 0.20876557779438643, 0.23705689082391745, 0.23434997752032105, 0.20324943604054624, 0.18497938911447076, 0.16796009204192563, 0.5832577218652562, 0.15254327351980934, 0.18159204745711655, 0.5815743728792518, 0.19495884915643735, 0.18509053545621323, 0.6364815142716764, 0.6502636873015597, 0.5764611077488019, 0.48798331361918224, 0.15199816667289234, 0.203386963250906, 0.5335988859914538, 0.20315083132386202, 0.20690060755977824, 0.5428151624593767, 0.20482631863604372, 0.17407561479187894, 0.2009813661210389, 0.19462589700452215, 0.1957509665898276, 0.1839789739029708, 0.18151315091830178, 0.1793283974286256, 0.18566559930149928, 0.187304169305741, 0.08435359571920176, 0.08501958976615642, 0.09968029659511757, 0.09015217140293263, 0.11275237407040173, 0.08665749537097467, 0.08508056202671921, 0.08918138952531685, 0.08339947336393505]}, "mutation_prompt": null}
{"id": "8bb9937f-b27b-46f9-a5f9-09566421bf7c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.25)  # Changed line: Increase CR increment from 0.2 to 0.25\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n            \n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, self.population_size // 2)\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n                self.CR = min(1.0, self.CR + 0.05)  # Changed line: Introduce a small increase in CR\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a small increase in CR when the fitness variance is low to encourage exploration.", "configspace": "", "generation": 33, "fitness": 0.32236792420126714, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.19.", "error": "", "parent_id": "e52996f0-ab0e-4257-aa10-26e72b7a4ffe", "metadata": {"aucs": [0.45203746461248473, 0.481129659276075, 0.5170061617643404, 0.5001878914235622, 0.41924337039063564, 0.42904155935150345, 0.4973511774580358, 0.4930482697570887, 0.4694856128609798, 0.3382301032421883, 0.33181461269985635, 0.31898221301850394, 0.32908283559173, 0.3049366247859606, 0.3440009350887445, 0.37377036976316846, 0.33518514060111326, 0.3264841823510327, 0.13334130394651056, 0.16882227051015997, 0.14600188502260203, 0.14554025463486286, 0.3397361427360983, 0.12947249144189588, 0.16402345775654248, 0.14941779883592377, 0.13435510160877462, 0.1264790353763119, 0.12993017241047378, 0.15736359219087648, 0.10695727394044696, 0.11740309611861499, 0.13858120925563377, 0.16380672262534013, 0.13871047012340953, 0.14249562613341604, 0.846261418710645, 0.8873689250847024, 0.917097023242121, 0.9756760631660589, 0.9540851278944535, 0.9390555195616939, 0.9738097338493318, 0.9727931151435046, 0.9599460045947447, 0.3111616270487404, 0.3195124414209175, 0.2916390195670834, 0.3214814693558954, 0.3051865547396292, 0.30815198994135073, 0.3554794798273734, 0.3295606001979484, 0.28492576835328043, 0.7849462628489294, 0.7589853193025019, 0.7433726362881098, 0.765249823050244, 0.7633665221914736, 0.7722964694684591, 0.7382477568024708, 0.36220855860246426, 0.7781177664846235, 0.3352239230794307, 0.30537008649059627, 0.3402248598403501, 0.2926883898092064, 0.29471917108594914, 0.27341328365488093, 0.3169131409717656, 0.28076549568243314, 0.3711535317371787, 0.33047287844308637, 0.3999675777924202, 0.36560730013926845, 0.2868703380598838, 0.28434831633514046, 0.3235814024248491, 0.2731401548622362, 0.36847542781692666, 0.2701655643775599, 0.32812016498884367, 0.2926269017873928, 0.15197622505461694, 0.3429282540629015, 0.30471814485685844, 0.15157400289988288, 0.31238174554550846, 0.29306004997219326, 0.21114231040996878, 0.41245123906744996, 0.3652034537673764, 0.34312338639518014, 0.3530875909382645, 0.3529114383142543, 0.32304287909422946, 0.41278894919119935, 0.37026683512365766, 0.36218057947481397, 0.1994302747859148, 0.20372761247874027, 0.15856071027650398, 0.2169281904599637, 0.23738370619574767, 0.22415052239215105, 0.18177377140553874, 0.23728070850665095, 0.1410539246306144, 0.2658543731031936, 0.24635110565824292, 0.25569035731582246, 0.2706993337557243, 0.2541886104105864, 0.26692849980490063, 0.2418936139689245, 0.3107388354535192, 0.2954839952097932, 0.4234633804793926, 0.4047273469355558, 0.4500173961210334, 0.44118164060247, 0.4201873796098142, 0.4200804304291823, 0.4219866133194812, 0.49731487463131885, 0.4261659216035525, 0.14634703960104856, 0.15163825032470957, 0.15038569632670518, 0.11137095130978292, 0.13024936466230497, 0.15079166105716502, 0.14550404735339328, 0.1091608356688274, 0.10906858474641157, 0.34214117308743075, 0.21835831690437946, 0.3799644970599646, 0.39489140673961387, 0.23677267212335118, 0.3815708595886642, 0.23002067002579452, 0.2871161152888225, 0.22195744298652664, 0.35147383607230176, 0.33309472390443184, 0.4143781451735562, 0.3474249694049062, 0.3535569321818445, 0.33961165003073035, 0.35848463281035103, 0.3377197971680205, 0.3358871466153719, 0.30649603851970064, 0.2808238423256263, 0.34407620074912515, 0.3149448934968814, 0.3203290478692524, 0.3194048561521484, 0.3301977018244642, 0.33250654287535486, 0.3279526155327507, 0.1942652501779929, 0.20167140290158792, 0.21591784386723734, 0.19967755756300698, 0.20043466783681096, 0.1996651428118148, 0.19375929395857128, 0.19873372698506975, 0.24280595489333445, 0.21014249376243077, 0.23357121822269367, 0.2328332271763247, 0.2087279094896719, 0.20874616132238388, 0.23699018607771327, 0.23434734045158145, 0.20324717246597923, 0.1848735608032347, 0.16794815886932923, 0.518160689636312, 0.15254270151749894, 0.18157621598773133, 0.5815743728792518, 0.19495136387255318, 0.1850799945573457, 0.6083746571906825, 0.6099346240723595, 0.5365704278993639, 0.5450042640454311, 0.1519950176123952, 0.20335640171882696, 0.47638704673034604, 0.203121222111195, 0.20689709873153572, 0.43422958149060575, 0.20482502318824336, 0.17407561479187894, 0.2009813661210389, 0.19462589700452215, 0.1957509665898276, 0.1839789739029708, 0.18151315091830178, 0.1793283974286256, 0.18566559930149928, 0.187304169305741, 0.08435359571920176, 0.08501958976615642, 0.09967960848725088, 0.09015161742727196, 0.11274482144657727, 0.08665749537097467, 0.08508056202671921, 0.08918138952531685, 0.08339947336393505]}, "mutation_prompt": null}
{"id": "307c9c6c-d781-4319-8ebb-09d831b3f493", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.25)  # Changed line: Increase CR increment from 0.2 to 0.25\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, self.population_size // 2)\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Improve solution selection by slightly increasing the decrement of mutation factor upon unsuccessful trials.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e52996f0-ab0e-4257-aa10-26e72b7a4ffe", "metadata": {"aucs": [0.4839835789668727, 0.5029002385007879, 0.44449207452046746, 0.53084235089218, 0.4289188791201477, 0.4282206498599972, 0.49840904539881326, 0.5474371056056342, 0.5225955598385083, 0.3389325029836725, 0.3363428774407502, 0.32087882889139374, 0.35568696856103366, 0.3049366247859606, 0.3937139122130723, 0.36865935322930155, 0.3561424771262738, 0.36596579068861956, 0.13334188196258168, 0.1688399822270059, 0.14601746877303745, 0.1455444772567389, 0.3597405702700417, 0.12947659784873744, 0.16404370158148862, 0.14943261368116767, 0.13435636398007267, 0.1264795028383764, 0.12993578231669545, 0.15737160850269416, 0.10695837762234528, 0.11741025005082761, 0.1385735736473538, 0.16382792941162116, 0.13870880507571548, 0.14249694581354766, 0.846261418710645, 0.8873689250847024, 0.917097023242121, 0.9756760631660589, 0.9540851278944535, 0.9390555195616939, 0.9738097338493318, 0.9727931151435046, 0.9599460045947447, 0.3269688029214328, 0.36585198733701707, 0.29156654178334784, 0.3453634584969554, 0.3110588297239095, 0.320685259925929, 0.3579232128354005, 0.33565146333775997, 0.2936293140753422, 0.7849462628489294, 0.7589853193025019, 0.7430794721043432, 0.765249823050244, 0.7633665221914736, 0.7722964694684591, 0.7382477568024708, 0.36220855860246426, 0.7781177664846235, 0.29165427291172663, 0.28440251849028075, 0.36443361854053324, 0.29542257706879094, 0.29803277085388513, 0.2978946427808912, 0.31839418235151395, 0.285979205929877, 0.4103283872402468, 0.3283422010068642, 0.46138671093375916, 0.39884725115474884, 0.29537499459060335, 0.29436488447431686, 0.33673595734460593, 0.27377829730432346, 0.4027379916570437, 0.2765810938254588, 0.3174481020521357, 0.29135684213908253, 0.15197622505461694, 0.3320304808810597, 0.2971839351672475, 0.15157400289988288, 0.32156674856382883, 0.2935761747544573, 0.21114231040996878, 0.41295120421520803, 0.3661827230901292, 0.34398724942384296, 0.35093798683374944, 0.3686799166822837, 0.32354416325958946, 0.42012347241405146, 0.37026683512365766, 0.36062277504330575, 0.19965024913880647, 0.2044025715284492, 0.1587308725417157, 0.22534910584570045, 0.23265013324600525, 0.2242680253536128, 0.1783449602379118, 0.2295586017633554, 0.1410539246306144, 0.26187791690679285, 0.28537854286216147, 0.2713712372301822, 0.2715427522568662, 0.25822172014861444, 0.28109585718248686, 0.2629121147587914, 0.32291258893735375, 0.30259286195126756, 0.4424838362378173, 0.447709594267498, 0.43459757292561385, 0.4479996585817928, 0.48935860691651045, 0.40446043301175505, 0.41750388785324144, 0.4811487186020542, 0.4318103697540804, 0.14634327644373424, 0.15163825032470957, 0.15038325244170025, 0.11137095130978292, 0.13025137960134703, 0.1507913744152034, 0.1455161800951239, 0.10916214298852955, 0.10906747205690659, 0.34963281511683686, 0.21850457245438504, 0.3909056534408246, 0.4481326489983065, 0.23692002875580287, 0.4270526141588128, 0.2300904244131149, 0.2875280020801748, 0.22211429312485342, 0.35141588153229864, 0.3339681780786874, 0.4237509525242731, 0.350507424080889, 0.3535569321818445, 0.34355035047004034, 0.35848463281035103, 0.3409608443578267, 0.336331470890167, 0.31397798867704374, 0.2822296591428314, 0.3450469990913585, 0.3149448934968814, 0.3203290478692524, 0.32563191837663485, 0.3393854382922936, 0.3256650435557844, 0.32655902218638544, 0.1942652501779929, 0.20167140290158792, 0.21591784386723734, 0.19967755756300698, 0.20043466783681096, 0.1996651428118148, 0.19375929395857128, 0.19873372698506975, 0.24280595489333445, 0.2101621722475735, 0.2338220819932707, 0.23278122391409406, 0.2087794556310365, 0.20876557779438643, 0.23705689082391745, 0.23434997752032105, 0.20324943604054624, 0.18497938911447076, 0.16796009204192563, 0.5832577218652562, 0.15254327351980934, 0.18159204745711655, 0.5815743728792518, 0.19495884915643735, 0.18509053545621323, 0.6364815142716764, 0.6502636873015597, 0.5764611077488019, 0.48798331361918224, 0.15199816667289234, 0.203386963250906, 0.5335988859914538, 0.20315083132386202, 0.20690060755977824, 0.5428151624593767, 0.20482631863604372, 0.17407561479187894, 0.2009813661210389, 0.19462589700452215, 0.1957509665898276, 0.1839789739029708, 0.18151315091830178, 0.1793283974286256, 0.18566559930149928, 0.187304169305741, 0.08435359571920176, 0.08501958976615642, 0.09968029659511757, 0.09015217140293263, 0.11275237407040173, 0.08665749537097467, 0.08508056202671921, 0.08918138952531685, 0.08339947336393505]}, "mutation_prompt": null}
{"id": "1589b4ca-189d-49e7-94b6-143a7127b2c1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.25)  # Changed line: Increase CR increment from 0.2 to 0.25\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, self.population_size // 2)\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Improve solution selection by slightly increasing the decrement of mutation factor upon unsuccessful trials.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e52996f0-ab0e-4257-aa10-26e72b7a4ffe", "metadata": {"aucs": [0.4839835789668727, 0.5029002385007879, 0.44449207452046746, 0.53084235089218, 0.4289188791201477, 0.4282206498599972, 0.49840904539881326, 0.5474371056056342, 0.5225955598385083, 0.3389325029836725, 0.3363428774407502, 0.32087882889139374, 0.35568696856103366, 0.3049366247859606, 0.3937139122130723, 0.36865935322930155, 0.3561424771262738, 0.36596579068861956, 0.13334188196258168, 0.1688399822270059, 0.14601746877303745, 0.1455444772567389, 0.3597405702700417, 0.12947659784873744, 0.16404370158148862, 0.14943261368116767, 0.13435636398007267, 0.1264795028383764, 0.12993578231669545, 0.15737160850269416, 0.10695837762234528, 0.11741025005082761, 0.1385735736473538, 0.16382792941162116, 0.13870880507571548, 0.14249694581354766, 0.846261418710645, 0.8873689250847024, 0.917097023242121, 0.9756760631660589, 0.9540851278944535, 0.9390555195616939, 0.9738097338493318, 0.9727931151435046, 0.9599460045947447, 0.3269688029214328, 0.36585198733701707, 0.29156654178334784, 0.3453634584969554, 0.3110588297239095, 0.320685259925929, 0.3579232128354005, 0.33565146333775997, 0.2936293140753422, 0.7849462628489294, 0.7589853193025019, 0.7430794721043432, 0.765249823050244, 0.7633665221914736, 0.7722964694684591, 0.7382477568024708, 0.36220855860246426, 0.7781177664846235, 0.29165427291172663, 0.28440251849028075, 0.36443361854053324, 0.29542257706879094, 0.29803277085388513, 0.2978946427808912, 0.31839418235151395, 0.285979205929877, 0.4103283872402468, 0.3283422010068642, 0.46138671093375916, 0.39884725115474884, 0.29537499459060335, 0.29436488447431686, 0.33673595734460593, 0.27377829730432346, 0.4027379916570437, 0.2765810938254588, 0.3174481020521357, 0.29135684213908253, 0.15197622505461694, 0.3320304808810597, 0.2971839351672475, 0.15157400289988288, 0.32156674856382883, 0.2935761747544573, 0.21114231040996878, 0.41295120421520803, 0.3661827230901292, 0.34398724942384296, 0.35093798683374944, 0.3686799166822837, 0.32354416325958946, 0.42012347241405146, 0.37026683512365766, 0.36062277504330575, 0.19965024913880647, 0.2044025715284492, 0.1587308725417157, 0.22534910584570045, 0.23265013324600525, 0.2242680253536128, 0.1783449602379118, 0.2295586017633554, 0.1410539246306144, 0.26187791690679285, 0.28537854286216147, 0.2713712372301822, 0.2715427522568662, 0.25822172014861444, 0.28109585718248686, 0.2629121147587914, 0.32291258893735375, 0.30259286195126756, 0.4424838362378173, 0.447709594267498, 0.43459757292561385, 0.4479996585817928, 0.48935860691651045, 0.40446043301175505, 0.41750388785324144, 0.4811487186020542, 0.4318103697540804, 0.14634327644373424, 0.15163825032470957, 0.15038325244170025, 0.11137095130978292, 0.13025137960134703, 0.1507913744152034, 0.1455161800951239, 0.10916214298852955, 0.10906747205690659, 0.34963281511683686, 0.21850457245438504, 0.3909056534408246, 0.4481326489983065, 0.23692002875580287, 0.4270526141588128, 0.2300904244131149, 0.2875280020801748, 0.22211429312485342, 0.35141588153229864, 0.3339681780786874, 0.4237509525242731, 0.350507424080889, 0.3535569321818445, 0.34355035047004034, 0.35848463281035103, 0.3409608443578267, 0.336331470890167, 0.31397798867704374, 0.2822296591428314, 0.3450469990913585, 0.3149448934968814, 0.3203290478692524, 0.32563191837663485, 0.3393854382922936, 0.3256650435557844, 0.32655902218638544, 0.1942652501779929, 0.20167140290158792, 0.21591784386723734, 0.19967755756300698, 0.20043466783681096, 0.1996651428118148, 0.19375929395857128, 0.19873372698506975, 0.24280595489333445, 0.2101621722475735, 0.2338220819932707, 0.23278122391409406, 0.2087794556310365, 0.20876557779438643, 0.23705689082391745, 0.23434997752032105, 0.20324943604054624, 0.18497938911447076, 0.16796009204192563, 0.5832577218652562, 0.15254327351980934, 0.18159204745711655, 0.5815743728792518, 0.19495884915643735, 0.18509053545621323, 0.6364815142716764, 0.6502636873015597, 0.5764611077488019, 0.48798331361918224, 0.15199816667289234, 0.203386963250906, 0.5335988859914538, 0.20315083132386202, 0.20690060755977824, 0.5428151624593767, 0.20482631863604372, 0.17407561479187894, 0.2009813661210389, 0.19462589700452215, 0.1957509665898276, 0.1839789739029708, 0.18151315091830178, 0.1793283974286256, 0.18566559930149928, 0.187304169305741, 0.08435359571920176, 0.08501958976615642, 0.09968029659511757, 0.09015217140293263, 0.11275237407040173, 0.08665749537097467, 0.08508056202671921, 0.08918138952531685, 0.08339947336393505]}, "mutation_prompt": null}
{"id": "db31e1ac-1b1b-406d-bbed-0ddb212c8461", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.25)  # Changed line: Increase CR increment from 0.2 to 0.25\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance solution quality by introducing an adaptive population resizing strategy when solution diversity is low.", "configspace": "", "generation": 36, "fitness": 0.3339634636292147, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.20.", "error": "", "parent_id": "e52996f0-ab0e-4257-aa10-26e72b7a4ffe", "metadata": {"aucs": [0.5082626459156885, 0.4920345562584, 0.5973222835891654, 0.48470382515330046, 0.5472992351351778, 0.5016151083134475, 0.4304986637524647, 0.5337841530254885, 0.5921069944119618, 0.34660415199807537, 0.5027939978393365, 0.33865598168284716, 0.37362876025031233, 0.32297092959071483, 0.3473968736346369, 0.3924867600445937, 0.33199892438454004, 0.38386278792317974, 0.13333490376144674, 0.16885383827538425, 0.14602061079335404, 0.14554451822667414, 0.3439497881137342, 0.12947646946337776, 0.16406649623125924, 0.14943322267409898, 0.13435634859779455, 0.1264879735140002, 0.1299327942021764, 0.15736359219087648, 0.10695807349286957, 0.11740384031761497, 0.13857586923982357, 0.1638309734468223, 0.13872803591498906, 0.14249868864036164, 0.846261418710645, 0.8873689250847024, 0.917097023242121, 0.9756760631660589, 0.9540851278944535, 0.9390555195616939, 0.9738097338493318, 0.9727931151435046, 0.9599460045947447, 0.3313958783189579, 0.3207619732836239, 0.303375354082306, 0.36106633299617796, 0.3241239060265163, 0.3704630882032294, 0.3796279857932652, 0.3352771044512939, 0.3018462110423543, 0.7849462628489294, 0.7612719999358808, 0.7437244333086297, 0.765249823050244, 0.7633665221914736, 0.7722964694684591, 0.3584181246481907, 0.742326727396178, 0.7781177664846235, 0.33942195955741905, 0.29601414148403415, 0.3393305392595781, 0.3290061817586293, 0.311684040999062, 0.2668971483570298, 0.2797949452097993, 0.3067969728209936, 0.41035133393358925, 0.32205970602718303, 0.41696438853413764, 0.4167411344705523, 0.29880378748236625, 0.29496293075246993, 0.3383101677956998, 0.2963240213401356, 0.31850714785690803, 0.30783709465371456, 0.36896124421325627, 0.3073672078817373, 0.15197622505461694, 0.32197063877207266, 0.3312710617449224, 0.15157400289988288, 0.29748548117470086, 0.3138774880243671, 0.21114231040996878, 0.4449704820374121, 0.39527378380841516, 0.3484481211289113, 0.37821140556714394, 0.39673004477360263, 0.31724319630388487, 0.35741812038021537, 0.39238112864163355, 0.3939717519965472, 0.20808012203010517, 0.20050262677830555, 0.15846578606848594, 0.20717344894561918, 0.23352745818162868, 0.25273981580168914, 0.18076749590827335, 0.22909216283078615, 0.1410539246306144, 0.27428780464625113, 0.2447000886560311, 0.27297489637656136, 0.2646175387614348, 0.2655610435100896, 0.28188081747565064, 0.2607173527634544, 0.2754651277369442, 0.27754493128989965, 0.41989675069105736, 0.46476190686234375, 0.4402300244479461, 0.5138197318661115, 0.4689631431413983, 0.4221065409019542, 0.4750535413898458, 0.418673647317619, 0.4377658697202802, 0.14635120884166586, 0.1516575013853051, 0.1503857841396974, 0.11137458450451299, 0.13025096682024395, 0.15077625957690488, 0.14551733352676677, 0.10916169798552944, 0.10906821627412899, 0.3718121200148353, 0.21902443285888717, 0.39511236608425115, 0.3486455057847625, 0.23636283721442553, 0.3738477685342919, 0.23020608542723742, 0.2849291680954029, 0.22151715467368271, 0.34904673791159346, 0.3335901108046505, 0.3903649380517148, 0.34612252196368953, 0.3756484647966901, 0.3590455996002917, 0.35848463281035103, 0.3411935007025023, 0.34457140490333926, 0.3138903058207445, 0.2844762983102992, 0.3552578944884496, 0.32371303376472016, 0.339991757301624, 0.32771398792578854, 0.3335482000199239, 0.3448256182148052, 0.33925630257116346, 0.1942652501779929, 0.20167140290158792, 0.21591784386723734, 0.19967755756300698, 0.20043466783681096, 0.1996651428118148, 0.19375929395857128, 0.19873372698506975, 0.24280595489333445, 0.21015361780374897, 0.2338578239097865, 0.2328811269913702, 0.2087532459388195, 0.2087220617716885, 0.23699270430888686, 0.23424571391918003, 0.2032457324051552, 0.18492349300643973, 0.16805393147972025, 0.6664374682208554, 0.15254155529978852, 0.1815957419684464, 0.6208750073576663, 0.19496431634948963, 0.1850879836438476, 0.6664148429311703, 0.8123514147566231, 0.7456911041130164, 0.47780876165850483, 0.1520012317187842, 0.20338512160953437, 0.6072291214339395, 0.2031453724049549, 0.20688139186729138, 0.5907685611407758, 0.20482615310133478, 0.17407561479187894, 0.2009813661210389, 0.19462589700452215, 0.1957509665898276, 0.1839789739029708, 0.18151315091830178, 0.1793283974286256, 0.18566559930149928, 0.187304169305741, 0.08435359571920176, 0.08501958976615642, 0.09967907676339705, 0.09015205403383719, 0.11275652755075971, 0.08665749537097467, 0.08508056202671921, 0.08918138952531685, 0.08339947336393505]}, "mutation_prompt": null}
{"id": "f4f26033-1ae6-47aa-be6c-9c43aabe0e41", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.75  # Changed line: Increased mutation factor from 0.7 to 0.75\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.25)  # Changed line: Increase CR increment from 0.2 to 0.25\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a more aggressive mutation strategy by slightly increasing the mutation factor to enhance exploration.", "configspace": "", "generation": 37, "fitness": 0.32535327543991305, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.20.", "error": "", "parent_id": "db31e1ac-1b1b-406d-bbed-0ddb212c8461", "metadata": {"aucs": [0.6669379972937078, 0.4741731739271866, 0.42198198944201526, 0.4780950135421954, 0.4535102262517017, 0.4583079286412539, 0.4991451906102209, 0.4308596243791779, 0.5065314863659979, 0.322152040976208, 0.33630102788795724, 0.3156006660578051, 0.39625480800325397, 0.35789259917022564, 0.31182939787282926, 0.31994639357946575, 0.37651619467879993, 0.36183874777708147, 0.16817776046640975, 0.16915730173814592, 0.13219653086121763, 0.12761452679277208, 0.3290695385387977, 0.1424295996828827, 0.14316988963790278, 0.3822299852777533, 0.13275713417129842, 0.1575938273317291, 0.10077766723903847, 0.11676518412609005, 0.14099414657457343, 0.13949759543910967, 0.12867704505866118, 0.10182201650683687, 0.1434320403921483, 0.12937161936196517, 0.9837806391379715, 0.9148378645193795, 0.9017299928554701, 0.976247448132809, 0.9508439986202519, 0.8607026804433595, 0.9737644183567754, 0.9727931151435046, 0.9672810216870356, 0.4079423778249497, 0.32718734386858417, 0.3235974517383099, 0.3234646795961371, 0.32468118039391036, 0.34374819098386067, 0.3157985658878084, 0.33518058642773907, 0.34303404195212894, 0.785035575170251, 0.7978442081722888, 0.35406977057057076, 0.7626654273156561, 0.7686794928146636, 0.781571461347139, 0.7422291213891323, 0.7658583606990417, 0.7711718034697339, 0.286145070271855, 0.2932078175819154, 0.33715449088060223, 0.4115987137030849, 0.3162499626435249, 0.3469836512264921, 0.31908091274962813, 0.32776679476167647, 0.3252058753203776, 0.3468305296974138, 0.12181542339101581, 0.41583187260807164, 0.3735219842781691, 0.2979670117306906, 0.31140705552192227, 0.33644968306852363, 0.29276644775166405, 0.35409101726733305, 0.16669644900612168, 0.3185065447024559, 0.31505635701548695, 0.3725913187150117, 0.037011824102824, 0.33284624922012096, 0.3424902754581808, 0.33928124372789037, 0.3519602295293667, 0.4006839603616229, 0.40484253113286084, 0.40116965939593574, 0.4045211455347191, 0.3731383435327379, 0.45934484225190364, 0.3691327587437975, 0.3705160235298678, 0.4063890236077038, 0.20396005116080873, 0.20732713398130753, 0.22112855250716412, 0.22601582277802357, 0.3116379445510614, 0.22456157698723223, 0.21380566901623232, 0.16757236234632178, 0.17816110155559106, 0.27160331035749896, 0.3014404610543352, 0.257806436540417, 0.25335920340779416, 0.23564622753549025, 0.2580038793662556, 0.2630543967078245, 0.26269244946231673, 0.26239803494143477, 0.42099092746105393, 0.44938390188554045, 0.4324900350071813, 0.4200096872196095, 0.4722864273049441, 0.3962563602097785, 0.4824405715557235, 0.42681730364377024, 0.43507928067225443, 0.1362671179919649, 0.12854047547721925, 0.1354839754018714, 0.16395017848623994, 0.12392728611548665, 0.1493585605354374, 0.13104339975091517, 0.11706837973560646, 0.12560486032844254, 0.25122322246326545, 0.16172004652807814, 0.18357742394511856, 0.2563772417204353, 0.30979614566691394, 0.17442516616932058, 0.16869125615564773, 0.39260585472961107, 0.19845336486916199, 0.3450164240611002, 0.34434665371048856, 0.39622661034561857, 0.352499335565707, 0.3692163638884679, 0.36750707719022213, 0.3643842962762248, 0.3428543590066282, 0.3378911781688575, 0.32851444795678586, 0.3274562343246644, 0.34497539583539105, 0.34436330661358494, 0.3114713586950053, 0.32326036935158997, 0.3387958906138563, 0.32530229592180726, 0.3339251487839475, 0.19179656773207776, 0.22451354887418973, 0.2118922075260149, 0.18018561719067216, 0.21084953460169886, 0.1836436343297494, 0.21999930928089617, 0.21373510855745548, 0.20347671620415275, 0.23022167740255506, 0.2317401254271112, 0.19010386266659163, 0.2298082258698635, 0.23621946058287957, 0.21182902323575248, 0.44061648555809185, 0.19233706684998608, 0.18310782379220092, 0.15946041463223248, 0.18110934419681202, 0.16383950713394557, 0.19358289669583795, 0.1686831007894367, 0.19298666282839438, 0.7951815392636871, 0.6111494052148567, 0.18365783975658145, 0.5799464490695394, 0.20484062995811791, 0.15207720013808268, 0.6607300095647254, 0.603446877096555, 0.16555631223260048, 0.207392505515975, 0.1480529638458511, 0.20440983332617735, 0.18334436453937675, 0.18756673708324256, 0.17611596132276353, 0.1821629512231867, 0.18218345855243157, 0.1777663401973847, 0.19493358884946987, 0.2097517192138335, 0.18672708483640776, 0.10507764731378788, 0.08727859607239807, 0.10559342262049465, 0.08822188310940005, 0.09257668008823816, 0.0882035569627535, 0.09171940140749535, 0.09169060583343214, 0.09156236906067283]}, "mutation_prompt": null}
{"id": "f087e429-dc04-4bf5-8ff5-76add6096104", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.25)  # Changed line: Increase CR increment from 0.2 to 0.25\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance solution quality by introducing an adaptive population resizing strategy when solution diversity is low.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "db31e1ac-1b1b-406d-bbed-0ddb212c8461", "metadata": {"aucs": [0.5082626459156885, 0.4920345562584, 0.5973222835891654, 0.48470382515330046, 0.5472992351351778, 0.5016151083134475, 0.4304986637524647, 0.5337841530254885, 0.5921069944119618, 0.34660415199807537, 0.5027939978393365, 0.33865598168284716, 0.37362876025031233, 0.32297092959071483, 0.3473968736346369, 0.3924867600445937, 0.33199892438454004, 0.38386278792317974, 0.13333490376144674, 0.16885383827538425, 0.14602061079335404, 0.14554451822667414, 0.3439497881137342, 0.12947646946337776, 0.16406649623125924, 0.14943322267409898, 0.13435634859779455, 0.1264879735140002, 0.1299327942021764, 0.15736359219087648, 0.10695807349286957, 0.11740384031761497, 0.13857586923982357, 0.1638309734468223, 0.13872803591498906, 0.14249868864036164, 0.846261418710645, 0.8873689250847024, 0.917097023242121, 0.9756760631660589, 0.9540851278944535, 0.9390555195616939, 0.9738097338493318, 0.9727931151435046, 0.9599460045947447, 0.3313958783189579, 0.3207619732836239, 0.303375354082306, 0.36106633299617796, 0.3241239060265163, 0.3704630882032294, 0.3796279857932652, 0.3352771044512939, 0.3018462110423543, 0.7849462628489294, 0.7612719999358808, 0.7437244333086297, 0.765249823050244, 0.7633665221914736, 0.7722964694684591, 0.3584181246481907, 0.742326727396178, 0.7781177664846235, 0.33942195955741905, 0.29601414148403415, 0.3393305392595781, 0.3290061817586293, 0.311684040999062, 0.2668971483570298, 0.2797949452097993, 0.3067969728209936, 0.41035133393358925, 0.32205970602718303, 0.41696438853413764, 0.4167411344705523, 0.29880378748236625, 0.29496293075246993, 0.3383101677956998, 0.2963240213401356, 0.31850714785690803, 0.30783709465371456, 0.36896124421325627, 0.3073672078817373, 0.15197622505461694, 0.32197063877207266, 0.3312710617449224, 0.15157400289988288, 0.29748548117470086, 0.3138774880243671, 0.21114231040996878, 0.4449704820374121, 0.39527378380841516, 0.3484481211289113, 0.37821140556714394, 0.39673004477360263, 0.31724319630388487, 0.35741812038021537, 0.39238112864163355, 0.3939717519965472, 0.20808012203010517, 0.20050262677830555, 0.15846578606848594, 0.20717344894561918, 0.23352745818162868, 0.25273981580168914, 0.18076749590827335, 0.22909216283078615, 0.1410539246306144, 0.27428780464625113, 0.2447000886560311, 0.27297489637656136, 0.2646175387614348, 0.2655610435100896, 0.28188081747565064, 0.2607173527634544, 0.2754651277369442, 0.27754493128989965, 0.41989675069105736, 0.46476190686234375, 0.4402300244479461, 0.5138197318661115, 0.4689631431413983, 0.4221065409019542, 0.4750535413898458, 0.418673647317619, 0.4377658697202802, 0.14635120884166586, 0.1516575013853051, 0.1503857841396974, 0.11137458450451299, 0.13025096682024395, 0.15077625957690488, 0.14551733352676677, 0.10916169798552944, 0.10906821627412899, 0.3718121200148353, 0.21902443285888717, 0.39511236608425115, 0.3486455057847625, 0.23636283721442553, 0.3738477685342919, 0.23020608542723742, 0.2849291680954029, 0.22151715467368271, 0.34904673791159346, 0.3335901108046505, 0.3903649380517148, 0.34612252196368953, 0.3756484647966901, 0.3590455996002917, 0.35848463281035103, 0.3411935007025023, 0.34457140490333926, 0.3138903058207445, 0.2844762983102992, 0.3552578944884496, 0.32371303376472016, 0.339991757301624, 0.32771398792578854, 0.3335482000199239, 0.3448256182148052, 0.33925630257116346, 0.1942652501779929, 0.20167140290158792, 0.21591784386723734, 0.19967755756300698, 0.20043466783681096, 0.1996651428118148, 0.19375929395857128, 0.19873372698506975, 0.24280595489333445, 0.21015361780374897, 0.2338578239097865, 0.2328811269913702, 0.2087532459388195, 0.2087220617716885, 0.23699270430888686, 0.23424571391918003, 0.2032457324051552, 0.18492349300643973, 0.16805393147972025, 0.6664374682208554, 0.15254155529978852, 0.1815957419684464, 0.6208750073576663, 0.19496431634948963, 0.1850879836438476, 0.6664148429311703, 0.8123514147566231, 0.7456911041130164, 0.47780876165850483, 0.1520012317187842, 0.20338512160953437, 0.6072291214339395, 0.2031453724049549, 0.20688139186729138, 0.5907685611407758, 0.20482615310133478, 0.17407561479187894, 0.2009813661210389, 0.19462589700452215, 0.1957509665898276, 0.1839789739029708, 0.18151315091830178, 0.1793283974286256, 0.18566559930149928, 0.187304169305741, 0.08435359571920176, 0.08501958976615642, 0.09967907676339705, 0.09015205403383719, 0.11275652755075971, 0.08665749537097467, 0.08508056202671921, 0.08918138952531685, 0.08339947336393505]}, "mutation_prompt": null}
{"id": "517118b7-985e-4f68-98a6-5b152f9e2900", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.25)  # Changed line: Increase CR increment from 0.2 to 0.25\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration by slightly increasing the mutation factor's upper bound during unsuccessful iterations.", "configspace": "", "generation": 39, "fitness": 0.3339634636292147, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.20.", "error": "", "parent_id": "db31e1ac-1b1b-406d-bbed-0ddb212c8461", "metadata": {"aucs": [0.5082626459156885, 0.4920345562584, 0.5973222835891654, 0.48470382515330046, 0.5472992351351778, 0.5016151083134475, 0.4304986637524647, 0.5337841530254885, 0.5921069944119618, 0.34660415199807537, 0.5027939978393365, 0.33865598168284716, 0.37362876025031233, 0.32297092959071483, 0.3473968736346369, 0.3924867600445937, 0.33199892438454004, 0.38386278792317974, 0.13333490376144674, 0.16885383827538425, 0.14602061079335404, 0.14554451822667414, 0.3439497881137342, 0.12947646946337776, 0.16406649623125924, 0.14943322267409898, 0.13435634859779455, 0.1264879735140002, 0.1299327942021764, 0.15736359219087648, 0.10695807349286957, 0.11740384031761497, 0.13857586923982357, 0.1638309734468223, 0.13872803591498906, 0.14249868864036164, 0.846261418710645, 0.8873689250847024, 0.917097023242121, 0.9756760631660589, 0.9540851278944535, 0.9390555195616939, 0.9738097338493318, 0.9727931151435046, 0.9599460045947447, 0.3313958783189579, 0.3207619732836239, 0.303375354082306, 0.36106633299617796, 0.3241239060265163, 0.3704630882032294, 0.3796279857932652, 0.3352771044512939, 0.3018462110423543, 0.7849462628489294, 0.7612719999358808, 0.7437244333086297, 0.765249823050244, 0.7633665221914736, 0.7722964694684591, 0.3584181246481907, 0.742326727396178, 0.7781177664846235, 0.33942195955741905, 0.29601414148403415, 0.3393305392595781, 0.3290061817586293, 0.311684040999062, 0.2668971483570298, 0.2797949452097993, 0.3067969728209936, 0.41035133393358925, 0.32205970602718303, 0.41696438853413764, 0.4167411344705523, 0.29880378748236625, 0.29496293075246993, 0.3383101677956998, 0.2963240213401356, 0.31850714785690803, 0.30783709465371456, 0.36896124421325627, 0.3073672078817373, 0.15197622505461694, 0.32197063877207266, 0.3312710617449224, 0.15157400289988288, 0.29748548117470086, 0.3138774880243671, 0.21114231040996878, 0.4449704820374121, 0.39527378380841516, 0.3484481211289113, 0.37821140556714394, 0.39673004477360263, 0.31724319630388487, 0.35741812038021537, 0.39238112864163355, 0.3939717519965472, 0.20808012203010517, 0.20050262677830555, 0.15846578606848594, 0.20717344894561918, 0.23352745818162868, 0.25273981580168914, 0.18076749590827335, 0.22909216283078615, 0.1410539246306144, 0.27428780464625113, 0.2447000886560311, 0.27297489637656136, 0.2646175387614348, 0.2655610435100896, 0.28188081747565064, 0.2607173527634544, 0.2754651277369442, 0.27754493128989965, 0.41989675069105736, 0.46476190686234375, 0.4402300244479461, 0.5138197318661115, 0.4689631431413983, 0.4221065409019542, 0.4750535413898458, 0.418673647317619, 0.4377658697202802, 0.14635120884166586, 0.1516575013853051, 0.1503857841396974, 0.11137458450451299, 0.13025096682024395, 0.15077625957690488, 0.14551733352676677, 0.10916169798552944, 0.10906821627412899, 0.3718121200148353, 0.21902443285888717, 0.39511236608425115, 0.3486455057847625, 0.23636283721442553, 0.3738477685342919, 0.23020608542723742, 0.2849291680954029, 0.22151715467368271, 0.34904673791159346, 0.3335901108046505, 0.3903649380517148, 0.34612252196368953, 0.3756484647966901, 0.3590455996002917, 0.35848463281035103, 0.3411935007025023, 0.34457140490333926, 0.3138903058207445, 0.2844762983102992, 0.3552578944884496, 0.32371303376472016, 0.339991757301624, 0.32771398792578854, 0.3335482000199239, 0.3448256182148052, 0.33925630257116346, 0.1942652501779929, 0.20167140290158792, 0.21591784386723734, 0.19967755756300698, 0.20043466783681096, 0.1996651428118148, 0.19375929395857128, 0.19873372698506975, 0.24280595489333445, 0.21015361780374897, 0.2338578239097865, 0.2328811269913702, 0.2087532459388195, 0.2087220617716885, 0.23699270430888686, 0.23424571391918003, 0.2032457324051552, 0.18492349300643973, 0.16805393147972025, 0.6664374682208554, 0.15254155529978852, 0.1815957419684464, 0.6208750073576663, 0.19496431634948963, 0.1850879836438476, 0.6664148429311703, 0.8123514147566231, 0.7456911041130164, 0.47780876165850483, 0.1520012317187842, 0.20338512160953437, 0.6072291214339395, 0.2031453724049549, 0.20688139186729138, 0.5907685611407758, 0.20482615310133478, 0.17407561479187894, 0.2009813661210389, 0.19462589700452215, 0.1957509665898276, 0.1839789739029708, 0.18151315091830178, 0.1793283974286256, 0.18566559930149928, 0.187304169305741, 0.08435359571920176, 0.08501958976615642, 0.09967907676339705, 0.09015205403383719, 0.11275652755075971, 0.08665749537097467, 0.08508056202671921, 0.08918138952531685, 0.08339947336393505]}, "mutation_prompt": null}
{"id": "eef12c57-aac4-403c-82f2-f082b50e3d50", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + np.random.uniform(0.5, 1.0) * (b - c), -5, 5)  # Changed line: Stochastic scaling to F\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.25)\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce stochastic scaling to mutation factor to enhance exploration and prevent premature convergence.", "configspace": "", "generation": 40, "fitness": 0.25184363580568786, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.18.", "error": "", "parent_id": "db31e1ac-1b1b-406d-bbed-0ddb212c8461", "metadata": {"aucs": [0.4511330416084942, 0.43897591786453116, 0.4297799109770989, 0.45634528157619003, 0.44591044438491256, 0.45539604050631133, 0.5328769879340257, 0.45702608417216395, 0.4801767668691651, 0.32372845203770073, 0.35156569888820766, 0.33825194149641447, 0.31966024829320094, 0.435877687594569, 0.3481701975365462, 0.3156868998715189, 0.32861978369296396, 0.33805991903477517, 0.1143507140959571, 0.11899715740187256, 0.12253566097574642, 0.12215129444903705, 0.11659523052732734, 0.11555636812447978, 0.11499253174602564, 0.11345754545613385, 0.10990087424526518, 0.10190466148509736, 0.11167788636463516, 0.11656190932848642, 0.1114035767181909, 0.1079182671343839, 0.10379195163561394, 0.09355971869135626, 0.10812551217953514, 0.09575390530517158, 0.9365578730804137, 0.9149224547592923, 0.38402183423979497, 0.7807635738362326, 0.9224868294375054, 0.889813536776731, 0.3880676562191956, 0.8255553346033095, 0.3301333301878837, 0.29348375196499255, 0.2870539905384819, 0.29820904944205673, 0.30046503565706983, 0.28872578499907864, 0.3357472049465551, 0.3036399467503137, 0.31061855687132267, 0.31487439358395963, 0.6728874164959233, 0.6143185564932985, 0.618603870721733, 0.7266369717391002, 0.6927116695538704, 0.6637867861487413, 0.6762471627741113, 0.6933184341359178, 0.6765297186160104, 0.2939916267569733, 0.25194679522263697, 0.2449631277582971, 0.2972171007473394, 0.2523310093773493, 0.23199969778137852, 0.29918521762309525, 0.23372443251731678, 0.24939436571687768, 0.05183968941758088, 0.20805228769401451, 0.021741593575697493, 0.3085077170254453, 0.2873104138017196, 0.2848240535251152, 0.28211963334613854, 0.2508810922510638, 0.2898578187309434, 0.05483331898186283, 0.058318154746016426, 0.06489233852667842, 0.001270299858909807, 0.09862591292141243, 0.0801685593486362, 0.004253978173259787, 0.02514591992738424, 9.999999999998899e-05, 0.12809886649188285, 0.0746894383716874, 0.061552510273703454, 0.22613801404094291, 0.07863005047423888, 0.07188248474238912, 0.2940357202247075, 0.22236665281753976, 0.3403396904165594, 0.02526537772302051, 9.999999999998899e-05, 0.018644969640674747, 9.999999999998899e-05, 0.005912452173042371, 0.00942852286788165, 0.01664546401946687, 0.02220805677643989, 0.029270055644589732, 0.18540250374882306, 0.19696301146139783, 0.20157554043740777, 0.23009158078760505, 0.23209975866762467, 0.2570768818963053, 0.14989984234886655, 0.17080548276121987, 0.23621417051706772, 0.454621109713675, 0.41833226805301116, 0.4094758715479877, 0.3968336206359523, 0.42776156354947437, 0.4085966486440078, 0.4130218390809274, 0.4102890441226016, 0.40281447726604713, 0.10613194368931234, 0.09450470063999872, 0.11562227083061294, 0.10358575781190194, 0.09469097135176785, 0.09942204843972502, 0.08855908372562116, 0.10971023063984708, 0.09392727477201801, 0.17726766226320456, 0.13671611342299217, 0.13580356413324912, 0.16387755034374785, 0.17872289466890356, 0.13724698248128975, 0.1529248624188949, 0.181983468442665, 0.15285034158180244, 0.3312415465359382, 0.3123877146661711, 0.3135643975186778, 0.3327133201114574, 0.28737944665937976, 0.2970865602280691, 0.3258616497581541, 0.3553798179441333, 0.33419983508942996, 0.21107625926823692, 0.22065155759956911, 0.21778974405454532, 0.209947764231873, 0.24805208697632974, 0.21264525956014935, 0.2501186847979071, 0.2693437198340274, 0.2700840545469776, 0.1863468650964042, 0.18540938552148445, 0.19137207504919218, 0.1978358103215071, 0.18225373303200954, 0.18070967648643377, 0.19216289502890893, 0.1914909619985249, 0.1914361093045993, 0.20583202325440042, 0.1934921436669782, 0.19378811432129572, 0.19172282959777287, 0.1842741093775787, 0.21425806301366834, 0.19788212788563186, 0.20539328906728138, 0.20007433019271825, 0.4793451724252681, 0.6610024700808935, 0.16909959072678427, 0.3849713605528339, 0.17914643075940362, 0.40296862973967695, 0.16155836952835712, 0.18447822459636476, 0.20956673348904764, 0.19428602446408705, 0.2029686108336951, 0.3102214166812385, 0.3634731642746527, 0.2338181136726406, 0.18273055988746223, 0.19957705514297364, 0.19548263619587303, 0.20439484443360756, 0.18303284492978134, 0.1724351520470706, 0.20457285994737473, 0.18082180388400992, 0.1871402343599443, 0.17437690980647313, 0.1874764659837117, 0.18769066415552904, 0.18440059500967043, 0.07884341390996452, 0.07873200530815971, 0.08221603760783724, 0.0770414220367347, 0.06850221170166348, 0.06916478571463847, 0.0711764678177973, 0.06720522657471717, 0.0741646504257617]}, "mutation_prompt": null}
{"id": "1a6a3914-0be3-4f92-9428-f858796413cb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.15)  # Changed line: Increase maximum F increment from 0.1 to 0.15\n                    self.CR = min(1.0, self.CR + 0.25)  # Changed line: Increase CR increment from 0.2 to 0.25\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Improve exploration by slightly increasing the range of the mutation factor adaptation.", "configspace": "", "generation": 41, "fitness": 0.31399249559568104, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.20.", "error": "", "parent_id": "db31e1ac-1b1b-406d-bbed-0ddb212c8461", "metadata": {"aucs": [0.41572093246439523, 0.5394213666285722, 0.4549025045546544, 0.5346138918345851, 0.42581272656089164, 0.5792347481667407, 0.5775943582307766, 0.47854003483766183, 0.5404367654721691, 0.34843774129514427, 0.29379250645591526, 0.29121841927905145, 0.34307584132718727, 0.2914912333088606, 0.2847498792490467, 0.33335294475545885, 0.2905233152478881, 0.29782965411505735, 0.27386948819196166, 0.14569658979051614, 0.12670406354410568, 0.16109876004753643, 0.34592576882141335, 0.15683594346416374, 0.34110371881312507, 0.33221127316517374, 0.33300131210487427, 0.12412336992816542, 0.13868040348447686, 0.10854854777138045, 0.12805725124953027, 0.14644471550984473, 0.12191615463012617, 0.1503169831307648, 0.14301725009775146, 0.12708030025974437, 0.953261517113702, 0.9294118003913778, 0.9555974080173695, 0.98676811799101, 0.9541933524186859, 0.9244524615334262, 0.9738097338493318, 0.9727931151435046, 0.9672113195659523, 0.2882942987290129, 0.3109555664709672, 0.3001508846407763, 0.3119164799388412, 0.28610889178956045, 0.30878616180495133, 0.30898413646161016, 0.3320327241177834, 0.3171510832677761, 0.7383775788631921, 0.7296413254922465, 0.7115176651300419, 0.7204979647756986, 0.7017454746460259, 0.7182725403707202, 0.689320866063819, 0.7076391346577657, 0.7334895060839189, 0.2728162038108506, 0.2637750528024271, 0.29910109985804634, 0.2977611242561711, 0.11023797193231089, 0.24387628402329475, 0.3310026955169475, 0.2718940009442794, 0.2640177375153073, 0.4181308504601198, 0.3061060654611134, 0.34101307239041667, 0.25720473335530647, 0.26246427603489086, 0.30361126566616237, 0.2640946543985224, 0.24403853261105357, 0.28912285225561973, 0.2721003262850491, 0.27517094101173845, 0.2936450393634037, 0.2224717490909982, 0.2828972068813367, 0.27729355853579685, 0.2786555884012727, 0.27723916536332904, 0.27408953441150685, 0.09371229617579424, 0.11946675340417656, 0.38321326388612076, 0.19298767927065186, 0.16905455061738628, 0.3801493319469361, 0.3667836910204276, 0.3856440495448902, 0.381790592391386, 0.07988224915946707, 0.10521356435964646, 0.15893124810005088, 0.1193985097908219, 0.13190898424870212, 0.1858875865595928, 0.13869938098618018, 0.1662034425856309, 0.10524254141598177, 0.20986142226953175, 0.20445676560121706, 0.20782012578281428, 0.2104273931870172, 0.21548361477991962, 0.22594297317907874, 0.22222554485891843, 0.21801484148731565, 0.2253030602856393, 0.4376745730679523, 0.4354191519995616, 0.394858724060526, 0.46481004454236774, 0.3850126280292592, 0.3821125951364709, 0.42800545342719776, 0.39296808604933053, 0.45807586988334514, 0.1300735728566912, 0.16516655031917638, 0.1619957738485699, 0.1299869080742363, 0.13896873501730533, 0.11223305484347745, 0.14121343663555086, 0.12904272331710887, 0.12123691851431118, 0.36178036521374024, 0.19541268024278657, 0.3721006911722733, 0.37439953267540216, 0.19235958812408926, 0.334022188957376, 0.3015120254817444, 0.3001076997932407, 0.3921532531812568, 0.33686275669709453, 0.3229148579252614, 0.33277972818297663, 0.33672368396554153, 0.3437125581582705, 0.32477937475388985, 0.3334792283240635, 0.36265738647612056, 0.32907699485456643, 0.29007187681144786, 0.30443858045253724, 0.2861826057245148, 0.2790959894615723, 0.29159036184300735, 0.30492996899867264, 0.3068344374498623, 0.3144198171060466, 0.29922656535654646, 0.18554353769499754, 0.18090454659397315, 0.2127537233277722, 0.19139684166691484, 0.19219236266990325, 0.19211470366454397, 0.20061173652012798, 0.18102732124026877, 0.21170228568503546, 0.20563146460126613, 0.20767459502812502, 0.1978191269981623, 0.18899920313474206, 0.20812137385542506, 0.21793970126500217, 0.1992036157854442, 0.3619069315640697, 0.4164838664996863, 0.15259457937514165, 0.16666340781210087, 0.19188469039292322, 0.7477013256441271, 0.19061025938255283, 0.18887207833630515, 0.20041015164579445, 0.6441035422201575, 0.7512147854543088, 0.46781130847139496, 0.20202257033417714, 0.1988003567401435, 0.1973390390569485, 0.19975379074568977, 0.5819633790116743, 0.2067734222107298, 0.752201494358468, 0.20487794877559506, 0.17960496409431814, 0.19121312640888066, 0.1869822755042978, 0.1806743934292615, 0.187502512012247, 0.17799416349537678, 0.186248802760416, 0.17666452134812194, 0.17801756746906927, 0.08637076359369344, 0.09077144987583274, 0.08916871274255822, 0.09110975290056544, 0.08635615066916047, 0.09339696134375697, 0.08274224839957645, 0.0853517701178842, 0.08680534108170668]}, "mutation_prompt": null}
{"id": "6d1753dd-92ab-427e-af08-ffd57b4dafe9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.25)  # Changed line: Increase CR increment from 0.2 to 0.25\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.5))  # Changed line: More aggressive reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a more aggressive population size reduction strategy by adjusting the reduction factor, promoting faster convergence.", "configspace": "", "generation": 42, "fitness": 0.3281419352568924, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.20.", "error": "", "parent_id": "db31e1ac-1b1b-406d-bbed-0ddb212c8461", "metadata": {"aucs": [0.4839835789668727, 0.5029002385007879, 0.44449207452046746, 0.53084235089218, 0.4289188791201477, 0.4282206498599972, 0.49840904539881326, 0.5474371056056342, 0.5225955598385083, 0.3389325029836725, 0.3363428774407502, 0.32087882889139374, 0.35568696856103366, 0.3049366247859606, 0.3937139122130723, 0.36865935322930155, 0.3561424771262738, 0.36596579068861956, 0.13334188196258168, 0.1688399822270059, 0.14601746877303745, 0.1455444772567389, 0.3597405702700417, 0.12947659784873744, 0.16404370158148862, 0.14943261368116767, 0.13435636398007267, 0.1264795028383764, 0.12993578231669545, 0.15737160850269416, 0.10695837762234528, 0.11741025005082761, 0.1385735736473538, 0.16382792941162116, 0.13870880507571548, 0.14249694581354766, 0.846261418710645, 0.8873689250847024, 0.917097023242121, 0.9756760631660589, 0.9540851278944535, 0.9390555195616939, 0.9738097338493318, 0.9727931151435046, 0.9599460045947447, 0.3269688029214328, 0.36585198733701707, 0.29156654178334784, 0.3453634584969554, 0.3110588297239095, 0.320685259925929, 0.3579232128354005, 0.33565146333775997, 0.2936293140753422, 0.7849462628489294, 0.7589853193025019, 0.7430794721043432, 0.765249823050244, 0.7633665221914736, 0.7722964694684591, 0.7382477568024708, 0.36220855860246426, 0.7781177664846235, 0.29165427291172663, 0.28440251849028075, 0.36443361854053324, 0.29542257706879094, 0.29803277085388513, 0.2978946427808912, 0.31839418235151395, 0.285979205929877, 0.4103283872402468, 0.3283422010068642, 0.46138671093375916, 0.39884725115474884, 0.29537499459060335, 0.29436488447431686, 0.33673595734460593, 0.27377829730432346, 0.4027379916570437, 0.2765810938254588, 0.3174481020521357, 0.29135684213908253, 0.15197622505461694, 0.3320304808810597, 0.2971839351672475, 0.15157400289988288, 0.32156674856382883, 0.2935761747544573, 0.21114231040996878, 0.41295120421520803, 0.3661827230901292, 0.34398724942384296, 0.35093798683374944, 0.3686799166822837, 0.32354416325958946, 0.42012347241405146, 0.37026683512365766, 0.36062277504330575, 0.19965024913880647, 0.2044025715284492, 0.1587308725417157, 0.22534910584570045, 0.23265013324600525, 0.2242680253536128, 0.1783449602379118, 0.2295586017633554, 0.1410539246306144, 0.26187791690679285, 0.28537854286216147, 0.2713712372301822, 0.2715427522568662, 0.25822172014861444, 0.28109585718248686, 0.2629121147587914, 0.32291258893735375, 0.30259286195126756, 0.4424838362378173, 0.447709594267498, 0.43459757292561385, 0.4479996585817928, 0.48935860691651045, 0.40446043301175505, 0.41750388785324144, 0.4811487186020542, 0.4318103697540804, 0.14634327644373424, 0.15163825032470957, 0.15038325244170025, 0.11137095130978292, 0.13025137960134703, 0.1507913744152034, 0.1455161800951239, 0.10916214298852955, 0.10906747205690659, 0.34963281511683686, 0.21850457245438504, 0.3909056534408246, 0.4481326489983065, 0.23692002875580287, 0.4270526141588128, 0.2300904244131149, 0.2875280020801748, 0.22211429312485342, 0.35141588153229864, 0.3339681780786874, 0.4237509525242731, 0.350507424080889, 0.3535569321818445, 0.34355035047004034, 0.35848463281035103, 0.3409608443578267, 0.336331470890167, 0.31397798867704374, 0.2822296591428314, 0.3450469990913585, 0.3149448934968814, 0.3203290478692524, 0.32563191837663485, 0.3393854382922936, 0.3256650435557844, 0.32655902218638544, 0.1942652501779929, 0.20167140290158792, 0.21591784386723734, 0.19967755756300698, 0.20043466783681096, 0.1996651428118148, 0.19375929395857128, 0.19873372698506975, 0.24280595489333445, 0.2101621722475735, 0.2338220819932707, 0.23278122391409406, 0.2087794556310365, 0.20876557779438643, 0.23705689082391745, 0.23434997752032105, 0.20324943604054624, 0.18497938911447076, 0.16796009204192563, 0.5832577218652562, 0.15254327351980934, 0.18159204745711655, 0.5815743728792518, 0.19495884915643735, 0.18509053545621323, 0.6364815142716764, 0.6502636873015597, 0.5764611077488019, 0.48798331361918224, 0.15199816667289234, 0.203386963250906, 0.5335988859914538, 0.20315083132386202, 0.20690060755977824, 0.5428151624593767, 0.20482631863604372, 0.17407561479187894, 0.2009813661210389, 0.19462589700452215, 0.1957509665898276, 0.1839789739029708, 0.18151315091830178, 0.1793283974286256, 0.18566559930149928, 0.187304169305741, 0.08435359571920176, 0.08501958976615642, 0.09968029659511757, 0.09015217140293263, 0.11275237407040173, 0.08665749537097467, 0.08508056202671921, 0.08918138952531685, 0.08339947336393505]}, "mutation_prompt": null}
{"id": "ae36d822-c00b-457b-adb5-467bbe324326", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.25)  # Changed line: Increase CR increment from 0.2 to 0.25\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.025)  # Changed line: Adjust mutation factor decrement (from 0.03 to 0.025)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Improve exploration by reducing the mutation factor decrement slightly, fostering more diverse trials.", "configspace": "", "generation": 43, "fitness": 0.31937293282551477, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.20.", "error": "", "parent_id": "db31e1ac-1b1b-406d-bbed-0ddb212c8461", "metadata": {"aucs": [0.405944097189456, 0.4859498531513603, 0.4623672377691257, 0.5307499393146013, 0.5002687930210095, 0.5158021067045069, 0.4566911840150364, 0.5031552081861488, 0.4404084982548859, 0.28673410493090534, 0.3037803439872797, 0.41203913242085577, 0.29867709192567327, 0.31084860996572405, 0.31068398408179365, 0.34937966429317435, 0.34144502327240944, 0.3397781844910678, 0.14267060488264338, 0.16310142563701424, 0.14338956754206322, 0.14093889342483035, 0.13905860316302732, 0.13269958988357355, 0.13111170412690176, 0.1288237182405414, 0.11320365850366143, 0.10247242552531222, 0.1389223381225313, 0.13480224094181792, 0.13122199737250795, 0.12312455743824391, 0.12282543405119317, 0.15840214924525264, 0.11915240369799629, 0.14854051037517768, 0.9431838043092216, 0.9342332048104974, 0.9293351526705655, 0.9867682415168489, 0.9529298750914761, 0.9391677523725189, 0.973808682433698, 0.97293766039159, 0.9608886007002679, 0.29347771592434035, 0.3720046191656664, 0.30333471985062, 0.3087909351474276, 0.31455988934656065, 0.3639485672264635, 0.3202558592040211, 0.3223891215357393, 0.3374095020963599, 0.7262118511705953, 0.7371929409329456, 0.7189570853522164, 0.7272916257915271, 0.7180603784944364, 0.7234557841176932, 0.6947813245986786, 0.7352317899090197, 0.6944561916131347, 0.28418340281658827, 0.268161516459669, 0.3754720489455785, 0.2951632915688869, 0.36031109060322575, 0.2662553283052074, 0.27632734896253563, 0.25086762078320946, 0.2450988902648874, 0.24875788480683325, 0.33232878503017094, 0.05187216862584243, 0.3774308071504372, 0.27736519317471786, 0.2760530189207435, 0.3518221061518473, 0.34340274481031907, 0.3058929690743586, 0.3149620866082208, 0.30328506036108505, 0.32380755008133943, 0.29411007171542314, 0.3218779832650761, 0.3070192727529327, 0.3040855566039301, 0.2788383328311903, 0.23442342574559227, 0.39982606335169035, 0.31655748834961805, 0.3593664537368437, 0.3907254962758321, 0.4502893189950449, 0.39375708005096666, 0.372990714061476, 0.36631444045213024, 0.39490231747960947, 0.1608029536516299, 0.11567186786455863, 0.21936995891264388, 0.19861894209267283, 0.21536987662528218, 0.14457535554252277, 0.13892002810378234, 0.14280558761220585, 0.1241714030970894, 0.270106155164623, 0.2290519000410679, 0.22349010626826515, 0.23476083698578243, 0.22354467974105463, 0.24011219061536793, 0.2409153966932982, 0.2275592464949645, 0.24418465472104656, 0.4481785147499969, 0.44893466663248405, 0.42581819567757206, 0.4405786680506246, 0.4355340396222168, 0.4415098241479415, 0.4130635422911971, 0.39001656620611, 0.4522641656944596, 0.13457894322536867, 0.13309017938341516, 0.14855535708347012, 0.1443372510721107, 0.143701205842241, 0.13662967240564794, 0.17038673067387067, 0.13210094549613727, 0.16159444783303245, 0.18997266199615281, 0.22042777721935003, 0.17661621129545024, 0.40638133399175913, 0.33144238922170866, 0.2027768518321813, 0.39027875432866455, 0.29211439843569964, 0.24285012495486757, 0.3417179291978758, 0.3141334123813935, 0.34825315895096687, 0.3215052151916564, 0.3466284123280542, 0.3266811953038935, 0.35737218698202244, 0.36687824961122983, 0.3468347002143851, 0.31034150311757114, 0.31809748617082, 0.31996119666909195, 0.3130492388661995, 0.30668008619215703, 0.3227823437372277, 0.33708937543251827, 0.3411150120660822, 0.33307522952171464, 0.1878627205578457, 0.21435587227506736, 0.20028364401050602, 0.2186971967021646, 0.1999842448807071, 0.19968374935944755, 0.2151786499734042, 0.19860366748458536, 0.22180220174060783, 0.42188473115005387, 0.17545370018746564, 0.19631530217849502, 0.20681742063109243, 0.41418077546297116, 0.39905922235108415, 0.2107847336023685, 0.19192116221705657, 0.1985072457423085, 0.15245260854835074, 0.4857326051116051, 0.1528447537429869, 0.661480762305394, 0.1913605250958319, 0.6972250831393123, 0.18446359678127222, 0.7169891672422879, 0.20607668391978506, 0.6320037888788397, 0.20214692204552953, 0.5625881957387815, 0.20247782858997243, 0.20181911840345024, 0.16118215674427427, 0.2066836599410794, 0.20064226363791682, 0.20678426475545375, 0.1820952448294938, 0.19215426327647112, 0.18452247436304436, 0.188614659461803, 0.17495659426875987, 0.1818803810533287, 0.18297705830933952, 0.17845218138449614, 0.18835815516724397, 0.09913784999113195, 0.09916010246000917, 0.09599989209454429, 0.09020546128075035, 0.08777765825344963, 0.08838643406893265, 0.09641935873353868, 0.07981151286730459, 0.08922080769524132]}, "mutation_prompt": null}
{"id": "15194070-c3b9-4dce-b684-76a21c76d900", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.25)  # Changed line: Increase CR increment from 0.2 to 0.25\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.05)  # Changed line: Increase mutation factor decrement (from 0.03 to 0.05)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a more aggressive mutation factor decrement for unsuccessful trials to enhance convergence speed.", "configspace": "", "generation": 44, "fitness": 0.3330235833740626, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.20.", "error": "", "parent_id": "db31e1ac-1b1b-406d-bbed-0ddb212c8461", "metadata": {"aucs": [0.4366340467626513, 0.4845395639328488, 0.5061579074784038, 0.46819423093296086, 0.5228876253378735, 0.46993009152669707, 0.4867052108175428, 0.5199522418939198, 0.4854646833564076, 0.38141849174611275, 0.40254422854321714, 0.37724555908014545, 0.3751278387726994, 0.38959463517898096, 0.38686151419533765, 0.3498323818392117, 0.3854763979048734, 0.3917574990838675, 0.17880948338152824, 0.15043459680225246, 0.13472068415285865, 0.1265891355408315, 0.14060381635031882, 0.13928007283325972, 0.17892205342619583, 0.11183823875139298, 0.1377129079445364, 0.14845282692835504, 0.14821587283183113, 0.14955405983145886, 0.1103838680279341, 0.10651579221437202, 0.13185109039206422, 0.10516427518026505, 0.11747814599029427, 0.14515212478338158, 0.6762635050604091, 0.9299430977377103, 0.9305341653441805, 0.9570245188323433, 0.9493806641408827, 0.9370888510326205, 0.9738774597585489, 0.870099653740185, 0.9583379415405788, 0.3070235312224642, 0.3276758932147008, 0.363780622381054, 0.3362355474059615, 0.32519269042111687, 0.3131348803203765, 0.31646028342896926, 0.38218284650724266, 0.3371289309017381, 0.840105132343068, 0.35558578925192175, 0.2720673257495728, 0.8486364507325352, 0.2681803823434252, 0.8189551686376267, 0.8443412038811424, 0.8259762449031184, 0.8424345620244703, 0.3225764196373311, 0.2977280011251764, 0.39133384815972483, 0.3235584160503634, 0.28360051510814, 0.3068955576370235, 0.3530938887017905, 0.3449653964174285, 0.2374593626368552, 0.12551877021679958, 0.39548711709466033, 0.12800809367320676, 0.40923810623312395, 0.3140778841126668, 0.3530294930954021, 0.34859999763630334, 0.30397393912360815, 0.3440860070550802, 0.30999964843435257, 0.4033506668867115, 0.39273926884878874, 0.3616547171565472, 0.41774342548619325, 0.3266346634673225, 0.37424673610148596, 0.4178874302782175, 0.3622785386811981, 0.43457294756993015, 0.44719511170741255, 0.45708573638486805, 0.40569961050280234, 0.4003370807072919, 0.44786462247451253, 0.43108580195931934, 0.4533754978738004, 0.38532290453586315, 0.18027136076302708, 0.2729103144413835, 0.2058282283299584, 0.21113872168392678, 0.19177482639243082, 0.33424481339817236, 0.23599800138874494, 0.17359899199005924, 0.2672905299291335, 0.31509877686700605, 0.32219429474020167, 0.31959344194525907, 0.3010439014940627, 0.3247234092073238, 0.3358661479380671, 0.3083351660120597, 0.31983792019403434, 0.32065724432302, 0.4497223836787688, 0.48753203539607715, 0.4618013860580472, 0.4735848857806586, 0.4423961296133796, 0.47144162172163395, 0.451332786227839, 0.4662006656489127, 0.4867834855099197, 0.13800281868926634, 0.12706144680484854, 0.15114840413509523, 0.15476381976805353, 0.11952556637780565, 0.1058315790507246, 0.11222699386864443, 0.13455574825478744, 0.11922042635375785, 0.2388066675248024, 0.2669745218123539, 0.33350011890657427, 0.16485956466505447, 0.19953446891734106, 0.22607130138553555, 0.245753902717733, 0.2298158941282673, 0.21667033678596814, 0.4036412328197966, 0.36906792308570235, 0.31194075288531053, 0.2862263624937704, 0.20334850290678153, 0.3906785616075704, 0.35979628252943663, 0.40272246457447347, 0.267178712156945, 0.2561685740345565, 0.30393312639226056, 0.28629282290089875, 0.2638458967810864, 0.35463785020081817, 0.31640914976922463, 0.36055822809307314, 0.1972638046415255, 0.24165920665810003, 0.19505457144973115, 0.19179448714852032, 0.25032763744140374, 0.22939720700219124, 0.23102322758891647, 0.19162589982663392, 0.20131363384242462, 0.235605864461209, 0.21315052177086302, 0.20039644736636208, 0.22064308387034104, 0.20900441110028234, 0.1933700731071133, 0.2003286418633774, 0.2069058517489104, 0.1967997952680829, 0.198051347385521, 0.17823698151637468, 0.15365392344531137, 0.7495968807276472, 0.17040824024697687, 0.1752699142810883, 0.5762504738904981, 0.7309237593710689, 0.16544864715234686, 0.7836080489298902, 0.7315993489039543, 0.699574924690631, 0.20863645070769177, 0.7890413247830455, 0.5861002428173621, 0.20008038979745046, 0.15173164524167204, 0.15222901576597703, 0.15316797338981758, 0.20701748137712228, 0.18461096842134628, 0.20237148249623715, 0.1965502887127748, 0.18109173865172923, 0.19150619211942477, 0.1899799366168825, 0.17877141993807977, 0.2006845380590544, 0.17653476738128482, 0.08770230890986819, 0.10111750803226949, 0.1008483943463756, 0.08465930011708855, 0.11280174709802016, 0.10972910105976152, 0.09277904626859612, 0.08760694470578523, 0.13352969185794505]}, "mutation_prompt": null}
{"id": "64d840bf-6dba-4258-8b01-af452e28b857", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.25)  # Changed line: Increase CR increment from 0.2 to 0.25\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Implement a cooling schedule to gradually decrease the mutation factor F for improved convergence over iterations.", "configspace": "", "generation": 45, "fitness": 0.33677335921200036, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.21.", "error": "", "parent_id": "db31e1ac-1b1b-406d-bbed-0ddb212c8461", "metadata": {"aucs": [0.45423475525930346, 0.5927976667991433, 0.4478207448727176, 0.5050373065997071, 0.4702452101766964, 0.48600792933161463, 0.47076454557405456, 0.4628399370104399, 0.4853636663808768, 0.33726603660181886, 0.33018451317248687, 0.33396336625706047, 0.4425371291857788, 0.2974828313252138, 0.4141294753826936, 0.3730189407893012, 0.30813130854410864, 0.3461288969541044, 0.16435226662354596, 0.14282092076003772, 0.16319680057437091, 0.15001804002325136, 0.16518068159824884, 0.16693403115746752, 0.12401076282336476, 0.146640494718295, 0.14774949250498903, 0.13136299521680062, 0.12280573539651263, 0.11770517957994231, 0.1288080516214728, 0.11923445010365974, 0.1283607237455393, 0.1276834095249737, 0.13797157202185917, 0.14278382299360637, 0.9053192009470553, 0.8660483334673228, 0.9002098347817125, 0.975528753634753, 0.9498768151140763, 0.9445713831460156, 0.9738097338493318, 0.9546027307857413, 0.9514852738835676, 0.3378366540342965, 0.3130663362093764, 0.3216204505781177, 0.3572684762827889, 0.2847855736383835, 0.31689038997083163, 0.323797335449335, 0.31248482374204145, 0.3254843614410512, 0.7880249127743724, 0.7713646661446508, 0.7783392489367843, 0.781922848511541, 0.7876052042262797, 0.7608748436472922, 0.7765301524640645, 0.753840082182759, 0.7735915016132198, 0.3513540289877535, 0.3511431583817436, 0.3516358737271146, 0.32503692437897147, 0.2942853050383335, 0.29451520135981135, 0.2638751731166953, 0.2667503703925358, 0.38910760164481784, 0.33656152910046244, 0.021415486323483446, 0.372303148440586, 0.29153955165403256, 0.35758051996796225, 0.3383168630044149, 0.3112497595998619, 0.3264443288445539, 0.29640982305402563, 0.36588962087293875, 0.37516436571613976, 0.33201560699079147, 0.30943352556367365, 0.3327450463251007, 0.2997028325377187, 0.1391242689264065, 0.32194466356153517, 0.1483545351355391, 0.45240315623337923, 0.391995025679059, 0.4447609638044835, 0.3820254651906416, 0.3963726879422397, 0.3948852657264168, 0.38295553856407283, 0.42267364186519685, 0.4082174911438471, 0.18082875545614763, 0.2109551027866866, 0.2205809325499385, 0.11001031683602758, 0.25560786048665396, 0.24837400025029177, 0.21942997024606548, 0.20261893404103037, 0.12357702720461383, 0.23987267419518454, 0.24723294465067003, 0.28439960781731466, 0.2652380083281898, 0.2534639690956757, 0.2528464174959012, 0.27454483437409394, 0.2612543370059113, 0.2761475624756643, 0.3987109691348111, 0.4495602710821951, 0.4406913655622201, 0.6054232260012435, 0.47533578333452753, 0.4972684102428657, 0.4460480911527953, 0.3917005747927599, 0.397540183501946, 0.14677607089834532, 0.1367358116217935, 0.422478896035712, 0.12532546476573203, 0.1344847157120881, 0.1347318575860087, 0.10800363739350993, 0.13730443539785153, 0.13518870223482848, 0.2050279896955498, 0.4040796265231339, 0.32782962198705123, 0.3269608955603651, 0.30255814577067264, 0.444848699806772, 0.2296447471642451, 0.2732557627008909, 0.2466689090287728, 0.3460792704740334, 0.361252878730534, 0.3436855205734437, 0.32949183876596677, 0.3621127650035568, 0.36615005386039245, 0.3599892456795285, 0.3316229375803932, 0.36958342556268964, 0.30781149690747767, 0.33142653097099406, 0.34269916614612783, 0.29057010713019094, 0.3058052856572302, 0.332952085484867, 0.34173953289829684, 0.3342977578763938, 0.3359058879113027, 0.210382424524151, 0.21162320494434161, 0.20056311436274565, 0.2182678576315341, 0.18113146566323113, 0.19219138737727226, 0.2275732525654356, 0.1932620182214395, 0.21351789038557145, 0.431474548940182, 0.18464654569699734, 0.1907854365928764, 0.1907486642456907, 0.4720491401871061, 0.21291994520546587, 0.19953007914403353, 0.23165119402685008, 0.19911964117185255, 0.5777238853222668, 0.1819694298511585, 0.805284722941409, 0.1827188108192469, 0.6718231135370532, 0.5723426404916139, 0.16788922892198066, 0.6570687801071586, 0.6195585362245959, 0.5543602853678709, 0.5448715393087575, 0.15220068708900103, 0.6788195176683121, 0.16107315122358468, 0.20351384609295642, 0.20722171834060177, 0.15100718461893448, 0.20705058968235823, 0.183185971113362, 0.21602158923790882, 0.1810123962224095, 0.17861155362873637, 0.18552669716616188, 0.20123687293850867, 0.1758627774733471, 0.18002778909602057, 0.17720678290517244, 0.08595906469312253, 0.11005410530791415, 0.10735734276244124, 0.08471544867514658, 0.08499254432823566, 0.08600670599181426, 0.09120144232755534, 0.08786549366302465, 0.09138166510922696]}, "mutation_prompt": null}
{"id": "7a5116cc-ad00-4121-b973-8f4491cd76f7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.25)  # Changed line: Increase CR increment from 0.2 to 0.25\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Implement a cooling schedule to gradually decrease the mutation factor F for improved convergence over iterations.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "64d840bf-6dba-4258-8b01-af452e28b857", "metadata": {"aucs": [0.45423475525930346, 0.5927976667991433, 0.4478207448727176, 0.5050373065997071, 0.4702452101766964, 0.48600792933161463, 0.47076454557405456, 0.4628399370104399, 0.4853636663808768, 0.33726603660181886, 0.33018451317248687, 0.33396336625706047, 0.4425371291857788, 0.2974828313252138, 0.4141294753826936, 0.3730189407893012, 0.30813130854410864, 0.3461288969541044, 0.16435226662354596, 0.14282092076003772, 0.16319680057437091, 0.15001804002325136, 0.16518068159824884, 0.16693403115746752, 0.12401076282336476, 0.146640494718295, 0.14774949250498903, 0.13136299521680062, 0.12280573539651263, 0.11770517957994231, 0.1288080516214728, 0.11923445010365974, 0.1283607237455393, 0.1276834095249737, 0.13797157202185917, 0.14278382299360637, 0.9053192009470553, 0.8660483334673228, 0.9002098347817125, 0.975528753634753, 0.9498768151140763, 0.9445713831460156, 0.9738097338493318, 0.9546027307857413, 0.9514852738835676, 0.3378366540342965, 0.3130663362093764, 0.3216204505781177, 0.3572684762827889, 0.2847855736383835, 0.31689038997083163, 0.323797335449335, 0.31248482374204145, 0.3254843614410512, 0.7880249127743724, 0.7713646661446508, 0.7783392489367843, 0.781922848511541, 0.7876052042262797, 0.7608748436472922, 0.7765301524640645, 0.753840082182759, 0.7735915016132198, 0.3513540289877535, 0.3511431583817436, 0.3516358737271146, 0.32503692437897147, 0.2942853050383335, 0.29451520135981135, 0.2638751731166953, 0.2667503703925358, 0.38910760164481784, 0.33656152910046244, 0.021415486323483446, 0.372303148440586, 0.29153955165403256, 0.35758051996796225, 0.3383168630044149, 0.3112497595998619, 0.3264443288445539, 0.29640982305402563, 0.36588962087293875, 0.37516436571613976, 0.33201560699079147, 0.30943352556367365, 0.3327450463251007, 0.2997028325377187, 0.1391242689264065, 0.32194466356153517, 0.1483545351355391, 0.45240315623337923, 0.391995025679059, 0.4447609638044835, 0.3820254651906416, 0.3963726879422397, 0.3948852657264168, 0.38295553856407283, 0.42267364186519685, 0.4082174911438471, 0.18082875545614763, 0.2109551027866866, 0.2205809325499385, 0.11001031683602758, 0.25560786048665396, 0.24837400025029177, 0.21942997024606548, 0.20261893404103037, 0.12357702720461383, 0.23987267419518454, 0.24723294465067003, 0.28439960781731466, 0.2652380083281898, 0.2534639690956757, 0.2528464174959012, 0.27454483437409394, 0.2612543370059113, 0.2761475624756643, 0.3987109691348111, 0.4495602710821951, 0.4406913655622201, 0.6054232260012435, 0.47533578333452753, 0.4972684102428657, 0.4460480911527953, 0.3917005747927599, 0.397540183501946, 0.14677607089834532, 0.1367358116217935, 0.422478896035712, 0.12532546476573203, 0.1344847157120881, 0.1347318575860087, 0.10800363739350993, 0.13730443539785153, 0.13518870223482848, 0.2050279896955498, 0.4040796265231339, 0.32782962198705123, 0.3269608955603651, 0.30255814577067264, 0.444848699806772, 0.2296447471642451, 0.2732557627008909, 0.2466689090287728, 0.3460792704740334, 0.361252878730534, 0.3436855205734437, 0.32949183876596677, 0.3621127650035568, 0.36615005386039245, 0.3599892456795285, 0.3316229375803932, 0.36958342556268964, 0.30781149690747767, 0.33142653097099406, 0.34269916614612783, 0.29057010713019094, 0.3058052856572302, 0.332952085484867, 0.34173953289829684, 0.3342977578763938, 0.3359058879113027, 0.210382424524151, 0.21162320494434161, 0.20056311436274565, 0.2182678576315341, 0.18113146566323113, 0.19219138737727226, 0.2275732525654356, 0.1932620182214395, 0.21351789038557145, 0.431474548940182, 0.18464654569699734, 0.1907854365928764, 0.1907486642456907, 0.4720491401871061, 0.21291994520546587, 0.19953007914403353, 0.23165119402685008, 0.19911964117185255, 0.5777238853222668, 0.1819694298511585, 0.805284722941409, 0.1827188108192469, 0.6718231135370532, 0.5723426404916139, 0.16788922892198066, 0.6570687801071586, 0.6195585362245959, 0.5543602853678709, 0.5448715393087575, 0.15220068708900103, 0.6788195176683121, 0.16107315122358468, 0.20351384609295642, 0.20722171834060177, 0.15100718461893448, 0.20705058968235823, 0.183185971113362, 0.21602158923790882, 0.1810123962224095, 0.17861155362873637, 0.18552669716616188, 0.20123687293850867, 0.1758627774733471, 0.18002778909602057, 0.17720678290517244, 0.08595906469312253, 0.11005410530791415, 0.10735734276244124, 0.08471544867514658, 0.08499254432823566, 0.08600670599181426, 0.09120144232755534, 0.08786549366302465, 0.09138166510922696]}, "mutation_prompt": null}
{"id": "106582a7-82ac-4879-a5f5-48eca193e836", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.25)  # Changed line: Increase CR increment from 0.2 to 0.25\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Implement a cooling schedule to gradually decrease the mutation factor F for improved convergence over iterations.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "64d840bf-6dba-4258-8b01-af452e28b857", "metadata": {"aucs": [0.45423475525930346, 0.5927976667991433, 0.4478207448727176, 0.5050373065997071, 0.4702452101766964, 0.48600792933161463, 0.47076454557405456, 0.4628399370104399, 0.4853636663808768, 0.33726603660181886, 0.33018451317248687, 0.33396336625706047, 0.4425371291857788, 0.2974828313252138, 0.4141294753826936, 0.3730189407893012, 0.30813130854410864, 0.3461288969541044, 0.16435226662354596, 0.14282092076003772, 0.16319680057437091, 0.15001804002325136, 0.16518068159824884, 0.16693403115746752, 0.12401076282336476, 0.146640494718295, 0.14774949250498903, 0.13136299521680062, 0.12280573539651263, 0.11770517957994231, 0.1288080516214728, 0.11923445010365974, 0.1283607237455393, 0.1276834095249737, 0.13797157202185917, 0.14278382299360637, 0.9053192009470553, 0.8660483334673228, 0.9002098347817125, 0.975528753634753, 0.9498768151140763, 0.9445713831460156, 0.9738097338493318, 0.9546027307857413, 0.9514852738835676, 0.3378366540342965, 0.3130663362093764, 0.3216204505781177, 0.3572684762827889, 0.2847855736383835, 0.31689038997083163, 0.323797335449335, 0.31248482374204145, 0.3254843614410512, 0.7880249127743724, 0.7713646661446508, 0.7783392489367843, 0.781922848511541, 0.7876052042262797, 0.7608748436472922, 0.7765301524640645, 0.753840082182759, 0.7735915016132198, 0.3513540289877535, 0.3511431583817436, 0.3516358737271146, 0.32503692437897147, 0.2942853050383335, 0.29451520135981135, 0.2638751731166953, 0.2667503703925358, 0.38910760164481784, 0.33656152910046244, 0.021415486323483446, 0.372303148440586, 0.29153955165403256, 0.35758051996796225, 0.3383168630044149, 0.3112497595998619, 0.3264443288445539, 0.29640982305402563, 0.36588962087293875, 0.37516436571613976, 0.33201560699079147, 0.30943352556367365, 0.3327450463251007, 0.2997028325377187, 0.1391242689264065, 0.32194466356153517, 0.1483545351355391, 0.45240315623337923, 0.391995025679059, 0.4447609638044835, 0.3820254651906416, 0.3963726879422397, 0.3948852657264168, 0.38295553856407283, 0.42267364186519685, 0.4082174911438471, 0.18082875545614763, 0.2109551027866866, 0.2205809325499385, 0.11001031683602758, 0.25560786048665396, 0.24837400025029177, 0.21942997024606548, 0.20261893404103037, 0.12357702720461383, 0.23987267419518454, 0.24723294465067003, 0.28439960781731466, 0.2652380083281898, 0.2534639690956757, 0.2528464174959012, 0.27454483437409394, 0.2612543370059113, 0.2761475624756643, 0.3987109691348111, 0.4495602710821951, 0.4406913655622201, 0.6054232260012435, 0.47533578333452753, 0.4972684102428657, 0.4460480911527953, 0.3917005747927599, 0.397540183501946, 0.14677607089834532, 0.1367358116217935, 0.422478896035712, 0.12532546476573203, 0.1344847157120881, 0.1347318575860087, 0.10800363739350993, 0.13730443539785153, 0.13518870223482848, 0.2050279896955498, 0.4040796265231339, 0.32782962198705123, 0.3269608955603651, 0.30255814577067264, 0.444848699806772, 0.2296447471642451, 0.2732557627008909, 0.2466689090287728, 0.3460792704740334, 0.361252878730534, 0.3436855205734437, 0.32949183876596677, 0.3621127650035568, 0.36615005386039245, 0.3599892456795285, 0.3316229375803932, 0.36958342556268964, 0.30781149690747767, 0.33142653097099406, 0.34269916614612783, 0.29057010713019094, 0.3058052856572302, 0.332952085484867, 0.34173953289829684, 0.3342977578763938, 0.3359058879113027, 0.210382424524151, 0.21162320494434161, 0.20056311436274565, 0.2182678576315341, 0.18113146566323113, 0.19219138737727226, 0.2275732525654356, 0.1932620182214395, 0.21351789038557145, 0.431474548940182, 0.18464654569699734, 0.1907854365928764, 0.1907486642456907, 0.4720491401871061, 0.21291994520546587, 0.19953007914403353, 0.23165119402685008, 0.19911964117185255, 0.5777238853222668, 0.1819694298511585, 0.805284722941409, 0.1827188108192469, 0.6718231135370532, 0.5723426404916139, 0.16788922892198066, 0.6570687801071586, 0.6195585362245959, 0.5543602853678709, 0.5448715393087575, 0.15220068708900103, 0.6788195176683121, 0.16107315122358468, 0.20351384609295642, 0.20722171834060177, 0.15100718461893448, 0.20705058968235823, 0.183185971113362, 0.21602158923790882, 0.1810123962224095, 0.17861155362873637, 0.18552669716616188, 0.20123687293850867, 0.1758627774733471, 0.18002778909602057, 0.17720678290517244, 0.08595906469312253, 0.11005410530791415, 0.10735734276244124, 0.08471544867514658, 0.08499254432823566, 0.08600670599181426, 0.09120144232755534, 0.08786549366302465, 0.09138166510922696]}, "mutation_prompt": null}
{"id": "07afd2de-be2c-4238-a933-5a5f01d5b772", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.25)  # Changed line: Increase CR increment from 0.2 to 0.25\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F = self.F * 0.99 + np.random.uniform(-0.01, 0.01)  # Changed line: Added random perturbation to F\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a small random perturbation to F in each iteration to increase exploration diversity.", "configspace": "", "generation": 48, "fitness": 0.3318110440109154, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.20.", "error": "", "parent_id": "64d840bf-6dba-4258-8b01-af452e28b857", "metadata": {"aucs": [0.48708885282644054, 0.5619605481204779, 0.46065782215111517, 0.4962586780814391, 0.5609200856824799, 0.5940869008996037, 0.4872352255013185, 0.5441533819969282, 0.4982935152271458, 0.36803324294811524, 0.32607622403818093, 0.38879173170781633, 0.3184486473042567, 0.365925598652468, 0.3029539846166587, 0.30394960192130827, 0.34386646252951736, 0.324390007658246, 0.11684785688007882, 0.1739798750624022, 0.12263107276621898, 0.39914162126110597, 0.13548093194590127, 0.3858483080301427, 0.14736359952006384, 0.16097255233673036, 0.1682561930647447, 0.11711806164796112, 0.1386867987804855, 0.1335787653158712, 0.156648931082371, 0.1367300711222813, 0.10428748347362904, 0.10828130859217033, 0.12860939481488654, 0.159592791240742, 0.9407345319828573, 0.9023802560509253, 0.9229388311394839, 0.9819098371209668, 0.9198424809991054, 0.9465894252573117, 0.9210343710404326, 0.961761887156099, 0.9489487936523551, 0.30284392876816335, 0.05724030569899752, 0.34062553984983235, 0.3260340475028276, 0.2879696915891208, 0.38236002646301825, 0.3171009113977763, 0.3485762140460471, 0.3418841593479095, 0.7801684137806952, 0.7749861627561165, 0.7454004816875496, 0.7858813165854507, 0.7590964582685564, 0.7996913525636253, 0.7751593892608255, 0.7898721357393171, 0.7893820339958548, 0.35141338186461646, 0.44967985466029325, 0.3203374627105492, 0.3124196452718938, 0.3020424011952707, 0.23545913071432245, 0.3383704305213848, 0.3865192293956129, 0.31856571354806096, 0.02112545381710862, 0.016428106641763973, 0.335580209548451, 0.31215512426742675, 0.2939450812447031, 0.3824805670688025, 0.3991300900332757, 0.26608373026527754, 0.30565045707100524, 0.3493233447884483, 0.3112538675166917, 0.3343954726761591, 0.34349133082299155, 0.30759703215877676, 0.31073468382278613, 0.3416413481795616, 0.3337807197225021, 0.30429737189207295, 0.3582171822971112, 0.35955931305486044, 0.4099290933970823, 0.3981698645505195, 0.394067414430762, 0.3854876442285854, 0.3906384044497293, 0.4159288958285208, 0.37747777456804965, 0.1829279469006665, 0.2295903929312454, 0.11451635781741365, 0.23245895273867467, 0.23266906600220816, 0.2532812642623049, 0.13522183471594673, 0.15254476189723176, 0.12275034609277369, 0.2671061671780909, 0.24376546839912572, 0.24365195975477616, 0.2519639787980237, 0.2464850397462549, 0.251450520386738, 0.2932099907091331, 0.2836849729407739, 0.30264655255963113, 0.5677522718724646, 0.4837715343556961, 0.44820469410667163, 0.4352141761910997, 0.4207825419839536, 0.4162164254009141, 0.47449000790032503, 0.4388200346902321, 0.43509615036007976, 0.10930907641734322, 0.13034911317819364, 0.11725579724196455, 0.12413480531998355, 0.16662028407699958, 0.11677002413759452, 0.13160989490929298, 0.10253193232880353, 0.12419723665940452, 0.2786837929183129, 0.33670787443516104, 0.19788164419343757, 0.3236853896441998, 0.38566987645941164, 0.3184787390910587, 0.2616715981241938, 0.308394569428303, 0.20068331517345372, 0.3390931056358192, 0.3540101060652173, 0.3576583550853093, 0.359455634287666, 0.34428326225511696, 0.3665426814348429, 0.37278956785624173, 0.3544566789864725, 0.34108418908646465, 0.33153365648836564, 0.2903455233545933, 0.33252612681061766, 0.3224402745838242, 0.33131838238599, 0.34316761994154477, 0.33488556039541106, 0.31775316321282554, 0.3163848470750864, 0.20703792859620185, 0.2096909292650555, 0.193307048456832, 0.19972215005716254, 0.17837051134635473, 0.19712844377502647, 0.19765005648107703, 0.21941044128872134, 0.20830607161366477, 0.19601591253386286, 0.1755529183338631, 0.19895915349866633, 0.4078033358964269, 0.42554398828724205, 0.19706557116906265, 0.2114469382057298, 0.18101933802165304, 0.23130568105079952, 0.19100485889517493, 0.18043549032655648, 0.16756444028307904, 0.18380098105811227, 0.6297493647695174, 0.6001206943028545, 0.167857590227814, 0.5410801861665258, 0.19285100258036758, 0.5397765358829103, 0.20741627086858794, 0.516377957150828, 0.5775069873317995, 0.5897772135958074, 0.6062988440848838, 0.20633561427581149, 0.2016513838073004, 0.20533419142695053, 0.19543017180416977, 0.1880169502543143, 0.1766143793328505, 0.19916056845705898, 0.1857417072466666, 0.18581823496087146, 0.17879556834482158, 0.18418005643559698, 0.19035269839995894, 0.0930289895780072, 0.08873851425082446, 0.08260004539949839, 0.09228767276954897, 0.09739128505449657, 0.07838082639579369, 0.0820442440804533, 0.08674353873116047, 0.09001097985082085]}, "mutation_prompt": null}
{"id": "31d11da2-4354-4aa4-bbbc-3a40d09ac76d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.25)  # Changed line: Increase CR increment from 0.2 to 0.25\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Implement a cooling schedule to gradually decrease the mutation factor F for improved convergence over iterations.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "64d840bf-6dba-4258-8b01-af452e28b857", "metadata": {"aucs": [0.45423475525930346, 0.5927976667991433, 0.4478207448727176, 0.5050373065997071, 0.4702452101766964, 0.48600792933161463, 0.47076454557405456, 0.4628399370104399, 0.4853636663808768, 0.33726603660181886, 0.33018451317248687, 0.33396336625706047, 0.4425371291857788, 0.2974828313252138, 0.4141294753826936, 0.3730189407893012, 0.30813130854410864, 0.3461288969541044, 0.16435226662354596, 0.14282092076003772, 0.16319680057437091, 0.15001804002325136, 0.16518068159824884, 0.16693403115746752, 0.12401076282336476, 0.146640494718295, 0.14774949250498903, 0.13136299521680062, 0.12280573539651263, 0.11770517957994231, 0.1288080516214728, 0.11923445010365974, 0.1283607237455393, 0.1276834095249737, 0.13797157202185917, 0.14278382299360637, 0.9053192009470553, 0.8660483334673228, 0.9002098347817125, 0.975528753634753, 0.9498768151140763, 0.9445713831460156, 0.9738097338493318, 0.9546027307857413, 0.9514852738835676, 0.3378366540342965, 0.3130663362093764, 0.3216204505781177, 0.3572684762827889, 0.2847855736383835, 0.31689038997083163, 0.323797335449335, 0.31248482374204145, 0.3254843614410512, 0.7880249127743724, 0.7713646661446508, 0.7783392489367843, 0.781922848511541, 0.7876052042262797, 0.7608748436472922, 0.7765301524640645, 0.753840082182759, 0.7735915016132198, 0.3513540289877535, 0.3511431583817436, 0.3516358737271146, 0.32503692437897147, 0.2942853050383335, 0.29451520135981135, 0.2638751731166953, 0.2667503703925358, 0.38910760164481784, 0.33656152910046244, 0.021415486323483446, 0.372303148440586, 0.29153955165403256, 0.35758051996796225, 0.3383168630044149, 0.3112497595998619, 0.3264443288445539, 0.29640982305402563, 0.36588962087293875, 0.37516436571613976, 0.33201560699079147, 0.30943352556367365, 0.3327450463251007, 0.2997028325377187, 0.1391242689264065, 0.32194466356153517, 0.1483545351355391, 0.45240315623337923, 0.391995025679059, 0.4447609638044835, 0.3820254651906416, 0.3963726879422397, 0.3948852657264168, 0.38295553856407283, 0.42267364186519685, 0.4082174911438471, 0.18082875545614763, 0.2109551027866866, 0.2205809325499385, 0.11001031683602758, 0.25560786048665396, 0.24837400025029177, 0.21942997024606548, 0.20261893404103037, 0.12357702720461383, 0.23987267419518454, 0.24723294465067003, 0.28439960781731466, 0.2652380083281898, 0.2534639690956757, 0.2528464174959012, 0.27454483437409394, 0.2612543370059113, 0.2761475624756643, 0.3987109691348111, 0.4495602710821951, 0.4406913655622201, 0.6054232260012435, 0.47533578333452753, 0.4972684102428657, 0.4460480911527953, 0.3917005747927599, 0.397540183501946, 0.14677607089834532, 0.1367358116217935, 0.422478896035712, 0.12532546476573203, 0.1344847157120881, 0.1347318575860087, 0.10800363739350993, 0.13730443539785153, 0.13518870223482848, 0.2050279896955498, 0.4040796265231339, 0.32782962198705123, 0.3269608955603651, 0.30255814577067264, 0.444848699806772, 0.2296447471642451, 0.2732557627008909, 0.2466689090287728, 0.3460792704740334, 0.361252878730534, 0.3436855205734437, 0.32949183876596677, 0.3621127650035568, 0.36615005386039245, 0.3599892456795285, 0.3316229375803932, 0.36958342556268964, 0.30781149690747767, 0.33142653097099406, 0.34269916614612783, 0.29057010713019094, 0.3058052856572302, 0.332952085484867, 0.34173953289829684, 0.3342977578763938, 0.3359058879113027, 0.210382424524151, 0.21162320494434161, 0.20056311436274565, 0.2182678576315341, 0.18113146566323113, 0.19219138737727226, 0.2275732525654356, 0.1932620182214395, 0.21351789038557145, 0.431474548940182, 0.18464654569699734, 0.1907854365928764, 0.1907486642456907, 0.4720491401871061, 0.21291994520546587, 0.19953007914403353, 0.23165119402685008, 0.19911964117185255, 0.5777238853222668, 0.1819694298511585, 0.805284722941409, 0.1827188108192469, 0.6718231135370532, 0.5723426404916139, 0.16788922892198066, 0.6570687801071586, 0.6195585362245959, 0.5543602853678709, 0.5448715393087575, 0.15220068708900103, 0.6788195176683121, 0.16107315122358468, 0.20351384609295642, 0.20722171834060177, 0.15100718461893448, 0.20705058968235823, 0.183185971113362, 0.21602158923790882, 0.1810123962224095, 0.17861155362873637, 0.18552669716616188, 0.20123687293850867, 0.1758627774733471, 0.18002778909602057, 0.17720678290517244, 0.08595906469312253, 0.11005410530791415, 0.10735734276244124, 0.08471544867514658, 0.08499254432823566, 0.08600670599181426, 0.09120144232755534, 0.08786549366302465, 0.09138166510922696]}, "mutation_prompt": null}
{"id": "97d3f932-602d-493c-9b8e-9cb433409d42", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.25)  # Changed line: Increase CR increment from 0.2 to 0.25\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Implement a cooling schedule to gradually decrease the mutation factor F for improved convergence over iterations.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "64d840bf-6dba-4258-8b01-af452e28b857", "metadata": {"aucs": [0.45423475525930346, 0.5927976667991433, 0.4478207448727176, 0.5050373065997071, 0.4702452101766964, 0.48600792933161463, 0.47076454557405456, 0.4628399370104399, 0.4853636663808768, 0.33726603660181886, 0.33018451317248687, 0.33396336625706047, 0.4425371291857788, 0.2974828313252138, 0.4141294753826936, 0.3730189407893012, 0.30813130854410864, 0.3461288969541044, 0.16435226662354596, 0.14282092076003772, 0.16319680057437091, 0.15001804002325136, 0.16518068159824884, 0.16693403115746752, 0.12401076282336476, 0.146640494718295, 0.14774949250498903, 0.13136299521680062, 0.12280573539651263, 0.11770517957994231, 0.1288080516214728, 0.11923445010365974, 0.1283607237455393, 0.1276834095249737, 0.13797157202185917, 0.14278382299360637, 0.9053192009470553, 0.8660483334673228, 0.9002098347817125, 0.975528753634753, 0.9498768151140763, 0.9445713831460156, 0.9738097338493318, 0.9546027307857413, 0.9514852738835676, 0.3378366540342965, 0.3130663362093764, 0.3216204505781177, 0.3572684762827889, 0.2847855736383835, 0.31689038997083163, 0.323797335449335, 0.31248482374204145, 0.3254843614410512, 0.7880249127743724, 0.7713646661446508, 0.7783392489367843, 0.781922848511541, 0.7876052042262797, 0.7608748436472922, 0.7765301524640645, 0.753840082182759, 0.7735915016132198, 0.3513540289877535, 0.3511431583817436, 0.3516358737271146, 0.32503692437897147, 0.2942853050383335, 0.29451520135981135, 0.2638751731166953, 0.2667503703925358, 0.38910760164481784, 0.33656152910046244, 0.021415486323483446, 0.372303148440586, 0.29153955165403256, 0.35758051996796225, 0.3383168630044149, 0.3112497595998619, 0.3264443288445539, 0.29640982305402563, 0.36588962087293875, 0.37516436571613976, 0.33201560699079147, 0.30943352556367365, 0.3327450463251007, 0.2997028325377187, 0.1391242689264065, 0.32194466356153517, 0.1483545351355391, 0.45240315623337923, 0.391995025679059, 0.4447609638044835, 0.3820254651906416, 0.3963726879422397, 0.3948852657264168, 0.38295553856407283, 0.42267364186519685, 0.4082174911438471, 0.18082875545614763, 0.2109551027866866, 0.2205809325499385, 0.11001031683602758, 0.25560786048665396, 0.24837400025029177, 0.21942997024606548, 0.20261893404103037, 0.12357702720461383, 0.23987267419518454, 0.24723294465067003, 0.28439960781731466, 0.2652380083281898, 0.2534639690956757, 0.2528464174959012, 0.27454483437409394, 0.2612543370059113, 0.2761475624756643, 0.3987109691348111, 0.4495602710821951, 0.4406913655622201, 0.6054232260012435, 0.47533578333452753, 0.4972684102428657, 0.4460480911527953, 0.3917005747927599, 0.397540183501946, 0.14677607089834532, 0.1367358116217935, 0.422478896035712, 0.12532546476573203, 0.1344847157120881, 0.1347318575860087, 0.10800363739350993, 0.13730443539785153, 0.13518870223482848, 0.2050279896955498, 0.4040796265231339, 0.32782962198705123, 0.3269608955603651, 0.30255814577067264, 0.444848699806772, 0.2296447471642451, 0.2732557627008909, 0.2466689090287728, 0.3460792704740334, 0.361252878730534, 0.3436855205734437, 0.32949183876596677, 0.3621127650035568, 0.36615005386039245, 0.3599892456795285, 0.3316229375803932, 0.36958342556268964, 0.30781149690747767, 0.33142653097099406, 0.34269916614612783, 0.29057010713019094, 0.3058052856572302, 0.332952085484867, 0.34173953289829684, 0.3342977578763938, 0.3359058879113027, 0.210382424524151, 0.21162320494434161, 0.20056311436274565, 0.2182678576315341, 0.18113146566323113, 0.19219138737727226, 0.2275732525654356, 0.1932620182214395, 0.21351789038557145, 0.431474548940182, 0.18464654569699734, 0.1907854365928764, 0.1907486642456907, 0.4720491401871061, 0.21291994520546587, 0.19953007914403353, 0.23165119402685008, 0.19911964117185255, 0.5777238853222668, 0.1819694298511585, 0.805284722941409, 0.1827188108192469, 0.6718231135370532, 0.5723426404916139, 0.16788922892198066, 0.6570687801071586, 0.6195585362245959, 0.5543602853678709, 0.5448715393087575, 0.15220068708900103, 0.6788195176683121, 0.16107315122358468, 0.20351384609295642, 0.20722171834060177, 0.15100718461893448, 0.20705058968235823, 0.183185971113362, 0.21602158923790882, 0.1810123962224095, 0.17861155362873637, 0.18552669716616188, 0.20123687293850867, 0.1758627774733471, 0.18002778909602057, 0.17720678290517244, 0.08595906469312253, 0.11005410530791415, 0.10735734276244124, 0.08471544867514658, 0.08499254432823566, 0.08600670599181426, 0.09120144232755534, 0.08786549366302465, 0.09138166510922696]}, "mutation_prompt": null}
{"id": "a593d49e-60a6-40c2-bfe7-7f381f7cfcad", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.25)  # Changed line: Increase CR increment from 0.2 to 0.25\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Implement a cooling schedule to gradually decrease the mutation factor F for improved convergence over iterations.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "64d840bf-6dba-4258-8b01-af452e28b857", "metadata": {"aucs": [0.45423475525930346, 0.5927976667991433, 0.4478207448727176, 0.5050373065997071, 0.4702452101766964, 0.48600792933161463, 0.47076454557405456, 0.4628399370104399, 0.4853636663808768, 0.33726603660181886, 0.33018451317248687, 0.33396336625706047, 0.4425371291857788, 0.2974828313252138, 0.4141294753826936, 0.3730189407893012, 0.30813130854410864, 0.3461288969541044, 0.16435226662354596, 0.14282092076003772, 0.16319680057437091, 0.15001804002325136, 0.16518068159824884, 0.16693403115746752, 0.12401076282336476, 0.146640494718295, 0.14774949250498903, 0.13136299521680062, 0.12280573539651263, 0.11770517957994231, 0.1288080516214728, 0.11923445010365974, 0.1283607237455393, 0.1276834095249737, 0.13797157202185917, 0.14278382299360637, 0.9053192009470553, 0.8660483334673228, 0.9002098347817125, 0.975528753634753, 0.9498768151140763, 0.9445713831460156, 0.9738097338493318, 0.9546027307857413, 0.9514852738835676, 0.3378366540342965, 0.3130663362093764, 0.3216204505781177, 0.3572684762827889, 0.2847855736383835, 0.31689038997083163, 0.323797335449335, 0.31248482374204145, 0.3254843614410512, 0.7880249127743724, 0.7713646661446508, 0.7783392489367843, 0.781922848511541, 0.7876052042262797, 0.7608748436472922, 0.7765301524640645, 0.753840082182759, 0.7735915016132198, 0.3513540289877535, 0.3511431583817436, 0.3516358737271146, 0.32503692437897147, 0.2942853050383335, 0.29451520135981135, 0.2638751731166953, 0.2667503703925358, 0.38910760164481784, 0.33656152910046244, 0.021415486323483446, 0.372303148440586, 0.29153955165403256, 0.35758051996796225, 0.3383168630044149, 0.3112497595998619, 0.3264443288445539, 0.29640982305402563, 0.36588962087293875, 0.37516436571613976, 0.33201560699079147, 0.30943352556367365, 0.3327450463251007, 0.2997028325377187, 0.1391242689264065, 0.32194466356153517, 0.1483545351355391, 0.45240315623337923, 0.391995025679059, 0.4447609638044835, 0.3820254651906416, 0.3963726879422397, 0.3948852657264168, 0.38295553856407283, 0.42267364186519685, 0.4082174911438471, 0.18082875545614763, 0.2109551027866866, 0.2205809325499385, 0.11001031683602758, 0.25560786048665396, 0.24837400025029177, 0.21942997024606548, 0.20261893404103037, 0.12357702720461383, 0.23987267419518454, 0.24723294465067003, 0.28439960781731466, 0.2652380083281898, 0.2534639690956757, 0.2528464174959012, 0.27454483437409394, 0.2612543370059113, 0.2761475624756643, 0.3987109691348111, 0.4495602710821951, 0.4406913655622201, 0.6054232260012435, 0.47533578333452753, 0.4972684102428657, 0.4460480911527953, 0.3917005747927599, 0.397540183501946, 0.14677607089834532, 0.1367358116217935, 0.422478896035712, 0.12532546476573203, 0.1344847157120881, 0.1347318575860087, 0.10800363739350993, 0.13730443539785153, 0.13518870223482848, 0.2050279896955498, 0.4040796265231339, 0.32782962198705123, 0.3269608955603651, 0.30255814577067264, 0.444848699806772, 0.2296447471642451, 0.2732557627008909, 0.2466689090287728, 0.3460792704740334, 0.361252878730534, 0.3436855205734437, 0.32949183876596677, 0.3621127650035568, 0.36615005386039245, 0.3599892456795285, 0.3316229375803932, 0.36958342556268964, 0.30781149690747767, 0.33142653097099406, 0.34269916614612783, 0.29057010713019094, 0.3058052856572302, 0.332952085484867, 0.34173953289829684, 0.3342977578763938, 0.3359058879113027, 0.210382424524151, 0.21162320494434161, 0.20056311436274565, 0.2182678576315341, 0.18113146566323113, 0.19219138737727226, 0.2275732525654356, 0.1932620182214395, 0.21351789038557145, 0.431474548940182, 0.18464654569699734, 0.1907854365928764, 0.1907486642456907, 0.4720491401871061, 0.21291994520546587, 0.19953007914403353, 0.23165119402685008, 0.19911964117185255, 0.5777238853222668, 0.1819694298511585, 0.805284722941409, 0.1827188108192469, 0.6718231135370532, 0.5723426404916139, 0.16788922892198066, 0.6570687801071586, 0.6195585362245959, 0.5543602853678709, 0.5448715393087575, 0.15220068708900103, 0.6788195176683121, 0.16107315122358468, 0.20351384609295642, 0.20722171834060177, 0.15100718461893448, 0.20705058968235823, 0.183185971113362, 0.21602158923790882, 0.1810123962224095, 0.17861155362873637, 0.18552669716616188, 0.20123687293850867, 0.1758627774733471, 0.18002778909602057, 0.17720678290517244, 0.08595906469312253, 0.11005410530791415, 0.10735734276244124, 0.08471544867514658, 0.08499254432823566, 0.08600670599181426, 0.09120144232755534, 0.08786549366302465, 0.09138166510922696]}, "mutation_prompt": null}
{"id": "6416154a-e7d1-46e3-84b9-5e1810d2f11b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.25)  # Changed line: Increase CR increment from 0.2 to 0.25\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.025)  # Changed line: Fine-tune mutation factor decrement (from 0.03 to 0.025)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Fine-tune the mutation factor decrement for better adaptability and convergence.", "configspace": "", "generation": 52, "fitness": 0.3224007248188246, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.20.", "error": "", "parent_id": "64d840bf-6dba-4258-8b01-af452e28b857", "metadata": {"aucs": [0.4968547723236566, 0.449351041788711, 0.47768936620102265, 0.4527615410879442, 0.5401435777612844, 0.467611237399018, 0.486437902955817, 0.45617955264386356, 0.42398977310002495, 0.28049034643438775, 0.3102647954235036, 0.3613982347226108, 0.35384719511360585, 0.2822649754381584, 0.3024811641532448, 0.30802438143845956, 0.3230610887441163, 0.2925926538421204, 0.33516416604291877, 0.16123261026204438, 0.14130036748386976, 0.39505807865043285, 0.1301611807115336, 0.16109230342674963, 0.1674280619833578, 0.16101317690030104, 0.16269288063297027, 0.10446906500652098, 0.15140302619097679, 0.1330033264332473, 0.10701371342416188, 0.15521923455448272, 0.13846512416188994, 0.13538241330393863, 0.15107823996032455, 0.11397478409305462, 0.8791922480510558, 0.939330177212758, 0.9293099852641374, 0.9867682415168489, 0.9529302690543411, 0.9391825511699456, 0.973808682433698, 0.97293766039159, 0.9608885327362298, 0.323987894043854, 0.31485742877885015, 0.3442195450851345, 0.30792049233349694, 0.28565058973983926, 0.3367142596927071, 0.3168826516511255, 0.33853721135393766, 0.3189681520746115, 0.7453257261051425, 0.7449939008023212, 0.7378592782503147, 0.7416211902540374, 0.7331854181929962, 0.7840358670821252, 0.7373790179783872, 0.7370877972460947, 0.7369668084175292, 0.27540495954977573, 0.3152150458299118, 0.35732116823296967, 0.3220846594310657, 0.2899890991091518, 0.3201895989518101, 0.32228359343911284, 0.26411331265593185, 0.2843929559010536, 0.27515777462296287, 0.01626347390378191, 0.45152079946770696, 0.28500306736186687, 0.3020918118595183, 0.3166006323873338, 0.29076590150582204, 0.29327518877715886, 0.2871489580440245, 0.2913090331659186, 0.23963825727109378, 0.282273123531968, 0.21054640644796785, 0.31939883113540724, 0.26338219986937983, 0.18815180589599012, 0.2768963175598267, 0.3356910321200255, 0.39348257030843725, 0.3607448995388549, 0.3540341287311779, 0.3822648503292029, 0.16777815429160547, 0.3615229272288426, 0.35691985680451277, 0.36707501542380594, 0.42522049096782966, 0.1053625656852275, 0.2055823347243222, 0.1933969031670303, 0.21198640518275136, 0.1966633026050646, 0.19361376801082442, 0.1472030835190058, 0.17469223270126144, 0.13406867103370568, 0.21823236500085386, 0.2047418964290214, 0.23716797082870256, 0.2284138744964569, 0.24471457368008886, 0.2464954602661873, 0.2402728830863311, 0.23900035184046753, 0.2527132984034779, 0.43233351919081464, 0.4592447155175914, 0.4618795462863714, 0.4250652200715469, 0.4484954240597351, 0.4633230983827836, 0.4249382136114528, 0.38952272195755466, 0.4208471854726462, 0.1453807588879843, 0.1463933588596621, 0.14358838937965224, 0.12939949265803863, 0.11825800813844412, 0.1214526538533528, 0.10016485922698193, 0.1428520825217684, 0.11462594659610714, 0.43650766977176736, 0.34661588900861073, 0.17308766121834873, 0.45335341959133024, 0.18273491563155198, 0.2669741187989352, 0.33676755242766154, 0.18874361578890975, 0.21075219475251128, 0.3560342497084916, 0.34097698928942044, 0.34940376839197995, 0.33940302518693743, 0.3462711940168819, 0.3404440994711352, 0.3345821435980604, 0.350669752234673, 0.3428158736464033, 0.3253126474841649, 0.3249454604354607, 0.3355556096664877, 0.3150912389845746, 0.33204433603329575, 0.3290019073508741, 0.3105768574642067, 0.31267610386295486, 0.31965206911288213, 0.21192065226766255, 0.21248114201957546, 0.20916192241878828, 0.19904666428876872, 0.2165804692905362, 0.23376021443088446, 0.2112283656895816, 0.23220321045057357, 0.20450523182028923, 0.18153037908683056, 0.20773966398720245, 0.23756146503546482, 0.40411481667209004, 0.20695551913325594, 0.23308809857460888, 0.19736973851798278, 0.23383527576478813, 0.39588279443501684, 0.16267908400972997, 0.1818437214232631, 0.18013409558965465, 0.18200138460846516, 0.193960388527324, 0.7193220499925956, 0.1841884333140632, 0.7991783597893135, 0.6932039215501684, 0.45493047103536566, 0.20421755967883481, 0.676086605758311, 0.597955588138281, 0.19849495807545658, 0.5799864522604702, 0.20596865332725478, 0.15226245132497074, 0.20544998588194652, 0.17882766937339933, 0.18428295508731352, 0.18548358451629954, 0.19106803291348462, 0.17080141385774295, 0.1824552123079176, 0.17989941706605117, 0.18495197884344539, 0.18690980624546139, 0.08634789873881576, 0.08051752057566153, 0.09085188178327985, 0.09338659762799928, 0.09152539538174842, 0.08274881159022751, 0.09585430246981452, 0.08574368748190919, 0.08670027621413723]}, "mutation_prompt": null}
{"id": "3d60726d-bc51-45ce-99f5-cc7e148fc5bb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.25)  # Changed line: Increase CR increment from 0.2 to 0.25\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Implement a cooling schedule to gradually decrease the mutation factor F for improved convergence over iterations.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "64d840bf-6dba-4258-8b01-af452e28b857", "metadata": {"aucs": [0.45423475525930346, 0.5927976667991433, 0.4478207448727176, 0.5050373065997071, 0.4702452101766964, 0.48600792933161463, 0.47076454557405456, 0.4628399370104399, 0.4853636663808768, 0.33726603660181886, 0.33018451317248687, 0.33396336625706047, 0.4425371291857788, 0.2974828313252138, 0.4141294753826936, 0.3730189407893012, 0.30813130854410864, 0.3461288969541044, 0.16435226662354596, 0.14282092076003772, 0.16319680057437091, 0.15001804002325136, 0.16518068159824884, 0.16693403115746752, 0.12401076282336476, 0.146640494718295, 0.14774949250498903, 0.13136299521680062, 0.12280573539651263, 0.11770517957994231, 0.1288080516214728, 0.11923445010365974, 0.1283607237455393, 0.1276834095249737, 0.13797157202185917, 0.14278382299360637, 0.9053192009470553, 0.8660483334673228, 0.9002098347817125, 0.975528753634753, 0.9498768151140763, 0.9445713831460156, 0.9738097338493318, 0.9546027307857413, 0.9514852738835676, 0.3378366540342965, 0.3130663362093764, 0.3216204505781177, 0.3572684762827889, 0.2847855736383835, 0.31689038997083163, 0.323797335449335, 0.31248482374204145, 0.3254843614410512, 0.7880249127743724, 0.7713646661446508, 0.7783392489367843, 0.781922848511541, 0.7876052042262797, 0.7608748436472922, 0.7765301524640645, 0.753840082182759, 0.7735915016132198, 0.3513540289877535, 0.3511431583817436, 0.3516358737271146, 0.32503692437897147, 0.2942853050383335, 0.29451520135981135, 0.2638751731166953, 0.2667503703925358, 0.38910760164481784, 0.33656152910046244, 0.021415486323483446, 0.372303148440586, 0.29153955165403256, 0.35758051996796225, 0.3383168630044149, 0.3112497595998619, 0.3264443288445539, 0.29640982305402563, 0.36588962087293875, 0.37516436571613976, 0.33201560699079147, 0.30943352556367365, 0.3327450463251007, 0.2997028325377187, 0.1391242689264065, 0.32194466356153517, 0.1483545351355391, 0.45240315623337923, 0.391995025679059, 0.4447609638044835, 0.3820254651906416, 0.3963726879422397, 0.3948852657264168, 0.38295553856407283, 0.42267364186519685, 0.4082174911438471, 0.18082875545614763, 0.2109551027866866, 0.2205809325499385, 0.11001031683602758, 0.25560786048665396, 0.24837400025029177, 0.21942997024606548, 0.20261893404103037, 0.12357702720461383, 0.23987267419518454, 0.24723294465067003, 0.28439960781731466, 0.2652380083281898, 0.2534639690956757, 0.2528464174959012, 0.27454483437409394, 0.2612543370059113, 0.2761475624756643, 0.3987109691348111, 0.4495602710821951, 0.4406913655622201, 0.6054232260012435, 0.47533578333452753, 0.4972684102428657, 0.4460480911527953, 0.3917005747927599, 0.397540183501946, 0.14677607089834532, 0.1367358116217935, 0.422478896035712, 0.12532546476573203, 0.1344847157120881, 0.1347318575860087, 0.10800363739350993, 0.13730443539785153, 0.13518870223482848, 0.2050279896955498, 0.4040796265231339, 0.32782962198705123, 0.3269608955603651, 0.30255814577067264, 0.444848699806772, 0.2296447471642451, 0.2732557627008909, 0.2466689090287728, 0.3460792704740334, 0.361252878730534, 0.3436855205734437, 0.32949183876596677, 0.3621127650035568, 0.36615005386039245, 0.3599892456795285, 0.3316229375803932, 0.36958342556268964, 0.30781149690747767, 0.33142653097099406, 0.34269916614612783, 0.29057010713019094, 0.3058052856572302, 0.332952085484867, 0.34173953289829684, 0.3342977578763938, 0.3359058879113027, 0.210382424524151, 0.21162320494434161, 0.20056311436274565, 0.2182678576315341, 0.18113146566323113, 0.19219138737727226, 0.2275732525654356, 0.1932620182214395, 0.21351789038557145, 0.431474548940182, 0.18464654569699734, 0.1907854365928764, 0.1907486642456907, 0.4720491401871061, 0.21291994520546587, 0.19953007914403353, 0.23165119402685008, 0.19911964117185255, 0.5777238853222668, 0.1819694298511585, 0.805284722941409, 0.1827188108192469, 0.6718231135370532, 0.5723426404916139, 0.16788922892198066, 0.6570687801071586, 0.6195585362245959, 0.5543602853678709, 0.5448715393087575, 0.15220068708900103, 0.6788195176683121, 0.16107315122358468, 0.20351384609295642, 0.20722171834060177, 0.15100718461893448, 0.20705058968235823, 0.183185971113362, 0.21602158923790882, 0.1810123962224095, 0.17861155362873637, 0.18552669716616188, 0.20123687293850867, 0.1758627774733471, 0.18002778909602057, 0.17720678290517244, 0.08595906469312253, 0.11005410530791415, 0.10735734276244124, 0.08471544867514658, 0.08499254432823566, 0.08600670599181426, 0.09120144232755534, 0.08786549366302465, 0.09138166510922696]}, "mutation_prompt": null}
{"id": "be19588f-871f-456a-9898-e4bbb04528cf", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.25)  # Changed line: Increase CR increment from 0.2 to 0.25\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Implement a cooling schedule to gradually decrease the mutation factor F for improved convergence over iterations.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "64d840bf-6dba-4258-8b01-af452e28b857", "metadata": {"aucs": [0.45423475525930346, 0.5927976667991433, 0.4478207448727176, 0.5050373065997071, 0.4702452101766964, 0.48600792933161463, 0.47076454557405456, 0.4628399370104399, 0.4853636663808768, 0.33726603660181886, 0.33018451317248687, 0.33396336625706047, 0.4425371291857788, 0.2974828313252138, 0.4141294753826936, 0.3730189407893012, 0.30813130854410864, 0.3461288969541044, 0.16435226662354596, 0.14282092076003772, 0.16319680057437091, 0.15001804002325136, 0.16518068159824884, 0.16693403115746752, 0.12401076282336476, 0.146640494718295, 0.14774949250498903, 0.13136299521680062, 0.12280573539651263, 0.11770517957994231, 0.1288080516214728, 0.11923445010365974, 0.1283607237455393, 0.1276834095249737, 0.13797157202185917, 0.14278382299360637, 0.9053192009470553, 0.8660483334673228, 0.9002098347817125, 0.975528753634753, 0.9498768151140763, 0.9445713831460156, 0.9738097338493318, 0.9546027307857413, 0.9514852738835676, 0.3378366540342965, 0.3130663362093764, 0.3216204505781177, 0.3572684762827889, 0.2847855736383835, 0.31689038997083163, 0.323797335449335, 0.31248482374204145, 0.3254843614410512, 0.7880249127743724, 0.7713646661446508, 0.7783392489367843, 0.781922848511541, 0.7876052042262797, 0.7608748436472922, 0.7765301524640645, 0.753840082182759, 0.7735915016132198, 0.3513540289877535, 0.3511431583817436, 0.3516358737271146, 0.32503692437897147, 0.2942853050383335, 0.29451520135981135, 0.2638751731166953, 0.2667503703925358, 0.38910760164481784, 0.33656152910046244, 0.021415486323483446, 0.372303148440586, 0.29153955165403256, 0.35758051996796225, 0.3383168630044149, 0.3112497595998619, 0.3264443288445539, 0.29640982305402563, 0.36588962087293875, 0.37516436571613976, 0.33201560699079147, 0.30943352556367365, 0.3327450463251007, 0.2997028325377187, 0.1391242689264065, 0.32194466356153517, 0.1483545351355391, 0.45240315623337923, 0.391995025679059, 0.4447609638044835, 0.3820254651906416, 0.3963726879422397, 0.3948852657264168, 0.38295553856407283, 0.42267364186519685, 0.4082174911438471, 0.18082875545614763, 0.2109551027866866, 0.2205809325499385, 0.11001031683602758, 0.25560786048665396, 0.24837400025029177, 0.21942997024606548, 0.20261893404103037, 0.12357702720461383, 0.23987267419518454, 0.24723294465067003, 0.28439960781731466, 0.2652380083281898, 0.2534639690956757, 0.2528464174959012, 0.27454483437409394, 0.2612543370059113, 0.2761475624756643, 0.3987109691348111, 0.4495602710821951, 0.4406913655622201, 0.6054232260012435, 0.47533578333452753, 0.4972684102428657, 0.4460480911527953, 0.3917005747927599, 0.397540183501946, 0.14677607089834532, 0.1367358116217935, 0.422478896035712, 0.12532546476573203, 0.1344847157120881, 0.1347318575860087, 0.10800363739350993, 0.13730443539785153, 0.13518870223482848, 0.2050279896955498, 0.4040796265231339, 0.32782962198705123, 0.3269608955603651, 0.30255814577067264, 0.444848699806772, 0.2296447471642451, 0.2732557627008909, 0.2466689090287728, 0.3460792704740334, 0.361252878730534, 0.3436855205734437, 0.32949183876596677, 0.3621127650035568, 0.36615005386039245, 0.3599892456795285, 0.3316229375803932, 0.36958342556268964, 0.30781149690747767, 0.33142653097099406, 0.34269916614612783, 0.29057010713019094, 0.3058052856572302, 0.332952085484867, 0.34173953289829684, 0.3342977578763938, 0.3359058879113027, 0.210382424524151, 0.21162320494434161, 0.20056311436274565, 0.2182678576315341, 0.18113146566323113, 0.19219138737727226, 0.2275732525654356, 0.1932620182214395, 0.21351789038557145, 0.431474548940182, 0.18464654569699734, 0.1907854365928764, 0.1907486642456907, 0.4720491401871061, 0.21291994520546587, 0.19953007914403353, 0.23165119402685008, 0.19911964117185255, 0.5777238853222668, 0.1819694298511585, 0.805284722941409, 0.1827188108192469, 0.6718231135370532, 0.5723426404916139, 0.16788922892198066, 0.6570687801071586, 0.6195585362245959, 0.5543602853678709, 0.5448715393087575, 0.15220068708900103, 0.6788195176683121, 0.16107315122358468, 0.20351384609295642, 0.20722171834060177, 0.15100718461893448, 0.20705058968235823, 0.183185971113362, 0.21602158923790882, 0.1810123962224095, 0.17861155362873637, 0.18552669716616188, 0.20123687293850867, 0.1758627774733471, 0.18002778909602057, 0.17720678290517244, 0.08595906469312253, 0.11005410530791415, 0.10735734276244124, 0.08471544867514658, 0.08499254432823566, 0.08600670599181426, 0.09120144232755534, 0.08786549366302465, 0.09138166510922696]}, "mutation_prompt": null}
{"id": "8332cc58-9bf2-4cfd-96b7-a95084dc96fc", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.15)  # Changed line: Increase F increment from 0.1 to 0.15\n                    self.CR = min(1.0, self.CR + 0.25)  # Changed line: Increase CR increment from 0.2 to 0.25\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Fine-tune the adaptation strategy by increasing the mutation factor increment, enhancing exploration.", "configspace": "", "generation": 55, "fitness": 0.3131607587385631, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.20.", "error": "", "parent_id": "64d840bf-6dba-4258-8b01-af452e28b857", "metadata": {"aucs": [0.42086438510626434, 0.5157225673050797, 0.465867950749285, 0.5032063456240097, 0.502684528812086, 0.47263303979875493, 0.4889859211657852, 0.45905092699849337, 0.4850543877740753, 0.28714257908396545, 0.34313065286760247, 0.26337188939312084, 0.3662835935881217, 0.29146144950061537, 0.35024367113743826, 0.3120589932055202, 0.2689782249135485, 0.33077157773032784, 0.15755408891943168, 0.29444378978350716, 0.15742269137939968, 0.34076869807572674, 0.15711537763855232, 0.13542997543864166, 0.1621638509948371, 0.35023506426195083, 0.16426017057926767, 0.14625924948022218, 0.12501606602023463, 0.1354644663999388, 0.10277807888548485, 0.12640765399913034, 0.10267385094457981, 0.1316875226242673, 0.1287747280342464, 0.12807692506982238, 0.9532431455400221, 0.9294343409497433, 0.9555974201241896, 0.98676811799101, 0.9538667287913051, 0.9404095122737225, 0.9738097338493318, 0.9727931151435046, 0.9672136740533176, 0.2972734061168687, 0.2864109719819886, 0.3034829513431254, 0.3051145792036106, 0.3103210198700823, 0.3148102517260347, 0.2851861835714562, 0.3043761762158199, 0.307427441974367, 0.6921550787053011, 0.6890015347240841, 0.35180881495965843, 0.6869045304628857, 0.6976194743903567, 0.6978860102910834, 0.694573197311686, 0.7022643016014674, 0.6860867169477396, 0.2579705575521398, 0.253250322204999, 0.25923956466131537, 0.23258816174143526, 0.28263994436187934, 0.31402204768872277, 0.24671967724663169, 0.31595810147164693, 0.33725028860867656, 0.04927309614839137, 0.30327676697537065, 0.12364667529720685, 0.292277183762091, 0.23461770922553538, 0.2820765886981187, 0.28648530342323664, 0.25474053232703486, 0.34073721658813005, 0.29628827116784473, 0.27495026172297665, 0.2701810338628058, 0.27889127906142874, 0.3379075540970089, 0.12093714954095591, 0.09223438797599959, 0.28927599354763023, 0.26825512533226403, 0.3625533894316799, 0.33029171616026176, 0.35010136486876264, 0.3457016735632359, 0.3737089845423839, 0.35927718680246856, 0.3415783793772954, 0.324274844990179, 0.38835233450906226, 0.13268135309031126, 0.10499651932542509, 0.12495102181657369, 0.1535565150965965, 0.1664773472819705, 0.1550468892874689, 0.08737418394850449, 0.14550376767118922, 0.09695831383344344, 0.2047615574048739, 0.20782338247103627, 0.21831590890922103, 0.18140623814102363, 0.210911399745777, 0.247635755588688, 0.23529751911521257, 0.21662600552471445, 0.20531642860517252, 0.4223474182480724, 0.43148875858612046, 0.446015414325744, 0.4256710962048986, 0.4531296505915695, 0.438455662976897, 0.43691237783973824, 0.388327692959641, 0.4252670539970437, 0.13161488960638235, 0.31853344602413525, 0.16104295495295284, 0.16714072544423675, 0.11266513583318138, 0.14441929839014844, 0.12932692392718492, 0.16061359338620096, 0.12830685523006868, 0.3507832106424652, 0.4314711198248118, 0.39445396892669704, 0.3964039944647725, 0.35756056603015063, 0.15820560485861057, 0.3522371010368881, 0.23087201479098207, 0.21853395890171745, 0.333689451951962, 0.346479043100136, 0.351060631560549, 0.32372039356357496, 0.3277082137625551, 0.3428129706299391, 0.33278596268423977, 0.3412567703020726, 0.33106218633557705, 0.3023753748795125, 0.3038168971560371, 0.30184335743916324, 0.29752391863011785, 0.29596082767734844, 0.28928358195474424, 0.31748636050791057, 0.2974617423403133, 0.29208045812664185, 0.22407947271192008, 0.2006643216951185, 0.25196142035378766, 0.21893053504896987, 0.23155121644236087, 0.21156304790122427, 0.20836103058231503, 0.19618334838100138, 0.20987433785242682, 0.21919707720047177, 0.2170894684497262, 0.21415070350960064, 0.22097956836006738, 0.18757594739643746, 0.38677924661113794, 0.20993584317147584, 0.1912028787201221, 0.20634969115107415, 0.15257468590750922, 0.668644588272313, 0.7349723908077708, 0.6744768044568894, 0.16589963430980514, 0.20195874575052397, 0.20436704581250975, 0.7251036331760841, 0.19957658986412885, 0.6735358345645277, 0.16417662029411062, 0.16250729106219985, 0.577872518417945, 0.20153124932195965, 0.19580634001757002, 0.20677595915028824, 0.5569522383347458, 0.20536789742124872, 0.18429345081833082, 0.176235381385616, 0.19403107362785987, 0.1934894575952345, 0.17731278557785846, 0.1847814940412511, 0.18430166618421817, 0.1853013763771374, 0.1802284926003429, 0.08602270197374473, 0.08372996916561914, 0.08288547471362506, 0.08172145171384404, 0.0947557340416606, 0.0815877639671031, 0.08721447162182927, 0.08028650931746506, 0.09875264093070657]}, "mutation_prompt": null}
{"id": "a9a42024-480a-42f1-be3b-1dfec36f258c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.25)  # Changed line: Increase CR increment from 0.2 to 0.25\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Implement a cooling schedule to gradually decrease the mutation factor F for improved convergence over iterations.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "64d840bf-6dba-4258-8b01-af452e28b857", "metadata": {"aucs": [0.45423475525930346, 0.5927976667991433, 0.4478207448727176, 0.5050373065997071, 0.4702452101766964, 0.48600792933161463, 0.47076454557405456, 0.4628399370104399, 0.4853636663808768, 0.33726603660181886, 0.33018451317248687, 0.33396336625706047, 0.4425371291857788, 0.2974828313252138, 0.4141294753826936, 0.3730189407893012, 0.30813130854410864, 0.3461288969541044, 0.16435226662354596, 0.14282092076003772, 0.16319680057437091, 0.15001804002325136, 0.16518068159824884, 0.16693403115746752, 0.12401076282336476, 0.146640494718295, 0.14774949250498903, 0.13136299521680062, 0.12280573539651263, 0.11770517957994231, 0.1288080516214728, 0.11923445010365974, 0.1283607237455393, 0.1276834095249737, 0.13797157202185917, 0.14278382299360637, 0.9053192009470553, 0.8660483334673228, 0.9002098347817125, 0.975528753634753, 0.9498768151140763, 0.9445713831460156, 0.9738097338493318, 0.9546027307857413, 0.9514852738835676, 0.3378366540342965, 0.3130663362093764, 0.3216204505781177, 0.3572684762827889, 0.2847855736383835, 0.31689038997083163, 0.323797335449335, 0.31248482374204145, 0.3254843614410512, 0.7880249127743724, 0.7713646661446508, 0.7783392489367843, 0.781922848511541, 0.7876052042262797, 0.7608748436472922, 0.7765301524640645, 0.753840082182759, 0.7735915016132198, 0.3513540289877535, 0.3511431583817436, 0.3516358737271146, 0.32503692437897147, 0.2942853050383335, 0.29451520135981135, 0.2638751731166953, 0.2667503703925358, 0.38910760164481784, 0.33656152910046244, 0.021415486323483446, 0.372303148440586, 0.29153955165403256, 0.35758051996796225, 0.3383168630044149, 0.3112497595998619, 0.3264443288445539, 0.29640982305402563, 0.36588962087293875, 0.37516436571613976, 0.33201560699079147, 0.30943352556367365, 0.3327450463251007, 0.2997028325377187, 0.1391242689264065, 0.32194466356153517, 0.1483545351355391, 0.45240315623337923, 0.391995025679059, 0.4447609638044835, 0.3820254651906416, 0.3963726879422397, 0.3948852657264168, 0.38295553856407283, 0.42267364186519685, 0.4082174911438471, 0.18082875545614763, 0.2109551027866866, 0.2205809325499385, 0.11001031683602758, 0.25560786048665396, 0.24837400025029177, 0.21942997024606548, 0.20261893404103037, 0.12357702720461383, 0.23987267419518454, 0.24723294465067003, 0.28439960781731466, 0.2652380083281898, 0.2534639690956757, 0.2528464174959012, 0.27454483437409394, 0.2612543370059113, 0.2761475624756643, 0.3987109691348111, 0.4495602710821951, 0.4406913655622201, 0.6054232260012435, 0.47533578333452753, 0.4972684102428657, 0.4460480911527953, 0.3917005747927599, 0.397540183501946, 0.14677607089834532, 0.1367358116217935, 0.422478896035712, 0.12532546476573203, 0.1344847157120881, 0.1347318575860087, 0.10800363739350993, 0.13730443539785153, 0.13518870223482848, 0.2050279896955498, 0.4040796265231339, 0.32782962198705123, 0.3269608955603651, 0.30255814577067264, 0.444848699806772, 0.2296447471642451, 0.2732557627008909, 0.2466689090287728, 0.3460792704740334, 0.361252878730534, 0.3436855205734437, 0.32949183876596677, 0.3621127650035568, 0.36615005386039245, 0.3599892456795285, 0.3316229375803932, 0.36958342556268964, 0.30781149690747767, 0.33142653097099406, 0.34269916614612783, 0.29057010713019094, 0.3058052856572302, 0.332952085484867, 0.34173953289829684, 0.3342977578763938, 0.3359058879113027, 0.210382424524151, 0.21162320494434161, 0.20056311436274565, 0.2182678576315341, 0.18113146566323113, 0.19219138737727226, 0.2275732525654356, 0.1932620182214395, 0.21351789038557145, 0.431474548940182, 0.18464654569699734, 0.1907854365928764, 0.1907486642456907, 0.4720491401871061, 0.21291994520546587, 0.19953007914403353, 0.23165119402685008, 0.19911964117185255, 0.5777238853222668, 0.1819694298511585, 0.805284722941409, 0.1827188108192469, 0.6718231135370532, 0.5723426404916139, 0.16788922892198066, 0.6570687801071586, 0.6195585362245959, 0.5543602853678709, 0.5448715393087575, 0.15220068708900103, 0.6788195176683121, 0.16107315122358468, 0.20351384609295642, 0.20722171834060177, 0.15100718461893448, 0.20705058968235823, 0.183185971113362, 0.21602158923790882, 0.1810123962224095, 0.17861155362873637, 0.18552669716616188, 0.20123687293850867, 0.1758627774733471, 0.18002778909602057, 0.17720678290517244, 0.08595906469312253, 0.11005410530791415, 0.10735734276244124, 0.08471544867514658, 0.08499254432823566, 0.08600670599181426, 0.09120144232755534, 0.08786549366302465, 0.09138166510922696]}, "mutation_prompt": null}
{"id": "8c1a61d3-2012-4edd-9ae4-1fb7c7a9dbe2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.25)  # Changed line: Increase CR increment from 0.2 to 0.25\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Implement a cooling schedule to gradually decrease the mutation factor F for improved convergence over iterations.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "64d840bf-6dba-4258-8b01-af452e28b857", "metadata": {"aucs": [0.45423475525930346, 0.5927976667991433, 0.4478207448727176, 0.5050373065997071, 0.4702452101766964, 0.48600792933161463, 0.47076454557405456, 0.4628399370104399, 0.4853636663808768, 0.33726603660181886, 0.33018451317248687, 0.33396336625706047, 0.4425371291857788, 0.2974828313252138, 0.4141294753826936, 0.3730189407893012, 0.30813130854410864, 0.3461288969541044, 0.16435226662354596, 0.14282092076003772, 0.16319680057437091, 0.15001804002325136, 0.16518068159824884, 0.16693403115746752, 0.12401076282336476, 0.146640494718295, 0.14774949250498903, 0.13136299521680062, 0.12280573539651263, 0.11770517957994231, 0.1288080516214728, 0.11923445010365974, 0.1283607237455393, 0.1276834095249737, 0.13797157202185917, 0.14278382299360637, 0.9053192009470553, 0.8660483334673228, 0.9002098347817125, 0.975528753634753, 0.9498768151140763, 0.9445713831460156, 0.9738097338493318, 0.9546027307857413, 0.9514852738835676, 0.3378366540342965, 0.3130663362093764, 0.3216204505781177, 0.3572684762827889, 0.2847855736383835, 0.31689038997083163, 0.323797335449335, 0.31248482374204145, 0.3254843614410512, 0.7880249127743724, 0.7713646661446508, 0.7783392489367843, 0.781922848511541, 0.7876052042262797, 0.7608748436472922, 0.7765301524640645, 0.753840082182759, 0.7735915016132198, 0.3513540289877535, 0.3511431583817436, 0.3516358737271146, 0.32503692437897147, 0.2942853050383335, 0.29451520135981135, 0.2638751731166953, 0.2667503703925358, 0.38910760164481784, 0.33656152910046244, 0.021415486323483446, 0.372303148440586, 0.29153955165403256, 0.35758051996796225, 0.3383168630044149, 0.3112497595998619, 0.3264443288445539, 0.29640982305402563, 0.36588962087293875, 0.37516436571613976, 0.33201560699079147, 0.30943352556367365, 0.3327450463251007, 0.2997028325377187, 0.1391242689264065, 0.32194466356153517, 0.1483545351355391, 0.45240315623337923, 0.391995025679059, 0.4447609638044835, 0.3820254651906416, 0.3963726879422397, 0.3948852657264168, 0.38295553856407283, 0.42267364186519685, 0.4082174911438471, 0.18082875545614763, 0.2109551027866866, 0.2205809325499385, 0.11001031683602758, 0.25560786048665396, 0.24837400025029177, 0.21942997024606548, 0.20261893404103037, 0.12357702720461383, 0.23987267419518454, 0.24723294465067003, 0.28439960781731466, 0.2652380083281898, 0.2534639690956757, 0.2528464174959012, 0.27454483437409394, 0.2612543370059113, 0.2761475624756643, 0.3987109691348111, 0.4495602710821951, 0.4406913655622201, 0.6054232260012435, 0.47533578333452753, 0.4972684102428657, 0.4460480911527953, 0.3917005747927599, 0.397540183501946, 0.14677607089834532, 0.1367358116217935, 0.422478896035712, 0.12532546476573203, 0.1344847157120881, 0.1347318575860087, 0.10800363739350993, 0.13730443539785153, 0.13518870223482848, 0.2050279896955498, 0.4040796265231339, 0.32782962198705123, 0.3269608955603651, 0.30255814577067264, 0.444848699806772, 0.2296447471642451, 0.2732557627008909, 0.2466689090287728, 0.3460792704740334, 0.361252878730534, 0.3436855205734437, 0.32949183876596677, 0.3621127650035568, 0.36615005386039245, 0.3599892456795285, 0.3316229375803932, 0.36958342556268964, 0.30781149690747767, 0.33142653097099406, 0.34269916614612783, 0.29057010713019094, 0.3058052856572302, 0.332952085484867, 0.34173953289829684, 0.3342977578763938, 0.3359058879113027, 0.210382424524151, 0.21162320494434161, 0.20056311436274565, 0.2182678576315341, 0.18113146566323113, 0.19219138737727226, 0.2275732525654356, 0.1932620182214395, 0.21351789038557145, 0.431474548940182, 0.18464654569699734, 0.1907854365928764, 0.1907486642456907, 0.4720491401871061, 0.21291994520546587, 0.19953007914403353, 0.23165119402685008, 0.19911964117185255, 0.5777238853222668, 0.1819694298511585, 0.805284722941409, 0.1827188108192469, 0.6718231135370532, 0.5723426404916139, 0.16788922892198066, 0.6570687801071586, 0.6195585362245959, 0.5543602853678709, 0.5448715393087575, 0.15220068708900103, 0.6788195176683121, 0.16107315122358468, 0.20351384609295642, 0.20722171834060177, 0.15100718461893448, 0.20705058968235823, 0.183185971113362, 0.21602158923790882, 0.1810123962224095, 0.17861155362873637, 0.18552669716616188, 0.20123687293850867, 0.1758627774733471, 0.18002778909602057, 0.17720678290517244, 0.08595906469312253, 0.11005410530791415, 0.10735734276244124, 0.08471544867514658, 0.08499254432823566, 0.08600670599181426, 0.09120144232755534, 0.08786549366302465, 0.09138166510922696]}, "mutation_prompt": null}
{"id": "4b583ea3-22cd-431f-bd43-bfa9c3cb7273", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.25)  # Changed line: Increase CR increment from 0.2 to 0.25\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.015)  # Changed line: Adjust CR decrement (from 0.01 to 0.015)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a dynamic crossover probability adjustment to better adapt the search process.", "configspace": "", "generation": 58, "fitness": 0.31702796360129204, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.22.", "error": "", "parent_id": "64d840bf-6dba-4258-8b01-af452e28b857", "metadata": {"aucs": [0.43537663441755603, 0.5694685896044334, 0.498226126535662, 0.479179350459629, 0.43045946442637506, 0.49683228554713954, 0.5276891824141082, 0.6953575858854577, 0.5444990033606116, 0.32922873735786984, 0.3845301441479855, 0.36092241069631503, 0.3343499013239779, 0.3377588459782044, 0.37694440893085457, 0.40126180275307266, 0.3567484897970027, 0.3700933316874775, 0.14234040026908878, 0.1361847312322394, 0.16009001107108178, 0.13402321006977114, 0.1657078512320579, 0.16726795592831312, 0.1315812051048122, 0.17074688719591047, 0.16583697809406117, 0.10501987522215628, 0.1399558246271566, 0.10475875691434211, 0.12996046899926894, 0.14205786712947643, 0.15958224954993472, 0.11831156332373138, 0.13917287161321779, 0.10728213780956308, 0.9364248496662163, 0.8656344358319776, 0.9624905985305237, 0.975528753634753, 0.9500211284626174, 0.9716402948647421, 0.943397915496227, 0.943664619899307, 0.9272126273871835, 0.36607645836222436, 0.3081845152392261, 0.29534246499522965, 0.31223912936232634, 0.3777731066372205, 0.34397832789025584, 0.3555053130676804, 0.3213730626789021, 0.3278728801555235, 0.7863475560717038, 0.7731996168084763, 0.7700007395494526, 0.7640690394763462, 0.7669339365694094, 0.7644610086886602, 0.7746490773259842, 0.7754575570536981, 0.7597545731179328, 0.33425149463451564, 0.35135927366716346, 0.2584979564780918, 0.3247563342848494, 0.27995893353857604, 0.327808806149671, 0.3149220464494279, 0.35373784138657316, 0.2742952582461592, 0.34203620968145754, 0.12762231312397887, 0.009608606641075323, 0.32615955215224046, 0.3215336766155239, 0.3288791669120059, 0.28385152013431203, 0.31338489120827806, 0.29229601208347966, 0.0877272019068761, 0.25899871266923424, 0.0805213115159491, 0.02064148340600991, 0.0494147464102207, 0.12123846002086591, 0.07541185558750862, 0.3152858757200371, 0.13255421559535785, 0.1535863889542608, 0.09949181453895506, 0.15636654354489943, 0.09945000172004315, 0.14080870283877267, 0.22588607420538453, 0.3738643241022005, 0.40271915683810555, 0.3890053708961314, 0.05879214158654522, 0.10181589785089817, 0.1312636044675004, 0.12754786494667747, 0.09393587276740967, 0.15367658544278562, 0.1477711227107995, 0.16664010269929552, 0.16767447035878358, 0.2115938188062506, 0.22457311984939632, 0.19948651775330872, 0.2720709421437416, 0.29266742932791145, 0.25813317442452766, 0.19362974890874085, 0.21478287482240843, 0.2295371592947758, 0.4596847201853287, 0.5252362066657345, 0.4635847459173821, 0.42497269071241894, 0.4976087986788226, 0.44626346088849544, 0.4457151081038906, 0.4601652079107603, 0.5069348099763208, 0.378074132012005, 0.12727168287544555, 0.17176968518273317, 0.14791230679755796, 0.12254702538818696, 0.10975698419664892, 0.1431851008524443, 0.10553369799640733, 0.12083457428530875, 0.2518644094590251, 0.1868458766839063, 0.38059876361778333, 0.41996843141354767, 0.1822889844977419, 0.1662009654115678, 0.200590962985168, 0.2982918316429367, 0.4275786381341713, 0.3455582310432136, 0.36454346774447133, 0.3621605585091119, 0.3628062807635345, 0.33572934501185214, 0.3376290597986906, 0.3441975356927587, 0.3899939140231464, 0.35878754141826497, 0.32980117428752176, 0.3225807009828636, 0.3304246066240464, 0.2637859345994048, 0.31807851252930464, 0.32568463800667125, 0.3438352038473095, 0.35397314186928885, 0.34096963193646623, 0.22566811544108423, 0.2017795788387291, 0.19367669642908591, 0.2088184575402796, 0.22851223605113413, 0.22813041670946677, 0.23547127259518585, 0.20517915631163763, 0.2155143697789932, 0.19965391846799518, 0.21448999082593467, 0.20142699163529798, 0.21157939199722597, 0.2068179237631811, 0.5466357347772568, 0.20626977515610645, 0.21989635236022564, 0.21251323586254467, 0.16609021748205544, 0.18270771015966447, 0.1692532228547987, 0.5163957984363843, 0.5571542397874317, 0.6252744799318704, 0.6248191622164256, 0.6592747951961764, 0.6607242304669105, 0.6084534287220683, 0.20521659104611634, 0.2007398336251135, 0.6834913235516625, 0.1594177040695316, 0.5646459535649625, 0.148797000720424, 0.12455022547230854, 0.20612623801143914, 0.21347520188579316, 0.18069730582056398, 0.18410686843386548, 0.18632698885930254, 0.18277277929825153, 0.18612916585809114, 0.18128946168187, 0.1815592952335171, 0.2008567026854985, 0.09557270015868202, 0.09182012258659067, 0.07871855363552804, 0.0824159243652619, 0.08604529413997608, 0.09490448790644401, 0.08765191938155825, 0.08109188328405148, 0.09405512209420053]}, "mutation_prompt": null}
{"id": "a112617d-2d4e-4a8f-b0e0-daafb6c54e80", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.25)  # Changed line: Increase CR increment from 0.2 to 0.25\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Implement a cooling schedule to gradually decrease the mutation factor F for improved convergence over iterations.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "64d840bf-6dba-4258-8b01-af452e28b857", "metadata": {"aucs": [0.45423475525930346, 0.5927976667991433, 0.4478207448727176, 0.5050373065997071, 0.4702452101766964, 0.48600792933161463, 0.47076454557405456, 0.4628399370104399, 0.4853636663808768, 0.33726603660181886, 0.33018451317248687, 0.33396336625706047, 0.4425371291857788, 0.2974828313252138, 0.4141294753826936, 0.3730189407893012, 0.30813130854410864, 0.3461288969541044, 0.16435226662354596, 0.14282092076003772, 0.16319680057437091, 0.15001804002325136, 0.16518068159824884, 0.16693403115746752, 0.12401076282336476, 0.146640494718295, 0.14774949250498903, 0.13136299521680062, 0.12280573539651263, 0.11770517957994231, 0.1288080516214728, 0.11923445010365974, 0.1283607237455393, 0.1276834095249737, 0.13797157202185917, 0.14278382299360637, 0.9053192009470553, 0.8660483334673228, 0.9002098347817125, 0.975528753634753, 0.9498768151140763, 0.9445713831460156, 0.9738097338493318, 0.9546027307857413, 0.9514852738835676, 0.3378366540342965, 0.3130663362093764, 0.3216204505781177, 0.3572684762827889, 0.2847855736383835, 0.31689038997083163, 0.323797335449335, 0.31248482374204145, 0.3254843614410512, 0.7880249127743724, 0.7713646661446508, 0.7783392489367843, 0.781922848511541, 0.7876052042262797, 0.7608748436472922, 0.7765301524640645, 0.753840082182759, 0.7735915016132198, 0.3513540289877535, 0.3511431583817436, 0.3516358737271146, 0.32503692437897147, 0.2942853050383335, 0.29451520135981135, 0.2638751731166953, 0.2667503703925358, 0.38910760164481784, 0.33656152910046244, 0.021415486323483446, 0.372303148440586, 0.29153955165403256, 0.35758051996796225, 0.3383168630044149, 0.3112497595998619, 0.3264443288445539, 0.29640982305402563, 0.36588962087293875, 0.37516436571613976, 0.33201560699079147, 0.30943352556367365, 0.3327450463251007, 0.2997028325377187, 0.1391242689264065, 0.32194466356153517, 0.1483545351355391, 0.45240315623337923, 0.391995025679059, 0.4447609638044835, 0.3820254651906416, 0.3963726879422397, 0.3948852657264168, 0.38295553856407283, 0.42267364186519685, 0.4082174911438471, 0.18082875545614763, 0.2109551027866866, 0.2205809325499385, 0.11001031683602758, 0.25560786048665396, 0.24837400025029177, 0.21942997024606548, 0.20261893404103037, 0.12357702720461383, 0.23987267419518454, 0.24723294465067003, 0.28439960781731466, 0.2652380083281898, 0.2534639690956757, 0.2528464174959012, 0.27454483437409394, 0.2612543370059113, 0.2761475624756643, 0.3987109691348111, 0.4495602710821951, 0.4406913655622201, 0.6054232260012435, 0.47533578333452753, 0.4972684102428657, 0.4460480911527953, 0.3917005747927599, 0.397540183501946, 0.14677607089834532, 0.1367358116217935, 0.422478896035712, 0.12532546476573203, 0.1344847157120881, 0.1347318575860087, 0.10800363739350993, 0.13730443539785153, 0.13518870223482848, 0.2050279896955498, 0.4040796265231339, 0.32782962198705123, 0.3269608955603651, 0.30255814577067264, 0.444848699806772, 0.2296447471642451, 0.2732557627008909, 0.2466689090287728, 0.3460792704740334, 0.361252878730534, 0.3436855205734437, 0.32949183876596677, 0.3621127650035568, 0.36615005386039245, 0.3599892456795285, 0.3316229375803932, 0.36958342556268964, 0.30781149690747767, 0.33142653097099406, 0.34269916614612783, 0.29057010713019094, 0.3058052856572302, 0.332952085484867, 0.34173953289829684, 0.3342977578763938, 0.3359058879113027, 0.210382424524151, 0.21162320494434161, 0.20056311436274565, 0.2182678576315341, 0.18113146566323113, 0.19219138737727226, 0.2275732525654356, 0.1932620182214395, 0.21351789038557145, 0.431474548940182, 0.18464654569699734, 0.1907854365928764, 0.1907486642456907, 0.4720491401871061, 0.21291994520546587, 0.19953007914403353, 0.23165119402685008, 0.19911964117185255, 0.5777238853222668, 0.1819694298511585, 0.805284722941409, 0.1827188108192469, 0.6718231135370532, 0.5723426404916139, 0.16788922892198066, 0.6570687801071586, 0.6195585362245959, 0.5543602853678709, 0.5448715393087575, 0.15220068708900103, 0.6788195176683121, 0.16107315122358468, 0.20351384609295642, 0.20722171834060177, 0.15100718461893448, 0.20705058968235823, 0.183185971113362, 0.21602158923790882, 0.1810123962224095, 0.17861155362873637, 0.18552669716616188, 0.20123687293850867, 0.1758627774733471, 0.18002778909602057, 0.17720678290517244, 0.08595906469312253, 0.11005410530791415, 0.10735734276244124, 0.08471544867514658, 0.08499254432823566, 0.08600670599181426, 0.09120144232755534, 0.08786549366302465, 0.09138166510922696]}, "mutation_prompt": null}
{"id": "77e60f29-0896-4764-a8a5-e049f3d8db3b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.25)  # Changed line: Increase CR increment from 0.2 to 0.25\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Implement a cooling schedule to gradually decrease the mutation factor F for improved convergence over iterations.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "64d840bf-6dba-4258-8b01-af452e28b857", "metadata": {"aucs": [0.45423475525930346, 0.5927976667991433, 0.4478207448727176, 0.5050373065997071, 0.4702452101766964, 0.48600792933161463, 0.47076454557405456, 0.4628399370104399, 0.4853636663808768, 0.33726603660181886, 0.33018451317248687, 0.33396336625706047, 0.4425371291857788, 0.2974828313252138, 0.4141294753826936, 0.3730189407893012, 0.30813130854410864, 0.3461288969541044, 0.16435226662354596, 0.14282092076003772, 0.16319680057437091, 0.15001804002325136, 0.16518068159824884, 0.16693403115746752, 0.12401076282336476, 0.146640494718295, 0.14774949250498903, 0.13136299521680062, 0.12280573539651263, 0.11770517957994231, 0.1288080516214728, 0.11923445010365974, 0.1283607237455393, 0.1276834095249737, 0.13797157202185917, 0.14278382299360637, 0.9053192009470553, 0.8660483334673228, 0.9002098347817125, 0.975528753634753, 0.9498768151140763, 0.9445713831460156, 0.9738097338493318, 0.9546027307857413, 0.9514852738835676, 0.3378366540342965, 0.3130663362093764, 0.3216204505781177, 0.3572684762827889, 0.2847855736383835, 0.31689038997083163, 0.323797335449335, 0.31248482374204145, 0.3254843614410512, 0.7880249127743724, 0.7713646661446508, 0.7783392489367843, 0.781922848511541, 0.7876052042262797, 0.7608748436472922, 0.7765301524640645, 0.753840082182759, 0.7735915016132198, 0.3513540289877535, 0.3511431583817436, 0.3516358737271146, 0.32503692437897147, 0.2942853050383335, 0.29451520135981135, 0.2638751731166953, 0.2667503703925358, 0.38910760164481784, 0.33656152910046244, 0.021415486323483446, 0.372303148440586, 0.29153955165403256, 0.35758051996796225, 0.3383168630044149, 0.3112497595998619, 0.3264443288445539, 0.29640982305402563, 0.36588962087293875, 0.37516436571613976, 0.33201560699079147, 0.30943352556367365, 0.3327450463251007, 0.2997028325377187, 0.1391242689264065, 0.32194466356153517, 0.1483545351355391, 0.45240315623337923, 0.391995025679059, 0.4447609638044835, 0.3820254651906416, 0.3963726879422397, 0.3948852657264168, 0.38295553856407283, 0.42267364186519685, 0.4082174911438471, 0.18082875545614763, 0.2109551027866866, 0.2205809325499385, 0.11001031683602758, 0.25560786048665396, 0.24837400025029177, 0.21942997024606548, 0.20261893404103037, 0.12357702720461383, 0.23987267419518454, 0.24723294465067003, 0.28439960781731466, 0.2652380083281898, 0.2534639690956757, 0.2528464174959012, 0.27454483437409394, 0.2612543370059113, 0.2761475624756643, 0.3987109691348111, 0.4495602710821951, 0.4406913655622201, 0.6054232260012435, 0.47533578333452753, 0.4972684102428657, 0.4460480911527953, 0.3917005747927599, 0.397540183501946, 0.14677607089834532, 0.1367358116217935, 0.422478896035712, 0.12532546476573203, 0.1344847157120881, 0.1347318575860087, 0.10800363739350993, 0.13730443539785153, 0.13518870223482848, 0.2050279896955498, 0.4040796265231339, 0.32782962198705123, 0.3269608955603651, 0.30255814577067264, 0.444848699806772, 0.2296447471642451, 0.2732557627008909, 0.2466689090287728, 0.3460792704740334, 0.361252878730534, 0.3436855205734437, 0.32949183876596677, 0.3621127650035568, 0.36615005386039245, 0.3599892456795285, 0.3316229375803932, 0.36958342556268964, 0.30781149690747767, 0.33142653097099406, 0.34269916614612783, 0.29057010713019094, 0.3058052856572302, 0.332952085484867, 0.34173953289829684, 0.3342977578763938, 0.3359058879113027, 0.210382424524151, 0.21162320494434161, 0.20056311436274565, 0.2182678576315341, 0.18113146566323113, 0.19219138737727226, 0.2275732525654356, 0.1932620182214395, 0.21351789038557145, 0.431474548940182, 0.18464654569699734, 0.1907854365928764, 0.1907486642456907, 0.4720491401871061, 0.21291994520546587, 0.19953007914403353, 0.23165119402685008, 0.19911964117185255, 0.5777238853222668, 0.1819694298511585, 0.805284722941409, 0.1827188108192469, 0.6718231135370532, 0.5723426404916139, 0.16788922892198066, 0.6570687801071586, 0.6195585362245959, 0.5543602853678709, 0.5448715393087575, 0.15220068708900103, 0.6788195176683121, 0.16107315122358468, 0.20351384609295642, 0.20722171834060177, 0.15100718461893448, 0.20705058968235823, 0.183185971113362, 0.21602158923790882, 0.1810123962224095, 0.17861155362873637, 0.18552669716616188, 0.20123687293850867, 0.1758627774733471, 0.18002778909602057, 0.17720678290517244, 0.08595906469312253, 0.11005410530791415, 0.10735734276244124, 0.08471544867514658, 0.08499254432823566, 0.08600670599181426, 0.09120144232755534, 0.08786549366302465, 0.09138166510922696]}, "mutation_prompt": null}
{"id": "545e4b3a-748c-485d-b073-d64b6ea0f5c2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.35)  # Changed line: Increase CR increment from 0.25 to 0.35\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adjust the crossover probability (CR) increment more aggressively to enhance exploration.", "configspace": "", "generation": 61, "fitness": 0.33972926548717397, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.21.", "error": "", "parent_id": "64d840bf-6dba-4258-8b01-af452e28b857", "metadata": {"aucs": [0.45423475525930346, 0.5927976667991433, 0.4478207448727176, 0.5050373065997071, 0.4702452101766964, 0.48600792933161463, 0.47076454557405456, 0.4628399370104399, 0.4853636663808768, 0.33726603660181886, 0.33018451317248687, 0.33396336625706047, 0.4425371291857788, 0.2974828313252138, 0.4141294753826936, 0.3730189407893012, 0.30813130854410864, 0.3461288969541044, 0.16435226662354596, 0.14282092076003772, 0.16319680057437091, 0.15001804002325136, 0.16518068159824884, 0.16693403115746752, 0.12401076282336476, 0.146640494718295, 0.14774949250498903, 0.13136299521680062, 0.12263806891088969, 0.11770517957994231, 0.1288080516214728, 0.11923445010365974, 0.1283607237455393, 0.1276834095249737, 0.13797157202185917, 0.14278382299360637, 0.9053192009470553, 0.8660483334673228, 0.9002098347817125, 0.975528753634753, 0.9498768151140763, 0.9445713831460156, 0.9738097338493318, 0.9546027307857413, 0.9514852738835676, 0.3378366540342965, 0.3130663362093764, 0.3216204505781177, 0.3572684762827889, 0.2847855736383835, 0.3390576964849119, 0.323797335449335, 0.31248482374204145, 0.3254843614410512, 0.7880249127743724, 0.7758175415326543, 0.7783392489367843, 0.781922848511541, 0.7876052042262797, 0.7608748436472922, 0.7765301524640645, 0.753840082182759, 0.7735915016132198, 0.3513540289877535, 0.3511431583817436, 0.38881576447906285, 0.32503692437897147, 0.2942853050383335, 0.29451520135981135, 0.2638751731166953, 0.2667503703925358, 0.38910760164481784, 0.33656152910046244, 0.021415486323483446, 0.372303148440586, 0.29153955165403256, 0.35758051996796225, 0.3383168630044149, 0.3112497595998619, 0.3264443288445539, 0.29640982305402563, 0.36588962087293875, 0.37516436571613976, 0.33201560699079147, 0.30943352556367365, 0.3262494890216736, 0.2997028325377187, 0.3907390934044397, 0.32194466356153517, 0.22796188537421458, 0.45240315623337923, 0.391995025679059, 0.4447609638044835, 0.3820254651906416, 0.3826218333965329, 0.4067483142978534, 0.38295553856407283, 0.3900928423540908, 0.36603894508716717, 0.17625367710628392, 0.2109551027866866, 0.2205809325499385, 0.22380315548455176, 0.27971691250337327, 0.24837400025029177, 0.21942997024606548, 0.2071870123831504, 0.12357702720461383, 0.23987267419518454, 0.24723294465067003, 0.28439960781731466, 0.2652380083281898, 0.2534639690956757, 0.2901810812946989, 0.2678444904616174, 0.2612543370059113, 0.2761475624756643, 0.3987109691348111, 0.4495602710821951, 0.4406913655622201, 0.6054232260012435, 0.47533578333452753, 0.4972684102428657, 0.4460480911527953, 0.3917005747927599, 0.397540183501946, 0.14677607089834532, 0.1367358116217935, 0.17582005229186248, 0.12532546476573203, 0.1344847157120881, 0.1347318575860087, 0.10800363739350993, 0.13730443539785153, 0.13518870223482848, 0.2050279896955498, 0.4508391046717215, 0.3178774564801511, 0.3269608955603651, 0.40782590221522674, 0.444848699806772, 0.26668666247989925, 0.2732557627008909, 0.2466689090287728, 0.3460792704740334, 0.361252878730534, 0.3436855205734437, 0.32949183876596677, 0.3621127650035568, 0.36615005386039245, 0.3599892456795285, 0.3316229375803932, 0.36958342556268964, 0.30781149690747767, 0.33142653097099406, 0.34269916614612783, 0.29057010713019094, 0.3058052856572302, 0.332952085484867, 0.34173953289829684, 0.3242271853737194, 0.3359058879113027, 0.22613597482719083, 0.21910704009662563, 0.20853688730891606, 0.23279687908033264, 0.1996675940732865, 0.20849799083872966, 0.20629088373239002, 0.20250849847632868, 0.21712490380545602, 0.431474548940182, 0.18464654569699734, 0.1907854365928764, 0.1907486642456907, 0.4720491401871061, 0.21291994520546587, 0.19953007914403353, 0.23165119402685008, 0.19911964117185255, 0.5777238853222668, 0.1819694298511585, 0.805284722941409, 0.1827188108192469, 0.6718231135370532, 0.7342224072668191, 0.16788922892198066, 0.6570687801071586, 0.6195585362245959, 0.5543602853678709, 0.5448715393087575, 0.15220068708900103, 0.6788195176683121, 0.16107315122358468, 0.20351384609295642, 0.20722171834060177, 0.15100718461893448, 0.20705058968235823, 0.19291903330483506, 0.1927668071191252, 0.18051616448412133, 0.1804748863163672, 0.19290455161222564, 0.18847986626923618, 0.17334847366521866, 0.19250133426298022, 0.18740139095833652, 0.09666082236714824, 0.10126582876367973, 0.10604509092083714, 0.09250812907863437, 0.08016757558078114, 0.08723435933669532, 0.08754455264720873, 0.09042208314581235, 0.08687859416680477]}, "mutation_prompt": null}
{"id": "4c8f72e8-6ea9-4d10-83b9-27a0c2c73dc8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.15)  # Changed line: Increase F increment from 0.1 to 0.15\n                    self.CR = min(1.0, self.CR + 0.35)  # Changed line: Increase CR increment from 0.25 to 0.35\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adjust the mutation scaling factor increment more aggressively to enhance exploration.", "configspace": "", "generation": 62, "fitness": 0.31564749767274386, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.20.", "error": "", "parent_id": "545e4b3a-748c-485d-b073-d64b6ea0f5c2", "metadata": {"aucs": [0.42086438510626434, 0.5157225673050797, 0.465867950749285, 0.5032063456240097, 0.502684528812086, 0.47263303979875493, 0.4889859211657852, 0.45905092699849337, 0.4850543877740753, 0.28714257908396545, 0.34313065286760247, 0.26337188939312084, 0.3662835935881217, 0.29146144950061537, 0.35024367113743826, 0.3120589932055202, 0.2689782249135485, 0.33077157773032784, 0.15755408891943168, 0.29444378978350716, 0.15742269137939968, 0.28697906982414856, 0.15711537763855232, 0.13542997543864166, 0.1621638509948371, 0.35023506426195083, 0.16426017057926767, 0.14625924948022218, 0.13370874365786167, 0.1354644663999388, 0.10277807888548485, 0.12640765399913034, 0.10267385094457981, 0.1316875226242673, 0.1287747280342464, 0.12807692506982238, 0.9532431455400221, 0.9294343409497433, 0.9555974201241896, 0.98676811799101, 0.9538667287913051, 0.9404095122737225, 0.9738097338493318, 0.9727931151435046, 0.9672136740533176, 0.2972734061168687, 0.2864109719819886, 0.3034829513431254, 0.3051145792036106, 0.3103210198700823, 0.3148102517260347, 0.2851861835714562, 0.3043761762158199, 0.307427441974367, 0.7287278810916313, 0.6890015347240841, 0.35180881495965843, 0.6869045304628857, 0.6976194743903567, 0.7369364995669909, 0.694573197311686, 0.7022643016014674, 0.6860867169477396, 0.2579705575521398, 0.253250322204999, 0.28165017482456645, 0.23258816174143526, 0.2860056520539451, 0.31402204768872277, 0.24671967724663169, 0.31595810147164693, 0.33725028860867656, 0.04927309614839137, 0.30327676697537065, 0.12364667529720685, 0.292277183762091, 0.23461770922553538, 0.2766305878397469, 0.34165375713970547, 0.25474053232703486, 0.2675967089320349, 0.29628827116784473, 0.27495026172297665, 0.28083684513036955, 0.27573908958303295, 0.2704437520293931, 0.24592958735830572, 0.28479927658218385, 0.28927599354763023, 0.2793616051198913, 0.3899192565571322, 0.42343163433081155, 0.35713285134091877, 0.27109695702748093, 0.3466265582883391, 0.35927718680246856, 0.325305740714534, 0.35342746165498584, 0.38835233450906226, 0.16096211331105803, 0.11132255882045505, 0.12495102181657369, 0.1535565150965965, 0.13896661280293865, 0.1550468892874689, 0.11999971245524177, 0.1469206527317254, 0.10086960338461215, 0.212155909232559, 0.20811893599684783, 0.22293035429750474, 0.18361474453287974, 0.2250722127912771, 0.23651193141512872, 0.22724453638358755, 0.21662600552471445, 0.24367905926019418, 0.4223474182480724, 0.43148875858612046, 0.4532970750754618, 0.4256710962048986, 0.4531296505915695, 0.438455662976897, 0.43691237783973824, 0.388327692959641, 0.4252670539970437, 0.13161488960638235, 0.31853344602413525, 0.16104295495295284, 0.16714072544423675, 0.11266513583318138, 0.1443953740577013, 0.12937627214382041, 0.16061359338620096, 0.12819788040031033, 0.3507832106424652, 0.39261986259080506, 0.4845071649515992, 0.4077513703997949, 0.40474742370198835, 0.246720560990901, 0.3522371010368881, 0.21173978890379042, 0.2431732682426221, 0.333689451951962, 0.346479043100136, 0.351060631560549, 0.32725106753891, 0.336248262851109, 0.3428129706299391, 0.33396236580197236, 0.3412567703020726, 0.36042643364913896, 0.3171871288220137, 0.31115252659231174, 0.30184335743916324, 0.29752391863011785, 0.3057271163620958, 0.2879535958176598, 0.2998965997866908, 0.30187600977622053, 0.28440948609733363, 0.21039221387221607, 0.20455903677880127, 0.2161893814710707, 0.22103700901201873, 0.20390855246967454, 0.19639351508467606, 0.20425560692381062, 0.19929832150906945, 0.21580511820756298, 0.21919707720047177, 0.2170894684497262, 0.21390070144200912, 0.22097956836006738, 0.18733770445983022, 0.38677924661113794, 0.20993584317147584, 0.1912028787201221, 0.20634969115107415, 0.15257468590750922, 0.5245153523228866, 0.7349723908077708, 0.6744768044568894, 0.16589938796790304, 0.20195874575052397, 0.20436704581250975, 0.7251036331760841, 0.19957658986412885, 0.6735358345645277, 0.16417662029411062, 0.16250729106219985, 0.577872518417945, 0.20153124932195965, 0.19676934865044926, 0.20677595915028824, 0.5569522383347458, 0.20536789742124872, 0.18846609699241978, 0.1860435472358949, 0.18178958226178643, 0.1934894575952345, 0.1881175155493383, 0.17918162253172742, 0.19599466038528934, 0.191510242626041, 0.18298461203300564, 0.0918751432168099, 0.08902186190347261, 0.08548652896933562, 0.08522488786540039, 0.09323304622604578, 0.08808541305664652, 0.08742037773988598, 0.08905813657504824, 0.10553695177818967]}, "mutation_prompt": null}
{"id": "c129e113-ce5f-47b7-b189-3e4e3966a1d7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.35)  # Changed line: Increase CR increment from 0.25 to 0.35\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - (0.03 * (1 - self.evaluations/self.budget)))  # Changed line: Adapt mutation factor decrement based on iteration progress\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration by modifying the mutation factor decrement to adaptively adjust based on the current iteration.", "configspace": "", "generation": 63, "fitness": 0.32545735225727157, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.21.", "error": "", "parent_id": "545e4b3a-748c-485d-b073-d64b6ea0f5c2", "metadata": {"aucs": [0.5955196580756063, 0.632107481034001, 0.49596025730486704, 0.6837373862332126, 0.44589672162091454, 0.4559987558606423, 0.5376363046519093, 0.512554220812502, 0.5603613908114815, 0.28535041002870665, 0.31887173061519514, 0.2778923135975754, 0.29925529759043656, 0.30354101514939724, 0.35880927805164575, 0.3276375122218895, 0.34870977790783053, 0.28258773385031655, 0.38186059970875663, 0.1612706106029318, 0.15939247599059658, 0.12920103241509406, 0.45205636485649425, 0.29815377420322753, 0.16401170682573463, 0.15836316309001408, 0.4594174585284194, 0.11295917570641378, 0.13183428592789914, 0.10526436827029062, 0.10564648531038145, 0.14926368257540124, 0.12506546916946115, 0.136571338182223, 0.13205661780346367, 0.1316370764092668, 0.9463036384213381, 0.9092125768295234, 0.9118070991824355, 0.97553230263937, 0.9533879499226722, 0.9418995537208125, 0.9738095700862194, 0.9589824632541986, 0.952405510733313, 0.3246279619510758, 0.3071924760894468, 0.3300429109672822, 0.3383336057936853, 0.34175114600065304, 0.4107875360485598, 0.3119655922288612, 0.3430595011777867, 0.32398816810010267, 0.730704477896391, 0.7277152900930308, 0.7169172938613544, 0.7383036950026355, 0.7309109490106718, 0.7646030332352642, 0.7340330195338327, 0.7104815386808024, 0.35997430538844144, 0.23899021175703417, 0.29792175034991986, 0.28618318161450684, 0.2893897374065515, 0.26166308024380414, 0.23515169905922884, 0.24811534733730167, 0.2832062747433862, 0.3281456136590707, 0.4068362759711739, 0.021755385822628703, 0.3396592492892575, 0.26423724250581193, 0.22130147809717804, 0.26157086636060634, 0.265784232526191, 0.2608757794057779, 0.30653281674049826, 0.19888738485502233, 0.20566376982531398, 0.1683529097181694, 0.15434478335172952, 0.12019276929295863, 0.17266435159510307, 0.21527424274668083, 0.1690065530153645, 0.1392571073651896, 0.3815696553789193, 0.43739635934103593, 0.4035131534112608, 0.3264685539697092, 0.37028934392089463, 0.36468425454433107, 0.35884684295845914, 0.34636959442867454, 0.38631156954038137, 0.1162591389401667, 0.10307315528391081, 0.11142117167940546, 0.07860062779209587, 0.06206348825424757, 0.10910811443243618, 0.10106556370016206, 0.10608332561902756, 0.10416957887853151, 0.17894390144846462, 0.1822864622788194, 0.17349038002008543, 0.1941664789399805, 0.1855801501453157, 0.19975391058871028, 0.17943724188801058, 0.16637205272830757, 0.20089831534541036, 0.460869875908968, 0.40247414946343174, 0.4389514790026826, 0.48378566209020757, 0.4559311400280699, 0.45122436349543005, 0.47272400807830095, 0.4283551560419998, 0.44740353946599476, 0.11053228387317426, 0.12326993571588174, 0.10934420101867048, 0.129956122113829, 0.14241601680727523, 0.14897268097517824, 0.1427365792134322, 0.12202035174638859, 0.1464849742866503, 0.2200649199674668, 0.4618177153671702, 0.21654976609151189, 0.46476211830929903, 0.4410521361396963, 0.43534666412179435, 0.412113742872664, 0.23567066181225027, 0.3624372751341598, 0.35353738756420794, 0.3235867276010801, 0.3687957499310226, 0.3494708947671529, 0.3416886881760035, 0.33779194798755274, 0.3476746999924516, 0.33722443083716425, 0.3458580496016902, 0.316902977161454, 0.3103585078206226, 0.30778341617545835, 0.3055564816075842, 0.31459649473523743, 0.3281490996380899, 0.3316749560437422, 0.31645512505107387, 0.2994450618048481, 0.2042652818359123, 0.2582932960650375, 0.2286523574073246, 0.20078775947452565, 0.19516252040680027, 0.21062964858559186, 0.20999978252808904, 0.2244161358021971, 0.2011555034331135, 0.2230525558605717, 0.22409601762859543, 0.44574603455601747, 0.22614917261920986, 0.2121097629088191, 0.20854577686227405, 0.22698002963533603, 0.21898266746701978, 0.43431946193273574, 0.19185232268430652, 0.18213819514722984, 0.55390033035579, 0.7736022356217478, 0.5579303090090275, 0.7480083453401505, 0.16613205712769086, 0.7489346398563865, 0.8013410068700572, 0.5108796773262921, 0.2038863590729446, 0.6721212449544605, 0.6676381274119871, 0.1593020925629417, 0.16249818622460366, 0.20515107851377, 0.15103922344922616, 0.2086018377793175, 0.18250931070391896, 0.17976905695503187, 0.18235916022438903, 0.21276691476800413, 0.18577107369173496, 0.1879584850749204, 0.19913643922266655, 0.17893202971997146, 0.2120514199744099, 0.08477527828244724, 0.0975468080839077, 0.09289148282028659, 0.09703531241029195, 0.08554653886390662, 0.08637859600919529, 0.10586336111692507, 0.12179156062850927, 0.10921343210885293]}, "mutation_prompt": null}
{"id": "6f498457-7ba3-4433-9296-c3d70af2505c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.35)  # Changed line: Increase CR increment from 0.25 to 0.35\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.70))  # Changed line: Slightly faster reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Slightly increase the gradient of dynamic population size reduction to enhance convergence speed while preserving diversity.", "configspace": "", "generation": 64, "fitness": 0.33657690287103936, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.20.", "error": "", "parent_id": "545e4b3a-748c-485d-b073-d64b6ea0f5c2", "metadata": {"aucs": [0.4609493082870919, 0.42455106636847595, 0.4617491390992068, 0.48491867749046214, 0.43817745775808536, 0.4887109164137178, 0.4586352584189909, 0.4336713567345887, 0.5006729283885012, 0.3305267906037124, 0.36786340227046277, 0.3988149751049833, 0.3546162755593373, 0.3176970947671861, 0.34047534407054647, 0.33064935712155563, 0.3088699826139295, 0.3207480975240946, 0.16432882455332798, 0.14282207146610448, 0.1631820405908727, 0.15002885064584082, 0.1651984635079703, 0.1669233882260116, 0.12400921016060407, 0.1466346964875771, 0.14774928943372856, 0.13136487358804227, 0.12263881321358372, 0.11770747800539594, 0.12881765412443225, 0.11922875712768277, 0.12834195030302142, 0.12768823817057728, 0.13796930782425676, 0.14276363091492783, 0.9053192009470553, 0.8660483334673228, 0.9002098347817125, 0.975528753634753, 0.9498768151140763, 0.9445713831460156, 0.9738097338493318, 0.9546027307857413, 0.9514852738835676, 0.3269490365343706, 0.31961763118915765, 0.3214533516626781, 0.3092223219796211, 0.2943348808440307, 0.32620037451738915, 0.3107178477644098, 0.3241539221757296, 0.3300811663719091, 0.7880249127743724, 0.7758175415326543, 0.7783392489367843, 0.781922848511541, 0.7876052042262797, 0.7608748436472922, 0.7765301524640645, 0.753840082182759, 0.7735915016132198, 0.3775849264373051, 0.31792851573142, 0.4102105795942439, 0.3272654903725005, 0.2969116088605126, 0.33432393447510633, 0.26565285951177864, 0.2460696444619369, 0.37184866632001157, 0.3322298637725185, 0.021415487608228645, 0.3465864727196706, 0.3466635188389199, 0.3160802773531397, 0.3176799571804725, 0.2733126808095704, 0.31575070607696676, 0.2942141530351051, 0.32702974812526175, 0.3309693263794733, 0.3533925249973998, 0.30943352556367365, 0.3189963015987467, 0.30594518086096445, 0.3540412383057536, 0.31601026596720483, 0.22942417121899594, 0.4234374165803978, 0.391995025679059, 0.4455022463271582, 0.41578444875364484, 0.3522215129751731, 0.4386900969624806, 0.37349510575067446, 0.4262990771618249, 0.3832429632158112, 0.1812298221402019, 0.21344789697303834, 0.2107193675348994, 0.22573368433805974, 0.2548809320883708, 0.252907785606876, 0.23426989991509461, 0.20457935378165082, 0.12357702720461383, 0.25653504191853604, 0.27916516583306417, 0.25620515091823615, 0.2582282479155239, 0.25936079199068296, 0.2664345030596743, 0.2871238582086776, 0.2645546552384471, 0.2609793544588592, 0.41820437607430194, 0.4048836484928593, 0.46674551779571716, 0.4361067092728774, 0.47665893908551193, 0.5015943359601119, 0.4229968258372002, 0.4300971645973083, 0.45785110637732274, 0.1467878950501279, 0.13673561685302704, 0.17576961877709907, 0.12532661878318596, 0.13449256730253456, 0.13473702750866778, 0.10799938674211029, 0.1373036939969372, 0.13518150481364133, 0.2044703127286901, 0.3907688125166896, 0.3226952820321395, 0.32591198813366995, 0.41049720202714013, 0.3849809940991107, 0.26886196550493213, 0.2757150617060805, 0.24776035712516953, 0.35036513081074006, 0.3520793897009509, 0.3379977166281858, 0.325416142404896, 0.37395460501738076, 0.3714116599000341, 0.36295909798662473, 0.3291688375423595, 0.3563635544426764, 0.318101435080818, 0.3345085264461233, 0.33081415778855827, 0.30205463768840635, 0.3193108635611095, 0.36493298786358697, 0.32588199363418635, 0.3520262197876809, 0.3347610553883459, 0.22613597482719083, 0.21910704009662563, 0.20853688730891606, 0.23279687908033264, 0.1996675940732865, 0.20849799083872966, 0.20629088373239002, 0.20250849847632868, 0.21712490380545602, 0.460063899410604, 0.1845944348408156, 0.19078798830752852, 0.19073556336796027, 0.42500926729578037, 0.21286943605973774, 0.199540138891384, 0.23168003455160868, 0.19903598712667459, 0.7122522370811024, 0.18196461884224002, 0.6160425105656324, 0.18272055632144324, 0.5903052047388296, 0.610318738252088, 0.16788943452910388, 0.7261613124440436, 0.7196565597258211, 0.6788527202481529, 0.6063591152754776, 0.15219101721185013, 0.569850909639283, 0.1610716798110592, 0.20350876895049108, 0.20721223498949615, 0.15099023083465524, 0.20700093682299026, 0.19291903330483506, 0.1927668071191252, 0.18051616448412133, 0.1804748863163672, 0.19290455161222564, 0.18847986626923618, 0.17334847366521866, 0.19250133426298022, 0.18740139095833652, 0.09666467127550205, 0.10126582876367973, 0.1060420347306632, 0.09250812907863437, 0.08016757558078114, 0.08723435933669532, 0.08754455264720873, 0.09042208314581235, 0.08687859416680477]}, "mutation_prompt": null}
{"id": "c2d9670b-5a1a-4ea5-b973-ab1fc9b545b0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.35)  # Changed line: Increase CR increment from 0.25 to 0.35\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adjust the crossover probability (CR) increment more aggressively to enhance exploration.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "545e4b3a-748c-485d-b073-d64b6ea0f5c2", "metadata": {"aucs": [0.45423475525930346, 0.5927976667991433, 0.4478207448727176, 0.5050373065997071, 0.4702452101766964, 0.48600792933161463, 0.47076454557405456, 0.4628399370104399, 0.4853636663808768, 0.33726603660181886, 0.33018451317248687, 0.33396336625706047, 0.4425371291857788, 0.2974828313252138, 0.4141294753826936, 0.3730189407893012, 0.30813130854410864, 0.3461288969541044, 0.16435226662354596, 0.14282092076003772, 0.16319680057437091, 0.15001804002325136, 0.16518068159824884, 0.16693403115746752, 0.12401076282336476, 0.146640494718295, 0.14774949250498903, 0.13136299521680062, 0.12263806891088969, 0.11770517957994231, 0.1288080516214728, 0.11923445010365974, 0.1283607237455393, 0.1276834095249737, 0.13797157202185917, 0.14278382299360637, 0.9053192009470553, 0.8660483334673228, 0.9002098347817125, 0.975528753634753, 0.9498768151140763, 0.9445713831460156, 0.9738097338493318, 0.9546027307857413, 0.9514852738835676, 0.3378366540342965, 0.3130663362093764, 0.3216204505781177, 0.3572684762827889, 0.2847855736383835, 0.3390576964849119, 0.323797335449335, 0.31248482374204145, 0.3254843614410512, 0.7880249127743724, 0.7758175415326543, 0.7783392489367843, 0.781922848511541, 0.7876052042262797, 0.7608748436472922, 0.7765301524640645, 0.753840082182759, 0.7735915016132198, 0.3513540289877535, 0.3511431583817436, 0.38881576447906285, 0.32503692437897147, 0.2942853050383335, 0.29451520135981135, 0.2638751731166953, 0.2667503703925358, 0.38910760164481784, 0.33656152910046244, 0.021415486323483446, 0.372303148440586, 0.29153955165403256, 0.35758051996796225, 0.3383168630044149, 0.3112497595998619, 0.3264443288445539, 0.29640982305402563, 0.36588962087293875, 0.37516436571613976, 0.33201560699079147, 0.30943352556367365, 0.3262494890216736, 0.2997028325377187, 0.3907390934044397, 0.32194466356153517, 0.22796188537421458, 0.45240315623337923, 0.391995025679059, 0.4447609638044835, 0.3820254651906416, 0.3826218333965329, 0.4067483142978534, 0.38295553856407283, 0.3900928423540908, 0.36603894508716717, 0.17625367710628392, 0.2109551027866866, 0.2205809325499385, 0.22380315548455176, 0.27971691250337327, 0.24837400025029177, 0.21942997024606548, 0.2071870123831504, 0.12357702720461383, 0.23987267419518454, 0.24723294465067003, 0.28439960781731466, 0.2652380083281898, 0.2534639690956757, 0.2901810812946989, 0.2678444904616174, 0.2612543370059113, 0.2761475624756643, 0.3987109691348111, 0.4495602710821951, 0.4406913655622201, 0.6054232260012435, 0.47533578333452753, 0.4972684102428657, 0.4460480911527953, 0.3917005747927599, 0.397540183501946, 0.14677607089834532, 0.1367358116217935, 0.17582005229186248, 0.12532546476573203, 0.1344847157120881, 0.1347318575860087, 0.10800363739350993, 0.13730443539785153, 0.13518870223482848, 0.2050279896955498, 0.4508391046717215, 0.3178774564801511, 0.3269608955603651, 0.40782590221522674, 0.444848699806772, 0.26668666247989925, 0.2732557627008909, 0.2466689090287728, 0.3460792704740334, 0.361252878730534, 0.3436855205734437, 0.32949183876596677, 0.3621127650035568, 0.36615005386039245, 0.3599892456795285, 0.3316229375803932, 0.36958342556268964, 0.30781149690747767, 0.33142653097099406, 0.34269916614612783, 0.29057010713019094, 0.3058052856572302, 0.332952085484867, 0.34173953289829684, 0.3242271853737194, 0.3359058879113027, 0.22613597482719083, 0.21910704009662563, 0.20853688730891606, 0.23279687908033264, 0.1996675940732865, 0.20849799083872966, 0.20629088373239002, 0.20250849847632868, 0.21712490380545602, 0.431474548940182, 0.18464654569699734, 0.1907854365928764, 0.1907486642456907, 0.4720491401871061, 0.21291994520546587, 0.19953007914403353, 0.23165119402685008, 0.19911964117185255, 0.5777238853222668, 0.1819694298511585, 0.805284722941409, 0.1827188108192469, 0.6718231135370532, 0.7342224072668191, 0.16788922892198066, 0.6570687801071586, 0.6195585362245959, 0.5543602853678709, 0.5448715393087575, 0.15220068708900103, 0.6788195176683121, 0.16107315122358468, 0.20351384609295642, 0.20722171834060177, 0.15100718461893448, 0.20705058968235823, 0.19291903330483506, 0.1927668071191252, 0.18051616448412133, 0.1804748863163672, 0.19290455161222564, 0.18847986626923618, 0.17334847366521866, 0.19250133426298022, 0.18740139095833652, 0.09666082236714824, 0.10126582876367973, 0.10604509092083714, 0.09250812907863437, 0.08016757558078114, 0.08723435933669532, 0.08754455264720873, 0.09042208314581235, 0.08687859416680477]}, "mutation_prompt": null}
{"id": "8ba86083-3267-4806-9659-774d3053da63", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.35)  # Changed line: Increase CR increment from 0.25 to 0.35\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adjust the crossover probability (CR) increment more aggressively to enhance exploration.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "545e4b3a-748c-485d-b073-d64b6ea0f5c2", "metadata": {"aucs": [0.45423475525930346, 0.5927976667991433, 0.4478207448727176, 0.5050373065997071, 0.4702452101766964, 0.48600792933161463, 0.47076454557405456, 0.4628399370104399, 0.4853636663808768, 0.33726603660181886, 0.33018451317248687, 0.33396336625706047, 0.4425371291857788, 0.2974828313252138, 0.4141294753826936, 0.3730189407893012, 0.30813130854410864, 0.3461288969541044, 0.16435226662354596, 0.14282092076003772, 0.16319680057437091, 0.15001804002325136, 0.16518068159824884, 0.16693403115746752, 0.12401076282336476, 0.146640494718295, 0.14774949250498903, 0.13136299521680062, 0.12263806891088969, 0.11770517957994231, 0.1288080516214728, 0.11923445010365974, 0.1283607237455393, 0.1276834095249737, 0.13797157202185917, 0.14278382299360637, 0.9053192009470553, 0.8660483334673228, 0.9002098347817125, 0.975528753634753, 0.9498768151140763, 0.9445713831460156, 0.9738097338493318, 0.9546027307857413, 0.9514852738835676, 0.3378366540342965, 0.3130663362093764, 0.3216204505781177, 0.3572684762827889, 0.2847855736383835, 0.3390576964849119, 0.323797335449335, 0.31248482374204145, 0.3254843614410512, 0.7880249127743724, 0.7758175415326543, 0.7783392489367843, 0.781922848511541, 0.7876052042262797, 0.7608748436472922, 0.7765301524640645, 0.753840082182759, 0.7735915016132198, 0.3513540289877535, 0.3511431583817436, 0.38881576447906285, 0.32503692437897147, 0.2942853050383335, 0.29451520135981135, 0.2638751731166953, 0.2667503703925358, 0.38910760164481784, 0.33656152910046244, 0.021415486323483446, 0.372303148440586, 0.29153955165403256, 0.35758051996796225, 0.3383168630044149, 0.3112497595998619, 0.3264443288445539, 0.29640982305402563, 0.36588962087293875, 0.37516436571613976, 0.33201560699079147, 0.30943352556367365, 0.3262494890216736, 0.2997028325377187, 0.3907390934044397, 0.32194466356153517, 0.22796188537421458, 0.45240315623337923, 0.391995025679059, 0.4447609638044835, 0.3820254651906416, 0.3826218333965329, 0.4067483142978534, 0.38295553856407283, 0.3900928423540908, 0.36603894508716717, 0.17625367710628392, 0.2109551027866866, 0.2205809325499385, 0.22380315548455176, 0.27971691250337327, 0.24837400025029177, 0.21942997024606548, 0.2071870123831504, 0.12357702720461383, 0.23987267419518454, 0.24723294465067003, 0.28439960781731466, 0.2652380083281898, 0.2534639690956757, 0.2901810812946989, 0.2678444904616174, 0.2612543370059113, 0.2761475624756643, 0.3987109691348111, 0.4495602710821951, 0.4406913655622201, 0.6054232260012435, 0.47533578333452753, 0.4972684102428657, 0.4460480911527953, 0.3917005747927599, 0.397540183501946, 0.14677607089834532, 0.1367358116217935, 0.17582005229186248, 0.12532546476573203, 0.1344847157120881, 0.1347318575860087, 0.10800363739350993, 0.13730443539785153, 0.13518870223482848, 0.2050279896955498, 0.4508391046717215, 0.3178774564801511, 0.3269608955603651, 0.40782590221522674, 0.444848699806772, 0.26668666247989925, 0.2732557627008909, 0.2466689090287728, 0.3460792704740334, 0.361252878730534, 0.3436855205734437, 0.32949183876596677, 0.3621127650035568, 0.36615005386039245, 0.3599892456795285, 0.3316229375803932, 0.36958342556268964, 0.30781149690747767, 0.33142653097099406, 0.34269916614612783, 0.29057010713019094, 0.3058052856572302, 0.332952085484867, 0.34173953289829684, 0.3242271853737194, 0.3359058879113027, 0.22613597482719083, 0.21910704009662563, 0.20853688730891606, 0.23279687908033264, 0.1996675940732865, 0.20849799083872966, 0.20629088373239002, 0.20250849847632868, 0.21712490380545602, 0.431474548940182, 0.18464654569699734, 0.1907854365928764, 0.1907486642456907, 0.4720491401871061, 0.21291994520546587, 0.19953007914403353, 0.23165119402685008, 0.19911964117185255, 0.5777238853222668, 0.1819694298511585, 0.805284722941409, 0.1827188108192469, 0.6718231135370532, 0.7342224072668191, 0.16788922892198066, 0.6570687801071586, 0.6195585362245959, 0.5543602853678709, 0.5448715393087575, 0.15220068708900103, 0.6788195176683121, 0.16107315122358468, 0.20351384609295642, 0.20722171834060177, 0.15100718461893448, 0.20705058968235823, 0.19291903330483506, 0.1927668071191252, 0.18051616448412133, 0.1804748863163672, 0.19290455161222564, 0.18847986626923618, 0.17334847366521866, 0.19250133426298022, 0.18740139095833652, 0.09666082236714824, 0.10126582876367973, 0.10604509092083714, 0.09250812907863437, 0.08016757558078114, 0.08723435933669532, 0.08754455264720873, 0.09042208314581235, 0.08687859416680477]}, "mutation_prompt": null}
{"id": "58a8879d-9935-4ce3-acc7-91fe66a848f5", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.15)  # Changed line: Increase F increment from 0.1 to 0.15\n                    self.CR = min(1.0, self.CR + 0.35)  # Changed line: Increase CR increment from 0.25 to 0.35\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Increase the mutation factor increment upon success for more aggressive exploration.", "configspace": "", "generation": 67, "fitness": 0.31564749767274386, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.20.", "error": "", "parent_id": "545e4b3a-748c-485d-b073-d64b6ea0f5c2", "metadata": {"aucs": [0.42086438510626434, 0.5157225673050797, 0.465867950749285, 0.5032063456240097, 0.502684528812086, 0.47263303979875493, 0.4889859211657852, 0.45905092699849337, 0.4850543877740753, 0.28714257908396545, 0.34313065286760247, 0.26337188939312084, 0.3662835935881217, 0.29146144950061537, 0.35024367113743826, 0.3120589932055202, 0.2689782249135485, 0.33077157773032784, 0.15755408891943168, 0.29444378978350716, 0.15742269137939968, 0.28697906982414856, 0.15711537763855232, 0.13542997543864166, 0.1621638509948371, 0.35023506426195083, 0.16426017057926767, 0.14625924948022218, 0.13370874365786167, 0.1354644663999388, 0.10277807888548485, 0.12640765399913034, 0.10267385094457981, 0.1316875226242673, 0.1287747280342464, 0.12807692506982238, 0.9532431455400221, 0.9294343409497433, 0.9555974201241896, 0.98676811799101, 0.9538667287913051, 0.9404095122737225, 0.9738097338493318, 0.9727931151435046, 0.9672136740533176, 0.2972734061168687, 0.2864109719819886, 0.3034829513431254, 0.3051145792036106, 0.3103210198700823, 0.3148102517260347, 0.2851861835714562, 0.3043761762158199, 0.307427441974367, 0.7287278810916313, 0.6890015347240841, 0.35180881495965843, 0.6869045304628857, 0.6976194743903567, 0.7369364995669909, 0.694573197311686, 0.7022643016014674, 0.6860867169477396, 0.2579705575521398, 0.253250322204999, 0.28165017482456645, 0.23258816174143526, 0.2860056520539451, 0.31402204768872277, 0.24671967724663169, 0.31595810147164693, 0.33725028860867656, 0.04927309614839137, 0.30327676697537065, 0.12364667529720685, 0.292277183762091, 0.23461770922553538, 0.2766305878397469, 0.34165375713970547, 0.25474053232703486, 0.2675967089320349, 0.29628827116784473, 0.27495026172297665, 0.28083684513036955, 0.27573908958303295, 0.2704437520293931, 0.24592958735830572, 0.28479927658218385, 0.28927599354763023, 0.2793616051198913, 0.3899192565571322, 0.42343163433081155, 0.35713285134091877, 0.27109695702748093, 0.3466265582883391, 0.35927718680246856, 0.325305740714534, 0.35342746165498584, 0.38835233450906226, 0.16096211331105803, 0.11132255882045505, 0.12495102181657369, 0.1535565150965965, 0.13896661280293865, 0.1550468892874689, 0.11999971245524177, 0.1469206527317254, 0.10086960338461215, 0.212155909232559, 0.20811893599684783, 0.22293035429750474, 0.18361474453287974, 0.2250722127912771, 0.23651193141512872, 0.22724453638358755, 0.21662600552471445, 0.24367905926019418, 0.4223474182480724, 0.43148875858612046, 0.4532970750754618, 0.4256710962048986, 0.4531296505915695, 0.438455662976897, 0.43691237783973824, 0.388327692959641, 0.4252670539970437, 0.13161488960638235, 0.31853344602413525, 0.16104295495295284, 0.16714072544423675, 0.11266513583318138, 0.1443953740577013, 0.12937627214382041, 0.16061359338620096, 0.12819788040031033, 0.3507832106424652, 0.39261986259080506, 0.4845071649515992, 0.4077513703997949, 0.40474742370198835, 0.246720560990901, 0.3522371010368881, 0.21173978890379042, 0.2431732682426221, 0.333689451951962, 0.346479043100136, 0.351060631560549, 0.32725106753891, 0.336248262851109, 0.3428129706299391, 0.33396236580197236, 0.3412567703020726, 0.36042643364913896, 0.3171871288220137, 0.31115252659231174, 0.30184335743916324, 0.29752391863011785, 0.3057271163620958, 0.2879535958176598, 0.2998965997866908, 0.30187600977622053, 0.28440948609733363, 0.21039221387221607, 0.20455903677880127, 0.2161893814710707, 0.22103700901201873, 0.20390855246967454, 0.19639351508467606, 0.20425560692381062, 0.19929832150906945, 0.21580511820756298, 0.21919707720047177, 0.2170894684497262, 0.21390070144200912, 0.22097956836006738, 0.18733770445983022, 0.38677924661113794, 0.20993584317147584, 0.1912028787201221, 0.20634969115107415, 0.15257468590750922, 0.5245153523228866, 0.7349723908077708, 0.6744768044568894, 0.16589938796790304, 0.20195874575052397, 0.20436704581250975, 0.7251036331760841, 0.19957658986412885, 0.6735358345645277, 0.16417662029411062, 0.16250729106219985, 0.577872518417945, 0.20153124932195965, 0.19676934865044926, 0.20677595915028824, 0.5569522383347458, 0.20536789742124872, 0.18846609699241978, 0.1860435472358949, 0.18178958226178643, 0.1934894575952345, 0.1881175155493383, 0.17918162253172742, 0.19599466038528934, 0.191510242626041, 0.18298461203300564, 0.0918751432168099, 0.08902186190347261, 0.08548652896933562, 0.08522488786540039, 0.09323304622604578, 0.08808541305664652, 0.08742037773988598, 0.08905813657504824, 0.10553695177818967]}, "mutation_prompt": null}
{"id": "23bcac0c-8a89-4e7c-8717-d68f7f03234f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.12)  # Changed line: Slightly increase F increment\n                    self.CR = min(1.0, self.CR + 0.4)  # Changed line: Increase CR increment from 0.35 to 0.4\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration by further increasing the crossover probability when successful and slightly increasing F adaptation.", "configspace": "", "generation": 68, "fitness": 0.32034348032448323, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.20.", "error": "", "parent_id": "545e4b3a-748c-485d-b073-d64b6ea0f5c2", "metadata": {"aucs": [0.517558986939153, 0.4820455957907054, 0.5351462483929326, 0.4622137253805778, 0.5307516711700246, 0.4404947023491703, 0.5447955467221243, 0.4697820423538588, 0.5241858524714326, 0.31810240617536845, 0.32365163417955223, 0.2939462466598429, 0.32946402537713115, 0.3773760559783198, 0.3139119809415777, 0.33968576475612366, 0.3056083629099202, 0.339613685293761, 0.16242919821522195, 0.14363496591939495, 0.1649710777295712, 0.14902691441675253, 0.16586867039010555, 0.37689101160788363, 0.13050054284559032, 0.1283506753108764, 0.16378533033865628, 0.12901291440977036, 0.16226084119490747, 0.13851995411153872, 0.15926291895277445, 0.12676380111953445, 0.1053530038895153, 0.12721654063226817, 0.1584077298068589, 0.13502720970291848, 0.9837814833088644, 0.882068410121541, 0.9552636130595129, 0.98676811799101, 0.9540398078095159, 0.9239282053677036, 0.9738097338493318, 0.9727931151435046, 0.9412290383599264, 0.3263695028309579, 0.2908455839045929, 0.295954803875915, 0.3097534891882924, 0.34419565235323746, 0.3072383452344212, 0.32361970281559915, 0.30475080282050926, 0.3467800440012929, 0.7654001851074694, 0.765381528804987, 0.7441884875960212, 0.7503646995621964, 0.732215015642151, 0.7476104385347733, 0.706073104129249, 0.7947216870883683, 0.7349262925765823, 0.2781795189950156, 0.3406317165808028, 0.2930184308677114, 0.26435740182481426, 0.2896502894297076, 0.2960732042409602, 0.24067508178643937, 0.34623605613727815, 0.33565689954271716, 0.35466283816008515, 0.40564626499733925, 0.01611242227447951, 0.330105866090064, 0.30418154298657496, 0.29082056924930444, 0.2632549761120113, 0.23753974248648724, 0.32152437824841273, 0.29835387702259486, 0.2774515981259298, 0.29163699001681453, 0.2552368751528171, 0.272989973211734, 0.28171468844525693, 0.29393053583101336, 0.3021345863896975, 0.3212851609931734, 0.3768319514953795, 0.36304680271686307, 0.3825905447016613, 0.3918908267108574, 0.3771808322473674, 0.3474474718324745, 0.37192992893036303, 0.36495479709204537, 0.3319560505531052, 0.14961729536904422, 0.15599444933132967, 0.13800977846251494, 0.253188752495634, 0.17661000240261582, 0.18872569321092802, 0.1569394539503597, 0.17131828154731088, 0.1286338272664883, 0.23137750950693647, 0.24157751412846762, 0.25006684933943124, 0.25005164456072637, 0.23525881616719324, 0.26602050558444734, 0.2331197706744219, 0.2525079975727076, 0.25307661251930236, 0.4054539858360724, 0.44033072260831874, 0.45084671675805466, 0.5058812794343595, 0.42621414590776263, 0.4299644265440866, 0.3850720311250798, 0.4145190551870279, 0.4020372071554066, 0.12402507925011219, 0.13564360116997287, 0.11308847273938138, 0.17113941596255522, 0.1195414404524161, 0.13379198176711593, 0.10778321828102033, 0.131421290974289, 0.16468521586128682, 0.38478378439768013, 0.2269402302212511, 0.19024652191335212, 0.38215763071713404, 0.3986159407451405, 0.2512046282335856, 0.25913676845507894, 0.35586136554750825, 0.30286948067408603, 0.3596214675980176, 0.3185176413596872, 0.3897646697230155, 0.36640052833716463, 0.3400369420961942, 0.34338453132210356, 0.35743169661910734, 0.36754622931858594, 0.373517860734476, 0.33202931697074345, 0.2939378236893013, 0.3420882520102432, 0.32993085540479994, 0.3071114096318782, 0.27334749792523316, 0.3369235804123235, 0.3117164083648728, 0.3198192637884514, 0.21161359907187482, 0.20991033041682972, 0.199436266491834, 0.19482270386706135, 0.19045477557687862, 0.19936418853008075, 0.2401637387092912, 0.2113515891568063, 0.20396554946015732, 0.20270991090422164, 0.3828374313732853, 0.2010417992931639, 0.2117155900314448, 0.20686750346545657, 0.19776549343571992, 0.232327516264073, 0.3837579381646212, 0.340631441456973, 0.15208243196936733, 0.19989471874090758, 0.19599718264125132, 0.1748176755267481, 0.1940135669612605, 0.19242384881699115, 0.6556166414955302, 0.20609545589857148, 0.5514656164621086, 0.20062407854793052, 0.20349645056046395, 0.1629905195265926, 0.7853551802205706, 0.20043522039977313, 0.1629696878648651, 0.20739044323742717, 0.5637142985315768, 0.20649512823297578, 0.20677809187224827, 0.1956699705300894, 0.18862143333397785, 0.2335736962622924, 0.17929389740833102, 0.1871081819451922, 0.18208371616682462, 0.18086559303866845, 0.18690839766021194, 0.08880927234863445, 0.08628673789674302, 0.15057325595616367, 0.08442229717838323, 0.09622019060389997, 0.0868524456769908, 0.08259450965390114, 0.08711706985518797, 0.09474169708816971]}, "mutation_prompt": null}
{"id": "a67acb45-7a23-4082-8704-d6d8fb5b4962", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.95  # Changed line: Increased initial crossover probability from 0.9 to 0.95\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.35)  # Changed line: Increase CR increment from 0.25 to 0.35\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Increase the initial crossover probability (CR) to enhance exploration in the early stages.", "configspace": "", "generation": 69, "fitness": 0.336852114854861, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.20.", "error": "", "parent_id": "545e4b3a-748c-485d-b073-d64b6ea0f5c2", "metadata": {"aucs": [0.45423475525930346, 0.5927976667991433, 0.4453988791860417, 0.5050373065997071, 0.4702452101766964, 0.48600792933161463, 0.47076454557405456, 0.4628399370104399, 0.4853636663808768, 0.33726603660181886, 0.33018451317248687, 0.33396336625706047, 0.4425371291857788, 0.2974828313252138, 0.4141294753826936, 0.3730189407893012, 0.30813130854410864, 0.33108654342409294, 0.16435226662354596, 0.14282092076003772, 0.16319680057437091, 0.15001804002325136, 0.16518068159824884, 0.12462409841871247, 0.12401076282336476, 0.146640494718295, 0.17049870239193465, 0.13136299521680062, 0.12263806891088969, 0.390313106472689, 0.1288080516214728, 0.11923445010365974, 0.10254354385009301, 0.1276834095249737, 0.13797157202185917, 0.3024881416054561, 0.9053192009470553, 0.8660483334673228, 0.9002098347817125, 0.975528753634753, 0.9498768151140763, 0.9445713831460156, 0.9738097338493318, 0.9546027307857413, 0.9514852738835676, 0.3378366540342965, 0.3130663362093764, 0.31061508715886044, 0.3572684762827889, 0.2847855736383835, 0.3390576964849119, 0.323797335449335, 0.31248482374204145, 0.3254843614410512, 0.7880249127743724, 0.7758175415326543, 0.7783392489367843, 0.781922848511541, 0.7876052042262797, 0.7608748436472922, 0.7765301524640645, 0.753840082182759, 0.7735915016132198, 0.3513540289877535, 0.3511431583817436, 0.36862894161349624, 0.32503692437897147, 0.2942853050383335, 0.29451520135981135, 0.2638751731166953, 0.2667503703925358, 0.38910760164481784, 0.33656152910046244, 0.021415486323483446, 0.372303148440586, 0.29153955165403256, 0.35758051996796225, 0.3152805062490499, 0.3112497595998619, 0.3264443288445539, 0.29640982305402563, 0.36588962087293875, 0.37516436571613976, 0.33201560699079147, 0.30943352556367365, 0.3262494890216736, 0.2997028325377187, 0.3907390934044397, 0.32194466356153517, 0.22796188537421458, 0.45240315623337923, 0.391995025679059, 0.4447609638044835, 0.3820254651906416, 0.3826218333965329, 0.4067483142978534, 0.38295553856407283, 0.3900928423540908, 0.36603894508716717, 0.17625367710628392, 0.2109551027866866, 0.2205809325499385, 0.22380315548455176, 0.27971691250337327, 0.24837400025029177, 0.21942997024606548, 0.2071870123831504, 0.12357702720461383, 0.23987267419518454, 0.24723294465067003, 0.28439960781731466, 0.2652380083281898, 0.2534639690956757, 0.2901810812946989, 0.2678444904616174, 0.2612543370059113, 0.2761475624756643, 0.3987109691348111, 0.4495602710821951, 0.4406913655622201, 0.6054232260012435, 0.47533578333452753, 0.4972684102428657, 0.4460480911527953, 0.3917005747927599, 0.397540183501946, 0.14677607089834532, 0.1367358116217935, 0.17582005229186248, 0.12532546476573203, 0.1344847157120881, 0.1347318575860087, 0.10800363739350993, 0.13730443539785153, 0.13518870223482848, 0.2050279896955498, 0.1800275866714195, 0.3178774564801511, 0.3269608955603651, 0.25043611120326037, 0.444848699806772, 0.26668666247989925, 0.2732557627008909, 0.2466689090287728, 0.3460792704740334, 0.361252878730534, 0.3436855205734437, 0.32949183876596677, 0.3621127650035568, 0.36615005386039245, 0.3599892456795285, 0.3316229375803932, 0.36958342556268964, 0.30781149690747767, 0.33142653097099406, 0.34269916614612783, 0.29057010713019094, 0.3058052856572302, 0.332952085484867, 0.34173953289829684, 0.3242271853737194, 0.3359058879113027, 0.22613597482719083, 0.21910704009662563, 0.23590891042288675, 0.23279687908033264, 0.1996675940732865, 0.20849799083872966, 0.20629088373239002, 0.20250849847632868, 0.21712490380545602, 0.431474548940182, 0.18464654569699734, 0.1907854365928764, 0.1907486642456907, 0.4720491401871061, 0.21424321551615155, 0.19953007914403353, 0.23165119402685008, 0.19911964117185255, 0.5777238853222668, 0.1819694298511585, 0.6789531923681378, 0.1827188108192469, 0.6718231135370532, 0.7342224072668191, 0.16788922892198066, 0.18505996093242139, 0.6195585362245959, 0.5543602853678709, 0.5448715393087575, 0.15220068708900103, 0.6788195176683121, 0.16107315122358468, 0.20351384609295642, 0.20722171834060177, 0.208934452325104, 0.20705058968235823, 0.19291903330483506, 0.1927668071191252, 0.18051616448412133, 0.1804748863163672, 0.19290455161222564, 0.18847986626923618, 0.17334847366521866, 0.19250133426298022, 0.18740139095833652, 0.09666082236714824, 0.10126582876367973, 0.10604509092083714, 0.09250812907863437, 0.08016757558078114, 0.08723435933669532, 0.08754455264720873, 0.09042208314581235, 0.09009157471618434]}, "mutation_prompt": null}
{"id": "0e03df69-f8bd-4ced-8618-c3c21d499d8b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.35)  # Changed line: Increase CR increment from 0.25 to 0.35\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adjust the crossover probability (CR) increment more aggressively to enhance exploration.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "545e4b3a-748c-485d-b073-d64b6ea0f5c2", "metadata": {"aucs": [0.45423475525930346, 0.5927976667991433, 0.4478207448727176, 0.5050373065997071, 0.4702452101766964, 0.48600792933161463, 0.47076454557405456, 0.4628399370104399, 0.4853636663808768, 0.33726603660181886, 0.33018451317248687, 0.33396336625706047, 0.4425371291857788, 0.2974828313252138, 0.4141294753826936, 0.3730189407893012, 0.30813130854410864, 0.3461288969541044, 0.16435226662354596, 0.14282092076003772, 0.16319680057437091, 0.15001804002325136, 0.16518068159824884, 0.16693403115746752, 0.12401076282336476, 0.146640494718295, 0.14774949250498903, 0.13136299521680062, 0.12263806891088969, 0.11770517957994231, 0.1288080516214728, 0.11923445010365974, 0.1283607237455393, 0.1276834095249737, 0.13797157202185917, 0.14278382299360637, 0.9053192009470553, 0.8660483334673228, 0.9002098347817125, 0.975528753634753, 0.9498768151140763, 0.9445713831460156, 0.9738097338493318, 0.9546027307857413, 0.9514852738835676, 0.3378366540342965, 0.3130663362093764, 0.3216204505781177, 0.3572684762827889, 0.2847855736383835, 0.3390576964849119, 0.323797335449335, 0.31248482374204145, 0.3254843614410512, 0.7880249127743724, 0.7758175415326543, 0.7783392489367843, 0.781922848511541, 0.7876052042262797, 0.7608748436472922, 0.7765301524640645, 0.753840082182759, 0.7735915016132198, 0.3513540289877535, 0.3511431583817436, 0.38881576447906285, 0.32503692437897147, 0.2942853050383335, 0.29451520135981135, 0.2638751731166953, 0.2667503703925358, 0.38910760164481784, 0.33656152910046244, 0.021415486323483446, 0.372303148440586, 0.29153955165403256, 0.35758051996796225, 0.3383168630044149, 0.3112497595998619, 0.3264443288445539, 0.29640982305402563, 0.36588962087293875, 0.37516436571613976, 0.33201560699079147, 0.30943352556367365, 0.3262494890216736, 0.2997028325377187, 0.3907390934044397, 0.32194466356153517, 0.22796188537421458, 0.45240315623337923, 0.391995025679059, 0.4447609638044835, 0.3820254651906416, 0.3826218333965329, 0.4067483142978534, 0.38295553856407283, 0.3900928423540908, 0.36603894508716717, 0.17625367710628392, 0.2109551027866866, 0.2205809325499385, 0.22380315548455176, 0.27971691250337327, 0.24837400025029177, 0.21942997024606548, 0.2071870123831504, 0.12357702720461383, 0.23987267419518454, 0.24723294465067003, 0.28439960781731466, 0.2652380083281898, 0.2534639690956757, 0.2901810812946989, 0.2678444904616174, 0.2612543370059113, 0.2761475624756643, 0.3987109691348111, 0.4495602710821951, 0.4406913655622201, 0.6054232260012435, 0.47533578333452753, 0.4972684102428657, 0.4460480911527953, 0.3917005747927599, 0.397540183501946, 0.14677607089834532, 0.1367358116217935, 0.17582005229186248, 0.12532546476573203, 0.1344847157120881, 0.1347318575860087, 0.10800363739350993, 0.13730443539785153, 0.13518870223482848, 0.2050279896955498, 0.4508391046717215, 0.3178774564801511, 0.3269608955603651, 0.40782590221522674, 0.444848699806772, 0.26668666247989925, 0.2732557627008909, 0.2466689090287728, 0.3460792704740334, 0.361252878730534, 0.3436855205734437, 0.32949183876596677, 0.3621127650035568, 0.36615005386039245, 0.3599892456795285, 0.3316229375803932, 0.36958342556268964, 0.30781149690747767, 0.33142653097099406, 0.34269916614612783, 0.29057010713019094, 0.3058052856572302, 0.332952085484867, 0.34173953289829684, 0.3242271853737194, 0.3359058879113027, 0.22613597482719083, 0.21910704009662563, 0.20853688730891606, 0.23279687908033264, 0.1996675940732865, 0.20849799083872966, 0.20629088373239002, 0.20250849847632868, 0.21712490380545602, 0.431474548940182, 0.18464654569699734, 0.1907854365928764, 0.1907486642456907, 0.4720491401871061, 0.21291994520546587, 0.19953007914403353, 0.23165119402685008, 0.19911964117185255, 0.5777238853222668, 0.1819694298511585, 0.805284722941409, 0.1827188108192469, 0.6718231135370532, 0.7342224072668191, 0.16788922892198066, 0.6570687801071586, 0.6195585362245959, 0.5543602853678709, 0.5448715393087575, 0.15220068708900103, 0.6788195176683121, 0.16107315122358468, 0.20351384609295642, 0.20722171834060177, 0.15100718461893448, 0.20705058968235823, 0.19291903330483506, 0.1927668071191252, 0.18051616448412133, 0.1804748863163672, 0.19290455161222564, 0.18847986626923618, 0.17334847366521866, 0.19250133426298022, 0.18740139095833652, 0.09666082236714824, 0.10126582876367973, 0.10604509092083714, 0.09250812907863437, 0.08016757558078114, 0.08723435933669532, 0.08754455264720873, 0.09042208314581235, 0.08687859416680477]}, "mutation_prompt": null}
{"id": "eec6a5ab-d350-423c-817e-132cee85bbb1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.35)  # Changed line: Increase CR increment from 0.25 to 0.35\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adjust the crossover probability (CR) increment more aggressively to enhance exploration.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "545e4b3a-748c-485d-b073-d64b6ea0f5c2", "metadata": {"aucs": [0.45423475525930346, 0.5927976667991433, 0.4478207448727176, 0.5050373065997071, 0.4702452101766964, 0.48600792933161463, 0.47076454557405456, 0.4628399370104399, 0.4853636663808768, 0.33726603660181886, 0.33018451317248687, 0.33396336625706047, 0.4425371291857788, 0.2974828313252138, 0.4141294753826936, 0.3730189407893012, 0.30813130854410864, 0.3461288969541044, 0.16435226662354596, 0.14282092076003772, 0.16319680057437091, 0.15001804002325136, 0.16518068159824884, 0.16693403115746752, 0.12401076282336476, 0.146640494718295, 0.14774949250498903, 0.13136299521680062, 0.12263806891088969, 0.11770517957994231, 0.1288080516214728, 0.11923445010365974, 0.1283607237455393, 0.1276834095249737, 0.13797157202185917, 0.14278382299360637, 0.9053192009470553, 0.8660483334673228, 0.9002098347817125, 0.975528753634753, 0.9498768151140763, 0.9445713831460156, 0.9738097338493318, 0.9546027307857413, 0.9514852738835676, 0.3378366540342965, 0.3130663362093764, 0.3216204505781177, 0.3572684762827889, 0.2847855736383835, 0.3390576964849119, 0.323797335449335, 0.31248482374204145, 0.3254843614410512, 0.7880249127743724, 0.7758175415326543, 0.7783392489367843, 0.781922848511541, 0.7876052042262797, 0.7608748436472922, 0.7765301524640645, 0.753840082182759, 0.7735915016132198, 0.3513540289877535, 0.3511431583817436, 0.38881576447906285, 0.32503692437897147, 0.2942853050383335, 0.29451520135981135, 0.2638751731166953, 0.2667503703925358, 0.38910760164481784, 0.33656152910046244, 0.021415486323483446, 0.372303148440586, 0.29153955165403256, 0.35758051996796225, 0.3383168630044149, 0.3112497595998619, 0.3264443288445539, 0.29640982305402563, 0.36588962087293875, 0.37516436571613976, 0.33201560699079147, 0.30943352556367365, 0.3262494890216736, 0.2997028325377187, 0.3907390934044397, 0.32194466356153517, 0.22796188537421458, 0.45240315623337923, 0.391995025679059, 0.4447609638044835, 0.3820254651906416, 0.3826218333965329, 0.4067483142978534, 0.38295553856407283, 0.3900928423540908, 0.36603894508716717, 0.17625367710628392, 0.2109551027866866, 0.2205809325499385, 0.22380315548455176, 0.27971691250337327, 0.24837400025029177, 0.21942997024606548, 0.2071870123831504, 0.12357702720461383, 0.23987267419518454, 0.24723294465067003, 0.28439960781731466, 0.2652380083281898, 0.2534639690956757, 0.2901810812946989, 0.2678444904616174, 0.2612543370059113, 0.2761475624756643, 0.3987109691348111, 0.4495602710821951, 0.4406913655622201, 0.6054232260012435, 0.47533578333452753, 0.4972684102428657, 0.4460480911527953, 0.3917005747927599, 0.397540183501946, 0.14677607089834532, 0.1367358116217935, 0.17582005229186248, 0.12532546476573203, 0.1344847157120881, 0.1347318575860087, 0.10800363739350993, 0.13730443539785153, 0.13518870223482848, 0.2050279896955498, 0.4508391046717215, 0.3178774564801511, 0.3269608955603651, 0.40782590221522674, 0.444848699806772, 0.26668666247989925, 0.2732557627008909, 0.2466689090287728, 0.3460792704740334, 0.361252878730534, 0.3436855205734437, 0.32949183876596677, 0.3621127650035568, 0.36615005386039245, 0.3599892456795285, 0.3316229375803932, 0.36958342556268964, 0.30781149690747767, 0.33142653097099406, 0.34269916614612783, 0.29057010713019094, 0.3058052856572302, 0.332952085484867, 0.34173953289829684, 0.3242271853737194, 0.3359058879113027, 0.22613597482719083, 0.21910704009662563, 0.20853688730891606, 0.23279687908033264, 0.1996675940732865, 0.20849799083872966, 0.20629088373239002, 0.20250849847632868, 0.21712490380545602, 0.431474548940182, 0.18464654569699734, 0.1907854365928764, 0.1907486642456907, 0.4720491401871061, 0.21291994520546587, 0.19953007914403353, 0.23165119402685008, 0.19911964117185255, 0.5777238853222668, 0.1819694298511585, 0.805284722941409, 0.1827188108192469, 0.6718231135370532, 0.7342224072668191, 0.16788922892198066, 0.6570687801071586, 0.6195585362245959, 0.5543602853678709, 0.5448715393087575, 0.15220068708900103, 0.6788195176683121, 0.16107315122358468, 0.20351384609295642, 0.20722171834060177, 0.15100718461893448, 0.20705058968235823, 0.19291903330483506, 0.1927668071191252, 0.18051616448412133, 0.1804748863163672, 0.19290455161222564, 0.18847986626923618, 0.17334847366521866, 0.19250133426298022, 0.18740139095833652, 0.09666082236714824, 0.10126582876367973, 0.10604509092083714, 0.09250812907863437, 0.08016757558078114, 0.08723435933669532, 0.08754455264720873, 0.09042208314581235, 0.08687859416680477]}, "mutation_prompt": null}
{"id": "4402eca7-844f-4f66-8a70-81ea42a09ed3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.35)  # Changed line: Increase CR increment from 0.25 to 0.35\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adjust the crossover probability (CR) increment more aggressively to enhance exploration.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "545e4b3a-748c-485d-b073-d64b6ea0f5c2", "metadata": {"aucs": [0.45423475525930346, 0.5927976667991433, 0.4478207448727176, 0.5050373065997071, 0.4702452101766964, 0.48600792933161463, 0.47076454557405456, 0.4628399370104399, 0.4853636663808768, 0.33726603660181886, 0.33018451317248687, 0.33396336625706047, 0.4425371291857788, 0.2974828313252138, 0.4141294753826936, 0.3730189407893012, 0.30813130854410864, 0.3461288969541044, 0.16435226662354596, 0.14282092076003772, 0.16319680057437091, 0.15001804002325136, 0.16518068159824884, 0.16693403115746752, 0.12401076282336476, 0.146640494718295, 0.14774949250498903, 0.13136299521680062, 0.12263806891088969, 0.11770517957994231, 0.1288080516214728, 0.11923445010365974, 0.1283607237455393, 0.1276834095249737, 0.13797157202185917, 0.14278382299360637, 0.9053192009470553, 0.8660483334673228, 0.9002098347817125, 0.975528753634753, 0.9498768151140763, 0.9445713831460156, 0.9738097338493318, 0.9546027307857413, 0.9514852738835676, 0.3378366540342965, 0.3130663362093764, 0.3216204505781177, 0.3572684762827889, 0.2847855736383835, 0.3390576964849119, 0.323797335449335, 0.31248482374204145, 0.3254843614410512, 0.7880249127743724, 0.7758175415326543, 0.7783392489367843, 0.781922848511541, 0.7876052042262797, 0.7608748436472922, 0.7765301524640645, 0.753840082182759, 0.7735915016132198, 0.3513540289877535, 0.3511431583817436, 0.38881576447906285, 0.32503692437897147, 0.2942853050383335, 0.29451520135981135, 0.2638751731166953, 0.2667503703925358, 0.38910760164481784, 0.33656152910046244, 0.021415486323483446, 0.372303148440586, 0.29153955165403256, 0.35758051996796225, 0.3383168630044149, 0.3112497595998619, 0.3264443288445539, 0.29640982305402563, 0.36588962087293875, 0.37516436571613976, 0.33201560699079147, 0.30943352556367365, 0.3262494890216736, 0.2997028325377187, 0.3907390934044397, 0.32194466356153517, 0.22796188537421458, 0.45240315623337923, 0.391995025679059, 0.4447609638044835, 0.3820254651906416, 0.3826218333965329, 0.4067483142978534, 0.38295553856407283, 0.3900928423540908, 0.36603894508716717, 0.17625367710628392, 0.2109551027866866, 0.2205809325499385, 0.22380315548455176, 0.27971691250337327, 0.24837400025029177, 0.21942997024606548, 0.2071870123831504, 0.12357702720461383, 0.23987267419518454, 0.24723294465067003, 0.28439960781731466, 0.2652380083281898, 0.2534639690956757, 0.2901810812946989, 0.2678444904616174, 0.2612543370059113, 0.2761475624756643, 0.3987109691348111, 0.4495602710821951, 0.4406913655622201, 0.6054232260012435, 0.47533578333452753, 0.4972684102428657, 0.4460480911527953, 0.3917005747927599, 0.397540183501946, 0.14677607089834532, 0.1367358116217935, 0.17582005229186248, 0.12532546476573203, 0.1344847157120881, 0.1347318575860087, 0.10800363739350993, 0.13730443539785153, 0.13518870223482848, 0.2050279896955498, 0.4508391046717215, 0.3178774564801511, 0.3269608955603651, 0.40782590221522674, 0.444848699806772, 0.26668666247989925, 0.2732557627008909, 0.2466689090287728, 0.3460792704740334, 0.361252878730534, 0.3436855205734437, 0.32949183876596677, 0.3621127650035568, 0.36615005386039245, 0.3599892456795285, 0.3316229375803932, 0.36958342556268964, 0.30781149690747767, 0.33142653097099406, 0.34269916614612783, 0.29057010713019094, 0.3058052856572302, 0.332952085484867, 0.34173953289829684, 0.3242271853737194, 0.3359058879113027, 0.22613597482719083, 0.21910704009662563, 0.20853688730891606, 0.23279687908033264, 0.1996675940732865, 0.20849799083872966, 0.20629088373239002, 0.20250849847632868, 0.21712490380545602, 0.431474548940182, 0.18464654569699734, 0.1907854365928764, 0.1907486642456907, 0.4720491401871061, 0.21291994520546587, 0.19953007914403353, 0.23165119402685008, 0.19911964117185255, 0.5777238853222668, 0.1819694298511585, 0.805284722941409, 0.1827188108192469, 0.6718231135370532, 0.7342224072668191, 0.16788922892198066, 0.6570687801071586, 0.6195585362245959, 0.5543602853678709, 0.5448715393087575, 0.15220068708900103, 0.6788195176683121, 0.16107315122358468, 0.20351384609295642, 0.20722171834060177, 0.15100718461893448, 0.20705058968235823, 0.19291903330483506, 0.1927668071191252, 0.18051616448412133, 0.1804748863163672, 0.19290455161222564, 0.18847986626923618, 0.17334847366521866, 0.19250133426298022, 0.18740139095833652, 0.09666082236714824, 0.10126582876367973, 0.10604509092083714, 0.09250812907863437, 0.08016757558078114, 0.08723435933669532, 0.08754455264720873, 0.09042208314581235, 0.08687859416680477]}, "mutation_prompt": null}
{"id": "b61bcae3-2c76-4736-be54-d8becd38592e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.35)  # Changed line: Increase CR increment from 0.25 to 0.35\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.995  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Refine by increasing the mutation factor cooling schedule to maintain diversity longer.", "configspace": "", "generation": 73, "fitness": 0.33148511273959247, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.20.", "error": "", "parent_id": "545e4b3a-748c-485d-b073-d64b6ea0f5c2", "metadata": {"aucs": [0.5007776712111259, 0.47876154478140653, 0.46310047082825045, 0.4448792284011829, 0.4885611993767075, 0.4347852107620602, 0.5084078237588843, 0.5863612561327392, 0.45661373969000696, 0.34484452737888327, 0.3273312805966082, 0.3765658364761624, 0.3250105031927175, 0.3414430731493291, 0.31915581660159553, 0.36688360958237676, 0.3206744296424924, 0.3694050292918688, 0.1410310320226359, 0.14493247393334663, 0.1423714855668794, 0.38158718886360277, 0.16110350886519842, 0.3605101959716087, 0.13452053062003722, 0.1306043477852492, 0.17041209969678472, 0.14506247509844983, 0.12976396915756883, 0.1344274335796246, 0.13662696998604806, 0.1112353327695873, 0.13381114633860014, 0.10445967541906775, 0.13540570472262858, 0.13981905714506138, 0.908424856109344, 0.8972868382228393, 0.8791543091357664, 0.9755980203738749, 0.9538916181061056, 0.9391866904410171, 0.9738097338493318, 0.9727931151435046, 0.9518987042197715, 0.36446153781218493, 0.2884568250537256, 0.3194144334680491, 0.32748347529813426, 0.34296715256849963, 0.3299703989646283, 0.34351805296041205, 0.3128563061394325, 0.3219513865877608, 0.7579292247894027, 0.7636298227303149, 0.7482417005510431, 0.7647279771022545, 0.7643540756415093, 0.7950800084237599, 0.7819050044101274, 0.7852285261673968, 0.7526319602920483, 0.3015402465676734, 0.2676658717431055, 0.31225745682369666, 0.32306761092686287, 0.32573501539212013, 0.3157693485413775, 0.2745434113043087, 0.28745655935874037, 0.36041559912613597, 0.34190899089149984, 0.05134680791181656, 0.3536914663437698, 0.2837943932632522, 0.37084179779419923, 0.3032819218467232, 0.28880515397375717, 0.35325262571049665, 0.34768427677717795, 0.3409946452568162, 0.3153375813796435, 0.3485471122266517, 0.22235664708971314, 0.29291150406793875, 0.3154873429309154, 0.22606027717350696, 0.2446708067239921, 0.2909857924349536, 0.39868360668507496, 0.35073975338597163, 0.3677343580665874, 0.44826639689831516, 0.4209243916711757, 0.43136944637760566, 0.3940192300029387, 0.4255880241207133, 0.43073620842016946, 0.21691031677543093, 0.19608455579366302, 0.15209926854177558, 0.24111167619680707, 0.25100977259818336, 0.24553819519280362, 0.119448827616909, 0.2299047925349812, 0.22540762527027758, 0.2856515493908456, 0.27604028267273406, 0.3016326240744057, 0.27337638731796887, 0.2783589422930448, 0.27350189793461244, 0.28212460695481345, 0.2733762765622554, 0.2650962522790341, 0.46186768492784214, 0.4442060073384386, 0.4710308936776577, 0.41401230639136144, 0.4354744185549242, 0.5490637714991189, 0.4228392086667513, 0.4986167812847132, 0.5023575385531317, 0.14884201599743796, 0.1367583470371615, 0.09534028482009449, 0.16621787280000067, 0.14518232768671002, 0.1759338716385197, 0.14558787976312892, 0.13862545705524243, 0.10370083445911404, 0.1848922762921117, 0.44180163468192946, 0.23000731571226884, 0.22885114580244348, 0.39696325860956416, 0.2158535123030486, 0.26353118046467316, 0.29192605950993944, 0.3810123251051577, 0.3491033357179383, 0.3524649478893339, 0.35030702501756783, 0.35586016077660587, 0.35336804689966184, 0.3713103166689612, 0.37766194725236324, 0.3520203717592414, 0.35683763757019604, 0.33580874381502734, 0.2913979633006507, 0.3181232620112855, 0.3096079522794374, 0.3300655287909898, 0.3168093304031194, 0.3472118726567345, 0.32789061809837416, 0.26965395342348686, 0.21562057469269513, 0.23215319767797193, 0.20708867785302776, 0.22931231180532774, 0.24348415380681965, 0.20778698898564796, 0.20079667726260508, 0.18459742038856408, 0.22273895500669916, 0.18880438013052603, 0.18202621560479104, 0.1887774958611792, 0.19775650248728616, 0.1973673103724214, 0.20041239107931252, 0.1941281191999884, 0.18975099774373283, 0.1955026597112297, 0.15351408280231293, 0.1538064767198617, 0.7567715345482859, 0.619862189936319, 0.19583348896502684, 0.5976089519875529, 0.16752661616593867, 0.7184132688186613, 0.1911223880446672, 0.20398410717982818, 0.20301374237651515, 0.6132096360870916, 0.45301067551269214, 0.2018476079110869, 0.20231126574333902, 0.2068053536244383, 0.5814692949453215, 0.2076862640403735, 0.1894219387957673, 0.20009352182025142, 0.1758374182943342, 0.18233799682243657, 0.18417603709502528, 0.18411548946257494, 0.17767395467254177, 0.1940253192243634, 0.186967292008261, 0.09461764864093059, 0.1029143045346389, 0.08268188713390645, 0.09001204563053566, 0.09193920019927826, 0.08947670751135317, 0.09439896116047708, 0.0994892103355991, 0.09546005619852693]}, "mutation_prompt": null}
{"id": "58946a37-ba7a-4a1b-b998-1ec7fa63b705", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.35)  # Changed line: Increase CR increment from 0.25 to 0.35\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adjust the crossover probability (CR) increment more aggressively to enhance exploration.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "545e4b3a-748c-485d-b073-d64b6ea0f5c2", "metadata": {"aucs": [0.45423475525930346, 0.5927976667991433, 0.4478207448727176, 0.5050373065997071, 0.4702452101766964, 0.48600792933161463, 0.47076454557405456, 0.4628399370104399, 0.4853636663808768, 0.33726603660181886, 0.33018451317248687, 0.33396336625706047, 0.4425371291857788, 0.2974828313252138, 0.4141294753826936, 0.3730189407893012, 0.30813130854410864, 0.3461288969541044, 0.16435226662354596, 0.14282092076003772, 0.16319680057437091, 0.15001804002325136, 0.16518068159824884, 0.16693403115746752, 0.12401076282336476, 0.146640494718295, 0.14774949250498903, 0.13136299521680062, 0.12263806891088969, 0.11770517957994231, 0.1288080516214728, 0.11923445010365974, 0.1283607237455393, 0.1276834095249737, 0.13797157202185917, 0.14278382299360637, 0.9053192009470553, 0.8660483334673228, 0.9002098347817125, 0.975528753634753, 0.9498768151140763, 0.9445713831460156, 0.9738097338493318, 0.9546027307857413, 0.9514852738835676, 0.3378366540342965, 0.3130663362093764, 0.3216204505781177, 0.3572684762827889, 0.2847855736383835, 0.3390576964849119, 0.323797335449335, 0.31248482374204145, 0.3254843614410512, 0.7880249127743724, 0.7758175415326543, 0.7783392489367843, 0.781922848511541, 0.7876052042262797, 0.7608748436472922, 0.7765301524640645, 0.753840082182759, 0.7735915016132198, 0.3513540289877535, 0.3511431583817436, 0.38881576447906285, 0.32503692437897147, 0.2942853050383335, 0.29451520135981135, 0.2638751731166953, 0.2667503703925358, 0.38910760164481784, 0.33656152910046244, 0.021415486323483446, 0.372303148440586, 0.29153955165403256, 0.35758051996796225, 0.3383168630044149, 0.3112497595998619, 0.3264443288445539, 0.29640982305402563, 0.36588962087293875, 0.37516436571613976, 0.33201560699079147, 0.30943352556367365, 0.3262494890216736, 0.2997028325377187, 0.3907390934044397, 0.32194466356153517, 0.22796188537421458, 0.45240315623337923, 0.391995025679059, 0.4447609638044835, 0.3820254651906416, 0.3826218333965329, 0.4067483142978534, 0.38295553856407283, 0.3900928423540908, 0.36603894508716717, 0.17625367710628392, 0.2109551027866866, 0.2205809325499385, 0.22380315548455176, 0.27971691250337327, 0.24837400025029177, 0.21942997024606548, 0.2071870123831504, 0.12357702720461383, 0.23987267419518454, 0.24723294465067003, 0.28439960781731466, 0.2652380083281898, 0.2534639690956757, 0.2901810812946989, 0.2678444904616174, 0.2612543370059113, 0.2761475624756643, 0.3987109691348111, 0.4495602710821951, 0.4406913655622201, 0.6054232260012435, 0.47533578333452753, 0.4972684102428657, 0.4460480911527953, 0.3917005747927599, 0.397540183501946, 0.14677607089834532, 0.1367358116217935, 0.17582005229186248, 0.12532546476573203, 0.1344847157120881, 0.1347318575860087, 0.10800363739350993, 0.13730443539785153, 0.13518870223482848, 0.2050279896955498, 0.4508391046717215, 0.3178774564801511, 0.3269608955603651, 0.40782590221522674, 0.444848699806772, 0.26668666247989925, 0.2732557627008909, 0.2466689090287728, 0.3460792704740334, 0.361252878730534, 0.3436855205734437, 0.32949183876596677, 0.3621127650035568, 0.36615005386039245, 0.3599892456795285, 0.3316229375803932, 0.36958342556268964, 0.30781149690747767, 0.33142653097099406, 0.34269916614612783, 0.29057010713019094, 0.3058052856572302, 0.332952085484867, 0.34173953289829684, 0.3242271853737194, 0.3359058879113027, 0.22613597482719083, 0.21910704009662563, 0.20853688730891606, 0.23279687908033264, 0.1996675940732865, 0.20849799083872966, 0.20629088373239002, 0.20250849847632868, 0.21712490380545602, 0.431474548940182, 0.18464654569699734, 0.1907854365928764, 0.1907486642456907, 0.4720491401871061, 0.21291994520546587, 0.19953007914403353, 0.23165119402685008, 0.19911964117185255, 0.5777238853222668, 0.1819694298511585, 0.805284722941409, 0.1827188108192469, 0.6718231135370532, 0.7342224072668191, 0.16788922892198066, 0.6570687801071586, 0.6195585362245959, 0.5543602853678709, 0.5448715393087575, 0.15220068708900103, 0.6788195176683121, 0.16107315122358468, 0.20351384609295642, 0.20722171834060177, 0.15100718461893448, 0.20705058968235823, 0.19291903330483506, 0.1927668071191252, 0.18051616448412133, 0.1804748863163672, 0.19290455161222564, 0.18847986626923618, 0.17334847366521866, 0.19250133426298022, 0.18740139095833652, 0.09666082236714824, 0.10126582876367973, 0.10604509092083714, 0.09250812907863437, 0.08016757558078114, 0.08723435933669532, 0.08754455264720873, 0.09042208314581235, 0.08687859416680477]}, "mutation_prompt": null}
{"id": "3790ee6a-5fee-4c4b-94e9-7adf2c2c3c87", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.36)  # Changed line: Increase CR increment from 0.35 to 0.36\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploitation by slightly increasing the CR increment during successful adaptations.", "configspace": "", "generation": 75, "fitness": 0.3392632119699628, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.21.", "error": "", "parent_id": "545e4b3a-748c-485d-b073-d64b6ea0f5c2", "metadata": {"aucs": [0.45423475525930346, 0.5927976667991433, 0.4478207448727176, 0.5050373065997071, 0.4702452101766964, 0.48600792933161463, 0.47076454557405456, 0.4628399370104399, 0.4853636663808768, 0.33726603660181886, 0.33018451317248687, 0.33396336625706047, 0.4425371291857788, 0.2974828313252138, 0.4141294753826936, 0.3730189407893012, 0.30813130854410864, 0.3461288969541044, 0.16435226662354596, 0.14282092076003772, 0.16319680057437091, 0.15001804002325136, 0.16518068159824884, 0.16693403115746752, 0.12401076282336476, 0.146640494718295, 0.14774949250498903, 0.13136299521680062, 0.12263806891088969, 0.11770517957994231, 0.1288080516214728, 0.11923445010365974, 0.1283607237455393, 0.1276834095249737, 0.13797157202185917, 0.14278382299360637, 0.9053192009470553, 0.8660483334673228, 0.9002098347817125, 0.975528753634753, 0.9498768151140763, 0.9445713831460156, 0.9738097338493318, 0.9546027307857413, 0.9514852738835676, 0.3378366540342965, 0.3130663362093764, 0.3216204505781177, 0.3572684762827889, 0.2847855736383835, 0.3390576964849119, 0.323797335449335, 0.31248482374204145, 0.3254843614410512, 0.7880249127743724, 0.7758175415326543, 0.7783392489367843, 0.781922848511541, 0.7876052042262797, 0.7608748436472922, 0.7765301524640645, 0.753840082182759, 0.7735915016132198, 0.3513540289877535, 0.3511431583817436, 0.38881576447906285, 0.32503692437897147, 0.2942853050383335, 0.29451520135981135, 0.2638751731166953, 0.2667503703925358, 0.38910760164481784, 0.33656152910046244, 0.021415486323483446, 0.372303148440586, 0.29153955165403256, 0.35758051996796225, 0.3383168630044149, 0.3112497595998619, 0.3264443288445539, 0.29640982305402563, 0.36588962087293875, 0.37516436571613976, 0.33201560699079147, 0.30943352556367365, 0.3262494890216736, 0.2997028325377187, 0.3187013061995594, 0.32194466356153517, 0.22796188537421458, 0.45240315623337923, 0.391995025679059, 0.4447609638044835, 0.3820254651906416, 0.3826218333965329, 0.4067483142978534, 0.38295553856407283, 0.3900928423540908, 0.3809462537495222, 0.17625367710628392, 0.2109551027866866, 0.2205809325499385, 0.22380315548455176, 0.27971691250337327, 0.24837400025029177, 0.21942997024606548, 0.2071870123831504, 0.12357702720461383, 0.23987267419518454, 0.24723294465067003, 0.28439960781731466, 0.2652380083281898, 0.2534639690956757, 0.2901810812946989, 0.2678444904616174, 0.2612543370059113, 0.2761475624756643, 0.3987109691348111, 0.4495602710821951, 0.4406913655622201, 0.6054232260012435, 0.47533578333452753, 0.4972684102428657, 0.4460480911527953, 0.3917005747927599, 0.397540183501946, 0.14677607089834532, 0.1367358116217935, 0.17582005229186248, 0.12532546476573203, 0.1344847157120881, 0.1347318575860087, 0.10800363739350993, 0.13730443539785153, 0.13518870223482848, 0.2050279896955498, 0.4508391046717215, 0.3081392951433993, 0.3269608955603651, 0.40782590221522674, 0.444848699806772, 0.26668666247989925, 0.2732557627008909, 0.2466689090287728, 0.3460792704740334, 0.361252878730534, 0.3436855205734437, 0.32949183876596677, 0.3621127650035568, 0.36615005386039245, 0.3599892456795285, 0.3316229375803932, 0.36958342556268964, 0.30781149690747767, 0.33142653097099406, 0.34269916614612783, 0.29057010713019094, 0.3058052856572302, 0.332952085484867, 0.34173953289829684, 0.3242271853737194, 0.3359058879113027, 0.2261373802710419, 0.24197027289155748, 0.20264990591973286, 0.22620237326273795, 0.18944608611337999, 0.19735815403550427, 0.19876766312497351, 0.19266278011425697, 0.19089389734519513, 0.431474548940182, 0.18464654569699734, 0.1907854365928764, 0.1907486642456907, 0.4720491401871061, 0.21291994520546587, 0.19953007914403353, 0.23165119402685008, 0.19911964117185255, 0.5777238853222668, 0.1819694298511585, 0.805284722941409, 0.1827188108192469, 0.6718231135370532, 0.7342224072668191, 0.16788922892198066, 0.6570687801071586, 0.6195585362245959, 0.5543602853678709, 0.5448715393087575, 0.15220068708900103, 0.6788195176683121, 0.16107315122358468, 0.20351384609295642, 0.20722171834060177, 0.15100718461893448, 0.20705058968235823, 0.19377719418736028, 0.1928958170824333, 0.1834074986870562, 0.18186650137639992, 0.18212161912380465, 0.18573398743432912, 0.17591645011013168, 0.18404601038472834, 0.18301612262323774, 0.09666082236714824, 0.1113974734592682, 0.10604509092083714, 0.09250812907863437, 0.08082579055713379, 0.09114653058809852, 0.0938875848442825, 0.09493048298673423, 0.1006356575109637]}, "mutation_prompt": null}
{"id": "b35f6273-4df8-4df7-b888-9a2ab32193aa", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.35)  # Changed line: Increase CR increment from 0.25 to 0.35\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adjust the crossover probability (CR) increment more aggressively to enhance exploration.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "545e4b3a-748c-485d-b073-d64b6ea0f5c2", "metadata": {"aucs": [0.45423475525930346, 0.5927976667991433, 0.4478207448727176, 0.5050373065997071, 0.4702452101766964, 0.48600792933161463, 0.47076454557405456, 0.4628399370104399, 0.4853636663808768, 0.33726603660181886, 0.33018451317248687, 0.33396336625706047, 0.4425371291857788, 0.2974828313252138, 0.4141294753826936, 0.3730189407893012, 0.30813130854410864, 0.3461288969541044, 0.16435226662354596, 0.14282092076003772, 0.16319680057437091, 0.15001804002325136, 0.16518068159824884, 0.16693403115746752, 0.12401076282336476, 0.146640494718295, 0.14774949250498903, 0.13136299521680062, 0.12263806891088969, 0.11770517957994231, 0.1288080516214728, 0.11923445010365974, 0.1283607237455393, 0.1276834095249737, 0.13797157202185917, 0.14278382299360637, 0.9053192009470553, 0.8660483334673228, 0.9002098347817125, 0.975528753634753, 0.9498768151140763, 0.9445713831460156, 0.9738097338493318, 0.9546027307857413, 0.9514852738835676, 0.3378366540342965, 0.3130663362093764, 0.3216204505781177, 0.3572684762827889, 0.2847855736383835, 0.3390576964849119, 0.323797335449335, 0.31248482374204145, 0.3254843614410512, 0.7880249127743724, 0.7758175415326543, 0.7783392489367843, 0.781922848511541, 0.7876052042262797, 0.7608748436472922, 0.7765301524640645, 0.753840082182759, 0.7735915016132198, 0.3513540289877535, 0.3511431583817436, 0.38881576447906285, 0.32503692437897147, 0.2942853050383335, 0.29451520135981135, 0.2638751731166953, 0.2667503703925358, 0.38910760164481784, 0.33656152910046244, 0.021415486323483446, 0.372303148440586, 0.29153955165403256, 0.35758051996796225, 0.3383168630044149, 0.3112497595998619, 0.3264443288445539, 0.29640982305402563, 0.36588962087293875, 0.37516436571613976, 0.33201560699079147, 0.30943352556367365, 0.3262494890216736, 0.2997028325377187, 0.3907390934044397, 0.32194466356153517, 0.22796188537421458, 0.45240315623337923, 0.391995025679059, 0.4447609638044835, 0.3820254651906416, 0.3826218333965329, 0.4067483142978534, 0.38295553856407283, 0.3900928423540908, 0.36603894508716717, 0.17625367710628392, 0.2109551027866866, 0.2205809325499385, 0.22380315548455176, 0.27971691250337327, 0.24837400025029177, 0.21942997024606548, 0.2071870123831504, 0.12357702720461383, 0.23987267419518454, 0.24723294465067003, 0.28439960781731466, 0.2652380083281898, 0.2534639690956757, 0.2901810812946989, 0.2678444904616174, 0.2612543370059113, 0.2761475624756643, 0.3987109691348111, 0.4495602710821951, 0.4406913655622201, 0.6054232260012435, 0.47533578333452753, 0.4972684102428657, 0.4460480911527953, 0.3917005747927599, 0.397540183501946, 0.14677607089834532, 0.1367358116217935, 0.17582005229186248, 0.12532546476573203, 0.1344847157120881, 0.1347318575860087, 0.10800363739350993, 0.13730443539785153, 0.13518870223482848, 0.2050279896955498, 0.4508391046717215, 0.3178774564801511, 0.3269608955603651, 0.40782590221522674, 0.444848699806772, 0.26668666247989925, 0.2732557627008909, 0.2466689090287728, 0.3460792704740334, 0.361252878730534, 0.3436855205734437, 0.32949183876596677, 0.3621127650035568, 0.36615005386039245, 0.3599892456795285, 0.3316229375803932, 0.36958342556268964, 0.30781149690747767, 0.33142653097099406, 0.34269916614612783, 0.29057010713019094, 0.3058052856572302, 0.332952085484867, 0.34173953289829684, 0.3242271853737194, 0.3359058879113027, 0.22613597482719083, 0.21910704009662563, 0.20853688730891606, 0.23279687908033264, 0.1996675940732865, 0.20849799083872966, 0.20629088373239002, 0.20250849847632868, 0.21712490380545602, 0.431474548940182, 0.18464654569699734, 0.1907854365928764, 0.1907486642456907, 0.4720491401871061, 0.21291994520546587, 0.19953007914403353, 0.23165119402685008, 0.19911964117185255, 0.5777238853222668, 0.1819694298511585, 0.805284722941409, 0.1827188108192469, 0.6718231135370532, 0.7342224072668191, 0.16788922892198066, 0.6570687801071586, 0.6195585362245959, 0.5543602853678709, 0.5448715393087575, 0.15220068708900103, 0.6788195176683121, 0.16107315122358468, 0.20351384609295642, 0.20722171834060177, 0.15100718461893448, 0.20705058968235823, 0.19291903330483506, 0.1927668071191252, 0.18051616448412133, 0.1804748863163672, 0.19290455161222564, 0.18847986626923618, 0.17334847366521866, 0.19250133426298022, 0.18740139095833652, 0.09666082236714824, 0.10126582876367973, 0.10604509092083714, 0.09250812907863437, 0.08016757558078114, 0.08723435933669532, 0.08754455264720873, 0.09042208314581235, 0.08687859416680477]}, "mutation_prompt": null}
{"id": "e67fd047-ffe4-43d1-8873-b44664a54520", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.35)  # Changed line: Increase CR increment from 0.25 to 0.35\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adjust the crossover probability (CR) increment more aggressively to enhance exploration.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "545e4b3a-748c-485d-b073-d64b6ea0f5c2", "metadata": {"aucs": [0.45423475525930346, 0.5927976667991433, 0.4478207448727176, 0.5050373065997071, 0.4702452101766964, 0.48600792933161463, 0.47076454557405456, 0.4628399370104399, 0.4853636663808768, 0.33726603660181886, 0.33018451317248687, 0.33396336625706047, 0.4425371291857788, 0.2974828313252138, 0.4141294753826936, 0.3730189407893012, 0.30813130854410864, 0.3461288969541044, 0.16435226662354596, 0.14282092076003772, 0.16319680057437091, 0.15001804002325136, 0.16518068159824884, 0.16693403115746752, 0.12401076282336476, 0.146640494718295, 0.14774949250498903, 0.13136299521680062, 0.12263806891088969, 0.11770517957994231, 0.1288080516214728, 0.11923445010365974, 0.1283607237455393, 0.1276834095249737, 0.13797157202185917, 0.14278382299360637, 0.9053192009470553, 0.8660483334673228, 0.9002098347817125, 0.975528753634753, 0.9498768151140763, 0.9445713831460156, 0.9738097338493318, 0.9546027307857413, 0.9514852738835676, 0.3378366540342965, 0.3130663362093764, 0.3216204505781177, 0.3572684762827889, 0.2847855736383835, 0.3390576964849119, 0.323797335449335, 0.31248482374204145, 0.3254843614410512, 0.7880249127743724, 0.7758175415326543, 0.7783392489367843, 0.781922848511541, 0.7876052042262797, 0.7608748436472922, 0.7765301524640645, 0.753840082182759, 0.7735915016132198, 0.3513540289877535, 0.3511431583817436, 0.38881576447906285, 0.32503692437897147, 0.2942853050383335, 0.29451520135981135, 0.2638751731166953, 0.2667503703925358, 0.38910760164481784, 0.33656152910046244, 0.021415486323483446, 0.372303148440586, 0.29153955165403256, 0.35758051996796225, 0.3383168630044149, 0.3112497595998619, 0.3264443288445539, 0.29640982305402563, 0.36588962087293875, 0.37516436571613976, 0.33201560699079147, 0.30943352556367365, 0.3262494890216736, 0.2997028325377187, 0.3907390934044397, 0.32194466356153517, 0.22796188537421458, 0.45240315623337923, 0.391995025679059, 0.4447609638044835, 0.3820254651906416, 0.3826218333965329, 0.4067483142978534, 0.38295553856407283, 0.3900928423540908, 0.36603894508716717, 0.17625367710628392, 0.2109551027866866, 0.2205809325499385, 0.22380315548455176, 0.27971691250337327, 0.24837400025029177, 0.21942997024606548, 0.2071870123831504, 0.12357702720461383, 0.23987267419518454, 0.24723294465067003, 0.28439960781731466, 0.2652380083281898, 0.2534639690956757, 0.2901810812946989, 0.2678444904616174, 0.2612543370059113, 0.2761475624756643, 0.3987109691348111, 0.4495602710821951, 0.4406913655622201, 0.6054232260012435, 0.47533578333452753, 0.4972684102428657, 0.4460480911527953, 0.3917005747927599, 0.397540183501946, 0.14677607089834532, 0.1367358116217935, 0.17582005229186248, 0.12532546476573203, 0.1344847157120881, 0.1347318575860087, 0.10800363739350993, 0.13730443539785153, 0.13518870223482848, 0.2050279896955498, 0.4508391046717215, 0.3178774564801511, 0.3269608955603651, 0.40782590221522674, 0.444848699806772, 0.26668666247989925, 0.2732557627008909, 0.2466689090287728, 0.3460792704740334, 0.361252878730534, 0.3436855205734437, 0.32949183876596677, 0.3621127650035568, 0.36615005386039245, 0.3599892456795285, 0.3316229375803932, 0.36958342556268964, 0.30781149690747767, 0.33142653097099406, 0.34269916614612783, 0.29057010713019094, 0.3058052856572302, 0.332952085484867, 0.34173953289829684, 0.3242271853737194, 0.3359058879113027, 0.22613597482719083, 0.21910704009662563, 0.20853688730891606, 0.23279687908033264, 0.1996675940732865, 0.20849799083872966, 0.20629088373239002, 0.20250849847632868, 0.21712490380545602, 0.431474548940182, 0.18464654569699734, 0.1907854365928764, 0.1907486642456907, 0.4720491401871061, 0.21291994520546587, 0.19953007914403353, 0.23165119402685008, 0.19911964117185255, 0.5777238853222668, 0.1819694298511585, 0.805284722941409, 0.1827188108192469, 0.6718231135370532, 0.7342224072668191, 0.16788922892198066, 0.6570687801071586, 0.6195585362245959, 0.5543602853678709, 0.5448715393087575, 0.15220068708900103, 0.6788195176683121, 0.16107315122358468, 0.20351384609295642, 0.20722171834060177, 0.15100718461893448, 0.20705058968235823, 0.19291903330483506, 0.1927668071191252, 0.18051616448412133, 0.1804748863163672, 0.19290455161222564, 0.18847986626923618, 0.17334847366521866, 0.19250133426298022, 0.18740139095833652, 0.09666082236714824, 0.10126582876367973, 0.10604509092083714, 0.09250812907863437, 0.08016757558078114, 0.08723435933669532, 0.08754455264720873, 0.09042208314581235, 0.08687859416680477]}, "mutation_prompt": null}
{"id": "ee151159-9965-4a5c-80ab-6480d69a3f39", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.15)  # Changed line: Increased mutation factor increment from 0.1 to 0.15\n                    self.CR = min(1.0, self.CR + 0.35)\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration by increasing the mutation factor F increment more aggressively.", "configspace": "", "generation": 78, "fitness": 0.31564749767274386, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.20.", "error": "", "parent_id": "545e4b3a-748c-485d-b073-d64b6ea0f5c2", "metadata": {"aucs": [0.42086438510626434, 0.5157225673050797, 0.465867950749285, 0.5032063456240097, 0.502684528812086, 0.47263303979875493, 0.4889859211657852, 0.45905092699849337, 0.4850543877740753, 0.28714257908396545, 0.34313065286760247, 0.26337188939312084, 0.3662835935881217, 0.29146144950061537, 0.35024367113743826, 0.3120589932055202, 0.2689782249135485, 0.33077157773032784, 0.15755408891943168, 0.29444378978350716, 0.15742269137939968, 0.28697906982414856, 0.15711537763855232, 0.13542997543864166, 0.1621638509948371, 0.35023506426195083, 0.16426017057926767, 0.14625924948022218, 0.13370874365786167, 0.1354644663999388, 0.10277807888548485, 0.12640765399913034, 0.10267385094457981, 0.1316875226242673, 0.1287747280342464, 0.12807692506982238, 0.9532431455400221, 0.9294343409497433, 0.9555974201241896, 0.98676811799101, 0.9538667287913051, 0.9404095122737225, 0.9738097338493318, 0.9727931151435046, 0.9672136740533176, 0.2972734061168687, 0.2864109719819886, 0.3034829513431254, 0.3051145792036106, 0.3103210198700823, 0.3148102517260347, 0.2851861835714562, 0.3043761762158199, 0.307427441974367, 0.7287278810916313, 0.6890015347240841, 0.35180881495965843, 0.6869045304628857, 0.6976194743903567, 0.7369364995669909, 0.694573197311686, 0.7022643016014674, 0.6860867169477396, 0.2579705575521398, 0.253250322204999, 0.28165017482456645, 0.23258816174143526, 0.2860056520539451, 0.31402204768872277, 0.24671967724663169, 0.31595810147164693, 0.33725028860867656, 0.04927309614839137, 0.30327676697537065, 0.12364667529720685, 0.292277183762091, 0.23461770922553538, 0.2766305878397469, 0.34165375713970547, 0.25474053232703486, 0.2675967089320349, 0.29628827116784473, 0.27495026172297665, 0.28083684513036955, 0.27573908958303295, 0.2704437520293931, 0.24592958735830572, 0.28479927658218385, 0.28927599354763023, 0.2793616051198913, 0.3899192565571322, 0.42343163433081155, 0.35713285134091877, 0.27109695702748093, 0.3466265582883391, 0.35927718680246856, 0.325305740714534, 0.35342746165498584, 0.38835233450906226, 0.16096211331105803, 0.11132255882045505, 0.12495102181657369, 0.1535565150965965, 0.13896661280293865, 0.1550468892874689, 0.11999971245524177, 0.1469206527317254, 0.10086960338461215, 0.212155909232559, 0.20811893599684783, 0.22293035429750474, 0.18361474453287974, 0.2250722127912771, 0.23651193141512872, 0.22724453638358755, 0.21662600552471445, 0.24367905926019418, 0.4223474182480724, 0.43148875858612046, 0.4532970750754618, 0.4256710962048986, 0.4531296505915695, 0.438455662976897, 0.43691237783973824, 0.388327692959641, 0.4252670539970437, 0.13161488960638235, 0.31853344602413525, 0.16104295495295284, 0.16714072544423675, 0.11266513583318138, 0.1443953740577013, 0.12937627214382041, 0.16061359338620096, 0.12819788040031033, 0.3507832106424652, 0.39261986259080506, 0.4845071649515992, 0.4077513703997949, 0.40474742370198835, 0.246720560990901, 0.3522371010368881, 0.21173978890379042, 0.2431732682426221, 0.333689451951962, 0.346479043100136, 0.351060631560549, 0.32725106753891, 0.336248262851109, 0.3428129706299391, 0.33396236580197236, 0.3412567703020726, 0.36042643364913896, 0.3171871288220137, 0.31115252659231174, 0.30184335743916324, 0.29752391863011785, 0.3057271163620958, 0.2879535958176598, 0.2998965997866908, 0.30187600977622053, 0.28440948609733363, 0.21039221387221607, 0.20455903677880127, 0.2161893814710707, 0.22103700901201873, 0.20390855246967454, 0.19639351508467606, 0.20425560692381062, 0.19929832150906945, 0.21580511820756298, 0.21919707720047177, 0.2170894684497262, 0.21390070144200912, 0.22097956836006738, 0.18733770445983022, 0.38677924661113794, 0.20993584317147584, 0.1912028787201221, 0.20634969115107415, 0.15257468590750922, 0.5245153523228866, 0.7349723908077708, 0.6744768044568894, 0.16589938796790304, 0.20195874575052397, 0.20436704581250975, 0.7251036331760841, 0.19957658986412885, 0.6735358345645277, 0.16417662029411062, 0.16250729106219985, 0.577872518417945, 0.20153124932195965, 0.19676934865044926, 0.20677595915028824, 0.5569522383347458, 0.20536789742124872, 0.18846609699241978, 0.1860435472358949, 0.18178958226178643, 0.1934894575952345, 0.1881175155493383, 0.17918162253172742, 0.19599466038528934, 0.191510242626041, 0.18298461203300564, 0.0918751432168099, 0.08902186190347261, 0.08548652896933562, 0.08522488786540039, 0.09323304622604578, 0.08808541305664652, 0.08742037773988598, 0.08905813657504824, 0.10553695177818967]}, "mutation_prompt": null}
{"id": "f19acdbe-9c53-42f8-b623-f8bfd689fdcc", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.35)  # Changed line: Increase CR increment from 0.25 to 0.35\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.015)  # Changed line: Increase CR decrement from 0.01 to 0.015\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Slightly increase CR decrement on failure to balance exploration and exploitation effectively.", "configspace": "", "generation": 79, "fitness": 0.3290648817270809, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.21.", "error": "", "parent_id": "545e4b3a-748c-485d-b073-d64b6ea0f5c2", "metadata": {"aucs": [0.5056743169617877, 0.5694685896044334, 0.498226126535662, 0.479179350459629, 0.43045946442637506, 0.49683228554713954, 0.5276891824141082, 0.6953575858854577, 0.5444990033606116, 0.3602688585355026, 0.3845301441479855, 0.36092241069631503, 0.3343499013239779, 0.34601815162895244, 0.37694440893085457, 0.40126180275307266, 0.3567484897970027, 0.3700933316874775, 0.14234040026908878, 0.13627762655931308, 0.16757280928303886, 0.13402321006977114, 0.1657078512320579, 0.16717742087696774, 0.1315812051048122, 0.17074688719591047, 0.16583697809406117, 0.10501987522215628, 0.1399558246271566, 0.10474823607885297, 0.14029553495570268, 0.13001579934764318, 0.1602732637695835, 0.14031797109369182, 0.13917287161321779, 0.10728800523391568, 0.9364248496662163, 0.8656344358319776, 0.9624905985305237, 0.975528753634753, 0.9500211284626174, 0.9716402948647421, 0.943397915496227, 0.943664619899307, 0.9272126273871835, 0.33048914613424396, 0.3081845152392261, 0.29534246499522965, 0.35089163798660516, 0.3777731066372205, 0.35026417732893933, 0.3270695336873607, 0.3213730626789021, 0.3395382460581462, 0.7657108502128311, 0.7731996168084763, 0.7700007395494526, 0.7640690394763462, 0.7481437403190027, 0.7558715816070908, 0.7746490773259842, 0.7611548602917854, 0.7597545731179328, 0.3423186337357994, 0.32876065102381524, 0.32624584887782826, 0.4133744078895776, 0.26691123464859023, 0.31868331951666007, 0.32901549476120595, 0.32357768108497054, 0.30275782785834626, 0.29812462297615017, 0.12757576935880155, 0.009608606641075323, 0.34197245892024764, 0.28354811215197206, 0.3288791669120059, 0.28920854553204867, 0.39222457900670915, 0.29229601208347966, 0.26629980073017445, 0.3053688069669396, 0.15718041955187512, 0.13410417024544585, 0.24857684383059153, 0.07120158724065917, 0.18236747347741467, 0.22081816297896462, 0.13688202421713647, 0.3159361014456227, 0.25419083785175367, 0.16535155275401026, 0.23587811047678586, 0.32253782421843924, 0.24054259881453777, 0.399644969055552, 0.3508207853510019, 0.4348035738491266, 0.17053588916862394, 0.14116093248686556, 0.1615823014719634, 0.1220810804259792, 0.11780316557618697, 0.1311285800426918, 0.20609711006263076, 0.16640616574043088, 0.10618924738288138, 0.2579133027238327, 0.22600293665702453, 0.29505932012266467, 0.2543505675698251, 0.2908548937458062, 0.25173184935774073, 0.2798816052467219, 0.2277532961668205, 0.21192025026591543, 0.4596847201853287, 0.5252362066657345, 0.4359351836298493, 0.4857911625442569, 0.4994965422533929, 0.48515262457624353, 0.43621674180476355, 0.4601652079107603, 0.5069348099763208, 0.44198002030446304, 0.12734824148162283, 0.17163969921276767, 0.14801833749452276, 0.11635070204683651, 0.14636236569847094, 0.11388256991395507, 0.11219964549930195, 0.12171608605384776, 0.21337187750521203, 0.2957975590819111, 0.4039946814980906, 0.2572656338872422, 0.2769368823442414, 0.499239344886069, 0.2623984900031805, 0.4256737916913057, 0.3170574867728906, 0.36347461215710064, 0.3831816168399559, 0.3621605585091119, 0.3628062807635345, 0.33572934501185214, 0.3374781193582215, 0.3766622956504371, 0.346177533951853, 0.35878754141826497, 0.3261001164526057, 0.3174066912600533, 0.3380224157862205, 0.3251754761054765, 0.3386912695793034, 0.3059307393204561, 0.3318715331065023, 0.3360064638983221, 0.32866925730278074, 0.20804412026682073, 0.21828633147690002, 0.21154201542356532, 0.22543671277789046, 0.1876114730426115, 0.21572301310293152, 0.21202389824066226, 0.19908258468378826, 0.19742827286666476, 0.19965391846799518, 0.21417579581336554, 0.20142699163529798, 0.21157939199722597, 0.2068179237631811, 0.4810954237635092, 0.20626977515610645, 0.21989635236022564, 0.39252259020272706, 0.16609555239788765, 0.18137693618430184, 0.1692532228547987, 0.5163957984363843, 0.5571542397874317, 0.6252744799318704, 0.6248191622164256, 0.6535685492256702, 0.6187933673762294, 0.6979690628858153, 0.6531877059204558, 0.20086869287081832, 0.6255041468392517, 0.1594177040695316, 0.16566923029460068, 0.148797000720424, 0.1245344590195826, 0.20612623801143914, 0.21347520188579316, 0.19352642248444207, 0.20561537807165065, 0.17916546476892325, 0.19361826169130236, 0.18976523480343488, 0.18486633666378394, 0.19386797068321915, 0.18459443818139543, 0.0864076747992103, 0.08485885622791556, 0.09477710566499753, 0.09130286968283163, 0.09689652711617414, 0.08579191135899622, 0.09124443991240128, 0.07979511033281017, 0.09243315443963707]}, "mutation_prompt": null}
{"id": "5e5319b4-bbbb-469f-adcf-a6bc789a8e52", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.35)  # Changed line: Increase CR increment from 0.25 to 0.35\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adjust the crossover probability (CR) increment more aggressively to enhance exploration.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "545e4b3a-748c-485d-b073-d64b6ea0f5c2", "metadata": {"aucs": [0.45423475525930346, 0.5927976667991433, 0.4478207448727176, 0.5050373065997071, 0.4702452101766964, 0.48600792933161463, 0.47076454557405456, 0.4628399370104399, 0.4853636663808768, 0.33726603660181886, 0.33018451317248687, 0.33396336625706047, 0.4425371291857788, 0.2974828313252138, 0.4141294753826936, 0.3730189407893012, 0.30813130854410864, 0.3461288969541044, 0.16435226662354596, 0.14282092076003772, 0.16319680057437091, 0.15001804002325136, 0.16518068159824884, 0.16693403115746752, 0.12401076282336476, 0.146640494718295, 0.14774949250498903, 0.13136299521680062, 0.12263806891088969, 0.11770517957994231, 0.1288080516214728, 0.11923445010365974, 0.1283607237455393, 0.1276834095249737, 0.13797157202185917, 0.14278382299360637, 0.9053192009470553, 0.8660483334673228, 0.9002098347817125, 0.975528753634753, 0.9498768151140763, 0.9445713831460156, 0.9738097338493318, 0.9546027307857413, 0.9514852738835676, 0.3378366540342965, 0.3130663362093764, 0.3216204505781177, 0.3572684762827889, 0.2847855736383835, 0.3390576964849119, 0.323797335449335, 0.31248482374204145, 0.3254843614410512, 0.7880249127743724, 0.7758175415326543, 0.7783392489367843, 0.781922848511541, 0.7876052042262797, 0.7608748436472922, 0.7765301524640645, 0.753840082182759, 0.7735915016132198, 0.3513540289877535, 0.3511431583817436, 0.38881576447906285, 0.32503692437897147, 0.2942853050383335, 0.29451520135981135, 0.2638751731166953, 0.2667503703925358, 0.38910760164481784, 0.33656152910046244, 0.021415486323483446, 0.372303148440586, 0.29153955165403256, 0.35758051996796225, 0.3383168630044149, 0.3112497595998619, 0.3264443288445539, 0.29640982305402563, 0.36588962087293875, 0.37516436571613976, 0.33201560699079147, 0.30943352556367365, 0.3262494890216736, 0.2997028325377187, 0.3907390934044397, 0.32194466356153517, 0.22796188537421458, 0.45240315623337923, 0.391995025679059, 0.4447609638044835, 0.3820254651906416, 0.3826218333965329, 0.4067483142978534, 0.38295553856407283, 0.3900928423540908, 0.36603894508716717, 0.17625367710628392, 0.2109551027866866, 0.2205809325499385, 0.22380315548455176, 0.27971691250337327, 0.24837400025029177, 0.21942997024606548, 0.2071870123831504, 0.12357702720461383, 0.23987267419518454, 0.24723294465067003, 0.28439960781731466, 0.2652380083281898, 0.2534639690956757, 0.2901810812946989, 0.2678444904616174, 0.2612543370059113, 0.2761475624756643, 0.3987109691348111, 0.4495602710821951, 0.4406913655622201, 0.6054232260012435, 0.47533578333452753, 0.4972684102428657, 0.4460480911527953, 0.3917005747927599, 0.397540183501946, 0.14677607089834532, 0.1367358116217935, 0.17582005229186248, 0.12532546476573203, 0.1344847157120881, 0.1347318575860087, 0.10800363739350993, 0.13730443539785153, 0.13518870223482848, 0.2050279896955498, 0.4508391046717215, 0.3178774564801511, 0.3269608955603651, 0.40782590221522674, 0.444848699806772, 0.26668666247989925, 0.2732557627008909, 0.2466689090287728, 0.3460792704740334, 0.361252878730534, 0.3436855205734437, 0.32949183876596677, 0.3621127650035568, 0.36615005386039245, 0.3599892456795285, 0.3316229375803932, 0.36958342556268964, 0.30781149690747767, 0.33142653097099406, 0.34269916614612783, 0.29057010713019094, 0.3058052856572302, 0.332952085484867, 0.34173953289829684, 0.3242271853737194, 0.3359058879113027, 0.22613597482719083, 0.21910704009662563, 0.20853688730891606, 0.23279687908033264, 0.1996675940732865, 0.20849799083872966, 0.20629088373239002, 0.20250849847632868, 0.21712490380545602, 0.431474548940182, 0.18464654569699734, 0.1907854365928764, 0.1907486642456907, 0.4720491401871061, 0.21291994520546587, 0.19953007914403353, 0.23165119402685008, 0.19911964117185255, 0.5777238853222668, 0.1819694298511585, 0.805284722941409, 0.1827188108192469, 0.6718231135370532, 0.7342224072668191, 0.16788922892198066, 0.6570687801071586, 0.6195585362245959, 0.5543602853678709, 0.5448715393087575, 0.15220068708900103, 0.6788195176683121, 0.16107315122358468, 0.20351384609295642, 0.20722171834060177, 0.15100718461893448, 0.20705058968235823, 0.19291903330483506, 0.1927668071191252, 0.18051616448412133, 0.1804748863163672, 0.19290455161222564, 0.18847986626923618, 0.17334847366521866, 0.19250133426298022, 0.18740139095833652, 0.09666082236714824, 0.10126582876367973, 0.10604509092083714, 0.09250812907863437, 0.08016757558078114, 0.08723435933669532, 0.08754455264720873, 0.09042208314581235, 0.08687859416680477]}, "mutation_prompt": null}
{"id": "e77fbf49-138d-44b3-a8c6-d345cf3a22f5", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.35)  # Changed line: Increase CR increment from 0.25 to 0.35\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adjust the crossover probability (CR) increment more aggressively to enhance exploration.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "545e4b3a-748c-485d-b073-d64b6ea0f5c2", "metadata": {"aucs": [0.45423475525930346, 0.5927976667991433, 0.4478207448727176, 0.5050373065997071, 0.4702452101766964, 0.48600792933161463, 0.47076454557405456, 0.4628399370104399, 0.4853636663808768, 0.33726603660181886, 0.33018451317248687, 0.33396336625706047, 0.4425371291857788, 0.2974828313252138, 0.4141294753826936, 0.3730189407893012, 0.30813130854410864, 0.3461288969541044, 0.16435226662354596, 0.14282092076003772, 0.16319680057437091, 0.15001804002325136, 0.16518068159824884, 0.16693403115746752, 0.12401076282336476, 0.146640494718295, 0.14774949250498903, 0.13136299521680062, 0.12263806891088969, 0.11770517957994231, 0.1288080516214728, 0.11923445010365974, 0.1283607237455393, 0.1276834095249737, 0.13797157202185917, 0.14278382299360637, 0.9053192009470553, 0.8660483334673228, 0.9002098347817125, 0.975528753634753, 0.9498768151140763, 0.9445713831460156, 0.9738097338493318, 0.9546027307857413, 0.9514852738835676, 0.3378366540342965, 0.3130663362093764, 0.3216204505781177, 0.3572684762827889, 0.2847855736383835, 0.3390576964849119, 0.323797335449335, 0.31248482374204145, 0.3254843614410512, 0.7880249127743724, 0.7758175415326543, 0.7783392489367843, 0.781922848511541, 0.7876052042262797, 0.7608748436472922, 0.7765301524640645, 0.753840082182759, 0.7735915016132198, 0.3513540289877535, 0.3511431583817436, 0.38881576447906285, 0.32503692437897147, 0.2942853050383335, 0.29451520135981135, 0.2638751731166953, 0.2667503703925358, 0.38910760164481784, 0.33656152910046244, 0.021415486323483446, 0.372303148440586, 0.29153955165403256, 0.35758051996796225, 0.3383168630044149, 0.3112497595998619, 0.3264443288445539, 0.29640982305402563, 0.36588962087293875, 0.37516436571613976, 0.33201560699079147, 0.30943352556367365, 0.3262494890216736, 0.2997028325377187, 0.3907390934044397, 0.32194466356153517, 0.22796188537421458, 0.45240315623337923, 0.391995025679059, 0.4447609638044835, 0.3820254651906416, 0.3826218333965329, 0.4067483142978534, 0.38295553856407283, 0.3900928423540908, 0.36603894508716717, 0.17625367710628392, 0.2109551027866866, 0.2205809325499385, 0.22380315548455176, 0.27971691250337327, 0.24837400025029177, 0.21942997024606548, 0.2071870123831504, 0.12357702720461383, 0.23987267419518454, 0.24723294465067003, 0.28439960781731466, 0.2652380083281898, 0.2534639690956757, 0.2901810812946989, 0.2678444904616174, 0.2612543370059113, 0.2761475624756643, 0.3987109691348111, 0.4495602710821951, 0.4406913655622201, 0.6054232260012435, 0.47533578333452753, 0.4972684102428657, 0.4460480911527953, 0.3917005747927599, 0.397540183501946, 0.14677607089834532, 0.1367358116217935, 0.17582005229186248, 0.12532546476573203, 0.1344847157120881, 0.1347318575860087, 0.10800363739350993, 0.13730443539785153, 0.13518870223482848, 0.2050279896955498, 0.4508391046717215, 0.3178774564801511, 0.3269608955603651, 0.40782590221522674, 0.444848699806772, 0.26668666247989925, 0.2732557627008909, 0.2466689090287728, 0.3460792704740334, 0.361252878730534, 0.3436855205734437, 0.32949183876596677, 0.3621127650035568, 0.36615005386039245, 0.3599892456795285, 0.3316229375803932, 0.36958342556268964, 0.30781149690747767, 0.33142653097099406, 0.34269916614612783, 0.29057010713019094, 0.3058052856572302, 0.332952085484867, 0.34173953289829684, 0.3242271853737194, 0.3359058879113027, 0.22613597482719083, 0.21910704009662563, 0.20853688730891606, 0.23279687908033264, 0.1996675940732865, 0.20849799083872966, 0.20629088373239002, 0.20250849847632868, 0.21712490380545602, 0.431474548940182, 0.18464654569699734, 0.1907854365928764, 0.1907486642456907, 0.4720491401871061, 0.21291994520546587, 0.19953007914403353, 0.23165119402685008, 0.19911964117185255, 0.5777238853222668, 0.1819694298511585, 0.805284722941409, 0.1827188108192469, 0.6718231135370532, 0.7342224072668191, 0.16788922892198066, 0.6570687801071586, 0.6195585362245959, 0.5543602853678709, 0.5448715393087575, 0.15220068708900103, 0.6788195176683121, 0.16107315122358468, 0.20351384609295642, 0.20722171834060177, 0.15100718461893448, 0.20705058968235823, 0.19291903330483506, 0.1927668071191252, 0.18051616448412133, 0.1804748863163672, 0.19290455161222564, 0.18847986626923618, 0.17334847366521866, 0.19250133426298022, 0.18740139095833652, 0.09666082236714824, 0.10126582876367973, 0.10604509092083714, 0.09250812907863437, 0.08016757558078114, 0.08723435933669532, 0.08754455264720873, 0.09042208314581235, 0.08687859416680477]}, "mutation_prompt": null}
{"id": "fd8a0c25-05da-4780-8f0f-5db89119a27c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n        no_improvement_count = 0  # Added line: Count the number of iterations without improvement\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    no_improvement_count = 0  # Reset the counter on improvement\n                    \n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.35)  # Changed line: Increase CR increment from 0.25 to 0.35\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n                    no_improvement_count += 1  # Increment the counter if no improvement\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n            # Random restart mechanism\n            if no_improvement_count > 20:  # If no improvement for 20 iterations\n                self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                self.fitness.fill(np.inf)\n                no_improvement_count = 0  # Reset the counter\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a random restart mechanism if there's no improvement over a defined number of iterations to escape local optima.", "configspace": "", "generation": 82, "fitness": 0.32033198849036915, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.21.", "error": "", "parent_id": "545e4b3a-748c-485d-b073-d64b6ea0f5c2", "metadata": {"aucs": [0.45423475525930346, 0.5927976667991433, 0.4478207448727176, 0.5050373065997071, 0.4702452101766964, 0.48600792933161463, 0.47076454557405456, 0.4628399370104399, 0.4853636663808768, 0.33726603660181886, 0.33018451317248687, 0.33396336625706047, 0.4425371291857788, 0.2974828313252138, 0.4141294753826936, 0.3730189407893012, 0.30813130854410864, 0.3461288969541044, 0.16435226662354596, 0.14282092076003772, 0.16319680057437091, 0.15001804002325136, 0.16518068159824884, 0.16693403115746752, 0.12401076282336476, 0.146640494718295, 0.14774949250498903, 0.13136299521680062, 0.12263806891088969, 0.11770517957994231, 0.1288080516214728, 0.11923445010365974, 0.1283607237455393, 0.1276834095249737, 0.13797157202185917, 0.14278382299360637, 0.9053192009470553, 0.8660483334673228, 0.9002098347817125, 0.975528753634753, 0.9498768151140763, 0.9445713831460156, 0.9738097338493318, 0.9546027307857413, 0.9514852738835676, 0.29070843210555886, 0.3130663362093764, 0.3216204505781177, 0.3572684762827889, 0.2847855736383835, 0.3390576964849119, 0.323797335449335, 0.31248482374204145, 0.3254843614410512, 0.7880249127743724, 0.431004714222187, 0.7783392489367843, 0.781922848511541, 0.7876052042262797, 0.7608748436472922, 0.7765301524640645, 0.753840082182759, 0.7735915016132198, 0.3513540289877535, 0.3511431583817436, 0.23048230760968147, 0.32503692437897147, 0.27914572412499006, 0.18550579761885455, 0.2638751731166953, 0.2667503703925358, 0.23880828688144828, 0.33656152910046244, 0.04157557771627596, 0.372303148440586, 0.19612630794122698, 0.281822438308139, 0.27801415950971464, 0.3112497595998619, 0.3264443288445539, 0.29640982305402563, 0.36588962087293875, 0.25004440566110564, 0.2344476197528721, 0.30943352556367365, 0.3011097124784452, 0.24440734531394515, 0.27126989648745437, 0.32194466356153517, 0.20200684820719328, 0.4044354335660353, 0.34887409402186587, 0.3141964741286172, 0.29535532671673226, 0.3826218333965329, 0.4067483142978534, 0.38295553856407283, 0.3900928423540908, 0.29481533705194574, 0.09879862041756826, 0.2109551027866866, 0.05613995759052559, 0.13827320240941188, 0.27971691250337327, 0.1350985190023375, 0.21942997024606548, 0.16100565706357595, 0.07929629642056757, 0.14857943973563215, 0.11913183386698512, 0.19248263000806032, 0.2652380083281898, 0.18186523467693327, 0.2901810812946989, 0.2678444904616174, 0.13159660441701293, 0.2761475624756643, 0.3987109691348111, 0.4495602710821951, 0.39799356059155133, 0.6013977427718196, 0.47533578333452753, 0.4972684102428657, 0.4460480911527953, 0.3917005747927599, 0.397540183501946, 0.14677607089834532, 0.1418781245437647, 0.17582005229186248, 0.1489481973596507, 0.1344847157120881, 0.1347318575860087, 0.10800363739350993, 0.12315055760191629, 0.13530294979410906, 0.2050201705896184, 0.16437276179395777, 0.2696158849765955, 0.3269608955603651, 0.16909947874456377, 0.444848699806772, 0.26668666247989925, 0.2732557627008909, 0.2466689090287728, 0.3460792704740334, 0.361252878730534, 0.3436855205734437, 0.32949183876596677, 0.3621127650035568, 0.36615005386039245, 0.3599892456795285, 0.3316229375803932, 0.36958342556268964, 0.29242580548302066, 0.33142653097099406, 0.34269916614612783, 0.29057010713019094, 0.3058052856572302, 0.329643939853665, 0.34173953289829684, 0.3242271853737194, 0.3359058879113027, 0.22613597482719083, 0.21162320494434161, 0.2090245939762222, 0.2047091423280355, 0.17868687515023085, 0.19943423664309223, 0.18443071459698523, 0.1971650663707082, 0.20546019477463862, 0.431474548940182, 0.18464654569699734, 0.1907854365928764, 0.1907486642456907, 0.4720491401871061, 0.21291994520546587, 0.19953007914403353, 0.23165119402685008, 0.19911964117185255, 0.19259616289878778, 0.5995814635433985, 0.805284722941409, 0.1827188108192469, 0.6718231135370532, 0.7342224072668191, 0.16788922892198066, 0.6570687801071586, 0.6195585362245959, 0.5543602853678709, 0.5448715393087575, 0.15220068708900103, 0.23707240945608243, 0.16107315122358468, 0.20351384609295642, 0.20722171834060177, 0.15701060236182407, 0.20705058968235823, 0.1870127559828616, 0.18663543478966993, 0.18657492308057178, 0.18114092667838688, 0.1899961846915198, 0.1785845235431378, 0.1751165122925089, 0.17973670415112575, 0.17924334137604458, 0.07629054291018289, 0.08788807416837008, 0.0895043406500492, 0.07389708452188626, 0.07825702833393788, 0.07163460488329487, 0.07751132196088273, 0.08347852039195935, 0.07699720383589359]}, "mutation_prompt": null}
{"id": "8c15c7a8-697f-46b4-bc80-6d95bd95f0e2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.35)  # Changed line: Increase CR increment from 0.25 to 0.35\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adjust the crossover probability (CR) increment more aggressively to enhance exploration.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "545e4b3a-748c-485d-b073-d64b6ea0f5c2", "metadata": {"aucs": [0.45423475525930346, 0.5927976667991433, 0.4478207448727176, 0.5050373065997071, 0.4702452101766964, 0.48600792933161463, 0.47076454557405456, 0.4628399370104399, 0.4853636663808768, 0.33726603660181886, 0.33018451317248687, 0.33396336625706047, 0.4425371291857788, 0.2974828313252138, 0.4141294753826936, 0.3730189407893012, 0.30813130854410864, 0.3461288969541044, 0.16435226662354596, 0.14282092076003772, 0.16319680057437091, 0.15001804002325136, 0.16518068159824884, 0.16693403115746752, 0.12401076282336476, 0.146640494718295, 0.14774949250498903, 0.13136299521680062, 0.12263806891088969, 0.11770517957994231, 0.1288080516214728, 0.11923445010365974, 0.1283607237455393, 0.1276834095249737, 0.13797157202185917, 0.14278382299360637, 0.9053192009470553, 0.8660483334673228, 0.9002098347817125, 0.975528753634753, 0.9498768151140763, 0.9445713831460156, 0.9738097338493318, 0.9546027307857413, 0.9514852738835676, 0.3378366540342965, 0.3130663362093764, 0.3216204505781177, 0.3572684762827889, 0.2847855736383835, 0.3390576964849119, 0.323797335449335, 0.31248482374204145, 0.3254843614410512, 0.7880249127743724, 0.7758175415326543, 0.7783392489367843, 0.781922848511541, 0.7876052042262797, 0.7608748436472922, 0.7765301524640645, 0.753840082182759, 0.7735915016132198, 0.3513540289877535, 0.3511431583817436, 0.38881576447906285, 0.32503692437897147, 0.2942853050383335, 0.29451520135981135, 0.2638751731166953, 0.2667503703925358, 0.38910760164481784, 0.33656152910046244, 0.021415486323483446, 0.372303148440586, 0.29153955165403256, 0.35758051996796225, 0.3383168630044149, 0.3112497595998619, 0.3264443288445539, 0.29640982305402563, 0.36588962087293875, 0.37516436571613976, 0.33201560699079147, 0.30943352556367365, 0.3262494890216736, 0.2997028325377187, 0.3907390934044397, 0.32194466356153517, 0.22796188537421458, 0.45240315623337923, 0.391995025679059, 0.4447609638044835, 0.3820254651906416, 0.3826218333965329, 0.4067483142978534, 0.38295553856407283, 0.3900928423540908, 0.36603894508716717, 0.17625367710628392, 0.2109551027866866, 0.2205809325499385, 0.22380315548455176, 0.27971691250337327, 0.24837400025029177, 0.21942997024606548, 0.2071870123831504, 0.12357702720461383, 0.23987267419518454, 0.24723294465067003, 0.28439960781731466, 0.2652380083281898, 0.2534639690956757, 0.2901810812946989, 0.2678444904616174, 0.2612543370059113, 0.2761475624756643, 0.3987109691348111, 0.4495602710821951, 0.4406913655622201, 0.6054232260012435, 0.47533578333452753, 0.4972684102428657, 0.4460480911527953, 0.3917005747927599, 0.397540183501946, 0.14677607089834532, 0.1367358116217935, 0.17582005229186248, 0.12532546476573203, 0.1344847157120881, 0.1347318575860087, 0.10800363739350993, 0.13730443539785153, 0.13518870223482848, 0.2050279896955498, 0.4508391046717215, 0.3178774564801511, 0.3269608955603651, 0.40782590221522674, 0.444848699806772, 0.26668666247989925, 0.2732557627008909, 0.2466689090287728, 0.3460792704740334, 0.361252878730534, 0.3436855205734437, 0.32949183876596677, 0.3621127650035568, 0.36615005386039245, 0.3599892456795285, 0.3316229375803932, 0.36958342556268964, 0.30781149690747767, 0.33142653097099406, 0.34269916614612783, 0.29057010713019094, 0.3058052856572302, 0.332952085484867, 0.34173953289829684, 0.3242271853737194, 0.3359058879113027, 0.22613597482719083, 0.21910704009662563, 0.20853688730891606, 0.23279687908033264, 0.1996675940732865, 0.20849799083872966, 0.20629088373239002, 0.20250849847632868, 0.21712490380545602, 0.431474548940182, 0.18464654569699734, 0.1907854365928764, 0.1907486642456907, 0.4720491401871061, 0.21291994520546587, 0.19953007914403353, 0.23165119402685008, 0.19911964117185255, 0.5777238853222668, 0.1819694298511585, 0.805284722941409, 0.1827188108192469, 0.6718231135370532, 0.7342224072668191, 0.16788922892198066, 0.6570687801071586, 0.6195585362245959, 0.5543602853678709, 0.5448715393087575, 0.15220068708900103, 0.6788195176683121, 0.16107315122358468, 0.20351384609295642, 0.20722171834060177, 0.15100718461893448, 0.20705058968235823, 0.19291903330483506, 0.1927668071191252, 0.18051616448412133, 0.1804748863163672, 0.19290455161222564, 0.18847986626923618, 0.17334847366521866, 0.19250133426298022, 0.18740139095833652, 0.09666082236714824, 0.10126582876367973, 0.10604509092083714, 0.09250812907863437, 0.08016757558078114, 0.08723435933669532, 0.08754455264720873, 0.09042208314581235, 0.08687859416680477]}, "mutation_prompt": null}
{"id": "098a1ef5-9e9b-4f68-b1ad-f7a37808d041", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.15)  # Changed line: Increase F increment from 0.1 to 0.15\n                    self.CR = min(1.0, self.CR + 0.35)\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration by increasing the mutation factor (F) more aggressively upon successful trials.", "configspace": "", "generation": 84, "fitness": 0.31564749767274386, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.20.", "error": "", "parent_id": "545e4b3a-748c-485d-b073-d64b6ea0f5c2", "metadata": {"aucs": [0.42086438510626434, 0.5157225673050797, 0.465867950749285, 0.5032063456240097, 0.502684528812086, 0.47263303979875493, 0.4889859211657852, 0.45905092699849337, 0.4850543877740753, 0.28714257908396545, 0.34313065286760247, 0.26337188939312084, 0.3662835935881217, 0.29146144950061537, 0.35024367113743826, 0.3120589932055202, 0.2689782249135485, 0.33077157773032784, 0.15755408891943168, 0.29444378978350716, 0.15742269137939968, 0.28697906982414856, 0.15711537763855232, 0.13542997543864166, 0.1621638509948371, 0.35023506426195083, 0.16426017057926767, 0.14625924948022218, 0.13370874365786167, 0.1354644663999388, 0.10277807888548485, 0.12640765399913034, 0.10267385094457981, 0.1316875226242673, 0.1287747280342464, 0.12807692506982238, 0.9532431455400221, 0.9294343409497433, 0.9555974201241896, 0.98676811799101, 0.9538667287913051, 0.9404095122737225, 0.9738097338493318, 0.9727931151435046, 0.9672136740533176, 0.2972734061168687, 0.2864109719819886, 0.3034829513431254, 0.3051145792036106, 0.3103210198700823, 0.3148102517260347, 0.2851861835714562, 0.3043761762158199, 0.307427441974367, 0.7287278810916313, 0.6890015347240841, 0.35180881495965843, 0.6869045304628857, 0.6976194743903567, 0.7369364995669909, 0.694573197311686, 0.7022643016014674, 0.6860867169477396, 0.2579705575521398, 0.253250322204999, 0.28165017482456645, 0.23258816174143526, 0.2860056520539451, 0.31402204768872277, 0.24671967724663169, 0.31595810147164693, 0.33725028860867656, 0.04927309614839137, 0.30327676697537065, 0.12364667529720685, 0.292277183762091, 0.23461770922553538, 0.2766305878397469, 0.34165375713970547, 0.25474053232703486, 0.2675967089320349, 0.29628827116784473, 0.27495026172297665, 0.28083684513036955, 0.27573908958303295, 0.2704437520293931, 0.24592958735830572, 0.28479927658218385, 0.28927599354763023, 0.2793616051198913, 0.3899192565571322, 0.42343163433081155, 0.35713285134091877, 0.27109695702748093, 0.3466265582883391, 0.35927718680246856, 0.325305740714534, 0.35342746165498584, 0.38835233450906226, 0.16096211331105803, 0.11132255882045505, 0.12495102181657369, 0.1535565150965965, 0.13896661280293865, 0.1550468892874689, 0.11999971245524177, 0.1469206527317254, 0.10086960338461215, 0.212155909232559, 0.20811893599684783, 0.22293035429750474, 0.18361474453287974, 0.2250722127912771, 0.23651193141512872, 0.22724453638358755, 0.21662600552471445, 0.24367905926019418, 0.4223474182480724, 0.43148875858612046, 0.4532970750754618, 0.4256710962048986, 0.4531296505915695, 0.438455662976897, 0.43691237783973824, 0.388327692959641, 0.4252670539970437, 0.13161488960638235, 0.31853344602413525, 0.16104295495295284, 0.16714072544423675, 0.11266513583318138, 0.1443953740577013, 0.12937627214382041, 0.16061359338620096, 0.12819788040031033, 0.3507832106424652, 0.39261986259080506, 0.4845071649515992, 0.4077513703997949, 0.40474742370198835, 0.246720560990901, 0.3522371010368881, 0.21173978890379042, 0.2431732682426221, 0.333689451951962, 0.346479043100136, 0.351060631560549, 0.32725106753891, 0.336248262851109, 0.3428129706299391, 0.33396236580197236, 0.3412567703020726, 0.36042643364913896, 0.3171871288220137, 0.31115252659231174, 0.30184335743916324, 0.29752391863011785, 0.3057271163620958, 0.2879535958176598, 0.2998965997866908, 0.30187600977622053, 0.28440948609733363, 0.21039221387221607, 0.20455903677880127, 0.2161893814710707, 0.22103700901201873, 0.20390855246967454, 0.19639351508467606, 0.20425560692381062, 0.19929832150906945, 0.21580511820756298, 0.21919707720047177, 0.2170894684497262, 0.21390070144200912, 0.22097956836006738, 0.18733770445983022, 0.38677924661113794, 0.20993584317147584, 0.1912028787201221, 0.20634969115107415, 0.15257468590750922, 0.5245153523228866, 0.7349723908077708, 0.6744768044568894, 0.16589938796790304, 0.20195874575052397, 0.20436704581250975, 0.7251036331760841, 0.19957658986412885, 0.6735358345645277, 0.16417662029411062, 0.16250729106219985, 0.577872518417945, 0.20153124932195965, 0.19676934865044926, 0.20677595915028824, 0.5569522383347458, 0.20536789742124872, 0.18846609699241978, 0.1860435472358949, 0.18178958226178643, 0.1934894575952345, 0.1881175155493383, 0.17918162253172742, 0.19599466038528934, 0.191510242626041, 0.18298461203300564, 0.0918751432168099, 0.08902186190347261, 0.08548652896933562, 0.08522488786540039, 0.09323304622604578, 0.08808541305664652, 0.08742037773988598, 0.08905813657504824, 0.10553695177818967]}, "mutation_prompt": null}
{"id": "2d27f685-49ae-498b-b968-62b62eab283f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.35)  # Changed line: Increase CR increment from 0.25 to 0.35\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adjust the crossover probability (CR) increment more aggressively to enhance exploration.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "545e4b3a-748c-485d-b073-d64b6ea0f5c2", "metadata": {"aucs": [0.45423475525930346, 0.5927976667991433, 0.4478207448727176, 0.5050373065997071, 0.4702452101766964, 0.48600792933161463, 0.47076454557405456, 0.4628399370104399, 0.4853636663808768, 0.33726603660181886, 0.33018451317248687, 0.33396336625706047, 0.4425371291857788, 0.2974828313252138, 0.4141294753826936, 0.3730189407893012, 0.30813130854410864, 0.3461288969541044, 0.16435226662354596, 0.14282092076003772, 0.16319680057437091, 0.15001804002325136, 0.16518068159824884, 0.16693403115746752, 0.12401076282336476, 0.146640494718295, 0.14774949250498903, 0.13136299521680062, 0.12263806891088969, 0.11770517957994231, 0.1288080516214728, 0.11923445010365974, 0.1283607237455393, 0.1276834095249737, 0.13797157202185917, 0.14278382299360637, 0.9053192009470553, 0.8660483334673228, 0.9002098347817125, 0.975528753634753, 0.9498768151140763, 0.9445713831460156, 0.9738097338493318, 0.9546027307857413, 0.9514852738835676, 0.3378366540342965, 0.3130663362093764, 0.3216204505781177, 0.3572684762827889, 0.2847855736383835, 0.3390576964849119, 0.323797335449335, 0.31248482374204145, 0.3254843614410512, 0.7880249127743724, 0.7758175415326543, 0.7783392489367843, 0.781922848511541, 0.7876052042262797, 0.7608748436472922, 0.7765301524640645, 0.753840082182759, 0.7735915016132198, 0.3513540289877535, 0.3511431583817436, 0.38881576447906285, 0.32503692437897147, 0.2942853050383335, 0.29451520135981135, 0.2638751731166953, 0.2667503703925358, 0.38910760164481784, 0.33656152910046244, 0.021415486323483446, 0.372303148440586, 0.29153955165403256, 0.35758051996796225, 0.3383168630044149, 0.3112497595998619, 0.3264443288445539, 0.29640982305402563, 0.36588962087293875, 0.37516436571613976, 0.33201560699079147, 0.30943352556367365, 0.3262494890216736, 0.2997028325377187, 0.3907390934044397, 0.32194466356153517, 0.22796188537421458, 0.45240315623337923, 0.391995025679059, 0.4447609638044835, 0.3820254651906416, 0.3826218333965329, 0.4067483142978534, 0.38295553856407283, 0.3900928423540908, 0.36603894508716717, 0.17625367710628392, 0.2109551027866866, 0.2205809325499385, 0.22380315548455176, 0.27971691250337327, 0.24837400025029177, 0.21942997024606548, 0.2071870123831504, 0.12357702720461383, 0.23987267419518454, 0.24723294465067003, 0.28439960781731466, 0.2652380083281898, 0.2534639690956757, 0.2901810812946989, 0.2678444904616174, 0.2612543370059113, 0.2761475624756643, 0.3987109691348111, 0.4495602710821951, 0.4406913655622201, 0.6054232260012435, 0.47533578333452753, 0.4972684102428657, 0.4460480911527953, 0.3917005747927599, 0.397540183501946, 0.14677607089834532, 0.1367358116217935, 0.17582005229186248, 0.12532546476573203, 0.1344847157120881, 0.1347318575860087, 0.10800363739350993, 0.13730443539785153, 0.13518870223482848, 0.2050279896955498, 0.4508391046717215, 0.3178774564801511, 0.3269608955603651, 0.40782590221522674, 0.444848699806772, 0.26668666247989925, 0.2732557627008909, 0.2466689090287728, 0.3460792704740334, 0.361252878730534, 0.3436855205734437, 0.32949183876596677, 0.3621127650035568, 0.36615005386039245, 0.3599892456795285, 0.3316229375803932, 0.36958342556268964, 0.30781149690747767, 0.33142653097099406, 0.34269916614612783, 0.29057010713019094, 0.3058052856572302, 0.332952085484867, 0.34173953289829684, 0.3242271853737194, 0.3359058879113027, 0.22613597482719083, 0.21910704009662563, 0.20853688730891606, 0.23279687908033264, 0.1996675940732865, 0.20849799083872966, 0.20629088373239002, 0.20250849847632868, 0.21712490380545602, 0.431474548940182, 0.18464654569699734, 0.1907854365928764, 0.1907486642456907, 0.4720491401871061, 0.21291994520546587, 0.19953007914403353, 0.23165119402685008, 0.19911964117185255, 0.5777238853222668, 0.1819694298511585, 0.805284722941409, 0.1827188108192469, 0.6718231135370532, 0.7342224072668191, 0.16788922892198066, 0.6570687801071586, 0.6195585362245959, 0.5543602853678709, 0.5448715393087575, 0.15220068708900103, 0.6788195176683121, 0.16107315122358468, 0.20351384609295642, 0.20722171834060177, 0.15100718461893448, 0.20705058968235823, 0.19291903330483506, 0.1927668071191252, 0.18051616448412133, 0.1804748863163672, 0.19290455161222564, 0.18847986626923618, 0.17334847366521866, 0.19250133426298022, 0.18740139095833652, 0.09666082236714824, 0.10126582876367973, 0.10604509092083714, 0.09250812907863437, 0.08016757558078114, 0.08723435933669532, 0.08754455264720873, 0.09042208314581235, 0.08687859416680477]}, "mutation_prompt": null}
{"id": "0c0d38f4-3290-4aad-b869-c10d74b4ff6e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.35)  # Changed line: Increase CR increment from 0.25 to 0.35\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adjust the crossover probability (CR) increment more aggressively to enhance exploration.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "545e4b3a-748c-485d-b073-d64b6ea0f5c2", "metadata": {"aucs": [0.45423475525930346, 0.5927976667991433, 0.4478207448727176, 0.5050373065997071, 0.4702452101766964, 0.48600792933161463, 0.47076454557405456, 0.4628399370104399, 0.4853636663808768, 0.33726603660181886, 0.33018451317248687, 0.33396336625706047, 0.4425371291857788, 0.2974828313252138, 0.4141294753826936, 0.3730189407893012, 0.30813130854410864, 0.3461288969541044, 0.16435226662354596, 0.14282092076003772, 0.16319680057437091, 0.15001804002325136, 0.16518068159824884, 0.16693403115746752, 0.12401076282336476, 0.146640494718295, 0.14774949250498903, 0.13136299521680062, 0.12263806891088969, 0.11770517957994231, 0.1288080516214728, 0.11923445010365974, 0.1283607237455393, 0.1276834095249737, 0.13797157202185917, 0.14278382299360637, 0.9053192009470553, 0.8660483334673228, 0.9002098347817125, 0.975528753634753, 0.9498768151140763, 0.9445713831460156, 0.9738097338493318, 0.9546027307857413, 0.9514852738835676, 0.3378366540342965, 0.3130663362093764, 0.3216204505781177, 0.3572684762827889, 0.2847855736383835, 0.3390576964849119, 0.323797335449335, 0.31248482374204145, 0.3254843614410512, 0.7880249127743724, 0.7758175415326543, 0.7783392489367843, 0.781922848511541, 0.7876052042262797, 0.7608748436472922, 0.7765301524640645, 0.753840082182759, 0.7735915016132198, 0.3513540289877535, 0.3511431583817436, 0.38881576447906285, 0.32503692437897147, 0.2942853050383335, 0.29451520135981135, 0.2638751731166953, 0.2667503703925358, 0.38910760164481784, 0.33656152910046244, 0.021415486323483446, 0.372303148440586, 0.29153955165403256, 0.35758051996796225, 0.3383168630044149, 0.3112497595998619, 0.3264443288445539, 0.29640982305402563, 0.36588962087293875, 0.37516436571613976, 0.33201560699079147, 0.30943352556367365, 0.3262494890216736, 0.2997028325377187, 0.3907390934044397, 0.32194466356153517, 0.22796188537421458, 0.45240315623337923, 0.391995025679059, 0.4447609638044835, 0.3820254651906416, 0.3826218333965329, 0.4067483142978534, 0.38295553856407283, 0.3900928423540908, 0.36603894508716717, 0.17625367710628392, 0.2109551027866866, 0.2205809325499385, 0.22380315548455176, 0.27971691250337327, 0.24837400025029177, 0.21942997024606548, 0.2071870123831504, 0.12357702720461383, 0.23987267419518454, 0.24723294465067003, 0.28439960781731466, 0.2652380083281898, 0.2534639690956757, 0.2901810812946989, 0.2678444904616174, 0.2612543370059113, 0.2761475624756643, 0.3987109691348111, 0.4495602710821951, 0.4406913655622201, 0.6054232260012435, 0.47533578333452753, 0.4972684102428657, 0.4460480911527953, 0.3917005747927599, 0.397540183501946, 0.14677607089834532, 0.1367358116217935, 0.17582005229186248, 0.12532546476573203, 0.1344847157120881, 0.1347318575860087, 0.10800363739350993, 0.13730443539785153, 0.13518870223482848, 0.2050279896955498, 0.4508391046717215, 0.3178774564801511, 0.3269608955603651, 0.40782590221522674, 0.444848699806772, 0.26668666247989925, 0.2732557627008909, 0.2466689090287728, 0.3460792704740334, 0.361252878730534, 0.3436855205734437, 0.32949183876596677, 0.3621127650035568, 0.36615005386039245, 0.3599892456795285, 0.3316229375803932, 0.36958342556268964, 0.30781149690747767, 0.33142653097099406, 0.34269916614612783, 0.29057010713019094, 0.3058052856572302, 0.332952085484867, 0.34173953289829684, 0.3242271853737194, 0.3359058879113027, 0.22613597482719083, 0.21910704009662563, 0.20853688730891606, 0.23279687908033264, 0.1996675940732865, 0.20849799083872966, 0.20629088373239002, 0.20250849847632868, 0.21712490380545602, 0.431474548940182, 0.18464654569699734, 0.1907854365928764, 0.1907486642456907, 0.4720491401871061, 0.21291994520546587, 0.19953007914403353, 0.23165119402685008, 0.19911964117185255, 0.5777238853222668, 0.1819694298511585, 0.805284722941409, 0.1827188108192469, 0.6718231135370532, 0.7342224072668191, 0.16788922892198066, 0.6570687801071586, 0.6195585362245959, 0.5543602853678709, 0.5448715393087575, 0.15220068708900103, 0.6788195176683121, 0.16107315122358468, 0.20351384609295642, 0.20722171834060177, 0.15100718461893448, 0.20705058968235823, 0.19291903330483506, 0.1927668071191252, 0.18051616448412133, 0.1804748863163672, 0.19290455161222564, 0.18847986626923618, 0.17334847366521866, 0.19250133426298022, 0.18740139095833652, 0.09666082236714824, 0.10126582876367973, 0.10604509092083714, 0.09250812907863437, 0.08016757558078114, 0.08723435933669532, 0.08754455264720873, 0.09042208314581235, 0.08687859416680477]}, "mutation_prompt": null}
{"id": "cd1faed6-ba1b-4675-8ae4-ef1b3d863fb3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.35)  # Changed line: Increase CR increment from 0.25 to 0.35\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-3:  # Changed line: Adjust variance threshold from 1e-4 to 1e-3\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Fine-tune population resizing to react more dynamically to fitness variance changes.", "configspace": "", "generation": 87, "fitness": 0.3147761875476164, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.19.", "error": "", "parent_id": "545e4b3a-748c-485d-b073-d64b6ea0f5c2", "metadata": {"aucs": [0.46008561352372046, 0.6015783899073985, 0.4433137235460898, 0.5303044307889315, 0.4518635961658767, 0.44560896264287597, 0.4377087952680906, 0.3955777875350205, 0.42403502277763605, 0.2994019981807571, 0.31273971534143585, 0.421798209137782, 0.29282615588578487, 0.3100788869154668, 0.4033024770769321, 0.31252043350442915, 0.333247691615146, 0.2846566372674597, 0.1642979705170805, 0.14280443005087795, 0.1631796403983793, 0.15001598516646286, 0.16514036187924452, 0.1669409609129341, 0.12400000573795733, 0.1466425248358455, 0.14775874118493104, 0.13136008990050485, 0.1226359026843653, 0.11769933028755108, 0.1288106493086425, 0.11923066395043247, 0.12835167969261962, 0.12766896402714756, 0.1379762298688424, 0.14269787525779698, 0.9053192009470553, 0.8660483334673228, 0.9002098347817125, 0.975528753634753, 0.9498768151140763, 0.9445713831460156, 0.9738097338493318, 0.9546027307857413, 0.9514852738835676, 0.27155832128440993, 0.29842631393150143, 0.3114749181988977, 0.3654515412640934, 0.2638347064848665, 0.324666525818032, 0.2808543231982109, 0.2898979336442894, 0.2717667378016587, 0.7938881964497029, 0.7853746939234427, 0.36122524827395586, 0.7831375810819017, 0.7876052042262797, 0.37013041968301463, 0.3620845800021242, 0.36118488244316704, 0.7676811121151255, 0.2759118444056988, 0.2824140177980675, 0.28902753302045703, 0.258696892089356, 0.2615333101836145, 0.2602937528735684, 0.24056569157994045, 0.220455063334981, 0.376170548714744, 0.331432483882541, 0.021415486143243623, 0.3852123470645967, 0.2653947364642254, 0.3293407662793374, 0.3090237631951833, 0.2672658678720222, 0.31506147320335853, 0.28669760652086296, 0.3086250185877256, 0.29372362832286547, 0.2822032853708475, 0.3061796291448391, 0.31744513632727234, 0.3007075487669466, 0.3047197125644099, 0.30640223175905, 0.21140710635548998, 0.3858205835626759, 0.34465041937977625, 0.3463855774344389, 0.37716079793054136, 0.40517126184519736, 0.3336045639986659, 0.4007528991047289, 0.3375767961676336, 0.34328194434694215, 0.176867255546737, 0.20334180247920075, 0.19737441912136622, 0.2168518734153626, 0.22229904124645117, 0.2467019277948419, 0.20729061062934429, 0.19822401569379822, 0.12451881593037506, 0.28045321839816195, 0.26601374641644304, 0.2536199845069691, 0.2351351958752642, 0.25501509542726564, 0.2554791939840554, 0.2523944547273883, 0.28723440290208224, 0.2748958856055338, 0.39157124812778965, 0.4494733697237301, 0.3739475160164041, 0.4803877736985316, 0.42879438530989233, 0.4087583237150838, 0.39220362056322733, 0.35963820641620214, 0.3848920331650423, 0.1467848403353018, 0.13674055577174427, 0.17578881669076218, 0.12533240190053874, 0.13450059117716084, 0.13471376751192532, 0.10759909390518785, 0.13730181470183722, 0.13519112044066273, 0.20232367959857134, 0.41033651110090774, 0.3218529813322484, 0.31690625965869623, 0.35098529112743293, 0.3463986735789629, 0.26624339640152306, 0.26343400226366476, 0.24402269765771034, 0.328821816546363, 0.33907673638505254, 0.3306987351165519, 0.3395969655549539, 0.31399480731749807, 0.3197618131261937, 0.31700155072766856, 0.3433380271403952, 0.3210119165848725, 0.3080270493108185, 0.3257010270816776, 0.3134287756059714, 0.2825031600057397, 0.29571131314632626, 0.2898091720294751, 0.29366915734958543, 0.31057693969981914, 0.3056646866353977, 0.22613597482719083, 0.21910704009662563, 0.20853688730891606, 0.23279687908033264, 0.1996675940732865, 0.20849799083872966, 0.20629088373239002, 0.20250849847632868, 0.21712490380545602, 0.393944777478475, 0.1846046531700667, 0.1907882748817722, 0.19071918597324977, 0.5020507061852755, 0.2128470824405152, 0.1993171599226985, 0.23165125497402206, 0.19903498514163043, 0.5278527492255736, 0.1819703271922256, 0.577858735169319, 0.18267657715657948, 0.7386503385787668, 0.5441572774299916, 0.16786578617052328, 0.58056862066787, 0.6081607275383526, 0.49018704939950897, 0.6862038819093261, 0.15217636535414736, 0.3885881627546385, 0.16104251964107974, 0.20345647003514555, 0.20707314963678036, 0.15096980875252464, 0.20702348869939813, 0.19291903330483506, 0.1927668071191252, 0.18051616448412133, 0.1804748863163672, 0.19290455161222564, 0.18847986626923618, 0.17334847366521866, 0.19250133426298022, 0.18740139095833652, 0.09666533606713779, 0.10126582876367973, 0.10603605705892893, 0.09250812907863437, 0.08016757558078114, 0.08723435933669532, 0.08754455264720873, 0.09042208314581235, 0.08687859416680477]}, "mutation_prompt": null}
{"id": "19f06cd1-d336-4385-bf68-e2d3597ca1c9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.35)  # Changed line: Increase CR increment from 0.25 to 0.35\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adjust the crossover probability (CR) increment more aggressively to enhance exploration.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "545e4b3a-748c-485d-b073-d64b6ea0f5c2", "metadata": {"aucs": [0.45423475525930346, 0.5927976667991433, 0.4478207448727176, 0.5050373065997071, 0.4702452101766964, 0.48600792933161463, 0.47076454557405456, 0.4628399370104399, 0.4853636663808768, 0.33726603660181886, 0.33018451317248687, 0.33396336625706047, 0.4425371291857788, 0.2974828313252138, 0.4141294753826936, 0.3730189407893012, 0.30813130854410864, 0.3461288969541044, 0.16435226662354596, 0.14282092076003772, 0.16319680057437091, 0.15001804002325136, 0.16518068159824884, 0.16693403115746752, 0.12401076282336476, 0.146640494718295, 0.14774949250498903, 0.13136299521680062, 0.12263806891088969, 0.11770517957994231, 0.1288080516214728, 0.11923445010365974, 0.1283607237455393, 0.1276834095249737, 0.13797157202185917, 0.14278382299360637, 0.9053192009470553, 0.8660483334673228, 0.9002098347817125, 0.975528753634753, 0.9498768151140763, 0.9445713831460156, 0.9738097338493318, 0.9546027307857413, 0.9514852738835676, 0.3378366540342965, 0.3130663362093764, 0.3216204505781177, 0.3572684762827889, 0.2847855736383835, 0.3390576964849119, 0.323797335449335, 0.31248482374204145, 0.3254843614410512, 0.7880249127743724, 0.7758175415326543, 0.7783392489367843, 0.781922848511541, 0.7876052042262797, 0.7608748436472922, 0.7765301524640645, 0.753840082182759, 0.7735915016132198, 0.3513540289877535, 0.3511431583817436, 0.38881576447906285, 0.32503692437897147, 0.2942853050383335, 0.29451520135981135, 0.2638751731166953, 0.2667503703925358, 0.38910760164481784, 0.33656152910046244, 0.021415486323483446, 0.372303148440586, 0.29153955165403256, 0.35758051996796225, 0.3383168630044149, 0.3112497595998619, 0.3264443288445539, 0.29640982305402563, 0.36588962087293875, 0.37516436571613976, 0.33201560699079147, 0.30943352556367365, 0.3262494890216736, 0.2997028325377187, 0.3907390934044397, 0.32194466356153517, 0.22796188537421458, 0.45240315623337923, 0.391995025679059, 0.4447609638044835, 0.3820254651906416, 0.3826218333965329, 0.4067483142978534, 0.38295553856407283, 0.3900928423540908, 0.36603894508716717, 0.17625367710628392, 0.2109551027866866, 0.2205809325499385, 0.22380315548455176, 0.27971691250337327, 0.24837400025029177, 0.21942997024606548, 0.2071870123831504, 0.12357702720461383, 0.23987267419518454, 0.24723294465067003, 0.28439960781731466, 0.2652380083281898, 0.2534639690956757, 0.2901810812946989, 0.2678444904616174, 0.2612543370059113, 0.2761475624756643, 0.3987109691348111, 0.4495602710821951, 0.4406913655622201, 0.6054232260012435, 0.47533578333452753, 0.4972684102428657, 0.4460480911527953, 0.3917005747927599, 0.397540183501946, 0.14677607089834532, 0.1367358116217935, 0.17582005229186248, 0.12532546476573203, 0.1344847157120881, 0.1347318575860087, 0.10800363739350993, 0.13730443539785153, 0.13518870223482848, 0.2050279896955498, 0.4508391046717215, 0.3178774564801511, 0.3269608955603651, 0.40782590221522674, 0.444848699806772, 0.26668666247989925, 0.2732557627008909, 0.2466689090287728, 0.3460792704740334, 0.361252878730534, 0.3436855205734437, 0.32949183876596677, 0.3621127650035568, 0.36615005386039245, 0.3599892456795285, 0.3316229375803932, 0.36958342556268964, 0.30781149690747767, 0.33142653097099406, 0.34269916614612783, 0.29057010713019094, 0.3058052856572302, 0.332952085484867, 0.34173953289829684, 0.3242271853737194, 0.3359058879113027, 0.22613597482719083, 0.21910704009662563, 0.20853688730891606, 0.23279687908033264, 0.1996675940732865, 0.20849799083872966, 0.20629088373239002, 0.20250849847632868, 0.21712490380545602, 0.431474548940182, 0.18464654569699734, 0.1907854365928764, 0.1907486642456907, 0.4720491401871061, 0.21291994520546587, 0.19953007914403353, 0.23165119402685008, 0.19911964117185255, 0.5777238853222668, 0.1819694298511585, 0.805284722941409, 0.1827188108192469, 0.6718231135370532, 0.7342224072668191, 0.16788922892198066, 0.6570687801071586, 0.6195585362245959, 0.5543602853678709, 0.5448715393087575, 0.15220068708900103, 0.6788195176683121, 0.16107315122358468, 0.20351384609295642, 0.20722171834060177, 0.15100718461893448, 0.20705058968235823, 0.19291903330483506, 0.1927668071191252, 0.18051616448412133, 0.1804748863163672, 0.19290455161222564, 0.18847986626923618, 0.17334847366521866, 0.19250133426298022, 0.18740139095833652, 0.09666082236714824, 0.10126582876367973, 0.10604509092083714, 0.09250812907863437, 0.08016757558078114, 0.08723435933669532, 0.08754455264720873, 0.09042208314581235, 0.08687859416680477]}, "mutation_prompt": null}
{"id": "dff391f7-13c6-4212-94eb-e7f17e98acce", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.35)  # Changed line: Increase CR increment from 0.25 to 0.35\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)  # Changed line: Adjust mutation factor decrement (from 0.02 to 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adjust the crossover probability (CR) increment more aggressively to enhance exploration.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "545e4b3a-748c-485d-b073-d64b6ea0f5c2", "metadata": {"aucs": [0.45423475525930346, 0.5927976667991433, 0.4478207448727176, 0.5050373065997071, 0.4702452101766964, 0.48600792933161463, 0.47076454557405456, 0.4628399370104399, 0.4853636663808768, 0.33726603660181886, 0.33018451317248687, 0.33396336625706047, 0.4425371291857788, 0.2974828313252138, 0.4141294753826936, 0.3730189407893012, 0.30813130854410864, 0.3461288969541044, 0.16435226662354596, 0.14282092076003772, 0.16319680057437091, 0.15001804002325136, 0.16518068159824884, 0.16693403115746752, 0.12401076282336476, 0.146640494718295, 0.14774949250498903, 0.13136299521680062, 0.12263806891088969, 0.11770517957994231, 0.1288080516214728, 0.11923445010365974, 0.1283607237455393, 0.1276834095249737, 0.13797157202185917, 0.14278382299360637, 0.9053192009470553, 0.8660483334673228, 0.9002098347817125, 0.975528753634753, 0.9498768151140763, 0.9445713831460156, 0.9738097338493318, 0.9546027307857413, 0.9514852738835676, 0.3378366540342965, 0.3130663362093764, 0.3216204505781177, 0.3572684762827889, 0.2847855736383835, 0.3390576964849119, 0.323797335449335, 0.31248482374204145, 0.3254843614410512, 0.7880249127743724, 0.7758175415326543, 0.7783392489367843, 0.781922848511541, 0.7876052042262797, 0.7608748436472922, 0.7765301524640645, 0.753840082182759, 0.7735915016132198, 0.3513540289877535, 0.3511431583817436, 0.38881576447906285, 0.32503692437897147, 0.2942853050383335, 0.29451520135981135, 0.2638751731166953, 0.2667503703925358, 0.38910760164481784, 0.33656152910046244, 0.021415486323483446, 0.372303148440586, 0.29153955165403256, 0.35758051996796225, 0.3383168630044149, 0.3112497595998619, 0.3264443288445539, 0.29640982305402563, 0.36588962087293875, 0.37516436571613976, 0.33201560699079147, 0.30943352556367365, 0.3262494890216736, 0.2997028325377187, 0.3907390934044397, 0.32194466356153517, 0.22796188537421458, 0.45240315623337923, 0.391995025679059, 0.4447609638044835, 0.3820254651906416, 0.3826218333965329, 0.4067483142978534, 0.38295553856407283, 0.3900928423540908, 0.36603894508716717, 0.17625367710628392, 0.2109551027866866, 0.2205809325499385, 0.22380315548455176, 0.27971691250337327, 0.24837400025029177, 0.21942997024606548, 0.2071870123831504, 0.12357702720461383, 0.23987267419518454, 0.24723294465067003, 0.28439960781731466, 0.2652380083281898, 0.2534639690956757, 0.2901810812946989, 0.2678444904616174, 0.2612543370059113, 0.2761475624756643, 0.3987109691348111, 0.4495602710821951, 0.4406913655622201, 0.6054232260012435, 0.47533578333452753, 0.4972684102428657, 0.4460480911527953, 0.3917005747927599, 0.397540183501946, 0.14677607089834532, 0.1367358116217935, 0.17582005229186248, 0.12532546476573203, 0.1344847157120881, 0.1347318575860087, 0.10800363739350993, 0.13730443539785153, 0.13518870223482848, 0.2050279896955498, 0.4508391046717215, 0.3178774564801511, 0.3269608955603651, 0.40782590221522674, 0.444848699806772, 0.26668666247989925, 0.2732557627008909, 0.2466689090287728, 0.3460792704740334, 0.361252878730534, 0.3436855205734437, 0.32949183876596677, 0.3621127650035568, 0.36615005386039245, 0.3599892456795285, 0.3316229375803932, 0.36958342556268964, 0.30781149690747767, 0.33142653097099406, 0.34269916614612783, 0.29057010713019094, 0.3058052856572302, 0.332952085484867, 0.34173953289829684, 0.3242271853737194, 0.3359058879113027, 0.22613597482719083, 0.21910704009662563, 0.20853688730891606, 0.23279687908033264, 0.1996675940732865, 0.20849799083872966, 0.20629088373239002, 0.20250849847632868, 0.21712490380545602, 0.431474548940182, 0.18464654569699734, 0.1907854365928764, 0.1907486642456907, 0.4720491401871061, 0.21291994520546587, 0.19953007914403353, 0.23165119402685008, 0.19911964117185255, 0.5777238853222668, 0.1819694298511585, 0.805284722941409, 0.1827188108192469, 0.6718231135370532, 0.7342224072668191, 0.16788922892198066, 0.6570687801071586, 0.6195585362245959, 0.5543602853678709, 0.5448715393087575, 0.15220068708900103, 0.6788195176683121, 0.16107315122358468, 0.20351384609295642, 0.20722171834060177, 0.15100718461893448, 0.20705058968235823, 0.19291903330483506, 0.1927668071191252, 0.18051616448412133, 0.1804748863163672, 0.19290455161222564, 0.18847986626923618, 0.17334847366521866, 0.19250133426298022, 0.18740139095833652, 0.09666082236714824, 0.10126582876367973, 0.10604509092083714, 0.09250812907863437, 0.08016757558078114, 0.08723435933669532, 0.08754455264720873, 0.09042208314581235, 0.08687859416680477]}, "mutation_prompt": null}
{"id": "69a7b565-1893-4461-9ecf-26c1d7e18322", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.4)  # Changed line: Increase CR increment from 0.35 to 0.4\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic adjustment of CR based on fitness improvements to enhance exploitation.", "configspace": "", "generation": 90, "fitness": 0.34036755407699026, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.20.", "error": "", "parent_id": "545e4b3a-748c-485d-b073-d64b6ea0f5c2", "metadata": {"aucs": [0.45423475525930346, 0.5927976667991433, 0.4478207448727176, 0.5050373065997071, 0.4702452101766964, 0.48600792933161463, 0.47076454557405456, 0.4628399370104399, 0.4853636663808768, 0.33726603660181886, 0.33018451317248687, 0.33396336625706047, 0.4425371291857788, 0.2974828313252138, 0.4141294753826936, 0.3730189407893012, 0.30813130854410864, 0.3461288969541044, 0.16435226662354596, 0.14282092076003772, 0.16319680057437091, 0.15001804002325136, 0.16518068159824884, 0.16693403115746752, 0.12401076282336476, 0.146640494718295, 0.14774949250498903, 0.13136299521680062, 0.12263806891088969, 0.11770517957994231, 0.1288080516214728, 0.11923445010365974, 0.1283607237455393, 0.1276834095249737, 0.13797157202185917, 0.14278382299360637, 0.9053192009470553, 0.8660483334673228, 0.9002098347817125, 0.975528753634753, 0.9498768151140763, 0.9445713831460156, 0.9738097338493318, 0.9546027307857413, 0.9514852738835676, 0.3378366540342965, 0.3130663362093764, 0.3216204505781177, 0.3572684762827889, 0.2847855736383835, 0.3390576964849119, 0.323797335449335, 0.31248482374204145, 0.3254843614410512, 0.7880249127743724, 0.7758175415326543, 0.7783392489367843, 0.781922848511541, 0.7876052042262797, 0.7608748436472922, 0.7765301524640645, 0.753840082182759, 0.7735915016132198, 0.3513540289877535, 0.3511431583817436, 0.38881576447906285, 0.32503692437897147, 0.2942853050383335, 0.29451520135981135, 0.2638751731166953, 0.2667503703925358, 0.38910760164481784, 0.33656152910046244, 0.021415486323483446, 0.372303148440586, 0.29153955165403256, 0.35758051996796225, 0.3383168630044149, 0.3112497595998619, 0.3264443288445539, 0.29640982305402563, 0.36588962087293875, 0.35185506952379486, 0.33201560699079147, 0.30943352556367365, 0.3262494890216736, 0.34528076529232876, 0.3187013061995594, 0.32194466356153517, 0.24993165324218447, 0.45240315623337923, 0.391995025679059, 0.4447609638044835, 0.3820254651906416, 0.3826218333965329, 0.4067483142978534, 0.38295553856407283, 0.3900928423540908, 0.3809462537495222, 0.17625367710628392, 0.2109551027866866, 0.2205809325499385, 0.22380315548455176, 0.27971691250337327, 0.24837400025029177, 0.21942997024606548, 0.20808125862973947, 0.12357702720461383, 0.23987267419518454, 0.24723294465067003, 0.28439960781731466, 0.2652380083281898, 0.2534639690956757, 0.2901810812946989, 0.2678444904616174, 0.2612543370059113, 0.2761475624756643, 0.3987109691348111, 0.4495602710821951, 0.4406913655622201, 0.6054232260012435, 0.47533578333452753, 0.4972684102428657, 0.4460480911527953, 0.3917005747927599, 0.397540183501946, 0.14677607089834532, 0.1367358116217935, 0.17582005229186248, 0.12532546476573203, 0.1344847157120881, 0.1347318575860087, 0.10800363739350993, 0.13730443539785153, 0.13518870223482848, 0.2050279896955498, 0.4508391046717215, 0.3215748302868656, 0.3269608955603651, 0.40782590221522674, 0.444848699806772, 0.26668666247989925, 0.2732557627008909, 0.2466689090287728, 0.3460792704740334, 0.361252878730534, 0.3436855205734437, 0.32949183876596677, 0.3621127650035568, 0.36615005386039245, 0.3599892456795285, 0.3316229375803932, 0.36958342556268964, 0.30781149690747767, 0.3384501354945826, 0.34269916614612783, 0.29057010713019094, 0.3058052856572302, 0.332952085484867, 0.34173953289829684, 0.3242271853737194, 0.3359058879113027, 0.22613597482719083, 0.22728302173898352, 0.2048786858906767, 0.22085164409867486, 0.21699193728162736, 0.2659410293870397, 0.20037594236196432, 0.19855196020361798, 0.22445232953363492, 0.431474548940182, 0.18464654569699734, 0.1907854365928764, 0.1907486642456907, 0.4720491401871061, 0.21291994520546587, 0.19953007914403353, 0.23165119402685008, 0.19911964117185255, 0.5777238853222668, 0.1819694298511585, 0.805284722941409, 0.1827188108192469, 0.6718231135370532, 0.7342224072668191, 0.16788922892198066, 0.6570687801071586, 0.6195585362245959, 0.5543602853678709, 0.5448715393087575, 0.15220068708900103, 0.6788195176683121, 0.16107315122358468, 0.20351384609295642, 0.20722171834060177, 0.15100718461893448, 0.20705058968235823, 0.18199419304724573, 0.19270992828123723, 0.19633719819670203, 0.18492949861113506, 0.18217307997782972, 0.1863969438421721, 0.1863969617644845, 0.18550458840725437, 0.1916930810088895, 0.09611749144874082, 0.14935359775397372, 0.10604509092083714, 0.09462337438579238, 0.07769072065065141, 0.09103301374084549, 0.08805761920896349, 0.0931252003852816, 0.1002092742195686]}, "mutation_prompt": null}
{"id": "4780c0b0-916e-43e4-bb43-a6917ca4651e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.7  # Changed line: Increased mutation factor from 0.65 to 0.7\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.4)  # Changed line: Increase CR increment from 0.35 to 0.4\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic adjustment of CR based on fitness improvements to enhance exploitation.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "69a7b565-1893-4461-9ecf-26c1d7e18322", "metadata": {"aucs": [0.45423475525930346, 0.5927976667991433, 0.4478207448727176, 0.5050373065997071, 0.4702452101766964, 0.48600792933161463, 0.47076454557405456, 0.4628399370104399, 0.4853636663808768, 0.33726603660181886, 0.33018451317248687, 0.33396336625706047, 0.4425371291857788, 0.2974828313252138, 0.4141294753826936, 0.3730189407893012, 0.30813130854410864, 0.3461288969541044, 0.16435226662354596, 0.14282092076003772, 0.16319680057437091, 0.15001804002325136, 0.16518068159824884, 0.16693403115746752, 0.12401076282336476, 0.146640494718295, 0.14774949250498903, 0.13136299521680062, 0.12263806891088969, 0.11770517957994231, 0.1288080516214728, 0.11923445010365974, 0.1283607237455393, 0.1276834095249737, 0.13797157202185917, 0.14278382299360637, 0.9053192009470553, 0.8660483334673228, 0.9002098347817125, 0.975528753634753, 0.9498768151140763, 0.9445713831460156, 0.9738097338493318, 0.9546027307857413, 0.9514852738835676, 0.3378366540342965, 0.3130663362093764, 0.3216204505781177, 0.3572684762827889, 0.2847855736383835, 0.3390576964849119, 0.323797335449335, 0.31248482374204145, 0.3254843614410512, 0.7880249127743724, 0.7758175415326543, 0.7783392489367843, 0.781922848511541, 0.7876052042262797, 0.7608748436472922, 0.7765301524640645, 0.753840082182759, 0.7735915016132198, 0.3513540289877535, 0.3511431583817436, 0.38881576447906285, 0.32503692437897147, 0.2942853050383335, 0.29451520135981135, 0.2638751731166953, 0.2667503703925358, 0.38910760164481784, 0.33656152910046244, 0.021415486323483446, 0.372303148440586, 0.29153955165403256, 0.35758051996796225, 0.3383168630044149, 0.3112497595998619, 0.3264443288445539, 0.29640982305402563, 0.36588962087293875, 0.35185506952379486, 0.33201560699079147, 0.30943352556367365, 0.3262494890216736, 0.34528076529232876, 0.3187013061995594, 0.32194466356153517, 0.24993165324218447, 0.45240315623337923, 0.391995025679059, 0.4447609638044835, 0.3820254651906416, 0.3826218333965329, 0.4067483142978534, 0.38295553856407283, 0.3900928423540908, 0.3809462537495222, 0.17625367710628392, 0.2109551027866866, 0.2205809325499385, 0.22380315548455176, 0.27971691250337327, 0.24837400025029177, 0.21942997024606548, 0.20808125862973947, 0.12357702720461383, 0.23987267419518454, 0.24723294465067003, 0.28439960781731466, 0.2652380083281898, 0.2534639690956757, 0.2901810812946989, 0.2678444904616174, 0.2612543370059113, 0.2761475624756643, 0.3987109691348111, 0.4495602710821951, 0.4406913655622201, 0.6054232260012435, 0.47533578333452753, 0.4972684102428657, 0.4460480911527953, 0.3917005747927599, 0.397540183501946, 0.14677607089834532, 0.1367358116217935, 0.17582005229186248, 0.12532546476573203, 0.1344847157120881, 0.1347318575860087, 0.10800363739350993, 0.13730443539785153, 0.13518870223482848, 0.2050279896955498, 0.4508391046717215, 0.3215748302868656, 0.3269608955603651, 0.40782590221522674, 0.444848699806772, 0.26668666247989925, 0.2732557627008909, 0.2466689090287728, 0.3460792704740334, 0.361252878730534, 0.3436855205734437, 0.32949183876596677, 0.3621127650035568, 0.36615005386039245, 0.3599892456795285, 0.3316229375803932, 0.36958342556268964, 0.30781149690747767, 0.3384501354945826, 0.34269916614612783, 0.29057010713019094, 0.3058052856572302, 0.332952085484867, 0.34173953289829684, 0.3242271853737194, 0.3359058879113027, 0.22613597482719083, 0.22728302173898352, 0.2048786858906767, 0.22085164409867486, 0.21699193728162736, 0.2659410293870397, 0.20037594236196432, 0.19855196020361798, 0.22445232953363492, 0.431474548940182, 0.18464654569699734, 0.1907854365928764, 0.1907486642456907, 0.4720491401871061, 0.21291994520546587, 0.19953007914403353, 0.23165119402685008, 0.19911964117185255, 0.5777238853222668, 0.1819694298511585, 0.805284722941409, 0.1827188108192469, 0.6718231135370532, 0.7342224072668191, 0.16788922892198066, 0.6570687801071586, 0.6195585362245959, 0.5543602853678709, 0.5448715393087575, 0.15220068708900103, 0.6788195176683121, 0.16107315122358468, 0.20351384609295642, 0.20722171834060177, 0.15100718461893448, 0.20705058968235823, 0.18199419304724573, 0.19270992828123723, 0.19633719819670203, 0.18492949861113506, 0.18217307997782972, 0.1863969438421721, 0.1863969617644845, 0.18550458840725437, 0.1916930810088895, 0.09611749144874082, 0.14935359775397372, 0.10604509092083714, 0.09462337438579238, 0.07769072065065141, 0.09103301374084549, 0.08805761920896349, 0.0931252003852816, 0.1002092742195686]}, "mutation_prompt": null}
{"id": "bda305d2-41e8-46ca-9cfc-bfea84b35ff3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.75  # Changed line: Increase mutation factor from 0.7 to 0.75\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.4)  # Changed line: Increase CR increment from 0.35 to 0.4\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Slightly increase the mutation factor F to enhance diversity in exploration.", "configspace": "", "generation": 92, "fitness": 0.3428936761592347, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.21.", "error": "", "parent_id": "69a7b565-1893-4461-9ecf-26c1d7e18322", "metadata": {"aucs": [0.4558376084209088, 0.48212542122325597, 0.4989679993423016, 0.40787267880518174, 0.4758312459091456, 0.674834011687057, 0.49366146844164027, 0.5713638933179963, 0.5535699603000988, 0.30647831201982434, 0.3257078286355962, 0.3051482625595079, 0.34235274956659134, 0.4061341301981739, 0.3766233137350705, 0.3394051850633013, 0.34039358696280664, 0.3420612481249138, 0.16773850570275495, 0.36783033827582745, 0.1661347258353535, 0.14777366540692105, 0.16293757708001244, 0.1679690068257631, 0.1328963863391096, 0.1471259387546856, 0.4189003168762836, 0.16467578956670426, 0.12339637205481391, 0.08617063967584415, 0.1443367184800587, 0.10581029830581279, 0.11944879759483407, 0.10135033912242175, 0.11779616868928677, 0.12835472297962458, 0.9837802813366697, 0.8783326781280784, 0.8771306152068055, 0.9759269714246348, 0.9326295634763334, 0.9099809139936987, 0.9737644183567754, 0.9763109114489632, 0.9672835890843587, 0.3259417285923095, 0.3163311898281065, 0.31159558523030884, 0.3367910824259702, 0.3416218509567367, 0.33109567398399375, 0.3162943500226, 0.3331049295728863, 0.3344953630351918, 0.769097132128633, 0.781610492326535, 0.759944597358428, 0.7808116866704249, 0.7510063342593651, 0.763263999914624, 0.760070368744367, 0.7773413117351691, 0.7894095140988838, 0.3292323065142104, 0.255202173527875, 0.377357689506983, 0.4251506654965058, 0.3702944856818092, 0.3846866029736714, 0.3661655056684908, 0.32538657714422026, 0.3053024354738103, 0.41542792353933156, 0.02207662190227655, 0.3092224266996737, 0.3105329171956466, 0.29679388603086887, 0.40294590025365584, 0.31019215020153246, 0.3983738174639463, 0.30232840308430764, 0.31162029262426993, 0.32693027230428273, 0.3460491416644407, 0.26642523943130536, 0.32718787699683194, 0.3000133622696146, 0.3222837071750029, 0.3220970235271323, 0.3038302047729661, 0.3890370107270772, 0.37506280829347727, 0.42275477886443946, 0.36554281557308, 0.4063077057131218, 0.3746163325230274, 0.3981286339352714, 0.3434948175741427, 0.40532060506873324, 0.1577994811927994, 0.1566699586684026, 0.15403669116920116, 0.22402595684495297, 0.2344281172796896, 0.23131051123177582, 0.19963576411803285, 0.13416264706930014, 0.17724776299015943, 0.2497969951482487, 0.2404119882319341, 0.2480215690207208, 0.2602924201722592, 0.265026100310231, 0.27452835719636604, 0.27118087739715646, 0.2869042293831423, 0.2673590135313946, 0.42721593344078757, 0.46072565471289795, 0.4458116081239656, 0.47900929736384146, 0.431344978884202, 0.41805266755173376, 0.4092750608683948, 0.4422948258845507, 0.49254585448839105, 0.1352219244841466, 0.17260805571520543, 0.17248236900097513, 0.12369091533911392, 0.14047162651764356, 0.13346053746607434, 0.16753218035707906, 0.13266673270506513, 0.11040590463383504, 0.34778626942293256, 0.47889672573290887, 0.22601417606951546, 0.3955598486323054, 0.4200976842479818, 0.3238743129448397, 0.343020398242202, 0.2624940518189671, 0.3866800967063486, 0.41187890954423434, 0.379005482534423, 0.3513135056748634, 0.3772720157468591, 0.35551862757626573, 0.3849790899561052, 0.3661006946509209, 0.3562595842747245, 0.4110208558517442, 0.32677491420705296, 0.32083575361018, 0.31108746850386526, 0.31684263849476224, 0.322911780045514, 0.31867517593210537, 0.33338667210978634, 0.3433734081041667, 0.35534060233998177, 0.22015419604677522, 0.19826279504273026, 0.1971379428276634, 0.20321365442754535, 0.20339253887605568, 0.19825191611376258, 0.1942847638775902, 0.20806735533765142, 0.19959774156959753, 0.20421529498078428, 0.45612389518315755, 0.21366188130902686, 0.17389190771245688, 0.22049172555232943, 0.19891563610036633, 0.1966757114684381, 0.20266084334325285, 0.1798372313774449, 0.6686287421174123, 0.19203328440122336, 0.15082840842252632, 0.7476305451726246, 0.18588633193492388, 0.18022725322211464, 0.7251044307466081, 0.7974349033166972, 0.641251560969673, 0.4838823145972512, 0.16574777620149483, 0.5336530939968309, 0.5782402646800681, 0.1618477908342475, 0.20436215638131172, 0.20523004621284635, 0.665901169603102, 0.20611451458215402, 0.19487851765934683, 0.18563680657704262, 0.19617248580701174, 0.18930852454478542, 0.19467510981587954, 0.19169518988554457, 0.17713676419715352, 0.22551370327423648, 0.19074805824729857, 0.1028990578480643, 0.08732253669285606, 0.11657051344666414, 0.0836473605484882, 0.10396597242393346, 0.09678377922500081, 0.08195878348257357, 0.09733918482186421, 0.09392730927062043]}, "mutation_prompt": null}
{"id": "b354279d-0251-4637-842e-e38680f66594", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.75  # Changed line: Increase mutation factor from 0.7 to 0.75\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.15)  # Changed line: Increase F increment from 0.1 to 0.15\n                    self.CR = min(1.0, self.CR + 0.4)  # Changed line: Increase CR increment from 0.35 to 0.4\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Slightly increase population diversity by tweaking the mutation factor adjustment rate.", "configspace": "", "generation": 93, "fitness": 0.3182939208173237, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.20.", "error": "", "parent_id": "bda305d2-41e8-46ca-9cfc-bfea84b35ff3", "metadata": {"aucs": [0.5122113816920808, 0.5028846834404451, 0.520475655886468, 0.5645773842462674, 0.4943945648493968, 0.4515516015153729, 0.5729236813553857, 0.4654917770752406, 0.6260205747464965, 0.2938570113938387, 0.32022501786134394, 0.29821809133504606, 0.3051707934676142, 0.31894467526515824, 0.28917321648893457, 0.3117928429303921, 0.33362071500139756, 0.3120147256736264, 0.3384019973627975, 0.2904979751354847, 0.15431089687236055, 0.1429917932941398, 0.1612601880467004, 0.15548576141717618, 0.15274044461142078, 0.1565946669098437, 0.3748189462469621, 0.13367515789361073, 0.12809121082071584, 0.1523014827170981, 0.12109759277570797, 0.1562587081070893, 0.13476324607117385, 0.13404498066423443, 0.13038352517598872, 0.14365392241164432, 0.9720025606397787, 0.9405467230279805, 0.9370891914041283, 0.9629136539415102, 0.9507111907212277, 0.9521025817029806, 0.9737644183567754, 0.9727931151435046, 0.9588744168970785, 0.32784774990499854, 0.31365686040398477, 0.3222952420010121, 0.3358806120186696, 0.3035397678679693, 0.34002228784690214, 0.3151012573660331, 0.3064712891766427, 0.30535897578660975, 0.6937492662591804, 0.7237284841555829, 0.6757134365678495, 0.690732448395829, 0.6951514339541902, 0.7170413727118948, 0.6953646782955457, 0.7300429504949922, 0.739198488228013, 0.24629614459990867, 0.2944773655422299, 0.3212370471943584, 0.27718312889212826, 0.34196347042589015, 0.20407992231426442, 0.24067366184539452, 0.28372990377614893, 0.2921356134896107, 0.021662425153757825, 0.00981798515986576, 0.3960677289335498, 0.2580384766636198, 0.291960594852814, 0.2537735404845918, 0.28926963671649264, 0.3419100955875882, 0.23759381870770147, 0.2898208216572312, 0.29199081605272137, 0.2225067766303641, 0.3293032875183324, 0.2570789022757678, 0.1958559250522539, 0.2764673840791324, 0.2758406921028067, 0.2530375513455816, 0.3910152164898041, 0.35723785592655877, 0.3202787409696599, 0.358176378131985, 0.27313728696913453, 0.3414847451092997, 0.33746679788262224, 0.40139254190587237, 0.42171643795372993, 0.08857978862333693, 0.17597022106097393, 0.14444625319272641, 0.15300238659295717, 0.16022669441416404, 0.16666653126789077, 0.15944113204664334, 0.16325199097517473, 0.1429283943722789, 0.23236280265734766, 0.21139322630225565, 0.22651612063071347, 0.22237584376978525, 0.2112080638417967, 0.20778425860948158, 0.21121041634858162, 0.21633880450338672, 0.2263083988557757, 0.4214977760152022, 0.43917168292580644, 0.46931347075376284, 0.42548207042626895, 0.43431479114794014, 0.43187135370561514, 0.40153845322815873, 0.42232234832057414, 0.4649303288683484, 0.36485172584202163, 0.12150291447661044, 0.1100082463664297, 0.14185995816882002, 0.1199741015007505, 0.14108200651180292, 0.14502898986067725, 0.11545709806183035, 0.12748257729398915, 0.20244376460725155, 0.41051928393771453, 0.33506839540167044, 0.37252223952081753, 0.41372655093178623, 0.36685200823996567, 0.15965255041843174, 0.19295147177866234, 0.18418113631844168, 0.34106298703564364, 0.3607846276916603, 0.33933056788581284, 0.3573348810420164, 0.3360860968921141, 0.35020719068574957, 0.3268496735758072, 0.3464539873690615, 0.34949099823887175, 0.2995672833322295, 0.30753258950159623, 0.311310597574745, 0.299553656184526, 0.32148390242906033, 0.29045794117186075, 0.29731092559213435, 0.2982663287990561, 0.3149470985757714, 0.20383033496407588, 0.19933897725362137, 0.19398125460847138, 0.1917364067226749, 0.1930699440156265, 0.24155828525365108, 0.19545264462803436, 0.24409566223918977, 0.2359865554964119, 0.20474171971667166, 0.36390259031076144, 0.20209800505562647, 0.22746924494102794, 0.22938800615140864, 0.20681610950256513, 0.22443915810569492, 0.18700428986003903, 0.20686669144206826, 0.16287049871457038, 0.5858725792439914, 0.5574602017516452, 0.6301836585472038, 0.6241568081850926, 0.1981444450527703, 0.7746938244010535, 0.1905248361682481, 0.19403471696803776, 0.5705204651215185, 0.20318336377553237, 0.5797112920410905, 0.1997870348182167, 0.19771573938844433, 0.19620086993136576, 0.20769339041428092, 0.2049028281300288, 0.20906709851894312, 0.18033617136323443, 0.1912044952672104, 0.17764184436871788, 0.20978073225652938, 0.20247124120123472, 0.18143511591419714, 0.20085119045823407, 0.18340723008126392, 0.20022705648067463, 0.08754522185044278, 0.08900213570239868, 0.08517642755812649, 0.0771255427276919, 0.08402902284531988, 0.08775009167305547, 0.0903413457100849, 0.09249944312722658, 0.08621903782199092]}, "mutation_prompt": null}
{"id": "4252b603-d994-4fa5-ba6e-e0511aa125cb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.75  # Changed line: Increase mutation factor from 0.7 to 0.75\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.4)  # Changed line: Increase CR increment from 0.35 to 0.4\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Slightly increase the mutation factor F to enhance diversity in exploration.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bda305d2-41e8-46ca-9cfc-bfea84b35ff3", "metadata": {"aucs": [0.4558376084209088, 0.48212542122325597, 0.4989679993423016, 0.40787267880518174, 0.4758312459091456, 0.674834011687057, 0.49366146844164027, 0.5713638933179963, 0.5535699603000988, 0.30647831201982434, 0.3257078286355962, 0.3051482625595079, 0.34235274956659134, 0.4061341301981739, 0.3766233137350705, 0.3394051850633013, 0.34039358696280664, 0.3420612481249138, 0.16773850570275495, 0.36783033827582745, 0.1661347258353535, 0.14777366540692105, 0.16293757708001244, 0.1679690068257631, 0.1328963863391096, 0.1471259387546856, 0.4189003168762836, 0.16467578956670426, 0.12339637205481391, 0.08617063967584415, 0.1443367184800587, 0.10581029830581279, 0.11944879759483407, 0.10135033912242175, 0.11779616868928677, 0.12835472297962458, 0.9837802813366697, 0.8783326781280784, 0.8771306152068055, 0.9759269714246348, 0.9326295634763334, 0.9099809139936987, 0.9737644183567754, 0.9763109114489632, 0.9672835890843587, 0.3259417285923095, 0.3163311898281065, 0.31159558523030884, 0.3367910824259702, 0.3416218509567367, 0.33109567398399375, 0.3162943500226, 0.3331049295728863, 0.3344953630351918, 0.769097132128633, 0.781610492326535, 0.759944597358428, 0.7808116866704249, 0.7510063342593651, 0.763263999914624, 0.760070368744367, 0.7773413117351691, 0.7894095140988838, 0.3292323065142104, 0.255202173527875, 0.377357689506983, 0.4251506654965058, 0.3702944856818092, 0.3846866029736714, 0.3661655056684908, 0.32538657714422026, 0.3053024354738103, 0.41542792353933156, 0.02207662190227655, 0.3092224266996737, 0.3105329171956466, 0.29679388603086887, 0.40294590025365584, 0.31019215020153246, 0.3983738174639463, 0.30232840308430764, 0.31162029262426993, 0.32693027230428273, 0.3460491416644407, 0.26642523943130536, 0.32718787699683194, 0.3000133622696146, 0.3222837071750029, 0.3220970235271323, 0.3038302047729661, 0.3890370107270772, 0.37506280829347727, 0.42275477886443946, 0.36554281557308, 0.4063077057131218, 0.3746163325230274, 0.3981286339352714, 0.3434948175741427, 0.40532060506873324, 0.1577994811927994, 0.1566699586684026, 0.15403669116920116, 0.22402595684495297, 0.2344281172796896, 0.23131051123177582, 0.19963576411803285, 0.13416264706930014, 0.17724776299015943, 0.2497969951482487, 0.2404119882319341, 0.2480215690207208, 0.2602924201722592, 0.265026100310231, 0.27452835719636604, 0.27118087739715646, 0.2869042293831423, 0.2673590135313946, 0.42721593344078757, 0.46072565471289795, 0.4458116081239656, 0.47900929736384146, 0.431344978884202, 0.41805266755173376, 0.4092750608683948, 0.4422948258845507, 0.49254585448839105, 0.1352219244841466, 0.17260805571520543, 0.17248236900097513, 0.12369091533911392, 0.14047162651764356, 0.13346053746607434, 0.16753218035707906, 0.13266673270506513, 0.11040590463383504, 0.34778626942293256, 0.47889672573290887, 0.22601417606951546, 0.3955598486323054, 0.4200976842479818, 0.3238743129448397, 0.343020398242202, 0.2624940518189671, 0.3866800967063486, 0.41187890954423434, 0.379005482534423, 0.3513135056748634, 0.3772720157468591, 0.35551862757626573, 0.3849790899561052, 0.3661006946509209, 0.3562595842747245, 0.4110208558517442, 0.32677491420705296, 0.32083575361018, 0.31108746850386526, 0.31684263849476224, 0.322911780045514, 0.31867517593210537, 0.33338667210978634, 0.3433734081041667, 0.35534060233998177, 0.22015419604677522, 0.19826279504273026, 0.1971379428276634, 0.20321365442754535, 0.20339253887605568, 0.19825191611376258, 0.1942847638775902, 0.20806735533765142, 0.19959774156959753, 0.20421529498078428, 0.45612389518315755, 0.21366188130902686, 0.17389190771245688, 0.22049172555232943, 0.19891563610036633, 0.1966757114684381, 0.20266084334325285, 0.1798372313774449, 0.6686287421174123, 0.19203328440122336, 0.15082840842252632, 0.7476305451726246, 0.18588633193492388, 0.18022725322211464, 0.7251044307466081, 0.7974349033166972, 0.641251560969673, 0.4838823145972512, 0.16574777620149483, 0.5336530939968309, 0.5782402646800681, 0.1618477908342475, 0.20436215638131172, 0.20523004621284635, 0.665901169603102, 0.20611451458215402, 0.19487851765934683, 0.18563680657704262, 0.19617248580701174, 0.18930852454478542, 0.19467510981587954, 0.19169518988554457, 0.17713676419715352, 0.22551370327423648, 0.19074805824729857, 0.1028990578480643, 0.08732253669285606, 0.11657051344666414, 0.0836473605484882, 0.10396597242393346, 0.09678377922500081, 0.08195878348257357, 0.09733918482186421, 0.09392730927062043]}, "mutation_prompt": null}
{"id": "535373d0-9c59-4e62-8cf6-ad645713f220", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.75  # Changed line: Increase mutation factor from 0.7 to 0.75\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.4)  # Changed line: Increase CR increment from 0.35 to 0.4\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Slightly increase the mutation factor F to enhance diversity in exploration.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bda305d2-41e8-46ca-9cfc-bfea84b35ff3", "metadata": {"aucs": [0.4558376084209088, 0.48212542122325597, 0.4989679993423016, 0.40787267880518174, 0.4758312459091456, 0.674834011687057, 0.49366146844164027, 0.5713638933179963, 0.5535699603000988, 0.30647831201982434, 0.3257078286355962, 0.3051482625595079, 0.34235274956659134, 0.4061341301981739, 0.3766233137350705, 0.3394051850633013, 0.34039358696280664, 0.3420612481249138, 0.16773850570275495, 0.36783033827582745, 0.1661347258353535, 0.14777366540692105, 0.16293757708001244, 0.1679690068257631, 0.1328963863391096, 0.1471259387546856, 0.4189003168762836, 0.16467578956670426, 0.12339637205481391, 0.08617063967584415, 0.1443367184800587, 0.10581029830581279, 0.11944879759483407, 0.10135033912242175, 0.11779616868928677, 0.12835472297962458, 0.9837802813366697, 0.8783326781280784, 0.8771306152068055, 0.9759269714246348, 0.9326295634763334, 0.9099809139936987, 0.9737644183567754, 0.9763109114489632, 0.9672835890843587, 0.3259417285923095, 0.3163311898281065, 0.31159558523030884, 0.3367910824259702, 0.3416218509567367, 0.33109567398399375, 0.3162943500226, 0.3331049295728863, 0.3344953630351918, 0.769097132128633, 0.781610492326535, 0.759944597358428, 0.7808116866704249, 0.7510063342593651, 0.763263999914624, 0.760070368744367, 0.7773413117351691, 0.7894095140988838, 0.3292323065142104, 0.255202173527875, 0.377357689506983, 0.4251506654965058, 0.3702944856818092, 0.3846866029736714, 0.3661655056684908, 0.32538657714422026, 0.3053024354738103, 0.41542792353933156, 0.02207662190227655, 0.3092224266996737, 0.3105329171956466, 0.29679388603086887, 0.40294590025365584, 0.31019215020153246, 0.3983738174639463, 0.30232840308430764, 0.31162029262426993, 0.32693027230428273, 0.3460491416644407, 0.26642523943130536, 0.32718787699683194, 0.3000133622696146, 0.3222837071750029, 0.3220970235271323, 0.3038302047729661, 0.3890370107270772, 0.37506280829347727, 0.42275477886443946, 0.36554281557308, 0.4063077057131218, 0.3746163325230274, 0.3981286339352714, 0.3434948175741427, 0.40532060506873324, 0.1577994811927994, 0.1566699586684026, 0.15403669116920116, 0.22402595684495297, 0.2344281172796896, 0.23131051123177582, 0.19963576411803285, 0.13416264706930014, 0.17724776299015943, 0.2497969951482487, 0.2404119882319341, 0.2480215690207208, 0.2602924201722592, 0.265026100310231, 0.27452835719636604, 0.27118087739715646, 0.2869042293831423, 0.2673590135313946, 0.42721593344078757, 0.46072565471289795, 0.4458116081239656, 0.47900929736384146, 0.431344978884202, 0.41805266755173376, 0.4092750608683948, 0.4422948258845507, 0.49254585448839105, 0.1352219244841466, 0.17260805571520543, 0.17248236900097513, 0.12369091533911392, 0.14047162651764356, 0.13346053746607434, 0.16753218035707906, 0.13266673270506513, 0.11040590463383504, 0.34778626942293256, 0.47889672573290887, 0.22601417606951546, 0.3955598486323054, 0.4200976842479818, 0.3238743129448397, 0.343020398242202, 0.2624940518189671, 0.3866800967063486, 0.41187890954423434, 0.379005482534423, 0.3513135056748634, 0.3772720157468591, 0.35551862757626573, 0.3849790899561052, 0.3661006946509209, 0.3562595842747245, 0.4110208558517442, 0.32677491420705296, 0.32083575361018, 0.31108746850386526, 0.31684263849476224, 0.322911780045514, 0.31867517593210537, 0.33338667210978634, 0.3433734081041667, 0.35534060233998177, 0.22015419604677522, 0.19826279504273026, 0.1971379428276634, 0.20321365442754535, 0.20339253887605568, 0.19825191611376258, 0.1942847638775902, 0.20806735533765142, 0.19959774156959753, 0.20421529498078428, 0.45612389518315755, 0.21366188130902686, 0.17389190771245688, 0.22049172555232943, 0.19891563610036633, 0.1966757114684381, 0.20266084334325285, 0.1798372313774449, 0.6686287421174123, 0.19203328440122336, 0.15082840842252632, 0.7476305451726246, 0.18588633193492388, 0.18022725322211464, 0.7251044307466081, 0.7974349033166972, 0.641251560969673, 0.4838823145972512, 0.16574777620149483, 0.5336530939968309, 0.5782402646800681, 0.1618477908342475, 0.20436215638131172, 0.20523004621284635, 0.665901169603102, 0.20611451458215402, 0.19487851765934683, 0.18563680657704262, 0.19617248580701174, 0.18930852454478542, 0.19467510981587954, 0.19169518988554457, 0.17713676419715352, 0.22551370327423648, 0.19074805824729857, 0.1028990578480643, 0.08732253669285606, 0.11657051344666414, 0.0836473605484882, 0.10396597242393346, 0.09678377922500081, 0.08195878348257357, 0.09733918482186421, 0.09392730927062043]}, "mutation_prompt": null}
{"id": "f6245c9f-aceb-4e3a-8734-2622dc25bfcf", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.75  # Changed line: Increase mutation factor from 0.7 to 0.75\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.4)  # Changed line: Increase CR increment from 0.35 to 0.4\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.05)  # Adjust line: decrease F further for more exploration\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Increase exploration by further adjusting mutation factor F based on unsuccessful trials.", "configspace": "", "generation": 96, "fitness": 0.3404369173897874, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.21.", "error": "", "parent_id": "bda305d2-41e8-46ca-9cfc-bfea84b35ff3", "metadata": {"aucs": [0.43144712943132957, 0.514113765394121, 0.479842266970679, 0.4824444699609216, 0.4990670166945256, 0.47281134000016833, 0.512214255955733, 0.5669870219745711, 0.4608634750528361, 0.3447797356644505, 0.3836983916349139, 0.37259636158405063, 0.44782855709338476, 0.4424655121584983, 0.4040046143491769, 0.36926487267877817, 0.39675970955076434, 0.4341433489235722, 0.40452341673003833, 0.15495376222767776, 0.18057915285848558, 0.17244660104446907, 0.13716059941971182, 0.15326253153831404, 0.139230538734067, 0.3705298164749664, 0.11217751547251775, 0.1230825655494322, 0.13595606505237046, 0.1237858560394981, 0.11128312697011189, 0.15321128383976046, 0.13263159554961257, 0.11788981559029121, 0.11023363546688236, 0.1411089395372288, 0.9196540237291128, 0.8366536220764702, 0.9217672701088223, 0.9663992490278162, 0.9647200688198113, 0.9509935256833141, 0.973710745009966, 0.9746654566633326, 0.9604742800735192, 0.3382472810455842, 0.2968703906634105, 0.30882146878606376, 0.31578287140344097, 0.37996415227092917, 0.2996809597716691, 0.346133844038496, 0.2945487804383301, 0.3465111666593528, 0.858807011157302, 0.868909705003784, 0.8459167043259693, 0.38813737502999257, 0.8463009481091599, 0.8436112054699424, 0.22723989844709536, 0.8441171114451627, 0.8336987333896673, 0.2320304160201, 0.34947272536278684, 0.43828110874007875, 0.25386589238520474, 0.21535023899312367, 0.25971681693162074, 0.41057637360167787, 0.293553036196299, 0.3378792855870856, 0.3170908318717963, 0.12451220200895918, 0.22442260221524946, 0.44321290047413753, 0.44206987445689183, 0.3401272082066349, 0.36174386158980987, 0.2714772461797361, 0.3245368288269056, 0.4279642397856671, 0.4315089096163024, 0.41096572528577324, 0.3810965377307284, 0.40099516096440313, 0.3771083050258026, 0.3629141033447584, 0.3614617513947128, 0.4232236017209198, 0.3816784445304554, 0.4060262114792704, 0.4158705139262352, 0.4550597915746002, 0.37975062970087414, 0.41292060083757076, 0.3943233542466781, 0.5075429808584577, 0.42221250522784526, 0.20745684832277, 0.2152771367302052, 0.2486763692478775, 0.16860833444475398, 0.2105369964617878, 0.2943335206429589, 0.2057326081572861, 0.21322429741643623, 0.19081973195193092, 0.3162550234387429, 0.3141916827638549, 0.3239467486220933, 0.3386221666006597, 0.3112507449089329, 0.31400670024605837, 0.3160761014379163, 0.3258609954384897, 0.32344877797231, 0.40142925500529625, 0.46168271047911236, 0.40884791932410747, 0.401120010194588, 0.42950537531201094, 0.4486600542854048, 0.460967075889103, 0.450817430424753, 0.4645844736937492, 0.12143469777461502, 0.1381081998988375, 0.15227752414943074, 0.13687384443459538, 0.1479489047628777, 0.12726650335128775, 0.14967451941373744, 0.13184111377242824, 0.13521949290079138, 0.22878893773959685, 0.3540789898511477, 0.1984463097898489, 0.23722172042309564, 0.4350915712424166, 0.21923048473349138, 0.2558761338886868, 0.28360486553463704, 0.30458303083725025, 0.34471690796079624, 0.2794413873548114, 0.3685056019817561, 0.27219713427576164, 0.40207232543126925, 0.3305692261194043, 0.26186705821097644, 0.3708235084789009, 0.2653893515675233, 0.2323473395326614, 0.29255490502645853, 0.2957260228693258, 0.33996616290423165, 0.39328827228241114, 0.28308536014817487, 0.33652456784653006, 0.29663545577379136, 0.26372233525598254, 0.19542934171140647, 0.23643661845744446, 0.2879424365463449, 0.24150529401314025, 0.22027835996902223, 0.2347198005300718, 0.22499951920427907, 0.19668330353634433, 0.23432778809645793, 0.421240034310702, 0.19974271626396045, 0.2418512174795091, 0.2081070758571505, 0.2083565942201544, 0.20111516662168283, 0.20415208891694414, 0.20307298796842255, 0.1784481863743882, 0.15274843818132067, 0.2101388518690307, 0.6807525842132217, 0.8512139574612382, 0.18706993891029267, 0.20980466826891286, 0.7259419593646979, 0.16816542992117045, 0.7271954524097088, 0.5756069652374866, 0.5425522193626522, 0.11147055775162151, 0.2038105759838682, 0.16409522751400507, 0.5880776345046536, 0.1541414237106019, 0.2085792350314153, 0.206400962306725, 0.2035759533997077, 0.1941144287287786, 0.19678989928010293, 0.23400199744930084, 0.18981990412289773, 0.1879902205912144, 0.18857128629364606, 0.1889399334443861, 0.184790929452466, 0.08735686478152405, 0.09173496371111978, 0.09387798243153356, 0.07707030080384414, 0.09365329076886142, 0.10075161582241055, 0.1006021518611182, 0.10826076569870258, 0.1190988698251032]}, "mutation_prompt": null}
{"id": "40f0178a-edc6-4aaf-84e7-6ace9fd32f4c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.75  # Changed line: Increase mutation factor from 0.7 to 0.75\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.4)  # Changed line: Increase CR increment from 0.35 to 0.4\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.995  # Changed line: Adjust F to 0.995 for a smoother cooling effect\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Fine-tune F decrement in the cooling schedule for better convergence.", "configspace": "", "generation": 97, "fitness": 0.33559950648439774, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.20.", "error": "", "parent_id": "bda305d2-41e8-46ca-9cfc-bfea84b35ff3", "metadata": {"aucs": [0.5300465800923035, 0.4793540497658286, 0.5726306768939798, 0.585861973737099, 0.4794705518784024, 0.4703572351229265, 0.5013730239983611, 0.4710743942023691, 0.5000037896446164, 0.30629128366742076, 0.308991703439218, 0.34854977492406125, 0.32621027635031463, 0.38645162720282245, 0.36757051874284985, 0.37913321687196844, 0.4107058274495512, 0.3675531647922362, 0.1657341886674183, 0.16979890173161816, 0.17022553858812206, 0.1375370134660825, 0.16550764736482249, 0.16905256661543355, 0.1091017012195099, 0.17211452611326516, 0.17524880996122683, 0.15781049933913815, 0.1389161420799041, 0.16067757373609215, 0.1376465256484216, 0.12853460209908518, 0.15522735524555242, 0.167541555987486, 0.10610202166958949, 0.11959210471185722, 0.9837804595003764, 0.8537304413349454, 0.9017593282614629, 0.976066622306412, 0.9508453068400035, 0.9073804071910666, 0.9737644183567754, 0.9763109114489632, 0.9672823036451538, 0.33492879586728475, 0.3090332556081703, 0.2867439783663329, 0.35521910465591067, 0.3506236677890999, 0.3253278297906379, 0.320307898786084, 0.3154292567324518, 0.3385902147834655, 0.7519831205792902, 0.8067115347110217, 0.7863424790612424, 0.786711445280268, 0.7544716069809358, 0.7775874904586872, 0.7776198558168054, 0.7634343410587726, 0.793828732603841, 0.337422275110532, 0.26038528202923905, 0.4085650456940034, 0.3066222940238489, 0.3206366382663619, 0.28280921583540863, 0.29405197977463193, 0.33376605035133067, 0.3157192185444223, 0.2803372662846383, 0.022115303835834155, 0.39154113255922296, 0.3072246046081687, 0.3245872467816091, 0.3779768371501633, 0.3058937768181085, 0.2556258043064521, 0.3595903111236607, 0.34367890917198884, 0.3231184998919394, 0.3031836755346202, 0.33314725546238233, 0.3217554852586413, 0.31250550387780873, 0.3281004787804588, 0.3075967590344463, 0.31544466614064837, 0.3927678873730043, 0.41108156192255396, 0.3869745329271591, 0.42104484476132564, 0.3671898176704177, 0.4068975576524968, 0.3772669151746717, 0.400118532320034, 0.3788641221166852, 0.19150763014619632, 0.12245833879627865, 0.16790201170907126, 0.22551526518693676, 0.23730953970781388, 0.2269072472585092, 0.22406892709658555, 0.2150788646422389, 0.2229769573581888, 0.2596389830309629, 0.28675547739348695, 0.2558911072747445, 0.28311320965050846, 0.27655420578742274, 0.26330698250737883, 0.276012491678433, 0.2852473791731037, 0.27501148759486127, 0.441725504488493, 0.45651230176525215, 0.4181407052386298, 0.44420701270073215, 0.486241394803662, 0.4297507637234521, 0.4592985234306136, 0.4431920804436943, 0.48946035580026415, 0.1233408366281421, 0.12276354822484059, 0.136467953103672, 0.13223587547116566, 0.16551594754269738, 0.1467012861286694, 0.14095413876424423, 0.12269531491216079, 0.1445626385348282, 0.3891579270932666, 0.26283181444405057, 0.2711516737470231, 0.39420854535689287, 0.2190639942592154, 0.24333388394992483, 0.4342763949213839, 0.45143115208569884, 0.35096305555676754, 0.39905342270375044, 0.34473219327334415, 0.3857094706479398, 0.37463175373810587, 0.35959065958059977, 0.34671764888826806, 0.3730069618172479, 0.3659522940122826, 0.3820479191566162, 0.31936112848985454, 0.2725734967069319, 0.313054707965684, 0.34417353921441507, 0.3156569547064719, 0.3439889581681873, 0.3257300739154202, 0.3102002572185526, 0.31858082532639753, 0.2511754265907824, 0.22475970734022033, 0.2222312744573759, 0.21718904763670033, 0.2195491448130641, 0.21191305073997724, 0.19980758828939038, 0.20948360419650658, 0.18984106117960575, 0.2288465789968409, 0.19508698246169875, 0.21943432860365664, 0.40265923872708065, 0.19436632254487585, 0.19043404663190755, 0.18995417610752252, 0.2338438496190135, 0.18948545361010194, 0.6565021095105716, 0.204071219095306, 0.19329046568485841, 0.18293188057489118, 0.19648922997899387, 0.6722329705502571, 0.6958951874968295, 0.6246456672623102, 0.18319383270705014, 0.586606491179614, 0.20346085405652126, 0.15229300289894832, 0.5522203738156575, 0.5306198649880425, 0.1651630523548684, 0.2061771691281088, 0.15145148810598208, 0.20553144054494443, 0.18339623257096294, 0.18581184799653516, 0.1845021542120322, 0.1828412004941412, 0.1778127410570658, 0.18167527118607152, 0.19850259045288732, 0.19758940917120582, 0.17857864860575334, 0.08980027655504785, 0.09058845573887286, 0.09240018483720558, 0.09016668498108826, 0.09042722037151585, 0.0867026541061543, 0.08316807582556507, 0.10229893708567783, 0.09076959925448058]}, "mutation_prompt": null}
{"id": "d3ab479f-d561-4321-afb5-40848449285d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.75  # Changed line: Increase mutation factor from 0.7 to 0.75\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.4)  # Changed line: Increase CR increment from 0.35 to 0.4\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Slightly increase the mutation factor F to enhance diversity in exploration.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bda305d2-41e8-46ca-9cfc-bfea84b35ff3", "metadata": {"aucs": [0.4558376084209088, 0.48212542122325597, 0.4989679993423016, 0.40787267880518174, 0.4758312459091456, 0.674834011687057, 0.49366146844164027, 0.5713638933179963, 0.5535699603000988, 0.30647831201982434, 0.3257078286355962, 0.3051482625595079, 0.34235274956659134, 0.4061341301981739, 0.3766233137350705, 0.3394051850633013, 0.34039358696280664, 0.3420612481249138, 0.16773850570275495, 0.36783033827582745, 0.1661347258353535, 0.14777366540692105, 0.16293757708001244, 0.1679690068257631, 0.1328963863391096, 0.1471259387546856, 0.4189003168762836, 0.16467578956670426, 0.12339637205481391, 0.08617063967584415, 0.1443367184800587, 0.10581029830581279, 0.11944879759483407, 0.10135033912242175, 0.11779616868928677, 0.12835472297962458, 0.9837802813366697, 0.8783326781280784, 0.8771306152068055, 0.9759269714246348, 0.9326295634763334, 0.9099809139936987, 0.9737644183567754, 0.9763109114489632, 0.9672835890843587, 0.3259417285923095, 0.3163311898281065, 0.31159558523030884, 0.3367910824259702, 0.3416218509567367, 0.33109567398399375, 0.3162943500226, 0.3331049295728863, 0.3344953630351918, 0.769097132128633, 0.781610492326535, 0.759944597358428, 0.7808116866704249, 0.7510063342593651, 0.763263999914624, 0.760070368744367, 0.7773413117351691, 0.7894095140988838, 0.3292323065142104, 0.255202173527875, 0.377357689506983, 0.4251506654965058, 0.3702944856818092, 0.3846866029736714, 0.3661655056684908, 0.32538657714422026, 0.3053024354738103, 0.41542792353933156, 0.02207662190227655, 0.3092224266996737, 0.3105329171956466, 0.29679388603086887, 0.40294590025365584, 0.31019215020153246, 0.3983738174639463, 0.30232840308430764, 0.31162029262426993, 0.32693027230428273, 0.3460491416644407, 0.26642523943130536, 0.32718787699683194, 0.3000133622696146, 0.3222837071750029, 0.3220970235271323, 0.3038302047729661, 0.3890370107270772, 0.37506280829347727, 0.42275477886443946, 0.36554281557308, 0.4063077057131218, 0.3746163325230274, 0.3981286339352714, 0.3434948175741427, 0.40532060506873324, 0.1577994811927994, 0.1566699586684026, 0.15403669116920116, 0.22402595684495297, 0.2344281172796896, 0.23131051123177582, 0.19963576411803285, 0.13416264706930014, 0.17724776299015943, 0.2497969951482487, 0.2404119882319341, 0.2480215690207208, 0.2602924201722592, 0.265026100310231, 0.27452835719636604, 0.27118087739715646, 0.2869042293831423, 0.2673590135313946, 0.42721593344078757, 0.46072565471289795, 0.4458116081239656, 0.47900929736384146, 0.431344978884202, 0.41805266755173376, 0.4092750608683948, 0.4422948258845507, 0.49254585448839105, 0.1352219244841466, 0.17260805571520543, 0.17248236900097513, 0.12369091533911392, 0.14047162651764356, 0.13346053746607434, 0.16753218035707906, 0.13266673270506513, 0.11040590463383504, 0.34778626942293256, 0.47889672573290887, 0.22601417606951546, 0.3955598486323054, 0.4200976842479818, 0.3238743129448397, 0.343020398242202, 0.2624940518189671, 0.3866800967063486, 0.41187890954423434, 0.379005482534423, 0.3513135056748634, 0.3772720157468591, 0.35551862757626573, 0.3849790899561052, 0.3661006946509209, 0.3562595842747245, 0.4110208558517442, 0.32677491420705296, 0.32083575361018, 0.31108746850386526, 0.31684263849476224, 0.322911780045514, 0.31867517593210537, 0.33338667210978634, 0.3433734081041667, 0.35534060233998177, 0.22015419604677522, 0.19826279504273026, 0.1971379428276634, 0.20321365442754535, 0.20339253887605568, 0.19825191611376258, 0.1942847638775902, 0.20806735533765142, 0.19959774156959753, 0.20421529498078428, 0.45612389518315755, 0.21366188130902686, 0.17389190771245688, 0.22049172555232943, 0.19891563610036633, 0.1966757114684381, 0.20266084334325285, 0.1798372313774449, 0.6686287421174123, 0.19203328440122336, 0.15082840842252632, 0.7476305451726246, 0.18588633193492388, 0.18022725322211464, 0.7251044307466081, 0.7974349033166972, 0.641251560969673, 0.4838823145972512, 0.16574777620149483, 0.5336530939968309, 0.5782402646800681, 0.1618477908342475, 0.20436215638131172, 0.20523004621284635, 0.665901169603102, 0.20611451458215402, 0.19487851765934683, 0.18563680657704262, 0.19617248580701174, 0.18930852454478542, 0.19467510981587954, 0.19169518988554457, 0.17713676419715352, 0.22551370327423648, 0.19074805824729857, 0.1028990578480643, 0.08732253669285606, 0.11657051344666414, 0.0836473605484882, 0.10396597242393346, 0.09678377922500081, 0.08195878348257357, 0.09733918482186421, 0.09392730927062043]}, "mutation_prompt": null}
{"id": "2a273673-3872-4f4f-9d29-d515cac36a8f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # A common heuristic is to use 10 times the dimension\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.75  # Changed line: Increase mutation factor from 0.7 to 0.75\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        initial_budget = self.budget  # Store the initial budget for cooling schedule\n\n        while self.evaluations < self.budget:\n            # Evaluate initial population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            # Main loop\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation: select three random individuals\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                # Differential Mutation\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    # Adapt F and CR dynamically based on success\n                    self.F = min(1.0, self.F + 0.1)\n                    self.CR = min(1.0, self.CR + 0.4)  # Changed line: Increase CR increment from 0.35 to 0.4\n                else:\n                    # Slightly decrease F and CR if not successful\n                    self.F = max(0.05, self.F - 0.03)\n                    self.CR = max(0.1, self.CR - 0.01)\n\n            # Dynamically adjust population size based on fitness variance\n            if np.var(self.fitness) < 1e-4:\n                self.population_size = max(4, int(self.population_size * 0.75))  # Changed line: More gradual reduction\n                self.population = np.resize(self.population, (self.population_size, self.dim))\n                self.fitness = np.resize(self.fitness, self.population_size)\n\n            # Cooling schedule for mutation factor F\n            self.F *= 0.99  # Changed line: Gradually reduce F over iterations\n\n        # Return the best found solution\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Slightly increase the mutation factor F to enhance diversity in exploration.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bda305d2-41e8-46ca-9cfc-bfea84b35ff3", "metadata": {"aucs": [0.4558376084209088, 0.48212542122325597, 0.4989679993423016, 0.40787267880518174, 0.4758312459091456, 0.674834011687057, 0.49366146844164027, 0.5713638933179963, 0.5535699603000988, 0.30647831201982434, 0.3257078286355962, 0.3051482625595079, 0.34235274956659134, 0.4061341301981739, 0.3766233137350705, 0.3394051850633013, 0.34039358696280664, 0.3420612481249138, 0.16773850570275495, 0.36783033827582745, 0.1661347258353535, 0.14777366540692105, 0.16293757708001244, 0.1679690068257631, 0.1328963863391096, 0.1471259387546856, 0.4189003168762836, 0.16467578956670426, 0.12339637205481391, 0.08617063967584415, 0.1443367184800587, 0.10581029830581279, 0.11944879759483407, 0.10135033912242175, 0.11779616868928677, 0.12835472297962458, 0.9837802813366697, 0.8783326781280784, 0.8771306152068055, 0.9759269714246348, 0.9326295634763334, 0.9099809139936987, 0.9737644183567754, 0.9763109114489632, 0.9672835890843587, 0.3259417285923095, 0.3163311898281065, 0.31159558523030884, 0.3367910824259702, 0.3416218509567367, 0.33109567398399375, 0.3162943500226, 0.3331049295728863, 0.3344953630351918, 0.769097132128633, 0.781610492326535, 0.759944597358428, 0.7808116866704249, 0.7510063342593651, 0.763263999914624, 0.760070368744367, 0.7773413117351691, 0.7894095140988838, 0.3292323065142104, 0.255202173527875, 0.377357689506983, 0.4251506654965058, 0.3702944856818092, 0.3846866029736714, 0.3661655056684908, 0.32538657714422026, 0.3053024354738103, 0.41542792353933156, 0.02207662190227655, 0.3092224266996737, 0.3105329171956466, 0.29679388603086887, 0.40294590025365584, 0.31019215020153246, 0.3983738174639463, 0.30232840308430764, 0.31162029262426993, 0.32693027230428273, 0.3460491416644407, 0.26642523943130536, 0.32718787699683194, 0.3000133622696146, 0.3222837071750029, 0.3220970235271323, 0.3038302047729661, 0.3890370107270772, 0.37506280829347727, 0.42275477886443946, 0.36554281557308, 0.4063077057131218, 0.3746163325230274, 0.3981286339352714, 0.3434948175741427, 0.40532060506873324, 0.1577994811927994, 0.1566699586684026, 0.15403669116920116, 0.22402595684495297, 0.2344281172796896, 0.23131051123177582, 0.19963576411803285, 0.13416264706930014, 0.17724776299015943, 0.2497969951482487, 0.2404119882319341, 0.2480215690207208, 0.2602924201722592, 0.265026100310231, 0.27452835719636604, 0.27118087739715646, 0.2869042293831423, 0.2673590135313946, 0.42721593344078757, 0.46072565471289795, 0.4458116081239656, 0.47900929736384146, 0.431344978884202, 0.41805266755173376, 0.4092750608683948, 0.4422948258845507, 0.49254585448839105, 0.1352219244841466, 0.17260805571520543, 0.17248236900097513, 0.12369091533911392, 0.14047162651764356, 0.13346053746607434, 0.16753218035707906, 0.13266673270506513, 0.11040590463383504, 0.34778626942293256, 0.47889672573290887, 0.22601417606951546, 0.3955598486323054, 0.4200976842479818, 0.3238743129448397, 0.343020398242202, 0.2624940518189671, 0.3866800967063486, 0.41187890954423434, 0.379005482534423, 0.3513135056748634, 0.3772720157468591, 0.35551862757626573, 0.3849790899561052, 0.3661006946509209, 0.3562595842747245, 0.4110208558517442, 0.32677491420705296, 0.32083575361018, 0.31108746850386526, 0.31684263849476224, 0.322911780045514, 0.31867517593210537, 0.33338667210978634, 0.3433734081041667, 0.35534060233998177, 0.22015419604677522, 0.19826279504273026, 0.1971379428276634, 0.20321365442754535, 0.20339253887605568, 0.19825191611376258, 0.1942847638775902, 0.20806735533765142, 0.19959774156959753, 0.20421529498078428, 0.45612389518315755, 0.21366188130902686, 0.17389190771245688, 0.22049172555232943, 0.19891563610036633, 0.1966757114684381, 0.20266084334325285, 0.1798372313774449, 0.6686287421174123, 0.19203328440122336, 0.15082840842252632, 0.7476305451726246, 0.18588633193492388, 0.18022725322211464, 0.7251044307466081, 0.7974349033166972, 0.641251560969673, 0.4838823145972512, 0.16574777620149483, 0.5336530939968309, 0.5782402646800681, 0.1618477908342475, 0.20436215638131172, 0.20523004621284635, 0.665901169603102, 0.20611451458215402, 0.19487851765934683, 0.18563680657704262, 0.19617248580701174, 0.18930852454478542, 0.19467510981587954, 0.19169518988554457, 0.17713676419715352, 0.22551370327423648, 0.19074805824729857, 0.1028990578480643, 0.08732253669285606, 0.11657051344666414, 0.0836473605484882, 0.10396597242393346, 0.09678377922500081, 0.08195878348257357, 0.09733918482186421, 0.09392730927062043]}, "mutation_prompt": null}
