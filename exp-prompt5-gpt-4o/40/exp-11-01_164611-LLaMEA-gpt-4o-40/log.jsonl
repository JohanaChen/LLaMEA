{"id": "ca202daa-2988-4ec0-99d7-bf4be1382089", "solution": "import numpy as np\n\nclass ADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Evaluate initial population\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                # Select indices for mutation\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Perform mutation and crossover\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            # Apply local search to best individual periodically if budget allows\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ADELSOptimizer", "description": "Adaptive Differential Evolution with Local Search leveraging population diversity to balance exploration and exploitation.", "configspace": "", "generation": 0, "fitness": 0.36513909718289894, "feedback": "The algorithm ADELSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.24.", "error": "", "parent_id": null, "metadata": {"aucs": [0.766340889485982, 0.7520529560413111, 0.7560249256795225, 0.7633971263189563, 0.7665504257478769, 0.7787828195303294, 0.7578886937753072, 0.7622219541581322, 0.7574894015178413, 0.5890803386387622, 0.5589462299899586, 0.5686123729703655, 0.5809851650910498, 0.5813112291628394, 0.5556303464343665, 0.5506540989825193, 0.5345762314505946, 0.5355700416059447, 0.12347301282093104, 0.13143424027082784, 0.12105272917689036, 0.10981413589101408, 0.12358971933247798, 0.11691267105509329, 0.1274409310587491, 0.11148910394128175, 0.10364427375977958, 0.10830808935351721, 0.10977393756779164, 0.10562676562937579, 0.11363024334872973, 0.10175389214810782, 0.11345598906123233, 0.11004756963141427, 0.14669218587293142, 0.12219833513461564, 0.9112068164336699, 0.8219435570515549, 0.9293895914409617, 0.8738316990729859, 0.9159468719590579, 0.8900966285407703, 0.9102963721451325, 0.9282499617978527, 0.8643805863403157, 0.4522851478066665, 0.454482671639201, 0.3857347797749431, 0.4571666387690164, 0.4239893458981979, 0.44232393608077214, 0.4185596720903799, 0.44497021191977804, 0.4269189046916396, 0.766159095087064, 0.7322276021795446, 0.7142203583325963, 0.7652338002372329, 0.7692828289856131, 0.8217862579381361, 0.6898235657253902, 0.7993361099922829, 0.7318734614376174, 0.21320352621503535, 0.21929800454928605, 0.26312698664507583, 0.20782845722969168, 0.17077696338486748, 0.41117318876273445, 0.18686376091580692, 0.3211899417016847, 0.2397632953219505, 0.22977401078433213, 0.231067716876854, 0.24374656366802272, 0.20510755454940832, 0.22596159792863235, 0.3129595761489148, 0.19251457823885787, 0.20140221320119966, 0.21307302036608633, 0.3325813501027889, 0.31369774819073815, 0.315151856719483, 0.3435372799037111, 0.3327397558783113, 0.31408717472837555, 0.2980413614633052, 0.3394938361135662, 0.29528802352173456, 0.4473453340728152, 0.4568853079158455, 0.48327015718725586, 0.47759867570894443, 0.41405283806221127, 0.48703259555238076, 0.5209892566095362, 0.532966103109584, 0.5049684258465147, 0.11531797760367934, 0.11874711529431425, 0.14539699004319406, 0.19743195705126793, 0.23167694125613914, 0.13239932722534198, 0.12444584043770246, 0.19415495834834784, 0.10779991956121138, 0.2456724677133374, 0.2741551173337099, 0.27789222549222836, 0.2773466096137339, 0.2928370490585772, 0.3023800897263079, 0.26647185244543437, 0.27984607658351557, 0.2790902292478368, 0.6685109316033233, 0.6934533161633661, 0.6796744804627848, 0.6326908308011954, 0.6984607124310664, 0.6633547315673314, 0.6787336906029864, 0.6710729549453422, 0.6476241965971397, 0.11806016561921717, 0.11902547038801126, 0.12886644809185, 0.11321701389627414, 0.1092609473532784, 0.13365681698278875, 0.1345581762641176, 0.10632377835235785, 0.11980040734915276, 0.15885256226105193, 0.1768717101335434, 0.23146693845121225, 0.19745776560527173, 0.23484083918863075, 0.16312829454267852, 0.24076955342321849, 0.1854369460987415, 0.19293228229821202, 0.3706778456139088, 0.3817385935296913, 0.3837549560989635, 0.4013938786883241, 0.38664685444701696, 0.3795438333805752, 0.40475929739869354, 0.3844231650138672, 0.42381542516033055, 0.3151800533837411, 0.29694917091169326, 0.3114929119020817, 0.3180173948400937, 0.2868460075670397, 0.29853682913591173, 0.2949586652801275, 0.30859240937121535, 0.32608566030087127, 0.18499519255483543, 0.19806939730067075, 0.22441414292597317, 0.24000634836727586, 0.20568375252138726, 0.2319059822943793, 0.2036975894252463, 0.18665749307351287, 0.20453593973591855, 0.19381425350953696, 0.19120186785649973, 0.19658736205732807, 0.1972575571134083, 0.22505245412844577, 0.18995316363029646, 0.21357036907206406, 0.18479067292482365, 0.20303983659553615, 0.184825336533895, 0.7394076005667274, 0.19580166558265988, 0.7030170936353628, 0.7630603484519721, 0.7557264091768919, 0.8075567622457585, 0.6757007969064535, 0.17506707775659247, 0.7350683845247972, 0.5347138368957729, 0.3059608872260151, 0.19530145191134862, 0.6924661454957028, 0.7948307569031313, 0.20617172664891592, 0.7258222162406788, 0.21051058507166465, 0.18322748589751525, 0.20170151520761148, 0.17967302725195333, 0.18558973757923303, 0.19675780336442883, 0.2114102489492412, 0.18586136593286473, 0.195364097141973, 0.191462151097598, 0.0930725716306382, 0.08879791614684196, 0.08618244185650115, 0.08759544662214669, 0.08523595299592346, 0.08062079180247017, 0.0832396331658134, 0.08085926448336578, 0.08584584380407212]}, "mutation_prompt": null}
{"id": "4b50de86-8c8a-492c-a0c0-9e4fabac6a28", "solution": "import numpy as np\n\nclass ADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Evaluate initial population\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                # Select indices for mutation\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Perform mutation and crossover\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            # Apply local search to best individual periodically if budget allows\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ADELSOptimizer", "description": "Adaptive Differential Evolution with Local Search leveraging population diversity to balance exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ca202daa-2988-4ec0-99d7-bf4be1382089", "metadata": {"aucs": [0.766340889485982, 0.7520529560413111, 0.7560249256795225, 0.7633971263189563, 0.7665504257478769, 0.7787828195303294, 0.7578886937753072, 0.7622219541581322, 0.7574894015178413, 0.5890803386387622, 0.5589462299899586, 0.5686123729703655, 0.5809851650910498, 0.5813112291628394, 0.5556303464343665, 0.5506540989825193, 0.5345762314505946, 0.5355700416059447, 0.12347301282093104, 0.13143424027082784, 0.12105272917689036, 0.10981413589101408, 0.12358971933247798, 0.11691267105509329, 0.1274409310587491, 0.11148910394128175, 0.10364427375977958, 0.10830808935351721, 0.10977393756779164, 0.10562676562937579, 0.11363024334872973, 0.10175389214810782, 0.11345598906123233, 0.11004756963141427, 0.14669218587293142, 0.12219833513461564, 0.9112068164336699, 0.8219435570515549, 0.9293895914409617, 0.8738316990729859, 0.9159468719590579, 0.8900966285407703, 0.9102963721451325, 0.9282499617978527, 0.8643805863403157, 0.4522851478066665, 0.454482671639201, 0.3857347797749431, 0.4571666387690164, 0.4239893458981979, 0.44232393608077214, 0.4185596720903799, 0.44497021191977804, 0.4269189046916396, 0.766159095087064, 0.7322276021795446, 0.7142203583325963, 0.7652338002372329, 0.7692828289856131, 0.8217862579381361, 0.6898235657253902, 0.7993361099922829, 0.7318734614376174, 0.21320352621503535, 0.21929800454928605, 0.26312698664507583, 0.20782845722969168, 0.17077696338486748, 0.41117318876273445, 0.18686376091580692, 0.3211899417016847, 0.2397632953219505, 0.22977401078433213, 0.231067716876854, 0.24374656366802272, 0.20510755454940832, 0.22596159792863235, 0.3129595761489148, 0.19251457823885787, 0.20140221320119966, 0.21307302036608633, 0.3325813501027889, 0.31369774819073815, 0.315151856719483, 0.3435372799037111, 0.3327397558783113, 0.31408717472837555, 0.2980413614633052, 0.3394938361135662, 0.29528802352173456, 0.4473453340728152, 0.4568853079158455, 0.48327015718725586, 0.47759867570894443, 0.41405283806221127, 0.48703259555238076, 0.5209892566095362, 0.532966103109584, 0.5049684258465147, 0.11531797760367934, 0.11874711529431425, 0.14539699004319406, 0.19743195705126793, 0.23167694125613914, 0.13239932722534198, 0.12444584043770246, 0.19415495834834784, 0.10779991956121138, 0.2456724677133374, 0.2741551173337099, 0.27789222549222836, 0.2773466096137339, 0.2928370490585772, 0.3023800897263079, 0.26647185244543437, 0.27984607658351557, 0.2790902292478368, 0.6685109316033233, 0.6934533161633661, 0.6796744804627848, 0.6326908308011954, 0.6984607124310664, 0.6633547315673314, 0.6787336906029864, 0.6710729549453422, 0.6476241965971397, 0.11806016561921717, 0.11902547038801126, 0.12886644809185, 0.11321701389627414, 0.1092609473532784, 0.13365681698278875, 0.1345581762641176, 0.10632377835235785, 0.11980040734915276, 0.15885256226105193, 0.1768717101335434, 0.23146693845121225, 0.19745776560527173, 0.23484083918863075, 0.16312829454267852, 0.24076955342321849, 0.1854369460987415, 0.19293228229821202, 0.3706778456139088, 0.3817385935296913, 0.3837549560989635, 0.4013938786883241, 0.38664685444701696, 0.3795438333805752, 0.40475929739869354, 0.3844231650138672, 0.42381542516033055, 0.3151800533837411, 0.29694917091169326, 0.3114929119020817, 0.3180173948400937, 0.2868460075670397, 0.29853682913591173, 0.2949586652801275, 0.30859240937121535, 0.32608566030087127, 0.18499519255483543, 0.19806939730067075, 0.22441414292597317, 0.24000634836727586, 0.20568375252138726, 0.2319059822943793, 0.2036975894252463, 0.18665749307351287, 0.20453593973591855, 0.19381425350953696, 0.19120186785649973, 0.19658736205732807, 0.1972575571134083, 0.22505245412844577, 0.18995316363029646, 0.21357036907206406, 0.18479067292482365, 0.20303983659553615, 0.184825336533895, 0.7394076005667274, 0.19580166558265988, 0.7030170936353628, 0.7630603484519721, 0.7557264091768919, 0.8075567622457585, 0.6757007969064535, 0.17506707775659247, 0.7350683845247972, 0.5347138368957729, 0.3059608872260151, 0.19530145191134862, 0.6924661454957028, 0.7948307569031313, 0.20617172664891592, 0.7258222162406788, 0.21051058507166465, 0.18322748589751525, 0.20170151520761148, 0.17967302725195333, 0.18558973757923303, 0.19675780336442883, 0.2114102489492412, 0.18586136593286473, 0.195364097141973, 0.191462151097598, 0.0930725716306382, 0.08879791614684196, 0.08618244185650115, 0.08759544662214669, 0.08523595299592346, 0.08062079180247017, 0.0832396331658134, 0.08085926448336578, 0.08584584380407212]}, "mutation_prompt": null}
{"id": "5d3838c0-d6eb-438f-9391-d2182ab34f1e", "solution": "import numpy as np\n\nclass ADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Evaluate initial population\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                # Select indices for mutation\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Perform mutation and crossover\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            # Dynamically adjust local search intensity\n            if evaluations < self.budget * 0.5:\n                self.local_search_intensity = 3\n            else:\n                self.local_search_intensity = 7\n\n            # Apply local search to best individual periodically if budget allows\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ADELSOptimizer", "description": "Enhanced Adaptive Differential Evolution with Dynamic Local Search Intensity to better adapt to function landscapes.", "configspace": "", "generation": 2, "fitness": 0.35720142129373583, "feedback": "The algorithm ADELSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.24.", "error": "", "parent_id": "ca202daa-2988-4ec0-99d7-bf4be1382089", "metadata": {"aucs": [0.782609767197877, 0.7645387565020834, 0.7593338644579887, 0.7625373459628392, 0.7779948649723849, 0.7673771752011429, 0.7718048678742266, 0.7886105811049593, 0.7723656994000905, 0.5828557089357975, 0.5361699832377517, 0.5987332529709399, 0.5936125468656601, 0.5722843527507864, 0.5800147212936027, 0.5837238172271121, 0.5642362813664172, 0.5959597996999242, 0.12183680958536625, 0.12462454301301806, 0.1260590586741308, 0.1407883250199573, 0.12131615558620301, 0.11678402459596893, 0.1254705651615472, 0.12540973987394188, 0.12416976580476946, 0.10209062042726547, 0.107304468696649, 0.11202171151336937, 0.10686471732836256, 0.11505004765233884, 0.10260410208167214, 0.11324752511278224, 0.1173818005858337, 0.11170053790174972, 0.8753682717778561, 0.8927575033597341, 0.860957129223324, 0.9380732529568179, 0.9313903352594674, 0.9379413299586973, 0.8955904030796965, 0.8762159182920175, 0.9031635361431147, 0.42119798447298196, 0.43416164742820396, 0.398613638575522, 0.42200195885121183, 0.38862248877942407, 0.4283981866456642, 0.43794588823856306, 0.43641702608968613, 0.39826255048869075, 0.7602636318417053, 0.7657512897886171, 0.7472869074609119, 0.7930707071457748, 0.7895966154703598, 0.7541469641446622, 0.740301765661384, 0.7314188340820897, 0.7538411807254868, 0.2104766445748948, 0.21207873613576633, 0.1730674451387071, 0.16163542722086588, 0.19071059507882548, 0.25079256793628923, 0.295420149006244, 0.2761869742401195, 0.16591431980042703, 0.18960322140712182, 0.2235155633231377, 0.23169354527759123, 0.16640248084785525, 0.16460148092743054, 0.2501945385709434, 0.28319226629764627, 0.20248638954770892, 0.17208496649337446, 0.3714237175974253, 0.322783202687686, 0.2718043076361395, 0.33072817808298494, 0.3490025514599826, 0.3249830627938668, 0.36879492575961104, 0.3209138469907742, 0.3175106909528086, 0.47735851352250613, 0.45963861476752044, 0.44932790960436253, 0.4792986589997488, 0.4842405192405874, 0.4600861264041384, 0.5052961400265417, 0.5238350503032019, 0.44718225074580675, 0.1140315420946425, 0.20271330212307526, 0.15432568182978434, 0.2456585786003267, 0.19255886320127713, 0.16870121726312903, 0.1887515070627208, 0.1272737592740688, 0.1397821072389983, 0.26260908820037043, 0.29675247251100234, 0.2697302191501245, 0.30685562373797026, 0.2834140681708893, 0.2883027809761004, 0.2793775498913166, 0.26070984000400643, 0.2820373521436952, 0.6731441547145092, 0.6692178741506413, 0.654105042300059, 0.6846675602022376, 0.6664542302081623, 0.6671832421731463, 0.6801944155301622, 0.6816530791196882, 0.6940564116186552, 0.1239643150124975, 0.11077749062745534, 0.1268726738874275, 0.11720446673909024, 0.11466567328911914, 0.11216169666795317, 0.12023626778373786, 0.10771430662996084, 0.12525224692088466, 0.1678605667638029, 0.19439741119063514, 0.17735797899638728, 0.16570678050480714, 0.18193499079058995, 0.16703293460651714, 0.21144770050076012, 0.14628893310357216, 0.16496238565200838, 0.3947631663490785, 0.385402579002154, 0.3977591467088134, 0.4109977672579749, 0.3732987687123326, 0.36882926712941055, 0.41107579297524033, 0.3959490884019289, 0.40423801952739247, 0.3021616458123506, 0.27176886570049974, 0.3206684780451935, 0.28396740544723986, 0.29478553252882445, 0.3035808494378832, 0.3178238374711183, 0.30302458440866364, 0.3026290504135386, 0.1948450270029357, 0.20266109675713095, 0.2157704360264756, 0.1802009078201965, 0.19720780827857565, 0.1935393627146128, 0.20211183679226907, 0.21557774121962248, 0.19638868308820268, 0.2174523703854513, 0.2100681009207973, 0.22257482874357915, 0.2596316382062971, 0.20381900957118126, 0.20121657008037597, 0.21145570354092558, 0.2223682073248312, 0.1848252983187243, 0.7170141947447219, 0.18507469294147205, 0.19414946340038897, 0.7936446514627408, 0.1991530454399284, 0.19624669778516612, 0.5965642516716401, 0.6331833144750779, 0.5093280671048863, 0.6132796593147423, 0.7158743427628277, 0.6539814095141084, 0.5195977024602287, 0.20279296812737246, 0.5021635040365267, 0.2085560724675748, 0.20852165279830392, 0.2086637860769165, 0.2083822553035507, 0.20432409659327555, 0.20460447893197153, 0.19600671224102273, 0.18059645710909356, 0.19266363680315568, 0.18293672130877858, 0.18911581133009825, 0.1860199313634031, 0.08156218256794256, 0.08374767015161522, 0.08145323583632436, 0.07815678514559588, 0.08498766548281056, 0.08248604023563089, 0.07943517618698248, 0.08302209680652395, 0.08716728320593281]}, "mutation_prompt": null}
{"id": "717549fc-4e92-49cc-8e29-1248c88f4523", "solution": "import numpy as np\n\nclass ADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Evaluate initial population\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                # Select indices for mutation\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Perform mutation and crossover\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            # Apply local search to best individual periodically if budget allows\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ADELSOptimizer", "description": "Adaptive Differential Evolution with Local Search leveraging population diversity to balance exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ca202daa-2988-4ec0-99d7-bf4be1382089", "metadata": {"aucs": [0.766340889485982, 0.7520529560413111, 0.7560249256795225, 0.7633971263189563, 0.7665504257478769, 0.7787828195303294, 0.7578886937753072, 0.7622219541581322, 0.7574894015178413, 0.5890803386387622, 0.5589462299899586, 0.5686123729703655, 0.5809851650910498, 0.5813112291628394, 0.5556303464343665, 0.5506540989825193, 0.5345762314505946, 0.5355700416059447, 0.12347301282093104, 0.13143424027082784, 0.12105272917689036, 0.10981413589101408, 0.12358971933247798, 0.11691267105509329, 0.1274409310587491, 0.11148910394128175, 0.10364427375977958, 0.10830808935351721, 0.10977393756779164, 0.10562676562937579, 0.11363024334872973, 0.10175389214810782, 0.11345598906123233, 0.11004756963141427, 0.14669218587293142, 0.12219833513461564, 0.9112068164336699, 0.8219435570515549, 0.9293895914409617, 0.8738316990729859, 0.9159468719590579, 0.8900966285407703, 0.9102963721451325, 0.9282499617978527, 0.8643805863403157, 0.4522851478066665, 0.454482671639201, 0.3857347797749431, 0.4571666387690164, 0.4239893458981979, 0.44232393608077214, 0.4185596720903799, 0.44497021191977804, 0.4269189046916396, 0.766159095087064, 0.7322276021795446, 0.7142203583325963, 0.7652338002372329, 0.7692828289856131, 0.8217862579381361, 0.6898235657253902, 0.7993361099922829, 0.7318734614376174, 0.21320352621503535, 0.21929800454928605, 0.26312698664507583, 0.20782845722969168, 0.17077696338486748, 0.41117318876273445, 0.18686376091580692, 0.3211899417016847, 0.2397632953219505, 0.22977401078433213, 0.231067716876854, 0.24374656366802272, 0.20510755454940832, 0.22596159792863235, 0.3129595761489148, 0.19251457823885787, 0.20140221320119966, 0.21307302036608633, 0.3325813501027889, 0.31369774819073815, 0.315151856719483, 0.3435372799037111, 0.3327397558783113, 0.31408717472837555, 0.2980413614633052, 0.3394938361135662, 0.29528802352173456, 0.4473453340728152, 0.4568853079158455, 0.48327015718725586, 0.47759867570894443, 0.41405283806221127, 0.48703259555238076, 0.5209892566095362, 0.532966103109584, 0.5049684258465147, 0.11531797760367934, 0.11874711529431425, 0.14539699004319406, 0.19743195705126793, 0.23167694125613914, 0.13239932722534198, 0.12444584043770246, 0.19415495834834784, 0.10779991956121138, 0.2456724677133374, 0.2741551173337099, 0.27789222549222836, 0.2773466096137339, 0.2928370490585772, 0.3023800897263079, 0.26647185244543437, 0.27984607658351557, 0.2790902292478368, 0.6685109316033233, 0.6934533161633661, 0.6796744804627848, 0.6326908308011954, 0.6984607124310664, 0.6633547315673314, 0.6787336906029864, 0.6710729549453422, 0.6476241965971397, 0.11806016561921717, 0.11902547038801126, 0.12886644809185, 0.11321701389627414, 0.1092609473532784, 0.13365681698278875, 0.1345581762641176, 0.10632377835235785, 0.11980040734915276, 0.15885256226105193, 0.1768717101335434, 0.23146693845121225, 0.19745776560527173, 0.23484083918863075, 0.16312829454267852, 0.24076955342321849, 0.1854369460987415, 0.19293228229821202, 0.3706778456139088, 0.3817385935296913, 0.3837549560989635, 0.4013938786883241, 0.38664685444701696, 0.3795438333805752, 0.40475929739869354, 0.3844231650138672, 0.42381542516033055, 0.3151800533837411, 0.29694917091169326, 0.3114929119020817, 0.3180173948400937, 0.2868460075670397, 0.29853682913591173, 0.2949586652801275, 0.30859240937121535, 0.32608566030087127, 0.18499519255483543, 0.19806939730067075, 0.22441414292597317, 0.24000634836727586, 0.20568375252138726, 0.2319059822943793, 0.2036975894252463, 0.18665749307351287, 0.20453593973591855, 0.19381425350953696, 0.19120186785649973, 0.19658736205732807, 0.1972575571134083, 0.22505245412844577, 0.18995316363029646, 0.21357036907206406, 0.18479067292482365, 0.20303983659553615, 0.184825336533895, 0.7394076005667274, 0.19580166558265988, 0.7030170936353628, 0.7630603484519721, 0.7557264091768919, 0.8075567622457585, 0.6757007969064535, 0.17506707775659247, 0.7350683845247972, 0.5347138368957729, 0.3059608872260151, 0.19530145191134862, 0.6924661454957028, 0.7948307569031313, 0.20617172664891592, 0.7258222162406788, 0.21051058507166465, 0.18322748589751525, 0.20170151520761148, 0.17967302725195333, 0.18558973757923303, 0.19675780336442883, 0.2114102489492412, 0.18586136593286473, 0.195364097141973, 0.191462151097598, 0.0930725716306382, 0.08879791614684196, 0.08618244185650115, 0.08759544662214669, 0.08523595299592346, 0.08062079180247017, 0.0832396331658134, 0.08085926448336578, 0.08584584380407212]}, "mutation_prompt": null}
{"id": "ec09df6d-18ca-4e10-b941-6294e3d0db67", "solution": "import numpy as np\n\nclass ADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.elite_solution = None\n        self.elite_fitness = np.inf\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Evaluate initial population\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                # Select indices for mutation\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Perform mutation and crossover\n                F_dynamic = 0.4 + np.random.rand() * 0.6  # Self-adaptive F\n                mutant = self.population[a] + F_dynamic * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                # Selection with elite preservation\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.elite_fitness:\n                        self.elite_solution = trial\n                        self.elite_fitness = trial_fitness\n                else:\n                    new_population[i] = self.population[i]\n\n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            # Apply local search to best individual periodically if budget allows\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        if self.elite_solution is not None:\n            return self.elite_solution, self.elite_fitness\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ADELSOptimizer", "description": "Enhanced ADELS with self-adaptive parameters and elite preservation to improve convergence speed and solution quality.", "configspace": "", "generation": 4, "fitness": 0.306035887803316, "feedback": "The algorithm ADELSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.22.", "error": "", "parent_id": "ca202daa-2988-4ec0-99d7-bf4be1382089", "metadata": {"aucs": [0.6847214398147161, 0.6812110241799265, 0.6676624677459738, 0.7057994701028633, 0.6738585264618906, 0.7292285537900469, 0.6759109757862731, 0.6824649558767474, 0.6920687902921945, 0.401090110012823, 0.40207831156488194, 0.4274269172700258, 0.4099145377770963, 0.41008968506372756, 0.40509044920843595, 0.40895691660222977, 0.40565848774637947, 0.40700717355187876, 0.13079064121702955, 0.11401378920756033, 0.12465584348204406, 0.10621145209413463, 0.09314607470802516, 0.12119305980804929, 0.10806250873256718, 0.12777197673667218, 0.10750734180588684, 0.12666612244509234, 0.10001035742227704, 0.0951732894904338, 0.1080939990193972, 0.1182608546453956, 0.11024124834177584, 0.08701794463673418, 0.10393691147250306, 0.09747190892105029, 0.9621451970536552, 0.8591194501695858, 0.9614640485244093, 0.9337825583812607, 0.8716724565007028, 0.9423582379780574, 0.9557599371191626, 0.9328449357176735, 0.9414113955540427, 0.3283804881027772, 0.3257721551961257, 0.33512998799665705, 0.335058485376145, 0.32458632031991497, 0.32067136218015735, 0.3517102968552548, 0.361857864886743, 0.3775639312707675, 0.6069180843478903, 0.5259928139062222, 0.5831600707274602, 0.6318865357440492, 0.5937012874164793, 0.6316231929776013, 0.6257860116478204, 0.5691554493640181, 0.6205903086135244, 0.20452338250191826, 0.18072353048462753, 0.1925232672169821, 0.2394592274809746, 0.22673167869847954, 0.21201275406282072, 0.265503079344525, 0.20532863321289108, 0.2523801661099625, 0.22819917201490048, 0.19494366580886824, 0.22108269364653887, 0.2554970860025716, 0.24878785796080294, 0.24477399630207997, 0.27761828872636796, 0.17892666056944617, 0.20790265442100597, 0.1866276441488568, 0.18105029993309985, 0.17634772997672066, 0.20540218341060001, 0.18537696824475802, 0.1677131705757261, 0.18885154590693387, 0.2093855185322222, 0.17767571562742945, 0.2944531073258482, 0.29505717123174113, 0.32644414188320847, 0.32055579616368823, 0.2767856692559605, 0.2751986252011319, 0.357206937076462, 0.32914461230748626, 0.337130011066597, 0.05989833535489919, 0.019441277302221893, 0.07750216165563428, 0.060927510098773396, 0.05027639086610436, 0.07615652116363159, 0.07186231612038596, 0.09571429338295911, 0.05839141904745926, 0.20281742081017295, 0.2045423293849874, 0.21337573067986815, 0.20797819691441832, 0.19089199426310144, 0.20788547191460116, 0.18541466799349138, 0.20483134476429465, 0.19307650900384565, 0.5432922333177785, 0.5336842603009007, 0.5403612397475159, 0.5474411266946781, 0.5453376190934835, 0.5444659931940462, 0.5535683420105614, 0.5471518717141985, 0.5376530705684339, 0.1151997234003489, 0.10292689941002586, 0.10120099252805426, 0.10066092320790743, 0.11050900024549482, 0.11672272038505893, 0.09479425345721826, 0.10072673581004998, 0.08568023868991237, 0.19333365686618587, 0.17018332662853264, 0.38309027989000155, 0.21460263048651373, 0.3261993968628799, 0.16342002317307902, 0.20738135420331416, 0.16011890662831918, 0.20647951469443382, 0.3039507209845267, 0.3080267196921884, 0.32458509288467274, 0.29930198091756477, 0.29382586863897675, 0.3009626153168534, 0.34279661702893593, 0.3185499039976456, 0.3179210257240379, 0.23525891298878354, 0.2469799641114625, 0.2397589101518134, 0.23788506726741265, 0.23322650179774407, 0.24779232234999649, 0.24825055094279147, 0.24418652870726232, 0.2400234792730641, 0.18249510577631012, 0.18504864808234356, 0.21004256901406193, 0.19877771124932453, 0.17300996037572336, 0.18858279457518867, 0.21194719579199417, 0.2113161271097408, 0.18928637049408104, 0.19542076572168499, 0.22856296443515667, 0.21003569054821147, 0.18530023835344434, 0.17959119982505123, 0.20906804435942572, 0.18557447482292977, 0.18480480595939885, 0.1964597708934127, 0.636014493600866, 0.15430397734668588, 0.8051916638639662, 0.5686000339805024, 0.20498205564548477, 0.2855676386553446, 0.7105417999235185, 0.1785516867980239, 0.6788845667940164, 0.5887750155235788, 0.20251121958128904, 0.6292254493122407, 0.4729522399664462, 0.3706750999155243, 0.7051651937597687, 0.20661998970005768, 0.20792053318770365, 0.21147348171097669, 0.18180228180370916, 0.1889406536327245, 0.17661308287888244, 0.1780881724279303, 0.17658388029572303, 0.1980761326056779, 0.18059958490048156, 0.18393470126550315, 0.20761369875789604, 0.07203331261779966, 0.07200374581119906, 0.07132093540772133, 0.07775136708643515, 0.07730449991054011, 0.0802926618939136, 0.08010793083464196, 0.0755974533035183, 0.08346246332584795]}, "mutation_prompt": null}
{"id": "be0d6938-8860-4711-8f70-718ccdc0365f", "solution": "import numpy as np\n\nclass ADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Evaluate initial population\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                # Select indices for mutation\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Perform mutation and crossover\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            # Apply local search to best individual periodically if budget allows\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ADELSOptimizer", "description": "Adaptive Differential Evolution with Local Search leveraging population diversity to balance exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ca202daa-2988-4ec0-99d7-bf4be1382089", "metadata": {"aucs": [0.766340889485982, 0.7520529560413111, 0.7560249256795225, 0.7633971263189563, 0.7665504257478769, 0.7787828195303294, 0.7578886937753072, 0.7622219541581322, 0.7574894015178413, 0.5890803386387622, 0.5589462299899586, 0.5686123729703655, 0.5809851650910498, 0.5813112291628394, 0.5556303464343665, 0.5506540989825193, 0.5345762314505946, 0.5355700416059447, 0.12347301282093104, 0.13143424027082784, 0.12105272917689036, 0.10981413589101408, 0.12358971933247798, 0.11691267105509329, 0.1274409310587491, 0.11148910394128175, 0.10364427375977958, 0.10830808935351721, 0.10977393756779164, 0.10562676562937579, 0.11363024334872973, 0.10175389214810782, 0.11345598906123233, 0.11004756963141427, 0.14669218587293142, 0.12219833513461564, 0.9112068164336699, 0.8219435570515549, 0.9293895914409617, 0.8738316990729859, 0.9159468719590579, 0.8900966285407703, 0.9102963721451325, 0.9282499617978527, 0.8643805863403157, 0.4522851478066665, 0.454482671639201, 0.3857347797749431, 0.4571666387690164, 0.4239893458981979, 0.44232393608077214, 0.4185596720903799, 0.44497021191977804, 0.4269189046916396, 0.766159095087064, 0.7322276021795446, 0.7142203583325963, 0.7652338002372329, 0.7692828289856131, 0.8217862579381361, 0.6898235657253902, 0.7993361099922829, 0.7318734614376174, 0.21320352621503535, 0.21929800454928605, 0.26312698664507583, 0.20782845722969168, 0.17077696338486748, 0.41117318876273445, 0.18686376091580692, 0.3211899417016847, 0.2397632953219505, 0.22977401078433213, 0.231067716876854, 0.24374656366802272, 0.20510755454940832, 0.22596159792863235, 0.3129595761489148, 0.19251457823885787, 0.20140221320119966, 0.21307302036608633, 0.3325813501027889, 0.31369774819073815, 0.315151856719483, 0.3435372799037111, 0.3327397558783113, 0.31408717472837555, 0.2980413614633052, 0.3394938361135662, 0.29528802352173456, 0.4473453340728152, 0.4568853079158455, 0.48327015718725586, 0.47759867570894443, 0.41405283806221127, 0.48703259555238076, 0.5209892566095362, 0.532966103109584, 0.5049684258465147, 0.11531797760367934, 0.11874711529431425, 0.14539699004319406, 0.19743195705126793, 0.23167694125613914, 0.13239932722534198, 0.12444584043770246, 0.19415495834834784, 0.10779991956121138, 0.2456724677133374, 0.2741551173337099, 0.27789222549222836, 0.2773466096137339, 0.2928370490585772, 0.3023800897263079, 0.26647185244543437, 0.27984607658351557, 0.2790902292478368, 0.6685109316033233, 0.6934533161633661, 0.6796744804627848, 0.6326908308011954, 0.6984607124310664, 0.6633547315673314, 0.6787336906029864, 0.6710729549453422, 0.6476241965971397, 0.11806016561921717, 0.11902547038801126, 0.12886644809185, 0.11321701389627414, 0.1092609473532784, 0.13365681698278875, 0.1345581762641176, 0.10632377835235785, 0.11980040734915276, 0.15885256226105193, 0.1768717101335434, 0.23146693845121225, 0.19745776560527173, 0.23484083918863075, 0.16312829454267852, 0.24076955342321849, 0.1854369460987415, 0.19293228229821202, 0.3706778456139088, 0.3817385935296913, 0.3837549560989635, 0.4013938786883241, 0.38664685444701696, 0.3795438333805752, 0.40475929739869354, 0.3844231650138672, 0.42381542516033055, 0.3151800533837411, 0.29694917091169326, 0.3114929119020817, 0.3180173948400937, 0.2868460075670397, 0.29853682913591173, 0.2949586652801275, 0.30859240937121535, 0.32608566030087127, 0.18499519255483543, 0.19806939730067075, 0.22441414292597317, 0.24000634836727586, 0.20568375252138726, 0.2319059822943793, 0.2036975894252463, 0.18665749307351287, 0.20453593973591855, 0.19381425350953696, 0.19120186785649973, 0.19658736205732807, 0.1972575571134083, 0.22505245412844577, 0.18995316363029646, 0.21357036907206406, 0.18479067292482365, 0.20303983659553615, 0.184825336533895, 0.7394076005667274, 0.19580166558265988, 0.7030170936353628, 0.7630603484519721, 0.7557264091768919, 0.8075567622457585, 0.6757007969064535, 0.17506707775659247, 0.7350683845247972, 0.5347138368957729, 0.3059608872260151, 0.19530145191134862, 0.6924661454957028, 0.7948307569031313, 0.20617172664891592, 0.7258222162406788, 0.21051058507166465, 0.18322748589751525, 0.20170151520761148, 0.17967302725195333, 0.18558973757923303, 0.19675780336442883, 0.2114102489492412, 0.18586136593286473, 0.195364097141973, 0.191462151097598, 0.0930725716306382, 0.08879791614684196, 0.08618244185650115, 0.08759544662214669, 0.08523595299592346, 0.08062079180247017, 0.0832396331658134, 0.08085926448336578, 0.08584584380407212]}, "mutation_prompt": null}
{"id": "14935e55-5fc4-4bf9-b26b-578e09a4b20b", "solution": "import numpy as np\n\nclass ADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Evaluate initial population\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                # Select indices for mutation\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Perform mutation with adaptive factor\n                adaptive_F = self.F + (0.9 - self.F) * (self.fitness[i] - min(self.fitness)) / (max(self.fitness) - min(self.fitness))\n                mutant = self.population[a] + adaptive_F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            # Dynamic local search intensity based on budget\n            dynamic_intensity = max(1, int(self.local_search_intensity * (1 - evaluations / self.budget)))\n            if evaluations + dynamic_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func, dynamic_intensity)\n                evaluations += dynamic_intensity\n\n        return self.best_solution()\n\n    def local_search(self, index, func, intensity):\n        candidate = self.population[index]\n        for _ in range(intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ADELSOptimizer", "description": "Enhanced ADELSOptimizer by incorporating adaptive mutation and dynamic local search intensity to improve convergence.", "configspace": "", "generation": 6, "fitness": 0.30676360541769127, "feedback": "The algorithm ADELSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.22.", "error": "", "parent_id": "ca202daa-2988-4ec0-99d7-bf4be1382089", "metadata": {"aucs": [0.6671545101094282, 0.6869747378605716, 0.6949915852626618, 0.6890507027786567, 0.6709686170347695, 0.66503761146308, 0.6894177732574287, 0.7044180013468596, 0.6762591803400486, 0.44556675433414616, 0.4351722400783371, 0.4272778853957788, 0.43274543132750587, 0.43244294484073587, 0.43696880641165703, 0.4426789512230591, 0.4756995302610827, 0.399123664136772, 0.11358250005436166, 0.09692687310109593, 0.10733772548988874, 0.09848999598601627, 0.10045028874680773, 0.11363726978237232, 0.10877219780321501, 0.11423779401656353, 0.13606568147762865, 0.10612398166442416, 0.09950466993631546, 0.09752015414225135, 0.10358725170669403, 0.10118694520879346, 0.09149933031377988, 0.08615318617736556, 0.08694873133013248, 0.09911496709474887, 0.9262149247223775, 0.9240368562061158, 0.9549742238804679, 0.9089106552093984, 0.9331577349924352, 0.8952639380495072, 0.9658988438038006, 0.925198489022183, 0.8969037625642574, 0.32167794259265114, 0.35069793536561333, 0.34704778926405944, 0.35980921823596823, 0.3196472891964126, 0.33683007389413666, 0.34764554001417713, 0.334862742394207, 0.35513300388946645, 0.6199677442249272, 0.6426149911269605, 0.6216246803857328, 0.6294859083755816, 0.6685268806373251, 0.6239290226417725, 0.628853997920345, 0.6543680159682211, 0.605277425759157, 0.2294431714451125, 0.22369460587449552, 0.194317360817572, 0.28252136848215625, 0.18155924879175722, 0.2246382025846705, 0.2217193344737518, 0.27227661240590983, 0.2191412318440552, 0.1701387304379186, 0.18745639565907124, 0.23404084075589038, 0.22981973394830502, 0.23934623027750135, 0.24813062768656924, 0.20657801568547862, 0.2642934246258134, 0.3083224985370091, 0.19313685957944704, 0.23773564782958678, 0.22293096780132382, 0.21161157715370005, 0.22022054426512627, 0.1859958050956544, 0.19494609101672444, 0.19324992611469183, 0.22558833980903548, 0.3578792416601475, 0.35365055002244206, 0.35037027901719575, 0.33477675484743763, 0.3887889686243984, 0.33589699011383223, 0.3751198528891876, 0.3596943125687251, 0.358152351492492, 0.08371726533550139, 0.078469960723071, 0.05494223594413239, 0.10722878190162133, 0.09368047138295754, 0.07784039224791772, 0.059006011361540045, 0.09576594489920698, 0.033795117814217734, 0.1697445965050245, 0.1724494853676346, 0.1594930041656114, 0.1895652113791435, 0.17679031765576037, 0.1804925883252616, 0.1722739485664897, 0.18123987542222975, 0.16950942341485986, 0.5436183239409567, 0.5379889300615655, 0.5430449641235233, 0.5539847788632783, 0.5336975760190932, 0.5540932105242788, 0.5730118874598884, 0.5188936549785963, 0.5274620971293755, 0.11306426434477379, 0.1042762324033838, 0.09819360156004642, 0.09153143193942237, 0.0826807030505966, 0.10390989594573508, 0.10845504881782331, 0.0896421867821382, 0.10553923851285618, 0.24239605113600415, 0.1381725760004734, 0.1836546133653243, 0.24990828860931147, 0.2611236739612365, 0.19896440437670437, 0.18165072025188234, 0.22015333215208988, 0.21899390855946343, 0.2962051193398555, 0.29014175553137267, 0.2758356071694231, 0.2803742768937386, 0.29101458611464737, 0.29061034619880066, 0.3092591615452748, 0.30672453437737524, 0.31320962982973155, 0.23001962569095324, 0.23536856874335976, 0.21188322283947214, 0.23486117333929046, 0.20405696718612532, 0.20185291200230826, 0.22984345045988286, 0.23640307558480333, 0.22683948674341736, 0.18226016400739364, 0.2089566358336259, 0.18750647233028572, 0.19416362823166555, 0.19966294933750783, 0.21421907358258518, 0.19971388302780457, 0.21368005387385292, 0.1805197212142995, 0.18342069512838965, 0.19151281717023716, 0.19007784201079203, 0.20312013888162317, 0.20431736061660666, 0.26569791353063, 0.18533060879602803, 0.182060549188092, 0.1794048800658733, 0.19311028140251796, 0.43419697180716565, 0.7076839127185438, 0.37236137637599764, 0.6563023100916887, 0.1822847434623064, 0.5044776267225058, 0.2572205398127204, 0.7067776686196683, 0.6387156325874745, 0.20860457312331582, 0.49143381968870004, 0.32046847692946645, 0.47216576023953016, 0.22543160535487183, 0.20701082219333888, 0.6908193011621845, 0.20988628013953514, 0.19643298639937845, 0.18192851238981844, 0.170328175774911, 0.19757183390153088, 0.20123733049314318, 0.18064489316875765, 0.1743806653994363, 0.18085351195324817, 0.17621098345595965, 0.07995037634108959, 0.08240986795043992, 0.07048406267129281, 0.07304284590758436, 0.09735895878581069, 0.0794906345665859, 0.06561040121368356, 0.07054088545761694, 0.07044023219389706]}, "mutation_prompt": null}
{"id": "d0038126-defc-487a-a678-516aa63f40ca", "solution": "import numpy as np\n\nclass ADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Evaluate initial population\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                # Select indices for mutation\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Perform mutation and crossover\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            # Apply local search to best individual periodically if budget allows\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ADELSOptimizer", "description": "Adaptive Differential Evolution with Local Search leveraging population diversity to balance exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ca202daa-2988-4ec0-99d7-bf4be1382089", "metadata": {"aucs": [0.766340889485982, 0.7520529560413111, 0.7560249256795225, 0.7633971263189563, 0.7665504257478769, 0.7787828195303294, 0.7578886937753072, 0.7622219541581322, 0.7574894015178413, 0.5890803386387622, 0.5589462299899586, 0.5686123729703655, 0.5809851650910498, 0.5813112291628394, 0.5556303464343665, 0.5506540989825193, 0.5345762314505946, 0.5355700416059447, 0.12347301282093104, 0.13143424027082784, 0.12105272917689036, 0.10981413589101408, 0.12358971933247798, 0.11691267105509329, 0.1274409310587491, 0.11148910394128175, 0.10364427375977958, 0.10830808935351721, 0.10977393756779164, 0.10562676562937579, 0.11363024334872973, 0.10175389214810782, 0.11345598906123233, 0.11004756963141427, 0.14669218587293142, 0.12219833513461564, 0.9112068164336699, 0.8219435570515549, 0.9293895914409617, 0.8738316990729859, 0.9159468719590579, 0.8900966285407703, 0.9102963721451325, 0.9282499617978527, 0.8643805863403157, 0.4522851478066665, 0.454482671639201, 0.3857347797749431, 0.4571666387690164, 0.4239893458981979, 0.44232393608077214, 0.4185596720903799, 0.44497021191977804, 0.4269189046916396, 0.766159095087064, 0.7322276021795446, 0.7142203583325963, 0.7652338002372329, 0.7692828289856131, 0.8217862579381361, 0.6898235657253902, 0.7993361099922829, 0.7318734614376174, 0.21320352621503535, 0.21929800454928605, 0.26312698664507583, 0.20782845722969168, 0.17077696338486748, 0.41117318876273445, 0.18686376091580692, 0.3211899417016847, 0.2397632953219505, 0.22977401078433213, 0.231067716876854, 0.24374656366802272, 0.20510755454940832, 0.22596159792863235, 0.3129595761489148, 0.19251457823885787, 0.20140221320119966, 0.21307302036608633, 0.3325813501027889, 0.31369774819073815, 0.315151856719483, 0.3435372799037111, 0.3327397558783113, 0.31408717472837555, 0.2980413614633052, 0.3394938361135662, 0.29528802352173456, 0.4473453340728152, 0.4568853079158455, 0.48327015718725586, 0.47759867570894443, 0.41405283806221127, 0.48703259555238076, 0.5209892566095362, 0.532966103109584, 0.5049684258465147, 0.11531797760367934, 0.11874711529431425, 0.14539699004319406, 0.19743195705126793, 0.23167694125613914, 0.13239932722534198, 0.12444584043770246, 0.19415495834834784, 0.10779991956121138, 0.2456724677133374, 0.2741551173337099, 0.27789222549222836, 0.2773466096137339, 0.2928370490585772, 0.3023800897263079, 0.26647185244543437, 0.27984607658351557, 0.2790902292478368, 0.6685109316033233, 0.6934533161633661, 0.6796744804627848, 0.6326908308011954, 0.6984607124310664, 0.6633547315673314, 0.6787336906029864, 0.6710729549453422, 0.6476241965971397, 0.11806016561921717, 0.11902547038801126, 0.12886644809185, 0.11321701389627414, 0.1092609473532784, 0.13365681698278875, 0.1345581762641176, 0.10632377835235785, 0.11980040734915276, 0.15885256226105193, 0.1768717101335434, 0.23146693845121225, 0.19745776560527173, 0.23484083918863075, 0.16312829454267852, 0.24076955342321849, 0.1854369460987415, 0.19293228229821202, 0.3706778456139088, 0.3817385935296913, 0.3837549560989635, 0.4013938786883241, 0.38664685444701696, 0.3795438333805752, 0.40475929739869354, 0.3844231650138672, 0.42381542516033055, 0.3151800533837411, 0.29694917091169326, 0.3114929119020817, 0.3180173948400937, 0.2868460075670397, 0.29853682913591173, 0.2949586652801275, 0.30859240937121535, 0.32608566030087127, 0.18499519255483543, 0.19806939730067075, 0.22441414292597317, 0.24000634836727586, 0.20568375252138726, 0.2319059822943793, 0.2036975894252463, 0.18665749307351287, 0.20453593973591855, 0.19381425350953696, 0.19120186785649973, 0.19658736205732807, 0.1972575571134083, 0.22505245412844577, 0.18995316363029646, 0.21357036907206406, 0.18479067292482365, 0.20303983659553615, 0.184825336533895, 0.7394076005667274, 0.19580166558265988, 0.7030170936353628, 0.7630603484519721, 0.7557264091768919, 0.8075567622457585, 0.6757007969064535, 0.17506707775659247, 0.7350683845247972, 0.5347138368957729, 0.3059608872260151, 0.19530145191134862, 0.6924661454957028, 0.7948307569031313, 0.20617172664891592, 0.7258222162406788, 0.21051058507166465, 0.18322748589751525, 0.20170151520761148, 0.17967302725195333, 0.18558973757923303, 0.19675780336442883, 0.2114102489492412, 0.18586136593286473, 0.195364097141973, 0.191462151097598, 0.0930725716306382, 0.08879791614684196, 0.08618244185650115, 0.08759544662214669, 0.08523595299592346, 0.08062079180247017, 0.0832396331658134, 0.08085926448336578, 0.08584584380407212]}, "mutation_prompt": null}
{"id": "52d4b150-3994-4e15-900a-d2995957366b", "solution": "import numpy as np\n\nclass ADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Evaluate initial population\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                # Select indices for mutation\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Perform mutation and crossover\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            # Apply local search to best individual periodically if budget allows\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ADELSOptimizer", "description": "Adaptive Differential Evolution with Local Search leveraging population diversity to balance exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ca202daa-2988-4ec0-99d7-bf4be1382089", "metadata": {"aucs": [0.766340889485982, 0.7520529560413111, 0.7560249256795225, 0.7633971263189563, 0.7665504257478769, 0.7787828195303294, 0.7578886937753072, 0.7622219541581322, 0.7574894015178413, 0.5890803386387622, 0.5589462299899586, 0.5686123729703655, 0.5809851650910498, 0.5813112291628394, 0.5556303464343665, 0.5506540989825193, 0.5345762314505946, 0.5355700416059447, 0.12347301282093104, 0.13143424027082784, 0.12105272917689036, 0.10981413589101408, 0.12358971933247798, 0.11691267105509329, 0.1274409310587491, 0.11148910394128175, 0.10364427375977958, 0.10830808935351721, 0.10977393756779164, 0.10562676562937579, 0.11363024334872973, 0.10175389214810782, 0.11345598906123233, 0.11004756963141427, 0.14669218587293142, 0.12219833513461564, 0.9112068164336699, 0.8219435570515549, 0.9293895914409617, 0.8738316990729859, 0.9159468719590579, 0.8900966285407703, 0.9102963721451325, 0.9282499617978527, 0.8643805863403157, 0.4522851478066665, 0.454482671639201, 0.3857347797749431, 0.4571666387690164, 0.4239893458981979, 0.44232393608077214, 0.4185596720903799, 0.44497021191977804, 0.4269189046916396, 0.766159095087064, 0.7322276021795446, 0.7142203583325963, 0.7652338002372329, 0.7692828289856131, 0.8217862579381361, 0.6898235657253902, 0.7993361099922829, 0.7318734614376174, 0.21320352621503535, 0.21929800454928605, 0.26312698664507583, 0.20782845722969168, 0.17077696338486748, 0.41117318876273445, 0.18686376091580692, 0.3211899417016847, 0.2397632953219505, 0.22977401078433213, 0.231067716876854, 0.24374656366802272, 0.20510755454940832, 0.22596159792863235, 0.3129595761489148, 0.19251457823885787, 0.20140221320119966, 0.21307302036608633, 0.3325813501027889, 0.31369774819073815, 0.315151856719483, 0.3435372799037111, 0.3327397558783113, 0.31408717472837555, 0.2980413614633052, 0.3394938361135662, 0.29528802352173456, 0.4473453340728152, 0.4568853079158455, 0.48327015718725586, 0.47759867570894443, 0.41405283806221127, 0.48703259555238076, 0.5209892566095362, 0.532966103109584, 0.5049684258465147, 0.11531797760367934, 0.11874711529431425, 0.14539699004319406, 0.19743195705126793, 0.23167694125613914, 0.13239932722534198, 0.12444584043770246, 0.19415495834834784, 0.10779991956121138, 0.2456724677133374, 0.2741551173337099, 0.27789222549222836, 0.2773466096137339, 0.2928370490585772, 0.3023800897263079, 0.26647185244543437, 0.27984607658351557, 0.2790902292478368, 0.6685109316033233, 0.6934533161633661, 0.6796744804627848, 0.6326908308011954, 0.6984607124310664, 0.6633547315673314, 0.6787336906029864, 0.6710729549453422, 0.6476241965971397, 0.11806016561921717, 0.11902547038801126, 0.12886644809185, 0.11321701389627414, 0.1092609473532784, 0.13365681698278875, 0.1345581762641176, 0.10632377835235785, 0.11980040734915276, 0.15885256226105193, 0.1768717101335434, 0.23146693845121225, 0.19745776560527173, 0.23484083918863075, 0.16312829454267852, 0.24076955342321849, 0.1854369460987415, 0.19293228229821202, 0.3706778456139088, 0.3817385935296913, 0.3837549560989635, 0.4013938786883241, 0.38664685444701696, 0.3795438333805752, 0.40475929739869354, 0.3844231650138672, 0.42381542516033055, 0.3151800533837411, 0.29694917091169326, 0.3114929119020817, 0.3180173948400937, 0.2868460075670397, 0.29853682913591173, 0.2949586652801275, 0.30859240937121535, 0.32608566030087127, 0.18499519255483543, 0.19806939730067075, 0.22441414292597317, 0.24000634836727586, 0.20568375252138726, 0.2319059822943793, 0.2036975894252463, 0.18665749307351287, 0.20453593973591855, 0.19381425350953696, 0.19120186785649973, 0.19658736205732807, 0.1972575571134083, 0.22505245412844577, 0.18995316363029646, 0.21357036907206406, 0.18479067292482365, 0.20303983659553615, 0.184825336533895, 0.7394076005667274, 0.19580166558265988, 0.7030170936353628, 0.7630603484519721, 0.7557264091768919, 0.8075567622457585, 0.6757007969064535, 0.17506707775659247, 0.7350683845247972, 0.5347138368957729, 0.3059608872260151, 0.19530145191134862, 0.6924661454957028, 0.7948307569031313, 0.20617172664891592, 0.7258222162406788, 0.21051058507166465, 0.18322748589751525, 0.20170151520761148, 0.17967302725195333, 0.18558973757923303, 0.19675780336442883, 0.2114102489492412, 0.18586136593286473, 0.195364097141973, 0.191462151097598, 0.0930725716306382, 0.08879791614684196, 0.08618244185650115, 0.08759544662214669, 0.08523595299592346, 0.08062079180247017, 0.0832396331658134, 0.08085926448336578, 0.08584584380407212]}, "mutation_prompt": null}
{"id": "c463a155-b1e9-4459-b8bc-51f9409e730d", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.adaptive_factor = 0.1  # New adaptive factor\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Evaluate initial population\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                # Select indices for mutation\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Perform mutation and crossover\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                # Selection and adaptive adjustment\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.F = min(1.0, self.F + self.adaptive_factor)  # Adjust F\n                else:\n                    new_population[i] = self.population[i]\n                    self.F = max(0.1, self.F - self.adaptive_factor)  # Adjust F\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            # Apply local search to best individual periodically if budget allows\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved the diversity and adaptability of the ADELSOptimizer by introducing adaptive parameter control and selective feedback mechanisms.", "configspace": "", "generation": 9, "fitness": 0.31255096100441465, "feedback": "The algorithm ImprovedADELSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "ca202daa-2988-4ec0-99d7-bf4be1382089", "metadata": {"aucs": [0.8222060354706257, 0.8143635596627732, 0.7978394106598696, 0.817335986949598, 0.8157595820420345, 0.8378794839175167, 0.8130139877128224, 0.8046489387662541, 0.8157908847150036, 0.6332932592286558, 0.614336251754096, 0.6369674904451172, 0.6415153563751672, 0.636134318071413, 0.6448303818222936, 0.664364664593874, 0.6144410256001289, 0.6673342157972294, 0.14355355798001834, 0.16326787382697472, 0.15187121878276433, 0.17114749373502292, 0.6172850642618075, 0.17337588423325778, 0.16275868951962835, 0.4635089371282224, 0.6105086048267181, 0.11278728512085856, 0.16783522661059036, 0.1310291667008796, 0.13554080681458291, 0.17086023332300304, 0.14858885824091428, 0.14900039536616572, 0.1669399535795012, 0.14931473792776595, 0.9239233912270577, 0.8432072783250034, 0.8936477670566838, 0.9080403221270914, 0.8952306735407681, 0.8868836297431091, 0.9184247030755837, 0.8674417600513369, 0.8885391272032312, 0.32889506781261635, 0.3431054353652926, 0.2864650923141253, 0.31934737446184913, 0.39476218712417777, 0.3920448193749414, 0.3320021825812749, 0.30637505857240943, 0.35446838794714663, 0.23902820885740217, 0.3277021028436008, 0.20977987778625884, 0.28040719132147274, 0.8428287414427024, 0.36991354004545873, 0.2173793241144616, 0.22591727803030637, 0.37584794280749534, 0.16799276791965534, 0.16920782115909494, 0.1460606287922126, 0.12454227356741598, 0.13013305035015543, 0.17410064449670104, 0.31775779340533805, 0.1997062696638724, 0.15182438848511082, 0.36122237857664463, 0.1261014280151248, 0.12443349330965192, 0.2074844635869033, 0.24605734613759656, 0.2142085637331722, 0.12260277520422258, 0.23222294186641068, 0.1842832975504689, 9.999999999998899e-05, 0.04002489642562779, 0.005740020540834112, 0.06739972283538631, 0.06120684013735789, 0.00017602676299521836, 0.05460924941280498, 0.07506232135616264, 9.999999999998899e-05, 0.1349441760429838, 0.10389413000682324, 0.10257553780287598, 0.1312439851737951, 0.11382002008543546, 0.07286572030632887, 0.18769112706038926, 0.11673110265045739, 0.23767949751474804, 0.13105608082189812, 0.08286616488033616, 0.13556489582034814, 0.14562158088885457, 0.13332264602512256, 0.17222184760168568, 0.10494466780884903, 0.15367341974138893, 0.10446681308587502, 0.13286839749487567, 0.15526330762710183, 0.18738390918219805, 0.10843239616898115, 0.1509689098802932, 0.3625367152118756, 0.23694591463512493, 0.10141651438632271, 0.08119231653725001, 0.6259162178012864, 0.6168097261616754, 0.5958531979521656, 0.48635030747482344, 0.4594459716358299, 0.5208956930462931, 0.6267485384125608, 0.5800471053641958, 0.434852673941708, 0.1280659828966716, 0.10075357245919336, 0.14898650425159576, 0.15437526138980795, 0.11573573108249946, 0.13508442156739275, 0.1334842906342466, 0.14493452265940776, 0.12693664923600567, 0.21121096662931216, 0.2648109032119541, 0.5753402624601327, 0.27305874285048737, 0.24909727039925222, 0.206574523893721, 0.26204724772315535, 0.3056504528956637, 0.3647766263021609, 0.42404948226595995, 0.39249289098108786, 0.33102509973029404, 0.4593428854235081, 0.28962542714385087, 0.31962051158846894, 0.2543337126766386, 0.37803597881515383, 0.2695822116412059, 0.2419194659866193, 0.18972457299809797, 0.2643952820259279, 0.42365796812047096, 0.23167493529764693, 0.3619218505376387, 0.19971407309087608, 0.2905560259318102, 0.2774343751096292, 0.21604592110478027, 0.19637943733033014, 0.2722228373543183, 0.20638669516969343, 0.1936931916150345, 0.22699328744665215, 0.2166576277386636, 0.2899762579618502, 0.2254532198861896, 0.2165974224335977, 0.20445540998543787, 0.23274430851204875, 0.6621546001273737, 0.20816091832905903, 0.6714839211378147, 0.20590023888965236, 0.21629451868649863, 0.21005575786527075, 0.833705239887785, 0.18867972725081705, 0.18769028234586782, 0.2004338576857776, 0.8520683069367178, 0.8488316101303033, 0.16738672173326707, 0.16993047172208442, 0.6488299554768419, 0.49111233033788915, 0.2113785136852988, 0.12834832107106964, 0.2115684364608743, 0.553518979637365, 0.16556251571060987, 0.36717862171218674, 0.25359485981805574, 0.21157103252048415, 0.19464799444157177, 0.20109445720137442, 0.19836886890252003, 0.18830743214486179, 0.18984359076917934, 0.20843334628711363, 0.18598808109922815, 0.1946953690242189, 0.1996129544896732, 0.13835640740803679, 0.09018009929441073, 0.08183161653675652, 0.10807570375099151, 0.08938765075375499, 0.09772678376479704, 0.11271238364147573, 0.09039436221277575, 0.09196452138602595]}, "mutation_prompt": null}
{"id": "bd876119-1863-4a62-a8fa-959212f8f719", "solution": "import numpy as np\n\nclass ADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Evaluate initial population\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                # Select indices for mutation\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Perform mutation and crossover\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            # Apply local search to best individual periodically if budget allows\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ADELSOptimizer", "description": "Adaptive Differential Evolution with Local Search leveraging population diversity to balance exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ca202daa-2988-4ec0-99d7-bf4be1382089", "metadata": {"aucs": [0.766340889485982, 0.7520529560413111, 0.7560249256795225, 0.7633971263189563, 0.7665504257478769, 0.7787828195303294, 0.7578886937753072, 0.7622219541581322, 0.7574894015178413, 0.5890803386387622, 0.5589462299899586, 0.5686123729703655, 0.5809851650910498, 0.5813112291628394, 0.5556303464343665, 0.5506540989825193, 0.5345762314505946, 0.5355700416059447, 0.12347301282093104, 0.13143424027082784, 0.12105272917689036, 0.10981413589101408, 0.12358971933247798, 0.11691267105509329, 0.1274409310587491, 0.11148910394128175, 0.10364427375977958, 0.10830808935351721, 0.10977393756779164, 0.10562676562937579, 0.11363024334872973, 0.10175389214810782, 0.11345598906123233, 0.11004756963141427, 0.14669218587293142, 0.12219833513461564, 0.9112068164336699, 0.8219435570515549, 0.9293895914409617, 0.8738316990729859, 0.9159468719590579, 0.8900966285407703, 0.9102963721451325, 0.9282499617978527, 0.8643805863403157, 0.4522851478066665, 0.454482671639201, 0.3857347797749431, 0.4571666387690164, 0.4239893458981979, 0.44232393608077214, 0.4185596720903799, 0.44497021191977804, 0.4269189046916396, 0.766159095087064, 0.7322276021795446, 0.7142203583325963, 0.7652338002372329, 0.7692828289856131, 0.8217862579381361, 0.6898235657253902, 0.7993361099922829, 0.7318734614376174, 0.21320352621503535, 0.21929800454928605, 0.26312698664507583, 0.20782845722969168, 0.17077696338486748, 0.41117318876273445, 0.18686376091580692, 0.3211899417016847, 0.2397632953219505, 0.22977401078433213, 0.231067716876854, 0.24374656366802272, 0.20510755454940832, 0.22596159792863235, 0.3129595761489148, 0.19251457823885787, 0.20140221320119966, 0.21307302036608633, 0.3325813501027889, 0.31369774819073815, 0.315151856719483, 0.3435372799037111, 0.3327397558783113, 0.31408717472837555, 0.2980413614633052, 0.3394938361135662, 0.29528802352173456, 0.4473453340728152, 0.4568853079158455, 0.48327015718725586, 0.47759867570894443, 0.41405283806221127, 0.48703259555238076, 0.5209892566095362, 0.532966103109584, 0.5049684258465147, 0.11531797760367934, 0.11874711529431425, 0.14539699004319406, 0.19743195705126793, 0.23167694125613914, 0.13239932722534198, 0.12444584043770246, 0.19415495834834784, 0.10779991956121138, 0.2456724677133374, 0.2741551173337099, 0.27789222549222836, 0.2773466096137339, 0.2928370490585772, 0.3023800897263079, 0.26647185244543437, 0.27984607658351557, 0.2790902292478368, 0.6685109316033233, 0.6934533161633661, 0.6796744804627848, 0.6326908308011954, 0.6984607124310664, 0.6633547315673314, 0.6787336906029864, 0.6710729549453422, 0.6476241965971397, 0.11806016561921717, 0.11902547038801126, 0.12886644809185, 0.11321701389627414, 0.1092609473532784, 0.13365681698278875, 0.1345581762641176, 0.10632377835235785, 0.11980040734915276, 0.15885256226105193, 0.1768717101335434, 0.23146693845121225, 0.19745776560527173, 0.23484083918863075, 0.16312829454267852, 0.24076955342321849, 0.1854369460987415, 0.19293228229821202, 0.3706778456139088, 0.3817385935296913, 0.3837549560989635, 0.4013938786883241, 0.38664685444701696, 0.3795438333805752, 0.40475929739869354, 0.3844231650138672, 0.42381542516033055, 0.3151800533837411, 0.29694917091169326, 0.3114929119020817, 0.3180173948400937, 0.2868460075670397, 0.29853682913591173, 0.2949586652801275, 0.30859240937121535, 0.32608566030087127, 0.18499519255483543, 0.19806939730067075, 0.22441414292597317, 0.24000634836727586, 0.20568375252138726, 0.2319059822943793, 0.2036975894252463, 0.18665749307351287, 0.20453593973591855, 0.19381425350953696, 0.19120186785649973, 0.19658736205732807, 0.1972575571134083, 0.22505245412844577, 0.18995316363029646, 0.21357036907206406, 0.18479067292482365, 0.20303983659553615, 0.184825336533895, 0.7394076005667274, 0.19580166558265988, 0.7030170936353628, 0.7630603484519721, 0.7557264091768919, 0.8075567622457585, 0.6757007969064535, 0.17506707775659247, 0.7350683845247972, 0.5347138368957729, 0.3059608872260151, 0.19530145191134862, 0.6924661454957028, 0.7948307569031313, 0.20617172664891592, 0.7258222162406788, 0.21051058507166465, 0.18322748589751525, 0.20170151520761148, 0.17967302725195333, 0.18558973757923303, 0.19675780336442883, 0.2114102489492412, 0.18586136593286473, 0.195364097141973, 0.191462151097598, 0.0930725716306382, 0.08879791614684196, 0.08618244185650115, 0.08759544662214669, 0.08523595299592346, 0.08062079180247017, 0.0832396331658134, 0.08085926448336578, 0.08584584380407212]}, "mutation_prompt": null}
{"id": "fc0b79fd-f5c3-40cf-ab92-682d4d5aa520", "solution": "import numpy as np\n\nclass ADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Evaluate initial population\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                # Select indices for mutation\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Perform mutation and crossover\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            # Apply local search to best individual periodically if budget allows\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ADELSOptimizer", "description": "Adaptive Differential Evolution with Local Search leveraging population diversity to balance exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ca202daa-2988-4ec0-99d7-bf4be1382089", "metadata": {"aucs": [0.766340889485982, 0.7520529560413111, 0.7560249256795225, 0.7633971263189563, 0.7665504257478769, 0.7787828195303294, 0.7578886937753072, 0.7622219541581322, 0.7574894015178413, 0.5890803386387622, 0.5589462299899586, 0.5686123729703655, 0.5809851650910498, 0.5813112291628394, 0.5556303464343665, 0.5506540989825193, 0.5345762314505946, 0.5355700416059447, 0.12347301282093104, 0.13143424027082784, 0.12105272917689036, 0.10981413589101408, 0.12358971933247798, 0.11691267105509329, 0.1274409310587491, 0.11148910394128175, 0.10364427375977958, 0.10830808935351721, 0.10977393756779164, 0.10562676562937579, 0.11363024334872973, 0.10175389214810782, 0.11345598906123233, 0.11004756963141427, 0.14669218587293142, 0.12219833513461564, 0.9112068164336699, 0.8219435570515549, 0.9293895914409617, 0.8738316990729859, 0.9159468719590579, 0.8900966285407703, 0.9102963721451325, 0.9282499617978527, 0.8643805863403157, 0.4522851478066665, 0.454482671639201, 0.3857347797749431, 0.4571666387690164, 0.4239893458981979, 0.44232393608077214, 0.4185596720903799, 0.44497021191977804, 0.4269189046916396, 0.766159095087064, 0.7322276021795446, 0.7142203583325963, 0.7652338002372329, 0.7692828289856131, 0.8217862579381361, 0.6898235657253902, 0.7993361099922829, 0.7318734614376174, 0.21320352621503535, 0.21929800454928605, 0.26312698664507583, 0.20782845722969168, 0.17077696338486748, 0.41117318876273445, 0.18686376091580692, 0.3211899417016847, 0.2397632953219505, 0.22977401078433213, 0.231067716876854, 0.24374656366802272, 0.20510755454940832, 0.22596159792863235, 0.3129595761489148, 0.19251457823885787, 0.20140221320119966, 0.21307302036608633, 0.3325813501027889, 0.31369774819073815, 0.315151856719483, 0.3435372799037111, 0.3327397558783113, 0.31408717472837555, 0.2980413614633052, 0.3394938361135662, 0.29528802352173456, 0.4473453340728152, 0.4568853079158455, 0.48327015718725586, 0.47759867570894443, 0.41405283806221127, 0.48703259555238076, 0.5209892566095362, 0.532966103109584, 0.5049684258465147, 0.11531797760367934, 0.11874711529431425, 0.14539699004319406, 0.19743195705126793, 0.23167694125613914, 0.13239932722534198, 0.12444584043770246, 0.19415495834834784, 0.10779991956121138, 0.2456724677133374, 0.2741551173337099, 0.27789222549222836, 0.2773466096137339, 0.2928370490585772, 0.3023800897263079, 0.26647185244543437, 0.27984607658351557, 0.2790902292478368, 0.6685109316033233, 0.6934533161633661, 0.6796744804627848, 0.6326908308011954, 0.6984607124310664, 0.6633547315673314, 0.6787336906029864, 0.6710729549453422, 0.6476241965971397, 0.11806016561921717, 0.11902547038801126, 0.12886644809185, 0.11321701389627414, 0.1092609473532784, 0.13365681698278875, 0.1345581762641176, 0.10632377835235785, 0.11980040734915276, 0.15885256226105193, 0.1768717101335434, 0.23146693845121225, 0.19745776560527173, 0.23484083918863075, 0.16312829454267852, 0.24076955342321849, 0.1854369460987415, 0.19293228229821202, 0.3706778456139088, 0.3817385935296913, 0.3837549560989635, 0.4013938786883241, 0.38664685444701696, 0.3795438333805752, 0.40475929739869354, 0.3844231650138672, 0.42381542516033055, 0.3151800533837411, 0.29694917091169326, 0.3114929119020817, 0.3180173948400937, 0.2868460075670397, 0.29853682913591173, 0.2949586652801275, 0.30859240937121535, 0.32608566030087127, 0.18499519255483543, 0.19806939730067075, 0.22441414292597317, 0.24000634836727586, 0.20568375252138726, 0.2319059822943793, 0.2036975894252463, 0.18665749307351287, 0.20453593973591855, 0.19381425350953696, 0.19120186785649973, 0.19658736205732807, 0.1972575571134083, 0.22505245412844577, 0.18995316363029646, 0.21357036907206406, 0.18479067292482365, 0.20303983659553615, 0.184825336533895, 0.7394076005667274, 0.19580166558265988, 0.7030170936353628, 0.7630603484519721, 0.7557264091768919, 0.8075567622457585, 0.6757007969064535, 0.17506707775659247, 0.7350683845247972, 0.5347138368957729, 0.3059608872260151, 0.19530145191134862, 0.6924661454957028, 0.7948307569031313, 0.20617172664891592, 0.7258222162406788, 0.21051058507166465, 0.18322748589751525, 0.20170151520761148, 0.17967302725195333, 0.18558973757923303, 0.19675780336442883, 0.2114102489492412, 0.18586136593286473, 0.195364097141973, 0.191462151097598, 0.0930725716306382, 0.08879791614684196, 0.08618244185650115, 0.08759544662214669, 0.08523595299592346, 0.08062079180247017, 0.0832396331658134, 0.08085926448336578, 0.08584584380407212]}, "mutation_prompt": null}
{"id": "6ac81570-b8b8-4de1-b8ed-8ce60ed28f4b", "solution": "import numpy as np\n\nclass ADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Evaluate initial population\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                # Select indices for mutation\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Perform mutation and crossover\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            # Apply local search to best individual periodically if budget allows\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ADELSOptimizer", "description": "Adaptive Differential Evolution with Local Search leveraging population diversity to balance exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ca202daa-2988-4ec0-99d7-bf4be1382089", "metadata": {"aucs": [0.766340889485982, 0.7520529560413111, 0.7560249256795225, 0.7633971263189563, 0.7665504257478769, 0.7787828195303294, 0.7578886937753072, 0.7622219541581322, 0.7574894015178413, 0.5890803386387622, 0.5589462299899586, 0.5686123729703655, 0.5809851650910498, 0.5813112291628394, 0.5556303464343665, 0.5506540989825193, 0.5345762314505946, 0.5355700416059447, 0.12347301282093104, 0.13143424027082784, 0.12105272917689036, 0.10981413589101408, 0.12358971933247798, 0.11691267105509329, 0.1274409310587491, 0.11148910394128175, 0.10364427375977958, 0.10830808935351721, 0.10977393756779164, 0.10562676562937579, 0.11363024334872973, 0.10175389214810782, 0.11345598906123233, 0.11004756963141427, 0.14669218587293142, 0.12219833513461564, 0.9112068164336699, 0.8219435570515549, 0.9293895914409617, 0.8738316990729859, 0.9159468719590579, 0.8900966285407703, 0.9102963721451325, 0.9282499617978527, 0.8643805863403157, 0.4522851478066665, 0.454482671639201, 0.3857347797749431, 0.4571666387690164, 0.4239893458981979, 0.44232393608077214, 0.4185596720903799, 0.44497021191977804, 0.4269189046916396, 0.766159095087064, 0.7322276021795446, 0.7142203583325963, 0.7652338002372329, 0.7692828289856131, 0.8217862579381361, 0.6898235657253902, 0.7993361099922829, 0.7318734614376174, 0.21320352621503535, 0.21929800454928605, 0.26312698664507583, 0.20782845722969168, 0.17077696338486748, 0.41117318876273445, 0.18686376091580692, 0.3211899417016847, 0.2397632953219505, 0.22977401078433213, 0.231067716876854, 0.24374656366802272, 0.20510755454940832, 0.22596159792863235, 0.3129595761489148, 0.19251457823885787, 0.20140221320119966, 0.21307302036608633, 0.3325813501027889, 0.31369774819073815, 0.315151856719483, 0.3435372799037111, 0.3327397558783113, 0.31408717472837555, 0.2980413614633052, 0.3394938361135662, 0.29528802352173456, 0.4473453340728152, 0.4568853079158455, 0.48327015718725586, 0.47759867570894443, 0.41405283806221127, 0.48703259555238076, 0.5209892566095362, 0.532966103109584, 0.5049684258465147, 0.11531797760367934, 0.11874711529431425, 0.14539699004319406, 0.19743195705126793, 0.23167694125613914, 0.13239932722534198, 0.12444584043770246, 0.19415495834834784, 0.10779991956121138, 0.2456724677133374, 0.2741551173337099, 0.27789222549222836, 0.2773466096137339, 0.2928370490585772, 0.3023800897263079, 0.26647185244543437, 0.27984607658351557, 0.2790902292478368, 0.6685109316033233, 0.6934533161633661, 0.6796744804627848, 0.6326908308011954, 0.6984607124310664, 0.6633547315673314, 0.6787336906029864, 0.6710729549453422, 0.6476241965971397, 0.11806016561921717, 0.11902547038801126, 0.12886644809185, 0.11321701389627414, 0.1092609473532784, 0.13365681698278875, 0.1345581762641176, 0.10632377835235785, 0.11980040734915276, 0.15885256226105193, 0.1768717101335434, 0.23146693845121225, 0.19745776560527173, 0.23484083918863075, 0.16312829454267852, 0.24076955342321849, 0.1854369460987415, 0.19293228229821202, 0.3706778456139088, 0.3817385935296913, 0.3837549560989635, 0.4013938786883241, 0.38664685444701696, 0.3795438333805752, 0.40475929739869354, 0.3844231650138672, 0.42381542516033055, 0.3151800533837411, 0.29694917091169326, 0.3114929119020817, 0.3180173948400937, 0.2868460075670397, 0.29853682913591173, 0.2949586652801275, 0.30859240937121535, 0.32608566030087127, 0.18499519255483543, 0.19806939730067075, 0.22441414292597317, 0.24000634836727586, 0.20568375252138726, 0.2319059822943793, 0.2036975894252463, 0.18665749307351287, 0.20453593973591855, 0.19381425350953696, 0.19120186785649973, 0.19658736205732807, 0.1972575571134083, 0.22505245412844577, 0.18995316363029646, 0.21357036907206406, 0.18479067292482365, 0.20303983659553615, 0.184825336533895, 0.7394076005667274, 0.19580166558265988, 0.7030170936353628, 0.7630603484519721, 0.7557264091768919, 0.8075567622457585, 0.6757007969064535, 0.17506707775659247, 0.7350683845247972, 0.5347138368957729, 0.3059608872260151, 0.19530145191134862, 0.6924661454957028, 0.7948307569031313, 0.20617172664891592, 0.7258222162406788, 0.21051058507166465, 0.18322748589751525, 0.20170151520761148, 0.17967302725195333, 0.18558973757923303, 0.19675780336442883, 0.2114102489492412, 0.18586136593286473, 0.195364097141973, 0.191462151097598, 0.0930725716306382, 0.08879791614684196, 0.08618244185650115, 0.08759544662214669, 0.08523595299592346, 0.08062079180247017, 0.0832396331658134, 0.08085926448336578, 0.08584584380407212]}, "mutation_prompt": null}
{"id": "112ca026-56f7-4ad3-ba92-8de319ae88bc", "solution": "import numpy as np\n\nclass ADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        # Evaluate initial population\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                # Select indices for mutation\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Perform mutation and crossover\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True  # Track improvement\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            # Dynamic Adaptation of Local Search Intensity\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n\n            # Apply local search to best individual periodically if budget allows\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ADELSOptimizer", "description": "Enhanced Adaptive Differential Evolution with Dynamic Local Search Intensity to boost convergence and adaptability.", "configspace": "", "generation": 13, "fitness": 0.3738191954948486, "feedback": "The algorithm ADELSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.24.", "error": "", "parent_id": "ca202daa-2988-4ec0-99d7-bf4be1382089", "metadata": {"aucs": [0.7792001086224225, 0.7513230358085143, 0.7706376971007186, 0.7665385438993475, 0.7757740257406791, 0.7680611353326741, 0.7754818832415746, 0.7808641960733638, 0.7834928795909286, 0.6036050012564385, 0.5834472956777756, 0.5732235041419516, 0.5809198952387966, 0.6238144491739585, 0.5715567403833136, 0.6047388281449301, 0.5940375477601878, 0.6029653305501617, 0.13060061219158703, 0.1331604135633172, 0.12563521321825377, 0.11962907242844889, 0.12209905819162437, 0.1041564776491497, 0.11193715488981071, 0.09900001934072711, 0.13864491867010742, 0.10511178440422753, 0.1196083057689511, 0.10384476612656723, 0.11028540335169967, 0.10707358909644771, 0.11792064856368889, 0.09294224918377403, 0.1005767977957035, 0.12418550965005903, 0.8838737208325241, 0.9119108816953605, 0.8415053521395808, 0.8717831940206152, 0.8975827426197159, 0.8565011511909489, 0.9069283696404941, 0.873259360827166, 0.8051334150766583, 0.3937050890993089, 0.44719101122148486, 0.4094428356772859, 0.435547515778019, 0.4175245806618936, 0.4254167060636467, 0.41304303887652905, 0.4802957448565165, 0.4285727716951121, 0.7281150529497491, 0.6941893185018543, 0.7657525316416878, 0.7970435015481473, 0.7798600704182534, 0.7588741116172091, 0.7543375456747536, 0.7874893786631498, 0.7469567338686431, 0.17108754345684885, 0.21829957532955224, 0.46914789865593753, 0.16330037331337777, 0.27831332171757284, 0.18576102539349093, 0.2838558661829108, 0.27834891888776625, 0.16649500372886683, 0.24002054420531171, 0.2912308799907989, 0.17815911613305302, 0.24375063963468935, 0.172422727593884, 0.30221767106561337, 0.25410578622127955, 0.2304616537223647, 0.3365899298163224, 0.3623628161698571, 0.34530779733822314, 0.35945909506500695, 0.3855083809142785, 0.35253281556900185, 0.3540830874247557, 0.35194644820167076, 0.3717405198999121, 0.3451486404271269, 0.49562819573656447, 0.4989418359530692, 0.5468228930780434, 0.5001375103785386, 0.44305574968860884, 0.5129947402983506, 0.5286388314595083, 0.5408146910833018, 0.511331878809594, 0.12852393658457273, 0.1387153029573468, 0.1197890457200188, 0.19496004658946875, 0.2555042355098399, 0.20730568348346767, 0.18805434804871113, 0.11490100474629361, 0.14716082552945886, 0.2837730859763774, 0.2946977475906406, 0.2936540001609703, 0.3131330724954383, 0.2973086771205964, 0.3009391901568026, 0.29364189584600187, 0.28583190704925754, 0.27717919506735067, 0.6834027604857797, 0.6956696184912128, 0.6476393882923912, 0.670088853492478, 0.6510501925230625, 0.6685467761288959, 0.6803748675087701, 0.6421125779458643, 0.6647395504646209, 0.1063455448513716, 0.1128332329870585, 0.11047174340339738, 0.13463540420788267, 0.11451260747456404, 0.12824682183707936, 0.12303303258140719, 0.11266818325204275, 0.10310498491581599, 0.2111864262276606, 0.16911456755388754, 0.17354591124489693, 0.22004320405388256, 0.22126239170175754, 0.20559248077756453, 0.18555528507936403, 0.1967538346749509, 0.1917421699116295, 0.379344551665041, 0.3966998326069544, 0.4061863181452472, 0.39369576546365226, 0.38342994032767586, 0.3943649180343659, 0.4036227209623118, 0.4226805543427731, 0.4101909197040109, 0.3124293622963301, 0.3243627139478499, 0.30867786985969603, 0.28097269234128297, 0.282008223939893, 0.2997357398485563, 0.3269522982879586, 0.30935284164186627, 0.32092683011319734, 0.2510217901639322, 0.19082371426952727, 0.2074118599063366, 0.18330535883186772, 0.1979237939359051, 0.19917395779588554, 0.20175672017001867, 0.2238820687989752, 0.18127033480002053, 0.21607551183058316, 0.20866947987252393, 0.2183628778171638, 0.24397265394460532, 0.2440762638058751, 0.24197201918205458, 0.19786944086893077, 0.24051183924406971, 0.2730729417102632, 0.16634430470666117, 0.6673304553723356, 0.699989266232637, 0.6731425297565159, 0.6588061083384216, 0.7173268005988713, 0.6721761719754413, 0.6548807111255253, 0.6225890755166685, 0.6414913050915643, 0.2083617787275136, 0.6977085993216171, 0.47348217697238426, 0.15995841966848567, 0.7235845183186234, 0.7136437328527038, 0.5139832333804534, 0.20886840940460993, 0.1952650582045765, 0.21218586833755837, 0.183783144333326, 0.17855554064335588, 0.1919018233987212, 0.1839615192286851, 0.20333085586040445, 0.19116845630278667, 0.18232364569631854, 0.08407335819875095, 0.07895802175913724, 0.10034249041186483, 0.08579983370583433, 0.08536263240371644, 0.0819349909828696, 0.0889874259722142, 0.08098683741458679, 0.08827057226921009]}, "mutation_prompt": null}
{"id": "74172578-d508-4916-ba71-88b8836d06a1", "solution": "import numpy as np\n\nclass ADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        # Evaluate initial population\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                # Select indices for mutation\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Perform mutation and crossover\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True  # Track improvement\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            # Population size adaptation\n            if evaluations > self.budget * 0.5:\n                self.pop_size = max(10, self.pop_size // 2)\n                self.population = self.population[:self.pop_size]\n                self.fitness = self.fitness[:self.pop_size]\n\n            # Dynamic Adaptation of Local Search Intensity\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n\n            # Apply local search to best individual progressively\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ADELSOptimizer", "description": "Advanced Adaptive Differential Evolution with Adaptive Population and Progressive Local Search for Enhanced Convergence.", "configspace": "", "generation": 14, "fitness": 0.3606513588624613, "feedback": "The algorithm ADELSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.23.", "error": "", "parent_id": "112ca026-56f7-4ad3-ba92-8de319ae88bc", "metadata": {"aucs": [0.7792001086224225, 0.7524652999276915, 0.7706376971007186, 0.7664109305621885, 0.7757740257406791, 0.7681639157606998, 0.7754002120449923, 0.7808866230418481, 0.7834928795909286, 0.5469454632714926, 0.5779502592530124, 0.6046436221346083, 0.6076884410689802, 0.6393263591281824, 0.5946780380967465, 0.5049558134223182, 0.5452740084899029, 0.5759352205464459, 0.14558738296030316, 0.14219953108325956, 0.15682546328051117, 0.13063715446742008, 0.12209905819162437, 0.13127296810586608, 0.13172666128281363, 0.1042701267794629, 0.1174809634064593, 0.11097507860693845, 0.12790662318161117, 0.11247108844768605, 0.10744998610225664, 0.11051653911263914, 0.106310171097043, 0.10099827335379707, 0.11582328408589004, 0.1231058142009992, 0.8838737208325241, 0.9119108816953605, 0.8415053521395808, 0.8717831940206152, 0.8975827426197159, 0.8565011511909489, 0.9069283696404941, 0.873259360827166, 0.8051334150766583, 0.2963371118998529, 0.39423299929159095, 0.32303407998567135, 0.3759820424922098, 0.37539263384981525, 0.3668707696535046, 0.3365822671546005, 0.3848830254534328, 0.3650154247984452, 0.7281150529497491, 0.6941893185018543, 0.7657525316416878, 0.7970435015481473, 0.7798600704182534, 0.7588741116172091, 0.7543375456747536, 0.7874893786631498, 0.7469567338686431, 0.17108103159825483, 0.20788284280344593, 0.32714402328958603, 0.16497089228687, 0.24054526594831105, 0.17371671155831214, 0.2269214387112708, 0.22984332639676897, 0.16401130890461768, 0.22567152634972654, 0.2715824920487806, 0.17464005588153775, 0.20806003585100308, 0.1685797467297041, 0.23790135770003795, 0.2353703623695922, 0.21355041823630028, 0.270297525173407, 0.32096574296913327, 0.27929875770922663, 0.37288626589638274, 0.31246760125574524, 0.29796731947921484, 0.25966377997778034, 0.28944605462208417, 0.2551195571537419, 0.24722341969618988, 0.455169577109203, 0.43168707765647296, 0.4813685543880639, 0.41738904129902077, 0.3569334658163542, 0.4120752282603738, 0.44641234142216446, 0.46286873549700547, 0.45846943001842655, 0.13524764834813485, 0.13462908350648717, 0.10901866315938535, 0.12132941210118675, 0.20910253811673263, 0.15791724750112357, 0.1495362553355024, 0.11748724700180979, 0.12859764906974092, 0.23708430137174696, 0.31324085380854694, 0.2931459868910048, 0.29147689080187933, 0.2745481103211297, 0.2771900393196429, 0.25888361222480705, 0.295600573053279, 0.2606525871369677, 0.6417505228099798, 0.6216130775149429, 0.616503784760555, 0.590197017564986, 0.5622827705605457, 0.6067908307502783, 0.6599666606860891, 0.5992664983840941, 0.6215609199231191, 0.10802803104258984, 0.12153412192868907, 0.11902150672018763, 0.21704800260384105, 0.11073635837028417, 0.13683214751304607, 0.11859427386160348, 0.12840948913846173, 0.11982668722877388, 0.20400508870667267, 0.18284794314210462, 0.1873642294645339, 0.22126020859662, 0.21868195910993238, 0.2146610264589155, 0.18896516086605075, 0.21133274602692131, 0.24460468448766282, 0.4058738936019507, 0.3999976754670771, 0.37987212368926426, 0.4318217475062137, 0.39044931173250874, 0.42433253158149675, 0.3600384816019704, 0.4429173829749026, 0.4382685222301088, 0.2916467576930998, 0.3146973299806015, 0.286240957389578, 0.2912980597253636, 0.39070382628091094, 0.30898768683560907, 0.33971997316004154, 0.34685369972369484, 0.36941181177963645, 0.2510217901639322, 0.20768807719779392, 0.2074118599063366, 0.18226103553753947, 0.2111913339309569, 0.21571762129402006, 0.20271824878228517, 0.21424190967439716, 0.1859610889022666, 0.2624423485409332, 0.22327995688864233, 0.2217111105344034, 0.2731866364166271, 0.23356639921648226, 0.20519925008907947, 0.3644732901969411, 0.22046731007277598, 0.21302402237596585, 0.16634438727344802, 0.6691393917396209, 0.699989266232637, 0.6759181357460899, 0.664386073011251, 0.7174191704362307, 0.6744476502562654, 0.660421075695492, 0.6003047731177831, 0.6550831085820277, 0.20836179018618473, 0.7039901441390797, 0.35220920454839744, 0.15995841924052034, 0.7219634893973261, 0.7154497348338391, 0.4033026668222741, 0.208868409415907, 0.2006342905428532, 0.21218586833755837, 0.18014060723549397, 0.18760396590513384, 0.19559914062354733, 0.1808280607346443, 0.1987801519633996, 0.19116845630278667, 0.17853048008435002, 0.08762017797356803, 0.0793217035545627, 0.10034249041186483, 0.08579983370583433, 0.08642453180390297, 0.08566926199004887, 0.08445766281300626, 0.07716687890368357, 0.0876993656448618]}, "mutation_prompt": null}
{"id": "da96143c-23c4-4ad4-b0ac-0e5a7b3edcc9", "solution": "import numpy as np\n\nclass ADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        # Evaluate initial population\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                # Select indices for mutation\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Perform mutation and crossover\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True  # Track improvement\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            # Dynamic Adaptation of Local Search Intensity\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n\n            # Apply local search to best individual periodically if budget allows\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ADELSOptimizer", "description": "Enhanced Adaptive Differential Evolution with Dynamic Local Search Intensity to boost convergence and adaptability.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "112ca026-56f7-4ad3-ba92-8de319ae88bc", "metadata": {"aucs": [0.7792001086224225, 0.7513230358085143, 0.7706376971007186, 0.7665385438993475, 0.7757740257406791, 0.7680611353326741, 0.7754818832415746, 0.7808641960733638, 0.7834928795909286, 0.6036050012564385, 0.5834472956777756, 0.5732235041419516, 0.5809198952387966, 0.6238144491739585, 0.5715567403833136, 0.6047388281449301, 0.5940375477601878, 0.6029653305501617, 0.13060061219158703, 0.1331604135633172, 0.12563521321825377, 0.11962907242844889, 0.12209905819162437, 0.1041564776491497, 0.11193715488981071, 0.09900001934072711, 0.13864491867010742, 0.10511178440422753, 0.1196083057689511, 0.10384476612656723, 0.11028540335169967, 0.10707358909644771, 0.11792064856368889, 0.09294224918377403, 0.1005767977957035, 0.12418550965005903, 0.8838737208325241, 0.9119108816953605, 0.8415053521395808, 0.8717831940206152, 0.8975827426197159, 0.8565011511909489, 0.9069283696404941, 0.873259360827166, 0.8051334150766583, 0.3937050890993089, 0.44719101122148486, 0.4094428356772859, 0.435547515778019, 0.4175245806618936, 0.4254167060636467, 0.41304303887652905, 0.4802957448565165, 0.4285727716951121, 0.7281150529497491, 0.6941893185018543, 0.7657525316416878, 0.7970435015481473, 0.7798600704182534, 0.7588741116172091, 0.7543375456747536, 0.7874893786631498, 0.7469567338686431, 0.17108754345684885, 0.21829957532955224, 0.46914789865593753, 0.16330037331337777, 0.27831332171757284, 0.18576102539349093, 0.2838558661829108, 0.27834891888776625, 0.16649500372886683, 0.24002054420531171, 0.2912308799907989, 0.17815911613305302, 0.24375063963468935, 0.172422727593884, 0.30221767106561337, 0.25410578622127955, 0.2304616537223647, 0.3365899298163224, 0.3623628161698571, 0.34530779733822314, 0.35945909506500695, 0.3855083809142785, 0.35253281556900185, 0.3540830874247557, 0.35194644820167076, 0.3717405198999121, 0.3451486404271269, 0.49562819573656447, 0.4989418359530692, 0.5468228930780434, 0.5001375103785386, 0.44305574968860884, 0.5129947402983506, 0.5286388314595083, 0.5408146910833018, 0.511331878809594, 0.12852393658457273, 0.1387153029573468, 0.1197890457200188, 0.19496004658946875, 0.2555042355098399, 0.20730568348346767, 0.18805434804871113, 0.11490100474629361, 0.14716082552945886, 0.2837730859763774, 0.2946977475906406, 0.2936540001609703, 0.3131330724954383, 0.2973086771205964, 0.3009391901568026, 0.29364189584600187, 0.28583190704925754, 0.27717919506735067, 0.6834027604857797, 0.6956696184912128, 0.6476393882923912, 0.670088853492478, 0.6510501925230625, 0.6685467761288959, 0.6803748675087701, 0.6421125779458643, 0.6647395504646209, 0.1063455448513716, 0.1128332329870585, 0.11047174340339738, 0.13463540420788267, 0.11451260747456404, 0.12824682183707936, 0.12303303258140719, 0.11266818325204275, 0.10310498491581599, 0.2111864262276606, 0.16911456755388754, 0.17354591124489693, 0.22004320405388256, 0.22126239170175754, 0.20559248077756453, 0.18555528507936403, 0.1967538346749509, 0.1917421699116295, 0.379344551665041, 0.3966998326069544, 0.4061863181452472, 0.39369576546365226, 0.38342994032767586, 0.3943649180343659, 0.4036227209623118, 0.4226805543427731, 0.4101909197040109, 0.3124293622963301, 0.3243627139478499, 0.30867786985969603, 0.28097269234128297, 0.282008223939893, 0.2997357398485563, 0.3269522982879586, 0.30935284164186627, 0.32092683011319734, 0.2510217901639322, 0.19082371426952727, 0.2074118599063366, 0.18330535883186772, 0.1979237939359051, 0.19917395779588554, 0.20175672017001867, 0.2238820687989752, 0.18127033480002053, 0.21607551183058316, 0.20866947987252393, 0.2183628778171638, 0.24397265394460532, 0.2440762638058751, 0.24197201918205458, 0.19786944086893077, 0.24051183924406971, 0.2730729417102632, 0.16634430470666117, 0.6673304553723356, 0.699989266232637, 0.6731425297565159, 0.6588061083384216, 0.7173268005988713, 0.6721761719754413, 0.6548807111255253, 0.6225890755166685, 0.6414913050915643, 0.2083617787275136, 0.6977085993216171, 0.47348217697238426, 0.15995841966848567, 0.7235845183186234, 0.7136437328527038, 0.5139832333804534, 0.20886840940460993, 0.1952650582045765, 0.21218586833755837, 0.183783144333326, 0.17855554064335588, 0.1919018233987212, 0.1839615192286851, 0.20333085586040445, 0.19116845630278667, 0.18232364569631854, 0.08407335819875095, 0.07895802175913724, 0.10034249041186483, 0.08579983370583433, 0.08536263240371644, 0.0819349909828696, 0.0889874259722142, 0.08098683741458679, 0.08827057226921009]}, "mutation_prompt": null}
{"id": "71b42e0f-13a8-48cc-ab5d-824060b77e42", "solution": "import numpy as np\n\nclass ADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        # Evaluate initial population\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                # Self-adaptive control parameters\n                self.F = np.random.uniform(0.4, 0.9)\n                self.CR = np.random.uniform(0.7, 1.0)\n\n                # Select indices for mutation\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Perform mutation and crossover\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True  # Track improvement\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            # Dynamic Adaptation of Local Search Intensity\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n\n            # Apply local search to best individual periodically if budget allows\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ADELSOptimizer", "description": "Enhanced Differential Evolution with Self-Adaptive Mutation and Crossover Strategies for Robust Optimization.", "configspace": "", "generation": 16, "fitness": 0.30694191513224894, "feedback": "The algorithm ADELSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.22.", "error": "", "parent_id": "112ca026-56f7-4ad3-ba92-8de319ae88bc", "metadata": {"aucs": [0.7171019329935043, 0.7135341278554261, 0.6909860767072399, 0.7221457184330847, 0.728484026462946, 0.7189547389439246, 0.7102470105275229, 0.7355795570290894, 0.7190635519365924, 0.49525316728453783, 0.48928861975449767, 0.49897111583102527, 0.5046350197500109, 0.48644351044965217, 0.4926053590548445, 0.4667764801162926, 0.49490735640158234, 0.5039169738410922, 0.11632126377294316, 0.11110929867642572, 0.11088219146018896, 0.12834190515311716, 0.11697505042750433, 0.11377157962007989, 0.11958998473469162, 0.12121039031266356, 0.10771219978805424, 0.099125969907919, 0.11052060402700992, 0.10924829536028324, 0.10373512857301981, 0.11076062278389931, 0.1182838028296248, 0.10533811794999581, 0.10428948488668643, 0.10098830188711783, 0.9666544397296049, 0.9201204181921211, 0.9401010123977809, 0.934715555491187, 0.9122096552064396, 0.913838759137449, 0.9420376003386625, 0.9618717841652615, 0.961275929749019, 0.3601590547005302, 0.3505084252050288, 0.36963064894799313, 0.3224869049074658, 0.337202514247506, 0.3717212889107985, 0.37094535627426983, 0.3565660449931707, 0.3598064253823774, 0.6182736077224591, 0.6680030971680533, 0.6290407795226041, 0.6591591127120615, 0.7007608788701845, 0.6685467464305319, 0.6188020252495985, 0.6400645930264659, 0.7035340125043199, 0.2729044273657547, 0.2031677835992245, 0.17497654547371289, 0.182596394667205, 0.19774589664810716, 0.2550646684781914, 0.28458565044641104, 0.21621271913825457, 0.24227831931422528, 0.2627671945528496, 0.11997947192719571, 0.22225981058392685, 0.2394401075586593, 0.2148574049129094, 0.2624388198283958, 0.2326527747714554, 0.23108687594793187, 0.2639200923325795, 0.20014120785716094, 0.1967872952182358, 0.14933364163802476, 0.1857992063497137, 0.19617018422689647, 0.16560904826788592, 0.21437160690124923, 0.18815105777839192, 0.17746962599727245, 0.3624849757034315, 0.30880317722527284, 0.31034702642661693, 0.3319707180574334, 0.3239449367779682, 0.30561064773954905, 0.35238618252406384, 0.3494944443475604, 0.34156620358319534, 0.0472671710138427, 0.06927905597546347, 0.06612204386744247, 0.09897277342524646, 0.05630287041570681, 0.08824273144189443, 0.06350254754891771, 0.07407279798587318, 0.08843861100799788, 0.18920211975552703, 0.17954528789104862, 0.1690876452347253, 0.20298963645322077, 0.19670552330485291, 0.2175923051619797, 0.19565345987787364, 0.2008711860137672, 0.1973555889535119, 0.5315509229143569, 0.567428830235418, 0.5796567807753799, 0.5743624451333968, 0.5646819871431876, 0.5452119950970019, 0.5606727782139196, 0.5580274913139617, 0.5540909436773691, 0.1223073157484138, 0.10328180972568513, 0.09431207870777525, 0.11590342320490687, 0.10065393724086757, 0.10152127646832121, 0.0962630575637482, 0.0951307816704009, 0.1062898816865161, 0.17527818686850605, 0.19198275917898744, 0.16208632781964827, 0.1716273808563561, 0.19135867176904953, 0.15478403481907876, 0.22205686004315417, 0.23237916147617632, 0.16461534947388756, 0.3065362420788239, 0.3281941860143054, 0.33399497117185484, 0.30810031716928843, 0.3233313360458061, 0.3243654373829129, 0.31537259906538084, 0.3615048097183603, 0.34943813736884743, 0.2494192308653781, 0.23443174605846018, 0.2288342461437336, 0.2260936282043865, 0.24062262270706591, 0.23461728487296363, 0.24387716716250218, 0.25603349297122824, 0.2519871177149098, 0.18223990951585534, 0.19494791248220467, 0.20081675553661504, 0.19613239692527273, 0.19389162102406388, 0.17676863292032796, 0.1857470700555064, 0.1923794214313379, 0.18114551304926296, 0.20149152380132418, 0.19277747109117838, 0.2127016577148536, 0.2104364083975757, 0.1971490545267871, 0.197490150557459, 0.1944566168187558, 0.20476860276544862, 0.21111057377021547, 0.6211458812912765, 0.18604138760511846, 0.19228845514582482, 0.17832566379190595, 0.4420222421654304, 0.18299175402970058, 0.4452863479472735, 0.25408199771676687, 0.5466059153616057, 0.4635336527339122, 0.1659739295842112, 0.5427222883697689, 0.38387168901852964, 0.41680334839316124, 0.4077188769894933, 0.20437638875688435, 0.20388577233665017, 0.20646458519739475, 0.1909414135933628, 0.20600230639017714, 0.18336070301191365, 0.1840878551887335, 0.192879853136823, 0.1771200539053821, 0.18300597576126054, 0.19029111497459783, 0.1801968600427648, 0.08215705242095206, 0.07753237586009232, 0.07081200867826176, 0.0698550745100629, 0.07633209212888581, 0.08352608171985298, 0.07831651455614341, 0.06913484860618935, 0.08332426751685507]}, "mutation_prompt": null}
{"id": "a0ba64f6-1f93-4ecd-82e8-a820b594bac4", "solution": "import numpy as np\n\nclass ADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        # Evaluate initial population\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                # Select indices for mutation\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Perform mutation and crossover\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True  # Track improvement\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            # Dynamic Adaptation of Local Search Intensity\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n\n            # Apply local search to best individual periodically if budget allows\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ADELSOptimizer", "description": "Enhanced Adaptive Differential Evolution with Dynamic Local Search Intensity to boost convergence and adaptability.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "112ca026-56f7-4ad3-ba92-8de319ae88bc", "metadata": {"aucs": [0.7792001086224225, 0.7513230358085143, 0.7706376971007186, 0.7665385438993475, 0.7757740257406791, 0.7680611353326741, 0.7754818832415746, 0.7808641960733638, 0.7834928795909286, 0.6036050012564385, 0.5834472956777756, 0.5732235041419516, 0.5809198952387966, 0.6238144491739585, 0.5715567403833136, 0.6047388281449301, 0.5940375477601878, 0.6029653305501617, 0.13060061219158703, 0.1331604135633172, 0.12563521321825377, 0.11962907242844889, 0.12209905819162437, 0.1041564776491497, 0.11193715488981071, 0.09900001934072711, 0.13864491867010742, 0.10511178440422753, 0.1196083057689511, 0.10384476612656723, 0.11028540335169967, 0.10707358909644771, 0.11792064856368889, 0.09294224918377403, 0.1005767977957035, 0.12418550965005903, 0.8838737208325241, 0.9119108816953605, 0.8415053521395808, 0.8717831940206152, 0.8975827426197159, 0.8565011511909489, 0.9069283696404941, 0.873259360827166, 0.8051334150766583, 0.3937050890993089, 0.44719101122148486, 0.4094428356772859, 0.435547515778019, 0.4175245806618936, 0.4254167060636467, 0.41304303887652905, 0.4802957448565165, 0.4285727716951121, 0.7281150529497491, 0.6941893185018543, 0.7657525316416878, 0.7970435015481473, 0.7798600704182534, 0.7588741116172091, 0.7543375456747536, 0.7874893786631498, 0.7469567338686431, 0.17108754345684885, 0.21829957532955224, 0.46914789865593753, 0.16330037331337777, 0.27831332171757284, 0.18576102539349093, 0.2838558661829108, 0.27834891888776625, 0.16649500372886683, 0.24002054420531171, 0.2912308799907989, 0.17815911613305302, 0.24375063963468935, 0.172422727593884, 0.30221767106561337, 0.25410578622127955, 0.2304616537223647, 0.3365899298163224, 0.3623628161698571, 0.34530779733822314, 0.35945909506500695, 0.3855083809142785, 0.35253281556900185, 0.3540830874247557, 0.35194644820167076, 0.3717405198999121, 0.3451486404271269, 0.49562819573656447, 0.4989418359530692, 0.5468228930780434, 0.5001375103785386, 0.44305574968860884, 0.5129947402983506, 0.5286388314595083, 0.5408146910833018, 0.511331878809594, 0.12852393658457273, 0.1387153029573468, 0.1197890457200188, 0.19496004658946875, 0.2555042355098399, 0.20730568348346767, 0.18805434804871113, 0.11490100474629361, 0.14716082552945886, 0.2837730859763774, 0.2946977475906406, 0.2936540001609703, 0.3131330724954383, 0.2973086771205964, 0.3009391901568026, 0.29364189584600187, 0.28583190704925754, 0.27717919506735067, 0.6834027604857797, 0.6956696184912128, 0.6476393882923912, 0.670088853492478, 0.6510501925230625, 0.6685467761288959, 0.6803748675087701, 0.6421125779458643, 0.6647395504646209, 0.1063455448513716, 0.1128332329870585, 0.11047174340339738, 0.13463540420788267, 0.11451260747456404, 0.12824682183707936, 0.12303303258140719, 0.11266818325204275, 0.10310498491581599, 0.2111864262276606, 0.16911456755388754, 0.17354591124489693, 0.22004320405388256, 0.22126239170175754, 0.20559248077756453, 0.18555528507936403, 0.1967538346749509, 0.1917421699116295, 0.379344551665041, 0.3966998326069544, 0.4061863181452472, 0.39369576546365226, 0.38342994032767586, 0.3943649180343659, 0.4036227209623118, 0.4226805543427731, 0.4101909197040109, 0.3124293622963301, 0.3243627139478499, 0.30867786985969603, 0.28097269234128297, 0.282008223939893, 0.2997357398485563, 0.3269522982879586, 0.30935284164186627, 0.32092683011319734, 0.2510217901639322, 0.19082371426952727, 0.2074118599063366, 0.18330535883186772, 0.1979237939359051, 0.19917395779588554, 0.20175672017001867, 0.2238820687989752, 0.18127033480002053, 0.21607551183058316, 0.20866947987252393, 0.2183628778171638, 0.24397265394460532, 0.2440762638058751, 0.24197201918205458, 0.19786944086893077, 0.24051183924406971, 0.2730729417102632, 0.16634430470666117, 0.6673304553723356, 0.699989266232637, 0.6731425297565159, 0.6588061083384216, 0.7173268005988713, 0.6721761719754413, 0.6548807111255253, 0.6225890755166685, 0.6414913050915643, 0.2083617787275136, 0.6977085993216171, 0.47348217697238426, 0.15995841966848567, 0.7235845183186234, 0.7136437328527038, 0.5139832333804534, 0.20886840940460993, 0.1952650582045765, 0.21218586833755837, 0.183783144333326, 0.17855554064335588, 0.1919018233987212, 0.1839615192286851, 0.20333085586040445, 0.19116845630278667, 0.18232364569631854, 0.08407335819875095, 0.07895802175913724, 0.10034249041186483, 0.08579983370583433, 0.08536263240371644, 0.0819349909828696, 0.0889874259722142, 0.08098683741458679, 0.08827057226921009]}, "mutation_prompt": null}
{"id": "1a298366-28e0-4789-86d3-cc5e7c9331c8", "solution": "import numpy as np\n\nclass ADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        # Evaluate initial population\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                # Select indices for mutation\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Perform mutation and crossover\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True  # Track improvement\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            # Dynamic Adaptation of Local Search Intensity\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n\n            # Apply local search to best individual periodically if budget allows\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ADELSOptimizer", "description": "Enhanced Adaptive Differential Evolution with Dynamic Local Search Intensity to boost convergence and adaptability.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "112ca026-56f7-4ad3-ba92-8de319ae88bc", "metadata": {"aucs": [0.7792001086224225, 0.7513230358085143, 0.7706376971007186, 0.7665385438993475, 0.7757740257406791, 0.7680611353326741, 0.7754818832415746, 0.7808641960733638, 0.7834928795909286, 0.6036050012564385, 0.5834472956777756, 0.5732235041419516, 0.5809198952387966, 0.6238144491739585, 0.5715567403833136, 0.6047388281449301, 0.5940375477601878, 0.6029653305501617, 0.13060061219158703, 0.1331604135633172, 0.12563521321825377, 0.11962907242844889, 0.12209905819162437, 0.1041564776491497, 0.11193715488981071, 0.09900001934072711, 0.13864491867010742, 0.10511178440422753, 0.1196083057689511, 0.10384476612656723, 0.11028540335169967, 0.10707358909644771, 0.11792064856368889, 0.09294224918377403, 0.1005767977957035, 0.12418550965005903, 0.8838737208325241, 0.9119108816953605, 0.8415053521395808, 0.8717831940206152, 0.8975827426197159, 0.8565011511909489, 0.9069283696404941, 0.873259360827166, 0.8051334150766583, 0.3937050890993089, 0.44719101122148486, 0.4094428356772859, 0.435547515778019, 0.4175245806618936, 0.4254167060636467, 0.41304303887652905, 0.4802957448565165, 0.4285727716951121, 0.7281150529497491, 0.6941893185018543, 0.7657525316416878, 0.7970435015481473, 0.7798600704182534, 0.7588741116172091, 0.7543375456747536, 0.7874893786631498, 0.7469567338686431, 0.17108754345684885, 0.21829957532955224, 0.46914789865593753, 0.16330037331337777, 0.27831332171757284, 0.18576102539349093, 0.2838558661829108, 0.27834891888776625, 0.16649500372886683, 0.24002054420531171, 0.2912308799907989, 0.17815911613305302, 0.24375063963468935, 0.172422727593884, 0.30221767106561337, 0.25410578622127955, 0.2304616537223647, 0.3365899298163224, 0.3623628161698571, 0.34530779733822314, 0.35945909506500695, 0.3855083809142785, 0.35253281556900185, 0.3540830874247557, 0.35194644820167076, 0.3717405198999121, 0.3451486404271269, 0.49562819573656447, 0.4989418359530692, 0.5468228930780434, 0.5001375103785386, 0.44305574968860884, 0.5129947402983506, 0.5286388314595083, 0.5408146910833018, 0.511331878809594, 0.12852393658457273, 0.1387153029573468, 0.1197890457200188, 0.19496004658946875, 0.2555042355098399, 0.20730568348346767, 0.18805434804871113, 0.11490100474629361, 0.14716082552945886, 0.2837730859763774, 0.2946977475906406, 0.2936540001609703, 0.3131330724954383, 0.2973086771205964, 0.3009391901568026, 0.29364189584600187, 0.28583190704925754, 0.27717919506735067, 0.6834027604857797, 0.6956696184912128, 0.6476393882923912, 0.670088853492478, 0.6510501925230625, 0.6685467761288959, 0.6803748675087701, 0.6421125779458643, 0.6647395504646209, 0.1063455448513716, 0.1128332329870585, 0.11047174340339738, 0.13463540420788267, 0.11451260747456404, 0.12824682183707936, 0.12303303258140719, 0.11266818325204275, 0.10310498491581599, 0.2111864262276606, 0.16911456755388754, 0.17354591124489693, 0.22004320405388256, 0.22126239170175754, 0.20559248077756453, 0.18555528507936403, 0.1967538346749509, 0.1917421699116295, 0.379344551665041, 0.3966998326069544, 0.4061863181452472, 0.39369576546365226, 0.38342994032767586, 0.3943649180343659, 0.4036227209623118, 0.4226805543427731, 0.4101909197040109, 0.3124293622963301, 0.3243627139478499, 0.30867786985969603, 0.28097269234128297, 0.282008223939893, 0.2997357398485563, 0.3269522982879586, 0.30935284164186627, 0.32092683011319734, 0.2510217901639322, 0.19082371426952727, 0.2074118599063366, 0.18330535883186772, 0.1979237939359051, 0.19917395779588554, 0.20175672017001867, 0.2238820687989752, 0.18127033480002053, 0.21607551183058316, 0.20866947987252393, 0.2183628778171638, 0.24397265394460532, 0.2440762638058751, 0.24197201918205458, 0.19786944086893077, 0.24051183924406971, 0.2730729417102632, 0.16634430470666117, 0.6673304553723356, 0.699989266232637, 0.6731425297565159, 0.6588061083384216, 0.7173268005988713, 0.6721761719754413, 0.6548807111255253, 0.6225890755166685, 0.6414913050915643, 0.2083617787275136, 0.6977085993216171, 0.47348217697238426, 0.15995841966848567, 0.7235845183186234, 0.7136437328527038, 0.5139832333804534, 0.20886840940460993, 0.1952650582045765, 0.21218586833755837, 0.183783144333326, 0.17855554064335588, 0.1919018233987212, 0.1839615192286851, 0.20333085586040445, 0.19116845630278667, 0.18232364569631854, 0.08407335819875095, 0.07895802175913724, 0.10034249041186483, 0.08579983370583433, 0.08536263240371644, 0.0819349909828696, 0.0889874259722142, 0.08098683741458679, 0.08827057226921009]}, "mutation_prompt": null}
{"id": "e6758133-1acd-40b8-8193-6fb74f697821", "solution": "import numpy as np\n\nclass ADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        # Evaluate initial population\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                # Select indices for mutation\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Perform mutation and crossover\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                # Stochastic perturbation for trial vector\n                perturbation = np.random.normal(0, 0.05, self.dim)  # Change 1\n                trial += perturbation  # Change 2\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)  # Change 3\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True  # Track improvement\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            # Dynamic Adaptation of Local Search Intensity\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n\n            # Adaptive strategy parameters\n            self.F = np.random.uniform(0.4, 0.9)  # Change 4\n            self.CR = np.random.uniform(0.8, 1.0)  # Change 5\n\n            # Apply local search to best individual periodically if budget allows\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ADELSOptimizer", "description": "Enhanced ADELSOptimizer with Stochastic Perturbation and Adaptive Strategy to improve diversity and balance exploration-exploitation.", "configspace": "", "generation": 19, "fitness": 0.24707626414218747, "feedback": "The algorithm ADELSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.20.", "error": "", "parent_id": "112ca026-56f7-4ad3-ba92-8de319ae88bc", "metadata": {"aucs": [0.49239355443095534, 0.44580770008820914, 0.4524555396019634, 0.5174840590271232, 0.5026846878496036, 0.47341685448372495, 0.45727784237354274, 0.4865624110573923, 0.4631051431704075, 0.07648965233846083, 0.06897055362588578, 0.07679494046845536, 0.07878947272716164, 0.06805624775094143, 0.08945340293279247, 0.10491256311556285, 0.058904678391007104, 0.07123774318892706, 0.10998674567157762, 0.11068346342404167, 0.11038885625916883, 0.12545638023056294, 0.1109453878893486, 0.11125470492375589, 0.12797939084221766, 0.12924901433424152, 0.1134605338570347, 0.1051552279281921, 0.1031309218985429, 0.10823277412444277, 0.09724648981933948, 0.08452970302215201, 0.0890850537808685, 0.10133323526706484, 0.10646303161799042, 0.10285052452287946, 0.9269273421927464, 0.8315756426824809, 0.8461483395120464, 0.9001764702855981, 0.8306816554412682, 0.8492146122010372, 0.8999332727114673, 0.8864513915324049, 0.8759319398993507, 0.27522036461075483, 0.2824142724639874, 0.2733917446191323, 0.2728549231359201, 0.2813130630605216, 0.2712506803327228, 0.2830680717080447, 0.2907069038850113, 0.2937960962466081, 0.5878371675825385, 0.6270855603225463, 0.6116374985411714, 0.6482116845672998, 0.6029471282671599, 0.6654081683329011, 0.46523812207711035, 0.616747324785352, 0.5979076616473316, 0.17834170469756305, 0.18727359895250928, 0.154591150354907, 0.14899064753525415, 0.19322071183980927, 0.17196100831675176, 0.1961336455408771, 0.1811632458933773, 0.17111729950270016, 0.15332287931849164, 0.15868654038966978, 0.15135254142455323, 0.16728062100881236, 0.1778144347614149, 0.16861727747992283, 0.17802994363695668, 0.15698613105415737, 0.18055679565066352, 0.0579267741645908, 0.04354422861103735, 0.05160040778149688, 0.06505371733510878, 0.04051481666300738, 0.062383282981255395, 0.05551965073687404, 0.028537754189555953, 0.0687632270037618, 0.12555940564858226, 0.11691896124332202, 0.13854088784244611, 0.12593312443169002, 0.11008763315235992, 0.1333825760870182, 0.13270636991152074, 0.1434362421258073, 0.1381534878704731, 0.00019484263003555213, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0001539032993285172, 0.0213784463746155, 9.999999999998899e-05, 9.999999999998899e-05, 0.1090838696366574, 0.12177865197708848, 0.11579668787614772, 0.12214649119357868, 0.1161952568004766, 0.1114456886359001, 0.11926001366713057, 0.12599631549234158, 0.11665693775553554, 0.4028028874081766, 0.3974132516424409, 0.42454549383143225, 0.4392560338339817, 0.42771965651232535, 0.4145891176234472, 0.4321201635920827, 0.409924483859358, 0.4240384134619941, 0.12149169667435522, 0.09200132056762123, 0.11692332516377668, 0.1102130210334662, 0.09058932626106941, 0.1117269568353022, 0.10384958370610342, 0.10244048555199914, 0.10345315823246215, 0.19763943879660362, 0.17307322973085515, 0.18686386560501633, 0.20035643110332269, 0.20481973423074473, 0.2089028416789065, 0.22155065872627622, 0.16625212422404934, 0.18393131219952275, 0.2786849327385049, 0.29254654757065, 0.2837805554548023, 0.27599941982663245, 0.29373560219977324, 0.2929672106388219, 0.2895448275015985, 0.29771089796329253, 0.2921259015344766, 0.22060047785823522, 0.22099203019279468, 0.21818353947366653, 0.22347513786599416, 0.20867973661094852, 0.2234260255077588, 0.22298136193193363, 0.22011938058672953, 0.2247750757726219, 0.18587599465935456, 0.208659156835022, 0.18822058302391476, 0.1937860209472102, 0.17584734761770582, 0.18690396932331765, 0.18526882536863498, 0.21794583723291128, 0.18719637367058017, 0.1763346481806709, 0.2195296167473797, 0.1915256933254479, 0.1763790719964502, 0.20001547348321935, 0.19009186730647365, 0.1883421055884723, 0.2056269057679424, 0.19766832781503885, 0.529507792657938, 0.577393431122277, 0.6297156327969242, 0.5709183183728501, 0.5981159350729415, 0.6396364685155052, 0.45385857711582134, 0.4960046985836578, 0.18246586182619062, 0.5285954337381586, 0.5041708941323301, 0.5796736194807995, 0.43526144629408936, 0.20547459159841253, 0.41268949385328324, 0.20260846790971976, 0.20536186907845144, 0.20672550405573298, 0.17898189405217435, 0.19242170112244106, 0.18384628897805222, 0.1762089171335529, 0.18715535546827888, 0.19175969605333243, 0.19065544053591787, 0.19270201642683404, 0.18471563972764604, 0.0794203897388186, 0.0807637461542341, 0.07507388026708361, 0.08325343028399479, 0.07148633680709005, 0.07930828368971543, 0.07213134634499252, 0.07407587583756525, 0.07130486852282047]}, "mutation_prompt": null}
{"id": "2e13050f-1cb3-4115-b0b2-9b9e0ada54d0", "solution": "import numpy as np\n\nclass ADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        # Evaluate initial population\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            diversity_factor = np.std(self.population, axis=0) / (self.upper_bound - self.lower_bound)\n            for i in range(self.pop_size):\n                # Select indices for mutation\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Perform mutation and crossover\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c]) + diversity_factor\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            # Dynamic Adaptation of Local Search Intensity\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n\n            # Apply local search to best individual periodically if budget allows\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ADELSOptimizer", "description": "Adaptive Differential Evolution with Diversity-Driven Mutation Strategy to enhance exploration and exploitation balance.", "configspace": "", "generation": 20, "fitness": 0.29891680573681584, "feedback": "The algorithm ADELSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "112ca026-56f7-4ad3-ba92-8de319ae88bc", "metadata": {"aucs": [0.7606937888734905, 0.7530075945630933, 0.765976443616724, 0.7528429943550472, 0.771435746621101, 0.7637830924566769, 0.760104888306375, 0.7729320193502678, 0.7562308910429499, 0.5851505370273142, 0.6132705675216495, 0.5846963799548615, 0.603319618442664, 0.6067104246277746, 0.6069192933546248, 0.602865113562818, 0.5747004568459477, 0.5858850516559532, 0.11572045518964913, 0.10736087056389698, 0.1212295624116676, 0.11214127502203974, 0.10101819791152955, 0.10701607651963752, 0.1224185652064691, 0.10942084696045751, 0.12806804069462674, 0.11460622195900505, 0.1015052462238476, 0.10716967790726939, 0.10457709403596183, 0.08964482083459957, 0.09507253658996373, 0.11142769360043114, 0.1213608995056833, 0.10715748492093047, 0.8692185344479136, 0.9062992661017809, 0.9131613532887782, 0.8088018905545147, 0.860087758503211, 0.842271531694543, 0.817377002240855, 0.8909578387275456, 0.9357551153526612, 0.44524539282887476, 0.42167227067443547, 0.4716961225338806, 0.46760936405274933, 0.46158997368851173, 0.4763467845999364, 0.40128921050153143, 0.4504772658439018, 0.4119740722584263, 0.7416785689320119, 0.7346420268063689, 0.7506105360846674, 0.6877449262684114, 0.6198117425605174, 0.6559805915546866, 0.6391451873712894, 0.5742993734817905, 0.5530126935406389, 0.3783053123318887, 0.29932232544314796, 0.2074278884735048, 0.28063800247314974, 0.28269489840820217, 0.23832780407039422, 0.28439631166742985, 0.19414282678071426, 0.2700210129072116, 0.17515424500546306, 0.18171914944202028, 0.19372376274632885, 0.1798343303777643, 0.2551841577996701, 0.1466584457314999, 0.2187242864756508, 0.16401666218564548, 0.16714872045288975, 9.999999999998899e-05, 0.05025859168631197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0174096377659696, 0.06541334284512756, 0.08528333663457976, 0.10784470058071105, 0.05841204234610886, 0.06380030808994885, 0.07069593346781855, 0.03669666034704788, 0.0694926022271598, 0.07204512006225794, 0.057935145387265075, 0.10477883938333232, 0.11218880581903345, 0.007272168962204173, 0.030804180896362054, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.038674821168168116, 9.999999999998899e-05, 0.0014589557244777396, 9.999999999998899e-05, 0.16691090245755036, 0.17239554161597914, 0.15912426000672864, 0.13497113041601372, 0.14451395777217146, 0.14390740814800462, 0.12904659342772173, 0.12218158588689754, 0.12164989679411742, 0.5113810147826039, 0.4916433039720056, 0.507231196374041, 0.5182351278340728, 0.5454369349351628, 0.5588470404183108, 0.5522176371992491, 0.5145880107309526, 0.5206192347966012, 0.11045872269280843, 0.11386137837403276, 0.1242511231392156, 0.12381731196968448, 0.10168891300561589, 0.1208336402696224, 0.11133402895675659, 0.10189101239093434, 0.1053029960653945, 0.20114131958057013, 0.1818821674841562, 0.16677398179384095, 0.2143897412641883, 0.21170760018248547, 0.23406129023046784, 0.1390116927095798, 0.17187044755089553, 0.2308456481674268, 0.3857042563866018, 0.38110511714283857, 0.388233927788071, 0.37200540602898613, 0.3704456530483343, 0.35514676226431885, 0.3927375634936344, 0.4368518866872504, 0.4119277439277328, 0.25318208168924894, 0.24744306874139088, 0.24296372052029847, 0.24696237436627622, 0.2670011351111947, 0.2598661405150593, 0.2736126597038183, 0.2715489494648564, 0.2825538472626469, 0.19346354910813812, 0.20425884249838222, 0.19428139136502842, 0.18093132187405925, 0.20764212921541214, 0.18687812759865896, 0.19741047554280233, 0.21215862209034864, 0.18244317548065947, 0.2011213193393121, 0.18787716561074352, 0.20273236981035314, 0.23138031730224307, 0.19249035578646223, 0.19934613722585703, 0.1995007420978474, 0.1835551883502463, 0.1899514713449857, 0.6524673376262913, 0.1830825194930148, 0.1912358184203884, 0.5272284618006299, 0.5705261548381537, 0.35679149029506707, 0.16707931217246552, 0.18795298833308327, 0.6376928919536713, 0.6983111957592587, 0.3427726457506063, 0.6994577608962678, 0.16358232724319643, 0.19731842381250764, 0.44568318884093083, 0.19494923320532864, 0.41370899621847446, 0.20468934368752678, 0.20412939490629256, 0.18029769890651315, 0.1829293529806244, 0.18645968684989234, 0.19215184485779369, 0.18190696052195277, 0.18503672941570026, 0.17972049952407432, 0.17640889483843147, 0.07320624053534452, 0.08253216286569387, 0.08434096172592487, 0.09131457798754605, 0.07787758086709395, 0.06490921936434935, 0.0788421820981362, 0.08963533318847328, 0.07805963929368043]}, "mutation_prompt": null}
{"id": "190f5c3e-c18b-47f8-9220-6acb9b35ce36", "solution": "import numpy as np\n\nclass ADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        # Evaluate initial population\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                # Select indices for mutation\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Perform mutation and crossover\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True  # Track improvement\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            # Dynamic Adaptation of Local Search Intensity\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n\n            # Apply local search to best individual periodically if budget allows\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ADELSOptimizer", "description": "Enhanced Adaptive Differential Evolution with Dynamic Local Search Intensity to boost convergence and adaptability.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "112ca026-56f7-4ad3-ba92-8de319ae88bc", "metadata": {"aucs": [0.7792001086224225, 0.7513230358085143, 0.7706376971007186, 0.7665385438993475, 0.7757740257406791, 0.7680611353326741, 0.7754818832415746, 0.7808641960733638, 0.7834928795909286, 0.6036050012564385, 0.5834472956777756, 0.5732235041419516, 0.5809198952387966, 0.6238144491739585, 0.5715567403833136, 0.6047388281449301, 0.5940375477601878, 0.6029653305501617, 0.13060061219158703, 0.1331604135633172, 0.12563521321825377, 0.11962907242844889, 0.12209905819162437, 0.1041564776491497, 0.11193715488981071, 0.09900001934072711, 0.13864491867010742, 0.10511178440422753, 0.1196083057689511, 0.10384476612656723, 0.11028540335169967, 0.10707358909644771, 0.11792064856368889, 0.09294224918377403, 0.1005767977957035, 0.12418550965005903, 0.8838737208325241, 0.9119108816953605, 0.8415053521395808, 0.8717831940206152, 0.8975827426197159, 0.8565011511909489, 0.9069283696404941, 0.873259360827166, 0.8051334150766583, 0.3937050890993089, 0.44719101122148486, 0.4094428356772859, 0.435547515778019, 0.4175245806618936, 0.4254167060636467, 0.41304303887652905, 0.4802957448565165, 0.4285727716951121, 0.7281150529497491, 0.6941893185018543, 0.7657525316416878, 0.7970435015481473, 0.7798600704182534, 0.7588741116172091, 0.7543375456747536, 0.7874893786631498, 0.7469567338686431, 0.17108754345684885, 0.21829957532955224, 0.46914789865593753, 0.16330037331337777, 0.27831332171757284, 0.18576102539349093, 0.2838558661829108, 0.27834891888776625, 0.16649500372886683, 0.24002054420531171, 0.2912308799907989, 0.17815911613305302, 0.24375063963468935, 0.172422727593884, 0.30221767106561337, 0.25410578622127955, 0.2304616537223647, 0.3365899298163224, 0.3623628161698571, 0.34530779733822314, 0.35945909506500695, 0.3855083809142785, 0.35253281556900185, 0.3540830874247557, 0.35194644820167076, 0.3717405198999121, 0.3451486404271269, 0.49562819573656447, 0.4989418359530692, 0.5468228930780434, 0.5001375103785386, 0.44305574968860884, 0.5129947402983506, 0.5286388314595083, 0.5408146910833018, 0.511331878809594, 0.12852393658457273, 0.1387153029573468, 0.1197890457200188, 0.19496004658946875, 0.2555042355098399, 0.20730568348346767, 0.18805434804871113, 0.11490100474629361, 0.14716082552945886, 0.2837730859763774, 0.2946977475906406, 0.2936540001609703, 0.3131330724954383, 0.2973086771205964, 0.3009391901568026, 0.29364189584600187, 0.28583190704925754, 0.27717919506735067, 0.6834027604857797, 0.6956696184912128, 0.6476393882923912, 0.670088853492478, 0.6510501925230625, 0.6685467761288959, 0.6803748675087701, 0.6421125779458643, 0.6647395504646209, 0.1063455448513716, 0.1128332329870585, 0.11047174340339738, 0.13463540420788267, 0.11451260747456404, 0.12824682183707936, 0.12303303258140719, 0.11266818325204275, 0.10310498491581599, 0.2111864262276606, 0.16911456755388754, 0.17354591124489693, 0.22004320405388256, 0.22126239170175754, 0.20559248077756453, 0.18555528507936403, 0.1967538346749509, 0.1917421699116295, 0.379344551665041, 0.3966998326069544, 0.4061863181452472, 0.39369576546365226, 0.38342994032767586, 0.3943649180343659, 0.4036227209623118, 0.4226805543427731, 0.4101909197040109, 0.3124293622963301, 0.3243627139478499, 0.30867786985969603, 0.28097269234128297, 0.282008223939893, 0.2997357398485563, 0.3269522982879586, 0.30935284164186627, 0.32092683011319734, 0.2510217901639322, 0.19082371426952727, 0.2074118599063366, 0.18330535883186772, 0.1979237939359051, 0.19917395779588554, 0.20175672017001867, 0.2238820687989752, 0.18127033480002053, 0.21607551183058316, 0.20866947987252393, 0.2183628778171638, 0.24397265394460532, 0.2440762638058751, 0.24197201918205458, 0.19786944086893077, 0.24051183924406971, 0.2730729417102632, 0.16634430470666117, 0.6673304553723356, 0.699989266232637, 0.6731425297565159, 0.6588061083384216, 0.7173268005988713, 0.6721761719754413, 0.6548807111255253, 0.6225890755166685, 0.6414913050915643, 0.2083617787275136, 0.6977085993216171, 0.47348217697238426, 0.15995841966848567, 0.7235845183186234, 0.7136437328527038, 0.5139832333804534, 0.20886840940460993, 0.1952650582045765, 0.21218586833755837, 0.183783144333326, 0.17855554064335588, 0.1919018233987212, 0.1839615192286851, 0.20333085586040445, 0.19116845630278667, 0.18232364569631854, 0.08407335819875095, 0.07895802175913724, 0.10034249041186483, 0.08579983370583433, 0.08536263240371644, 0.0819349909828696, 0.0889874259722142, 0.08098683741458679, 0.08827057226921009]}, "mutation_prompt": null}
{"id": "3a50dd41-549f-4d85-bc4f-9cfd360e04a9", "solution": "import numpy as np\nfrom sklearn.cluster import KMeans\n\nclass ADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Initial crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        # Evaluate initial population\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                if evaluations < self.budget // 2:\n                    self.CR = 0.9\n                else:\n                    self.CR = 0.5 + 0.4 * np.random.rand()\n                \n                # Select indices for mutation\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Perform mutation and crossover\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            # Dynamic Adaptation of Local Search Intensity\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n\n            # Apply local search to cluster centers periodically if budget allows\n            if evaluations + self.local_search_intensity <= self.budget:\n                kmeans = KMeans(n_clusters=5).fit(self.population)\n                centers = kmeans.cluster_centers_\n                for center in centers:\n                    self.local_search(center, func)\n                    evaluations += self.local_search_intensity\n\n        return self.best_solution()\n\n    def local_search(self, candidate, func):\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            # Update the closest individual in population\n            idx = np.argmin(np.linalg.norm(self.population - local_candidate, axis=1))\n            if local_fitness < self.fitness[idx]:\n                self.population[idx] = local_candidate\n                self.fitness[idx] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ADELSOptimizer", "description": "Improved ADELSOptimizer with adaptive crossover probability and population clustering for enhanced exploration-exploitation balance.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: ModuleNotFoundError(\"No module named 'sklearn'\").", "error": "ModuleNotFoundError(\"No module named 'sklearn'\")", "parent_id": "112ca026-56f7-4ad3-ba92-8de319ae88bc", "metadata": {}, "mutation_prompt": null}
{"id": "584f6efa-bcd8-4411-97d9-f00d5f7b5d35", "solution": "import numpy as np\n\nclass ADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        # Evaluate initial population\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                # Select indices for mutation\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Perform mutation and crossover\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True  # Track improvement\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            # Dynamic Adaptation of Local Search Intensity\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n\n            # Apply local search to best individual periodically if budget allows\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ADELSOptimizer", "description": "Enhanced Adaptive Differential Evolution with Dynamic Local Search Intensity to boost convergence and adaptability.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "112ca026-56f7-4ad3-ba92-8de319ae88bc", "metadata": {"aucs": [0.7792001086224225, 0.7513230358085143, 0.7706376971007186, 0.7665385438993475, 0.7757740257406791, 0.7680611353326741, 0.7754818832415746, 0.7808641960733638, 0.7834928795909286, 0.6036050012564385, 0.5834472956777756, 0.5732235041419516, 0.5809198952387966, 0.6238144491739585, 0.5715567403833136, 0.6047388281449301, 0.5940375477601878, 0.6029653305501617, 0.13060061219158703, 0.1331604135633172, 0.12563521321825377, 0.11962907242844889, 0.12209905819162437, 0.1041564776491497, 0.11193715488981071, 0.09900001934072711, 0.13864491867010742, 0.10511178440422753, 0.1196083057689511, 0.10384476612656723, 0.11028540335169967, 0.10707358909644771, 0.11792064856368889, 0.09294224918377403, 0.1005767977957035, 0.12418550965005903, 0.8838737208325241, 0.9119108816953605, 0.8415053521395808, 0.8717831940206152, 0.8975827426197159, 0.8565011511909489, 0.9069283696404941, 0.873259360827166, 0.8051334150766583, 0.3937050890993089, 0.44719101122148486, 0.4094428356772859, 0.435547515778019, 0.4175245806618936, 0.4254167060636467, 0.41304303887652905, 0.4802957448565165, 0.4285727716951121, 0.7281150529497491, 0.6941893185018543, 0.7657525316416878, 0.7970435015481473, 0.7798600704182534, 0.7588741116172091, 0.7543375456747536, 0.7874893786631498, 0.7469567338686431, 0.17108754345684885, 0.21829957532955224, 0.46914789865593753, 0.16330037331337777, 0.27831332171757284, 0.18576102539349093, 0.2838558661829108, 0.27834891888776625, 0.16649500372886683, 0.24002054420531171, 0.2912308799907989, 0.17815911613305302, 0.24375063963468935, 0.172422727593884, 0.30221767106561337, 0.25410578622127955, 0.2304616537223647, 0.3365899298163224, 0.3623628161698571, 0.34530779733822314, 0.35945909506500695, 0.3855083809142785, 0.35253281556900185, 0.3540830874247557, 0.35194644820167076, 0.3717405198999121, 0.3451486404271269, 0.49562819573656447, 0.4989418359530692, 0.5468228930780434, 0.5001375103785386, 0.44305574968860884, 0.5129947402983506, 0.5286388314595083, 0.5408146910833018, 0.511331878809594, 0.12852393658457273, 0.1387153029573468, 0.1197890457200188, 0.19496004658946875, 0.2555042355098399, 0.20730568348346767, 0.18805434804871113, 0.11490100474629361, 0.14716082552945886, 0.2837730859763774, 0.2946977475906406, 0.2936540001609703, 0.3131330724954383, 0.2973086771205964, 0.3009391901568026, 0.29364189584600187, 0.28583190704925754, 0.27717919506735067, 0.6834027604857797, 0.6956696184912128, 0.6476393882923912, 0.670088853492478, 0.6510501925230625, 0.6685467761288959, 0.6803748675087701, 0.6421125779458643, 0.6647395504646209, 0.1063455448513716, 0.1128332329870585, 0.11047174340339738, 0.13463540420788267, 0.11451260747456404, 0.12824682183707936, 0.12303303258140719, 0.11266818325204275, 0.10310498491581599, 0.2111864262276606, 0.16911456755388754, 0.17354591124489693, 0.22004320405388256, 0.22126239170175754, 0.20559248077756453, 0.18555528507936403, 0.1967538346749509, 0.1917421699116295, 0.379344551665041, 0.3966998326069544, 0.4061863181452472, 0.39369576546365226, 0.38342994032767586, 0.3943649180343659, 0.4036227209623118, 0.4226805543427731, 0.4101909197040109, 0.3124293622963301, 0.3243627139478499, 0.30867786985969603, 0.28097269234128297, 0.282008223939893, 0.2997357398485563, 0.3269522982879586, 0.30935284164186627, 0.32092683011319734, 0.2510217901639322, 0.19082371426952727, 0.2074118599063366, 0.18330535883186772, 0.1979237939359051, 0.19917395779588554, 0.20175672017001867, 0.2238820687989752, 0.18127033480002053, 0.21607551183058316, 0.20866947987252393, 0.2183628778171638, 0.24397265394460532, 0.2440762638058751, 0.24197201918205458, 0.19786944086893077, 0.24051183924406971, 0.2730729417102632, 0.16634430470666117, 0.6673304553723356, 0.699989266232637, 0.6731425297565159, 0.6588061083384216, 0.7173268005988713, 0.6721761719754413, 0.6548807111255253, 0.6225890755166685, 0.6414913050915643, 0.2083617787275136, 0.6977085993216171, 0.47348217697238426, 0.15995841966848567, 0.7235845183186234, 0.7136437328527038, 0.5139832333804534, 0.20886840940460993, 0.1952650582045765, 0.21218586833755837, 0.183783144333326, 0.17855554064335588, 0.1919018233987212, 0.1839615192286851, 0.20333085586040445, 0.19116845630278667, 0.18232364569631854, 0.08407335819875095, 0.07895802175913724, 0.10034249041186483, 0.08579983370583433, 0.08536263240371644, 0.0819349909828696, 0.0889874259722142, 0.08098683741458679, 0.08827057226921009]}, "mutation_prompt": null}
{"id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 24, "fitness": 0.38458114934239296, "feedback": "The algorithm ImprovedADELSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.24.", "error": "", "parent_id": "112ca026-56f7-4ad3-ba92-8de319ae88bc", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "34f30274-8d2a-41cf-a648-3cd325cfaac2", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "506605bc-5e29-4989-ae4a-09060a0fe92f", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Initial crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                \n                # Dynamic crossover rate\n                CR_dynamic = self.CR * (1 - evaluations / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_dynamic\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Diversified re-initialization strategy\n            if self.no_improvement_count > 5:\n                reinit_indices = np.random.choice(self.pop_size, self.pop_size // 5, replace=False)\n                for idx in reinit_indices:\n                    self.population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    self.fitness[idx] = func(self.population[idx])\n                evaluations += len(reinit_indices)\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Refined ADELS with dynamic crossover rate and a diversified re-initialization strategy for improved convergence and exploration.", "configspace": "", "generation": 26, "fitness": 0.2884396626613061, "feedback": "The algorithm ImprovedADELSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7449773380173212, 0.7452314477276639, 0.7469926270561061, 0.7608050998636344, 0.7546970614569214, 0.749031017196292, 0.7641536152595596, 0.7433782394214953, 0.7673293321759342, 0.5680860628930791, 0.5746376399237121, 0.5529130325020895, 0.5716239808864455, 0.5624004422963056, 0.5545612662564237, 0.5524793440376841, 0.5812245853239664, 0.5622443311792495, 0.2284872620554682, 0.1918507450814564, 0.2798817721921045, 0.20407230917478425, 0.2217815107539317, 0.16541905427233394, 0.2824108741708521, 0.24650755194448815, 0.23835734148196364, 0.15187031879447854, 0.2259200935342789, 0.1623095254330279, 0.185485205325859, 0.16966631728542503, 0.20621923091618788, 0.2325866627805755, 0.19416373372189177, 0.20291109079559233, 0.916795994674648, 0.9098941535734193, 0.8965069317290583, 0.9510929354843223, 0.909250194325682, 0.9146249971753944, 0.961969795357074, 0.9104517688223445, 0.9549052820944721, 0.3175226300887207, 0.3270698293275267, 0.3158467818961125, 0.30777014935028624, 0.2918873193333048, 0.3014305630105458, 0.3153997681447148, 0.3300323512505491, 0.3202140144419152, 0.312404667889843, 0.29422260500228714, 0.3536580387928483, 0.314021825074548, 0.583285240895137, 0.33204677233988267, 0.5318284678775143, 0.6136262669107805, 0.316974222632337, 0.16288305291376814, 0.1771157490073212, 0.17432450161245328, 0.15692349305618825, 0.17466671145514612, 0.20849793748289247, 0.18269343435727348, 0.16908839443716028, 0.18003331708149362, 0.19144671297914173, 0.13726618752806752, 0.15460565394904047, 0.13997325072596267, 0.18396127449508037, 0.1428958497976064, 0.163357869211756, 0.15428437605645084, 0.15216005303347324, 0.018906420359924403, 0.01797157437039243, 0.003679595318884954, 0.04133042411668142, 0.0691525244443354, 0.005172372629518196, 0.05717162682047072, 0.08269465599732062, 9.999999999998899e-05, 0.1672847319502192, 0.14568053495045608, 0.1507214350917686, 0.15193896668494034, 0.11413562310523961, 0.16148085738457596, 0.18290436841974955, 0.13030358388468377, 0.13331169412213584, 0.007264646378824735, 0.005394574446016431, 9.999999999998899e-05, 9.999999999998899e-05, 0.006250060672401414, 9.999999999998899e-05, 0.0011424851010215509, 0.04518756908874133, 0.0015696094639613412, 0.13491401664340696, 0.12820007273991263, 0.13916857352673273, 0.12381113545801514, 0.13764380116160468, 0.13760327551673124, 0.1261961154057133, 0.11126420519018976, 0.12278513882994879, 0.4692608874555737, 0.4964230108833928, 0.488795222658565, 0.4660694836980255, 0.46613864274924266, 0.45491111196980405, 0.4989952404480882, 0.47593991212780096, 0.4731037768208457, 0.10345812952232192, 0.11549580299746032, 0.10903719934963552, 0.13398517340442417, 0.10452801447897131, 0.11582422204801512, 0.11646297731186406, 0.12745524164207567, 0.13788644377459425, 0.1813214882746752, 0.1703772289081248, 0.21310414219624185, 0.16831259720458114, 0.1683934466601622, 0.1876168107224726, 0.1677604633207146, 0.19848277311326112, 0.16048296377640614, 0.3233699664206593, 0.32288335038263105, 0.3163593880253378, 0.3310017540583623, 0.31228195668308467, 0.3165411882515021, 0.3346877007667852, 0.3619298167727013, 0.36044495715806457, 0.2201785193289606, 0.23504193345981128, 0.2529283939549807, 0.2116818217032197, 0.20350713641374008, 0.21982161308231185, 0.25754102186294014, 0.2773816620475742, 0.24335699878183004, 0.20766885829669923, 0.19103878675827624, 0.19796289681002555, 0.1751301308499289, 0.19369479098708775, 0.24541598528991238, 0.19323000079923358, 0.18456785901689154, 0.18445447942668025, 0.3044322621298251, 0.23085185340604564, 0.2238938585544602, 0.2286222367073164, 0.20588933913287122, 0.26899091646166073, 0.2704407878802666, 0.2139620171043849, 0.23975669315100878, 0.42957632288075986, 0.47208407912118433, 0.1685809496803422, 0.5327429038372671, 0.5243621781061172, 0.7434951694235915, 0.5155233273506712, 0.5030860129049968, 0.5409357087404216, 0.3871750849700265, 0.28751911925912776, 0.4042364186561809, 0.3243025586754982, 0.4248485757913141, 0.44529900277742174, 0.20409804927205688, 0.204467110823631, 0.4023853005914759, 0.18197782122765938, 0.18208986319679377, 0.18967419043782674, 0.18392769133895281, 0.1805125258116448, 0.1770310104591195, 0.2005227725420896, 0.18180708348003505, 0.20691908950772853, 0.08198594267044768, 0.07732283400050788, 0.09093641326053425, 0.0930419379574654, 0.08511268404921735, 0.09459258628906131, 0.08023910563095382, 0.07323230851307416, 0.07654334303386001]}, "mutation_prompt": null}
{"id": "acefe5f1-350e-4fc2-a25d-c77863831270", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "0bec9934-d4d4-436c-acf3-afeac16afcfb", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = 10 * dim\n        self.pop_size = self.initial_pop_size\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive mutation strategy\n                F_adaptive = 0.2 + 0.8 * np.random.rand() * (1 - evaluations / self.budget)\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Dynamic population size adjustment\n            if self.no_improvement_count > 5 and self.pop_size > self.dim:\n                self.pop_size = max(self.dim, self.pop_size // 2)\n                self.population = self.population[:self.pop_size]\n                self.fitness = self.fitness[:self.pop_size]\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Enhanced ADELS with dynamic population size adjustment and adaptive mutation strategy for improved convergence and exploration-exploitation balance.", "configspace": "", "generation": 28, "fitness": 0.3762258237423951, "feedback": "The algorithm ImprovedADELSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.25.", "error": "", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7722589886166344, 0.7610441619364545, 0.7916535407220932, 0.7799442684657836, 0.7530892455618381, 0.7681898955038564, 0.784109850831993, 0.7591438778347823, 0.7689780544547157, 0.5871860062012206, 0.5859493806384104, 0.609049085664537, 0.5961897524349349, 0.5806784518682058, 0.5875666359191223, 0.5856783412301876, 0.5914174309828534, 0.6036711013546454, 0.12146293393607643, 0.13383669722450564, 0.11961789656018518, 0.124693247043271, 0.18041128589318178, 0.11275733638240804, 0.15545849792214428, 0.1642924301737203, 0.12829400798157564, 0.12866239026346904, 0.13090546812389459, 0.11391422862612421, 0.13529457620329266, 0.1266810354994823, 0.11609568684175497, 0.11472170957342276, 0.11319600602047686, 0.10698688648136756, 0.866672729774161, 0.9287259490715791, 0.8543304327609071, 0.8792190987800506, 0.8562122857179177, 0.902625076878656, 0.9573891924234492, 0.8989206779583561, 0.8970389025204737, 0.407074868884039, 0.37291000602055335, 0.44598968556233454, 0.4287640621569201, 0.3650469204771658, 0.4116441878413468, 0.40907363224807525, 0.30432972820642723, 0.37859760322642555, 0.7262193778888777, 0.7451726618735113, 0.7086501769254661, 0.7776770064535989, 0.7336991446220633, 0.7851907810596832, 0.7909948699947965, 0.765144620301896, 0.743966486460379, 0.18281087213947955, 0.14798491068044473, 0.20796800683225358, 0.16261789314141684, 0.12446353104037267, 0.20574882140602813, 0.22064301045986978, 0.21887161491768603, 0.19824160375960231, 0.1784773222704985, 0.28924524837849175, 0.16841966717938883, 0.2718285129155905, 0.15434994968788485, 0.17560059888922874, 0.1864158241154491, 0.22504833114694145, 0.19107691010410666, 0.3310736171376173, 0.3676575245402569, 0.2876875122389302, 0.40832583470470474, 0.3838689798437226, 0.4199941521989069, 0.46810153151720446, 0.3813766162759845, 0.2818411276903362, 0.5777096669820667, 0.5330929689720416, 0.5204961987269637, 0.5452275507411908, 0.4556353383369106, 0.5124430467003213, 0.49308122915432784, 0.5033706275520058, 0.4810929563174837, 0.14300290446831865, 0.1174415185798714, 0.10559521613508482, 0.14013283092629703, 0.15239851903799895, 0.1867335017845373, 0.14303168628283003, 0.1854003964702592, 0.09959967087012378, 0.2642636439004379, 0.315725323391312, 0.28947745879335496, 0.31350791582765236, 0.3372240380445335, 0.2771984119128068, 0.3082044520798758, 0.30450602792877757, 0.27629005789484173, 0.6797866235882858, 0.7018931401837651, 0.6761198535743314, 0.6395656213258858, 0.709754204029466, 0.6792134907253358, 0.6873928011748451, 0.6889473829649593, 0.7164884263819316, 0.10990687008654498, 0.1498270197145566, 0.11112756816704406, 0.14427791452965666, 0.10345943725932671, 0.1698000018527851, 0.11379714473501423, 0.12902033930660872, 0.09850152721949001, 0.21127547606697072, 0.18991552021501668, 0.19100118262042398, 0.22275613134613936, 0.16276547566559563, 0.22096768730971617, 0.18659369779824742, 0.22972500936084395, 0.20181709223385536, 0.4023471270158132, 0.41014568527960005, 0.43467045521361647, 0.406223069031454, 0.4374138840023394, 0.43904461122062455, 0.488842789370586, 0.4737522439514429, 0.45390133482615447, 0.34870391244450805, 0.3345551600127834, 0.3314074528276153, 0.3171503076999226, 0.3341754058692621, 0.3581626917839207, 0.3304857513825282, 0.33897095591303583, 0.3487605227324658, 0.20570041891354685, 0.18920770055443215, 0.19956921255872462, 0.19671580730989058, 0.20232797372930333, 0.19906394165069885, 0.2134895025804706, 0.2011952790419259, 0.19086774669059758, 0.2188150291650418, 0.26033739178193305, 0.34618977241474624, 0.35160896084295146, 0.2540717097724685, 0.27915289755683936, 0.21423401258562047, 0.26636156656039367, 0.21771681908008667, 0.7193995969721174, 0.7084058437246429, 0.16694347596680892, 0.6711257592727153, 0.6097786224604166, 0.7593736963031963, 0.8135585158587066, 0.7059834971767118, 0.7189142798027037, 0.7060778897869681, 0.6251319707035704, 0.7648511726803751, 0.19996298746873753, 0.230741524917071, 0.7776345031437023, 0.12562809781765538, 0.20730019449495296, 0.7210303055311948, 0.17949501388510658, 0.1929829381476479, 0.18304059116357352, 0.1836182122489557, 0.17551178005553425, 0.1833803920128363, 0.1824870477860392, 0.1793544390138595, 0.1851845033014089, 0.07213943909227816, 0.07656715711701723, 0.07498304042099047, 0.08221944296743677, 0.07816899219809603, 0.0850357452311018, 0.08142216773698852, 0.07938414599079135, 0.08094196301509404]}, "mutation_prompt": null}
{"id": "8a844446-5b76-4aa6-a368-8d5914800541", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.adaptive_local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n            # Opposition-based learning\n            opposite_pop = self.lower_bound + self.upper_bound - self.population\n            for i in range(self.pop_size):\n                opposite_fitness = func(opposite_pop[i])\n                evaluations += 1\n                if opposite_fitness < self.fitness[i]:\n                    self.population[i] = opposite_pop[i]\n                    self.fitness[i] = opposite_fitness\n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n        return self.best_solution()\n\n    def adaptive_local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Integration of opposition-based learning and adaptive local search to enhance convergence speed and avoid local optima.", "configspace": "", "generation": 29, "fitness": 0.25722501007419013, "feedback": "The algorithm ImprovedADELSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.19.", "error": "", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.5599892987472357, 0.5287464314841988, 0.5467045705230433, 0.5656920945676001, 0.550476754477874, 0.5582035521455262, 0.5548229107260448, 0.5529381019846271, 0.5703421669144719, 0.2876999647537759, 0.2570818119299494, 0.2757978805709522, 0.265682133485854, 0.22722164027404657, 0.25171998986618505, 0.22754871372250185, 0.25497694395650683, 0.2904379731454174, 0.12575206705246889, 0.09992088047758063, 0.10201853730167154, 0.09951888717907498, 0.09232958313074668, 0.08819493877531748, 0.10100386033128339, 0.08883390107157285, 0.12026291450970805, 0.0901545905517982, 0.08868615339085206, 0.10920158534565305, 0.09133087306006293, 0.08075799513765292, 0.08681226119200458, 0.10754262400488146, 0.08936590396941024, 0.08930744450857642, 0.8637312951547158, 0.6903025205141452, 0.7403265880029742, 0.9411062259180377, 0.6966458890364854, 0.8512566497322178, 0.8053295755378884, 0.8381952986609662, 0.7679371489561756, 0.24583767955533398, 0.25638303957168274, 0.20847964230126914, 0.24394275507559382, 0.21526366572443856, 0.2181687633795516, 0.2555748539555923, 0.25610441813419693, 0.24899180498738793, 0.5299457126967906, 0.5100043450028329, 0.534153174828353, 0.4686736906952963, 0.4863316967675264, 0.4424014798099398, 0.6124506809900772, 0.5592728849963018, 0.5372097657442054, 0.21460825434786268, 0.19087290191772355, 0.14599728979023896, 0.15677274951105702, 0.12183448552631182, 0.172780802546059, 0.1279962847025492, 0.1336460586771322, 0.14246894845784341, 0.22316981220984067, 0.11856000193006078, 0.2340904321945133, 0.19664355068911377, 0.18678225673839932, 0.19041757683996985, 0.2869831611440339, 0.17200439006609447, 0.22200783199385354, 0.101288031918922, 0.1295472512518845, 0.09419890201273051, 0.1003624827120233, 0.08355846121053578, 0.10180387744514796, 0.12339229354271408, 0.1244279980741636, 0.09413168526833438, 0.23651411525584987, 0.27383908443066285, 0.24377468551405157, 0.20700214543953122, 0.1921653117815676, 0.224722713302431, 0.2211182435672756, 0.26016371423032403, 0.2900332052436062, 0.02775871038577349, 0.04932132498509367, 0.046486442561659125, 0.03846439237478694, 0.07477983870785743, 0.01925758753377027, 0.04228336083263262, 0.04989950709349811, 0.01551682407367605, 0.1414890840806109, 0.13934818367855772, 0.14938422858850098, 0.12961951870601074, 0.13499448833298233, 0.16099658892487823, 0.12846948652420886, 0.1305589493951509, 0.15207288321066792, 0.4670418985002923, 0.48332850351084833, 0.48042332801063803, 0.43736934150770457, 0.4431580344701953, 0.4696862098488904, 0.4818071603172769, 0.44478675520713895, 0.47963961287369516, 0.08521690861933462, 0.09496507176208269, 0.10119287699251522, 0.09523805510188654, 0.09218843746008476, 0.10024992580712966, 0.09785068340207526, 0.0962513557750102, 0.09359522606471327, 0.16336321582770852, 0.17314285934972762, 0.21195927416256977, 0.17208559605542562, 0.1658120949593611, 0.1484737088914213, 0.1873433352744297, 0.19605577238937844, 0.19150486750939621, 0.27661385360197155, 0.27308680559356013, 0.28139535237775803, 0.27359592145115474, 0.26388348834960085, 0.3000451365534783, 0.29283128968610816, 0.3045454676442856, 0.2793990322479962, 0.2070175629013139, 0.20378140634031938, 0.23434853799391575, 0.2047556529698471, 0.21499735131418596, 0.21071641730308333, 0.2358920075236247, 0.22859858783412268, 0.21190669707336562, 0.16256733800416445, 0.17278005346927272, 0.1881940836326721, 0.19727360155858165, 0.18951862643462114, 0.21123335670072907, 0.18637831713933062, 0.184614410635905, 0.18725634617280584, 0.1800580773029269, 0.18657483630771843, 0.19465596308385935, 0.19059062067753196, 0.1775480205121357, 0.20501828366192876, 0.18188226668371632, 0.19070074929087033, 0.2013541743288021, 0.4116734352866144, 0.40923017037024934, 0.5549039031908365, 0.5264749568975781, 0.5288586305159844, 0.5825946390063541, 0.668743895778825, 0.46899923483000316, 0.525256693891524, 0.5556357864999397, 0.16504297059444129, 0.5171697136697733, 0.2053767189402751, 0.498513926877892, 0.3325896404709977, 0.28294259944021183, 0.19482272529705846, 0.21130795246100942, 0.1822863179572869, 0.17956476084454698, 0.18174106568372295, 0.17127900721932088, 0.18223534273040798, 0.16988180910241024, 0.1801363783114348, 0.1830048709079679, 0.19397419356904255, 0.07936502440131876, 0.06035812756331582, 0.07131961462992098, 0.09446032267623994, 0.06995785782146668, 0.07145625271853806, 0.07451179212699166, 0.07243395293476551, 0.09167651532777965]}, "mutation_prompt": null}
{"id": "41875a5f-1bb0-4fe5-9499-a609f2bfe798", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor based on fitness variance\n                variance = np.var(self.fitness)\n                F_adaptive = 0.1 + 0.9 * np.random.rand() * variance\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            # Preserve best solutions\n            elite_idx = np.argmin(self.fitness)\n            new_population[elite_idx] = self.population[elite_idx]\n            self.fitness[elite_idx] = self.fitness[elite_idx]\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Incorporate an adaptive mutation strategy and elite preservation to improve convergence and solution quality.", "configspace": "", "generation": 30, "fitness": 0.14319028870096973, "feedback": "The algorithm ImprovedADELSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.20.", "error": "", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.4115348909988612, 0.36058299264126503, 0.3877431879840274, 0.34686190466687616, 0.386609306337829, 0.3490133543645103, 0.21771798497677863, 0.18238003619812648, 0.19364459537027956, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00021285879266941254, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030122542145333164, 0.0339821128645621, 0.029709965550566042, 0.03365696845393362, 0.04034203814470039, 0.031492842360194895, 0.03803375040994528, 0.10855469267194495, 0.06728082300958416, 0.01804728898482133, 0.0061948124643106395, 0.02572106018721354, 0.06555235394716141, 0.019672469209772503, 0.007948453191930271, 0.035858962341492995, 0.013690095448959605, 0.012489705497931158, 0.9926015961743028, 0.9829844317189916, 0.9826387167801766, 0.9950430951803938, 0.9847665827839727, 0.9924440211743883, 0.9870637877148265, 0.9834562383145184, 0.9946228987512515, 0.11306812721021797, 0.026742589824353513, 0.021398030391705625, 0.02254798847557271, 0.040728271523080894, 0.025358852032507095, 0.062058923979750436, 0.0683542749897359, 0.04390747044232446, 0.13782387193417855, 0.21963856491508726, 0.1121246539438926, 0.20539758235209515, 0.15346383864037016, 0.088154631947439, 0.06480605217049507, 0.14112848072466933, 0.13856921544027168, 0.21896575421086162, 0.10328234716565499, 0.11025034666961764, 9.999999999998899e-05, 0.11698731542655005, 9.999999999998899e-05, 0.08148835829535783, 0.12195859730909231, 9.999999999998899e-05, 0.042175331623434564, 0.07114244191686381, 9.999999999998899e-05, 0.11932558651767977, 0.0008268219126357224, 0.14795045031207898, 0.017532821057427483, 9.999999999998899e-05, 0.05495163537627179, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011683363701472604, 0.03532908522090494, 0.05356479104218792, 9.999999999998899e-05, 0.015565753430389795, 0.002925346209341706, 0.008177853383433686, 0.06395887226392094, 0.0041335966420738, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07264966832433406, 9.999999999998899e-05, 9.999999999998899e-05, 0.023778619612797924, 0.01873641861903974, 0.00024081820915011765, 9.999999999998899e-05, 0.33265569047597887, 0.37524022996081674, 0.3574905112883279, 0.27018040160595813, 0.3016893797180219, 0.2592887980896701, 0.38425139578786616, 0.3635706694829193, 0.32051147522033163, 0.05800755078310482, 0.048756318377545016, 0.06796045898325243, 0.057573878598568995, 0.024705012969948648, 0.052332165518278795, 0.015332081060325575, 0.0329481702882638, 0.06684823431415843, 0.15219873105142656, 0.22729062067971706, 0.15621048629737766, 0.16208010895038127, 0.1627079458046532, 0.1242146227878893, 0.19059733657287448, 0.14636950172611773, 0.13385302695604062, 0.20553589766395275, 0.20616471533125869, 0.22982364000001232, 0.2527658691390716, 0.23201500022053612, 0.23165454593025392, 0.28062530857734613, 0.26349561068171945, 0.2658936730386241, 0.10425198900522248, 0.07898137616312828, 0.11204358372174361, 0.12312930526934929, 0.12415885418320705, 0.12775716784424151, 0.1750721798384517, 0.18298386265025157, 0.15950557397338816, 0.1577601081073795, 0.18011563198263358, 0.1497713718033925, 0.16810761987012335, 0.14476618891968052, 0.14786708097890044, 0.16367072319593012, 0.13700070588203217, 0.14755541849609688, 0.14978470512908537, 0.11218898893413165, 9.999999999998899e-05, 0.18195740800092886, 9.999999999998899e-05, 0.1689168026372434, 0.1513072038150053, 0.008236402824934652, 0.015453232060349542, 0.1553638345727788, 0.1283193036494613, 0.1663021641713336, 0.15556432592368108, 0.19100761320288107, 0.18673865008136714, 0.15249262768577465, 0.14366634933249534, 0.13380144603201805, 0.35559366939784565, 0.20262830103769258, 0.11485071106886402, 0.09830462948318619, 0.0910831306769978, 0.11595899350814853, 0.17219895333651658, 0.1979062717304898, 0.18492371793063633, 0.19340902316814412, 0.17559584098968284, 0.19700251298506244, 0.19717027019278566, 0.17955732067718966, 0.177232374786929, 0.1764088275782364, 0.18817105205795726, 0.1764734332075566, 0.04158930049217291, 0.04114218802467273, 0.044052127216131165, 0.03672264151529803, 0.053409384304340946, 0.04703339365429382, 0.029432813904480493, 0.039362319215534125, 0.046423460198683486]}, "mutation_prompt": null}
{"id": "bacd5e7a-4d58-4b3f-8450-da8a6caf12dc", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "6f4f223b-e036-4343-a20a-eca8929961fb", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n        self.adaptive_factor = 0.1\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = self.adaptive_factor + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n            \n            # Dynamic local search\n            if evaluations + self.local_search_intensity <= self.budget and np.random.rand() < 0.5:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Enhanced diversity and convergence using adaptive mutation and dynamic local search.", "configspace": "", "generation": 32, "fitness": 0.37220520021303466, "feedback": "The algorithm ImprovedADELSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.24.", "error": "", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7507166775070251, 0.7587410781454835, 0.7767772174399966, 0.7638264987262191, 0.744522879558656, 0.7524118106527975, 0.7626821378241929, 0.743965701006338, 0.7433571634419196, 0.5627316215293494, 0.6000688287632782, 0.5483612715531745, 0.5816130096795344, 0.5751344338126885, 0.5841285329361039, 0.5873603092293932, 0.5758900359420038, 0.5832531182199943, 0.1176288754283702, 0.14617795687312662, 0.128126012835739, 0.10123089681082742, 0.14033040222890247, 0.12823011785716065, 0.12183510610714243, 0.11428897627551282, 0.1282720545590933, 0.11141806338619242, 0.13546955919482462, 0.11386750645856558, 0.1187063143380307, 0.11605280487762937, 0.11815391809955889, 0.13286047754375918, 0.10764532882785571, 0.1192419765863566, 0.9358224118373807, 0.9218865153114247, 0.897199482471818, 0.9392362476667439, 0.8803558746110701, 0.9034072310522543, 0.9269594743276187, 0.892402524534548, 0.8871799707735059, 0.3954110353718906, 0.40274849374314914, 0.3953962489611458, 0.3966324928245224, 0.38469026736613454, 0.41979422921856324, 0.36864136655732227, 0.36676040757002226, 0.4228652251348254, 0.7242235512646491, 0.7728155033773041, 0.707988486775363, 0.7409395650085593, 0.7395383268010075, 0.790339702246219, 0.765740955106424, 0.7275692897212087, 0.2292458854080327, 0.33849479671897575, 0.15413364528690832, 0.1803759739072237, 0.196926725196387, 0.1695792376749612, 0.3140247214069506, 0.19360512622607995, 0.2686509663164458, 0.3829835540622445, 0.1701688645487357, 0.25622246029381057, 0.12440379271295221, 0.22033521324739325, 0.16897320519384806, 0.3272882225015392, 0.3833271354570993, 0.23026735700326395, 0.19084520687890916, 0.3432676438052227, 0.42485418733169267, 0.3310686837418808, 0.318919538085327, 0.34545065038772216, 0.35888096394627755, 0.371650917048727, 0.36759379789443714, 0.3508297531100476, 0.5273639774078176, 0.4454202343663397, 0.47329869802347424, 0.42654559855927643, 0.4374696912780145, 0.4623604859941365, 0.5623924741373492, 0.5361335576061463, 0.5294772601774658, 0.14706646727084427, 0.11506815609888377, 0.07042595139774366, 0.12292137746244913, 0.18421762612391224, 0.15043707933455175, 0.14877565730022946, 0.11732617629032516, 0.14845941229744786, 0.26188674854753713, 0.2778139965350028, 0.3139645707081866, 0.2889005000907734, 0.27027305731072604, 0.28345641624921014, 0.2883770142691445, 0.29640095887758466, 0.29042601632249365, 0.6596854280421163, 0.6787353344537501, 0.6701701681500667, 0.6490336573758022, 0.6593954471404173, 0.685200211327087, 0.679417650964362, 0.6626928250833463, 0.6846085367079533, 0.08998599963758913, 0.0988442678029412, 0.12746611021808185, 0.11290187201148438, 0.11677485804073562, 0.1088201955777226, 0.10318401321454129, 0.11058436492516488, 0.11513396086947991, 0.1733112698175362, 0.1858031423300739, 0.19518283080098553, 0.21171156155285176, 0.219985181379587, 0.18615375284128122, 0.16574678223209116, 0.1640862024292492, 0.19453850694331964, 0.3559819220495668, 0.39506089862280425, 0.40786671519551243, 0.4194281187192236, 0.386976952990425, 0.39405016205077414, 0.3952507446030531, 0.4365743538207293, 0.4128635267810038, 0.3210725857201874, 0.2947610576021914, 0.32067310091430146, 0.2974153004523822, 0.3099701673407036, 0.33496389764471246, 0.328899544356547, 0.3384664491876769, 0.3371347880729505, 0.18887967127054028, 0.18204036857367867, 0.183967969302003, 0.19642426661666412, 0.1861584971450394, 0.19224706226304178, 0.184154223739889, 0.203857528004037, 0.22735027281505327, 0.46375626010768844, 0.31002350521822586, 0.35689677694616073, 0.5382018034086334, 0.3658221197787195, 0.28908890173924806, 0.19359787487136815, 0.3433505063792439, 0.4596587888441497, 0.7560476888869664, 0.729347950061431, 0.720547016515672, 0.7432777593544613, 0.6505214339779668, 0.1923743550711653, 0.8246963551027706, 0.16942986534496962, 0.801197108877514, 0.7710995361871438, 0.20952293967557745, 0.7523804759291092, 0.19682028079177738, 0.6595429830586547, 0.5949825919727693, 0.7122518327151999, 0.20482453857046523, 0.21055805291539487, 0.18549438676411, 0.18141653881897823, 0.19299885757966817, 0.2053600759526445, 0.1897702474264229, 0.1915796090546984, 0.18657114726878066, 0.18412939525056404, 0.1846456093263209, 0.09135648684695974, 0.0823166842729266, 0.0819981043603415, 0.08302085360481692, 0.07709760838861202, 0.07368875414099108, 0.07905077809709415, 0.08646401609115872, 0.08724957342199746]}, "mutation_prompt": null}
{"id": "5d0fca86-dcee-495d-8e42-9fa268c3929a", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "d175075b-1c62-4592-a8b8-e59abe2ad33f", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = 10 * dim\n        self.pop_size = self.initial_pop_size\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Dynamic mutation strategy\n                if evaluations < self.budget / 2:\n                    F_adaptive = 0.2 + 0.8 * np.random.rand()\n                else:\n                    F_adaptive = 0.5 + 0.5 * np.random.rand()\n                \n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Adaptive population size reduction\n            if self.no_improvement_count > 5 and self.pop_size > self.dim:\n                self.pop_size = max(self.dim, self.pop_size // 2)\n                self.population = self.population[:self.pop_size]\n                self.fitness = self.fitness[:self.pop_size]\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Enhanced ADELS with dynamic population size and mutation strategy for improved convergence and solution diversity.", "configspace": "", "generation": 34, "fitness": 0.34882261782055246, "feedback": "The algorithm ImprovedADELSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.23.", "error": "", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.741962364985101, 0.7424315067503782, 0.7303128297123935, 0.7534246720886322, 0.7388924474454777, 0.7426490087939963, 0.7402213381847886, 0.7247518440513157, 0.7318991483241807, 0.5090070629608556, 0.5266679280049591, 0.5203639364896926, 0.4740115987300384, 0.5100527624693321, 0.48544473989285875, 0.5205259748905919, 0.526731058839039, 0.5166086865895578, 0.10297435673732269, 0.10428150724877305, 0.11149263921521868, 0.13071923154235954, 0.10166995416303704, 0.12262128009380102, 0.11770048369699693, 0.12159001622374654, 0.13746079618507223, 0.1065567695967371, 0.10892021923899797, 0.11305516450861974, 0.11256274710800407, 0.12420987395361427, 0.10094339329329816, 0.10487728591695489, 0.10892739340517432, 0.10372133895271474, 0.9281570435986428, 0.9129014778082969, 0.9323735117131499, 0.933397395333946, 0.8592012657949293, 0.9300749774012363, 0.9574166896796695, 0.9249466577834761, 0.8896536707710845, 0.3850653970182355, 0.3273419882447751, 0.3298601737378759, 0.41709664193092955, 0.32204792142408356, 0.38741202354557824, 0.37367060257831486, 0.3414014707355759, 0.34024705420849555, 0.7191085706280931, 0.6946773246219511, 0.7081084332603634, 0.7304258036800826, 0.710712246311086, 0.7392745190304291, 0.7112913714729991, 0.7083462292705387, 0.730176681569755, 0.20839086813126007, 0.2995898307774705, 0.22033671927880039, 0.3241852341125294, 0.24841926366884315, 0.1858596589285697, 0.20447919940099013, 0.2563455896597584, 0.2893071815408793, 0.25774039982020436, 0.2847920251992512, 0.2271375627984391, 0.27063420995739806, 0.3209326320492052, 0.24099129412830966, 0.3213526178267644, 0.23194734508780024, 0.2618754421189814, 0.24084120268869513, 0.3112441095950428, 0.31346477899672787, 0.2815171692814975, 0.25770897559354067, 0.2333063500421504, 0.31330543168173364, 0.23524608153902926, 0.2580168763373367, 0.40877483147181404, 0.407454340914444, 0.37956031621435626, 0.4018012058551328, 0.395673222198031, 0.3669675643649132, 0.4150192285258273, 0.40933117049462064, 0.3899354029580687, 0.10446338110093234, 0.13334237218977063, 0.09284316452577601, 0.16960620602294962, 0.14622931850443455, 0.11212637244914891, 0.09491608867892976, 0.10538327155228222, 0.1278175385708994, 0.22532000418115727, 0.2215677397460888, 0.21837656839826158, 0.26059381684037786, 0.23960970385478708, 0.2271244985010229, 0.2429016637354895, 0.22128689981984206, 0.24490854288901154, 0.6116649697773715, 0.6000586034056239, 0.6523326710017593, 0.6012004187689539, 0.5957671462079459, 0.6160645183901738, 0.6067359968607651, 0.5925136276648961, 0.6264765624067892, 0.09206377210321137, 0.10989826087070398, 0.10842972172365228, 0.11285558846045096, 0.09302414861225183, 0.12283300304371314, 0.10124157891443752, 0.12241939665701718, 0.12151226959248562, 0.16235004833822875, 0.16792859616669753, 0.3294788981612502, 0.20742726470093786, 0.1678232165521073, 0.2194999547365294, 0.27341233511693386, 0.1708600598969029, 0.20609463234301817, 0.3344346684086078, 0.34711730531883944, 0.34563707145579214, 0.3352713203509906, 0.3222121419532997, 0.3805939887958343, 0.39513626381851663, 0.3467713656627197, 0.37728745656426466, 0.2784730030628112, 0.28522245120983014, 0.28462174850244626, 0.29171592415562164, 0.26870637988813206, 0.30799872710742415, 0.2829145513304152, 0.30256407162544185, 0.3047469030793062, 0.1951897822022014, 0.18024085669222, 0.18420307524687418, 0.1961053511651777, 0.2008626265527591, 0.20306822028060634, 0.20399105330473177, 0.1947316220126033, 0.19360132734447566, 0.2050982135824967, 0.20608059354387653, 0.21152387303422238, 0.20457932683221292, 0.18593391950459404, 0.2011708330838866, 0.1958890894702494, 0.2020676659865418, 0.21348978391378526, 0.724594068591264, 0.7379273754968383, 0.6376303857084218, 0.18827983011308125, 0.19492437228528448, 0.7700883292278076, 0.8107828528651642, 0.6288497378908733, 0.7138684188394229, 0.6574488350806675, 0.4570987225854747, 0.6450258632275688, 0.2026928234924339, 0.5380957452591548, 0.7314505927189419, 0.20617407268215526, 0.5284419664412041, 0.7181153996367275, 0.19055513361610743, 0.18562036756780986, 0.19786617439289111, 0.18457918615551494, 0.19814422968001022, 0.18668201469958556, 0.17838143460965605, 0.1781339481572911, 0.18926627265922036, 0.07255938442503884, 0.08038547791176776, 0.09156427322581417, 0.08265439917685857, 0.07790090727877508, 0.08303018974138199, 0.07982831499814125, 0.08268403916218536, 0.0766075048833712]}, "mutation_prompt": null}
{"id": "f6abaee5-395d-482a-b24c-2fb8fb30c4d1", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "aa2dbdc6-2e06-4ece-a51d-33483912c3c9", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "ea2af4a9-5ee1-4a0f-aaba-3f6d5d84000f", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "b43c5ac1-47ec-4648-8f35-fdb089fd3622", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "e4bd449a-fd3c-4358-900a-c3b66dd81aee", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                # Dynamic crossover strategy\n                adaptive_CR = np.random.random() * self.CR\n                crossover_points = np.random.rand(self.dim) < adaptive_CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.variable_neighborhood_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def variable_neighborhood_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1 * (1 + self.no_improvement_count), self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Enhanced ADELS with variable neighborhood search and dynamic crossover strategy for improved convergence.", "configspace": "", "generation": 39, "fitness": 0.2587280709568219, "feedback": "The algorithm ImprovedADELSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7112280583883663, 0.7167067813921792, 0.7031095752080032, 0.6994241000356664, 0.6921155820609252, 0.7063699368871538, 0.700820856294813, 0.6851556589080727, 0.6810737790465923, 0.4412967068070238, 0.47427286694098125, 0.4433890646854385, 0.46156730649532496, 0.4370610696543249, 0.42325392167186326, 0.42754376492898116, 0.47841601389716304, 0.4548161317185926, 0.2199889415999995, 0.2585012053891018, 0.2775043687243155, 0.24693846529283026, 0.21087433923792376, 0.18592820786739084, 0.17959623373295985, 0.19367528812820067, 0.15075275589670167, 0.16970058079132833, 0.1720586629571802, 0.1284622979161386, 0.16411069755049035, 0.18184559550339285, 0.1459970862408585, 0.1668428401445361, 0.179887686468848, 0.1379327188221079, 0.9318268480340354, 0.9245902893588951, 0.8924695971356303, 0.9221048171751209, 0.9220226206159241, 0.9068859659680425, 0.9322336841018904, 0.919634961248921, 0.9473703600278093, 0.29634709427090056, 0.2773158744107169, 0.2911685160741976, 0.2765726328036855, 0.24943463899846285, 0.25714799193082405, 0.257546753051877, 0.25180613655991124, 0.2529393792956187, 0.3213564773069143, 0.31025005436890984, 0.2786558829964939, 0.4598785261298609, 0.3013746993784141, 0.4528443325778916, 0.3348208132776823, 0.3770945080209275, 0.31486630318984443, 0.1639187659612158, 0.19268187122436742, 0.1697213622624879, 0.13341761387354056, 0.15741361241239937, 0.17251490133043212, 0.15471824838898773, 0.16928374447937278, 0.1792042747019824, 0.12393002172968448, 0.13521415019518712, 0.18557108459881877, 0.17100742961306592, 0.15972210039177204, 0.14636837655082913, 0.13355983161972185, 0.1640392548281101, 0.19994820969630422, 0.0146227507448492, 0.013166427144592818, 0.025673724699099565, 0.0005700703314658329, 0.01516649837482309, 0.005682633912363455, 0.0117444301018933, 0.008583293203929476, 0.037483625935153086, 0.07794747680544512, 0.10306048733598583, 0.1048162605504751, 0.08007662356426393, 0.10885816618205679, 0.08047636482219622, 0.11718303384919693, 0.13369207174083442, 0.1769095617598868, 0.004743538009237325, 0.01877214670633298, 0.015822057850515603, 9.999999999998899e-05, 0.019914436160423987, 0.016408607402825126, 0.006715732518001505, 0.0029886655035447074, 0.01347565305125098, 0.11196032952504154, 0.10277054552815656, 0.12128314205590163, 0.12144930473731363, 0.14457570280412713, 0.1339836642762099, 0.11172015097988619, 0.10642108865160593, 0.1180755831734065, 0.4669662298130086, 0.4582895789938283, 0.4643061506595234, 0.4739213777907407, 0.4770391084223894, 0.4622704541317759, 0.4683212234935026, 0.46537816025650613, 0.4775674357666837, 0.09364154605808561, 0.09276793112326209, 0.09189266339417523, 0.1053386876925011, 0.09226068325787617, 0.10355022313061746, 0.09775107190092314, 0.10259143178476493, 0.11084118419943811, 0.19143547126100524, 0.15015871995641594, 0.20801100151003837, 0.17125044148184276, 0.18782055568593337, 0.20641223217694715, 0.1843616308146091, 0.2508567958689947, 0.23276652866728575, 0.27998679666368875, 0.28187879317262654, 0.2867210812973542, 0.27535359560350736, 0.2675624079430271, 0.32271070178212546, 0.3138306833188883, 0.321464027453195, 0.31580393950596386, 0.21776380524141692, 0.20069757093645513, 0.21058525250083038, 0.215635682530827, 0.2000007551416113, 0.1879495829939879, 0.22250207523085297, 0.2250371894498101, 0.22222885318981145, 0.18799608498097053, 0.1861944046230265, 0.17222747130441074, 0.19268991778486155, 0.19026392782851898, 0.19536735754307377, 0.1802711759626483, 0.23476663506602258, 0.19822680075245558, 0.21148765336329667, 0.20437038257421503, 0.22668419454013977, 0.19725435270558145, 0.2178751827876133, 0.2226758937507891, 0.23020682814101867, 0.20380291392840533, 0.19952914859811643, 0.39206530393694417, 0.41073486203233056, 0.38634139739838225, 0.48196186871990343, 0.49546250310613515, 0.31458505268059456, 0.2772235632871025, 0.3224643440376187, 0.3418314956344466, 0.40210344531494424, 0.25512591449433275, 0.25136144523791126, 0.18929618316673846, 0.1887676969657025, 0.30525865588831724, 0.19510275492358475, 0.201924825403499, 0.1946992373228389, 0.18124479084267275, 0.19536627057656775, 0.1792675806580719, 0.18696594353828266, 0.19686534146442114, 0.17931078358599806, 0.190036379334251, 0.1848253673869632, 0.18780862345826743, 0.08968481719441168, 0.07537278617517984, 0.07811836232880709, 0.08009510738282266, 0.0749077564050814, 0.08209679049155472, 0.07259924765471137, 0.08261871201201143, 0.08648886770256525]}, "mutation_prompt": null}
{"id": "c55a09e4-d1d1-481a-a01b-481f1ba04ed6", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "6cec6b08-bf43-4448-bb5c-6d60de670442", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = 10 * dim\n        self.pop_size = self.initial_pop_size\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            dynamic_pop_size = max(4, self.pop_size - (2 * self.no_improvement_count))\n            new_population = np.empty_like(self.population)\n            for i in range(dynamic_pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                dynamic_CR = self.CR * (1.0 - 0.5 * np.random.rand())  # Dynamic crossover\n                crossover_points = np.random.rand(self.dim) < dynamic_CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.pop_size = dynamic_pop_size  # Update population size\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            if self.no_improvement_count > 5:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_pop_size, self.dim))\n                self.fitness = np.full(self.initial_pop_size, np.inf)\n                for i in range(self.pop_size):\n                    self.fitness[i] = func(self.population[i])\n                    evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Enhanced ADELS with adaptive population size and dynamic crossover for improved diversity and convergence.", "configspace": "", "generation": 41, "fitness": 0.3002512930860066, "feedback": "The algorithm ImprovedADELSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7638128929889137, 0.7296640936031316, 0.7663333923264101, 0.7657253525951947, 0.75123119959003, 0.7509827442400732, 0.757118292218752, 0.74413012178977, 0.7497703738144232, 0.5940680589213923, 0.5554397212172446, 0.5733543980934298, 0.5950709676647958, 0.5766772692510436, 0.5450040161191083, 0.5717695177326949, 0.5798555891829625, 0.5580972629809914, 0.23748086057927487, 0.24223956322973395, 0.1472370163735517, 0.18050785772297673, 0.16022780973305673, 0.1996431006951167, 0.21956717347885946, 0.25972460112996887, 0.21427619072328064, 0.12820002997273228, 0.13407937614806031, 0.1550688284036833, 0.20111584240025904, 0.12897214573820015, 0.19286798202968836, 0.14639950420006298, 0.17205167966351131, 0.14083122007212223, 0.9410087467743479, 0.9335359552225501, 0.9281703258762647, 0.9440583205941537, 0.9181711695407477, 0.9352923358352614, 0.9089365653885882, 0.9347999149223101, 0.9408855226524613, 0.3483935119822378, 0.34993951024011605, 0.288239325654554, 0.37863358160249616, 0.3387987053568755, 0.34566231762177735, 0.35648194333991357, 0.34538517973592897, 0.3552947658313126, 0.5832928708676397, 0.5120208082757822, 0.7153052243987648, 0.6227058999131696, 0.5725748665264305, 0.6537403414570786, 0.503410193959945, 0.6289596531423777, 0.5656484040703644, 0.16068781781630603, 0.1994207399995026, 0.20071804714369534, 0.1770496212981183, 0.14900423855305667, 0.1678350021566425, 0.17640974400506493, 0.18733081020325404, 0.21377331537139466, 0.1808376326960317, 0.1075311457855147, 0.16959323406160742, 0.1703450111674032, 0.17435277683545336, 0.14147948255213583, 0.180929863826906, 0.17772913444185034, 0.18881891175263177, 0.08473584020983238, 0.06856809516608575, 0.07758682827948071, 0.0794440479769597, 0.049888353462139046, 0.03604479001503802, 0.06654437595025064, 0.09324072433933683, 0.07904429084533382, 0.2026362626528474, 0.1973670898616947, 0.17278607383545186, 0.20354007818067643, 0.16782174094093005, 0.16594566610646122, 0.20255617611426302, 0.18970315562482343, 0.19869651336205585, 0.05767468661284891, 0.05217894592291994, 0.011439100137309643, 0.06233809609156904, 0.04272882117864152, 0.015102611133570254, 0.07013484640891599, 0.04698983291536318, 0.05049184986416788, 0.16229841977157433, 0.15445385187499594, 0.14979069199064, 0.1896269087412873, 0.1998101696727803, 0.18521103732390476, 0.16303262285381448, 0.17636137930385232, 0.15443776497519934, 0.535902650901678, 0.5583385061182273, 0.5065966838441418, 0.5378629309576107, 0.515424801329563, 0.5077716212309633, 0.5507447310078111, 0.49930251622461364, 0.5260527734691938, 0.1026721433445924, 0.12106535798312557, 0.10249338627236249, 0.1067653743967798, 0.10230220125638934, 0.08850682704031299, 0.11899856998686487, 0.11578873503527498, 0.0986478783878576, 0.13934794761755043, 0.20436592753810023, 0.14796658257824058, 0.1746323159347316, 0.19491491106614633, 0.19205151022462186, 0.16407607703761096, 0.16185191240455787, 0.19183064823596818, 0.32913776849110477, 0.33757839476290474, 0.3231789398107864, 0.32020558186293024, 0.33533680772350194, 0.33199031060988304, 0.38214034812734377, 0.3876913015323765, 0.37447015171740183, 0.2659750187104871, 0.22737091487406147, 0.2504564609436102, 0.2275447676953395, 0.2452114539856528, 0.23114156476454628, 0.29099904588512127, 0.2407528310596424, 0.28468439350225827, 0.2111851859361462, 0.19477818230011623, 0.19537605806752933, 0.2065960918751777, 0.18651428992204877, 0.2021055224914876, 0.2039195981020374, 0.1905997818699433, 0.2307241834487067, 0.25932120946535375, 0.22455069234592595, 0.2029550122437288, 0.20564487420125532, 0.21756084039032142, 0.22352872330862605, 0.4630056126504284, 0.22417119840667443, 0.24157040808156505, 0.6253521051303806, 0.18425153295246965, 0.19763350916091593, 0.7040707599105248, 0.5708912436986788, 0.4687536741777075, 0.17869693129462916, 0.1689745240531887, 0.18392256078064806, 0.5313913461484089, 0.20292888408251353, 0.39716856572210646, 0.20615830908045119, 0.19441749888899296, 0.27014544088223647, 0.467700149261284, 0.20204958201349932, 0.4976282966287625, 0.1881212446977213, 0.19159820705209507, 0.16789340227569138, 0.1810530097116705, 0.21379342510391053, 0.19168055442168297, 0.18459148866218633, 0.1748911560280132, 0.19724171780883604, 0.0844413776947407, 0.07631500247103018, 0.07830923106847676, 0.08117958716672913, 0.07216814091510682, 0.09516184361874624, 0.08572590782282863, 0.0812002929810467, 0.07848948384706744]}, "mutation_prompt": null}
{"id": "09c5f488-60c0-4953-b09c-03f8c11fc711", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "6beddfb5-5e97-4bc9-84d0-a78e86e4f94b", "solution": "import numpy as np\nfrom sklearn.cluster import KMeans\n\nclass EnhancedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Adaptive mutation based on clustering\n                kmeans = KMeans(n_clusters=3).fit(self.population)\n                cluster_indices = np.where(kmeans.labels_ == kmeans.labels_[i])[0]\n                cluster_fitness = self.fitness[cluster_indices]\n                scale_factor = np.min(cluster_fitness)\n                F_adaptive = 0.1 + 0.9 * (scale_factor / np.max(self.fitness))\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n\n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedADELSOptimizer", "description": "Enhanced ADELS with adaptive mutation, hierarchical clustering for diversity, and improved local search for refined exploration.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: ModuleNotFoundError(\"No module named 'sklearn'\").", "error": "ModuleNotFoundError(\"No module named 'sklearn'\")", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {}, "mutation_prompt": null}
{"id": "ca37c825-a92d-4baf-b14f-2cd7f5925860", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Dynamic mutation strategy\n                F_dynamic = self.F * (1 + 0.5 * np.sin(0.1 * evaluations))\n                mutant = self.population[a] + F_dynamic * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Fitness-based re-initialization\n            if self.no_improvement_count > 5:\n                worst_idx = np.argmax(self.fitness)\n                self.population[worst_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[worst_idx] = func(self.population[worst_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Enhanced ImprovedADELSOptimizer with dynamic mutation strategy and fitness-based reinitialization for better exploration and convergence.", "configspace": "", "generation": 44, "fitness": 0.3599458610839585, "feedback": "The algorithm ImprovedADELSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.24.", "error": "", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7527926130936147, 0.7561824604296595, 0.781694563168766, 0.7551815548433225, 0.8055047123386423, 0.7776383783778796, 0.7884755373637908, 0.7880748444403968, 0.771488364190673, 0.6131531937400136, 0.6032424060577561, 0.5816224309170113, 0.5888378191121247, 0.5900428720042901, 0.6273187024698331, 0.613610965215442, 0.5688942236151485, 0.6023545572088449, 0.10645916826463198, 0.12629722088436246, 0.10758256939738609, 0.12584321160151435, 0.11484853895727742, 0.11222015407809027, 0.12952251218501554, 0.1184516618551048, 0.11427598634589153, 0.10460053493587151, 0.12390034350908186, 0.1043454273164307, 0.1250733383187579, 0.09754123978236384, 0.1096556761143962, 0.12147932674932305, 0.10428140250710605, 0.09740407498270487, 0.9269968858753949, 0.9325812154281161, 0.8817940032643602, 0.9156222424808188, 0.8128245024442968, 0.8607219412715711, 0.8986615599225836, 0.8702180782696323, 0.904157051779122, 0.38492402826709604, 0.4435671996177907, 0.44371841179318683, 0.45158190194383685, 0.4322295098345472, 0.46305919234873416, 0.42925391431233384, 0.4296736268957776, 0.44090382878343803, 0.7956308350447401, 0.762988399994797, 0.7600907619614037, 0.8089315924025753, 0.7773470139307753, 0.7605078219237611, 0.7611427556202999, 0.7840302621812547, 0.7609155065429669, 0.1822325800371114, 0.2245101089229362, 0.2131103779816027, 0.25328443753966023, 0.4083069506753273, 0.30306795381682783, 0.19140376209357346, 0.3756313275702424, 0.15388198142989407, 0.16609018877189152, 0.19249939197356347, 0.14787159768895908, 0.2842424030914862, 0.1738100577112509, 0.25047871051893567, 0.19882515768154152, 0.2865973640830425, 0.22231114162908117, 0.322763527848663, 0.38176070844126175, 0.373475460956181, 0.414153176192282, 0.3608139985276254, 0.39681103767760506, 0.40128662744231525, 0.3675731745844282, 0.3832534380234712, 0.5055051963259661, 0.549175364171256, 0.504007876653849, 0.2463612280719505, 0.5110989677632882, 0.4869489903908216, 0.5786443420767935, 0.5595324421909377, 0.5055222008544392, 0.11063073666885426, 0.0821901059579504, 0.22899592642411415, 0.25311072355859854, 0.13027392778073177, 0.2717472144700056, 0.21212480663209266, 0.12761414532075, 0.14026620549361413, 0.284932324608952, 0.2971952189629833, 0.3358251394353573, 0.3470562861351204, 0.3013752862436846, 0.2966156252159784, 0.3001034421619312, 0.2819580815896384, 0.32465852674886186, 0.6655901215217436, 0.678717206976449, 0.6577299635318254, 0.6780832614061939, 0.6660298726438403, 0.6841842027987688, 0.6947127475125363, 0.6470078915846704, 0.6867982440962634, 0.11256947524983663, 0.10173676266343101, 0.1074532263500334, 0.11835199530706997, 0.1315909421595126, 0.11193967036507124, 0.11392597897939305, 0.14440914441829422, 0.11361754002062185, 0.17695022463683852, 0.20825477254909752, 0.2115346508403917, 0.19216684626035585, 0.20475398981668125, 0.2249714371294188, 0.17179554116572016, 0.21147997673443264, 0.20043417286546972, 0.4201928099796758, 0.413200603306218, 0.4257674547249808, 0.42537755149807566, 0.4085132215411923, 0.3943586285190671, 0.4274546819933137, 0.44422498783107633, 0.43763974550748397, 0.34115475826765285, 0.31101575770256584, 0.34730633234966757, 0.32384287752800023, 0.32001266615519586, 0.31691052402191966, 0.33094063658212214, 0.3409282463059752, 0.3608783927200301, 0.18717351564987428, 0.19456792178305427, 0.18450829304353178, 0.20147937714361153, 0.2088087468828056, 0.22687330631375502, 0.20726963639739926, 0.20021400597458716, 0.2023412068618452, 0.21026602467135402, 0.24391439121453062, 0.2013017199508801, 0.2183269679518558, 0.21961110139195905, 0.2120665479970707, 0.27728577688596234, 0.2907007602438373, 0.23355402824570892, 0.19045438237104984, 0.190815878994949, 0.185705977210037, 0.17380205324214804, 0.6439161160155795, 0.194622814545784, 0.7625364553876525, 0.6703721979688655, 0.7180265434653181, 0.6898111672537909, 0.20866481145700033, 0.1986672700388713, 0.20780562430759286, 0.20487980350642576, 0.16713169430493235, 0.14901554141665807, 0.20464376933206163, 0.20944766344136367, 0.1986158942191114, 0.18331801100729683, 0.1812725314207171, 0.17643155314507553, 0.18204155583750103, 0.18896494586637302, 0.18113130278035705, 0.18243101682354357, 0.19442244553599963, 0.08430906853258491, 0.09084385018581886, 0.08477250544375547, 0.08980002074373938, 0.10136141173120727, 0.07741402386996721, 0.08331983391257802, 0.08146739790196189, 0.0818121908685655]}, "mutation_prompt": null}
{"id": "18e8a397-f511-4387-83c1-810a632af8bd", "solution": "import numpy as np\n\nclass EnhancedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = self.chaotic_initialization()\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def chaotic_initialization(self):\n        chaotic_map = np.sin(np.linspace(0, 2 * np.pi, self.pop_size))\n        normalized_chaos = (chaotic_map - chaotic_map.min()) / (chaotic_map.max() - chaotic_map.min())\n        return self.lower_bound + normalized_chaos[:, None] * (self.upper_bound - self.lower_bound)\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                self.CR = 0.9 * (1 - evaluations / self.budget)\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedADELSOptimizer", "description": "Enhanced ADELS with chaotic maps for population initialization and adaptive crossover to improve global exploration and convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('boolean index did not match indexed array along dimension 0; dimension is 1 but corresponding boolean dimension is 5').", "error": "IndexError('boolean index did not match indexed array along dimension 0; dimension is 1 but corresponding boolean dimension is 5')", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {}, "mutation_prompt": null}
{"id": "c3f9a2be-12c3-4466-b233-4d8b403b1833", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n        self.best_fitness = np.inf  # Track best fitness\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                    if trial_fitness < self.best_fitness:  # Update best fitness\n                        self.best_fitness = trial_fitness\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.adaptive_local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            if self.no_improvement_count > 5:\n                diversity_boost(func)\n                evaluations += self.pop_size  # Assume diversity boost re-evaluates the whole population\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def adaptive_local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1 / (1 + self.no_improvement_count), self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def diversity_boost(self, func):\n        mean_solution = np.mean(self.population, axis=0)\n        self.population = np.random.normal(mean_solution, 1.5, (self.pop_size, self.dim))\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Enhanced ADELS with adaptive local search and diversity boosting mechanism to improve convergence and prevent stagnation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'diversity_boost' is not defined\").", "error": "NameError(\"name 'diversity_boost' is not defined\")", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {}, "mutation_prompt": null}
{"id": "6e35c1bd-722c-4e21-bf57-4659fc3f47e9", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "497637fd-f119-48cf-aae3-f0f8af25db3e", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "0481a001-e5be-4176-96cc-997324d50bd8", "solution": "import numpy as np\n\nclass EnhancedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n        self.memory_F = [0.5] * 5  # Memory for F adaptation\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # F from memory\n                F_adaptive = np.random.choice(self.memory_F)\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                    # Update memory\n                    self.memory_F.append(F_adaptive)\n                    if len(self.memory_F) > 5:\n                        self.memory_F.pop(0)\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            if self.no_improvement_count > 5:\n                tournament_indices = np.random.choice(self.pop_size, 3, replace=False)\n                worst_idx = tournament_indices[np.argmax(self.fitness[tournament_indices])]\n                self.population[worst_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[worst_idx] = func(self.population[worst_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedADELSOptimizer", "description": "Enhanced ADELS using memory-based adaptation and tournament selection for improved convergence.", "configspace": "", "generation": 49, "fitness": 0.3766334379065726, "feedback": "The algorithm EnhancedADELSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.24.", "error": "", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7700366397624604, 0.7780574845023256, 0.766292042384254, 0.7711286969791645, 0.7480297459472285, 0.7901304173526724, 0.788790098804917, 0.7819733834697431, 0.7879047655026497, 0.5818235740994254, 0.6214182908758239, 0.6056299173314064, 0.5785831472527232, 0.5991386354708856, 0.5990110147422028, 0.6071144583384573, 0.6048054430526346, 0.600003252309306, 0.11637344580032893, 0.149998458306555, 0.10591398015533682, 0.11396925030959737, 0.11022493242607756, 0.11806987532091773, 0.12148039853805326, 0.1103585383188802, 0.13005281114946066, 0.11323554909081901, 0.1049457674449017, 0.10312651279510121, 0.10510094860959229, 0.10214389228027665, 0.11120686127384416, 0.10976683343045801, 0.11204712473241174, 0.11261765266328716, 0.9144791769374145, 0.8446706277007029, 0.8872401991649426, 0.8804372601305545, 0.9340487740060212, 0.8145941514448047, 0.9559384156678387, 0.9279800671436339, 0.8488446490997413, 0.43282223750109383, 0.4173001269155284, 0.40786380939622524, 0.483450563946363, 0.38971321704281936, 0.4595153240744534, 0.38251879208857, 0.4314205977126572, 0.47402330175087115, 0.7317714452275756, 0.7594008755468811, 0.7289101419064112, 0.765605619705702, 0.7585456459507206, 0.7608798900888105, 0.7302545193761206, 0.7812993986551336, 0.7431801576136982, 0.1843329038346634, 0.25250241326962664, 0.1988327087363576, 0.1646490700008464, 0.16332402790118594, 0.3591338000117965, 0.1605669459422464, 0.2369701038959211, 0.21695092871461863, 0.23814469208146816, 0.4145305557986718, 0.2063203869649768, 0.42358398558521115, 0.37380837742368545, 0.22130477672879156, 0.19567821008067798, 0.19040525602930047, 0.20554572786817038, 0.3868023374485524, 0.3368333631051812, 0.3680602637210484, 0.3707809522665588, 0.3766995967429627, 0.3408545408731204, 0.3873498375730985, 0.3825985374038352, 0.3557826175736184, 0.5097418942430313, 0.4642107658313527, 0.4892099922421409, 0.5225366230711059, 0.5400939068808635, 0.4547624627793718, 0.526926230704279, 0.5204975391034388, 0.4867202643030655, 0.08074368165437684, 0.1909831764321006, 0.19394224077375122, 0.2088591530665025, 0.20423428503488372, 0.21707225768123395, 0.11288279726883577, 0.12828296636366, 0.1347107979601757, 0.28384390648520597, 0.3226077447732214, 0.26941161328996455, 0.2932922529339258, 0.3240937095250057, 0.3245128392481459, 0.2821494104992096, 0.2747909754911927, 0.2778021355385101, 0.6756693507617653, 0.6993725957526276, 0.6904509537777483, 0.6929064202045894, 0.6881862130983807, 0.6891623379232142, 0.7053605563479759, 0.673177237601794, 0.6754450775744839, 0.11125745837373724, 0.12124806318467729, 0.10689343390582184, 0.12010741259724367, 0.10206153736237067, 0.10437807671679344, 0.11758231135303832, 0.09366754044503489, 0.10304471786783198, 0.18422504757231184, 0.16060105907740108, 0.16283176232175667, 0.17757167705036758, 0.18018407894298927, 0.21212907522596547, 0.20138845316986675, 0.30178537637952707, 0.23440096815504607, 0.4009763749466263, 0.36971679116511214, 0.3882343795820258, 0.42997992734253687, 0.36744946861431205, 0.39845492988118114, 0.45776470811359193, 0.41301556962195607, 0.39689086777113125, 0.29419922011554145, 0.3223174987077322, 0.3262635636476805, 0.320604531744777, 0.31498283821026374, 0.3268722793494572, 0.33453471235910703, 0.33884666886730586, 0.31128639415814996, 0.23387814917576566, 0.2064066182563037, 0.19661650388099416, 0.20617729425407527, 0.19738599880576213, 0.17651775854292695, 0.20993073938993312, 0.20581237466946645, 0.20989009770583522, 0.20985120947268765, 0.24356805955193328, 0.2515979017937119, 0.20750545621362848, 0.194714289454622, 0.21566146410541553, 0.184792031352924, 0.1935643917560037, 0.18218608376447676, 0.6385331218635314, 0.687151893438301, 0.7448919875098126, 0.5909304216998417, 0.7211633331542566, 0.6227972711273184, 0.6640649326420908, 0.6817182659721108, 0.7105396197604495, 0.7287299864763992, 0.20046039759697176, 0.4917926630994819, 0.6996682862410026, 0.2673875308073387, 0.21492830227444826, 0.20919620072540424, 0.6962251360718739, 0.6845135974427522, 0.1872635763175533, 0.18052051830866933, 0.18881730777062644, 0.18502113038515278, 0.19110026917797795, 0.19008250128900595, 0.19782581202950256, 0.18498263325447284, 0.19151928644823946, 0.0812854544514865, 0.07952855379643875, 0.0794242070228447, 0.0879196771287758, 0.08218069327432109, 0.07740717646271966, 0.08667239358434087, 0.09126001007039908, 0.08330713268024681]}, "mutation_prompt": null}
{"id": "96ae9cc1-ecde-4209-9700-7bbf69b4e03c", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                # Dynamic crossover probability\n                CR_dynamic = 0.9 - (evaluations / self.budget) * 0.8\n                \n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < CR_dynamic\n                trial[crossover_points] = mutant[crossover_points]\n                \n                # Lévy flight-based mutation\n                if np.random.rand() < 0.1:\n                    trial += self.levy_flight(self.dim)\n                \n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def levy_flight(self, dim, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, dim)\n        v = np.random.normal(0, 1, dim)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Enhanced ADELS with dynamic crossover probability and Lévy flight-based mutation for improved exploration and exploitation balance.", "configspace": "", "generation": 50, "fitness": 0.27531629312799333, "feedback": "The algorithm ImprovedADELSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7603332844578163, 0.7209947446891147, 0.7249390914805622, 0.7646569389918147, 0.7199365896251412, 0.7414471066087913, 0.7523921706083591, 0.7676093745583195, 0.7348369270539814, 0.5164639283427346, 0.5235310528856745, 0.5081130787532749, 0.5043312748923725, 0.5336947156128184, 0.5507193565107642, 0.5501462645138899, 0.5056051941452747, 0.5227418356954348, 0.20227012084306684, 0.2287398640207854, 0.2204476568065441, 0.1867199087898207, 0.22951492379363836, 0.21400652194544334, 0.20975451949099155, 0.27667467989668093, 0.1787955219868823, 0.18488240261743072, 0.15511208410577582, 0.17794692122773503, 0.17309633086479626, 0.15857848617739279, 0.18543026169158527, 0.16109495594073397, 0.16472357899852774, 0.16808759471719803, 0.9444890870851118, 0.9172316257474097, 0.8843220556024263, 0.9390387978162125, 0.949036643745245, 0.8560841378359327, 0.9437121514605209, 0.8974490760372567, 0.9395039261605147, 0.28842927605249347, 0.3136445859301049, 0.30753860323055604, 0.3103668722100297, 0.3111338246594524, 0.33027132955440897, 0.28328784788616745, 0.28476689781507947, 0.28375861854111484, 0.2962275896862151, 0.5232886307289282, 0.34886249379618617, 0.7918960363619261, 0.34155977482472777, 0.550158942305093, 0.33468499615293656, 0.5993289688055234, 0.3320925360825223, 0.15786590192216698, 0.14618390923909608, 0.1793141272143114, 0.17001761593672604, 0.17176105919385043, 0.15673848238416144, 0.16717105379539554, 0.16411396679084522, 0.1712338035792501, 0.15214455445169628, 0.11389562983617085, 0.15730442825548874, 0.16137294661989632, 0.1368810393234231, 0.14853736040883192, 0.1791210030014012, 0.15747577187277406, 0.16463469061004377, 0.015244975167728936, 0.0042204390361016975, 0.021635870714670102, 0.019974143877842465, 0.035898603846722055, 0.000356825453592835, 0.01857822851453328, 0.01737891469104924, 0.028700529071311265, 0.15085530056818297, 0.1614282929326537, 0.13599397392650026, 0.15557823085709932, 0.1268206906663898, 0.18751413104380288, 0.194908572205171, 0.1233890064341473, 0.15398645734136385, 9.999999999998899e-05, 0.008514585452954582, 0.008089063596587787, 0.020888115281321173, 9.999999999998899e-05, 9.999999999998899e-05, 0.01333221759289227, 0.004734548608753331, 0.010640514218313024, 0.14618125302535756, 0.1187906774376486, 0.11672866213662925, 0.12477915045532917, 0.1362266757051781, 0.13392469595514034, 0.10184316887716871, 0.12927633478632905, 0.12652721653253152, 0.4709528552547636, 0.4917475344174347, 0.46939825702103033, 0.4605983467577006, 0.4607794257578327, 0.4520647378229824, 0.48612240635143744, 0.46840392344653226, 0.4582193039804253, 0.10004154323637082, 0.10566319223650567, 0.10406494607515338, 0.10072445540230823, 0.09444684155441518, 0.10474216555666682, 0.10977301862178357, 0.13991858028093118, 0.11251398052315487, 0.20833214139572587, 0.27122495716445205, 0.1707963207439177, 0.19015454500487028, 0.18870065963038218, 0.19389796517236535, 0.19084128270461342, 0.2244509625365646, 0.16947509410277384, 0.3014857851570617, 0.3165503455636882, 0.3011575121295854, 0.3151603562516839, 0.33739408012333716, 0.34922335923856374, 0.334080786802069, 0.33216763926273796, 0.35097633109885684, 0.21917422534409603, 0.23587879769715414, 0.23098884026582323, 0.25430546230458617, 0.21660793705180081, 0.21808300169572337, 0.256667846429692, 0.2533427228650167, 0.22216028538980404, 0.18887746940083672, 0.1967022624504806, 0.18852919073355456, 0.20468467645666777, 0.19335000530839896, 0.19526329162356348, 0.1960583637070673, 0.185836076624336, 0.21419683949106716, 0.2747956027162666, 0.22400991545385018, 0.18696805944285166, 0.2795456612615287, 0.21261161913695836, 0.21563784912745865, 0.23766522653485134, 0.22556113389544374, 0.26017825144918794, 0.1711598031441488, 0.1902663749253073, 0.5224988510331936, 0.7404544660723764, 0.24154475809417708, 0.17853427594392834, 0.585126842927978, 0.33945810798862674, 0.5264095277666481, 0.36240099893460065, 0.2934394093591677, 0.21636345458675554, 0.28110534402930454, 0.16817152913557898, 0.16795889000420317, 0.20675330086106136, 0.20300177776194062, 0.15209007115012851, 0.18774843329977908, 0.1897372305450432, 0.18501373218078865, 0.19272145407278019, 0.18749495952641615, 0.17877005505743349, 0.19583537385733518, 0.18517429959452503, 0.1917778404611361, 0.08052011879963827, 0.08398531969821765, 0.0824095660289782, 0.07886255510206097, 0.07711277939556116, 0.07468899797795525, 0.07765072833964226, 0.08145118075169444, 0.07715865509791398]}, "mutation_prompt": null}
{"id": "2d88e69b-98ff-4589-8fe3-fdc28ae0a7c3", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "e3c9c712-d2fc-4ccf-98a2-ccb0f1dbe277", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = self.init_population_with_chaos()\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def init_population_with_chaos(self):\n        # Use a simple chaotic map for initialization\n        chaotic_sequence = np.zeros((self.pop_size, self.dim))\n        x = np.random.rand()\n        for i in range(self.pop_size):\n            x = 4.0 * x * (1.0 - x)  # Logistic map\n            chaotic_sequence[i] = self.lower_bound + (self.upper_bound - self.lower_bound) * x\n        return chaotic_sequence\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                \n                # Adaptive crossover probability\n                CR_adaptive = np.random.rand() * 0.5 + 0.5 * (1 - evaluations / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Enhanced ADELS with chaotic maps for population initialization and adaptive crossover for improved convergence.", "configspace": "", "generation": 52, "fitness": 0.29278717731360626, "feedback": "The algorithm ImprovedADELSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.765744460667561, 0.7788536560652097, 0.7681844424836647, 0.7526803570200618, 0.7501924102455235, 0.7482104953799878, 0.7835905862781278, 0.7445893518677601, 0.7646427539237335, 0.5587430827888159, 0.5605016224642486, 0.5889657088500208, 0.5796654523867677, 0.5758076083639228, 0.5373159636012581, 0.5442321715235069, 0.5956471132401087, 0.5516312722052676, 0.2591067949837472, 0.20232963163363105, 0.19597318418344034, 0.21967358656981362, 0.21758792752196943, 0.2053029970647139, 0.23054977832291557, 0.21979071105641124, 0.2448997078144326, 0.15566161766529107, 0.20201282245429242, 0.21101328009367493, 0.2050058593579709, 0.19928638263588805, 0.1916858372056519, 0.18264270535793403, 0.20869269091564235, 0.22499490829295432, 0.9301653049656433, 0.9478568892628344, 0.9666388451018058, 0.9333825881519153, 0.9257455269437159, 0.9247380717295484, 0.9020759365499023, 0.9398930053654743, 0.9434645818571942, 0.29093841793186526, 0.2646245030440334, 0.2909534652079716, 0.31638723739938124, 0.3008670082120124, 0.33867994678010505, 0.2864438632442735, 0.31255386239985605, 0.28981553340335464, 0.32147584572223564, 0.34956788566636376, 0.2882278584192042, 0.3658763734221908, 0.6118482699109971, 0.6073084114954915, 0.5765493890884262, 0.6008932312930264, 0.41748590039686817, 0.16811624854467666, 0.15799673996066999, 0.17938174386505468, 0.19789766116379393, 0.18200258265562963, 0.1667365142040691, 0.1753821810987083, 0.20366568557215103, 0.20143411840302028, 0.2253984938941267, 0.2064785469015067, 0.19114560660296276, 0.19936481348412594, 0.18411859892412996, 0.14380440442958609, 0.19474694336122023, 0.21171532455366504, 0.20975786331749313, 0.05957746310510137, 0.002452705961740631, 0.029637702819822476, 0.014519429724988764, 0.011300128287938804, 0.02209972886416689, 0.03932449337767907, 0.04674803433526198, 0.06853627621518477, 0.1050725480958501, 0.12388730570670159, 0.16593040997420216, 0.11423269509964595, 0.13647694487781614, 0.12130567926590252, 0.17063358193745803, 0.14304497180724063, 0.18964771283846582, 9.999999999998899e-05, 0.004485784321944797, 0.005180239623539973, 0.04183752439225208, 0.011892794231189274, 0.0002402899074864795, 0.025345909237477815, 0.007363056041119642, 0.011568975218860578, 0.12142216362175862, 0.11475996595649796, 0.1311400508584436, 0.1254744106824417, 0.1390697152480388, 0.14247555685468127, 0.12488053410926836, 0.10886254455504618, 0.12300467305519236, 0.48578796886551356, 0.518763163644154, 0.47776194655580306, 0.4820239255509383, 0.47471647099055225, 0.47618027568206756, 0.49026586112667125, 0.4862208825688249, 0.4821532046875735, 0.1091565022736104, 0.11288449208545537, 0.09112706198125253, 0.11232467541145374, 0.1201736914698287, 0.09485680199520596, 0.09631594094495921, 0.10212604599532404, 0.10798912927840976, 0.18554346778622943, 0.15280607598910279, 0.17718668745229937, 0.18762045339040512, 0.2278979387115263, 0.23907885294314368, 0.17563359999980255, 0.18807257770163344, 0.18101333998537705, 0.30521297605065056, 0.29960968598761073, 0.3421658846476975, 0.35286434035088754, 0.3463433621640979, 0.3325471475076778, 0.33265345823188985, 0.30598275065669456, 0.33577573846539244, 0.20313072598728887, 0.208397076010705, 0.23706435472255427, 0.23356843484581746, 0.23841230099405175, 0.21725448972977401, 0.24486053100368343, 0.23383934257857575, 0.2397488020202836, 0.2052319044331834, 0.21123773121640355, 0.21109643230286235, 0.22837047984726755, 0.21059889950399535, 0.20788273200435003, 0.1987876893969135, 0.23646638776182893, 0.21907267917439976, 0.2223103856844123, 0.2101433865099851, 0.23374713280332227, 0.22871305653235707, 0.24952815833698128, 0.2581111469028269, 0.22723737986239, 0.21974460473247204, 0.22407880609717057, 0.5824021295810762, 0.35473985986276324, 0.610145461572202, 0.6801681697052695, 0.5299941685402301, 0.3618654559126524, 0.42796095234310005, 0.2706032415231463, 0.6149791193532104, 0.45090944531619426, 0.4059628950127492, 0.3790622728129781, 0.4886054038661033, 0.20741300089114578, 0.16504235425643, 0.19715036051336576, 0.39562803428216164, 0.5195256026381605, 0.17937352771120718, 0.18074691343824867, 0.1813580920273058, 0.17907471176773704, 0.1887419299609172, 0.1786060931066057, 0.19715720992185448, 0.17884546715691707, 0.19627822337453826, 0.07424905281640204, 0.08474795345883157, 0.07854809794251671, 0.07202806595475375, 0.0887377858109476, 0.07961735638879963, 0.08700478654962807, 0.07374222704607492, 0.08100069059855064]}, "mutation_prompt": null}
{"id": "ab4a42fb-0d76-443d-a37d-c251a13fda06", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "8d417918-2d63-44ed-bde2-ff234bc18b64", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "80776639-9515-4783-a11a-449752aa66a3", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "99bb444b-bd81-4790-addf-53ccc1dff0c1", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "f0680f99-a533-4961-913e-70947917e0fc", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n        self.best_history = np.copy(self.population[0])  # Memory of best solutions\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.best_fitness:\n                self.best_fitness = self.fitness[i]\n                self.best_history = np.copy(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_history = np.copy(trial)\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n            if evaluations % (self.budget // 10) == 0:  # Periodic annealing step\n                self.population += np.random.normal(0, 0.1, self.population.shape)\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Enhanced ImprovedADELSOptimizer with periodic temperature-based annealing and memory of best solutions for improved exploration and convergence.", "configspace": "", "generation": 57, "fitness": 0.383664070188665, "feedback": "The algorithm ImprovedADELSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.25.", "error": "", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.10539389039266078, 0.12174008675537129, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.14965891243403673, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.240457552497244, 0.16802365992805102, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.21210353040525354, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.19713260397653698, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.2749072097298795, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.16997120192450166, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "15145183-5880-45a4-946d-89d598c12e43", "solution": "import numpy as np\n\nclass EnhancedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n        self.memory_F = []\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Memory-based adaptive scaling factor\n                if self.memory_F:\n                    F_adaptive = np.mean(self.memory_F) + 0.1 * np.random.randn()\n                else:\n                    F_adaptive = 0.1 + 0.9 * np.random.rand()\n                F_adaptive = np.clip(F_adaptive, 0.1, 0.9)\n                \n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                    self.memory_F.append(F_adaptive)\n                else:\n                    new_population[i] = self.population[i]\n\n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Dynamic population sizing\n            if self.no_improvement_count > 5:\n                if self.pop_size > 5:\n                    self.pop_size -= 1\n                    self.population = self.population[:self.pop_size]\n                    self.fitness = self.fitness[:self.pop_size]\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedADELSOptimizer", "description": "Enhanced Adaptive Differential Evolution with Memory (EADE-M) - integrates memory-based scaling factor adaptation and dynamic population sizing for improved performance and convergence.", "configspace": "", "generation": 58, "fitness": 0.31834455085231667, "feedback": "The algorithm EnhancedADELSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.23.", "error": "", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.8150541841996455, 0.6579271893511234, 0.7499583280570321, 0.7731167314030299, 0.6202713464376189, 0.7938024238009702, 0.6857278191170294, 0.7826328318117698, 0.6380826886567608, 0.6508201199218926, 0.3987591959660609, 0.4678788598097746, 0.6779212621037711, 0.37283436583045904, 0.4382196484041919, 0.36897816489900714, 0.37989353058775044, 0.687426733791823, 0.16427477671934554, 0.10969365600152925, 0.10412766965518205, 0.1250027207462625, 0.1099224966684047, 0.10762590863452115, 0.11682330324013035, 0.10344390191462594, 0.11743424416236414, 0.10350251513197994, 0.10583512964812802, 0.12840302881831123, 0.09778051264286403, 0.09536685418390156, 0.1752240602357762, 0.10419357929772555, 0.1005870967335335, 0.25730194152344055, 0.9740730987956283, 0.9569803286334251, 0.9427194387197212, 0.9306581750039946, 0.9489848784781371, 0.9266300509353426, 0.9162401869599848, 0.9483953667977706, 0.9169310810875102, 0.3970244475622471, 0.17634863404120116, 0.3563025119535932, 0.3686276217746167, 0.42577116145917426, 0.4301177593469748, 0.2514436816721739, 0.3006178327828779, 0.43525201423869553, 0.8165859567101227, 0.45877013251047993, 0.31827366387864464, 0.8308003890724269, 0.6207360626686307, 0.6365021741361733, 0.7633514779668449, 0.6041053497972777, 0.682410995404956, 0.16500847979907662, 0.20874764339051388, 0.20274550627150945, 0.18847119811175927, 0.15205705342398856, 0.23852467495771923, 0.3897110430835168, 0.15493447751164058, 0.15646160294838596, 0.4772902400193818, 0.20610797508458345, 0.13518981533092356, 0.20566195083040995, 0.1787777191861869, 0.23230626875574456, 0.27553017955355485, 0.2569144407343077, 0.24313002484588042, 0.2898052732903018, 0.47152606272418585, 9.999999999998899e-05, 0.1701837942562524, 0.11017414971591899, 0.17643657772986465, 0.34692939395555755, 0.14630592432892897, 0.23126477316856464, 0.30870204166402215, 0.28286138051371146, 0.3593456976146403, 0.05872418830400561, 0.2732292962083962, 0.3424505599185831, 0.6044262984768127, 0.2737005700970614, 0.4014229949187569, 0.09078483754393474, 0.02593289255729725, 0.11164309047866283, 0.16145602116360225, 0.057531468903648575, 0.15139818216172152, 0.10723940858376046, 0.03727218309599689, 0.12039214364880846, 0.2404595661570218, 0.288935233466485, 0.29429563464760433, 0.32559198660955724, 0.17210792034846878, 0.1906707072595637, 0.1763903465167279, 0.17661713103973165, 0.2969635488289094, 0.5732741881431516, 0.5034568785796579, 0.6882287782792126, 0.6551915182413961, 0.49337449588798876, 0.48899820010563655, 0.6819753256346983, 0.4964899063398308, 0.5680702183110329, 0.13070482041464326, 0.10407969740180834, 0.09715260924806612, 0.09038138636638726, 0.12071649659620942, 0.10547710775873587, 0.11674628548937094, 0.10040337637139396, 0.12274450839890505, 0.25672855303255504, 0.23453462438032746, 0.18314528071777592, 0.1843538652665645, 0.21945049486165202, 0.37604770434607615, 0.19145520907357638, 0.1684370803667291, 0.19785439355290113, 0.49487001680535625, 0.29662462099704445, 0.306691183411093, 0.45312020235876005, 0.265266527739106, 0.2853102417259624, 0.490575196535618, 0.2840055637079516, 0.31612997110186636, 0.3262924478550334, 0.2259151969933556, 0.2410742093370204, 0.290769902325432, 0.1988445774566584, 0.358167299676317, 0.40770617354880445, 0.23303451208590786, 0.2561655451145354, 0.20198029940472262, 0.18809296465924208, 0.20577218541794629, 0.2149398099178732, 0.19780523166911412, 0.18992666837196448, 0.2079781148505464, 0.20956208692995815, 0.18689279823217397, 0.206375814203844, 0.1984826663023287, 0.19389512955408839, 0.21010693050048457, 0.32376687876618593, 0.21329516047939023, 0.19008299331099854, 0.18692437410587437, 0.1862684885277036, 0.181447050313154, 0.18501539640779074, 0.185647227815801, 0.7567484644494379, 0.19640664677879505, 0.19829429002838284, 0.6339865117046357, 0.18164890785321863, 0.586181845416369, 0.829916699648992, 0.20704296755179374, 0.19580056331576612, 0.206096021085022, 0.5769324213627688, 0.5896698668380881, 0.20689297610226853, 0.16046971062936155, 0.21006626823080454, 0.18101486807092038, 0.1779560240463205, 0.18354530840671834, 0.19936999323060567, 0.1777770785552628, 0.18921005505913147, 0.18569224382057936, 0.17716697342782628, 0.17762374144726545, 0.1072024807501879, 0.0705219611356731, 0.08738439290517908, 0.09211862322376163, 0.07518034041418997, 0.10049664406615555, 0.07785976865004463, 0.07332172082009403, 0.0871870771589578]}, "mutation_prompt": null}
{"id": "9c60ab7c-21df-4d0c-8267-1347208a0d77", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "30306ad2-9537-4ed8-8b52-13587a08133a", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "527820fe-c9a6-4f5e-81eb-f8a050a935ff", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "651752c5-3b4a-441c-b8ba-a8139f24e674", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n\n                # Adaptive crossover probability\n                CR_adaptive = 0.8 + 0.2 * np.random.rand()\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n\n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Stochastic restart strategy\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 2)  # Restart two solutions\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, (2, self.dim))\n                for idx in random_idx:\n                    self.fitness[idx] = func(self.population[idx])\n                evaluations += 2\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Enhanced ADELS with adaptive crossover probability and stochastic restart strategy for improved convergence and diversity.", "configspace": "", "generation": 62, "fitness": 0.3761047925647009, "feedback": "The algorithm ImprovedADELSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.24.", "error": "", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7722876946398322, 0.760048595707057, 0.7530041288318388, 0.7401295940748458, 0.7816508032117306, 0.7623169009887568, 0.7702811217021797, 0.7805235620662326, 0.7734686578246419, 0.5873197914826539, 0.5792348266448877, 0.5453924969152921, 0.5902992559313265, 0.5646146754982329, 0.5657801995187342, 0.5983291801123681, 0.573182785745876, 0.5843695205978148, 0.14234057603982309, 0.12622264442642084, 0.16608432891826852, 0.12206095584051524, 0.12341571459552392, 0.12123180067790307, 0.12790576303782475, 0.13639241972533678, 0.12966763580022667, 0.13933628679698262, 0.11492572080483276, 0.12467937685948804, 0.12592700709077687, 0.12545533734760628, 0.13846965316430615, 0.13496914656541215, 0.11556653351682256, 0.11605867647663892, 0.9030221827453427, 0.9068186466209458, 0.9276773076198122, 0.9070570961167301, 0.889175677475885, 0.9067509653004787, 0.8903457165583077, 0.8724181331175161, 0.8511717962551186, 0.4626731521270554, 0.3993403257490794, 0.4146406794200107, 0.4189830281726463, 0.4394981674260916, 0.43863396422415424, 0.40716316104371664, 0.416130106394894, 0.3730682041997021, 0.7804491400379142, 0.7797966570058292, 0.769423092899346, 0.7799269871689575, 0.7895417087199603, 0.7936063465875222, 0.7376590717473617, 0.7073403946178618, 0.7692035302947338, 0.21116809159311778, 0.22470338810206136, 0.3021247402090007, 0.25460800186800814, 0.1864671714162991, 0.30147205271158184, 0.258216733436463, 0.3983136864617838, 0.20475423720981656, 0.20427968016676556, 0.14223854929246849, 0.3139170111917847, 0.2683643255675746, 0.35941354464706765, 0.23947842296866262, 0.3357249595036321, 0.1612653665547481, 0.1825964626713762, 0.3259920881251662, 0.31916252158825176, 0.3587579086742092, 0.3964627906491027, 0.3610552726357996, 0.33421861777446527, 0.3720828561119187, 0.33148015548230014, 0.3438040463091555, 0.46317372127975076, 0.48372989891225937, 0.48775054338041013, 0.484120927106378, 0.46960802338540986, 0.5049875772512629, 0.5208345385645371, 0.5006825939789591, 0.5169323509016706, 0.09958341722238473, 0.12822436650487068, 0.09771521221395019, 0.2513599976893851, 0.16164601384646193, 0.21378157190035096, 0.14425310188342078, 0.17148954055071375, 0.13941514117076037, 0.29923434745669497, 0.2893822297462496, 0.32292053580238333, 0.31678735164582306, 0.30561562190613134, 0.30661291267603896, 0.2867055096800033, 0.2965633244805451, 0.27775595464991465, 0.6679586423163749, 0.6340182134657091, 0.6923194259488916, 0.6757796379117963, 0.6473961015956973, 0.6550534261572875, 0.6685135504417576, 0.685969845362618, 0.6659306490134808, 0.12102411004904856, 0.1012173726781852, 0.12001099864805043, 0.09730904477710844, 0.1229028731099816, 0.12567100374754814, 0.1014953203656187, 0.14323329541859098, 0.1142571823433336, 0.2698147453026465, 0.17406271913542515, 0.24399754755401704, 0.17170255643389554, 0.17806039636478, 0.15975347558859543, 0.24411602168268842, 0.1694424755087417, 0.1636330325667823, 0.41836659145493627, 0.39532766309131107, 0.4003296363833744, 0.3822470667539062, 0.37368764973265967, 0.42434456942293963, 0.4221027644455603, 0.4221031972913465, 0.40705840652849046, 0.32471345160952414, 0.3092661630985424, 0.32362284589904855, 0.30506923286917376, 0.3196288564121901, 0.34103261135779694, 0.34309919871476335, 0.33724460531941025, 0.31608498997326573, 0.20367966195927378, 0.1961853204244024, 0.191792574361641, 0.18386261694625483, 0.20809435530735876, 0.20648381397483384, 0.20019603497555716, 0.20907244287772742, 0.19494636279051925, 0.2700943344247385, 0.21520063631716102, 0.4360529200656028, 0.20291921924120448, 0.25119571099270444, 0.4255451471331303, 0.22242286884650642, 0.26096768957301897, 0.30100604679221554, 0.789919295938128, 0.18938883845167398, 0.737922496705746, 0.8221378063581856, 0.6213943704997467, 0.8012020446027754, 0.1829628389910578, 0.7258113530696475, 0.7636122904585343, 0.7389109157191762, 0.6367307794754463, 0.6093786963059691, 0.6444858776371203, 0.1992228647298555, 0.6792745672605303, 0.20506036750991086, 0.20721001105431458, 0.12262597108465556, 0.1819242604600365, 0.17568172737290666, 0.19911859036543733, 0.17979759871056467, 0.1872871144856596, 0.19520346226191154, 0.18680111169540103, 0.17694236146059827, 0.19079182714172294, 0.08973795236994264, 0.08471936451300732, 0.09324615771007938, 0.08350185729269544, 0.0728853963778362, 0.08508692028867904, 0.08266405782650732, 0.08322840836540801, 0.07562710103850878]}, "mutation_prompt": null}
{"id": "83ab3cc5-42b4-4b32-a478-ef67b3fc1a29", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "c20d064e-0a02-4da7-8364-a79042b1f86e", "solution": "import numpy as np\n\nclass EnhancedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Initial crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_pop_size, dim))\n        self.fitness = np.full(self.initial_pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.initial_pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        pop_size = self.initial_pop_size\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(pop_size):\n                indices = list(range(pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                CR_adaptive = self.CR - (self.CR * (evaluations / self.budget))\n                crossover_points = np.random.rand(self.dim) < CR_adaptive\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n            # Dynamically adjust population size\n            if evaluations % 10 == 0 and evaluations < self.budget * 0.8:\n                pop_size = max(5, pop_size - 1)\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedADELSOptimizer", "description": "Enhanced ADELS with dynamic population size and adaptive crossover rate for improved convergence and diversity.", "configspace": "", "generation": 64, "fitness": 0.32558329505457095, "feedback": "The algorithm EnhancedADELSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.787495306508839, 0.7675634964323927, 0.7706383540213738, 0.8002908221296177, 0.7795048422796681, 0.7701777044698707, 0.7895029029846861, 0.767173475671447, 0.7755592093594219, 0.6332911277570219, 0.6515248823451474, 0.6441051732133304, 0.6229041338667204, 0.6612973829155058, 0.6360218959638009, 0.6513606850114192, 0.625707207561842, 0.6458787226640219, 0.3083937811843922, 0.4198745403498231, 0.45236402813831633, 0.41536905252592293, 0.3455811650317724, 0.26553053541880667, 0.29415334377015145, 0.4811171780547655, 0.4134218110718385, 0.1511025132629369, 0.3821560041652138, 0.418415452298988, 0.3200435035048951, 0.26886849443313965, 0.29739539289182315, 0.2853439068880078, 0.41238408562335616, 0.396919675330035, 0.9612197974562552, 0.9410132309294313, 0.9244737569211453, 0.9335830021055074, 0.9545134761645969, 0.9143624319715281, 0.950059358035696, 0.9296314627853429, 0.9652103709254619, 0.36783231093550117, 0.3784628950000981, 0.3827288656231963, 0.3919456228540029, 0.3804501424859209, 0.403785672952518, 0.34932531439911085, 0.3674366801266631, 0.38386288559023196, 0.7137432419479941, 0.5827526747368432, 0.6786926359240153, 0.730325393721705, 0.6277606583943487, 0.71050245686152, 0.7115032691847116, 0.516487156643867, 0.6544499994411087, 0.1734289197819795, 0.19839414085749763, 0.1476305423769474, 0.1866739539439749, 0.17186078160380713, 0.17446071995841794, 0.15060232459413714, 0.1622611562400159, 0.18591463530811847, 0.17803694788541946, 0.17188430386083187, 0.16887277639449927, 0.19207824714837596, 0.162256101686564, 0.14652422158139033, 0.17534357621640284, 0.1769658965606794, 0.17695605509051515, 0.044490251192718655, 0.07536116283937733, 9.999999999998899e-05, 0.005500262763036168, 0.020221274816260792, 0.032797853708056546, 0.026425208590754812, 0.004005662217850481, 0.030486257100804548, 0.17491527232870063, 0.20346932459930966, 0.16185091496768167, 0.13182730386515362, 0.10795494994468868, 0.1069885149445079, 0.17040243525709453, 0.17870547712440366, 0.21230301629134873, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0195293399046228, 9.999999999998899e-05, 9.999999999998899e-05, 0.035093965836035745, 0.024280149544164353, 0.028621740714441346, 0.14747778162704905, 0.13928651129453862, 0.13697458430564913, 0.15756769861360176, 0.1527276479798012, 0.16398140018185914, 0.14618070275941975, 0.1286854472582789, 0.11888582306858497, 0.4852038328765249, 0.5222146331698325, 0.49731404597246587, 0.4958721082585452, 0.49342005761153573, 0.4988542952144349, 0.492282661632119, 0.47251604925268353, 0.48590595087222554, 0.12575982269349129, 0.1027993751401105, 0.10538683937629811, 0.10680646638813907, 0.10509329290231983, 0.11811606856597823, 0.11792062047957519, 0.12514854423311494, 0.11660950251138857, 0.21964695291111314, 0.21776088586272757, 0.16652286511893466, 0.1623111895794469, 0.22764404015029227, 0.2028317766373089, 0.1807696770641758, 0.1857546198190535, 0.2002901962564383, 0.3067879599196913, 0.3203311829354374, 0.353941676192147, 0.3386744999342717, 0.31595284458572115, 0.35338129906692584, 0.3362673272808179, 0.39296655631831146, 0.43026268127174594, 0.22042442368569326, 0.2674784853643847, 0.24267713409243175, 0.2282871420482253, 0.18736535582884695, 0.2514382684882073, 0.25795232210224106, 0.30407800521306694, 0.23627697672375858, 0.2180775876723806, 0.19351073880547898, 0.19673508072818202, 0.20582687502141483, 0.18289983786078956, 0.21277735329256042, 0.18786491324749532, 0.2130918655515971, 0.19651982652387778, 0.5185593492366323, 0.21422383103271314, 0.26153562811271325, 0.20728883462583103, 0.242931388593413, 0.272821349391987, 0.23744669371938254, 0.22746999253663902, 0.19957190692726856, 0.5361539761907496, 0.7405202092607663, 0.16336519302171415, 0.7499592674540771, 0.5129169749017393, 0.7712497892442829, 0.18475520346693808, 0.5063974859797135, 0.7758800895551533, 0.5395374425513864, 0.3346902271627148, 0.2659907485048608, 0.6077335094806533, 0.3354430662431024, 0.19462751906347664, 0.20011900883453004, 0.43452074932736695, 0.21162658297735126, 0.17156107062694048, 0.19452466848406524, 0.17680638230358947, 0.188468808774374, 0.18345301506408218, 0.177308173399097, 0.18749215788339646, 0.210045434808672, 0.18023863592015021, 0.07542201930227566, 0.08691440982645726, 0.08603226133755504, 0.08078459512673375, 0.08381491418912179, 0.0748441471316883, 0.08123696750372178, 0.07535869076474933, 0.07945498168951526]}, "mutation_prompt": null}
{"id": "645d8afe-a96f-4fcb-b39a-4897ec83a265", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "41b230d3-21fb-415a-82f2-4d84d08487b4", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "391ce044-2ff3-4358-bd17-58b5b7f83256", "solution": "# Description: Enhanced ImprovedADELSOptimizer using adaptive local search intensity and mutation strategies for improved diversification and convergence.\n# Code:\nimport numpy as np\n\nclass EnhancedImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                F_adaptive = self.adaptive_mutation_factor(i)\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n\n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 3, replace=False)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                self.fitness[random_idx] = [func(self.population[idx]) for idx in random_idx]\n                evaluations += 3\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def adaptive_mutation_factor(self, index):\n        return 0.1 + 0.9 * (1 - self.fitness[index] / np.max(self.fitness))\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedImprovedADELSOptimizer", "description": "Enhanced ImprovedADELSOptimizer using adaptive local search intensity and mutation strategies for improved diversification and convergence.", "configspace": "", "generation": 67, "fitness": 0.24390670028580266, "feedback": "The algorithm EnhancedImprovedADELSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.16.", "error": "", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.515338434278048, 0.5435854175630053, 0.49643556889100626, 0.4167076698520241, 0.4189591675454314, 0.5036124234126534, 0.4485583864016416, 0.43821972778126816, 0.5118791616426428, 0.22784184765582738, 0.24901468966499762, 0.21891216458651908, 0.19207651426869532, 0.17938445349679732, 0.2083599752394797, 0.22535662466111928, 0.2909543851793056, 0.22467531842335653, 0.17688449231155623, 0.1359538485589159, 0.1414198063110833, 0.17476430571119927, 0.1476845158035509, 0.168349350293452, 0.1584571043085249, 0.17070949998283358, 0.1619786046128846, 0.14697015692735882, 0.12498356762161689, 0.11507089612055843, 0.1437110883320103, 0.16552366261049078, 0.11253276144199265, 0.15006651399020543, 0.13767560416933033, 0.13446420747078736, 0.9641302804528183, 0.9251124778656956, 0.9044835549602687, 0.346066203779701, 0.46039517410274944, 0.830168703053191, 0.8080348271525594, 0.8703061789652924, 0.7871630429507223, 0.24766315928382132, 0.2100762539678963, 0.21242458742033743, 0.24056714763879217, 0.23416876512549722, 0.2720788355045626, 0.21785145604942824, 0.1877022115094774, 0.21611962695173048, 0.24550529596359894, 0.3486493137052945, 0.31320466286248694, 0.35927781245456725, 0.3421191390561723, 0.20538230045990435, 0.773820183584648, 0.3343233936270119, 0.3702533143215513, 0.17999484312867076, 0.14409717603454286, 0.1795177396780656, 0.1509897106010516, 0.12882356957951813, 0.13362110710976105, 0.16849516166690592, 0.22578862588891702, 0.132554523232021, 0.08565690398379666, 0.15789718607866599, 0.11544463724047582, 0.13903314933767164, 0.19066373434087858, 0.14479273981737972, 0.20979559277033788, 0.16147389373909593, 0.12966579190175853, 0.18563997136441335, 0.18096551425693208, 0.14276173803612724, 0.18485726889273524, 0.25801753781034, 0.10528392965211986, 0.07825891962096898, 0.09840329468451237, 0.08516232337759233, 0.26606965515820835, 0.28038986700753665, 0.2282319889719887, 0.14602795170717453, 0.18092743437891545, 0.20764661803559192, 0.22775700362090145, 0.27951679305163324, 0.24990212816497237, 0.07445223060531958, 0.13574306514815215, 0.08599350079839019, 0.09684089346949754, 0.056508108215138186, 0.12898797230509973, 0.1634376761561529, 0.1292432648004599, 0.15865821227696775, 0.24342695844775586, 0.24907271344687665, 0.134958014919228, 0.159095680387508, 0.14167695613437192, 0.14994246734354566, 0.11481445811471569, 0.08862650319297993, 0.11681549194259366, 0.3629003310325636, 0.36724065102947023, 0.3540246363337055, 0.3607165010624399, 0.42799629346284696, 0.39714673942043066, 0.44798149564477674, 0.35426100025554264, 0.4529334110215617, 0.16834785731998347, 0.10973620398302808, 0.11454859957171049, 0.1288757597730077, 0.14142247225466942, 0.12159252751634664, 0.11345520119696906, 0.09459929737368944, 0.11828736594241185, 0.17172831104613884, 0.18673990740874324, 0.21422305592155688, 0.2625964903773321, 0.16066599393994607, 0.2372530096747073, 0.29773740282582584, 0.1991406552248679, 0.22875090713546564, 0.19806905848019518, 0.2868567218210236, 0.260570177597658, 0.35390885729343313, 0.3239994543994933, 0.2781732212448542, 0.4233224338987033, 0.3485639097907609, 0.3391436008102129, 0.21278969331316588, 0.23694804600096608, 0.23022558984417096, 0.33095553109583253, 0.3138474028758146, 0.34134774613398566, 0.22352954624660681, 0.21224446884723414, 0.2154821253343172, 0.2230579969755887, 0.212382297541597, 0.24122756427995407, 0.22435357158010671, 0.2509811970635971, 0.2201921913611904, 0.22107428312444022, 0.23049908465943958, 0.20997493592637773, 0.2144138440209361, 0.31239934711955164, 0.3310215939314217, 0.34224620400806194, 0.38454788669563, 0.20829657656280987, 0.1926317309046892, 0.23844579578348157, 0.20323476918888095, 0.1953040085562623, 0.18463270826790767, 0.1845151633330998, 0.5275954024286236, 0.1940080908667252, 0.19329455737579515, 0.14235158026997674, 0.16962318017826672, 0.16504085611531916, 0.46119303202681394, 0.2085871064955429, 0.07348601221776985, 0.20358566990487204, 0.24304159369103484, 0.14763377233164943, 0.2384872279368334, 0.3415491099317939, 0.2640885496058002, 0.20012905322411467, 0.18601437650913555, 0.18845908045560922, 0.19843460504010302, 0.19702369858102742, 0.18116751030394207, 0.1867146635870972, 0.20114769994858173, 0.18455220020537189, 0.10929328543130945, 0.08953374861012708, 0.09801466646074408, 0.0952609278268094, 0.08434880482286022, 0.08512999106496211, 0.0809261790723993, 0.09711788588530912, 0.1001607181449945]}, "mutation_prompt": null}
{"id": "600425c4-cdb9-48a9-94e3-0935b7508702", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "e48c4947-3b45-4366-9ff7-526e93bb37d3", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "347c58ce-ecf8-4137-8674-73fa1a3a899a", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "b6d84bac-f8d1-41b6-90e6-1449e3d84af2", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "723c5dd7-722b-4491-950b-d213c9213b2f", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "209d5ff8-8eb6-4fd6-a883-45d3352ccddd", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "ac2dea2b-2d76-47de-8fec-5dd84f8b7e4f", "solution": "import numpy as np\n\nclass EnhancedImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n        self.dynamic_pop_size = self.pop_size\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.dynamic_pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.dynamic_pop_size):\n                indices = list(range(self.dynamic_pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = np.vstack((new_population, self.create_random_solutions()))\n            self.dynamic_pop_size = len(self.population)\n            \n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                self.hybrid_local_search(func)\n                evaluations += self.local_search_intensity\n\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.dynamic_pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def create_random_solutions(self):\n        num_new_solutions = max(1, self.dynamic_pop_size // 10)\n        new_solutions = np.random.uniform(self.lower_bound, self.upper_bound, (num_new_solutions, self.dim))\n        return new_solutions\n\n    def hybrid_local_search(self, func):\n        best_idx = np.argmin(self.fitness)\n        best_candidate = self.population[best_idx]\n        perturbation = np.random.normal(0, 0.1, (self.local_search_intensity, self.dim))\n        local_candidates = best_candidate + perturbation\n        local_candidates = np.clip(local_candidates, self.lower_bound, self.upper_bound)\n        local_fitnesses = np.apply_along_axis(func, 1, local_candidates)\n        min_idx = np.argmin(local_fitnesses)\n        if local_fitnesses[min_idx] < self.fitness[best_idx]:\n            self.population[best_idx] = local_candidates[min_idx]\n            self.fitness[best_idx] = local_fitnesses[min_idx]\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedImprovedADELSOptimizer", "description": "Enhanced ImprovedADELSOptimizer with dynamic population size and hybrid local search for improved exploration and exploitation.", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 50 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 50 is out of bounds for axis 0 with size 50')", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {}, "mutation_prompt": null}
{"id": "2a7043cd-e593-4069-a34f-addf88d68d54", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                \n                # Dynamic crossover probability\n                CR_dynamic = 0.5 + 0.5 * (self.fitness[i] - np.min(self.fitness)) / (np.max(self.fitness) - np.min(self.fitness) + 1e-8)\n                crossover_points = np.random.rand(self.dim) < CR_dynamic\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Enhanced ImprovedADELSOptimizer with dynamic crossover probability and neighborhood mutation for better exploration-exploitation balance.", "configspace": "", "generation": 75, "fitness": 0.3501581960876178, "feedback": "The algorithm ImprovedADELSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7875246860309214, 0.779035706452267, 0.7853350373006822, 0.797461848327248, 0.7831273712655014, 0.773008982452209, 0.7629370237093582, 0.7841580926549954, 0.765519195976535, 0.6239639715351826, 0.6105223737711316, 0.6106793490627378, 0.6118485917672672, 0.5967953701803651, 0.6064407213975571, 0.5946737585520453, 0.616858465005039, 0.6119180428275021, 0.293427679069739, 0.19621316328279348, 0.28332980745755987, 0.3223830072992949, 0.24431114723048564, 0.1506713638432251, 0.19665418307253546, 0.1841489999551683, 0.35665890449253235, 0.21904079176835745, 0.2500303753037879, 0.13465116321056325, 0.20660155060902985, 0.18495219777092742, 0.14845970637178796, 0.18637460037922116, 0.17725187765173323, 0.16542212588631433, 0.9493369164615579, 0.93949070427332, 0.9146668847052587, 0.9426039344442072, 0.9288745735363897, 0.9303570676462191, 0.963131554407987, 0.958697680559175, 0.9437296098454138, 0.40578551699469756, 0.4492223892551398, 0.41926808502322876, 0.41848343334018145, 0.41137274510674504, 0.38852162638339116, 0.3992903550273842, 0.365429206023705, 0.39805282495608385, 0.6492734482774228, 0.7090505084954826, 0.6593012901770201, 0.689098748396408, 0.696340559033596, 0.666522935341173, 0.6771602152566472, 0.6602609371475214, 0.7371946047846429, 0.20272526724305473, 0.1962337922662475, 0.2026902087675888, 0.28169625534422715, 0.3140644511716918, 0.17687933511075715, 0.2719683959425626, 0.19742485633374862, 0.1964790434993977, 0.1973111999189483, 0.1838957922690745, 0.18168515627876147, 0.1980302555362109, 0.34519699691533134, 0.201035950053706, 0.2513699770561014, 0.1945797732725214, 0.1774970505194946, 0.1765892545015424, 0.14123650608740024, 0.1461818416984455, 0.18343512360296588, 0.1422974782500891, 0.08906644752323267, 0.21149042513925576, 0.1368080555563429, 0.19758876984444407, 0.27532183275007904, 0.2434772729893454, 0.3059082670810872, 0.2772452908962366, 0.20971954858509279, 0.2534896245495636, 0.3175859025523511, 0.2857438021830786, 0.2905765848884274, 0.07264285451956931, 0.057571292361316195, 0.10953742640185049, 0.1319225588231795, 0.1094581600188318, 0.08088932733935905, 0.08343688241824498, 0.127126375093209, 0.08598763210395133, 0.25113274420645215, 0.2530812246555303, 0.2408567266248952, 0.23450159427972417, 0.23407783693461692, 0.21819883039707155, 0.23775570044968575, 0.20456230917595086, 0.22954100796429522, 0.606331297079772, 0.5779295831700353, 0.6414240264098676, 0.6070628745185667, 0.5937577497749913, 0.5935044075242488, 0.6233140886242576, 0.5881204952931953, 0.6096029604130967, 0.117470758149951, 0.11103706581134498, 0.10949369723812086, 0.13940970960900867, 0.11834150457214854, 0.11593240832893881, 0.11483258659535456, 0.1084081343552793, 0.1115052623097732, 0.19015068256193268, 0.18198445401307572, 0.17257228483964193, 0.25232641388815014, 0.17380458216127603, 0.18089340428973355, 0.19135695780956674, 0.20060080054099294, 0.1641316326321839, 0.38469376635250396, 0.3984482190041643, 0.37896415875434064, 0.41172075039124145, 0.391964793791743, 0.38404185260541457, 0.4101753737884245, 0.42251888128624626, 0.4138569670513088, 0.281825168504121, 0.30369637862434506, 0.29011685276945953, 0.32052718703031013, 0.2620759099623523, 0.2895586317476535, 0.31390010740251606, 0.34009200950725527, 0.28794874748722854, 0.19901393563838055, 0.18035058894535283, 0.18652335462762937, 0.19507211294863291, 0.18295980357868713, 0.20081716716040654, 0.18654220070506744, 0.18953834048575946, 0.20464128904634937, 0.43128701986216234, 0.22773319418663573, 0.3875828723316347, 0.27822404580605886, 0.369331469821906, 0.26932800285145975, 0.21561633535327585, 0.3367458306965332, 0.2902939180480876, 0.6435691345192465, 0.646738168995443, 0.6758214322884469, 0.7376054089141544, 0.19436383226877785, 0.19497415879359592, 0.7518152246032124, 0.5708112444695996, 0.6435778734792141, 0.5812781858689671, 0.20242125809721556, 0.5278424282200559, 0.1984136811715309, 0.16276466861774608, 0.5310961459892966, 0.6065806986739941, 0.6029727371138097, 0.21297415682236553, 0.17562534021344223, 0.19088590535950356, 0.18448595421526615, 0.19242355654623067, 0.20234562958472202, 0.18460433451490998, 0.17962236998181702, 0.17868835660362403, 0.18877094599956967, 0.08035353807974244, 0.0840254656456253, 0.09104921236296448, 0.08430538651179231, 0.09003447031400424, 0.08170787407825175, 0.08261444501758564, 0.08194377603572867, 0.09232043651510013]}, "mutation_prompt": null}
{"id": "c32a4157-5ac3-48a8-bc98-c4c796c3d267", "solution": "import numpy as np\n\nclass EnhancedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n            \n            # Dynamic population resizing\n            if not improvement and len(self.population) > 5 * self.dim:\n                self.population = self.population[:len(self.population) // 2]\n                self.fitness = self.fitness[:len(self.fitness) // 2]\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                diversity_boost(func)\n                evaluations += len(self.population)\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def diversity_boost(self, func):\n        num_new = len(self.population) // 4\n        new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (num_new, self.dim))\n        new_fitness = np.array([func(ind) for ind in new_individuals])\n        self.population = np.vstack((self.population, new_individuals))\n        self.fitness = np.hstack((self.fitness, new_fitness))", "name": "EnhancedADELSOptimizer", "description": "Enhanced Adaptive Differential Evolution with Local Search (EADELS) incorporating dynamic population resizing and diversity boost for improved exploration and exploitation balance.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 49 is out of bounds for axis 0 with size 25').", "error": "IndexError('index 49 is out of bounds for axis 0 with size 25')", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {}, "mutation_prompt": null}
{"id": "466ecf0c-b832-42b4-ad02-8c370ec173de", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 2)  # Increased increment\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize a portion of population if no improvement\n            if self.no_improvement_count > 5:\n                reinit_indices = np.random.choice(self.pop_size, max(1, self.pop_size // 5), replace=False)  # 20% reinit\n                for idx in reinit_indices:\n                    self.population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    self.fitness[idx] = func(self.population[idx])\n                    evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Enhanced Varying-Intensity Local Search and Adaptive Population Re-Initialization in Improved ADELS.", "configspace": "", "generation": 77, "fitness": 0.38447276783678236, "feedback": "The algorithm ImprovedADELSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.24.", "error": "", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1228275515971553, 0.10643998187954729, 0.11851900271801419, 0.17355271737399458, 0.14214011868964116, 0.12879522147230216, 0.13086996314739685, 0.12997389488230948, 0.1303338698757167, 0.11734573639206392, 0.12209475159678584, 0.12388681691343972, 0.10947053316463151, 0.1103660113874958, 0.11643827634765058, 0.10036043003434147, 0.12903749036744117, 0.11833083046074466, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3951236544210349, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.12135061452017037, 0.12220862532272858, 0.12216848811203562, 0.11593177377562114, 0.11587431766352185, 0.1181792936733631, 0.11865921774256127, 0.1306332339182842, 0.12470803518993667, 0.17538225321985923, 0.15759217251372226, 0.23063895888023966, 0.19699526991381222, 0.2367563358819451, 0.34201749290640204, 0.1856998526657092, 0.24406482612680902, 0.14284635988182237, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2018686166880994, 0.19404319704450446, 0.1857397428538049, 0.21385922093451004, 0.1832882111531582, 0.195671647354153, 0.19410741028224643, 0.19436336918668373, 0.198051402501061, 0.3270206283018767, 0.28662154852704236, 0.2109447795249607, 0.3857197177768088, 0.20871888742153177, 0.24599512878818297, 0.5243334960693017, 0.37328160339409433, 0.39660915199986446, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6804093414449898, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7647670402320426, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6447081494325511, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17321791708907675, 0.1839249509977955, 0.17693828399266642, 0.18162799410242136, 0.19476242315911463, 0.17139554906485865, 0.18478281331721602, 0.18731640689451778, 0.17685314107929317, 0.07970803608298138, 0.0809344229429404, 0.08963571084145716, 0.08690032442857631, 0.09612450291627372, 0.07402309543821828, 0.08415033759801949, 0.0847023726350411, 0.07441866702002209]}, "mutation_prompt": null}
{"id": "5fcea20f-2b30-40b5-bd18-3e1300516a4b", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "fc97b890-8cf1-48a7-a9f9-2789243d0e3f", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                \n                # Dynamic crossover rate\n                CR_dynamic = 0.5 + 0.5 * np.random.rand()\n                crossover_points = np.random.rand(self.dim) < CR_dynamic\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            # Neighborhood search\n            perturbation = np.random.normal(0, 0.05, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Enhanced ADELS with dynamic crossover rate and neighborhood search for improved exploration.", "configspace": "", "generation": 79, "fitness": 0.32624938366438794, "feedback": "The algorithm ImprovedADELSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.23.", "error": "", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7558241977275342, 0.734902479774124, 0.7566965653167307, 0.7538125742413461, 0.7631053018719989, 0.7601849044125585, 0.7585776520957365, 0.7590744844411202, 0.7625257535403858, 0.564286274656141, 0.5755769426716095, 0.5692245882757907, 0.5231446367278225, 0.5718354523755619, 0.5939516774436517, 0.54469934705907, 0.5632657262287748, 0.5945689159728236, 0.15516592629827664, 0.15914844406035422, 0.18669589008923704, 0.15642886291277158, 0.2056884278856873, 0.1375335159396911, 0.16037125410486752, 0.20508572218869492, 0.13497969297407175, 0.1260089519870189, 0.14224547419239353, 0.16630041522402084, 0.133148337720279, 0.1493242025143665, 0.133664677826837, 0.21841450518689043, 0.13664179429550682, 0.15293131654429093, 0.9319544112575229, 0.9185706747414548, 0.895418970466201, 0.9490033945633306, 0.9002075425779241, 0.9264719827939939, 0.9420866836237072, 0.930378812016694, 0.9241319014517911, 0.38117132493907624, 0.34303570598361943, 0.32372562909772373, 0.35935224363762774, 0.35364138517618127, 0.37628247716254604, 0.35560637295552955, 0.38406511199975135, 0.3530837925287319, 0.5767549538842195, 0.648902314653965, 0.6256358123992944, 0.682387421926623, 0.6294641997121323, 0.638968624030633, 0.6482367216288389, 0.6751450188310197, 0.6888124031632774, 0.17538031577217372, 0.20123460328946385, 0.18484598960571041, 0.14275606631508586, 0.2636498137307395, 0.28063927037524805, 0.16556518273749565, 0.22447169595485295, 0.1975367522581285, 0.27006476412207103, 0.13610500583648788, 0.25979692979735935, 0.17125984916638137, 0.16951705218064694, 0.1597706612697417, 0.18805509334068715, 0.15763467622561478, 0.19506713877358617, 0.05918306453841726, 0.16942636178267256, 0.10805646030311178, 0.15352121630265902, 0.18648942906875654, 0.18102363027430735, 0.1824653363244152, 0.14427058784613456, 0.2423567451462726, 0.27692661587763434, 0.23785428711417678, 0.3172687277937293, 0.3292757310299099, 0.26338369261737593, 0.3192318041748321, 0.32090089843221736, 0.31955271013652287, 0.3414357154177754, 0.09484885940164367, 0.08873959525162811, 0.11188046092508608, 0.10270242384455319, 0.09942749534955075, 0.11581347381965812, 0.07678101512943436, 0.09246768936527805, 0.04984786130723984, 0.1889254583581753, 0.20789046993984717, 0.17469327147321456, 0.1970042914287332, 0.2069413077599146, 0.20061054725825578, 0.1999751985807645, 0.1925790740874852, 0.20812929576266626, 0.576014731918348, 0.569306364060641, 0.5550228273641716, 0.5656390284269146, 0.5849139094252768, 0.6031660715638966, 0.6254746610068064, 0.5542591373164928, 0.5702203396376904, 0.10753418998234376, 0.1312490533792825, 0.12514825217771908, 0.10250034041301392, 0.10629932747560922, 0.1172157674160611, 0.12255958495399266, 0.11254533291054303, 0.11882747419587958, 0.17487905446285112, 0.16097028373241007, 0.20216605800906173, 0.18092754378316567, 0.19117204413989852, 0.1465141676528976, 0.18472201489524864, 0.1786560969948192, 0.19960334288999415, 0.37403402167762334, 0.36796130524296855, 0.36748938665236075, 0.33299034682323136, 0.34892242633175696, 0.3568935657868735, 0.3869464075932416, 0.39308263476315064, 0.38436511049896294, 0.27501870792405847, 0.24926985813721292, 0.28576916711877065, 0.25268525756967364, 0.2445771530953188, 0.2725310288263535, 0.2588095644182137, 0.31680294990358715, 0.250711297209553, 0.21054862479534964, 0.2067103439810033, 0.1763450571369225, 0.2015795261289286, 0.19256088077832478, 0.20861161105592496, 0.1989366100070039, 0.19546637850635806, 0.21095386558865348, 0.22897304221305725, 0.23415789803202025, 0.30770900429479475, 0.20332969583989924, 0.21120175016775833, 0.3991203624411561, 0.2182195455628806, 0.21849880291816448, 0.21438143250361485, 0.1870928258035821, 0.20125994331154595, 0.7017005997784878, 0.7710358387570606, 0.5760868761897733, 0.7155185945668099, 0.6866991027863767, 0.48817377095453673, 0.6964238057841027, 0.5628693159469245, 0.5598102791834175, 0.2777896863748063, 0.5849843522872135, 0.19788889389611186, 0.19865946791165734, 0.2010961428331276, 0.20219042466225823, 0.2071605308715202, 0.1848372679691539, 0.17702683814313436, 0.18292097847506206, 0.1877837854912492, 0.1845599496121938, 0.1807762614058942, 0.19142317468735748, 0.17887347497277095, 0.17912106917547266, 0.0805658835772245, 0.08246127387947233, 0.07854685054878974, 0.09599632174483774, 0.08744650251707009, 0.08193414044240854, 0.07649783452492198, 0.0906149001065909, 0.07560585266814812]}, "mutation_prompt": null}
{"id": "83334596-0784-410d-aaec-74f714977978", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "e99d1712-8744-4106-a2d7-723ffb030ac8", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "b940683a-979d-4b45-9b95-a1247f23d26c", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "397d1bae-b10d-4a70-a6f7-069e58998cee", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor with diversity consideration\n                F_adaptive = 0.5 * (1 + np.std(self.fitness) / np.mean(self.fitness))\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n\n                # Dynamic crossover with small probability of full replacement\n                if np.random.rand() < 0.1:\n                    trial = mutant\n                else:\n                    trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Enhanced differential evolution with adaptive mutation and crossover strategies for improved convergence and solution diversity.", "configspace": "", "generation": 83, "fitness": 0.2933328582219327, "feedback": "The algorithm ImprovedADELSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.26.", "error": "", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7821666721639663, 0.7718925448190594, 0.7605444052435704, 0.7883160564116944, 0.7818218429241786, 0.777940275624341, 0.7864418694359009, 0.7686901094677284, 0.772169694713047, 0.030435879268923105, 0.053156937722003694, 0.056960383897879496, 0.03393356932477143, 0.0665589930870788, 0.06287436281154823, 0.07039335177760242, 0.05238676104253115, 0.06255708629316559, 0.11087086552407122, 0.12547529204898344, 0.13631573224710447, 0.1383188142744115, 0.11459562598219108, 0.10848466640631127, 0.11389965939411972, 0.1251298083726189, 0.1206848984629536, 0.10242172623659085, 0.09217815500709725, 0.10512806616948889, 0.11314497397564505, 0.09273359718312202, 0.1103779249674175, 0.10174955996543977, 0.12893873202442496, 0.10976745262872523, 0.9246816535510994, 0.9278374553711982, 0.9041335198315186, 0.9151994283449367, 0.862476487813979, 0.8672577588253028, 0.8927038064476697, 0.9051008652513206, 0.8675475743045621, 0.4021129175787599, 0.337638757674406, 0.3653307780144406, 0.3391290858515795, 0.3475476491629076, 0.3736149841004387, 0.25150684112707644, 0.33609951960828666, 0.28392505964107106, 0.7541266319949228, 0.727826155693958, 0.6943549545812722, 0.7412802882156659, 0.7438901157465984, 0.7233359764608474, 0.6977948920363832, 0.6565362518851776, 0.6337559781301354, 0.16188565515733822, 0.27209633246262777, 0.25226910312725537, 0.10978711912276795, 0.12245138737718786, 0.08801907221543082, 0.18762124357640853, 0.1956855059518975, 0.21807015309430255, 0.1172875220334787, 0.10313425323090164, 0.1084576064970737, 0.18914975134430134, 0.1480111221728756, 0.19091764409804823, 0.1362415657895304, 0.16835543649962237, 0.18713214013639845, 0.06402723207647598, 0.040719319616753236, 0.05475528476791691, 0.14342438268623903, 0.17374405203910026, 0.14264622077664713, 0.0015184619230823593, 9.999999999998899e-05, 0.03938712470306205, 0.06786887523703788, 0.06056481467360608, 0.17132702349843298, 0.05818103554681131, 0.10140323769317672, 0.060169223216381074, 0.3282092202408454, 0.26125885284475925, 0.1972003979505984, 0.002371359086370428, 0.01094708880411277, 0.011262125590703498, 0.011686718092697612, 0.03384134998862576, 0.0032189881871906856, 0.03504027793325948, 0.03092089272997367, 0.012242537422525124, 0.2637814469735821, 0.2672735340366512, 0.27282563192282383, 0.08721366010250309, 0.10697832166557841, 0.10958071083581233, 0.058353234748700245, 0.059361704434903406, 0.06460399355577462, 0.6709003289293305, 0.6599838762606643, 0.6866666463189937, 0.6904743461068534, 0.6810927595581813, 0.6983450398705691, 0.6897444695952564, 0.6598895096044197, 0.6793871406096306, 0.10647303692761323, 0.1274298417368842, 0.11697748804753283, 0.08818028315641568, 0.10876298747374058, 0.10216890064772766, 0.08093400688782493, 0.08253343408081959, 0.08393294235316717, 0.16983420996653553, 0.21177520118508386, 0.20814776721711592, 0.2211730571729995, 0.24489003103918028, 0.1687411765122, 0.16069140060150333, 0.1777490146338434, 0.16982082730118708, 0.4023197184451245, 0.38251218164129763, 0.38365035763293887, 0.392993397976633, 0.3626650884627125, 0.3975615671911572, 0.4304205837798082, 0.41023803840706385, 0.4159717799853594, 0.19226271610162637, 0.1869452627445306, 0.18004922159205927, 0.30285331834874074, 0.27022939642021804, 0.28093751467752837, 0.32024040905010165, 0.32788101077846754, 0.3293362693917936, 0.2103500951879026, 0.19202375378096892, 0.21071138605905027, 0.186969788067453, 0.20645249177128155, 0.19059504313584597, 0.20563622889159605, 0.18893239929996064, 0.20008383378727967, 0.1848165712398192, 0.17310896901997053, 0.16939052008224675, 0.26761217354750777, 0.2254800973681571, 0.19050783909126345, 0.20457475299266292, 0.18912814502568365, 0.20717530941110796, 0.6676514927251251, 0.7306424827235471, 0.6153993273710309, 0.44245741104142544, 0.42108488849216574, 0.4422530308973831, 0.7005482814054886, 0.19964127590512915, 0.7095987549745431, 0.6831734524396582, 0.6453142385236894, 0.7817598861294923, 0.3547282334591967, 0.6353104479676219, 0.5404221889421251, 0.19813550790683543, 0.21127521614564304, 0.20656190706886202, 0.2119437823747916, 0.18025595044939058, 0.18086641938064008, 0.19510931626273498, 0.20141035239750849, 0.18295664857285832, 0.2158291913511855, 0.19667218679194443, 0.18614653073503573, 0.07492681777608434, 0.08577569273016283, 0.0822331145760059, 0.0823921621756204, 0.08013676500972156, 0.08242573449751656, 0.0743375949208892, 0.07399038929334201, 0.09643106470549523]}, "mutation_prompt": null}
{"id": "b9f7193b-d8a6-4246-9f09-a44531daf89d", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "b759c301-4e2e-4213-9984-5e531ecf10ca", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "5dd6abc3-0f68-4d9d-8238-20ae2510e53e", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "5316314e-a6f0-4063-944f-82e8de3214aa", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "5fb9e987-717b-4314-819b-5dfd095017bf", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "c3591d9b-2d07-47f9-b223-d737c873ae41", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "c9d4a0a6-d135-4e3d-a734-aa20e6623d47", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "3ce0c262-e1fc-46d0-9324-3c03abdc3289", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "f5c6bdcc-85bc-4aa7-876f-6490ba9861a1", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "49fd484c-a4ab-40b2-baf5-208388d168a6", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n        self.elite_fraction = 0.1  # Fraction of elitism\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            elite_count = int(self.pop_size * self.elite_fraction)\n            elite_indices = np.argpartition(self.fitness, elite_count)[:elite_count]\n            new_population = np.copy(self.population[elite_indices])\n\n            for i in range(self.pop_size - elite_count):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population = np.vstack((new_population, trial))\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population = np.vstack((new_population, self.population[i]))\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population[:self.pop_size]\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Enhanced ImprovedADELSOptimizer with dynamic population size reduction and elitism for faster convergence and solution stability.", "configspace": "", "generation": 93, "fitness": 0.2518274456582306, "feedback": "The algorithm ImprovedADELSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.20.", "error": "", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.5275352182906697, 0.5524800406721322, 0.6247842215544783, 0.5645993963721883, 0.5300363459337655, 0.5400478292306141, 0.5545219348025185, 0.5079136219155773, 0.49930074554441284, 0.21329063566322148, 0.19431992428375766, 0.24997923821121426, 0.1834346218548485, 0.2052017203327714, 0.27109067299029144, 0.2439825955881162, 0.2548922880635771, 0.2477842511157018, 0.10150428511928111, 0.10260502156229345, 0.1880522259881111, 0.10252743135765063, 0.115719859519407, 0.12975556297736657, 0.1482965950112315, 0.11945726478214691, 0.1357169125937584, 0.09886354443163914, 0.09690943649579897, 0.0882800628278444, 0.09555176202331128, 0.09574447169958689, 0.10555488143066682, 0.1150806235455446, 0.10832037529869232, 0.08641687869370218, 0.9201682210597619, 0.7932699777127218, 0.9699108424637591, 0.9142747048956456, 0.9245360603590247, 0.9219283384970505, 0.9398360994555633, 0.87112582148983, 0.8985666003446381, 0.26963673169829117, 0.2574944923935252, 0.23408195415732602, 0.23842002530351114, 0.21553556196342016, 0.2548560456408493, 0.24052271522343982, 0.24480851465481834, 0.24336244139440888, 0.6842136392227887, 0.45772139473329887, 0.4849860734737944, 0.6639956563234863, 0.2391608560108205, 0.5808110580599357, 0.6590106904067603, 0.529298928190935, 0.6850993321534145, 0.1745582473427223, 0.15143917400624773, 0.21018300758834085, 0.15544010498443173, 0.14095314849545026, 0.1531809994350628, 0.15897221546758233, 0.2514362174309396, 0.12828715061862983, 0.11359439029942875, 0.0821841891539471, 0.1540364845645097, 0.11354655620124599, 0.20105934255729085, 0.17777858477545538, 0.12489807882415682, 0.1117189650845275, 0.18659585632480902, 0.04741017879414722, 0.09929878353839428, 0.06134967853739581, 0.07551486178907818, 0.07839646457454019, 0.03296757686028773, 0.08261218634849243, 0.1657770938631956, 0.09836493719179784, 0.2268656626392852, 0.1008708549043209, 0.23980504723490648, 0.0994009738149334, 0.1980429519168042, 0.12434608338576314, 0.24172811707625685, 0.2889563573037782, 0.29895482564707965, 0.06022702272703795, 0.04713549649349502, 0.04461980294887158, 0.04044083873952664, 0.06672229455902068, 0.0500420342924206, 0.032621068554334665, 0.06276791692849526, 0.07642779717544668, 0.13670377817725854, 0.1255762156332565, 0.1570337336392662, 0.16646240164906334, 0.14657071669380872, 0.15234445903733917, 0.13440761177123517, 0.12755399805416567, 0.18384380400181544, 0.4624115626739117, 0.4522455801286487, 0.417991819082729, 0.4532603288842695, 0.46334765786020704, 0.4788482153824888, 0.47645498165321254, 0.4570880198419982, 0.4961833444748469, 0.10195286283328275, 0.08606797934312393, 0.10026518618199265, 0.11320364341770983, 0.12406769152566266, 0.09129606289847403, 0.10165021895243864, 0.08885548170178281, 0.0986272393627291, 0.1523630344386695, 0.13416506349996127, 0.1430726599101264, 0.17050233562552297, 0.1858675798659407, 0.17907882815896825, 0.1596646634942661, 0.157438212879089, 0.16255776460461546, 0.3274616788273458, 0.2565008180098073, 0.2877410677241403, 0.27982661282538057, 0.28215716919989764, 0.28275392822083634, 0.2900705265239564, 0.2822106116760731, 0.29575385671394894, 0.22216929610446723, 0.21440673831065848, 0.20721287079549888, 0.23214063856783285, 0.21315138522191557, 0.2187896848894726, 0.2493010845535053, 0.2479232918541856, 0.24714805099876058, 0.20288990309426946, 0.20898577849645916, 0.20884643226748645, 0.18356988307706879, 0.18909532431109077, 0.1720942909887272, 0.1906708107353794, 0.17646636388135573, 0.24170801830179045, 0.1877813062171012, 0.18788903665244627, 0.1964028345444525, 0.18663314422321486, 0.19494172335937987, 0.18234772995319182, 0.20183407135169684, 0.20977028813135135, 0.2001940213604403, 0.6655475900847043, 0.1791392184994598, 0.5907854540147006, 0.21613152737231012, 0.20277361229573931, 0.5891164724745641, 0.17594798470991158, 0.17703392730096967, 0.4992777731216427, 0.15071116355482173, 0.16284345983840576, 0.537825622285945, 0.5618789752170343, 0.20906734649437342, 0.4017985147627421, 0.20730725743178335, 0.14868895001411897, 0.20677963255360643, 0.1736282626451795, 0.18336265208434255, 0.1789818239806733, 0.1817291561289327, 0.17755993403852877, 0.18439567029027326, 0.18394662196496303, 0.19905600981367266, 0.19888814833149304, 0.07184629834566691, 0.06811566034503924, 0.07850330792309557, 0.07230599827608952, 0.0764659925240816, 0.07055219387862777, 0.08607021211306143, 0.08044442272242791, 0.08064150939177506]}, "mutation_prompt": null}
{"id": "6f6125c1-e5cc-4c7f-a672-1d4608d4b9bb", "solution": "import numpy as np\n\nclass EnhancedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n        self.best_overall = np.inf\n        self.best_solution_so_far = None\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive mutation with elite influence\n                F_adaptive = 0.1 + 0.9 * np.random.rand() * (self.fitness[i] / self.best_overall)\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                # Dynamic crossover probability\n                CR_dynamic = 0.9 * (1 - evaluations / self.budget)\n                crossover_points = np.random.rand(self.dim) < CR_dynamic\n                trial = np.copy(self.population[i])\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if trial_fitness < self.best_overall:\n                    self.best_overall = trial_fitness\n                    self.best_solution_so_far = trial\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedADELSOptimizer", "description": "Enhanced ADELS with adaptive mutation scaling, dynamic crossover, and elitist selection to improve convergence performance.", "configspace": "", "generation": 94, "fitness": 0.23484969117799523, "feedback": "The algorithm EnhancedADELSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.23.", "error": "", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7650086024362438, 0.7427098036446216, 0.7481622067248187, 0.7606803171606815, 0.7749289368457241, 0.7536921506457331, 0.7512275357408633, 0.7559809619989362, 0.755891805919522, 0.05077781751365695, 0.007706730853259791, 0.00495232744475782, 0.0026721847699091583, 9.999999999998899e-05, 0.027342070083398395, 0.005679483236999294, 0.038364068277122576, 9.999999999998899e-05, 0.23313042469771794, 0.23451784314018564, 0.23701039549980396, 0.2368417940830343, 0.24098445707143767, 0.21090203032395405, 0.21488993388246003, 0.22787757338964276, 0.21082584115373093, 0.19269142756114366, 0.21268988614441764, 0.13147767457738702, 0.1775394847418985, 0.1390650848568703, 0.1774460475863271, 0.18441074159009863, 0.20251339818306457, 0.1548487387209323, 0.9690931854710126, 0.9687924592535835, 0.9796435869546019, 0.9427536431191822, 0.9289649046556825, 0.9394090747591088, 0.9407100680603584, 0.9578860206465276, 0.9824010896895032, 0.23794680873528895, 0.21548144924629986, 0.2180939190812805, 0.25943556994555095, 0.2201705494902476, 0.2459361583089642, 0.20366884337683488, 0.2012530119870679, 0.21973591635742162, 0.2925851278186188, 0.30551027662861674, 0.5445372064842859, 0.28942238684433397, 0.28387498597097716, 0.2538874380230063, 0.24348766825045143, 0.1949230199914993, 0.23764777017150396, 0.11935276253090144, 0.10946682663058094, 0.10926659423822349, 0.11692913161910257, 0.10895817533435259, 0.11120780642674111, 0.06932020550735285, 0.09947648701260792, 0.09405080514680353, 0.0897859425248716, 0.14928309183899147, 0.09592424278381873, 0.12016309878279463, 0.11070946681044591, 0.07904643336030492, 0.09475823052726495, 0.09314134881833958, 0.123581276789683, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002970678869318011, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.038178484179682504, 0.03394681139901479, 0.04105553571939802, 0.02234008823092626, 0.04203711106588437, 0.011988512895807935, 0.08756198686374939, 0.08051579908526274, 0.0625229652852537, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07685380303467826, 0.06804315429939312, 0.07814523971194998, 0.08191194511350508, 0.10474387572401012, 0.07033340825660106, 0.09005812660525714, 0.10272142266543272, 0.10077830348916539, 0.4728603000813829, 0.4877939898158854, 0.5156304921448317, 0.4707872202994309, 0.4734997165078476, 0.49041839501413964, 0.47315051191325186, 0.4605290698773331, 0.5125618501521281, 0.09669618893427379, 0.11441992049074712, 0.10040873683551521, 0.10211453535610182, 0.11318710248486386, 0.11336918111580085, 0.08374705071939026, 0.07795594371054049, 0.08362452460039227, 0.2038296807810156, 0.1671928899662818, 0.14859143964641264, 0.16046082892023028, 0.17574724938493913, 0.2048645133621766, 0.16404011392303763, 0.18797208343757466, 0.26973518955629694, 0.3330514001905396, 0.3148139193415227, 0.303255783394798, 0.29065023483292063, 0.2794386661233089, 0.3150587819582139, 0.3690416407720041, 0.3922843991596817, 0.33824358340827354, 0.18305414915299822, 0.19583661851835754, 0.16216826721764466, 0.19328957865410246, 0.18841635750696928, 0.22869744909632805, 0.2046230849880537, 0.22100066151229947, 0.22055931653765126, 0.20529304334182852, 0.18242682861950688, 0.19319109420328873, 0.21124481825834796, 0.20645492970588952, 0.20146315342861, 0.20195249540311344, 0.19941502499789854, 0.19574802673621838, 0.17058559673555518, 0.18125658473484207, 0.15356099016969982, 0.19520799103632858, 0.18979061420814192, 0.19140478043661024, 0.18173354899968897, 0.14583089143574957, 0.16646175253956585, 0.3801345704160166, 0.17677024970480548, 0.3673370428705721, 0.180116180795579, 0.19478034621171803, 0.19722438475289072, 0.7295683173691536, 0.46705499419020047, 0.6619397637750685, 0.3549460820764946, 0.3197678617337627, 0.433165983969544, 0.2508886201063555, 0.26667186474626425, 0.4157195680875371, 0.4588260645344835, 0.32055599388282285, 0.2112290179627765, 0.1721214564347332, 0.1953869825203971, 0.18402380803208807, 0.1882250056865934, 0.1896439940640009, 0.2031698751268669, 0.18718522999942555, 0.17111613374295198, 0.17667007792916078, 0.08012764414987428, 0.07992307939618515, 0.0853514241485458, 0.0718455517468638, 0.08519771653311548, 0.07795470626774337, 0.07155122674478975, 0.07084312757462852, 0.08308347177494901]}, "mutation_prompt": null}
{"id": "9dc41805-f3d5-48aa-b935-8b5b6221dbaf", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "98049ba9-0b88-4bcb-9d4f-90864e25e4df", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "ed9b165c-6793-4c85-a37e-b24e11b815dc", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
{"id": "0e5f5faf-a46a-49fc-9856-ec06562fbe37", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n        self.best_global_fitness = np.inf\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            self.best_global_fitness = min(self.best_global_fitness, self.fitness[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                if self.fitness[best_idx] < self.best_global_fitness:\n                    self.best_global_fitness = self.fitness[best_idx]\n                    self.local_search(best_idx, func)\n                    evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n            # Periodic re-evaluation to avoid stagnation\n            if evaluations % (self.pop_size * 2) == 0:\n                for i in range(self.pop_size):\n                    self.fitness[i] = func(self.population[i])\n                    evaluations += 1\n                    if evaluations >= self.budget:\n                        return self.best_solution()\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Enhanced ImprovedADELSOptimizer with adaptive local search scaling and periodic re-evaluation for increased exploitation and robustness.", "configspace": "", "generation": 98, "fitness": 0.37347756734172066, "feedback": "The algorithm ImprovedADELSOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.24.", "error": "", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7578407753717599, 0.7499871177142694, 0.7639593415741066, 0.7765511320010455, 0.7376212229551724, 0.7620607753733539, 0.7692997414186611, 0.7745579672311258, 0.7638613750978266, 0.5517627731059884, 0.5650006028059045, 0.5442680231166225, 0.5881594212839171, 0.5599697961628247, 0.5568534321577079, 0.5602961952855372, 0.5836129506968188, 0.5820058603031861, 0.14036190628478085, 0.16530152480490068, 0.14706035382123572, 0.15884604277504355, 0.13633889900228335, 0.14141683965636365, 0.12476486070537107, 0.20775588008023582, 0.12013103115199242, 0.1107845234353324, 0.11192032635226312, 0.13502936368359264, 0.11602351580735704, 0.1265277260582226, 0.12875298393294432, 0.11320559258902818, 0.1386393581928982, 0.1469546984471457, 0.9365515388532055, 0.856212381190117, 0.8639813701146603, 0.8196359264534923, 0.9167119213386732, 0.9054010395990365, 0.921568541807576, 0.9221535699256395, 0.9388523583487033, 0.3415285353670583, 0.41563331385628566, 0.39243703148287234, 0.42066890781750577, 0.36898165046570564, 0.44165417392475814, 0.48763196852495017, 0.3630119973534457, 0.3897023537656441, 0.7199761905382895, 0.8217771123650526, 0.7153074136123779, 0.7000326296465605, 0.7293664489924278, 0.795615741867618, 0.7478684339239421, 0.7749574550434297, 0.7861990340474577, 0.2464006242466361, 0.1831590329823759, 0.3079637561015304, 0.12321017811495727, 0.3221078938033226, 0.3572889169635146, 0.27858329543987614, 0.17067251133464556, 0.2645766646687039, 0.14557140227047316, 0.216656579803004, 0.20351092768702894, 0.2127054520620245, 0.23731528323697437, 0.18608499307029347, 0.3226047512530279, 0.44455931791732306, 0.18451416203056292, 0.35919996849306557, 0.31743101862521184, 0.36685498451104126, 0.3724435250492334, 0.32471975389428875, 0.24344779709126074, 0.3215361019920868, 0.33736683948936996, 0.29080961623963864, 0.46781637907826557, 0.5102468223410852, 0.4896416788982979, 0.44188920021697964, 0.4471807728946279, 0.44252185633091434, 0.485299640372474, 0.4899570994936132, 0.5282036627288658, 0.13281806443177413, 0.11363839332464798, 0.13731958408082934, 0.2169012184314566, 0.18982052750906486, 0.2246242906962057, 0.1767800301157758, 0.18993252314968467, 0.11726661931262228, 0.27585729722639507, 0.2867647782949888, 0.2837968203612219, 0.29169522474684684, 0.2907659492273693, 0.27473250949539973, 0.27742462019726855, 0.26258112191102634, 0.2506504284477392, 0.6915490570690552, 0.6825820013435661, 0.6819070318734466, 0.6440084330091377, 0.6409102653757349, 0.643132896193837, 0.6426058123483738, 0.630208886420327, 0.6793801410966642, 0.10140611137680022, 0.12272495119993743, 0.10108294557419029, 0.1284341984833962, 0.09876520164473201, 0.10535868654587088, 0.12876736766502395, 0.10706277220929039, 0.11459217658569432, 0.14630387293319436, 0.2931557435583525, 0.15860007941820098, 0.17846187867952612, 0.14914874303606807, 0.1432865413270794, 0.1949388073654641, 0.145197708640874, 0.21000691503130908, 0.4134128045162824, 0.38347474010498794, 0.39422198559000887, 0.4099233133380087, 0.39773381092424676, 0.44033793038114766, 0.3919994422324168, 0.41068492656802735, 0.4402801438522531, 0.33060672910641176, 0.29384137454227, 0.30678139787006875, 0.29151756854563826, 0.3006603861084476, 0.3286067635680927, 0.2861171929467208, 0.37414687926283974, 0.31804724589464317, 0.18759904656319237, 0.18250140892758504, 0.1758550321313025, 0.1927404094378119, 0.1849879160951865, 0.20960732378889335, 0.20629037189156885, 0.1976586111912345, 0.19965659333548524, 0.20090842801615305, 0.3594672928699916, 0.3189972889606404, 0.2044149852739554, 0.3017183636106062, 0.2290399528762116, 0.34647078255087604, 0.1990588143164389, 0.23860422336187026, 0.8159258198789565, 0.18094243290438783, 0.8089703878750346, 0.7739790052984562, 0.6941849174578051, 0.7656162694575862, 0.7208041698172167, 0.7616576579842138, 0.6959082299960151, 0.5999661974191366, 0.5667802639702731, 0.6741827298297671, 0.6326336746407253, 0.16465344700174134, 0.7106861355381067, 0.6367253976590315, 0.14916557035864464, 0.21057895284139772, 0.17252555197950592, 0.18355076518520497, 0.18084039113316785, 0.19318765019639983, 0.18096606596997744, 0.19374553848258813, 0.1764371000175875, 0.1723237069680077, 0.18654096078443105, 0.07164719282358001, 0.08329989952891503, 0.08207252641433227, 0.07440671885030115, 0.07370551908233702, 0.079182676970046, 0.08033484072678043, 0.07148356523396637, 0.09166647662914529]}, "mutation_prompt": null}
{"id": "fc09784b-787d-433b-978b-15f13fc0f3c2", "solution": "import numpy as np\n\nclass ImprovedADELSOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.local_search_intensity = 5\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement = True\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n            if evaluations >= self.budget:\n                return self.best_solution()\n\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive scaling factor\n                F_adaptive = 0.1 + 0.9 * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    improvement = True\n                else:\n                    new_population[i] = self.population[i]\n                \n                if evaluations >= self.budget:\n                    return self.best_solution()\n\n            self.population = new_population\n\n            if improvement:\n                self.local_search_intensity = max(1, self.local_search_intensity - 1)\n                improvement = False\n                self.no_improvement_count = 0\n            else:\n                self.local_search_intensity = min(10, self.local_search_intensity + 1)\n                self.no_improvement_count += 1\n\n            if evaluations + self.local_search_intensity <= self.budget:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += self.local_search_intensity\n\n            # Re-initialize if no improvement\n            if self.no_improvement_count > 5:\n                random_idx = np.random.choice(self.pop_size, 1)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n                self.no_improvement_count = 0\n\n        return self.best_solution()\n\n    def local_search(self, index, func):\n        candidate = self.population[index]\n        for _ in range(self.local_search_intensity):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            local_candidate = candidate + perturbation\n            local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_candidate)\n            if local_fitness < self.fitness[index]:\n                self.population[index] = local_candidate\n                self.fitness[index] = local_fitness\n\n    def best_solution(self):\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedADELSOptimizer", "description": "Improved ADELS with adaptive scaling factor and re-initialization strategy for enhanced exploration and robustness.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8aa478ac-3f88-4a7f-ad71-54867694aca5", "metadata": {"aucs": [0.7604090520670865, 0.7601404893690636, 0.7603809561260301, 0.7695226257480972, 0.7306913562600099, 0.7456202625305267, 0.7631131708139183, 0.7439606022317533, 0.7511717943485229, 0.567580798808293, 0.5681532003608212, 0.5738415849006502, 0.5893673232132061, 0.5877859227787805, 0.5834160066264484, 0.5674138142359526, 0.5877660694051057, 0.5575693507962081, 0.1254052796614935, 0.12347757369872436, 0.13426098541979714, 0.1980739030009162, 0.12424793789148603, 0.1800209529950667, 0.13941728495323258, 0.1266948882675728, 0.143877342392296, 0.1129595266865896, 0.12393139379024087, 0.11787897370594869, 0.11247070920074187, 0.11152107483101625, 0.129194058060478, 0.11667272224220904, 0.12935843113291445, 0.11345527975317404, 0.913796080717592, 0.8870823169149136, 0.9053078102066539, 0.9229220023454949, 0.9364364313586672, 0.9116095510221474, 0.9576411291330591, 0.9491312291414877, 0.9026719498640526, 0.45118849194990795, 0.3933552542953065, 0.431290354128688, 0.36817456730688114, 0.4304375722962276, 0.44618073016730464, 0.4156783044334652, 0.43182132910402893, 0.47856000491294404, 0.7545599503730211, 0.7404514734909051, 0.6882130000351654, 0.7820223598868887, 0.7782168019455428, 0.7825711332687889, 0.6919722548207204, 0.7495663990180166, 0.7977160641989877, 0.2166985134909074, 0.22795320020933896, 0.387261825747202, 0.23666927263032012, 0.19821790714805088, 0.20225827366300386, 0.24432723936057832, 0.3644483189143479, 0.30046747364230075, 0.20704107254863646, 0.18325488926236555, 0.214331155952448, 0.23052234199724164, 0.32219084703042966, 0.18532779194185378, 0.19052175206311595, 0.2364227404325303, 0.19610389410967877, 0.3496108532686407, 0.36634720969524615, 0.3383640218077437, 0.3999164029911221, 0.35043018714284524, 0.2677168162511735, 0.30568941165380625, 0.33547931628798755, 0.3131928227749521, 0.46038513455239893, 0.41346827212563775, 0.4602960724570698, 0.4898670323610833, 0.46776954048704955, 0.4252970653818894, 0.4974295395877286, 0.5333169785454326, 0.48517015692302234, 0.1228653916107878, 0.0902543177488716, 0.08364245544695792, 0.2148818554546772, 0.26966757229613814, 0.12141536489609295, 0.18098675713779822, 0.1974912396577435, 0.11883786970324495, 0.2810957844523214, 0.27244757263752983, 0.27238804223414836, 0.3043019377422034, 0.29856599675293816, 0.3041145976073456, 0.2448910296504031, 0.30475194315552034, 0.2682438773967907, 0.6835066212299508, 0.6805511664688988, 0.6719128932970462, 0.62108291343447, 0.6675383390044232, 0.6686740919512382, 0.6843694557752779, 0.6182529347895169, 0.6862102102187578, 0.1032806292808951, 0.11875009238436085, 0.11084693881943453, 0.11955590197482946, 0.11077049736501654, 0.12238208363133085, 0.10289895771542668, 0.13955618365053435, 0.11875609279674193, 0.20306323241484048, 0.2247538099186962, 0.2440252650266448, 0.18164715427020928, 0.20479574893366492, 0.2671437946621681, 0.19884294304055017, 0.18195674209081836, 0.16744773489017284, 0.4474488035993678, 0.4374484475002217, 0.38381842095766494, 0.39886858011452975, 0.40054466215775497, 0.41735542423719085, 0.3899691171986164, 0.44350648921762714, 0.41051151236429173, 0.30892556641917235, 0.32334765948429933, 0.31802733101830294, 0.28165643972157495, 0.2856011116535694, 0.3071692749937964, 0.34416935306803376, 0.349161967846515, 0.33977335167119205, 0.2061034895104713, 0.1930266388810271, 0.1924271199870865, 0.1962448115383063, 0.17726109180481908, 0.18061520369397366, 0.21677626621962154, 0.201209485467863, 0.18644890247417667, 0.23948492092552887, 0.27988597169721197, 0.36768911958076844, 0.22703708946332857, 0.21847156599841489, 0.3199722887165659, 0.5138834035812596, 0.41063855853686915, 0.39566357921008655, 0.6608256636810006, 0.7439151133042452, 0.7109994202865213, 0.7096099986850881, 0.6630338480997167, 0.8201571744929368, 0.8174530343629169, 0.7108114176296765, 0.7834214416720462, 0.7427602636208462, 0.5218005416823583, 0.6283728858435802, 0.6629411913905405, 0.6878455196984926, 0.7426170199632175, 0.7423976565373978, 0.14837537882567142, 0.21298185153184412, 0.17320238073751937, 0.18908459964084756, 0.18615047951732666, 0.18605757336474493, 0.1764595401594956, 0.17073257218435844, 0.17867875586394677, 0.19073936698135385, 0.18446847098571595, 0.07809291837493437, 0.0772877498763348, 0.08986037483755593, 0.08069857414958437, 0.08423298097626997, 0.07428657552442186, 0.08126699441835494, 0.083997097981238, 0.07719018686583246]}, "mutation_prompt": null}
