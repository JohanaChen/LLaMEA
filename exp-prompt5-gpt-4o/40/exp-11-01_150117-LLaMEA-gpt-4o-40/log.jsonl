{"id": "f2cdd4c2-6542-4060-a4de-e855d2f9f144", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (10 * dim)))\n        self.f = 0.5  # Differential evolution scaling factor\n        self.cr = 0.7  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = (self.w * velocities \n                         + self.c1 * r1 * (personal_best - population) \n                         + self.c2 * r2 * (global_best - population))\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "HybridDEPSO", "description": "A hybrid evolutionary and swarm-based algorithm, combining differential evolution and particle swarm optimization, adapts dynamically to search space dimensionality and complexity for efficient exploration and exploitation within a limited budget.", "configspace": "", "generation": 0, "fitness": 0.3103272408105577, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.27.", "error": "", "parent_id": null, "metadata": {"aucs": [0.8251647471904195, 0.8227904645914664, 0.8464487043158307, 0.8294390971035444, 0.8255093631645593, 0.8358376912004718, 0.8398782360709972, 0.8288824460303248, 0.8285286785300631, 0.6489141629081737, 0.6458137371260453, 0.22976862585429159, 0.6462306277045214, 0.6539090521439623, 0.06462254518574195, 0.40386556352503244, 0.05671810206597816, 0.4380414604765638, 0.16309813870100864, 0.1143280742515499, 0.07204183122351882, 0.13260241642594883, 0.17796018568292582, 0.14525546953782065, 0.17318864914969168, 0.17303473515053192, 0.10824383202544119, 0.13722268962524664, 0.1371700624835004, 0.1206020541145636, 0.13623116738949503, 0.12149837155627008, 0.11094273761639051, 0.16858872471909658, 0.1514288105370024, 0.11713565103626511, 0.9642350383362817, 0.9674057052973665, 0.9723521600864173, 0.9472395299832335, 0.9686507195251154, 0.9732820555991173, 0.9745842565814995, 0.9816534864997477, 0.9641291073133742, 0.5716337414327806, 0.6041730699492114, 0.6102506179673011, 0.6248690479427352, 0.1494406078309719, 0.6731163724893396, 0.12364000833391087, 0.5957054498078784, 0.12554220577271824, 0.8265667883569601, 0.22510120977365322, 0.85270340913916, 0.3677248112247793, 0.2793879947291461, 0.19287820599250094, 0.2171939391590897, 0.33613321235256954, 0.8656464627042229, 0.212925899014606, 0.13414490800548207, 0.3526304323366718, 0.18751015161735962, 0.18671628458613954, 0.18602134660642, 0.21148003452528463, 0.10866506494134132, 0.12999885044802084, 0.13059787564300185, 0.11686930632183934, 0.21772049038190477, 0.13181018807331202, 0.21987002477133677, 0.20358954050562417, 0.22692862296194494, 0.20315974027033912, 0.18581647747740904, 0.07445048759976203, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0378433341999187, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07379114330585834, 0.04638678745733249, 0.08300195210193684, 0.08370907075167067, 0.10591608941588349, 0.029836248453943837, 0.0636287373284038, 0.09325360606547473, 0.06310988673651885, 0.0457730286209479, 0.033652720074391795, 0.04621360202436331, 0.07286535304925967, 0.08814550655463849, 0.07190196081316991, 0.088675882462803, 0.16118937299731728, 0.17184423549139682, 0.12938405762906802, 0.12773246725298415, 0.24733835243370983, 0.16566509509959992, 0.3171550590823592, 0.11354645479440095, 0.053971070661603004, 0.07604352852644003, 0.08039178488047982, 0.5262150280236269, 0.568348736228005, 0.5725318195255249, 0.535066152009792, 0.5253630628481165, 0.6028246456880497, 0.5639403541529372, 0.572788078264381, 0.5922179730514407, 0.13858049608357048, 0.1140415469216608, 0.13514305031247187, 0.10543948770953071, 0.1311353177932859, 0.130468031098824, 0.15138975236411967, 0.13355429375791372, 0.1241796007089222, 0.1776089883101537, 0.2519132675539272, 0.1918040525007525, 0.2566690281664501, 0.32341108201577595, 0.2648665908586717, 0.17828663472076534, 0.21047850737600482, 0.24841171248975713, 0.4059317916094428, 0.23572422699409468, 0.47062397954357493, 0.5294038642594114, 0.4020321046062062, 0.4802464413676193, 0.5862067807824437, 0.5831901827472739, 0.5574206631206033, 0.28545525756064594, 0.17049474230081707, 0.289973778722285, 0.2388027150884935, 0.22913312921303097, 0.24367183765115574, 0.45274451166516494, 0.38917333881129057, 0.2806900392658306, 0.2518849165016671, 0.18785538251841938, 0.20866247538467264, 0.23809213034143473, 0.21921532515394726, 0.22151188282520995, 0.20618668059149303, 0.24772140863305514, 0.1920072738694445, 0.23569265119392202, 0.22036856959631468, 0.6435053432594741, 0.2225474414123656, 0.18604809559388336, 0.24590225001129606, 0.21234768144886373, 0.21996975893624116, 0.22077902570610708, 0.8808862074282178, 0.1128591555123456, 0.15280644174043678, 0.8880424395001292, 0.19971284365983077, 0.2111962099406487, 0.14239832665442587, 0.8718203830128949, 0.1639917253087937, 0.6887736471455064, 0.21095549047054152, 0.7299325539322526, 0.6834732648229717, 0.7900910434760625, 0.20538533601425035, 0.6179462928104767, 0.10399132571052849, 0.2985035745596182, 0.2114590846189568, 0.19491510578799764, 0.19626262695778052, 0.229466047481096, 0.18731500267214796, 0.19027143344441289, 0.2182812280995401, 0.20691977616819945, 0.18861803661371257, 0.09200880761236707, 0.08456812298385796, 0.10266674019698252, 0.09143038124012914, 0.10219288217769662, 0.09960646818687569, 0.08779138533527187, 0.08632558907355725, 0.09017583095929271]}, "mutation_prompt": null}
{"id": "146e7c6d-cf41-4de7-8a79-dac7fa4f7891", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (10 * dim)))\n        self.f = 0.5  # Differential evolution scaling factor\n        self.cr = 0.7  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = (self.w * velocities \n                         + self.c1 * r1 * (personal_best - population) \n                         + self.c2 * r2 * (global_best - population))\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "HybridDEPSO", "description": "A hybrid evolutionary and swarm-based algorithm, combining differential evolution and particle swarm optimization, adapts dynamically to search space dimensionality and complexity for efficient exploration and exploitation within a limited budget.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f2cdd4c2-6542-4060-a4de-e855d2f9f144", "metadata": {"aucs": [0.8251647471904195, 0.8227904645914664, 0.8464487043158307, 0.8294390971035444, 0.8255093631645593, 0.8358376912004718, 0.8398782360709972, 0.8288824460303248, 0.8285286785300631, 0.6489141629081737, 0.6458137371260453, 0.22976862585429159, 0.6462306277045214, 0.6539090521439623, 0.06462254518574195, 0.40386556352503244, 0.05671810206597816, 0.4380414604765638, 0.16309813870100864, 0.1143280742515499, 0.07204183122351882, 0.13260241642594883, 0.17796018568292582, 0.14525546953782065, 0.17318864914969168, 0.17303473515053192, 0.10824383202544119, 0.13722268962524664, 0.1371700624835004, 0.1206020541145636, 0.13623116738949503, 0.12149837155627008, 0.11094273761639051, 0.16858872471909658, 0.1514288105370024, 0.11713565103626511, 0.9642350383362817, 0.9674057052973665, 0.9723521600864173, 0.9472395299832335, 0.9686507195251154, 0.9732820555991173, 0.9745842565814995, 0.9816534864997477, 0.9641291073133742, 0.5716337414327806, 0.6041730699492114, 0.6102506179673011, 0.6248690479427352, 0.1494406078309719, 0.6731163724893396, 0.12364000833391087, 0.5957054498078784, 0.12554220577271824, 0.8265667883569601, 0.22510120977365322, 0.85270340913916, 0.3677248112247793, 0.2793879947291461, 0.19287820599250094, 0.2171939391590897, 0.33613321235256954, 0.8656464627042229, 0.212925899014606, 0.13414490800548207, 0.3526304323366718, 0.18751015161735962, 0.18671628458613954, 0.18602134660642, 0.21148003452528463, 0.10866506494134132, 0.12999885044802084, 0.13059787564300185, 0.11686930632183934, 0.21772049038190477, 0.13181018807331202, 0.21987002477133677, 0.20358954050562417, 0.22692862296194494, 0.20315974027033912, 0.18581647747740904, 0.07445048759976203, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0378433341999187, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07379114330585834, 0.04638678745733249, 0.08300195210193684, 0.08370907075167067, 0.10591608941588349, 0.029836248453943837, 0.0636287373284038, 0.09325360606547473, 0.06310988673651885, 0.0457730286209479, 0.033652720074391795, 0.04621360202436331, 0.07286535304925967, 0.08814550655463849, 0.07190196081316991, 0.088675882462803, 0.16118937299731728, 0.17184423549139682, 0.12938405762906802, 0.12773246725298415, 0.24733835243370983, 0.16566509509959992, 0.3171550590823592, 0.11354645479440095, 0.053971070661603004, 0.07604352852644003, 0.08039178488047982, 0.5262150280236269, 0.568348736228005, 0.5725318195255249, 0.535066152009792, 0.5253630628481165, 0.6028246456880497, 0.5639403541529372, 0.572788078264381, 0.5922179730514407, 0.13858049608357048, 0.1140415469216608, 0.13514305031247187, 0.10543948770953071, 0.1311353177932859, 0.130468031098824, 0.15138975236411967, 0.13355429375791372, 0.1241796007089222, 0.1776089883101537, 0.2519132675539272, 0.1918040525007525, 0.2566690281664501, 0.32341108201577595, 0.2648665908586717, 0.17828663472076534, 0.21047850737600482, 0.24841171248975713, 0.4059317916094428, 0.23572422699409468, 0.47062397954357493, 0.5294038642594114, 0.4020321046062062, 0.4802464413676193, 0.5862067807824437, 0.5831901827472739, 0.5574206631206033, 0.28545525756064594, 0.17049474230081707, 0.289973778722285, 0.2388027150884935, 0.22913312921303097, 0.24367183765115574, 0.45274451166516494, 0.38917333881129057, 0.2806900392658306, 0.2518849165016671, 0.18785538251841938, 0.20866247538467264, 0.23809213034143473, 0.21921532515394726, 0.22151188282520995, 0.20618668059149303, 0.24772140863305514, 0.1920072738694445, 0.23569265119392202, 0.22036856959631468, 0.6435053432594741, 0.2225474414123656, 0.18604809559388336, 0.24590225001129606, 0.21234768144886373, 0.21996975893624116, 0.22077902570610708, 0.8808862074282178, 0.1128591555123456, 0.15280644174043678, 0.8880424395001292, 0.19971284365983077, 0.2111962099406487, 0.14239832665442587, 0.8718203830128949, 0.1639917253087937, 0.6887736471455064, 0.21095549047054152, 0.7299325539322526, 0.6834732648229717, 0.7900910434760625, 0.20538533601425035, 0.6179462928104767, 0.10399132571052849, 0.2985035745596182, 0.2114590846189568, 0.19491510578799764, 0.19626262695778052, 0.229466047481096, 0.18731500267214796, 0.19027143344441289, 0.2182812280995401, 0.20691977616819945, 0.18861803661371257, 0.09200880761236707, 0.08456812298385796, 0.10266674019698252, 0.09143038124012914, 0.10219288217769662, 0.09960646818687569, 0.08779138533527187, 0.08632558907355725, 0.09017583095929271]}, "mutation_prompt": null}
{"id": "291c8af0-465a-4f82-a39d-5d457ae444c8", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (10 * dim)))\n        self.f = 0.5  # Differential evolution scaling factor\n        self.cr = 0.9  # Increase crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 2.0  # Increase cognitive coefficient\n        self.c2 = 2.0  # Increase social coefficient\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))  # Initialize velocities with random values\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = (self.w * velocities \n                         + self.c1 * r1 * (personal_best - population) \n                         + self.c2 * r2 * (global_best - population))\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "HybridDEPSO", "description": "A synergistic evolutionary-swarm algorithm with adaptive parameters dynamically balances exploration and exploitation, improving convergence speed and robustness.", "configspace": "", "generation": 2, "fitness": 0.2610686442676468, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "f2cdd4c2-6542-4060-a4de-e855d2f9f144", "metadata": {"aucs": [0.7076625200932521, 0.69861522670759, 0.6541888016013582, 0.1899879550037572, 0.6972792398100394, 0.7450771155636784, 0.7080174875817413, 0.716021776018404, 0.6694387051502588, 0.4195595474376158, 0.3954749736343741, 0.38231069498796755, 0.3756955474419147, 0.40941618083408426, 0.37160320727737184, 0.39798632946890333, 0.2574125139317214, 0.4439212670171452, 0.11173737057227795, 0.21989077929569234, 0.10868870354474403, 0.12829074433752352, 0.17964723248100833, 0.11070512623529216, 0.14211567509300016, 0.10923921355190014, 0.1389405485594718, 0.13031696024535178, 0.13521718480376, 0.11820541492374104, 0.10175866043285076, 0.16476117227396225, 0.11456742625604388, 0.13417837172944513, 0.12786347919438645, 0.10851910717016566, 0.97056871436292, 0.9734673271828918, 0.9774183575091111, 0.9817996522104895, 0.9627566094959615, 0.9637162210799021, 0.9732569221565066, 0.9725625804096845, 0.9809410870412195, 0.3097767303373361, 0.3383164138145712, 0.27724156951298684, 0.3290384531405258, 0.34350720189089434, 0.3251923498488851, 0.33397666750069444, 0.2865643615733434, 0.2379407765835786, 0.6759509150845628, 0.7023984027429907, 0.6657057271943765, 0.7447496959859846, 0.271937992698127, 0.1910975909068524, 0.6499009707460032, 0.4561514071273808, 0.12483029492326636, 0.17436005741783156, 0.11326301586210319, 0.21701275085225513, 0.15697237687082433, 0.16456655441727075, 0.15293683350779086, 0.16452834833975283, 0.17151114261747102, 0.15726113937952868, 0.2071578150159581, 0.17362568408763968, 0.163209539354924, 0.12920016347848673, 0.0756423349748826, 0.12741694506630086, 0.22560577943052762, 0.01226729491829015, 0.14718379719760555, 9.999999999998899e-05, 0.0021968025347212095, 0.012583166015323721, 0.000474564324569271, 9.999999999998899e-05, 9.999999999998899e-05, 0.018194545852643795, 9.999999999998899e-05, 9.999999999998899e-05, 0.15471133051030628, 0.11131875924324575, 0.13755825783509212, 0.027374490704167198, 0.05039973662115338, 0.0201835395699711, 0.02439152348868412, 0.0482576519331982, 0.049959990474597316, 0.027945718660697616, 0.02783822360672583, 0.1385413396197337, 0.07398555798823181, 0.060633178132773025, 0.08914820976352855, 0.07642945531438705, 0.08281787925924089, 0.0732750226224933, 0.05848746225542434, 0.13807248686383777, 0.12528717358449626, 0.14893199849956074, 0.10759280113517744, 0.07099787699179327, 0.07555982277260298, 0.07714662942617889, 0.07432247280155047, 0.4747561172699081, 0.49598788381839254, 0.49187775126787303, 0.49456957396231105, 0.46190375762075453, 0.47497801136095363, 0.4985997014834205, 0.5205166753084401, 0.46565132651177377, 0.13402703102116498, 0.09691566303874222, 0.05107283340708524, 0.1012810960192948, 0.09668575288018078, 0.11555052787993136, 0.1549817561863458, 0.0983255335041151, 0.10342177288524546, 0.17775882092297013, 0.1977988226841757, 0.19961089434828094, 0.20324005064545192, 0.17803329015321556, 0.2217362930632364, 0.2113503178870031, 0.19804964880563647, 0.18109048547371398, 0.3064849454614559, 0.3552852630940616, 0.34177948234996036, 0.31831207761365043, 0.3541124043557047, 0.2806023180431444, 0.32435206937668437, 0.3838753798991097, 0.3186559339513586, 0.2522161481207952, 0.28366924751944445, 0.2763224672999146, 0.23169790837102944, 0.24583344495582216, 0.2617300146783075, 0.16892922740727312, 0.3157557996007343, 0.21822637527097832, 0.19437253355175155, 0.1965409365495333, 0.19982154824007337, 0.2390113959262088, 0.1869876041059383, 0.20306266434987674, 0.221089096474114, 0.1930238248314352, 0.19760026467744252, 0.2171036243328206, 0.1883952339754098, 0.1920288991258604, 0.2813630231652222, 0.19084197676841008, 0.18478663381987737, 0.21298782954381457, 0.20582844362189112, 0.3991152563342646, 0.1744800214556672, 0.16639835264669023, 0.15310681150167182, 0.8260739272145642, 0.19845728440882282, 0.12637575299157577, 0.1691410286184135, 0.16186967157276722, 0.712772453925099, 0.5771604107373864, 0.20787806606659642, 0.15640803767584222, 0.650274435046311, 0.16598979303094386, 0.16652836400586601, 0.1579134190384871, 0.19809640302495268, 0.18643443174450525, 0.18145604792477932, 0.18899289788107188, 0.17860518792990754, 0.18520190601568398, 0.2004091165479871, 0.19158755648971926, 0.20149277028108803, 0.1888577884417506, 0.18487958765061918, 0.07780265547946785, 0.07377330922827874, 0.08017238414455918, 0.07713117517893464, 0.07680404411741093, 0.0811156558016859, 0.07993881769052857, 0.0739623712905122, 0.10779604432017709]}, "mutation_prompt": null}
{"id": "73b6945a-d61c-4b34-83b6-a9baf59aa94c", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (10 * dim)))\n        self.f = 0.5  # Differential evolution scaling factor\n        self.cr = 0.7  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = (self.w * velocities \n                         + self.c1 * r1 * (personal_best - population) \n                         + self.c2 * r2 * (global_best - population))\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "HybridDEPSO", "description": "A hybrid evolutionary and swarm-based algorithm, combining differential evolution and particle swarm optimization, adapts dynamically to search space dimensionality and complexity for efficient exploration and exploitation within a limited budget.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f2cdd4c2-6542-4060-a4de-e855d2f9f144", "metadata": {"aucs": [0.8251647471904195, 0.8227904645914664, 0.8464487043158307, 0.8294390971035444, 0.8255093631645593, 0.8358376912004718, 0.8398782360709972, 0.8288824460303248, 0.8285286785300631, 0.6489141629081737, 0.6458137371260453, 0.22976862585429159, 0.6462306277045214, 0.6539090521439623, 0.06462254518574195, 0.40386556352503244, 0.05671810206597816, 0.4380414604765638, 0.16309813870100864, 0.1143280742515499, 0.07204183122351882, 0.13260241642594883, 0.17796018568292582, 0.14525546953782065, 0.17318864914969168, 0.17303473515053192, 0.10824383202544119, 0.13722268962524664, 0.1371700624835004, 0.1206020541145636, 0.13623116738949503, 0.12149837155627008, 0.11094273761639051, 0.16858872471909658, 0.1514288105370024, 0.11713565103626511, 0.9642350383362817, 0.9674057052973665, 0.9723521600864173, 0.9472395299832335, 0.9686507195251154, 0.9732820555991173, 0.9745842565814995, 0.9816534864997477, 0.9641291073133742, 0.5716337414327806, 0.6041730699492114, 0.6102506179673011, 0.6248690479427352, 0.1494406078309719, 0.6731163724893396, 0.12364000833391087, 0.5957054498078784, 0.12554220577271824, 0.8265667883569601, 0.22510120977365322, 0.85270340913916, 0.3677248112247793, 0.2793879947291461, 0.19287820599250094, 0.2171939391590897, 0.33613321235256954, 0.8656464627042229, 0.212925899014606, 0.13414490800548207, 0.3526304323366718, 0.18751015161735962, 0.18671628458613954, 0.18602134660642, 0.21148003452528463, 0.10866506494134132, 0.12999885044802084, 0.13059787564300185, 0.11686930632183934, 0.21772049038190477, 0.13181018807331202, 0.21987002477133677, 0.20358954050562417, 0.22692862296194494, 0.20315974027033912, 0.18581647747740904, 0.07445048759976203, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0378433341999187, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07379114330585834, 0.04638678745733249, 0.08300195210193684, 0.08370907075167067, 0.10591608941588349, 0.029836248453943837, 0.0636287373284038, 0.09325360606547473, 0.06310988673651885, 0.0457730286209479, 0.033652720074391795, 0.04621360202436331, 0.07286535304925967, 0.08814550655463849, 0.07190196081316991, 0.088675882462803, 0.16118937299731728, 0.17184423549139682, 0.12938405762906802, 0.12773246725298415, 0.24733835243370983, 0.16566509509959992, 0.3171550590823592, 0.11354645479440095, 0.053971070661603004, 0.07604352852644003, 0.08039178488047982, 0.5262150280236269, 0.568348736228005, 0.5725318195255249, 0.535066152009792, 0.5253630628481165, 0.6028246456880497, 0.5639403541529372, 0.572788078264381, 0.5922179730514407, 0.13858049608357048, 0.1140415469216608, 0.13514305031247187, 0.10543948770953071, 0.1311353177932859, 0.130468031098824, 0.15138975236411967, 0.13355429375791372, 0.1241796007089222, 0.1776089883101537, 0.2519132675539272, 0.1918040525007525, 0.2566690281664501, 0.32341108201577595, 0.2648665908586717, 0.17828663472076534, 0.21047850737600482, 0.24841171248975713, 0.4059317916094428, 0.23572422699409468, 0.47062397954357493, 0.5294038642594114, 0.4020321046062062, 0.4802464413676193, 0.5862067807824437, 0.5831901827472739, 0.5574206631206033, 0.28545525756064594, 0.17049474230081707, 0.289973778722285, 0.2388027150884935, 0.22913312921303097, 0.24367183765115574, 0.45274451166516494, 0.38917333881129057, 0.2806900392658306, 0.2518849165016671, 0.18785538251841938, 0.20866247538467264, 0.23809213034143473, 0.21921532515394726, 0.22151188282520995, 0.20618668059149303, 0.24772140863305514, 0.1920072738694445, 0.23569265119392202, 0.22036856959631468, 0.6435053432594741, 0.2225474414123656, 0.18604809559388336, 0.24590225001129606, 0.21234768144886373, 0.21996975893624116, 0.22077902570610708, 0.8808862074282178, 0.1128591555123456, 0.15280644174043678, 0.8880424395001292, 0.19971284365983077, 0.2111962099406487, 0.14239832665442587, 0.8718203830128949, 0.1639917253087937, 0.6887736471455064, 0.21095549047054152, 0.7299325539322526, 0.6834732648229717, 0.7900910434760625, 0.20538533601425035, 0.6179462928104767, 0.10399132571052849, 0.2985035745596182, 0.2114590846189568, 0.19491510578799764, 0.19626262695778052, 0.229466047481096, 0.18731500267214796, 0.19027143344441289, 0.2182812280995401, 0.20691977616819945, 0.18861803661371257, 0.09200880761236707, 0.08456812298385796, 0.10266674019698252, 0.09143038124012914, 0.10219288217769662, 0.09960646818687569, 0.08779138533527187, 0.08632558907355725, 0.09017583095929271]}, "mutation_prompt": null}
{"id": "ad4fa03d-7523-47fc-8c6f-51020137a643", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (10 * dim)))\n        self.f = 0.5  \n        self.cr = 0.7  \n        self.w = 0.9  # Increased inertia weight for better exploration\n        self.c1 = 1.5\n        self.c2 = 1.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        while budget_used < self.budget:\n            # Differential Evolution with adaptive scaling factor\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                adaptive_f = self.f + 0.1 * np.random.rand()  # Adaptive scaling factor\n                mutant = np.clip(a + adaptive_f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization with adaptive inertia weight\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.w = 0.9 - 0.5 * budget_used / self.budget  # Adaptive inertia weight\n            velocities = (self.w * velocities \n                         + self.c1 * r1 * (personal_best - population) \n                         + self.c2 * r2 * (global_best - population))\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "HybridDEPSO", "description": "Hybrid adaptive DE-PSO algorithm with adaptive parameters for enhanced exploration and exploitation within constrained budget.", "configspace": "", "generation": 4, "fitness": 0.2389687677266793, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": "f2cdd4c2-6542-4060-a4de-e855d2f9f144", "metadata": {"aucs": [0.622487228159475, 0.6119073385587093, 0.5763095093120219, 0.6286836030127794, 0.6341584745482494, 0.6250908063266152, 0.639116670794492, 0.5933180847830356, 0.6217374183655251, 9.999999999998899e-05, 0.32232180273265953, 0.2774052329989537, 0.2820955321340378, 0.28357193818806004, 0.262306975537713, 0.31068833334429324, 0.29742103747209503, 0.28395891368328097, 0.10185064960266277, 0.22049557005423503, 0.10299750798053042, 0.12529076425872732, 0.1481597214164896, 0.06775391554015364, 0.13611640736230934, 0.12226287753564025, 0.10949172713765487, 0.09200472643525826, 0.10230213388518128, 0.09422410892216648, 0.09864230612155056, 0.08676622017484947, 0.10508167388997569, 0.11059098263753653, 0.1384966064508384, 0.10614185638456242, 0.9710368766460369, 0.9724035460105348, 0.9722109821552265, 0.9643562250958223, 0.9720427782575994, 0.9363098733380109, 0.9820972031195904, 0.9744435528766116, 0.9817572036643264, 0.34680285876488115, 0.34914815156532075, 0.33436373820546295, 0.3691502944068469, 0.35368626441245765, 0.32521790308742815, 0.28829986550828346, 0.32916004455900005, 0.35639464136528, 0.4299324242331499, 0.47010171810091606, 0.21393464374785875, 0.21056040863867276, 0.18846015897489077, 0.19277992694225699, 0.19037191945918008, 0.43239713663272517, 0.22066019673469472, 0.10180570151362922, 0.16981329034414483, 0.16658941604834887, 0.1517639698921288, 0.16812930010052418, 0.09059309840979968, 0.16866427632697145, 0.15566326495506655, 0.15578143433881741, 0.08791392086648808, 0.17838336222582096, 0.16876083440675482, 0.15530904607862794, 0.14743969545827806, 0.1503402655377718, 0.15838013962916375, 0.1827725599215807, 0.16044308223723458, 9.999999999998899e-05, 0.020986988564357878, 0.02102321744716118, 0.006783620650536948, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005044541001554936, 9.999999999998899e-05, 0.06564096870748815, 0.15750009111408725, 0.10170011541722579, 0.08149072747668029, 0.08592445784064362, 0.08762643425603345, 0.07479403072253954, 0.06939995643068764, 0.047609655781711946, 9.999999999998899e-05, 0.05199887167400663, 0.021220545991783912, 0.050871634258513376, 0.03864804161169999, 0.056379186641941526, 0.05425227261436938, 0.06610749536999116, 0.05577848361473503, 0.1250523235177805, 0.06902131102092213, 0.1203257241124851, 0.06618000624131315, 0.0317411060161068, 0.01437645686468425, 0.21809529537221561, 0.06486317594697066, 0.0714987741340739, 0.4604194263681375, 0.4193324176536518, 0.4710327658782396, 0.43640300079166683, 0.4766874435397297, 0.456301994659262, 0.45039475480156266, 0.43275786226757607, 0.4457953468434338, 0.09013684181739368, 0.0748455704343789, 0.11181414575412019, 0.11739700046265167, 0.10328586559846675, 0.09837785749360628, 0.10409827609003874, 0.111101207570939, 0.11538075506495282, 0.16096918343801137, 0.22542783537423472, 0.1927736300148446, 0.25186553063502704, 0.22431902778437973, 0.2167483553174212, 0.15279934730018574, 0.13736052340678762, 0.2072486899103071, 0.31310124380281146, 0.34058727418837187, 0.2884550833360756, 0.26110693122822703, 0.3284964649117794, 0.30655911401462776, 0.2874319944062961, 0.330880064108965, 0.35341836639409163, 0.21251585025506714, 0.24276954173261345, 0.17542776135826466, 0.26509746945868107, 0.17555533291647096, 0.20359939026936957, 0.20401926571474005, 0.2465075820238618, 0.21867237599968392, 0.21415818794675856, 0.21780086890674488, 0.19975581425709332, 0.20836807175042493, 0.2042969595550692, 0.19662388888343307, 0.20600001355091224, 0.19878334787486351, 0.20155080375753542, 0.2009644018563096, 0.19541691263279704, 0.37413068660351223, 0.1967782088077039, 0.20601975670934458, 0.19296730928190697, 0.2081807282116246, 0.21367373481126306, 0.1950781295897538, 0.16523198874728862, 0.6847164957631954, 0.15116560037689053, 0.16859121062476257, 0.1940993257424205, 0.6916264368761745, 0.172756042758052, 0.15345360669794117, 0.6651356503062804, 0.3578299251157723, 0.2059488591558185, 0.16089642120746994, 0.19787845771924617, 0.20222849313469116, 0.15746731825081683, 0.16263848688277727, 0.16297908266325212, 0.15421416942257404, 0.1967235834110742, 0.19517749975784415, 0.18969525805387533, 0.20198000288603546, 0.19991113961661056, 0.18207950652955585, 0.179317954220637, 0.18746589032081296, 0.19228598735582214, 0.0784604197493971, 0.0724322381335738, 0.07991793350625553, 0.08772982662592799, 0.09165108567103653, 0.08061137100271809, 0.09657206138583296, 0.09224074342810185, 0.08380880753330311]}, "mutation_prompt": null}
{"id": "16b88e4a-54f2-46c1-9af1-46d065e9d396", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (10 * dim)))\n        self.f = 0.5  # Differential evolution scaling factor\n        self.cr = 0.7  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.adapt_rate = 0.1  # Adaptive learning rate for dynamic adjustments\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        prev_global_best_fitness = personal_best_fitness[global_best_idx]\n        \n        while budget_used < self.budget:\n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = (self.w * velocities \n                         + self.c1 * r1 * (personal_best - population) \n                         + self.c2 * r2 * (global_best - population))\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n            \n            # Adaptive strategy adjustment\n            if personal_best_fitness[global_best_idx] < prev_global_best_fitness:\n                self.f = min(1.0, self.f + self.adapt_rate)\n                self.w = max(0.1, self.w - self.adapt_rate)\n            prev_global_best_fitness = personal_best_fitness[global_best_idx]\n\n        return global_best", "name": "HybridDEPSO", "description": "An enhanced hybrid algorithm incorporating adaptive learning rates to balance exploration and exploitation dynamically based on fitness improvements.", "configspace": "", "generation": 5, "fitness": 0.2975223191060988, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.27.", "error": "", "parent_id": "f2cdd4c2-6542-4060-a4de-e855d2f9f144", "metadata": {"aucs": [0.9082462247277188, 0.909407902272171, 0.9044464787851612, 0.8985214592423851, 0.901517721360833, 0.9019306977169856, 0.9011389276487087, 0.8831303651171573, 0.897033903212061, 0.8083299008872187, 0.7835808309058672, 0.7559517736026119, 0.7503885068239855, 0.8057018631459358, 0.713075607501889, 0.7558151910679978, 0.6107463780435287, 0.7859937887822841, 0.13999951580487613, 0.12958393477492258, 0.09548388136919761, 0.14231605622666088, 0.1336278061849887, 0.18170499336150447, 0.15679554305363252, 0.17324355753911636, 0.09671898040298421, 0.16081996473788385, 0.11590147518308624, 0.14154512653802176, 0.14275409492380786, 0.14795621673405746, 0.09813035793848612, 0.18503312853950904, 0.10433401500580641, 0.11050414854274859, 0.9584962936933248, 0.9636515768492256, 0.9727813348043074, 0.9577917010791804, 0.9723799699929654, 0.9731778440888258, 0.9740607445728189, 0.981652595474231, 0.957747523265023, 0.4036927403452948, 0.48062118489098593, 0.7789061862154408, 0.5776475481704186, 0.2795724966623556, 0.2736476225737253, 0.44255563848952195, 0.6620927576224769, 0.3086915077536935, 0.22753228467354525, 0.22789666009752918, 0.16973129510744633, 0.2797365745453776, 0.28223844227587724, 0.19343411760422946, 0.21829502632101538, 0.17860443377423052, 0.2377344935368727, 0.12553330762575643, 0.10381780832367882, 0.16555111445707427, 0.12542309762791648, 0.16296663215400442, 0.1558588827357258, 0.18700816121562946, 0.17362327008127032, 0.39525421660443505, 0.127536516140336, 9.999999999998899e-05, 0.18523475381858068, 0.1498250193629843, 0.23677899531058333, 0.20863633964329653, 0.12918134748636856, 0.12859566132662892, 0.10895488537425935, 0.03817947215056994, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08052573085219794, 0.000398410423679163, 0.0024972962155536127, 9.999999999998899e-05, 9.999999999998899e-05, 0.0787574305709311, 0.05125243532789814, 0.10472299851407785, 0.11791963931106986, 0.07260064018923562, 0.0234511641754096, 0.04648429190301684, 0.10381051888635362, 0.0434300243785154, 0.05310684370345897, 0.0359200452682753, 0.05388914321009142, 0.11565220306217794, 0.09708454404096412, 0.08042769318106735, 0.10113154417554249, 0.0741120213774018, 0.2807883588052428, 0.18414677972117666, 0.12638841352184993, 0.12466065522360603, 0.2386299807666714, 0.12196737412211656, 0.29199285453715207, 0.16632878998477718, 0.12564130124076056, 0.13154535817683832, 0.4852503057119012, 0.5087858301315719, 0.4905626011185025, 0.5511190955415683, 0.5169375262648145, 0.5817722870837114, 0.6712128851629948, 0.5509275577780416, 0.5685706929274166, 0.11428601649147874, 0.11022457705874744, 0.10930686705268222, 0.07907752276551783, 0.07599314664058254, 0.15408815666109277, 0.08552168765080426, 0.13622866047258553, 0.09503499094719159, 0.17151344209658637, 0.23694353009000302, 0.22538956175067704, 0.22980940233407177, 0.19599060063772322, 0.188868297583487, 0.20516356569002847, 0.20122267327070087, 0.20633168635941002, 0.2562207644113025, 0.29723160367504275, 0.32203881484792096, 0.26685788681668865, 0.36801056409749244, 0.2955946460720503, 0.3039092443042003, 0.4208356025142136, 0.6009845149504124, 0.2816469425584418, 0.17650176692164954, 0.2711038108050786, 0.19645991635438553, 0.2500158984148283, 0.2665377043865095, 0.23062101908628674, 0.25216035162205297, 0.2435054969686984, 0.2149451968050664, 0.24663195966357976, 0.17832176481495665, 0.2107745301123375, 0.2000569553098246, 0.21935286960937905, 0.25263830458630354, 0.21701613261889507, 0.21063031067697735, 0.2082391292604595, 0.18861934513455503, 0.19424481108369696, 0.1996264729649203, 0.18579830426031962, 0.2000444527220675, 0.2036093361667457, 0.19842222909326357, 0.19482052086663482, 0.6005293213836523, 0.1128574074280112, 0.15299542895790796, 0.904456986601043, 0.20075233003490534, 0.21131465339394084, 0.1422793900064866, 0.853472840636601, 0.16444183654772715, 0.5317208420719088, 0.21167482143599103, 0.6460140524327362, 0.4955994869478678, 0.31874993932015516, 0.206279027741596, 0.10465325824592109, 0.1041108452823879, 0.7111765483755506, 0.1915874675049707, 0.1826924526558803, 0.17778239327016576, 0.18929624916113952, 0.20352324541995415, 0.18844097669489246, 0.18548549254824498, 0.19538942396159886, 0.1829506146506905, 0.09240499275379666, 0.10521516305308964, 0.08318853130188453, 0.0906451207372686, 0.09583979334570503, 0.08090980472480369, 0.09404551097266867, 0.08336279641454059, 0.09521466057859784]}, "mutation_prompt": null}
{"id": "c7377548-f95d-4e98-abdc-80da6682594b", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (10 * dim)))\n        self.f = 0.5  # Differential evolution scaling factor\n        self.cr = 0.7  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = (self.w * velocities \n                         + self.c1 * r1 * (personal_best - population) \n                         + self.c2 * r2 * (global_best - population))\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "HybridDEPSO", "description": "A hybrid evolutionary and swarm-based algorithm, combining differential evolution and particle swarm optimization, adapts dynamically to search space dimensionality and complexity for efficient exploration and exploitation within a limited budget.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f2cdd4c2-6542-4060-a4de-e855d2f9f144", "metadata": {"aucs": [0.8251647471904195, 0.8227904645914664, 0.8464487043158307, 0.8294390971035444, 0.8255093631645593, 0.8358376912004718, 0.8398782360709972, 0.8288824460303248, 0.8285286785300631, 0.6489141629081737, 0.6458137371260453, 0.22976862585429159, 0.6462306277045214, 0.6539090521439623, 0.06462254518574195, 0.40386556352503244, 0.05671810206597816, 0.4380414604765638, 0.16309813870100864, 0.1143280742515499, 0.07204183122351882, 0.13260241642594883, 0.17796018568292582, 0.14525546953782065, 0.17318864914969168, 0.17303473515053192, 0.10824383202544119, 0.13722268962524664, 0.1371700624835004, 0.1206020541145636, 0.13623116738949503, 0.12149837155627008, 0.11094273761639051, 0.16858872471909658, 0.1514288105370024, 0.11713565103626511, 0.9642350383362817, 0.9674057052973665, 0.9723521600864173, 0.9472395299832335, 0.9686507195251154, 0.9732820555991173, 0.9745842565814995, 0.9816534864997477, 0.9641291073133742, 0.5716337414327806, 0.6041730699492114, 0.6102506179673011, 0.6248690479427352, 0.1494406078309719, 0.6731163724893396, 0.12364000833391087, 0.5957054498078784, 0.12554220577271824, 0.8265667883569601, 0.22510120977365322, 0.85270340913916, 0.3677248112247793, 0.2793879947291461, 0.19287820599250094, 0.2171939391590897, 0.33613321235256954, 0.8656464627042229, 0.212925899014606, 0.13414490800548207, 0.3526304323366718, 0.18751015161735962, 0.18671628458613954, 0.18602134660642, 0.21148003452528463, 0.10866506494134132, 0.12999885044802084, 0.13059787564300185, 0.11686930632183934, 0.21772049038190477, 0.13181018807331202, 0.21987002477133677, 0.20358954050562417, 0.22692862296194494, 0.20315974027033912, 0.18581647747740904, 0.07445048759976203, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0378433341999187, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07379114330585834, 0.04638678745733249, 0.08300195210193684, 0.08370907075167067, 0.10591608941588349, 0.029836248453943837, 0.0636287373284038, 0.09325360606547473, 0.06310988673651885, 0.0457730286209479, 0.033652720074391795, 0.04621360202436331, 0.07286535304925967, 0.08814550655463849, 0.07190196081316991, 0.088675882462803, 0.16118937299731728, 0.17184423549139682, 0.12938405762906802, 0.12773246725298415, 0.24733835243370983, 0.16566509509959992, 0.3171550590823592, 0.11354645479440095, 0.053971070661603004, 0.07604352852644003, 0.08039178488047982, 0.5262150280236269, 0.568348736228005, 0.5725318195255249, 0.535066152009792, 0.5253630628481165, 0.6028246456880497, 0.5639403541529372, 0.572788078264381, 0.5922179730514407, 0.13858049608357048, 0.1140415469216608, 0.13514305031247187, 0.10543948770953071, 0.1311353177932859, 0.130468031098824, 0.15138975236411967, 0.13355429375791372, 0.1241796007089222, 0.1776089883101537, 0.2519132675539272, 0.1918040525007525, 0.2566690281664501, 0.32341108201577595, 0.2648665908586717, 0.17828663472076534, 0.21047850737600482, 0.24841171248975713, 0.4059317916094428, 0.23572422699409468, 0.47062397954357493, 0.5294038642594114, 0.4020321046062062, 0.4802464413676193, 0.5862067807824437, 0.5831901827472739, 0.5574206631206033, 0.28545525756064594, 0.17049474230081707, 0.289973778722285, 0.2388027150884935, 0.22913312921303097, 0.24367183765115574, 0.45274451166516494, 0.38917333881129057, 0.2806900392658306, 0.2518849165016671, 0.18785538251841938, 0.20866247538467264, 0.23809213034143473, 0.21921532515394726, 0.22151188282520995, 0.20618668059149303, 0.24772140863305514, 0.1920072738694445, 0.23569265119392202, 0.22036856959631468, 0.6435053432594741, 0.2225474414123656, 0.18604809559388336, 0.24590225001129606, 0.21234768144886373, 0.21996975893624116, 0.22077902570610708, 0.8808862074282178, 0.1128591555123456, 0.15280644174043678, 0.8880424395001292, 0.19971284365983077, 0.2111962099406487, 0.14239832665442587, 0.8718203830128949, 0.1639917253087937, 0.6887736471455064, 0.21095549047054152, 0.7299325539322526, 0.6834732648229717, 0.7900910434760625, 0.20538533601425035, 0.6179462928104767, 0.10399132571052849, 0.2985035745596182, 0.2114590846189568, 0.19491510578799764, 0.19626262695778052, 0.229466047481096, 0.18731500267214796, 0.19027143344441289, 0.2182812280995401, 0.20691977616819945, 0.18861803661371257, 0.09200880761236707, 0.08456812298385796, 0.10266674019698252, 0.09143038124012914, 0.10219288217769662, 0.09960646818687569, 0.08779138533527187, 0.08632558907355725, 0.09017583095929271]}, "mutation_prompt": null}
{"id": "7db28b93-ba48-4214-9f35-f66c255a0c8b", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (10 * dim)))\n        self.f = 0.5  # Differential evolution scaling factor\n        self.cr = 0.7  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = (self.w * velocities \n                         + self.c1 * r1 * (personal_best - population) \n                         + self.c2 * r2 * (global_best - population))\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "HybridDEPSO", "description": "A hybrid evolutionary and swarm-based algorithm, combining differential evolution and particle swarm optimization, adapts dynamically to search space dimensionality and complexity for efficient exploration and exploitation within a limited budget.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f2cdd4c2-6542-4060-a4de-e855d2f9f144", "metadata": {"aucs": [0.8251647471904195, 0.8227904645914664, 0.8464487043158307, 0.8294390971035444, 0.8255093631645593, 0.8358376912004718, 0.8398782360709972, 0.8288824460303248, 0.8285286785300631, 0.6489141629081737, 0.6458137371260453, 0.22976862585429159, 0.6462306277045214, 0.6539090521439623, 0.06462254518574195, 0.40386556352503244, 0.05671810206597816, 0.4380414604765638, 0.16309813870100864, 0.1143280742515499, 0.07204183122351882, 0.13260241642594883, 0.17796018568292582, 0.14525546953782065, 0.17318864914969168, 0.17303473515053192, 0.10824383202544119, 0.13722268962524664, 0.1371700624835004, 0.1206020541145636, 0.13623116738949503, 0.12149837155627008, 0.11094273761639051, 0.16858872471909658, 0.1514288105370024, 0.11713565103626511, 0.9642350383362817, 0.9674057052973665, 0.9723521600864173, 0.9472395299832335, 0.9686507195251154, 0.9732820555991173, 0.9745842565814995, 0.9816534864997477, 0.9641291073133742, 0.5716337414327806, 0.6041730699492114, 0.6102506179673011, 0.6248690479427352, 0.1494406078309719, 0.6731163724893396, 0.12364000833391087, 0.5957054498078784, 0.12554220577271824, 0.8265667883569601, 0.22510120977365322, 0.85270340913916, 0.3677248112247793, 0.2793879947291461, 0.19287820599250094, 0.2171939391590897, 0.33613321235256954, 0.8656464627042229, 0.212925899014606, 0.13414490800548207, 0.3526304323366718, 0.18751015161735962, 0.18671628458613954, 0.18602134660642, 0.21148003452528463, 0.10866506494134132, 0.12999885044802084, 0.13059787564300185, 0.11686930632183934, 0.21772049038190477, 0.13181018807331202, 0.21987002477133677, 0.20358954050562417, 0.22692862296194494, 0.20315974027033912, 0.18581647747740904, 0.07445048759976203, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0378433341999187, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07379114330585834, 0.04638678745733249, 0.08300195210193684, 0.08370907075167067, 0.10591608941588349, 0.029836248453943837, 0.0636287373284038, 0.09325360606547473, 0.06310988673651885, 0.0457730286209479, 0.033652720074391795, 0.04621360202436331, 0.07286535304925967, 0.08814550655463849, 0.07190196081316991, 0.088675882462803, 0.16118937299731728, 0.17184423549139682, 0.12938405762906802, 0.12773246725298415, 0.24733835243370983, 0.16566509509959992, 0.3171550590823592, 0.11354645479440095, 0.053971070661603004, 0.07604352852644003, 0.08039178488047982, 0.5262150280236269, 0.568348736228005, 0.5725318195255249, 0.535066152009792, 0.5253630628481165, 0.6028246456880497, 0.5639403541529372, 0.572788078264381, 0.5922179730514407, 0.13858049608357048, 0.1140415469216608, 0.13514305031247187, 0.10543948770953071, 0.1311353177932859, 0.130468031098824, 0.15138975236411967, 0.13355429375791372, 0.1241796007089222, 0.1776089883101537, 0.2519132675539272, 0.1918040525007525, 0.2566690281664501, 0.32341108201577595, 0.2648665908586717, 0.17828663472076534, 0.21047850737600482, 0.24841171248975713, 0.4059317916094428, 0.23572422699409468, 0.47062397954357493, 0.5294038642594114, 0.4020321046062062, 0.4802464413676193, 0.5862067807824437, 0.5831901827472739, 0.5574206631206033, 0.28545525756064594, 0.17049474230081707, 0.289973778722285, 0.2388027150884935, 0.22913312921303097, 0.24367183765115574, 0.45274451166516494, 0.38917333881129057, 0.2806900392658306, 0.2518849165016671, 0.18785538251841938, 0.20866247538467264, 0.23809213034143473, 0.21921532515394726, 0.22151188282520995, 0.20618668059149303, 0.24772140863305514, 0.1920072738694445, 0.23569265119392202, 0.22036856959631468, 0.6435053432594741, 0.2225474414123656, 0.18604809559388336, 0.24590225001129606, 0.21234768144886373, 0.21996975893624116, 0.22077902570610708, 0.8808862074282178, 0.1128591555123456, 0.15280644174043678, 0.8880424395001292, 0.19971284365983077, 0.2111962099406487, 0.14239832665442587, 0.8718203830128949, 0.1639917253087937, 0.6887736471455064, 0.21095549047054152, 0.7299325539322526, 0.6834732648229717, 0.7900910434760625, 0.20538533601425035, 0.6179462928104767, 0.10399132571052849, 0.2985035745596182, 0.2114590846189568, 0.19491510578799764, 0.19626262695778052, 0.229466047481096, 0.18731500267214796, 0.19027143344441289, 0.2182812280995401, 0.20691977616819945, 0.18861803661371257, 0.09200880761236707, 0.08456812298385796, 0.10266674019698252, 0.09143038124012914, 0.10219288217769662, 0.09960646818687569, 0.08779138533527187, 0.08632558907355725, 0.09017583095929271]}, "mutation_prompt": null}
{"id": "654e364f-c1b7-4995-95d6-bbd470de5653", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))  # Adjusted population size\n        self.f = 0.8  # Increased DE scaling factor\n        self.cr = 0.9  # Increased crossover probability\n        self.w = 0.4  # Reduced inertia weight for PSO\n        self.c1 = 2.0  # Increased cognitive coefficient\n        self.c2 = 1.5  # Social coefficient remains unchanged\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = (self.w * velocities \n                         + self.c1 * r1 * (personal_best - population) \n                         + self.c2 * r2 * (global_best - population))\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "HybridDEPSO", "description": "An enhanced hybrid algorithm integrating adaptive differential evolution and particle swarm optimization with a dynamic population size adjustment to improve convergence speed and solution quality.", "configspace": "", "generation": 8, "fitness": 0.320398714838173, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "f2cdd4c2-6542-4060-a4de-e855d2f9f144", "metadata": {"aucs": [0.8394962469168398, 0.8417813244282686, 0.8455187156914244, 0.8403226970091702, 0.8343401775951185, 0.8519545049720507, 0.8391899275295616, 0.8281183993172871, 0.834739297766486, 0.6558526235445217, 0.6848861609713168, 0.675942127735668, 0.6754730324398399, 0.6949642598564284, 0.6940982422276516, 0.6783318024195201, 0.6937579700035201, 0.5964843461403746, 0.10668689265107256, 0.470583134602518, 0.1703506830230379, 0.21476877920406934, 0.14158858254061324, 0.13014758007124727, 0.17085702408230863, 0.11781928710569334, 0.2532771563527624, 0.13802327165938566, 0.12823011312495858, 0.09884727989174336, 0.12401247165346485, 0.13367696878086532, 0.12631246680892527, 0.14954224810644134, 0.10593666390640588, 0.1743427825984445, 0.9808685602426443, 0.9734985661583649, 0.9815393508001424, 0.977086044500265, 0.9712502798367887, 0.9735632365230347, 0.9823426630632758, 0.9818741702660454, 0.9730674847082628, 0.5255160327266236, 0.5298624465849949, 0.4244136362483977, 0.5874525245799853, 0.48602907433788767, 0.5797411892547846, 0.5165320657907935, 0.4587566559281213, 0.12474464519010176, 0.19678894004321623, 0.7640306945023762, 0.3700687589697921, 0.278611112526189, 0.6375760113115532, 0.37669391627624127, 0.5662969320908695, 0.2245319436146267, 0.23195759115792625, 0.13932774807174597, 0.12095056516881597, 0.1947785784463435, 0.1980683465791151, 0.20221934469389913, 0.19193261816580265, 0.256055376304988, 0.20397180740414755, 0.20612904008100064, 0.21129551288892556, 0.11643336171720797, 0.20810723276177956, 0.23776192789576012, 0.19883311331817, 0.25720752050805895, 0.2507886644677606, 0.21382170780991605, 0.25739383749036393, 0.006309616302559329, 0.0003407137397345439, 9.999999999998899e-05, 0.013567422972583287, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0875928678973178, 0.040018526499390084, 0.05529070098849842, 0.061576159604076586, 0.004563522910143392, 0.023128167645673825, 0.04860369427426681, 0.05442214353699759, 0.05160262033667673, 0.03333840843884228, 0.03206765454124105, 0.2123750363316259, 0.19094572672301546, 0.29898544212976164, 0.08835428410745172, 0.09348247840328039, 0.09016988859379593, 0.08787886746801343, 0.13330482275504707, 9.999999999998899e-05, 0.0575254629609353, 0.4087667906596604, 0.15459209224285897, 0.16341738666111905, 0.23105485238168055, 0.08016685586186378, 0.14064684737966804, 0.5054269605052821, 0.5563069425076299, 0.551516695133986, 0.5071522127141552, 0.5280893639451725, 0.5687323266084054, 0.5804911308009577, 0.532615323634141, 0.5576353390552538, 0.09557253045703706, 0.09356846694430132, 0.09617330755073905, 0.12415424362221694, 0.10058895989486993, 0.15582694808331998, 0.5194549538199267, 0.141895785983301, 0.1064180028924544, 0.3527897410471831, 0.23088912661962635, 0.20942558872597716, 0.18028588216205554, 0.16807130212078158, 0.3369659072154435, 0.26331298882058485, 0.21048599667950707, 0.3906858489602406, 0.3636802781120395, 0.2463404469694488, 0.40696408793728, 0.5183264130114135, 0.37380030574652423, 0.3350442133032665, 0.474801127708675, 0.5085174786515119, 0.5034826350465341, 0.37848033271944537, 0.17006479466512991, 0.3061538606631945, 0.25086817339396006, 0.20207272795270304, 0.3136093126003878, 0.2296436706009508, 0.23345885916060205, 0.21535021567684132, 0.23110795176745835, 0.19163854751023457, 0.20004259103028443, 0.20173185043592456, 0.22159133640853712, 0.20130339844920409, 0.24230649233313784, 0.21279194360306952, 0.22563249138905583, 0.24298340475830804, 0.24417692919218104, 0.22044398748113814, 0.22278751098610727, 0.24689943552277316, 0.21695487967015448, 0.243167960921696, 0.7073744977056169, 0.19322001933386213, 0.12684395588444752, 0.872934549264007, 0.15260540192827154, 0.8470783854577891, 0.7457469272801204, 0.1983266579692612, 0.14152982059971242, 0.16879368885917523, 0.8662333823841213, 0.6865999436543693, 0.1690919975970936, 0.20209176281590013, 0.6365828243392752, 0.4990521818531308, 0.4498687612545986, 0.11275281087037892, 0.104583443419076, 0.6889274914580292, 0.188707413305521, 0.18768631038139516, 0.18711153085641785, 0.1964128579191785, 0.1848995445187197, 0.18353731205452384, 0.19274732617768453, 0.19751774166559877, 0.19476158709052904, 0.09198154644897838, 0.09658790766121417, 0.09474635358958639, 0.0844649704190581, 0.08947295214502449, 0.0873514062794093, 0.0928323246767423, 0.08264388009436119, 0.09685428586558786]}, "mutation_prompt": null}
{"id": "d6f4facf-68d7-45eb-b87f-cd7683bfab37", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))  # Adjusted population size\n        self.f = 0.8  # Increased DE scaling factor\n        self.cr = 0.9  # Increased crossover probability\n        self.w = 0.4  # Reduced inertia weight for PSO\n        self.c1 = 2.0  # Increased cognitive coefficient\n        self.c2 = 1.5  # Social coefficient remains unchanged\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = (self.w * velocities \n                         + self.c1 * r1 * (personal_best - population) \n                         + self.c2 * r2 * (global_best - population))\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "HybridDEPSO", "description": "An enhanced hybrid algorithm integrating adaptive differential evolution and particle swarm optimization with a dynamic population size adjustment to improve convergence speed and solution quality.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "654e364f-c1b7-4995-95d6-bbd470de5653", "metadata": {"aucs": [0.8394962469168398, 0.8417813244282686, 0.8455187156914244, 0.8403226970091702, 0.8343401775951185, 0.8519545049720507, 0.8391899275295616, 0.8281183993172871, 0.834739297766486, 0.6558526235445217, 0.6848861609713168, 0.675942127735668, 0.6754730324398399, 0.6949642598564284, 0.6940982422276516, 0.6783318024195201, 0.6937579700035201, 0.5964843461403746, 0.10668689265107256, 0.470583134602518, 0.1703506830230379, 0.21476877920406934, 0.14158858254061324, 0.13014758007124727, 0.17085702408230863, 0.11781928710569334, 0.2532771563527624, 0.13802327165938566, 0.12823011312495858, 0.09884727989174336, 0.12401247165346485, 0.13367696878086532, 0.12631246680892527, 0.14954224810644134, 0.10593666390640588, 0.1743427825984445, 0.9808685602426443, 0.9734985661583649, 0.9815393508001424, 0.977086044500265, 0.9712502798367887, 0.9735632365230347, 0.9823426630632758, 0.9818741702660454, 0.9730674847082628, 0.5255160327266236, 0.5298624465849949, 0.4244136362483977, 0.5874525245799853, 0.48602907433788767, 0.5797411892547846, 0.5165320657907935, 0.4587566559281213, 0.12474464519010176, 0.19678894004321623, 0.7640306945023762, 0.3700687589697921, 0.278611112526189, 0.6375760113115532, 0.37669391627624127, 0.5662969320908695, 0.2245319436146267, 0.23195759115792625, 0.13932774807174597, 0.12095056516881597, 0.1947785784463435, 0.1980683465791151, 0.20221934469389913, 0.19193261816580265, 0.256055376304988, 0.20397180740414755, 0.20612904008100064, 0.21129551288892556, 0.11643336171720797, 0.20810723276177956, 0.23776192789576012, 0.19883311331817, 0.25720752050805895, 0.2507886644677606, 0.21382170780991605, 0.25739383749036393, 0.006309616302559329, 0.0003407137397345439, 9.999999999998899e-05, 0.013567422972583287, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0875928678973178, 0.040018526499390084, 0.05529070098849842, 0.061576159604076586, 0.004563522910143392, 0.023128167645673825, 0.04860369427426681, 0.05442214353699759, 0.05160262033667673, 0.03333840843884228, 0.03206765454124105, 0.2123750363316259, 0.19094572672301546, 0.29898544212976164, 0.08835428410745172, 0.09348247840328039, 0.09016988859379593, 0.08787886746801343, 0.13330482275504707, 9.999999999998899e-05, 0.0575254629609353, 0.4087667906596604, 0.15459209224285897, 0.16341738666111905, 0.23105485238168055, 0.08016685586186378, 0.14064684737966804, 0.5054269605052821, 0.5563069425076299, 0.551516695133986, 0.5071522127141552, 0.5280893639451725, 0.5687323266084054, 0.5804911308009577, 0.532615323634141, 0.5576353390552538, 0.09557253045703706, 0.09356846694430132, 0.09617330755073905, 0.12415424362221694, 0.10058895989486993, 0.15582694808331998, 0.5194549538199267, 0.141895785983301, 0.1064180028924544, 0.3527897410471831, 0.23088912661962635, 0.20942558872597716, 0.18028588216205554, 0.16807130212078158, 0.3369659072154435, 0.26331298882058485, 0.21048599667950707, 0.3906858489602406, 0.3636802781120395, 0.2463404469694488, 0.40696408793728, 0.5183264130114135, 0.37380030574652423, 0.3350442133032665, 0.474801127708675, 0.5085174786515119, 0.5034826350465341, 0.37848033271944537, 0.17006479466512991, 0.3061538606631945, 0.25086817339396006, 0.20207272795270304, 0.3136093126003878, 0.2296436706009508, 0.23345885916060205, 0.21535021567684132, 0.23110795176745835, 0.19163854751023457, 0.20004259103028443, 0.20173185043592456, 0.22159133640853712, 0.20130339844920409, 0.24230649233313784, 0.21279194360306952, 0.22563249138905583, 0.24298340475830804, 0.24417692919218104, 0.22044398748113814, 0.22278751098610727, 0.24689943552277316, 0.21695487967015448, 0.243167960921696, 0.7073744977056169, 0.19322001933386213, 0.12684395588444752, 0.872934549264007, 0.15260540192827154, 0.8470783854577891, 0.7457469272801204, 0.1983266579692612, 0.14152982059971242, 0.16879368885917523, 0.8662333823841213, 0.6865999436543693, 0.1690919975970936, 0.20209176281590013, 0.6365828243392752, 0.4990521818531308, 0.4498687612545986, 0.11275281087037892, 0.104583443419076, 0.6889274914580292, 0.188707413305521, 0.18768631038139516, 0.18711153085641785, 0.1964128579191785, 0.1848995445187197, 0.18353731205452384, 0.19274732617768453, 0.19751774166559877, 0.19476158709052904, 0.09198154644897838, 0.09658790766121417, 0.09474635358958639, 0.0844649704190581, 0.08947295214502449, 0.0873514062794093, 0.0928323246767423, 0.08264388009436119, 0.09685428586558786]}, "mutation_prompt": null}
{"id": "e95153cc-170a-4f7a-b687-cc28675f517a", "solution": "import numpy as np\n\nclass ImprovedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))  \n        self.f = 0.8  \n        self.cr = 0.9  \n        self.w = 0.4  \n        self.c1 = 2.0  \n        self.c2 = 1.5  \n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with adaptive mutation factor\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                adaptive_f = np.random.uniform(0.5, 1.0) # Adaptive mutation factor\n                mutant = np.clip(a + adaptive_f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Intensified local search step\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                candidate = global_best + np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    fitness[i] = candidate_fitness\n                    personal_best[i] = candidate\n                    personal_best_fitness[i] = candidate_fitness\n                    if candidate_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = candidate\n                        global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = (self.w * velocities \n                         + self.c1 * r1 * (personal_best - population) \n                         + self.c2 * r2 * (global_best - population))\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "ImprovedHybridDEPSO", "description": "Introducing adaptive mutation scaling and local search intensification to improve convergence speed and solution quality.", "configspace": "", "generation": 10, "fitness": 0.25742719702308725, "feedback": "The algorithm ImprovedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.24.", "error": "", "parent_id": "654e364f-c1b7-4995-95d6-bbd470de5653", "metadata": {"aucs": [0.7610374664829092, 0.7680271504343172, 0.7675637135767233, 0.7727751018853899, 0.7165358807078938, 0.76597116618583, 0.7658415286539534, 0.7452315292179884, 0.7611542025447069, 0.31539556388854173, 0.2764436193543581, 0.24040005626485617, 0.434804158650409, 0.3955362029365551, 0.4135749359935499, 0.49830101002123983, 0.32842756137853923, 0.41673122679255037, 0.026769905211312284, 0.16563892406669856, 0.09058213243945779, 0.0991233408937574, 0.06681310851868238, 0.14291806183995537, 0.09214148372312614, 0.11644127840566798, 0.07380105673679083, 0.0835874017899485, 0.05899855250306718, 0.04984570143115852, 0.07860563332623882, 0.0533323831803153, 0.038712964801950855, 0.10392038560367078, 0.019814028420674035, 0.03991801290578567, 0.9726860131844051, 0.974003025365499, 0.9851835638840805, 0.9599790675053955, 0.9609349631448868, 0.9746394505534646, 0.9732436970645166, 0.978547861663365, 0.9788289884248594, 0.5001054968544725, 0.4649618858967357, 0.4952176799806284, 0.4721090530309674, 0.5161684455642881, 0.47049272442733914, 0.45388563479230026, 0.463926744033502, 0.4809284045836063, 0.22370583798135857, 0.22052281993192657, 0.580588068991317, 0.21443926950867231, 0.2735287038682661, 0.15412232094768574, 0.11161570108856445, 0.13646282952934874, 0.12653634305138117, 0.2712850595442827, 0.36383581727304204, 0.20675489287559323, 0.12884527930351197, 0.24097189281713005, 0.20478244640391408, 0.20922695074818243, 0.2552706116035057, 0.13090745624860045, 0.12651583736613536, 0.21078795685171015, 0.12163854375653849, 0.21643600805590746, 0.18624354599122595, 0.22206015665814927, 0.21246920490289212, 0.14263349331848563, 0.21041470195845735, 0.0008428428353226547, 9.999999999998899e-05, 9.999999999998899e-05, 0.05155926263900634, 0.033046476973370376, 9.999999999998899e-05, 0.001923334677570665, 0.006340967763899807, 0.004601182580900032, 0.010296840641967675, 0.03078001603374847, 0.0849810524558825, 0.08057299655619932, 0.011435905458392348, 0.01434452419461174, 0.0681236711670985, 0.04091425764901779, 0.04102929486422402, 0.03214292017467979, 0.042785567853029005, 0.1366366816985446, 0.09323448711579929, 0.06261044759402323, 0.07328461742321035, 0.10110035259741712, 0.11788606179431349, 0.16002628451391243, 0.23517231320548249, 0.05195211573107661, 0.09708410723839622, 0.058023058628988156, 0.10080022242000086, 0.1551221553121681, 0.14592644411441635, 0.09774046399013481, 0.10600129551686821, 0.493755953464619, 0.5118933421821853, 0.5160834500958892, 0.5010560508548245, 0.509228617749195, 0.523536706959703, 0.5202595407228731, 0.4897052874192105, 0.5316539596843011, 0.1079368427522297, 0.05706036517433133, 0.052887027884048754, 0.06678445940415145, 0.04807645766393598, 0.11925290296764612, 0.08133778987035856, 0.14041577893162738, 0.07360878138967653, 0.2147965825290572, 0.26370371972708984, 0.22732912437520691, 0.15363894408637246, 0.6160716028939235, 0.16879800144694312, 0.4025386200135287, 0.17530977545291349, 0.1862836526806444, 0.19492007415372425, 0.1272207543376479, 0.30290602555097834, 0.2943976938044518, 0.18400422367875724, 0.36205095276280375, 0.23157110101480916, 0.3782655382460376, 0.39435807233265285, 0.219039910134475, 0.10427249284276274, 0.15029067921705352, 0.29397896694879233, 0.1453245047985241, 0.15038090021888695, 0.2383246679956995, 0.2022750209845282, 0.2509390383091198, 0.2105186462944274, 0.14130619085744545, 0.1808850974545223, 0.2246576280626078, 0.23916385895173187, 0.197373367897414, 0.18490252392381834, 0.17569433290244763, 0.19133495106003684, 0.19821202268140736, 0.22256856881246279, 0.18499790867263866, 0.20462536148639954, 0.19818788658991449, 0.21814297969607355, 0.19766478929721176, 0.2068217215979965, 0.19250224481562395, 0.13543586948240405, 0.12717887589056243, 0.15387362095384438, 0.17246705540331964, 0.2016619027683726, 0.17854194402749912, 0.14323189035702288, 0.16167443443222196, 0.14878312021095408, 0.7593575131220184, 0.21372444955087266, 0.21054966180339374, 0.7548897245688818, 0.1123313745339849, 0.8120522199260171, 0.2119761741775691, 0.21198786676008163, 0.15771320454593674, 0.18368640816049564, 0.2408249590143049, 0.19209479427959686, 0.20331807040744743, 0.19038416847240802, 0.19434790335566599, 0.18742518440479805, 0.1981877522116854, 0.20321148205678707, 0.07496655832221621, 0.10565567072275461, 0.06397332249132126, 0.09786031854374089, 0.09151884185932613, 0.055199065520031954, 0.0809511692658933, 0.07556991233415633, 0.07880093157454471]}, "mutation_prompt": null}
{"id": "05b0da9e-067e-44e0-b9a7-e6ee3b686d52", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))  # Adjusted population size\n        self.f = 0.9  # Further increased DE scaling factor for diversification\n        self.cr = 0.9  # Crossover probability remains unchanged\n        self.w = 0.5  # Increased inertia weight for PSO to enhance exploration\n        self.c1 = 2.0  # Cognitive coefficient remains unchanged\n        self.c2 = 1.5  # Social coefficient remains unchanged\n        self.immigration_rate = 0.1  # New immigration rate for random solutions\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = (self.w * velocities \n                         + self.c1 * r1 * (personal_best - population) \n                         + self.c2 * r2 * (global_best - population))\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n            # Random immigration to introduce diversity\n            immigrants = np.random.rand(self.pop_size, self.dim) < self.immigration_rate\n            population[immigrants] = np.random.uniform(self.lower_bound, self.upper_bound, (np.sum(immigrants), self.dim))\n            fitness[immigrants] = np.array([func(ind) for ind in population[immigrants]])\n            budget_used += np.sum(immigrants)\n\n        return global_best", "name": "HybridDEPSO", "description": "A refined hybrid algorithm integrating adaptive differential evolution and particle swarm optimization with enhanced exploration by introducing random immigration to prevent premature convergence and stagnation.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('NumPy boolean array indexing assignment requires a 0 or 1-dimensional input, input has 2 dimensions').", "error": "TypeError('NumPy boolean array indexing assignment requires a 0 or 1-dimensional input, input has 2 dimensions')", "parent_id": "654e364f-c1b7-4995-95d6-bbd470de5653", "metadata": {}, "mutation_prompt": null}
{"id": "176fc29f-902a-40e2-b7b4-4b48911f058b", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))  # Adjusted population size\n        self.f = 0.8  # Increased DE scaling factor\n        self.cr = 0.9  # Increased crossover probability\n        self.w = 0.4  # Reduced inertia weight for PSO\n        self.c1 = 2.0  # Increased cognitive coefficient\n        self.c2 = 1.5  # Social coefficient remains unchanged\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = (self.w * velocities \n                         + self.c1 * r1 * (personal_best - population) \n                         + self.c2 * r2 * (global_best - population))\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "HybridDEPSO", "description": "An enhanced hybrid algorithm integrating adaptive differential evolution and particle swarm optimization with a dynamic population size adjustment to improve convergence speed and solution quality.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "654e364f-c1b7-4995-95d6-bbd470de5653", "metadata": {"aucs": [0.8394962469168398, 0.8417813244282686, 0.8455187156914244, 0.8403226970091702, 0.8343401775951185, 0.8519545049720507, 0.8391899275295616, 0.8281183993172871, 0.834739297766486, 0.6558526235445217, 0.6848861609713168, 0.675942127735668, 0.6754730324398399, 0.6949642598564284, 0.6940982422276516, 0.6783318024195201, 0.6937579700035201, 0.5964843461403746, 0.10668689265107256, 0.470583134602518, 0.1703506830230379, 0.21476877920406934, 0.14158858254061324, 0.13014758007124727, 0.17085702408230863, 0.11781928710569334, 0.2532771563527624, 0.13802327165938566, 0.12823011312495858, 0.09884727989174336, 0.12401247165346485, 0.13367696878086532, 0.12631246680892527, 0.14954224810644134, 0.10593666390640588, 0.1743427825984445, 0.9808685602426443, 0.9734985661583649, 0.9815393508001424, 0.977086044500265, 0.9712502798367887, 0.9735632365230347, 0.9823426630632758, 0.9818741702660454, 0.9730674847082628, 0.5255160327266236, 0.5298624465849949, 0.4244136362483977, 0.5874525245799853, 0.48602907433788767, 0.5797411892547846, 0.5165320657907935, 0.4587566559281213, 0.12474464519010176, 0.19678894004321623, 0.7640306945023762, 0.3700687589697921, 0.278611112526189, 0.6375760113115532, 0.37669391627624127, 0.5662969320908695, 0.2245319436146267, 0.23195759115792625, 0.13932774807174597, 0.12095056516881597, 0.1947785784463435, 0.1980683465791151, 0.20221934469389913, 0.19193261816580265, 0.256055376304988, 0.20397180740414755, 0.20612904008100064, 0.21129551288892556, 0.11643336171720797, 0.20810723276177956, 0.23776192789576012, 0.19883311331817, 0.25720752050805895, 0.2507886644677606, 0.21382170780991605, 0.25739383749036393, 0.006309616302559329, 0.0003407137397345439, 9.999999999998899e-05, 0.013567422972583287, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0875928678973178, 0.040018526499390084, 0.05529070098849842, 0.061576159604076586, 0.004563522910143392, 0.023128167645673825, 0.04860369427426681, 0.05442214353699759, 0.05160262033667673, 0.03333840843884228, 0.03206765454124105, 0.2123750363316259, 0.19094572672301546, 0.29898544212976164, 0.08835428410745172, 0.09348247840328039, 0.09016988859379593, 0.08787886746801343, 0.13330482275504707, 9.999999999998899e-05, 0.0575254629609353, 0.4087667906596604, 0.15459209224285897, 0.16341738666111905, 0.23105485238168055, 0.08016685586186378, 0.14064684737966804, 0.5054269605052821, 0.5563069425076299, 0.551516695133986, 0.5071522127141552, 0.5280893639451725, 0.5687323266084054, 0.5804911308009577, 0.532615323634141, 0.5576353390552538, 0.09557253045703706, 0.09356846694430132, 0.09617330755073905, 0.12415424362221694, 0.10058895989486993, 0.15582694808331998, 0.5194549538199267, 0.141895785983301, 0.1064180028924544, 0.3527897410471831, 0.23088912661962635, 0.20942558872597716, 0.18028588216205554, 0.16807130212078158, 0.3369659072154435, 0.26331298882058485, 0.21048599667950707, 0.3906858489602406, 0.3636802781120395, 0.2463404469694488, 0.40696408793728, 0.5183264130114135, 0.37380030574652423, 0.3350442133032665, 0.474801127708675, 0.5085174786515119, 0.5034826350465341, 0.37848033271944537, 0.17006479466512991, 0.3061538606631945, 0.25086817339396006, 0.20207272795270304, 0.3136093126003878, 0.2296436706009508, 0.23345885916060205, 0.21535021567684132, 0.23110795176745835, 0.19163854751023457, 0.20004259103028443, 0.20173185043592456, 0.22159133640853712, 0.20130339844920409, 0.24230649233313784, 0.21279194360306952, 0.22563249138905583, 0.24298340475830804, 0.24417692919218104, 0.22044398748113814, 0.22278751098610727, 0.24689943552277316, 0.21695487967015448, 0.243167960921696, 0.7073744977056169, 0.19322001933386213, 0.12684395588444752, 0.872934549264007, 0.15260540192827154, 0.8470783854577891, 0.7457469272801204, 0.1983266579692612, 0.14152982059971242, 0.16879368885917523, 0.8662333823841213, 0.6865999436543693, 0.1690919975970936, 0.20209176281590013, 0.6365828243392752, 0.4990521818531308, 0.4498687612545986, 0.11275281087037892, 0.104583443419076, 0.6889274914580292, 0.188707413305521, 0.18768631038139516, 0.18711153085641785, 0.1964128579191785, 0.1848995445187197, 0.18353731205452384, 0.19274732617768453, 0.19751774166559877, 0.19476158709052904, 0.09198154644897838, 0.09658790766121417, 0.09474635358958639, 0.0844649704190581, 0.08947295214502449, 0.0873514062794093, 0.0928323246767423, 0.08264388009436119, 0.09685428586558786]}, "mutation_prompt": null}
{"id": "4d15f4a5-f2a2-4c8f-9fe9-bb252efca3fa", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))  # Adjusted population size\n        self.f = 0.8  # Increased DE scaling factor\n        self.cr = 0.9  # Increased crossover probability\n        self.w = 0.4  # Reduced inertia weight for PSO\n        self.c1 = 2.0  # Increased cognitive coefficient\n        self.c2 = 1.5  # Social coefficient remains unchanged\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = (self.w * velocities \n                         + self.c1 * r1 * (personal_best - population) \n                         + self.c2 * r2 * (global_best - population))\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "HybridDEPSO", "description": "An enhanced hybrid algorithm integrating adaptive differential evolution and particle swarm optimization with a dynamic population size adjustment to improve convergence speed and solution quality.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "654e364f-c1b7-4995-95d6-bbd470de5653", "metadata": {"aucs": [0.8394962469168398, 0.8417813244282686, 0.8455187156914244, 0.8403226970091702, 0.8343401775951185, 0.8519545049720507, 0.8391899275295616, 0.8281183993172871, 0.834739297766486, 0.6558526235445217, 0.6848861609713168, 0.675942127735668, 0.6754730324398399, 0.6949642598564284, 0.6940982422276516, 0.6783318024195201, 0.6937579700035201, 0.5964843461403746, 0.10668689265107256, 0.470583134602518, 0.1703506830230379, 0.21476877920406934, 0.14158858254061324, 0.13014758007124727, 0.17085702408230863, 0.11781928710569334, 0.2532771563527624, 0.13802327165938566, 0.12823011312495858, 0.09884727989174336, 0.12401247165346485, 0.13367696878086532, 0.12631246680892527, 0.14954224810644134, 0.10593666390640588, 0.1743427825984445, 0.9808685602426443, 0.9734985661583649, 0.9815393508001424, 0.977086044500265, 0.9712502798367887, 0.9735632365230347, 0.9823426630632758, 0.9818741702660454, 0.9730674847082628, 0.5255160327266236, 0.5298624465849949, 0.4244136362483977, 0.5874525245799853, 0.48602907433788767, 0.5797411892547846, 0.5165320657907935, 0.4587566559281213, 0.12474464519010176, 0.19678894004321623, 0.7640306945023762, 0.3700687589697921, 0.278611112526189, 0.6375760113115532, 0.37669391627624127, 0.5662969320908695, 0.2245319436146267, 0.23195759115792625, 0.13932774807174597, 0.12095056516881597, 0.1947785784463435, 0.1980683465791151, 0.20221934469389913, 0.19193261816580265, 0.256055376304988, 0.20397180740414755, 0.20612904008100064, 0.21129551288892556, 0.11643336171720797, 0.20810723276177956, 0.23776192789576012, 0.19883311331817, 0.25720752050805895, 0.2507886644677606, 0.21382170780991605, 0.25739383749036393, 0.006309616302559329, 0.0003407137397345439, 9.999999999998899e-05, 0.013567422972583287, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0875928678973178, 0.040018526499390084, 0.05529070098849842, 0.061576159604076586, 0.004563522910143392, 0.023128167645673825, 0.04860369427426681, 0.05442214353699759, 0.05160262033667673, 0.03333840843884228, 0.03206765454124105, 0.2123750363316259, 0.19094572672301546, 0.29898544212976164, 0.08835428410745172, 0.09348247840328039, 0.09016988859379593, 0.08787886746801343, 0.13330482275504707, 9.999999999998899e-05, 0.0575254629609353, 0.4087667906596604, 0.15459209224285897, 0.16341738666111905, 0.23105485238168055, 0.08016685586186378, 0.14064684737966804, 0.5054269605052821, 0.5563069425076299, 0.551516695133986, 0.5071522127141552, 0.5280893639451725, 0.5687323266084054, 0.5804911308009577, 0.532615323634141, 0.5576353390552538, 0.09557253045703706, 0.09356846694430132, 0.09617330755073905, 0.12415424362221694, 0.10058895989486993, 0.15582694808331998, 0.5194549538199267, 0.141895785983301, 0.1064180028924544, 0.3527897410471831, 0.23088912661962635, 0.20942558872597716, 0.18028588216205554, 0.16807130212078158, 0.3369659072154435, 0.26331298882058485, 0.21048599667950707, 0.3906858489602406, 0.3636802781120395, 0.2463404469694488, 0.40696408793728, 0.5183264130114135, 0.37380030574652423, 0.3350442133032665, 0.474801127708675, 0.5085174786515119, 0.5034826350465341, 0.37848033271944537, 0.17006479466512991, 0.3061538606631945, 0.25086817339396006, 0.20207272795270304, 0.3136093126003878, 0.2296436706009508, 0.23345885916060205, 0.21535021567684132, 0.23110795176745835, 0.19163854751023457, 0.20004259103028443, 0.20173185043592456, 0.22159133640853712, 0.20130339844920409, 0.24230649233313784, 0.21279194360306952, 0.22563249138905583, 0.24298340475830804, 0.24417692919218104, 0.22044398748113814, 0.22278751098610727, 0.24689943552277316, 0.21695487967015448, 0.243167960921696, 0.7073744977056169, 0.19322001933386213, 0.12684395588444752, 0.872934549264007, 0.15260540192827154, 0.8470783854577891, 0.7457469272801204, 0.1983266579692612, 0.14152982059971242, 0.16879368885917523, 0.8662333823841213, 0.6865999436543693, 0.1690919975970936, 0.20209176281590013, 0.6365828243392752, 0.4990521818531308, 0.4498687612545986, 0.11275281087037892, 0.104583443419076, 0.6889274914580292, 0.188707413305521, 0.18768631038139516, 0.18711153085641785, 0.1964128579191785, 0.1848995445187197, 0.18353731205452384, 0.19274732617768453, 0.19751774166559877, 0.19476158709052904, 0.09198154644897838, 0.09658790766121417, 0.09474635358958639, 0.0844649704190581, 0.08947295214502449, 0.0873514062794093, 0.0928323246767423, 0.08264388009436119, 0.09685428586558786]}, "mutation_prompt": null}
{"id": "fadaf861-ad20-4b58-b22d-abc60b05bcc1", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))  # Adjusted population size\n        self.f = 0.8  # Increased DE scaling factor\n        self.cr = 0.9  # Increased crossover probability\n        self.w = 0.4  # Reduced inertia weight for PSO\n        self.c1 = 2.0  # Increased cognitive coefficient\n        self.c2 = 1.5  # Social coefficient remains unchanged\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = (self.w * velocities \n                         + self.c1 * r1 * (personal_best - population) \n                         + self.c2 * r2 * (global_best - population))\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "HybridDEPSO", "description": "An enhanced hybrid algorithm integrating adaptive differential evolution and particle swarm optimization with a dynamic population size adjustment to improve convergence speed and solution quality.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "654e364f-c1b7-4995-95d6-bbd470de5653", "metadata": {"aucs": [0.8394962469168398, 0.8417813244282686, 0.8455187156914244, 0.8403226970091702, 0.8343401775951185, 0.8519545049720507, 0.8391899275295616, 0.8281183993172871, 0.834739297766486, 0.6558526235445217, 0.6848861609713168, 0.675942127735668, 0.6754730324398399, 0.6949642598564284, 0.6940982422276516, 0.6783318024195201, 0.6937579700035201, 0.5964843461403746, 0.10668689265107256, 0.470583134602518, 0.1703506830230379, 0.21476877920406934, 0.14158858254061324, 0.13014758007124727, 0.17085702408230863, 0.11781928710569334, 0.2532771563527624, 0.13802327165938566, 0.12823011312495858, 0.09884727989174336, 0.12401247165346485, 0.13367696878086532, 0.12631246680892527, 0.14954224810644134, 0.10593666390640588, 0.1743427825984445, 0.9808685602426443, 0.9734985661583649, 0.9815393508001424, 0.977086044500265, 0.9712502798367887, 0.9735632365230347, 0.9823426630632758, 0.9818741702660454, 0.9730674847082628, 0.5255160327266236, 0.5298624465849949, 0.4244136362483977, 0.5874525245799853, 0.48602907433788767, 0.5797411892547846, 0.5165320657907935, 0.4587566559281213, 0.12474464519010176, 0.19678894004321623, 0.7640306945023762, 0.3700687589697921, 0.278611112526189, 0.6375760113115532, 0.37669391627624127, 0.5662969320908695, 0.2245319436146267, 0.23195759115792625, 0.13932774807174597, 0.12095056516881597, 0.1947785784463435, 0.1980683465791151, 0.20221934469389913, 0.19193261816580265, 0.256055376304988, 0.20397180740414755, 0.20612904008100064, 0.21129551288892556, 0.11643336171720797, 0.20810723276177956, 0.23776192789576012, 0.19883311331817, 0.25720752050805895, 0.2507886644677606, 0.21382170780991605, 0.25739383749036393, 0.006309616302559329, 0.0003407137397345439, 9.999999999998899e-05, 0.013567422972583287, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0875928678973178, 0.040018526499390084, 0.05529070098849842, 0.061576159604076586, 0.004563522910143392, 0.023128167645673825, 0.04860369427426681, 0.05442214353699759, 0.05160262033667673, 0.03333840843884228, 0.03206765454124105, 0.2123750363316259, 0.19094572672301546, 0.29898544212976164, 0.08835428410745172, 0.09348247840328039, 0.09016988859379593, 0.08787886746801343, 0.13330482275504707, 9.999999999998899e-05, 0.0575254629609353, 0.4087667906596604, 0.15459209224285897, 0.16341738666111905, 0.23105485238168055, 0.08016685586186378, 0.14064684737966804, 0.5054269605052821, 0.5563069425076299, 0.551516695133986, 0.5071522127141552, 0.5280893639451725, 0.5687323266084054, 0.5804911308009577, 0.532615323634141, 0.5576353390552538, 0.09557253045703706, 0.09356846694430132, 0.09617330755073905, 0.12415424362221694, 0.10058895989486993, 0.15582694808331998, 0.5194549538199267, 0.141895785983301, 0.1064180028924544, 0.3527897410471831, 0.23088912661962635, 0.20942558872597716, 0.18028588216205554, 0.16807130212078158, 0.3369659072154435, 0.26331298882058485, 0.21048599667950707, 0.3906858489602406, 0.3636802781120395, 0.2463404469694488, 0.40696408793728, 0.5183264130114135, 0.37380030574652423, 0.3350442133032665, 0.474801127708675, 0.5085174786515119, 0.5034826350465341, 0.37848033271944537, 0.17006479466512991, 0.3061538606631945, 0.25086817339396006, 0.20207272795270304, 0.3136093126003878, 0.2296436706009508, 0.23345885916060205, 0.21535021567684132, 0.23110795176745835, 0.19163854751023457, 0.20004259103028443, 0.20173185043592456, 0.22159133640853712, 0.20130339844920409, 0.24230649233313784, 0.21279194360306952, 0.22563249138905583, 0.24298340475830804, 0.24417692919218104, 0.22044398748113814, 0.22278751098610727, 0.24689943552277316, 0.21695487967015448, 0.243167960921696, 0.7073744977056169, 0.19322001933386213, 0.12684395588444752, 0.872934549264007, 0.15260540192827154, 0.8470783854577891, 0.7457469272801204, 0.1983266579692612, 0.14152982059971242, 0.16879368885917523, 0.8662333823841213, 0.6865999436543693, 0.1690919975970936, 0.20209176281590013, 0.6365828243392752, 0.4990521818531308, 0.4498687612545986, 0.11275281087037892, 0.104583443419076, 0.6889274914580292, 0.188707413305521, 0.18768631038139516, 0.18711153085641785, 0.1964128579191785, 0.1848995445187197, 0.18353731205452384, 0.19274732617768453, 0.19751774166559877, 0.19476158709052904, 0.09198154644897838, 0.09658790766121417, 0.09474635358958639, 0.0844649704190581, 0.08947295214502449, 0.0873514062794093, 0.0928323246767423, 0.08264388009436119, 0.09685428586558786]}, "mutation_prompt": null}
{"id": "c0f0a797-8a21-4d71-9344-95547f345e0e", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))  # Adjusted population size\n        self.f = 0.8  # Increased DE scaling factor\n        self.cr = 0.9  # Increased crossover probability\n        self.w_max = 0.9  # Max inertia weight for PSO\n        self.w_min = 0.3  # Min inertia weight for PSO\n        self.c1 = 2.0  # Increased cognitive coefficient\n        self.c2 = 1.5  # Social coefficient remains unchanged\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        while budget_used < self.budget:\n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                random_factor = np.random.uniform(0.5, 1.5)  # Dynamic scaling factor\n                mutant = np.clip(a + random_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            w = self.w_max - (self.w_max - self.w_min) * (budget_used / self.budget)  # Adaptive inertia weight\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = (w * velocities \n                         + self.c1 * r1 * (personal_best - population) \n                         + self.c2 * r2 * (global_best - population))\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "HybridDEPSO", "description": "Integrate an adaptive inertia weight and mutation strategy to enhance convergence speed and exploration-exploitation balance in the hybrid DE-PSO algorithm.", "configspace": "", "generation": 15, "fitness": 0.21302125351437048, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.21.", "error": "", "parent_id": "654e364f-c1b7-4995-95d6-bbd470de5653", "metadata": {"aucs": [0.5470706257579039, 0.532197819733086, 0.5552873290944802, 0.5823596608058554, 0.5926767391878085, 0.6091128058336914, 0.5435492442175007, 0.5536947167339952, 0.5354377557904155, 0.23319632085543718, 0.14826607224439536, 0.04272831627366436, 0.04578482478161228, 0.2104871982486447, 0.23099945054703774, 0.03676504999468211, 0.24162389669127127, 0.12925047221928276, 0.12035431889844672, 0.10276668728269434, 0.13128519897484026, 0.10338263103329992, 0.12178190391930022, 0.08752209783944032, 0.09393467487340734, 0.11079349341728362, 0.10250912370260135, 0.09433298974350268, 0.09436585489420546, 0.09284716894667777, 0.09033423869997947, 0.09678585218990576, 0.10166430879634714, 0.10468508187953174, 0.09093256739716804, 0.10077860700121655, 0.9729069330927308, 0.9793052522764012, 0.9818248269609231, 0.9631582177788323, 0.9731888588904256, 0.9800791972483479, 0.9817085780800806, 0.980529228048049, 0.9815633063998319, 0.2812774265506829, 0.24258105260836416, 0.2514906969243801, 0.2755836265633743, 0.18519245824398944, 0.3170321638418413, 0.08633845732312107, 0.25362062333531166, 0.04975366199552955, 0.2097383273463087, 0.2558936083924306, 0.16539486619532906, 0.2555609069478173, 0.19053150564279409, 0.15743749621875047, 0.17179635508333124, 0.4694113586972185, 0.15677693038285256, 0.10747755662121328, 0.12502764439154312, 0.0758296048004169, 0.10347057854855024, 0.13252523413579054, 0.13387023025360045, 0.16440093369263198, 0.14577946137288567, 0.13230085651061896, 0.048868918225905666, 0.01857395353751523, 0.12725352390547373, 0.14329357811336962, 0.15459152778159546, 0.10102803709064845, 0.10873892796360729, 0.07107736258991848, 0.12509840516302684, 9.999999999998899e-05, 0.017134416891004145, 0.023590495403550293, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00468349382806077, 9.999999999998899e-05, 0.001971671288896637, 0.0593159709560106, 0.02688833715525074, 0.0667206322913938, 0.08228380568980032, 0.0043219451035989565, 0.07910032848405812, 0.038718139642386684, 0.06851527615236996, 0.04225582731147681, 0.0087004786471232, 0.017077722973653175, 0.02532080764133715, 0.05859516205601489, 0.03844885379107199, 9.999999999998899e-05, 0.05043226265011813, 0.05003483399476294, 0.04570745570787038, 0.16607063737292516, 0.040925615120517844, 0.0962334179842077, 0.0043719911468546035, 0.13816132366983636, 0.030019788795325075, 0.12014123532749033, 0.04812164646491035, 0.07738925031506805, 0.42331009185963886, 0.4164036462952859, 0.3938761891856457, 0.20667643838153682, 0.42535511294939465, 0.4345313640811195, 0.41793703633727086, 0.39565366815235403, 0.41998456064277867, 0.08751717582281249, 0.11398194033920195, 0.11140148206050948, 0.09888503681240857, 0.10067444800763092, 0.07586920115447537, 0.1375220810614155, 0.07508913514076465, 0.11320084657822427, 0.17890667186437514, 0.21319068493812543, 0.1529280886359038, 0.17904026007218232, 0.20163103383475722, 0.19433622580680776, 0.19351234812788143, 0.22445335759986496, 0.19253780243812124, 0.20844328651517008, 0.31333562936395254, 0.2743877830578315, 0.2892182624574935, 0.2788886337722607, 0.3116805760465372, 0.23795695262918148, 0.25965910992463437, 0.3582650701598453, 0.21854773492777413, 0.2084531143626741, 0.24719634064801543, 0.20331108914559148, 0.1989292436770096, 0.21569772851587454, 0.21898801689374126, 0.27120263187940996, 0.2186601214979903, 0.1795576877264794, 0.19397829626133023, 0.1936236070395635, 0.19226500584383843, 0.1720674137074205, 0.19870177998338645, 0.20456251781665902, 0.17510321314421895, 0.17050049819762247, 0.1881016324994077, 0.19714671805235018, 0.20893234142453943, 0.2105807394884922, 0.17295429212911217, 0.20275945737594614, 0.19287988297436076, 0.18394202350040256, 0.18822326603802453, 0.1740945038504773, 0.17933655501607115, 0.1520802581457752, 0.5850703898207215, 0.19331679405314295, 0.1730468053978419, 0.14187109511560825, 0.6074015226941013, 0.1517007998774097, 0.49067282889233044, 0.203382470714481, 0.18896656306234794, 0.33757530622269694, 0.18533074315068743, 0.6252674666188527, 0.19712240629110733, 0.19213915855819097, 0.14991955633543164, 0.17388288529424722, 0.18110759737163717, 0.18431245295930798, 0.18084332175412232, 0.1925027054216789, 0.20623567532677423, 0.19212372116511456, 0.20633381232494197, 0.19763093387836883, 0.07030298619463615, 0.06991470621928442, 0.08667012515030059, 0.06875418655181131, 0.0677017271742516, 0.08669354007065977, 0.08748121065646952, 0.0777910776757551, 0.08462506511383894]}, "mutation_prompt": null}
{"id": "9a95766d-9911-443d-942b-88e98db8c1c5", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))  # Adjusted population size\n        self.f = 0.8  # Increased DE scaling factor\n        self.cr = 0.9  # Increased crossover probability\n        self.w = 0.4  # Reduced inertia weight for PSO\n        self.c1 = 2.0  # Increased cognitive coefficient\n        self.c2 = 1.5  # Social coefficient remains unchanged\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = (self.w * velocities \n                         + self.c1 * r1 * (personal_best - population) \n                         + self.c2 * r2 * (global_best - population))\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "HybridDEPSO", "description": "An enhanced hybrid algorithm integrating adaptive differential evolution and particle swarm optimization with a dynamic population size adjustment to improve convergence speed and solution quality.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "654e364f-c1b7-4995-95d6-bbd470de5653", "metadata": {"aucs": [0.8394962469168398, 0.8417813244282686, 0.8455187156914244, 0.8403226970091702, 0.8343401775951185, 0.8519545049720507, 0.8391899275295616, 0.8281183993172871, 0.834739297766486, 0.6558526235445217, 0.6848861609713168, 0.675942127735668, 0.6754730324398399, 0.6949642598564284, 0.6940982422276516, 0.6783318024195201, 0.6937579700035201, 0.5964843461403746, 0.10668689265107256, 0.470583134602518, 0.1703506830230379, 0.21476877920406934, 0.14158858254061324, 0.13014758007124727, 0.17085702408230863, 0.11781928710569334, 0.2532771563527624, 0.13802327165938566, 0.12823011312495858, 0.09884727989174336, 0.12401247165346485, 0.13367696878086532, 0.12631246680892527, 0.14954224810644134, 0.10593666390640588, 0.1743427825984445, 0.9808685602426443, 0.9734985661583649, 0.9815393508001424, 0.977086044500265, 0.9712502798367887, 0.9735632365230347, 0.9823426630632758, 0.9818741702660454, 0.9730674847082628, 0.5255160327266236, 0.5298624465849949, 0.4244136362483977, 0.5874525245799853, 0.48602907433788767, 0.5797411892547846, 0.5165320657907935, 0.4587566559281213, 0.12474464519010176, 0.19678894004321623, 0.7640306945023762, 0.3700687589697921, 0.278611112526189, 0.6375760113115532, 0.37669391627624127, 0.5662969320908695, 0.2245319436146267, 0.23195759115792625, 0.13932774807174597, 0.12095056516881597, 0.1947785784463435, 0.1980683465791151, 0.20221934469389913, 0.19193261816580265, 0.256055376304988, 0.20397180740414755, 0.20612904008100064, 0.21129551288892556, 0.11643336171720797, 0.20810723276177956, 0.23776192789576012, 0.19883311331817, 0.25720752050805895, 0.2507886644677606, 0.21382170780991605, 0.25739383749036393, 0.006309616302559329, 0.0003407137397345439, 9.999999999998899e-05, 0.013567422972583287, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0875928678973178, 0.040018526499390084, 0.05529070098849842, 0.061576159604076586, 0.004563522910143392, 0.023128167645673825, 0.04860369427426681, 0.05442214353699759, 0.05160262033667673, 0.03333840843884228, 0.03206765454124105, 0.2123750363316259, 0.19094572672301546, 0.29898544212976164, 0.08835428410745172, 0.09348247840328039, 0.09016988859379593, 0.08787886746801343, 0.13330482275504707, 9.999999999998899e-05, 0.0575254629609353, 0.4087667906596604, 0.15459209224285897, 0.16341738666111905, 0.23105485238168055, 0.08016685586186378, 0.14064684737966804, 0.5054269605052821, 0.5563069425076299, 0.551516695133986, 0.5071522127141552, 0.5280893639451725, 0.5687323266084054, 0.5804911308009577, 0.532615323634141, 0.5576353390552538, 0.09557253045703706, 0.09356846694430132, 0.09617330755073905, 0.12415424362221694, 0.10058895989486993, 0.15582694808331998, 0.5194549538199267, 0.141895785983301, 0.1064180028924544, 0.3527897410471831, 0.23088912661962635, 0.20942558872597716, 0.18028588216205554, 0.16807130212078158, 0.3369659072154435, 0.26331298882058485, 0.21048599667950707, 0.3906858489602406, 0.3636802781120395, 0.2463404469694488, 0.40696408793728, 0.5183264130114135, 0.37380030574652423, 0.3350442133032665, 0.474801127708675, 0.5085174786515119, 0.5034826350465341, 0.37848033271944537, 0.17006479466512991, 0.3061538606631945, 0.25086817339396006, 0.20207272795270304, 0.3136093126003878, 0.2296436706009508, 0.23345885916060205, 0.21535021567684132, 0.23110795176745835, 0.19163854751023457, 0.20004259103028443, 0.20173185043592456, 0.22159133640853712, 0.20130339844920409, 0.24230649233313784, 0.21279194360306952, 0.22563249138905583, 0.24298340475830804, 0.24417692919218104, 0.22044398748113814, 0.22278751098610727, 0.24689943552277316, 0.21695487967015448, 0.243167960921696, 0.7073744977056169, 0.19322001933386213, 0.12684395588444752, 0.872934549264007, 0.15260540192827154, 0.8470783854577891, 0.7457469272801204, 0.1983266579692612, 0.14152982059971242, 0.16879368885917523, 0.8662333823841213, 0.6865999436543693, 0.1690919975970936, 0.20209176281590013, 0.6365828243392752, 0.4990521818531308, 0.4498687612545986, 0.11275281087037892, 0.104583443419076, 0.6889274914580292, 0.188707413305521, 0.18768631038139516, 0.18711153085641785, 0.1964128579191785, 0.1848995445187197, 0.18353731205452384, 0.19274732617768453, 0.19751774166559877, 0.19476158709052904, 0.09198154644897838, 0.09658790766121417, 0.09474635358958639, 0.0844649704190581, 0.08947295214502449, 0.0873514062794093, 0.0928323246767423, 0.08264388009436119, 0.09685428586558786]}, "mutation_prompt": null}
{"id": "a35c1898-ef13-4195-94f4-395522868ec6", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))  # Adjusted population size\n        self.f = 0.8  # Increased DE scaling factor\n        self.cr = 0.9  # Increased crossover probability\n        self.w = 0.4  # Reduced inertia weight for PSO\n        self.c1 = 2.0  # Increased cognitive coefficient\n        self.c2 = 1.5  # Social coefficient remains unchanged\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = (self.w * velocities \n                         + self.c1 * r1 * (personal_best - population) \n                         + self.c2 * r2 * (global_best - population))\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "HybridDEPSO", "description": "An enhanced hybrid algorithm integrating adaptive differential evolution and particle swarm optimization with a dynamic population size adjustment to improve convergence speed and solution quality.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "654e364f-c1b7-4995-95d6-bbd470de5653", "metadata": {"aucs": [0.8394962469168398, 0.8417813244282686, 0.8455187156914244, 0.8403226970091702, 0.8343401775951185, 0.8519545049720507, 0.8391899275295616, 0.8281183993172871, 0.834739297766486, 0.6558526235445217, 0.6848861609713168, 0.675942127735668, 0.6754730324398399, 0.6949642598564284, 0.6940982422276516, 0.6783318024195201, 0.6937579700035201, 0.5964843461403746, 0.10668689265107256, 0.470583134602518, 0.1703506830230379, 0.21476877920406934, 0.14158858254061324, 0.13014758007124727, 0.17085702408230863, 0.11781928710569334, 0.2532771563527624, 0.13802327165938566, 0.12823011312495858, 0.09884727989174336, 0.12401247165346485, 0.13367696878086532, 0.12631246680892527, 0.14954224810644134, 0.10593666390640588, 0.1743427825984445, 0.9808685602426443, 0.9734985661583649, 0.9815393508001424, 0.977086044500265, 0.9712502798367887, 0.9735632365230347, 0.9823426630632758, 0.9818741702660454, 0.9730674847082628, 0.5255160327266236, 0.5298624465849949, 0.4244136362483977, 0.5874525245799853, 0.48602907433788767, 0.5797411892547846, 0.5165320657907935, 0.4587566559281213, 0.12474464519010176, 0.19678894004321623, 0.7640306945023762, 0.3700687589697921, 0.278611112526189, 0.6375760113115532, 0.37669391627624127, 0.5662969320908695, 0.2245319436146267, 0.23195759115792625, 0.13932774807174597, 0.12095056516881597, 0.1947785784463435, 0.1980683465791151, 0.20221934469389913, 0.19193261816580265, 0.256055376304988, 0.20397180740414755, 0.20612904008100064, 0.21129551288892556, 0.11643336171720797, 0.20810723276177956, 0.23776192789576012, 0.19883311331817, 0.25720752050805895, 0.2507886644677606, 0.21382170780991605, 0.25739383749036393, 0.006309616302559329, 0.0003407137397345439, 9.999999999998899e-05, 0.013567422972583287, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0875928678973178, 0.040018526499390084, 0.05529070098849842, 0.061576159604076586, 0.004563522910143392, 0.023128167645673825, 0.04860369427426681, 0.05442214353699759, 0.05160262033667673, 0.03333840843884228, 0.03206765454124105, 0.2123750363316259, 0.19094572672301546, 0.29898544212976164, 0.08835428410745172, 0.09348247840328039, 0.09016988859379593, 0.08787886746801343, 0.13330482275504707, 9.999999999998899e-05, 0.0575254629609353, 0.4087667906596604, 0.15459209224285897, 0.16341738666111905, 0.23105485238168055, 0.08016685586186378, 0.14064684737966804, 0.5054269605052821, 0.5563069425076299, 0.551516695133986, 0.5071522127141552, 0.5280893639451725, 0.5687323266084054, 0.5804911308009577, 0.532615323634141, 0.5576353390552538, 0.09557253045703706, 0.09356846694430132, 0.09617330755073905, 0.12415424362221694, 0.10058895989486993, 0.15582694808331998, 0.5194549538199267, 0.141895785983301, 0.1064180028924544, 0.3527897410471831, 0.23088912661962635, 0.20942558872597716, 0.18028588216205554, 0.16807130212078158, 0.3369659072154435, 0.26331298882058485, 0.21048599667950707, 0.3906858489602406, 0.3636802781120395, 0.2463404469694488, 0.40696408793728, 0.5183264130114135, 0.37380030574652423, 0.3350442133032665, 0.474801127708675, 0.5085174786515119, 0.5034826350465341, 0.37848033271944537, 0.17006479466512991, 0.3061538606631945, 0.25086817339396006, 0.20207272795270304, 0.3136093126003878, 0.2296436706009508, 0.23345885916060205, 0.21535021567684132, 0.23110795176745835, 0.19163854751023457, 0.20004259103028443, 0.20173185043592456, 0.22159133640853712, 0.20130339844920409, 0.24230649233313784, 0.21279194360306952, 0.22563249138905583, 0.24298340475830804, 0.24417692919218104, 0.22044398748113814, 0.22278751098610727, 0.24689943552277316, 0.21695487967015448, 0.243167960921696, 0.7073744977056169, 0.19322001933386213, 0.12684395588444752, 0.872934549264007, 0.15260540192827154, 0.8470783854577891, 0.7457469272801204, 0.1983266579692612, 0.14152982059971242, 0.16879368885917523, 0.8662333823841213, 0.6865999436543693, 0.1690919975970936, 0.20209176281590013, 0.6365828243392752, 0.4990521818531308, 0.4498687612545986, 0.11275281087037892, 0.104583443419076, 0.6889274914580292, 0.188707413305521, 0.18768631038139516, 0.18711153085641785, 0.1964128579191785, 0.1848995445187197, 0.18353731205452384, 0.19274732617768453, 0.19751774166559877, 0.19476158709052904, 0.09198154644897838, 0.09658790766121417, 0.09474635358958639, 0.0844649704190581, 0.08947295214502449, 0.0873514062794093, 0.0928323246767423, 0.08264388009436119, 0.09685428586558786]}, "mutation_prompt": null}
{"id": "25e64c60-72f6-4216-a66b-aff2bf572c43", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))  # Adjusted population size\n        self.f = 0.8  # Increased DE scaling factor\n        self.cr = 0.9  # Increased crossover probability\n        self.w = 0.4  # Reduced inertia weight for PSO\n        self.c1 = 2.0  # Increased cognitive coefficient\n        self.c2 = 1.5  # Social coefficient remains unchanged\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = (self.w * velocities \n                         + self.c1 * r1 * (personal_best - population) \n                         + self.c2 * r2 * (global_best - population))\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "HybridDEPSO", "description": "An enhanced hybrid algorithm integrating adaptive differential evolution and particle swarm optimization with a dynamic population size adjustment to improve convergence speed and solution quality.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "654e364f-c1b7-4995-95d6-bbd470de5653", "metadata": {"aucs": [0.8394962469168398, 0.8417813244282686, 0.8455187156914244, 0.8403226970091702, 0.8343401775951185, 0.8519545049720507, 0.8391899275295616, 0.8281183993172871, 0.834739297766486, 0.6558526235445217, 0.6848861609713168, 0.675942127735668, 0.6754730324398399, 0.6949642598564284, 0.6940982422276516, 0.6783318024195201, 0.6937579700035201, 0.5964843461403746, 0.10668689265107256, 0.470583134602518, 0.1703506830230379, 0.21476877920406934, 0.14158858254061324, 0.13014758007124727, 0.17085702408230863, 0.11781928710569334, 0.2532771563527624, 0.13802327165938566, 0.12823011312495858, 0.09884727989174336, 0.12401247165346485, 0.13367696878086532, 0.12631246680892527, 0.14954224810644134, 0.10593666390640588, 0.1743427825984445, 0.9808685602426443, 0.9734985661583649, 0.9815393508001424, 0.977086044500265, 0.9712502798367887, 0.9735632365230347, 0.9823426630632758, 0.9818741702660454, 0.9730674847082628, 0.5255160327266236, 0.5298624465849949, 0.4244136362483977, 0.5874525245799853, 0.48602907433788767, 0.5797411892547846, 0.5165320657907935, 0.4587566559281213, 0.12474464519010176, 0.19678894004321623, 0.7640306945023762, 0.3700687589697921, 0.278611112526189, 0.6375760113115532, 0.37669391627624127, 0.5662969320908695, 0.2245319436146267, 0.23195759115792625, 0.13932774807174597, 0.12095056516881597, 0.1947785784463435, 0.1980683465791151, 0.20221934469389913, 0.19193261816580265, 0.256055376304988, 0.20397180740414755, 0.20612904008100064, 0.21129551288892556, 0.11643336171720797, 0.20810723276177956, 0.23776192789576012, 0.19883311331817, 0.25720752050805895, 0.2507886644677606, 0.21382170780991605, 0.25739383749036393, 0.006309616302559329, 0.0003407137397345439, 9.999999999998899e-05, 0.013567422972583287, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0875928678973178, 0.040018526499390084, 0.05529070098849842, 0.061576159604076586, 0.004563522910143392, 0.023128167645673825, 0.04860369427426681, 0.05442214353699759, 0.05160262033667673, 0.03333840843884228, 0.03206765454124105, 0.2123750363316259, 0.19094572672301546, 0.29898544212976164, 0.08835428410745172, 0.09348247840328039, 0.09016988859379593, 0.08787886746801343, 0.13330482275504707, 9.999999999998899e-05, 0.0575254629609353, 0.4087667906596604, 0.15459209224285897, 0.16341738666111905, 0.23105485238168055, 0.08016685586186378, 0.14064684737966804, 0.5054269605052821, 0.5563069425076299, 0.551516695133986, 0.5071522127141552, 0.5280893639451725, 0.5687323266084054, 0.5804911308009577, 0.532615323634141, 0.5576353390552538, 0.09557253045703706, 0.09356846694430132, 0.09617330755073905, 0.12415424362221694, 0.10058895989486993, 0.15582694808331998, 0.5194549538199267, 0.141895785983301, 0.1064180028924544, 0.3527897410471831, 0.23088912661962635, 0.20942558872597716, 0.18028588216205554, 0.16807130212078158, 0.3369659072154435, 0.26331298882058485, 0.21048599667950707, 0.3906858489602406, 0.3636802781120395, 0.2463404469694488, 0.40696408793728, 0.5183264130114135, 0.37380030574652423, 0.3350442133032665, 0.474801127708675, 0.5085174786515119, 0.5034826350465341, 0.37848033271944537, 0.17006479466512991, 0.3061538606631945, 0.25086817339396006, 0.20207272795270304, 0.3136093126003878, 0.2296436706009508, 0.23345885916060205, 0.21535021567684132, 0.23110795176745835, 0.19163854751023457, 0.20004259103028443, 0.20173185043592456, 0.22159133640853712, 0.20130339844920409, 0.24230649233313784, 0.21279194360306952, 0.22563249138905583, 0.24298340475830804, 0.24417692919218104, 0.22044398748113814, 0.22278751098610727, 0.24689943552277316, 0.21695487967015448, 0.243167960921696, 0.7073744977056169, 0.19322001933386213, 0.12684395588444752, 0.872934549264007, 0.15260540192827154, 0.8470783854577891, 0.7457469272801204, 0.1983266579692612, 0.14152982059971242, 0.16879368885917523, 0.8662333823841213, 0.6865999436543693, 0.1690919975970936, 0.20209176281590013, 0.6365828243392752, 0.4990521818531308, 0.4498687612545986, 0.11275281087037892, 0.104583443419076, 0.6889274914580292, 0.188707413305521, 0.18768631038139516, 0.18711153085641785, 0.1964128579191785, 0.1848995445187197, 0.18353731205452384, 0.19274732617768453, 0.19751774166559877, 0.19476158709052904, 0.09198154644897838, 0.09658790766121417, 0.09474635358958639, 0.0844649704190581, 0.08947295214502449, 0.0873514062794093, 0.0928323246767423, 0.08264388009436119, 0.09685428586558786]}, "mutation_prompt": null}
{"id": "d85216b2-4f3c-47e5-a79f-97e97d60b09e", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))  # Adjusted population size\n        self.f = 0.8  # Increased DE scaling factor\n        self.cr = 0.9  # Increased crossover probability\n        self.w = 0.4  # Reduced inertia weight for PSO\n        self.c1 = 2.0  # Increased cognitive coefficient\n        self.c2 = 1.5  # Social coefficient remains unchanged\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = (self.w * velocities \n                         + self.c1 * r1 * (personal_best - population) \n                         + self.c2 * r2 * (global_best - population))\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "HybridDEPSO", "description": "An enhanced hybrid algorithm integrating adaptive differential evolution and particle swarm optimization with a dynamic population size adjustment to improve convergence speed and solution quality.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "654e364f-c1b7-4995-95d6-bbd470de5653", "metadata": {"aucs": [0.8394962469168398, 0.8417813244282686, 0.8455187156914244, 0.8403226970091702, 0.8343401775951185, 0.8519545049720507, 0.8391899275295616, 0.8281183993172871, 0.834739297766486, 0.6558526235445217, 0.6848861609713168, 0.675942127735668, 0.6754730324398399, 0.6949642598564284, 0.6940982422276516, 0.6783318024195201, 0.6937579700035201, 0.5964843461403746, 0.10668689265107256, 0.470583134602518, 0.1703506830230379, 0.21476877920406934, 0.14158858254061324, 0.13014758007124727, 0.17085702408230863, 0.11781928710569334, 0.2532771563527624, 0.13802327165938566, 0.12823011312495858, 0.09884727989174336, 0.12401247165346485, 0.13367696878086532, 0.12631246680892527, 0.14954224810644134, 0.10593666390640588, 0.1743427825984445, 0.9808685602426443, 0.9734985661583649, 0.9815393508001424, 0.977086044500265, 0.9712502798367887, 0.9735632365230347, 0.9823426630632758, 0.9818741702660454, 0.9730674847082628, 0.5255160327266236, 0.5298624465849949, 0.4244136362483977, 0.5874525245799853, 0.48602907433788767, 0.5797411892547846, 0.5165320657907935, 0.4587566559281213, 0.12474464519010176, 0.19678894004321623, 0.7640306945023762, 0.3700687589697921, 0.278611112526189, 0.6375760113115532, 0.37669391627624127, 0.5662969320908695, 0.2245319436146267, 0.23195759115792625, 0.13932774807174597, 0.12095056516881597, 0.1947785784463435, 0.1980683465791151, 0.20221934469389913, 0.19193261816580265, 0.256055376304988, 0.20397180740414755, 0.20612904008100064, 0.21129551288892556, 0.11643336171720797, 0.20810723276177956, 0.23776192789576012, 0.19883311331817, 0.25720752050805895, 0.2507886644677606, 0.21382170780991605, 0.25739383749036393, 0.006309616302559329, 0.0003407137397345439, 9.999999999998899e-05, 0.013567422972583287, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0875928678973178, 0.040018526499390084, 0.05529070098849842, 0.061576159604076586, 0.004563522910143392, 0.023128167645673825, 0.04860369427426681, 0.05442214353699759, 0.05160262033667673, 0.03333840843884228, 0.03206765454124105, 0.2123750363316259, 0.19094572672301546, 0.29898544212976164, 0.08835428410745172, 0.09348247840328039, 0.09016988859379593, 0.08787886746801343, 0.13330482275504707, 9.999999999998899e-05, 0.0575254629609353, 0.4087667906596604, 0.15459209224285897, 0.16341738666111905, 0.23105485238168055, 0.08016685586186378, 0.14064684737966804, 0.5054269605052821, 0.5563069425076299, 0.551516695133986, 0.5071522127141552, 0.5280893639451725, 0.5687323266084054, 0.5804911308009577, 0.532615323634141, 0.5576353390552538, 0.09557253045703706, 0.09356846694430132, 0.09617330755073905, 0.12415424362221694, 0.10058895989486993, 0.15582694808331998, 0.5194549538199267, 0.141895785983301, 0.1064180028924544, 0.3527897410471831, 0.23088912661962635, 0.20942558872597716, 0.18028588216205554, 0.16807130212078158, 0.3369659072154435, 0.26331298882058485, 0.21048599667950707, 0.3906858489602406, 0.3636802781120395, 0.2463404469694488, 0.40696408793728, 0.5183264130114135, 0.37380030574652423, 0.3350442133032665, 0.474801127708675, 0.5085174786515119, 0.5034826350465341, 0.37848033271944537, 0.17006479466512991, 0.3061538606631945, 0.25086817339396006, 0.20207272795270304, 0.3136093126003878, 0.2296436706009508, 0.23345885916060205, 0.21535021567684132, 0.23110795176745835, 0.19163854751023457, 0.20004259103028443, 0.20173185043592456, 0.22159133640853712, 0.20130339844920409, 0.24230649233313784, 0.21279194360306952, 0.22563249138905583, 0.24298340475830804, 0.24417692919218104, 0.22044398748113814, 0.22278751098610727, 0.24689943552277316, 0.21695487967015448, 0.243167960921696, 0.7073744977056169, 0.19322001933386213, 0.12684395588444752, 0.872934549264007, 0.15260540192827154, 0.8470783854577891, 0.7457469272801204, 0.1983266579692612, 0.14152982059971242, 0.16879368885917523, 0.8662333823841213, 0.6865999436543693, 0.1690919975970936, 0.20209176281590013, 0.6365828243392752, 0.4990521818531308, 0.4498687612545986, 0.11275281087037892, 0.104583443419076, 0.6889274914580292, 0.188707413305521, 0.18768631038139516, 0.18711153085641785, 0.1964128579191785, 0.1848995445187197, 0.18353731205452384, 0.19274732617768453, 0.19751774166559877, 0.19476158709052904, 0.09198154644897838, 0.09658790766121417, 0.09474635358958639, 0.0844649704190581, 0.08947295214502449, 0.0873514062794093, 0.0928323246767423, 0.08264388009436119, 0.09685428586558786]}, "mutation_prompt": null}
{"id": "2ed6e99b-bda4-40fc-9aee-d1b00c241f0e", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))  # Adjusted population size\n        self.f = 0.8  # Increased DE scaling factor\n        self.cr = 0.9  # Increased crossover probability\n        self.w = 0.4  # Reduced inertia weight for PSO\n        self.c1 = 2.0  # Increased cognitive coefficient\n        self.c2 = 1.5  # Social coefficient remains unchanged\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = (self.w * velocities \n                         + self.c1 * r1 * (personal_best - population) \n                         + self.c2 * r2 * (global_best - population))\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "HybridDEPSO", "description": "An enhanced hybrid algorithm integrating adaptive differential evolution and particle swarm optimization with a dynamic population size adjustment to improve convergence speed and solution quality.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "654e364f-c1b7-4995-95d6-bbd470de5653", "metadata": {"aucs": [0.8394962469168398, 0.8417813244282686, 0.8455187156914244, 0.8403226970091702, 0.8343401775951185, 0.8519545049720507, 0.8391899275295616, 0.8281183993172871, 0.834739297766486, 0.6558526235445217, 0.6848861609713168, 0.675942127735668, 0.6754730324398399, 0.6949642598564284, 0.6940982422276516, 0.6783318024195201, 0.6937579700035201, 0.5964843461403746, 0.10668689265107256, 0.470583134602518, 0.1703506830230379, 0.21476877920406934, 0.14158858254061324, 0.13014758007124727, 0.17085702408230863, 0.11781928710569334, 0.2532771563527624, 0.13802327165938566, 0.12823011312495858, 0.09884727989174336, 0.12401247165346485, 0.13367696878086532, 0.12631246680892527, 0.14954224810644134, 0.10593666390640588, 0.1743427825984445, 0.9808685602426443, 0.9734985661583649, 0.9815393508001424, 0.977086044500265, 0.9712502798367887, 0.9735632365230347, 0.9823426630632758, 0.9818741702660454, 0.9730674847082628, 0.5255160327266236, 0.5298624465849949, 0.4244136362483977, 0.5874525245799853, 0.48602907433788767, 0.5797411892547846, 0.5165320657907935, 0.4587566559281213, 0.12474464519010176, 0.19678894004321623, 0.7640306945023762, 0.3700687589697921, 0.278611112526189, 0.6375760113115532, 0.37669391627624127, 0.5662969320908695, 0.2245319436146267, 0.23195759115792625, 0.13932774807174597, 0.12095056516881597, 0.1947785784463435, 0.1980683465791151, 0.20221934469389913, 0.19193261816580265, 0.256055376304988, 0.20397180740414755, 0.20612904008100064, 0.21129551288892556, 0.11643336171720797, 0.20810723276177956, 0.23776192789576012, 0.19883311331817, 0.25720752050805895, 0.2507886644677606, 0.21382170780991605, 0.25739383749036393, 0.006309616302559329, 0.0003407137397345439, 9.999999999998899e-05, 0.013567422972583287, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0875928678973178, 0.040018526499390084, 0.05529070098849842, 0.061576159604076586, 0.004563522910143392, 0.023128167645673825, 0.04860369427426681, 0.05442214353699759, 0.05160262033667673, 0.03333840843884228, 0.03206765454124105, 0.2123750363316259, 0.19094572672301546, 0.29898544212976164, 0.08835428410745172, 0.09348247840328039, 0.09016988859379593, 0.08787886746801343, 0.13330482275504707, 9.999999999998899e-05, 0.0575254629609353, 0.4087667906596604, 0.15459209224285897, 0.16341738666111905, 0.23105485238168055, 0.08016685586186378, 0.14064684737966804, 0.5054269605052821, 0.5563069425076299, 0.551516695133986, 0.5071522127141552, 0.5280893639451725, 0.5687323266084054, 0.5804911308009577, 0.532615323634141, 0.5576353390552538, 0.09557253045703706, 0.09356846694430132, 0.09617330755073905, 0.12415424362221694, 0.10058895989486993, 0.15582694808331998, 0.5194549538199267, 0.141895785983301, 0.1064180028924544, 0.3527897410471831, 0.23088912661962635, 0.20942558872597716, 0.18028588216205554, 0.16807130212078158, 0.3369659072154435, 0.26331298882058485, 0.21048599667950707, 0.3906858489602406, 0.3636802781120395, 0.2463404469694488, 0.40696408793728, 0.5183264130114135, 0.37380030574652423, 0.3350442133032665, 0.474801127708675, 0.5085174786515119, 0.5034826350465341, 0.37848033271944537, 0.17006479466512991, 0.3061538606631945, 0.25086817339396006, 0.20207272795270304, 0.3136093126003878, 0.2296436706009508, 0.23345885916060205, 0.21535021567684132, 0.23110795176745835, 0.19163854751023457, 0.20004259103028443, 0.20173185043592456, 0.22159133640853712, 0.20130339844920409, 0.24230649233313784, 0.21279194360306952, 0.22563249138905583, 0.24298340475830804, 0.24417692919218104, 0.22044398748113814, 0.22278751098610727, 0.24689943552277316, 0.21695487967015448, 0.243167960921696, 0.7073744977056169, 0.19322001933386213, 0.12684395588444752, 0.872934549264007, 0.15260540192827154, 0.8470783854577891, 0.7457469272801204, 0.1983266579692612, 0.14152982059971242, 0.16879368885917523, 0.8662333823841213, 0.6865999436543693, 0.1690919975970936, 0.20209176281590013, 0.6365828243392752, 0.4990521818531308, 0.4498687612545986, 0.11275281087037892, 0.104583443419076, 0.6889274914580292, 0.188707413305521, 0.18768631038139516, 0.18711153085641785, 0.1964128579191785, 0.1848995445187197, 0.18353731205452384, 0.19274732617768453, 0.19751774166559877, 0.19476158709052904, 0.09198154644897838, 0.09658790766121417, 0.09474635358958639, 0.0844649704190581, 0.08947295214502449, 0.0873514062794093, 0.0928323246767423, 0.08264388009436119, 0.09685428586558786]}, "mutation_prompt": null}
{"id": "7eb530c1-7a12-4724-ad73-54cd0d2278fc", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))  # Adjusted population size\n        self.f = 0.8  # Increased DE scaling factor\n        self.cr = 0.9  # Increased crossover probability\n        self.w = 0.4  # Reduced inertia weight for PSO\n        self.c1 = 2.0  # Increased cognitive coefficient\n        self.c2 = 1.5  # Social coefficient remains unchanged\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = (self.w * velocities \n                         + self.c1 * r1 * (personal_best - population) \n                         + self.c2 * r2 * (global_best - population))\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "HybridDEPSO", "description": "An enhanced hybrid algorithm integrating adaptive differential evolution and particle swarm optimization with a dynamic population size adjustment to improve convergence speed and solution quality.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "654e364f-c1b7-4995-95d6-bbd470de5653", "metadata": {"aucs": [0.8394962469168398, 0.8417813244282686, 0.8455187156914244, 0.8403226970091702, 0.8343401775951185, 0.8519545049720507, 0.8391899275295616, 0.8281183993172871, 0.834739297766486, 0.6558526235445217, 0.6848861609713168, 0.675942127735668, 0.6754730324398399, 0.6949642598564284, 0.6940982422276516, 0.6783318024195201, 0.6937579700035201, 0.5964843461403746, 0.10668689265107256, 0.470583134602518, 0.1703506830230379, 0.21476877920406934, 0.14158858254061324, 0.13014758007124727, 0.17085702408230863, 0.11781928710569334, 0.2532771563527624, 0.13802327165938566, 0.12823011312495858, 0.09884727989174336, 0.12401247165346485, 0.13367696878086532, 0.12631246680892527, 0.14954224810644134, 0.10593666390640588, 0.1743427825984445, 0.9808685602426443, 0.9734985661583649, 0.9815393508001424, 0.977086044500265, 0.9712502798367887, 0.9735632365230347, 0.9823426630632758, 0.9818741702660454, 0.9730674847082628, 0.5255160327266236, 0.5298624465849949, 0.4244136362483977, 0.5874525245799853, 0.48602907433788767, 0.5797411892547846, 0.5165320657907935, 0.4587566559281213, 0.12474464519010176, 0.19678894004321623, 0.7640306945023762, 0.3700687589697921, 0.278611112526189, 0.6375760113115532, 0.37669391627624127, 0.5662969320908695, 0.2245319436146267, 0.23195759115792625, 0.13932774807174597, 0.12095056516881597, 0.1947785784463435, 0.1980683465791151, 0.20221934469389913, 0.19193261816580265, 0.256055376304988, 0.20397180740414755, 0.20612904008100064, 0.21129551288892556, 0.11643336171720797, 0.20810723276177956, 0.23776192789576012, 0.19883311331817, 0.25720752050805895, 0.2507886644677606, 0.21382170780991605, 0.25739383749036393, 0.006309616302559329, 0.0003407137397345439, 9.999999999998899e-05, 0.013567422972583287, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0875928678973178, 0.040018526499390084, 0.05529070098849842, 0.061576159604076586, 0.004563522910143392, 0.023128167645673825, 0.04860369427426681, 0.05442214353699759, 0.05160262033667673, 0.03333840843884228, 0.03206765454124105, 0.2123750363316259, 0.19094572672301546, 0.29898544212976164, 0.08835428410745172, 0.09348247840328039, 0.09016988859379593, 0.08787886746801343, 0.13330482275504707, 9.999999999998899e-05, 0.0575254629609353, 0.4087667906596604, 0.15459209224285897, 0.16341738666111905, 0.23105485238168055, 0.08016685586186378, 0.14064684737966804, 0.5054269605052821, 0.5563069425076299, 0.551516695133986, 0.5071522127141552, 0.5280893639451725, 0.5687323266084054, 0.5804911308009577, 0.532615323634141, 0.5576353390552538, 0.09557253045703706, 0.09356846694430132, 0.09617330755073905, 0.12415424362221694, 0.10058895989486993, 0.15582694808331998, 0.5194549538199267, 0.141895785983301, 0.1064180028924544, 0.3527897410471831, 0.23088912661962635, 0.20942558872597716, 0.18028588216205554, 0.16807130212078158, 0.3369659072154435, 0.26331298882058485, 0.21048599667950707, 0.3906858489602406, 0.3636802781120395, 0.2463404469694488, 0.40696408793728, 0.5183264130114135, 0.37380030574652423, 0.3350442133032665, 0.474801127708675, 0.5085174786515119, 0.5034826350465341, 0.37848033271944537, 0.17006479466512991, 0.3061538606631945, 0.25086817339396006, 0.20207272795270304, 0.3136093126003878, 0.2296436706009508, 0.23345885916060205, 0.21535021567684132, 0.23110795176745835, 0.19163854751023457, 0.20004259103028443, 0.20173185043592456, 0.22159133640853712, 0.20130339844920409, 0.24230649233313784, 0.21279194360306952, 0.22563249138905583, 0.24298340475830804, 0.24417692919218104, 0.22044398748113814, 0.22278751098610727, 0.24689943552277316, 0.21695487967015448, 0.243167960921696, 0.7073744977056169, 0.19322001933386213, 0.12684395588444752, 0.872934549264007, 0.15260540192827154, 0.8470783854577891, 0.7457469272801204, 0.1983266579692612, 0.14152982059971242, 0.16879368885917523, 0.8662333823841213, 0.6865999436543693, 0.1690919975970936, 0.20209176281590013, 0.6365828243392752, 0.4990521818531308, 0.4498687612545986, 0.11275281087037892, 0.104583443419076, 0.6889274914580292, 0.188707413305521, 0.18768631038139516, 0.18711153085641785, 0.1964128579191785, 0.1848995445187197, 0.18353731205452384, 0.19274732617768453, 0.19751774166559877, 0.19476158709052904, 0.09198154644897838, 0.09658790766121417, 0.09474635358958639, 0.0844649704190581, 0.08947295214502449, 0.0873514062794093, 0.0928323246767423, 0.08264388009436119, 0.09685428586558786]}, "mutation_prompt": null}
{"id": "0dd55c50-1c57-4a38-9f84-417dc1880609", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))  # Adjusted population size\n        self.f = 0.8  # Increased DE scaling factor\n        self.cr = 0.9  # Increased crossover probability\n        self.w = 0.4  # Reduced inertia weight for PSO\n        self.c1 = 2.0  # Increased cognitive coefficient\n        self.c2 = 1.5  # Social coefficient remains unchanged\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = (self.w * velocities \n                         + self.c1 * r1 * (personal_best - population) \n                         + self.c2 * r2 * (global_best - population))\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "HybridDEPSO", "description": "An enhanced hybrid algorithm integrating adaptive differential evolution and particle swarm optimization with a dynamic population size adjustment to improve convergence speed and solution quality.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "654e364f-c1b7-4995-95d6-bbd470de5653", "metadata": {"aucs": [0.8394962469168398, 0.8417813244282686, 0.8455187156914244, 0.8403226970091702, 0.8343401775951185, 0.8519545049720507, 0.8391899275295616, 0.8281183993172871, 0.834739297766486, 0.6558526235445217, 0.6848861609713168, 0.675942127735668, 0.6754730324398399, 0.6949642598564284, 0.6940982422276516, 0.6783318024195201, 0.6937579700035201, 0.5964843461403746, 0.10668689265107256, 0.470583134602518, 0.1703506830230379, 0.21476877920406934, 0.14158858254061324, 0.13014758007124727, 0.17085702408230863, 0.11781928710569334, 0.2532771563527624, 0.13802327165938566, 0.12823011312495858, 0.09884727989174336, 0.12401247165346485, 0.13367696878086532, 0.12631246680892527, 0.14954224810644134, 0.10593666390640588, 0.1743427825984445, 0.9808685602426443, 0.9734985661583649, 0.9815393508001424, 0.977086044500265, 0.9712502798367887, 0.9735632365230347, 0.9823426630632758, 0.9818741702660454, 0.9730674847082628, 0.5255160327266236, 0.5298624465849949, 0.4244136362483977, 0.5874525245799853, 0.48602907433788767, 0.5797411892547846, 0.5165320657907935, 0.4587566559281213, 0.12474464519010176, 0.19678894004321623, 0.7640306945023762, 0.3700687589697921, 0.278611112526189, 0.6375760113115532, 0.37669391627624127, 0.5662969320908695, 0.2245319436146267, 0.23195759115792625, 0.13932774807174597, 0.12095056516881597, 0.1947785784463435, 0.1980683465791151, 0.20221934469389913, 0.19193261816580265, 0.256055376304988, 0.20397180740414755, 0.20612904008100064, 0.21129551288892556, 0.11643336171720797, 0.20810723276177956, 0.23776192789576012, 0.19883311331817, 0.25720752050805895, 0.2507886644677606, 0.21382170780991605, 0.25739383749036393, 0.006309616302559329, 0.0003407137397345439, 9.999999999998899e-05, 0.013567422972583287, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0875928678973178, 0.040018526499390084, 0.05529070098849842, 0.061576159604076586, 0.004563522910143392, 0.023128167645673825, 0.04860369427426681, 0.05442214353699759, 0.05160262033667673, 0.03333840843884228, 0.03206765454124105, 0.2123750363316259, 0.19094572672301546, 0.29898544212976164, 0.08835428410745172, 0.09348247840328039, 0.09016988859379593, 0.08787886746801343, 0.13330482275504707, 9.999999999998899e-05, 0.0575254629609353, 0.4087667906596604, 0.15459209224285897, 0.16341738666111905, 0.23105485238168055, 0.08016685586186378, 0.14064684737966804, 0.5054269605052821, 0.5563069425076299, 0.551516695133986, 0.5071522127141552, 0.5280893639451725, 0.5687323266084054, 0.5804911308009577, 0.532615323634141, 0.5576353390552538, 0.09557253045703706, 0.09356846694430132, 0.09617330755073905, 0.12415424362221694, 0.10058895989486993, 0.15582694808331998, 0.5194549538199267, 0.141895785983301, 0.1064180028924544, 0.3527897410471831, 0.23088912661962635, 0.20942558872597716, 0.18028588216205554, 0.16807130212078158, 0.3369659072154435, 0.26331298882058485, 0.21048599667950707, 0.3906858489602406, 0.3636802781120395, 0.2463404469694488, 0.40696408793728, 0.5183264130114135, 0.37380030574652423, 0.3350442133032665, 0.474801127708675, 0.5085174786515119, 0.5034826350465341, 0.37848033271944537, 0.17006479466512991, 0.3061538606631945, 0.25086817339396006, 0.20207272795270304, 0.3136093126003878, 0.2296436706009508, 0.23345885916060205, 0.21535021567684132, 0.23110795176745835, 0.19163854751023457, 0.20004259103028443, 0.20173185043592456, 0.22159133640853712, 0.20130339844920409, 0.24230649233313784, 0.21279194360306952, 0.22563249138905583, 0.24298340475830804, 0.24417692919218104, 0.22044398748113814, 0.22278751098610727, 0.24689943552277316, 0.21695487967015448, 0.243167960921696, 0.7073744977056169, 0.19322001933386213, 0.12684395588444752, 0.872934549264007, 0.15260540192827154, 0.8470783854577891, 0.7457469272801204, 0.1983266579692612, 0.14152982059971242, 0.16879368885917523, 0.8662333823841213, 0.6865999436543693, 0.1690919975970936, 0.20209176281590013, 0.6365828243392752, 0.4990521818531308, 0.4498687612545986, 0.11275281087037892, 0.104583443419076, 0.6889274914580292, 0.188707413305521, 0.18768631038139516, 0.18711153085641785, 0.1964128579191785, 0.1848995445187197, 0.18353731205452384, 0.19274732617768453, 0.19751774166559877, 0.19476158709052904, 0.09198154644897838, 0.09658790766121417, 0.09474635358958639, 0.0844649704190581, 0.08947295214502449, 0.0873514062794093, 0.0928323246767423, 0.08264388009436119, 0.09685428586558786]}, "mutation_prompt": null}
{"id": "026796fc-3aeb-45f2-8d7b-873e3fb625ef", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))  # Adjusted population size\n        self.f = 0.8  # Increased DE scaling factor\n        self.cr = 0.9  # Increased crossover probability\n        self.w = 0.4  # Reduced inertia weight for PSO\n        self.c1 = 2.0  # Increased cognitive coefficient\n        self.c2 = 1.5  # Social coefficient remains unchanged\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = (self.w * velocities \n                         + self.c1 * r1 * (personal_best - population) \n                         + self.c2 * r2 * (global_best - population))\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "HybridDEPSO", "description": "An enhanced hybrid algorithm integrating adaptive differential evolution and particle swarm optimization with a dynamic population size adjustment to improve convergence speed and solution quality.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "654e364f-c1b7-4995-95d6-bbd470de5653", "metadata": {"aucs": [0.8394962469168398, 0.8417813244282686, 0.8455187156914244, 0.8403226970091702, 0.8343401775951185, 0.8519545049720507, 0.8391899275295616, 0.8281183993172871, 0.834739297766486, 0.6558526235445217, 0.6848861609713168, 0.675942127735668, 0.6754730324398399, 0.6949642598564284, 0.6940982422276516, 0.6783318024195201, 0.6937579700035201, 0.5964843461403746, 0.10668689265107256, 0.470583134602518, 0.1703506830230379, 0.21476877920406934, 0.14158858254061324, 0.13014758007124727, 0.17085702408230863, 0.11781928710569334, 0.2532771563527624, 0.13802327165938566, 0.12823011312495858, 0.09884727989174336, 0.12401247165346485, 0.13367696878086532, 0.12631246680892527, 0.14954224810644134, 0.10593666390640588, 0.1743427825984445, 0.9808685602426443, 0.9734985661583649, 0.9815393508001424, 0.977086044500265, 0.9712502798367887, 0.9735632365230347, 0.9823426630632758, 0.9818741702660454, 0.9730674847082628, 0.5255160327266236, 0.5298624465849949, 0.4244136362483977, 0.5874525245799853, 0.48602907433788767, 0.5797411892547846, 0.5165320657907935, 0.4587566559281213, 0.12474464519010176, 0.19678894004321623, 0.7640306945023762, 0.3700687589697921, 0.278611112526189, 0.6375760113115532, 0.37669391627624127, 0.5662969320908695, 0.2245319436146267, 0.23195759115792625, 0.13932774807174597, 0.12095056516881597, 0.1947785784463435, 0.1980683465791151, 0.20221934469389913, 0.19193261816580265, 0.256055376304988, 0.20397180740414755, 0.20612904008100064, 0.21129551288892556, 0.11643336171720797, 0.20810723276177956, 0.23776192789576012, 0.19883311331817, 0.25720752050805895, 0.2507886644677606, 0.21382170780991605, 0.25739383749036393, 0.006309616302559329, 0.0003407137397345439, 9.999999999998899e-05, 0.013567422972583287, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0875928678973178, 0.040018526499390084, 0.05529070098849842, 0.061576159604076586, 0.004563522910143392, 0.023128167645673825, 0.04860369427426681, 0.05442214353699759, 0.05160262033667673, 0.03333840843884228, 0.03206765454124105, 0.2123750363316259, 0.19094572672301546, 0.29898544212976164, 0.08835428410745172, 0.09348247840328039, 0.09016988859379593, 0.08787886746801343, 0.13330482275504707, 9.999999999998899e-05, 0.0575254629609353, 0.4087667906596604, 0.15459209224285897, 0.16341738666111905, 0.23105485238168055, 0.08016685586186378, 0.14064684737966804, 0.5054269605052821, 0.5563069425076299, 0.551516695133986, 0.5071522127141552, 0.5280893639451725, 0.5687323266084054, 0.5804911308009577, 0.532615323634141, 0.5576353390552538, 0.09557253045703706, 0.09356846694430132, 0.09617330755073905, 0.12415424362221694, 0.10058895989486993, 0.15582694808331998, 0.5194549538199267, 0.141895785983301, 0.1064180028924544, 0.3527897410471831, 0.23088912661962635, 0.20942558872597716, 0.18028588216205554, 0.16807130212078158, 0.3369659072154435, 0.26331298882058485, 0.21048599667950707, 0.3906858489602406, 0.3636802781120395, 0.2463404469694488, 0.40696408793728, 0.5183264130114135, 0.37380030574652423, 0.3350442133032665, 0.474801127708675, 0.5085174786515119, 0.5034826350465341, 0.37848033271944537, 0.17006479466512991, 0.3061538606631945, 0.25086817339396006, 0.20207272795270304, 0.3136093126003878, 0.2296436706009508, 0.23345885916060205, 0.21535021567684132, 0.23110795176745835, 0.19163854751023457, 0.20004259103028443, 0.20173185043592456, 0.22159133640853712, 0.20130339844920409, 0.24230649233313784, 0.21279194360306952, 0.22563249138905583, 0.24298340475830804, 0.24417692919218104, 0.22044398748113814, 0.22278751098610727, 0.24689943552277316, 0.21695487967015448, 0.243167960921696, 0.7073744977056169, 0.19322001933386213, 0.12684395588444752, 0.872934549264007, 0.15260540192827154, 0.8470783854577891, 0.7457469272801204, 0.1983266579692612, 0.14152982059971242, 0.16879368885917523, 0.8662333823841213, 0.6865999436543693, 0.1690919975970936, 0.20209176281590013, 0.6365828243392752, 0.4990521818531308, 0.4498687612545986, 0.11275281087037892, 0.104583443419076, 0.6889274914580292, 0.188707413305521, 0.18768631038139516, 0.18711153085641785, 0.1964128579191785, 0.1848995445187197, 0.18353731205452384, 0.19274732617768453, 0.19751774166559877, 0.19476158709052904, 0.09198154644897838, 0.09658790766121417, 0.09474635358958639, 0.0844649704190581, 0.08947295214502449, 0.0873514062794093, 0.0928323246767423, 0.08264388009436119, 0.09685428586558786]}, "mutation_prompt": null}
{"id": "947ef036-7051-44ae-9f1f-213a75f0a0e6", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))  # Adjusted population size\n        self.f = 0.8  # Increased DE scaling factor\n        self.cr = 0.9  # Increased crossover probability\n        self.w = 0.4  # Reduced inertia weight for PSO\n        self.c1 = 2.0  # Increased cognitive coefficient\n        self.c2 = 1.5  # Social coefficient remains unchanged\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = (self.w * velocities \n                         + self.c1 * r1 * (personal_best - population) \n                         + self.c2 * r2 * (global_best - population))\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "HybridDEPSO", "description": "An enhanced hybrid algorithm integrating adaptive differential evolution and particle swarm optimization with a dynamic population size adjustment to improve convergence speed and solution quality.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "654e364f-c1b7-4995-95d6-bbd470de5653", "metadata": {"aucs": [0.8394962469168398, 0.8417813244282686, 0.8455187156914244, 0.8403226970091702, 0.8343401775951185, 0.8519545049720507, 0.8391899275295616, 0.8281183993172871, 0.834739297766486, 0.6558526235445217, 0.6848861609713168, 0.675942127735668, 0.6754730324398399, 0.6949642598564284, 0.6940982422276516, 0.6783318024195201, 0.6937579700035201, 0.5964843461403746, 0.10668689265107256, 0.470583134602518, 0.1703506830230379, 0.21476877920406934, 0.14158858254061324, 0.13014758007124727, 0.17085702408230863, 0.11781928710569334, 0.2532771563527624, 0.13802327165938566, 0.12823011312495858, 0.09884727989174336, 0.12401247165346485, 0.13367696878086532, 0.12631246680892527, 0.14954224810644134, 0.10593666390640588, 0.1743427825984445, 0.9808685602426443, 0.9734985661583649, 0.9815393508001424, 0.977086044500265, 0.9712502798367887, 0.9735632365230347, 0.9823426630632758, 0.9818741702660454, 0.9730674847082628, 0.5255160327266236, 0.5298624465849949, 0.4244136362483977, 0.5874525245799853, 0.48602907433788767, 0.5797411892547846, 0.5165320657907935, 0.4587566559281213, 0.12474464519010176, 0.19678894004321623, 0.7640306945023762, 0.3700687589697921, 0.278611112526189, 0.6375760113115532, 0.37669391627624127, 0.5662969320908695, 0.2245319436146267, 0.23195759115792625, 0.13932774807174597, 0.12095056516881597, 0.1947785784463435, 0.1980683465791151, 0.20221934469389913, 0.19193261816580265, 0.256055376304988, 0.20397180740414755, 0.20612904008100064, 0.21129551288892556, 0.11643336171720797, 0.20810723276177956, 0.23776192789576012, 0.19883311331817, 0.25720752050805895, 0.2507886644677606, 0.21382170780991605, 0.25739383749036393, 0.006309616302559329, 0.0003407137397345439, 9.999999999998899e-05, 0.013567422972583287, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0875928678973178, 0.040018526499390084, 0.05529070098849842, 0.061576159604076586, 0.004563522910143392, 0.023128167645673825, 0.04860369427426681, 0.05442214353699759, 0.05160262033667673, 0.03333840843884228, 0.03206765454124105, 0.2123750363316259, 0.19094572672301546, 0.29898544212976164, 0.08835428410745172, 0.09348247840328039, 0.09016988859379593, 0.08787886746801343, 0.13330482275504707, 9.999999999998899e-05, 0.0575254629609353, 0.4087667906596604, 0.15459209224285897, 0.16341738666111905, 0.23105485238168055, 0.08016685586186378, 0.14064684737966804, 0.5054269605052821, 0.5563069425076299, 0.551516695133986, 0.5071522127141552, 0.5280893639451725, 0.5687323266084054, 0.5804911308009577, 0.532615323634141, 0.5576353390552538, 0.09557253045703706, 0.09356846694430132, 0.09617330755073905, 0.12415424362221694, 0.10058895989486993, 0.15582694808331998, 0.5194549538199267, 0.141895785983301, 0.1064180028924544, 0.3527897410471831, 0.23088912661962635, 0.20942558872597716, 0.18028588216205554, 0.16807130212078158, 0.3369659072154435, 0.26331298882058485, 0.21048599667950707, 0.3906858489602406, 0.3636802781120395, 0.2463404469694488, 0.40696408793728, 0.5183264130114135, 0.37380030574652423, 0.3350442133032665, 0.474801127708675, 0.5085174786515119, 0.5034826350465341, 0.37848033271944537, 0.17006479466512991, 0.3061538606631945, 0.25086817339396006, 0.20207272795270304, 0.3136093126003878, 0.2296436706009508, 0.23345885916060205, 0.21535021567684132, 0.23110795176745835, 0.19163854751023457, 0.20004259103028443, 0.20173185043592456, 0.22159133640853712, 0.20130339844920409, 0.24230649233313784, 0.21279194360306952, 0.22563249138905583, 0.24298340475830804, 0.24417692919218104, 0.22044398748113814, 0.22278751098610727, 0.24689943552277316, 0.21695487967015448, 0.243167960921696, 0.7073744977056169, 0.19322001933386213, 0.12684395588444752, 0.872934549264007, 0.15260540192827154, 0.8470783854577891, 0.7457469272801204, 0.1983266579692612, 0.14152982059971242, 0.16879368885917523, 0.8662333823841213, 0.6865999436543693, 0.1690919975970936, 0.20209176281590013, 0.6365828243392752, 0.4990521818531308, 0.4498687612545986, 0.11275281087037892, 0.104583443419076, 0.6889274914580292, 0.188707413305521, 0.18768631038139516, 0.18711153085641785, 0.1964128579191785, 0.1848995445187197, 0.18353731205452384, 0.19274732617768453, 0.19751774166559877, 0.19476158709052904, 0.09198154644897838, 0.09658790766121417, 0.09474635358958639, 0.0844649704190581, 0.08947295214502449, 0.0873514062794093, 0.0928323246767423, 0.08264388009436119, 0.09685428586558786]}, "mutation_prompt": null}
{"id": "8b83a79a-60b3-4288-8398-1dd5ac596f61", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))  # Adjusted population size\n        self.f = 0.8  # Increased DE scaling factor\n        self.cr = 0.9  # Increased crossover probability\n        self.w = 0.4  # Reduced inertia weight for PSO\n        self.c1 = 2.0  # Increased cognitive coefficient\n        self.c2 = 1.5  # Social coefficient remains unchanged\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = (self.w * velocities \n                         + self.c1 * r1 * (personal_best - population) \n                         + self.c2 * r2 * (global_best - population))\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "HybridDEPSO", "description": "An enhanced hybrid algorithm integrating adaptive differential evolution and particle swarm optimization with a dynamic population size adjustment to improve convergence speed and solution quality.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "654e364f-c1b7-4995-95d6-bbd470de5653", "metadata": {"aucs": [0.8394962469168398, 0.8417813244282686, 0.8455187156914244, 0.8403226970091702, 0.8343401775951185, 0.8519545049720507, 0.8391899275295616, 0.8281183993172871, 0.834739297766486, 0.6558526235445217, 0.6848861609713168, 0.675942127735668, 0.6754730324398399, 0.6949642598564284, 0.6940982422276516, 0.6783318024195201, 0.6937579700035201, 0.5964843461403746, 0.10668689265107256, 0.470583134602518, 0.1703506830230379, 0.21476877920406934, 0.14158858254061324, 0.13014758007124727, 0.17085702408230863, 0.11781928710569334, 0.2532771563527624, 0.13802327165938566, 0.12823011312495858, 0.09884727989174336, 0.12401247165346485, 0.13367696878086532, 0.12631246680892527, 0.14954224810644134, 0.10593666390640588, 0.1743427825984445, 0.9808685602426443, 0.9734985661583649, 0.9815393508001424, 0.977086044500265, 0.9712502798367887, 0.9735632365230347, 0.9823426630632758, 0.9818741702660454, 0.9730674847082628, 0.5255160327266236, 0.5298624465849949, 0.4244136362483977, 0.5874525245799853, 0.48602907433788767, 0.5797411892547846, 0.5165320657907935, 0.4587566559281213, 0.12474464519010176, 0.19678894004321623, 0.7640306945023762, 0.3700687589697921, 0.278611112526189, 0.6375760113115532, 0.37669391627624127, 0.5662969320908695, 0.2245319436146267, 0.23195759115792625, 0.13932774807174597, 0.12095056516881597, 0.1947785784463435, 0.1980683465791151, 0.20221934469389913, 0.19193261816580265, 0.256055376304988, 0.20397180740414755, 0.20612904008100064, 0.21129551288892556, 0.11643336171720797, 0.20810723276177956, 0.23776192789576012, 0.19883311331817, 0.25720752050805895, 0.2507886644677606, 0.21382170780991605, 0.25739383749036393, 0.006309616302559329, 0.0003407137397345439, 9.999999999998899e-05, 0.013567422972583287, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0875928678973178, 0.040018526499390084, 0.05529070098849842, 0.061576159604076586, 0.004563522910143392, 0.023128167645673825, 0.04860369427426681, 0.05442214353699759, 0.05160262033667673, 0.03333840843884228, 0.03206765454124105, 0.2123750363316259, 0.19094572672301546, 0.29898544212976164, 0.08835428410745172, 0.09348247840328039, 0.09016988859379593, 0.08787886746801343, 0.13330482275504707, 9.999999999998899e-05, 0.0575254629609353, 0.4087667906596604, 0.15459209224285897, 0.16341738666111905, 0.23105485238168055, 0.08016685586186378, 0.14064684737966804, 0.5054269605052821, 0.5563069425076299, 0.551516695133986, 0.5071522127141552, 0.5280893639451725, 0.5687323266084054, 0.5804911308009577, 0.532615323634141, 0.5576353390552538, 0.09557253045703706, 0.09356846694430132, 0.09617330755073905, 0.12415424362221694, 0.10058895989486993, 0.15582694808331998, 0.5194549538199267, 0.141895785983301, 0.1064180028924544, 0.3527897410471831, 0.23088912661962635, 0.20942558872597716, 0.18028588216205554, 0.16807130212078158, 0.3369659072154435, 0.26331298882058485, 0.21048599667950707, 0.3906858489602406, 0.3636802781120395, 0.2463404469694488, 0.40696408793728, 0.5183264130114135, 0.37380030574652423, 0.3350442133032665, 0.474801127708675, 0.5085174786515119, 0.5034826350465341, 0.37848033271944537, 0.17006479466512991, 0.3061538606631945, 0.25086817339396006, 0.20207272795270304, 0.3136093126003878, 0.2296436706009508, 0.23345885916060205, 0.21535021567684132, 0.23110795176745835, 0.19163854751023457, 0.20004259103028443, 0.20173185043592456, 0.22159133640853712, 0.20130339844920409, 0.24230649233313784, 0.21279194360306952, 0.22563249138905583, 0.24298340475830804, 0.24417692919218104, 0.22044398748113814, 0.22278751098610727, 0.24689943552277316, 0.21695487967015448, 0.243167960921696, 0.7073744977056169, 0.19322001933386213, 0.12684395588444752, 0.872934549264007, 0.15260540192827154, 0.8470783854577891, 0.7457469272801204, 0.1983266579692612, 0.14152982059971242, 0.16879368885917523, 0.8662333823841213, 0.6865999436543693, 0.1690919975970936, 0.20209176281590013, 0.6365828243392752, 0.4990521818531308, 0.4498687612545986, 0.11275281087037892, 0.104583443419076, 0.6889274914580292, 0.188707413305521, 0.18768631038139516, 0.18711153085641785, 0.1964128579191785, 0.1848995445187197, 0.18353731205452384, 0.19274732617768453, 0.19751774166559877, 0.19476158709052904, 0.09198154644897838, 0.09658790766121417, 0.09474635358958639, 0.0844649704190581, 0.08947295214502449, 0.0873514062794093, 0.0928323246767423, 0.08264388009436119, 0.09685428586558786]}, "mutation_prompt": null}
{"id": "6e04ed36-9907-4d06-90b1-495ad4f9202c", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))  # Adjusted population size\n        self.f = 0.8  # Increased DE scaling factor\n        self.cr = 0.9  # Increased crossover probability\n        self.w = 0.4  # Reduced inertia weight for PSO\n        self.c1 = 2.0  # Increased cognitive coefficient\n        self.c2 = 1.5  # Social coefficient remains unchanged\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = (self.w * velocities \n                         + self.c1 * r1 * (personal_best - population) \n                         + self.c2 * r2 * (global_best - population))\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "HybridDEPSO", "description": "An enhanced hybrid algorithm integrating adaptive differential evolution and particle swarm optimization with a dynamic population size adjustment to improve convergence speed and solution quality.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "654e364f-c1b7-4995-95d6-bbd470de5653", "metadata": {"aucs": [0.8394962469168398, 0.8417813244282686, 0.8455187156914244, 0.8403226970091702, 0.8343401775951185, 0.8519545049720507, 0.8391899275295616, 0.8281183993172871, 0.834739297766486, 0.6558526235445217, 0.6848861609713168, 0.675942127735668, 0.6754730324398399, 0.6949642598564284, 0.6940982422276516, 0.6783318024195201, 0.6937579700035201, 0.5964843461403746, 0.10668689265107256, 0.470583134602518, 0.1703506830230379, 0.21476877920406934, 0.14158858254061324, 0.13014758007124727, 0.17085702408230863, 0.11781928710569334, 0.2532771563527624, 0.13802327165938566, 0.12823011312495858, 0.09884727989174336, 0.12401247165346485, 0.13367696878086532, 0.12631246680892527, 0.14954224810644134, 0.10593666390640588, 0.1743427825984445, 0.9808685602426443, 0.9734985661583649, 0.9815393508001424, 0.977086044500265, 0.9712502798367887, 0.9735632365230347, 0.9823426630632758, 0.9818741702660454, 0.9730674847082628, 0.5255160327266236, 0.5298624465849949, 0.4244136362483977, 0.5874525245799853, 0.48602907433788767, 0.5797411892547846, 0.5165320657907935, 0.4587566559281213, 0.12474464519010176, 0.19678894004321623, 0.7640306945023762, 0.3700687589697921, 0.278611112526189, 0.6375760113115532, 0.37669391627624127, 0.5662969320908695, 0.2245319436146267, 0.23195759115792625, 0.13932774807174597, 0.12095056516881597, 0.1947785784463435, 0.1980683465791151, 0.20221934469389913, 0.19193261816580265, 0.256055376304988, 0.20397180740414755, 0.20612904008100064, 0.21129551288892556, 0.11643336171720797, 0.20810723276177956, 0.23776192789576012, 0.19883311331817, 0.25720752050805895, 0.2507886644677606, 0.21382170780991605, 0.25739383749036393, 0.006309616302559329, 0.0003407137397345439, 9.999999999998899e-05, 0.013567422972583287, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0875928678973178, 0.040018526499390084, 0.05529070098849842, 0.061576159604076586, 0.004563522910143392, 0.023128167645673825, 0.04860369427426681, 0.05442214353699759, 0.05160262033667673, 0.03333840843884228, 0.03206765454124105, 0.2123750363316259, 0.19094572672301546, 0.29898544212976164, 0.08835428410745172, 0.09348247840328039, 0.09016988859379593, 0.08787886746801343, 0.13330482275504707, 9.999999999998899e-05, 0.0575254629609353, 0.4087667906596604, 0.15459209224285897, 0.16341738666111905, 0.23105485238168055, 0.08016685586186378, 0.14064684737966804, 0.5054269605052821, 0.5563069425076299, 0.551516695133986, 0.5071522127141552, 0.5280893639451725, 0.5687323266084054, 0.5804911308009577, 0.532615323634141, 0.5576353390552538, 0.09557253045703706, 0.09356846694430132, 0.09617330755073905, 0.12415424362221694, 0.10058895989486993, 0.15582694808331998, 0.5194549538199267, 0.141895785983301, 0.1064180028924544, 0.3527897410471831, 0.23088912661962635, 0.20942558872597716, 0.18028588216205554, 0.16807130212078158, 0.3369659072154435, 0.26331298882058485, 0.21048599667950707, 0.3906858489602406, 0.3636802781120395, 0.2463404469694488, 0.40696408793728, 0.5183264130114135, 0.37380030574652423, 0.3350442133032665, 0.474801127708675, 0.5085174786515119, 0.5034826350465341, 0.37848033271944537, 0.17006479466512991, 0.3061538606631945, 0.25086817339396006, 0.20207272795270304, 0.3136093126003878, 0.2296436706009508, 0.23345885916060205, 0.21535021567684132, 0.23110795176745835, 0.19163854751023457, 0.20004259103028443, 0.20173185043592456, 0.22159133640853712, 0.20130339844920409, 0.24230649233313784, 0.21279194360306952, 0.22563249138905583, 0.24298340475830804, 0.24417692919218104, 0.22044398748113814, 0.22278751098610727, 0.24689943552277316, 0.21695487967015448, 0.243167960921696, 0.7073744977056169, 0.19322001933386213, 0.12684395588444752, 0.872934549264007, 0.15260540192827154, 0.8470783854577891, 0.7457469272801204, 0.1983266579692612, 0.14152982059971242, 0.16879368885917523, 0.8662333823841213, 0.6865999436543693, 0.1690919975970936, 0.20209176281590013, 0.6365828243392752, 0.4990521818531308, 0.4498687612545986, 0.11275281087037892, 0.104583443419076, 0.6889274914580292, 0.188707413305521, 0.18768631038139516, 0.18711153085641785, 0.1964128579191785, 0.1848995445187197, 0.18353731205452384, 0.19274732617768453, 0.19751774166559877, 0.19476158709052904, 0.09198154644897838, 0.09658790766121417, 0.09474635358958639, 0.0844649704190581, 0.08947295214502449, 0.0873514062794093, 0.0928323246767423, 0.08264388009436119, 0.09685428586558786]}, "mutation_prompt": null}
{"id": "dce2b8c1-28d3-4bf0-83c3-653c08ab1ede", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.8\n        self.cr = 0.9\n        self.w = 0.4\n        self.c1 = 2.0\n        self.c2 = 1.5\n        self.iter_count = 0  # Track iterations\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        chaotic_seq = np.random.rand(self.budget)  # Pre-compute chaotic sequence\n\n        while budget_used < self.budget:\n            # Dynamic adjustment of DE parameters\n            self.f = 0.5 + 0.5 * chaotic_seq[self.iter_count % self.budget]\n            self.cr = 0.6 + 0.4 * chaotic_seq[(self.iter_count * 2) % self.budget]\n            self.iter_count += 1\n            \n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = (self.w * velocities \n                         + self.c1 * r1 * (personal_best - population) \n                         + self.c2 * r2 * (global_best - population))\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "HybridDEPSO", "description": "Introducing adaptive parameter control and chaotic sequences for enhanced diversity and convergence in the HybridDEPSO algorithm.", "configspace": "", "generation": 27, "fitness": 0.3016400742329387, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "654e364f-c1b7-4995-95d6-bbd470de5653", "metadata": {"aucs": [0.8461015845686897, 0.817881041399199, 0.8527198926184735, 0.8504016093115467, 0.84128938605042, 0.8419539750288377, 0.8475925235770063, 0.8483620073906506, 0.8401331481702867, 0.6548967599854355, 0.03989490416774499, 0.683825656110648, 0.6730091637402741, 0.6835259028850953, 0.6837167706447422, 0.05182789145679634, 0.6607386962503077, 0.6671158470821836, 0.16931164076137117, 0.1636915618549758, 0.11343907943219134, 0.1491876177038901, 0.1460591428412914, 0.16635894771439907, 0.13129868649606946, 0.14167968471898673, 0.15722336205541942, 0.14887193333759774, 0.1057995689788016, 0.10804734373141, 0.12573589803743712, 0.14578789558643768, 0.1218021115587028, 0.16685262776669574, 0.13094893966445909, 0.1479943152515374, 0.9741037982443801, 0.9690497689548864, 0.976440241508499, 0.9734650024172987, 0.9595570151783702, 0.9697974975511117, 0.9757594014027642, 0.9756066035814965, 0.9577797861002032, 0.5558264119869771, 0.5836016200541156, 0.39165301773955996, 0.6086006696350501, 0.5742031348299259, 0.5574196085218185, 0.5318555538726585, 0.5322863703883359, 0.5491166953147892, 0.7614917917536119, 0.22042316692721953, 0.22571303443694846, 0.21977977175691354, 0.7831273373540115, 0.27377107850765103, 0.12353739405709208, 0.6740521012360926, 0.7828351234283717, 0.1862092216226059, 0.10984723471187352, 0.2066873093731647, 0.12542480015065538, 0.209790410520459, 0.1256790363627942, 0.19987052359950375, 0.2156640526962812, 0.1841979207504919, 0.22091862395402906, 0.22488342732044697, 0.22818192022644768, 0.194388644359476, 0.22885869647268897, 0.2493417919979547, 0.12751180309212773, 0.22942260247287327, 0.22281236697362972, 9.999999999998899e-05, 9.999999999998899e-05, 0.04775963147919249, 0.016828556368356673, 9.999999999998899e-05, 9.999999999998899e-05, 0.0020680723959493053, 0.007511028515018392, 0.004875198315054563, 0.05858747156475097, 0.047016435597221795, 0.10416158996230951, 0.022404375778024233, 0.021291474604111515, 0.03191076627050138, 0.1350653124683786, 0.12252307875388813, 0.06890634629858938, 0.045666457453339304, 0.12871609856812372, 0.10729277749961874, 0.1556188456289176, 0.08421728215952351, 0.08843118065105937, 0.14658391927742764, 0.2052946991496304, 0.10801183390558822, 0.08438905120510864, 0.27047121469334257, 0.09848610330342511, 0.10502854177793053, 0.07050650325537611, 0.355702058106216, 0.05567812833224761, 0.08233657106899539, 0.11524774207398791, 0.5977424417498836, 0.5140062436130574, 0.5501079747323987, 0.5451656934754727, 0.5014504582211188, 0.567084368741184, 0.5968807528577276, 0.5588769458193374, 0.5678178323501935, 0.11285211446528576, 0.10703020193395296, 0.10515581990262357, 0.10525254629580172, 0.1328775371420714, 0.1413789554798377, 0.17669893327379227, 0.10231528067608375, 0.1397685085103072, 0.16587204963503532, 0.19513102702570118, 0.33333934250031705, 0.14134441656100694, 0.30300762020593275, 0.26445651406652193, 0.2786481878483177, 0.16535507339386535, 0.1766588587268101, 0.426509904299897, 0.3757501715128687, 0.478108511336817, 0.4933817130963556, 0.4728487958576053, 0.24049433656475627, 0.541582766822323, 0.542360357538052, 0.2575102268292808, 0.2233325817194527, 0.25413371994071965, 0.30231162457916694, 0.2027625505600662, 0.239556148464657, 0.18985384916285086, 0.22444826887782743, 0.24334898479337586, 0.3146456455326294, 0.21213337522003262, 0.17948764626839275, 0.2387668065071369, 0.2572861138773992, 0.21611574262999556, 0.19190915317071033, 0.2109101260723747, 0.21809842445121164, 0.22242659059410463, 0.20568340166576204, 0.22464594351678346, 0.21494291527550702, 0.218807241619568, 0.22101194997325713, 0.20410564331638015, 0.2384548099328253, 0.4583722928183308, 0.21541397704053544, 0.8511204293433139, 0.18418780490491005, 0.1521974412903826, 0.16577829085558693, 0.20007096061688912, 0.16870013244607363, 0.1422129129225772, 0.16203387541504033, 0.16614989936493407, 0.7238563123248967, 0.21073905837655882, 0.11099156241961228, 0.5192818759254765, 0.21092730406318194, 0.15530387489265285, 0.10441536634706428, 0.10444959435715628, 0.7794077445480914, 0.1817756078442777, 0.18000167883946838, 0.17730138891889657, 0.1983039756556444, 0.19905916831787884, 0.18387246338443997, 0.2055985536194005, 0.19845720440892212, 0.22505562137826762, 0.08524850986436705, 0.12888420808099255, 0.09193305047676292, 0.10141101316722001, 0.0884352687805724, 0.13933866128956085, 0.07873231404646663, 0.08342732939828568, 0.08319871797740508]}, "mutation_prompt": null}
{"id": "2785e243-6e6d-41b3-8b07-4209813dd3e8", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))  # Adjusted population size\n        self.f = 0.5  # Adaptive DE scaling factor initialized\n        self.cr = 0.9  # Increased crossover probability\n        self.w = 0.9  # Dynamic inertia weight for PSO\n        self.c1 = 2.0  # Increased cognitive coefficient\n        self.c2 = 1.5  # Social coefficient remains unchanged\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.zeros((self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n                self.f = 0.5 + 0.5 * (personal_best_fitness[i] - trial_fitness) / abs(personal_best_fitness[i] + 1e-10)\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.w = 0.4 + 0.5 * np.exp(-2 * (budget_used / self.budget))  # Dynamic inertia\n            velocities = (self.w * velocities \n                         + self.c1 * r1 * (personal_best - population) \n                         + self.c2 * r2 * (global_best - population))\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "HybridDEPSO", "description": "Introducing an adaptive mutation strategy and dynamic inertia weight adjustment to improve convergence in HybridDEPSO.", "configspace": "", "generation": 28, "fitness": 0.23421942586151126, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.22.", "error": "", "parent_id": "654e364f-c1b7-4995-95d6-bbd470de5653", "metadata": {"aucs": [0.5913818066482777, 0.5791556384302903, 0.5959068510741973, 0.6285702929899671, 0.6424633868114593, 0.676165415502383, 0.6357106047419474, 0.609815774565645, 0.6233101968288952, 0.23785913075028853, 0.22749544375474606, 0.2191779518444601, 0.04388173800922546, 0.04083764331813622, 0.1929339471125039, 0.2452601626843175, 0.039029981428239435, 0.215134467317885, 0.10181520178120496, 0.11705006168541277, 0.1214875403783382, 0.09741548701390657, 0.10597883025050958, 0.1330571774376853, 0.13368978550452337, 0.11444356181037108, 0.12426382575060213, 0.11145008485755592, 0.12789232869642841, 0.0915494820366215, 0.10848858805353279, 0.08772366237147944, 0.09371010727128326, 0.09800665373297546, 0.08946349124116093, 0.09788072394871394, 0.9713442004491767, 0.9757645002768286, 0.9747092621878348, 0.9717780713101936, 0.9793267893495453, 0.9649651251063056, 0.9726689995360223, 0.9808081969357106, 0.9718769860620662, 0.2768538504505679, 0.25907456588522615, 0.2944021155422686, 0.13763297955446285, 0.20173121962097207, 0.14400381753790792, 0.08702748057111243, 0.3021189918227378, 0.29163240784674027, 0.6245364331308898, 0.5958691891239545, 0.21091474614762973, 0.25790405054493903, 0.5619174623998457, 0.32040382784186483, 0.21693370471119255, 0.30507174017747607, 0.2512479574020676, 0.1822316085538831, 0.09757361212737437, 0.2304331160257137, 0.15660927016238124, 0.10947138083672947, 0.10923268560920218, 0.24287063464015857, 0.14068905466324955, 0.17378958181764226, 0.1747527810998456, 0.10150742793187695, 0.1428032452747411, 0.142752345459485, 0.12641825467608359, 0.13590029771526424, 0.10861802400117193, 0.0640171668140892, 0.08895180385978696, 9.999999999998899e-05, 0.0072325274253971505, 9.999999999998899e-05, 0.02735212421872313, 9.999999999998899e-05, 9.999999999998899e-05, 0.019904173456280483, 9.999999999998899e-05, 0.00725680390548622, 0.06099047147465375, 0.025634050300443634, 0.05684540724361009, 0.10232377170445106, 0.07603577470891709, 0.058165124421693304, 0.028115865813284624, 0.009183076700747583, 0.01601726245752433, 0.012189520402791088, 0.01432809856275219, 0.042949228355231406, 0.047208932929175496, 0.03925945207525494, 0.05527824096309597, 0.05254824076546849, 0.05921358426890333, 0.038143413368790235, 0.0890660698668928, 0.06984643587801054, 0.19157998606209314, 0.0065777908628853465, 0.08762973332466395, 0.19384382049796534, 0.04491669995645586, 0.06052171723246791, 0.0640106914873797, 0.44650088886159833, 0.43039998185556394, 0.4414285008104565, 0.45331052029252183, 0.44282611697445107, 0.46270266492721845, 0.45418703524291126, 0.451030119138243, 0.46822339802240065, 0.07968995595178696, 0.10049317244486156, 0.09233348993208834, 0.09936030245994298, 0.11055243765888334, 0.19604885969318508, 0.09572200941189712, 0.09799991268320007, 0.09091019091123287, 0.22842951334530892, 0.22867167319733683, 0.2201410407615234, 0.30136624365985953, 0.23090675717438125, 0.18453372464141615, 0.33618245909872946, 0.18436137749307202, 0.25521690765270166, 0.3495986054473932, 0.34934590599147064, 0.2785897031977428, 0.32739010801537705, 0.31681952053768936, 0.3248957477027433, 0.36678401339465605, 0.3548412111332948, 0.36503868899130043, 0.2613582094043384, 0.20823208593421905, 0.23228646607857173, 0.2518330322260791, 0.22140360443087204, 0.2591971075621877, 0.23962770458763705, 0.17782231759207623, 0.23683941039767475, 0.19892736042139136, 0.19449290290037202, 0.18940891685713135, 0.19714689745489178, 0.18710262879533768, 0.1882201680653277, 0.19989736110137624, 0.18267633081867585, 0.18442258217437113, 0.2069410385014535, 0.19903860921994843, 0.1891182798227683, 0.1941444108618784, 0.1988653731190786, 0.19565141972649358, 0.17918549772250447, 0.19697196845800813, 0.19065972223656624, 0.7069880024755939, 0.16198521541072863, 0.19315085719299507, 0.7218804992794394, 0.19762267638068287, 0.5056439787154214, 0.14100252155143334, 0.1670073045408732, 0.168073461631972, 0.4523320380780279, 0.2069894227031398, 0.14942509695574913, 0.4008730709414551, 0.1453390443011825, 0.15259301020605975, 0.2078586486172519, 0.2083470245038498, 0.1847403018981828, 0.19164177794703696, 0.1921134856282568, 0.1856424750566703, 0.17606240234834458, 0.19667033340524454, 0.18424370502380338, 0.18879396596682751, 0.18360510038170774, 0.1874103445531652, 0.07898601896595048, 0.07736633023124562, 0.11142933034726599, 0.08551968204147176, 0.08664471273602392, 0.07902536649815972, 0.07809657227351308, 0.08160343278137494, 0.0811185282157798]}, "mutation_prompt": null}
{"id": "5cffdc24-c79a-4027-933f-d3ab0455a8d3", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = 0.4\n        self.c1 = 2.0\n        self.c2 = 1.5\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "A hybrid algorithm blending DE and PSO with adaptive mutation strategy and velocity clamping for enhanced convergence and diversity.", "configspace": "", "generation": 29, "fitness": 0.32339373644920044, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "654e364f-c1b7-4995-95d6-bbd470de5653", "metadata": {"aucs": [0.8663894624309121, 0.8658012229388158, 0.8661528021745976, 0.8586228099286441, 0.8648093805719617, 0.8556301161544284, 0.8654521329077659, 0.8669039728225536, 0.8749261013633505, 0.7422126132989326, 0.7148586516064801, 0.7152684130891758, 0.7041028326772641, 0.7060004019009218, 0.6815726146662209, 0.6915240564883898, 0.6775629583707989, 0.6738187125955629, 0.1103085570771718, 0.18297461247508773, 0.15109602381588572, 0.15244640866801018, 0.1189252176548733, 0.1130802045983621, 0.11937760287315413, 0.14646611585183167, 0.12225276287875053, 0.18072031690173096, 0.1088417656577958, 0.14159548963362245, 0.13387091663099904, 0.1142898339818883, 0.08941605069442682, 0.13503427558710812, 0.1372277051625984, 0.10841102876876108, 0.9557350390722396, 0.9563270502703295, 0.9551792730462396, 0.9246066191177164, 0.9451837335813965, 0.9231091887031462, 0.9450388841815119, 0.9519086322383847, 0.9557618928457144, 0.5549863226200631, 0.6149825997830911, 0.5929941705391057, 0.6265752550905291, 0.610253571382019, 0.6490799873777237, 0.5946391465979857, 0.5597635243785605, 0.5902849221319537, 0.8336816542961284, 0.22833827909897186, 0.17053073775819683, 0.27788694284294047, 0.19317971380019228, 0.27880137756365386, 0.2335604706608474, 0.2430760046478777, 0.22067940237598793, 0.13430011142003406, 0.18932321525368545, 0.20143500252666813, 0.18490256297013674, 0.1933893707485993, 0.17672468041909528, 0.17905089391135331, 0.25627601371572906, 0.21165019073152536, 0.2267957531143303, 0.1930752021976645, 0.22936690709952468, 0.19359906783542302, 0.1621800478209542, 0.23654770933456892, 0.16603595540941474, 0.14842726029219888, 0.17749710606390312, 0.05117828704458993, 0.061742143856876486, 0.0004973303577575638, 0.05003751496819242, 9.999999999998899e-05, 0.008914844181407866, 0.014901434486843002, 9.999999999998899e-05, 0.0021291064895166967, 0.09765028356242966, 0.20087974028030642, 0.11254723473811046, 0.08089374869090893, 0.07130867126860707, 0.08120735135232826, 0.06410054123183961, 0.12542194428511833, 0.14383339563967312, 0.11880311752106754, 0.05720400398726344, 0.11943041537935895, 0.1185383932228451, 0.10343308793304407, 0.3225186860827529, 0.0963650483763866, 0.3039587706816085, 0.0936567432733606, 0.1854412800373756, 0.13498791914891406, 0.1755767274912925, 0.10408723440538559, 0.04135430710342958, 0.13315739234977841, 0.14718106801412445, 0.10024413096213525, 0.08198520135077902, 0.5678178066785194, 0.51849717289344, 0.5218720993924234, 0.5529077856321603, 0.543542511854904, 0.5774009569256447, 0.5793373976232661, 0.5980265923556152, 0.592513553895978, 0.11990570746315499, 0.14303574903874927, 0.12852617323878002, 0.10775752035702735, 0.15152507428642237, 0.1765637930221544, 0.13788461617642678, 0.09858974028858358, 0.15798973614876266, 0.1809532178375749, 0.20291741910285244, 0.3628644599837674, 0.22991275777113973, 0.23243359631158755, 0.25489938654650146, 0.20818580407552822, 0.23272315112528918, 0.20933906509056155, 0.3496402162069485, 0.40113744240615656, 0.32537079914848, 0.4265536023235281, 0.5256443149496921, 0.46966945532993043, 0.33109285546228273, 0.5930764373774111, 0.3664740675975089, 0.24612998344670756, 0.3263306591633154, 0.2666835116449644, 0.24581509852944727, 0.32430281590954646, 0.28181716856039296, 0.3815750736389327, 0.47251957508845066, 0.21601296866627462, 0.2206159936445673, 0.23121183302368586, 0.23068739269752792, 0.25379887933044576, 0.2691548778689199, 0.20351405670159328, 0.20357321119807847, 0.1999536343343521, 0.2309003507148496, 0.22411817372964837, 0.22194078923575622, 0.1840194741436456, 0.18667533202982323, 0.1915743152378132, 0.2217392801523289, 0.22411380615400545, 0.2059247123111908, 0.19258412839617267, 0.16784369943168675, 0.19953992780121754, 0.18652679414020756, 0.902905944313183, 0.19913907920696705, 0.8730540438467387, 0.16971082622311662, 0.15236614458347264, 0.8926857318762406, 0.6208093895999642, 0.21157050432608404, 0.7157249171297029, 0.8727216036158011, 0.7108569298776647, 0.15533261461381875, 0.16744117010502102, 0.10406796436526566, 0.8886507064490605, 0.19453367465922433, 0.20252241978775753, 0.19537681072656143, 0.20328843501909444, 0.22544863611418897, 0.19390215198151706, 0.2016059702586286, 0.18045278867883296, 0.18746661288917044, 0.0996081071557936, 0.09478611929860403, 0.08817989551481586, 0.13520299326132645, 0.09813606111365247, 0.09747460331221847, 0.09845638122577727, 0.10826098343889112, 0.11349461409329231]}, "mutation_prompt": null}
{"id": "d90394d9-b21d-4321-a320-4855d8e1f2d8", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5\n        self.cr = 0.9\n        self.w = 0.9  # Adjusted inertia weight for better balance\n        self.c1 = 2.0\n        self.c2 = 1.5\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization with adaptive inertia weight\n            self.w = 0.4 + 0.5 * (1 - budget_used / self.budget)  # Adaptive inertia weight\n            \n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n            # Elite opposition-based learning\n            if budget_used < self.budget:\n                opposition_population = self.lower_bound + self.upper_bound - global_best\n                opposition_fitness = func(opposition_population)\n                budget_used += 1\n                if opposition_fitness < personal_best_fitness[global_best_idx]:\n                    global_best = opposition_population\n                    global_best_idx = np.argmin(personal_best_fitness)\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "A refined hybrid DE-PSO algorithm incorporating adaptive inertia weight and elite opposition-based learning for improved exploration and exploitation.", "configspace": "", "generation": 30, "fitness": 0.2496411424880226, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "5cffdc24-c79a-4027-933f-d3ab0455a8d3", "metadata": {"aucs": [0.5642748904726458, 0.5323494419682436, 0.582651066947416, 0.6016418164955166, 0.578618693280194, 0.5784130118148547, 0.565574198157607, 0.5428153731069276, 0.5730889356312748, 0.18286807073388545, 0.08761506213606585, 0.22558116294840225, 0.2130720688430533, 0.25847115659168385, 0.20719488387191332, 0.21053606012916792, 0.20407079574962794, 0.19316002024148793, 0.11196304274357916, 0.107138073970517, 0.11230318695457242, 0.11813323266561493, 0.11920151356426634, 0.1089664594398071, 0.15189663928996633, 0.1311316760129987, 0.13434846734324146, 0.10632734124063059, 0.117278403044482, 0.10454644366008126, 0.10222901282982344, 0.11596697273531098, 0.0947513040623944, 0.11463662311782175, 0.13155937480545654, 0.10236334573394956, 0.9635759900886902, 0.9562670803282413, 0.9612283517766408, 0.9642132783964624, 0.9358291920801988, 0.9541129686359953, 0.9628406466309302, 0.9541166310408085, 0.9634215684021298, 0.28301169008958116, 0.3206170520731022, 0.29779638482124815, 0.325706552933403, 0.30187145991824704, 0.3092510279147196, 0.2848394846618728, 0.2964639089526018, 0.31440091291495564, 0.5869574224576922, 0.45072534874399506, 0.472878648167504, 0.24461938011094175, 0.20171512978867578, 0.23528890075901676, 0.30409180057504615, 0.32119479281957897, 0.5336685659571362, 0.15282095155968944, 0.1488442231540794, 0.14897168851754794, 0.12199574979884087, 0.10713660837325256, 0.15148223956942952, 0.14923934421372453, 0.15657987449670052, 0.17354996245955479, 0.16835536024630327, 0.19393810386364996, 0.13163125728870018, 0.12122839825390752, 0.17626948699721667, 0.16555425072962338, 0.1730378703841925, 0.1488032499532126, 0.1686550765837348, 0.029778174044137296, 0.00834223478720919, 0.005918137229985798, 0.02353424989797981, 9.999999999998899e-05, 0.00010931977019479344, 0.004080157972802367, 0.0003680165622795828, 0.01777188935670493, 0.0840112887039477, 0.06454762544464687, 0.07359724094631126, 0.04035005593942931, 0.09063029821943347, 0.06898329377056123, 0.04900053114820513, 0.06823407478106569, 0.08151607262100902, 0.04069021033667741, 0.0942421160554422, 0.02512821997413861, 0.052916916595629804, 0.03515044408696488, 0.10012486940338516, 0.04108998947015641, 0.04401113341616569, 0.044307581018473874, 0.17132369163441274, 0.1696714051090472, 0.09761596464061151, 0.1007838210574653, 0.08952397935978429, 0.0855306715087425, 0.04833717908236468, 0.06293977582262344, 0.06656566549597887, 0.43926897897269446, 0.45906819304369906, 0.43911210850751625, 0.4410435443660825, 0.4203079462134631, 0.454893612949965, 0.4534046925783951, 0.4458409822073113, 0.4605300025413175, 0.1299420267753698, 0.12288571688543926, 0.1081934034058093, 0.09900678546325126, 0.10695244000699733, 0.10801664536496991, 0.10630566793387208, 0.11247261235520234, 0.11978074298315222, 0.18366793668728643, 0.15355944814490707, 0.19770535484418628, 0.15636977864089407, 0.3067884730584217, 0.20845760049729678, 0.15147613379819835, 0.1943880973773241, 0.16557296592295623, 0.33344468890867074, 0.2713167638704319, 0.3184949077551471, 0.30836860477150485, 0.29134247710241756, 0.29372612196456493, 0.29710163593149563, 0.33992797092233873, 0.33489190682183456, 0.19578883186165885, 0.26174690067003203, 0.2264070338597316, 0.2316498555927401, 0.21879623115745683, 0.23237862994948744, 0.21953186738052388, 0.21866374809149125, 0.2669740885147024, 0.20324223014384235, 0.2309611808385893, 0.21932678273069628, 0.20817858189280092, 0.2190599080885477, 0.2248384881944645, 0.20428572827247893, 0.21485788069278922, 0.21878336783210683, 0.2254481813342274, 0.24624709427458846, 0.1956563702339721, 0.2762444759370264, 0.20752941171287564, 0.194524999311946, 0.214793734210303, 0.1843740411222956, 0.20423160141540908, 0.6866166113595749, 0.19686823764055095, 0.15213704778005122, 0.7341985608718912, 0.19562636225099705, 0.7193725760607541, 0.1685465984687844, 0.17353607873465404, 0.656528789232139, 0.6047241267932536, 0.21067639402819927, 0.46954581311747856, 0.6348814565150949, 0.4663069708205112, 0.41144852493422646, 0.16494859545097385, 0.206053850747957, 0.510882912131077, 0.18673493479053238, 0.20555779315539013, 0.18465895167720714, 0.19044974030799944, 0.19677266314164898, 0.1860349595104549, 0.20464306789509745, 0.20474894134904487, 0.17971888675674585, 0.08383718770144111, 0.0919153806426597, 0.08942553380561835, 0.08399433964067815, 0.09137679002503796, 0.08507222455151753, 0.08701082129598203, 0.09220553738872317, 0.0909193168665432]}, "mutation_prompt": null}
{"id": "8a3cfd41-6d7b-44d4-99c3-390b71e91c9c", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = 0.4\n        self.c1 = 2.0\n        self.c2 = 1.5\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "A hybrid algorithm blending DE and PSO with adaptive mutation strategy and velocity clamping for enhanced convergence and diversity.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5cffdc24-c79a-4027-933f-d3ab0455a8d3", "metadata": {"aucs": [0.8663894624309121, 0.8658012229388158, 0.8661528021745976, 0.8586228099286441, 0.8648093805719617, 0.8556301161544284, 0.8654521329077659, 0.8669039728225536, 0.8749261013633505, 0.7422126132989326, 0.7148586516064801, 0.7152684130891758, 0.7041028326772641, 0.7060004019009218, 0.6815726146662209, 0.6915240564883898, 0.6775629583707989, 0.6738187125955629, 0.1103085570771718, 0.18297461247508773, 0.15109602381588572, 0.15244640866801018, 0.1189252176548733, 0.1130802045983621, 0.11937760287315413, 0.14646611585183167, 0.12225276287875053, 0.18072031690173096, 0.1088417656577958, 0.14159548963362245, 0.13387091663099904, 0.1142898339818883, 0.08941605069442682, 0.13503427558710812, 0.1372277051625984, 0.10841102876876108, 0.9557350390722396, 0.9563270502703295, 0.9551792730462396, 0.9246066191177164, 0.9451837335813965, 0.9231091887031462, 0.9450388841815119, 0.9519086322383847, 0.9557618928457144, 0.5549863226200631, 0.6149825997830911, 0.5929941705391057, 0.6265752550905291, 0.610253571382019, 0.6490799873777237, 0.5946391465979857, 0.5597635243785605, 0.5902849221319537, 0.8336816542961284, 0.22833827909897186, 0.17053073775819683, 0.27788694284294047, 0.19317971380019228, 0.27880137756365386, 0.2335604706608474, 0.2430760046478777, 0.22067940237598793, 0.13430011142003406, 0.18932321525368545, 0.20143500252666813, 0.18490256297013674, 0.1933893707485993, 0.17672468041909528, 0.17905089391135331, 0.25627601371572906, 0.21165019073152536, 0.2267957531143303, 0.1930752021976645, 0.22936690709952468, 0.19359906783542302, 0.1621800478209542, 0.23654770933456892, 0.16603595540941474, 0.14842726029219888, 0.17749710606390312, 0.05117828704458993, 0.061742143856876486, 0.0004973303577575638, 0.05003751496819242, 9.999999999998899e-05, 0.008914844181407866, 0.014901434486843002, 9.999999999998899e-05, 0.0021291064895166967, 0.09765028356242966, 0.20087974028030642, 0.11254723473811046, 0.08089374869090893, 0.07130867126860707, 0.08120735135232826, 0.06410054123183961, 0.12542194428511833, 0.14383339563967312, 0.11880311752106754, 0.05720400398726344, 0.11943041537935895, 0.1185383932228451, 0.10343308793304407, 0.3225186860827529, 0.0963650483763866, 0.3039587706816085, 0.0936567432733606, 0.1854412800373756, 0.13498791914891406, 0.1755767274912925, 0.10408723440538559, 0.04135430710342958, 0.13315739234977841, 0.14718106801412445, 0.10024413096213525, 0.08198520135077902, 0.5678178066785194, 0.51849717289344, 0.5218720993924234, 0.5529077856321603, 0.543542511854904, 0.5774009569256447, 0.5793373976232661, 0.5980265923556152, 0.592513553895978, 0.11990570746315499, 0.14303574903874927, 0.12852617323878002, 0.10775752035702735, 0.15152507428642237, 0.1765637930221544, 0.13788461617642678, 0.09858974028858358, 0.15798973614876266, 0.1809532178375749, 0.20291741910285244, 0.3628644599837674, 0.22991275777113973, 0.23243359631158755, 0.25489938654650146, 0.20818580407552822, 0.23272315112528918, 0.20933906509056155, 0.3496402162069485, 0.40113744240615656, 0.32537079914848, 0.4265536023235281, 0.5256443149496921, 0.46966945532993043, 0.33109285546228273, 0.5930764373774111, 0.3664740675975089, 0.24612998344670756, 0.3263306591633154, 0.2666835116449644, 0.24581509852944727, 0.32430281590954646, 0.28181716856039296, 0.3815750736389327, 0.47251957508845066, 0.21601296866627462, 0.2206159936445673, 0.23121183302368586, 0.23068739269752792, 0.25379887933044576, 0.2691548778689199, 0.20351405670159328, 0.20357321119807847, 0.1999536343343521, 0.2309003507148496, 0.22411817372964837, 0.22194078923575622, 0.1840194741436456, 0.18667533202982323, 0.1915743152378132, 0.2217392801523289, 0.22411380615400545, 0.2059247123111908, 0.19258412839617267, 0.16784369943168675, 0.19953992780121754, 0.18652679414020756, 0.902905944313183, 0.19913907920696705, 0.8730540438467387, 0.16971082622311662, 0.15236614458347264, 0.8926857318762406, 0.6208093895999642, 0.21157050432608404, 0.7157249171297029, 0.8727216036158011, 0.7108569298776647, 0.15533261461381875, 0.16744117010502102, 0.10406796436526566, 0.8886507064490605, 0.19453367465922433, 0.20252241978775753, 0.19537681072656143, 0.20328843501909444, 0.22544863611418897, 0.19390215198151706, 0.2016059702586286, 0.18045278867883296, 0.18746661288917044, 0.0996081071557936, 0.09478611929860403, 0.08817989551481586, 0.13520299326132645, 0.09813606111365247, 0.09747460331221847, 0.09845638122577727, 0.10826098343889112, 0.11349461409329231]}, "mutation_prompt": null}
{"id": "4090e4ad-116a-4bd7-afc2-5076689a466d", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = 0.4\n        self.c1 = 2.0\n        self.c2 = 1.5\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "A hybrid algorithm blending DE and PSO with adaptive mutation strategy and velocity clamping for enhanced convergence and diversity.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5cffdc24-c79a-4027-933f-d3ab0455a8d3", "metadata": {"aucs": [0.8663894624309121, 0.8658012229388158, 0.8661528021745976, 0.8586228099286441, 0.8648093805719617, 0.8556301161544284, 0.8654521329077659, 0.8669039728225536, 0.8749261013633505, 0.7422126132989326, 0.7148586516064801, 0.7152684130891758, 0.7041028326772641, 0.7060004019009218, 0.6815726146662209, 0.6915240564883898, 0.6775629583707989, 0.6738187125955629, 0.1103085570771718, 0.18297461247508773, 0.15109602381588572, 0.15244640866801018, 0.1189252176548733, 0.1130802045983621, 0.11937760287315413, 0.14646611585183167, 0.12225276287875053, 0.18072031690173096, 0.1088417656577958, 0.14159548963362245, 0.13387091663099904, 0.1142898339818883, 0.08941605069442682, 0.13503427558710812, 0.1372277051625984, 0.10841102876876108, 0.9557350390722396, 0.9563270502703295, 0.9551792730462396, 0.9246066191177164, 0.9451837335813965, 0.9231091887031462, 0.9450388841815119, 0.9519086322383847, 0.9557618928457144, 0.5549863226200631, 0.6149825997830911, 0.5929941705391057, 0.6265752550905291, 0.610253571382019, 0.6490799873777237, 0.5946391465979857, 0.5597635243785605, 0.5902849221319537, 0.8336816542961284, 0.22833827909897186, 0.17053073775819683, 0.27788694284294047, 0.19317971380019228, 0.27880137756365386, 0.2335604706608474, 0.2430760046478777, 0.22067940237598793, 0.13430011142003406, 0.18932321525368545, 0.20143500252666813, 0.18490256297013674, 0.1933893707485993, 0.17672468041909528, 0.17905089391135331, 0.25627601371572906, 0.21165019073152536, 0.2267957531143303, 0.1930752021976645, 0.22936690709952468, 0.19359906783542302, 0.1621800478209542, 0.23654770933456892, 0.16603595540941474, 0.14842726029219888, 0.17749710606390312, 0.05117828704458993, 0.061742143856876486, 0.0004973303577575638, 0.05003751496819242, 9.999999999998899e-05, 0.008914844181407866, 0.014901434486843002, 9.999999999998899e-05, 0.0021291064895166967, 0.09765028356242966, 0.20087974028030642, 0.11254723473811046, 0.08089374869090893, 0.07130867126860707, 0.08120735135232826, 0.06410054123183961, 0.12542194428511833, 0.14383339563967312, 0.11880311752106754, 0.05720400398726344, 0.11943041537935895, 0.1185383932228451, 0.10343308793304407, 0.3225186860827529, 0.0963650483763866, 0.3039587706816085, 0.0936567432733606, 0.1854412800373756, 0.13498791914891406, 0.1755767274912925, 0.10408723440538559, 0.04135430710342958, 0.13315739234977841, 0.14718106801412445, 0.10024413096213525, 0.08198520135077902, 0.5678178066785194, 0.51849717289344, 0.5218720993924234, 0.5529077856321603, 0.543542511854904, 0.5774009569256447, 0.5793373976232661, 0.5980265923556152, 0.592513553895978, 0.11990570746315499, 0.14303574903874927, 0.12852617323878002, 0.10775752035702735, 0.15152507428642237, 0.1765637930221544, 0.13788461617642678, 0.09858974028858358, 0.15798973614876266, 0.1809532178375749, 0.20291741910285244, 0.3628644599837674, 0.22991275777113973, 0.23243359631158755, 0.25489938654650146, 0.20818580407552822, 0.23272315112528918, 0.20933906509056155, 0.3496402162069485, 0.40113744240615656, 0.32537079914848, 0.4265536023235281, 0.5256443149496921, 0.46966945532993043, 0.33109285546228273, 0.5930764373774111, 0.3664740675975089, 0.24612998344670756, 0.3263306591633154, 0.2666835116449644, 0.24581509852944727, 0.32430281590954646, 0.28181716856039296, 0.3815750736389327, 0.47251957508845066, 0.21601296866627462, 0.2206159936445673, 0.23121183302368586, 0.23068739269752792, 0.25379887933044576, 0.2691548778689199, 0.20351405670159328, 0.20357321119807847, 0.1999536343343521, 0.2309003507148496, 0.22411817372964837, 0.22194078923575622, 0.1840194741436456, 0.18667533202982323, 0.1915743152378132, 0.2217392801523289, 0.22411380615400545, 0.2059247123111908, 0.19258412839617267, 0.16784369943168675, 0.19953992780121754, 0.18652679414020756, 0.902905944313183, 0.19913907920696705, 0.8730540438467387, 0.16971082622311662, 0.15236614458347264, 0.8926857318762406, 0.6208093895999642, 0.21157050432608404, 0.7157249171297029, 0.8727216036158011, 0.7108569298776647, 0.15533261461381875, 0.16744117010502102, 0.10406796436526566, 0.8886507064490605, 0.19453367465922433, 0.20252241978775753, 0.19537681072656143, 0.20328843501909444, 0.22544863611418897, 0.19390215198151706, 0.2016059702586286, 0.18045278867883296, 0.18746661288917044, 0.0996081071557936, 0.09478611929860403, 0.08817989551481586, 0.13520299326132645, 0.09813606111365247, 0.09747460331221847, 0.09845638122577727, 0.10826098343889112, 0.11349461409329231]}, "mutation_prompt": null}
{"id": "287fba8d-40d5-47ac-8c01-e1a29f771b10", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = 0.4\n        self.c1 = 2.0\n        self.c2 = 1.5\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n        self.niching_radius = 0.1 * (self.upper_bound - self.lower_bound)  # Niching radius\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            self.f = 0.5 + 0.5 * (1 - budget_used / self.budget)  # Dynamic DE scaling factor\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if np.linalg.norm(population[i] - global_best) < self.niching_radius:\n                    continue  # Niching strategy\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Improved hybrid DE and PSO with dynamic parameter adjustment and niching strategy for better convergence and handling multimodality.", "configspace": "", "generation": 33, "fitness": 0.30065587746883554, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "5cffdc24-c79a-4027-933f-d3ab0455a8d3", "metadata": {"aucs": [0.7661077934300008, 0.7724806446389862, 0.7930697541546563, 0.7803626626390421, 0.775507007309744, 0.7707421386187034, 0.7615516565828733, 0.7567004913950128, 0.7571036151512945, 0.6015936206322017, 0.5831985143643141, 0.618783406692958, 0.6267305841564678, 0.5954178076794461, 0.6125623351102625, 0.6347820276795182, 0.5922558456700967, 0.6240257155714469, 0.1278366926607587, 0.15462020020461265, 0.16625145428042343, 0.196403577787302, 0.1497590469562201, 0.13157560014472724, 0.12026654439829088, 0.12778010659257544, 0.13685839098782404, 0.1274867828511269, 0.11247417597517051, 0.11668741506761948, 0.13740112064895316, 0.11575669466754657, 0.12468036438150809, 0.12056100457800545, 0.12221708277889087, 0.13021711277274095, 0.9697770821794135, 0.9610668588988683, 0.9470968714450463, 0.9460715357204539, 0.943997999346548, 0.9538015561115756, 0.9565275417443299, 0.9702082652382528, 0.9635923090588321, 0.4071196181968466, 0.4148429414232323, 0.39875028602183193, 0.40369651513459326, 0.4378892664598639, 0.39847064083747175, 0.37872675503693753, 0.3632026344058852, 0.37897352558508524, 0.31360016846683214, 0.5905158171116247, 0.6588717970731772, 0.7402742776165836, 0.6689949962912446, 0.6684938500239757, 0.54679117745276, 0.6340629620768496, 0.630555209892766, 0.23010401671521818, 0.1746166421354849, 0.18102329704780384, 0.17954566627001312, 0.19767187944079856, 0.21635381346939475, 0.24778740392302856, 0.18386249582780312, 0.17673965498449684, 0.20289435599500727, 0.11641643957200853, 0.19221452365958147, 0.20080942145091718, 0.23843546473155475, 0.12349148218425621, 0.2195785203928151, 0.22057942248256257, 0.12344763855059337, 9.999999999998899e-05, 0.012528755870602093, 0.0012376321145054492, 0.001574740646297923, 9.999999999998899e-05, 9.999999999998899e-05, 0.03869969394342898, 9.999999999998899e-05, 0.005370773414657526, 0.1138672104427616, 0.0667981247043119, 0.1025088921642997, 0.0900646242568619, 0.08530188213522993, 0.05546192035413988, 0.05031558314257856, 0.07035726441565215, 0.06666958107908505, 9.999999999998899e-05, 0.028691980705461195, 0.028361200706508827, 0.06207535399103836, 0.05419286505848886, 0.0894867263179091, 0.10570010708300559, 0.17189569373464297, 0.05700376249063388, 0.12595012619889878, 0.10750660680179369, 0.13888327823197288, 0.15909839650773427, 0.1666361128884951, 0.13156329345291762, 0.12931701632076997, 0.13550325132921504, 0.10528237722007383, 0.4983217710304325, 0.5025561066566926, 0.5231775344228539, 0.4893604515032661, 0.5052510943671082, 0.4850956219756646, 0.49413751294527897, 0.47927743405316614, 0.5165955435067229, 0.09156043360922672, 0.10512469005383551, 0.0989640863029515, 0.0945471678834574, 0.09469315323208283, 0.10315864105743999, 0.09994604606235302, 0.11606525903292297, 0.10000205919224081, 0.3266499694153726, 0.1568156210995214, 0.19000329129851623, 0.12236165573939428, 0.3292467191972188, 0.14176162916192792, 0.18637339233127537, 0.14048367739626788, 0.14426617285550547, 0.38233677562591695, 0.44390649525528203, 0.417727980918288, 0.3722812614929526, 0.41328579418068423, 0.38078861853712476, 0.4256642290517063, 0.4637409095941054, 0.39172917856898504, 0.23929879050804959, 0.21677878195477773, 0.2573105228355459, 0.2708138840898059, 0.20527167798528523, 0.22024029669913703, 0.326915470029955, 0.2631763297749877, 0.20753635477599597, 0.20953915300960668, 0.21028516980383716, 0.2179047827155456, 0.19781645278716087, 0.19211374403120263, 0.21284922111087767, 0.234978493166199, 0.19232256474668263, 0.20159779876563577, 0.541219325931121, 0.21969585803113778, 0.38571864222719965, 0.18914042665704245, 0.19009692790556698, 0.2111145502069336, 0.45934525857345154, 0.22548516640507232, 0.1943852551440518, 0.8127740564712869, 0.7762863460508329, 0.1526626323593573, 0.18440834052992994, 0.1974033098743303, 0.19243877967702916, 0.7909808310213837, 0.17146215050896718, 0.7636493359595637, 0.49254914713946263, 0.2088411576630841, 0.12480772917045868, 0.20718647266032597, 0.20926224739422106, 0.16672707605438264, 0.2109581758493575, 0.15491522908730404, 0.6624166921096848, 0.1925557341053009, 0.18594223101756002, 0.18982423948680238, 0.19156993707761116, 0.18807058062920146, 0.19336978322041154, 0.18148668038504456, 0.1726096653099679, 0.19669630491978118, 0.08990582281113679, 0.08427235690259982, 0.07851501485315515, 0.08655399629997429, 0.07841739697888883, 0.08664521251945223, 0.09184444675042991, 0.09031435592854808, 0.09137877139251926]}, "mutation_prompt": null}
{"id": "e61e0bee-e1f0-46e4-92fa-43bd55070319", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = 0.4\n        self.c1 = 2.0\n        self.c2 = 1.5\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        adapt_rate = 0.1  # Adaptive rate for parameter tuning\n\n        while budget_used < self.budget:\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n            # Adaptive parameter tuning\n            self.f = max(0.1, self.f * (1 - adapt_rate * (budget_used / self.budget)))\n            self.w = max(0.1, self.w * (1 - adapt_rate * (budget_used / self.budget)))\n\n            # Restart mechanism\n            if budget_used % (self.budget // 4) == 0:  # Restart every quarter of the budget\n                idx = np.random.choice(self.pop_size, size=1)\n                population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, (1, self.dim))\n                fitness[idx] = func(population[idx][0])\n                budget_used += 1\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "This version refines EnhancedHybridDEPSO with adaptive parameter tuning and a restart mechanism for improved exploration and convergence on diverse problem landscapes.", "configspace": "", "generation": 34, "fitness": 0.31474720693266606, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.27.", "error": "", "parent_id": "5cffdc24-c79a-4027-933f-d3ab0455a8d3", "metadata": {"aucs": [0.8813290488609262, 0.8771249495691452, 0.8819978347470804, 0.878496026627454, 0.8852916163913926, 0.8686770669148385, 0.8717687382296745, 0.8681125520967891, 0.8730989880107813, 0.24153037054299276, 0.7597181097411183, 0.7605078358539517, 0.7456319133484253, 0.7541845384449355, 0.730144589400686, 0.75271948885851, 0.19277449497503463, 0.759476845980366, 0.11220216190294541, 0.1556706965081196, 0.16922329369853684, 0.15629787238371662, 0.10818689719267227, 0.11299195792831473, 0.14945656579710942, 0.1389237747178258, 0.14089731993599086, 0.13029266943038875, 0.12923697715018512, 0.12990705947175485, 0.1411981731248465, 0.11429138704092578, 0.08622970910295646, 0.13695646453130106, 0.1743119503966143, 0.10330817177993756, 0.9557168336042058, 0.9563187779229736, 0.9551542738802101, 0.9244597506919842, 0.9450763106635375, 0.9230405254876545, 0.9419596257175682, 0.951855946558079, 0.9557484251406636, 0.5904998962421664, 0.5859908965414626, 0.45998429310777045, 0.47711387950128026, 0.7083328670247782, 0.627634643641447, 0.38099141640742984, 0.47231722355198813, 0.5356907137810502, 0.8911624400219947, 0.38571321114783785, 0.3131222665628366, 0.21410615358109997, 0.1931004755969603, 0.2793017382154994, 0.2331559934029651, 0.22911753903682874, 0.2317358175810943, 0.1354965684487739, 0.199138480663817, 0.18554902059829914, 0.1540520896632166, 0.1935546126112785, 0.16940508107128172, 0.16489643542568466, 0.2419387379685488, 0.18297914627789957, 0.13778565170243218, 0.17996514795962393, 0.12208835315946764, 0.18198970692937244, 0.16584631136422812, 0.16289779819223005, 0.15150383970051895, 0.2029331326471171, 0.14348355757409426, 0.013675369723576969, 0.0546984685925368, 9.999999999998899e-05, 0.04586626674451144, 9.999999999998899e-05, 0.01568197175303121, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08160538522070615, 0.16428895259999188, 0.10132400867195579, 0.06843801820749029, 0.09127383372427489, 0.05226272670017529, 0.0675865557999501, 0.15395433064982367, 0.11908143933914439, 0.13970590743068823, 0.0594810928349665, 0.1370996221546329, 0.12035585499210533, 0.07631755444835531, 0.3036039990704297, 0.09817386297179587, 0.284061309296339, 0.09664792086516405, 0.19411235786619374, 0.168292256877712, 0.1641359745769314, 0.10429348996327081, 0.04918566362743948, 0.12995979396157686, 0.15130698896738837, 0.12466034026850681, 0.08352970806484683, 0.5164547431650246, 0.5398732419317424, 0.520727645067967, 0.5535751216792703, 0.5392415123940921, 0.5780377058835515, 0.5862206347333125, 0.5762065214415864, 0.6472922902994714, 0.10225435443335085, 0.1519275186621868, 0.10540435759892064, 0.15163188278672968, 0.099849727060775, 0.17372564434963855, 0.1538658660979636, 0.1062411034931181, 0.15883673898416928, 0.19469407881613854, 0.2044527270220894, 0.19435595369767622, 0.23391695660586254, 0.25762493526657204, 0.32514142966942483, 0.25201236180969855, 0.22340067214086934, 0.31881798152218543, 0.314611345556291, 0.2945799074694123, 0.5792521123508756, 0.3227726740781074, 0.5419170252830612, 0.2763474951189422, 0.35900907684388417, 0.5238516388165946, 0.39888397968560796, 0.29704572287188635, 0.3247394389206587, 0.22159702726571573, 0.2288976918311253, 0.3176546261609505, 0.2983756617521518, 0.28373039608780404, 0.37645316040781474, 0.21961906594590608, 0.21826075275398193, 0.23008662827764637, 0.22060877564096992, 0.2184659797368098, 0.20254369902499636, 0.23496881773547995, 0.2288590388077768, 0.20494814785167248, 0.2244025940721317, 0.22458212388336118, 0.22127253016736026, 0.21654050163663063, 0.1866403237731411, 0.2046116923783523, 0.22250380551387816, 0.22442957233021887, 0.24219896045499567, 0.19094048779579664, 0.16783625256650103, 0.19957294658233182, 0.18654082872304067, 0.9105597610511676, 0.19917665163569265, 0.8714860209233493, 0.16970777424203842, 0.1527058754172247, 0.8840405285503526, 0.48610302147113127, 0.21148859340964943, 0.6135086840416815, 0.8772204248561326, 0.7099504041272511, 0.1553387653104895, 0.1679514709192741, 0.10406382708759954, 0.8606923024835373, 0.19843512794017093, 0.18746900955023516, 0.1938190695521692, 0.18628049664278834, 0.19307949801889346, 0.19700522161114797, 0.1897342488324668, 0.19145561039484404, 0.19417110741538457, 0.10767847085489646, 0.08776117556427032, 0.09326014888755585, 0.08375360077173533, 0.09107316346695937, 0.1016371589022187, 0.09843530013456092, 0.10483270803469424, 0.11435051936204765]}, "mutation_prompt": null}
{"id": "58ac76dc-4d68-4017-87d0-f888ee19e072", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.7  # Adjusted DE scaling factor\n        self.cr = 0.9\n        self.w_max = 0.9  # Added max inertia weight\n        self.w_min = 0.4  # Added min inertia weight\n        self.c1 = 2.0\n        self.c2 = 1.5\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Update inertia weight dynamically\n            self.w = self.w_max - ((self.w_max - self.w_min) * budget_used / self.budget)\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "An enhanced hybrid algorithm integrating DE, PSO, and a dynamic inertia weight strategy to balance exploration and exploitation for improved optimization performance.", "configspace": "", "generation": 35, "fitness": 0.2522269311031113, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "5cffdc24-c79a-4027-933f-d3ab0455a8d3", "metadata": {"aucs": [0.56796969817869, 0.5641185500075564, 0.5690778399731078, 0.5778248250125205, 0.5736852102322726, 0.5669741962741909, 0.549545395161017, 0.5511758141022576, 0.5731427740829341, 0.18802775646857794, 0.22956517289694733, 0.16019880007467946, 0.18803226553212182, 0.21762349156144833, 0.21824280588627554, 0.19410153627489712, 0.21583131022528446, 0.17834357461002115, 0.15762654039913226, 0.11481506464844338, 0.12158133994829567, 0.11169915159879362, 0.15170234786447578, 0.12426476116450758, 0.12665178812432676, 0.09926975373475011, 0.1212682494228875, 0.09033090517108011, 0.15879972615738103, 0.11850563430748784, 0.09754619615687588, 0.0962914721984598, 0.10144588950429645, 0.10961371349898852, 0.09889543953683111, 0.10921902416118023, 0.9691663305628839, 0.9711074729207146, 0.9546884300854098, 0.9595043212264227, 0.9483033494783912, 0.9394259968606062, 0.968667110894982, 0.9622961781830132, 0.9728323549971369, 0.27092000181147535, 0.32963381944804315, 0.31425540528235374, 0.31175340962747045, 0.3178767540511146, 0.30627231088628637, 0.29691319438582164, 0.3027549165437705, 0.29881276987113337, 0.5377062254884941, 0.21955002491174802, 0.5535131656762758, 0.20783830167166661, 0.24667337678269663, 0.1998874302720881, 0.4003220299230381, 0.44657263098384914, 0.30674924098978296, 0.17442166149126914, 0.17431983273754792, 0.1274170860002123, 0.1710898085955902, 0.11928125548423907, 0.15728624979176653, 0.14665481057065521, 0.20530613856363744, 0.14226827857610258, 0.1653802043273891, 0.1460977437181138, 0.17945068594325708, 0.15457799555618135, 0.19060473648456555, 0.14163556816710876, 0.13514467305924593, 0.157206113222764, 0.15704484829534682, 0.02172565820014094, 0.028358925292274573, 9.999999999998899e-05, 9.999999999998899e-05, 0.002213120182219641, 0.034630577020099196, 9.999999999998899e-05, 0.006523103752005377, 9.999999999998899e-05, 0.14004045983262148, 0.11360112597570993, 0.09865513002924364, 0.06203615159960829, 0.12749364248662354, 0.06435377705611478, 0.07160492419006281, 0.145971234808135, 0.09759732352945194, 9.999999999998899e-05, 0.016227819571017266, 0.05980859736051858, 0.0628522739212396, 0.1045425228274709, 0.046344887748971275, 0.04659987795077647, 0.06994766237849748, 0.03251482600746436, 0.105142511081036, 0.07775507282979921, 0.11710542255319323, 0.15249224800468486, 0.09078101548414197, 0.05044080679837204, 0.06617640939448177, 0.04746275797238375, 0.06672932492809469, 0.4481266882016435, 0.4277550666998301, 0.4134525527970482, 0.44836390172289275, 0.4389466111046185, 0.4232205556309494, 0.4322597739562889, 0.4348562678345256, 0.4064240965822582, 0.10928922026803634, 0.10989172700198191, 0.08398787263131091, 0.10758383517249381, 0.11547974233901148, 0.101047797597421, 0.11340504133461671, 0.09816334638963087, 0.0952442669575061, 0.14271377114483386, 0.20285482915958142, 0.19524223560728593, 0.22073191033126371, 0.2508003617264044, 0.17241251305999883, 0.30810050633680197, 0.18054776140319773, 0.21018325828378825, 0.3014170257922222, 0.3345810356605331, 0.28703349677874923, 0.2964091682245783, 0.3131503301690036, 0.2998580011630404, 0.3406701639223586, 0.35405002713309797, 0.3304582287984563, 0.22496450333958495, 0.22343196210786687, 0.22089938786679053, 0.22043840549362437, 0.24016580986145242, 0.23129317014067785, 0.25362870259122694, 0.23265942859051492, 0.2554673287777922, 0.20265109119169478, 0.18474490013208456, 0.23781741860754524, 0.17539082299081543, 0.2213216764348085, 0.22288503073997168, 0.22031039051046042, 0.2131671677494793, 0.2223383733140487, 0.3147291269339444, 0.3123767364471949, 0.20535795755890507, 0.21455524841130447, 0.31031840951388734, 0.1805199903821303, 0.1955186257499475, 0.3046195273693323, 0.19275414311274375, 0.18336258693386676, 0.16813148143538914, 0.14823796510826437, 0.6682440050814232, 0.19523982329483613, 0.6827858739575394, 0.7143710116108166, 0.6550346124835971, 0.7409543781951515, 0.4364921718119623, 0.2085737252153399, 0.5303380701939306, 0.5507860118501247, 0.16655958334255172, 0.15202256914215762, 0.534294358061774, 0.5554664623944305, 0.3417820447731358, 0.20210212083141543, 0.18032876347868387, 0.19335129175620025, 0.19763729918918294, 0.1809904230821171, 0.19046566226285588, 0.19128556047090461, 0.1953828382489421, 0.18477855986455383, 0.08504593867957044, 0.09037875862778888, 0.08017100670721389, 0.07480164273942791, 0.08456525582302765, 0.08390274337711656, 0.08731284641622239, 0.08535398014393336, 0.09702591752839307]}, "mutation_prompt": null}
{"id": "20c59d00-8b04-46a5-9b17-ee7fcf0da6ff", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5\n        self.cr = 0.9\n        self.w = 0.9  # Initial inertia weight for PSO\n        self.c1 = 2.0\n        self.c2 = 1.5\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            self.f = 0.5 + 0.3 * np.sin(2 * np.pi * budget_used / self.budget)  # Adaptive DE scaling factor\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            self.w = 0.9 - 0.5 * (budget_used / self.budget)  # Dynamic inertia weight\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with adaptive DE parameters and dynamic PSO inertia for robust performance.", "configspace": "", "generation": 36, "fitness": 0.2455252031737276, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "5cffdc24-c79a-4027-933f-d3ab0455a8d3", "metadata": {"aucs": [0.5726190169195371, 0.5678260515453776, 0.5702122742828719, 0.5913657738033646, 0.5751232392093706, 0.5690923156386758, 0.6083912873208125, 0.5724162471787725, 0.581580354567045, 0.21791546935359785, 0.13222798027022487, 0.27721108444501996, 0.2211954053863623, 0.21147781142910838, 0.2546510214971709, 0.19620720307143447, 0.02920953198317433, 0.17790370580774728, 0.10293507619897624, 0.1322065009951613, 0.11690556201638524, 0.11760769430630302, 0.10750816517388306, 0.12113397335826626, 0.12635340144570362, 0.1198212555299415, 0.11590371538963595, 0.10541473449293048, 0.09967888085981902, 0.10191088779405377, 0.11218671402506697, 0.10524889262078108, 0.09884282635361163, 0.09881744849290719, 0.11080506925302303, 0.09287749734815698, 0.9641865551845789, 0.9578847103796979, 0.9613630552523899, 0.968751985199886, 0.9439946722577994, 0.9542168617038548, 0.9589600081225654, 0.9616204549798901, 0.9637826163653337, 0.30412371827916473, 0.31872683898836407, 0.32766323539848174, 0.3120728726077766, 0.14417086274292779, 0.14559775911130368, 0.329588626320374, 0.28981178915450745, 0.3105163601095131, 0.22549887541418134, 0.3078149888866344, 0.3032966673124273, 0.4940906645239559, 0.20861273445141804, 0.2924249632074374, 0.22161500511089494, 0.3360090690879636, 0.5558097720555084, 0.15232286031018338, 0.1462652352357693, 0.1469201544998936, 0.17358839910593538, 0.11988686229331946, 0.11452366169111661, 0.14973586133902206, 0.15983430904504348, 0.1512831790131255, 0.12026798953685924, 0.21203212897211554, 0.15072181527370354, 0.1583757756281411, 0.17673592983100994, 0.17744295465078053, 0.17399477445298783, 0.15787656068400924, 0.17249145975608116, 0.01449805574155727, 0.020757628536380412, 0.015122149660205308, 0.0033940160844360134, 9.999999999998899e-05, 0.009722339685082848, 0.014924319302153322, 9.999999999998899e-05, 9.999999999998899e-05, 0.14112819992486925, 0.07338455622354523, 0.12836140610869284, 0.10615910505859716, 0.072600856300984, 0.0475950199413151, 0.16333419683553296, 0.07333812944597617, 0.08107485798850467, 0.06834205639379665, 0.02855417975302954, 0.04158275073040352, 0.03476794779191117, 0.039025200120689774, 0.1048823292034684, 0.047295458908064414, 0.05383694539606787, 0.04408507844311993, 0.08654843152989689, 0.08249511055407766, 0.10166989173656171, 0.15061805284788699, 0.13062958473094755, 0.1286290188706447, 0.04306953658010493, 0.06588670492251825, 0.06757508487502606, 0.4471074131556616, 0.43917369933729844, 0.4529699438036361, 0.43006853594503036, 0.45495596409575967, 0.41840345805030943, 0.43774300710889136, 0.4472903321181533, 0.4287565201599478, 0.10521976443772096, 0.1033197177348737, 0.1055296056202829, 0.0954478887833955, 0.10152111554025411, 0.11136555764111233, 0.2061705296953471, 0.11721031424038353, 0.08384136086943295, 0.16836094999172768, 0.16187919932546624, 0.3072225392566452, 0.18070472061379828, 0.21796518077786298, 0.162571175767796, 0.14870092621827313, 0.15045795985681654, 0.20544399811954972, 0.2937829116329066, 0.31823515606342945, 0.3081417307551746, 0.32581677512605567, 0.340277175250537, 0.28620962753256296, 0.3357286026109666, 0.35643350933493434, 0.31332077267373815, 0.24670358062632292, 0.21671202592992567, 0.24138726812921885, 0.240685195189975, 0.22021614974762183, 0.19849588057238055, 0.27598826651264885, 0.25770540954819954, 0.18214726825352046, 0.2056983765604239, 0.2108176674364749, 0.2065199139733609, 0.2096531878341088, 0.23037716739768221, 0.21926636360908713, 0.2124594924312766, 0.18847258277986245, 0.1992725250554399, 0.19903526122189175, 0.32305431574324894, 0.2609379354859549, 0.2916323704371051, 0.30673197542238273, 0.19170730979057427, 0.20803840963758125, 0.19309367641681896, 0.1938366738321059, 0.18411472093805836, 0.1936500353479349, 0.15050134225018375, 0.7084865493151549, 0.1947977419748551, 0.6923286651363879, 0.16874292109753897, 0.15666410194660496, 0.7078540277117245, 0.5545519236736378, 0.2105850580586045, 0.5066381936099273, 0.4997928401027668, 0.16637680052128612, 0.4074152949488885, 0.1653782630779952, 0.6155597691256605, 0.5528473343702981, 0.20275901245955597, 0.184079198331761, 0.190064795749735, 0.17622984393564312, 0.17988904116111426, 0.18277460339925256, 0.18286231728455793, 0.18809307709470302, 0.1756159346904238, 0.08399994243246911, 0.07812178974267103, 0.08585655613638177, 0.0859978116200042, 0.07966221275000518, 0.08520491421448462, 0.08487436006684401, 0.08732011149524932, 0.09128098781362182]}, "mutation_prompt": null}
{"id": "c2c1ef85-bee9-478d-8e61-0363f6dbd3fc", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5\n        self.cr = 0.9\n        self.w_init = 0.9  # Initial inertia\n        self.w_end = 0.4   # Final inertia\n        self.c1 = 1.5  # Reduced cognitive component\n        self.c2 = 1.7  # Increased social component\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Adaptive inertia weight\n            self.w = self.w_end + (self.w_init - self.w_end) * (self.budget - budget_used) / self.budget\n\n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                # Adaptive crossover rate\n                self.cr = 0.9 - 0.5 * (personal_best_fitness[i] - np.min(personal_best_fitness)) / (np.ptp(personal_best_fitness) + 1e-8)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "An enhanced DE-PSO hybrid with adaptive inertia and crossover rates for improved convergence stability and exploration.", "configspace": "", "generation": 37, "fitness": 0.2602271041105736, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "5cffdc24-c79a-4027-933f-d3ab0455a8d3", "metadata": {"aucs": [0.5855597186750167, 0.5952958497960711, 0.6174136418994698, 0.634064289844553, 0.6024040519336857, 0.6135702786920433, 0.6080126971887141, 0.5875693739650416, 0.5813941425828043, 0.22544488512628913, 0.2548490115615242, 0.2653285309747182, 0.242652446319772, 0.2438651744092052, 0.2835136162369558, 0.20623055186057282, 0.040646514191318595, 0.26146151623867186, 0.09646401345353439, 0.10901724702209759, 0.13106722327859677, 0.12299692381664973, 0.11563621964018689, 0.19040734401184767, 0.13196470812745864, 0.2286834493605655, 0.12384200371720366, 0.10926410416127585, 0.12248989052160375, 0.20531869959481674, 0.1186390971511686, 0.10397366802662056, 0.1248530815900093, 0.10248945539836385, 0.09820464523046013, 0.10888785061401562, 0.9651107271822849, 0.9645476873894916, 0.9553654454658896, 0.9555325694103303, 0.9551475775117068, 0.9370105883179517, 0.953225548288297, 0.9404597382902492, 0.9644632964275097, 0.3157291527959738, 0.35720099018195917, 0.33648777358915294, 0.37214543039366377, 0.34106934600668426, 0.1476134838788581, 0.3482608343453514, 0.3893561927956757, 0.3058260290604027, 0.2555502076890447, 0.5243710264012003, 0.45893541591185893, 0.5668271059844578, 0.3345327599407979, 0.19903296528503134, 0.22134411792934794, 0.4782790223907386, 0.2230719348106286, 0.18315173048240407, 0.16380423820408196, 0.15287214522996506, 0.10486411741479384, 0.16136402228607916, 0.1720767734749532, 0.1689389004304348, 0.15082671319274488, 0.18095986911205963, 0.1858395993583989, 0.1739286727324557, 0.1719457423658357, 0.15004556162384908, 0.2612240031550279, 0.12190293699210974, 0.19055329048487024, 0.19627802625675395, 0.14848657219146189, 0.033775644535315896, 0.03207664638374064, 9.999999999998899e-05, 0.024449539078400306, 0.02651080741601164, 0.01415649560881882, 9.999999999998899e-05, 0.02959044819598311, 0.05363333158306616, 0.10607722593916713, 0.09632450050449914, 0.15952183470798498, 0.058391500545887154, 0.03040644055199737, 0.0320908684565393, 0.14879060415619805, 0.10924668610924415, 0.10198971137559021, 0.13471457180420543, 0.021031504685758207, 0.027658306625630735, 0.041242122590655184, 0.04456045644272566, 0.040714986003034914, 0.04980776908421558, 0.05464031036462169, 0.07796208077950217, 0.10856964907302569, 0.1491332112084126, 0.13152144719499992, 0.03389275794734692, 0.11740523426690619, 0.05210429480797829, 0.08851979242383445, 0.126547545604361, 0.06857839557278966, 0.44835134551410194, 0.4172641362845242, 0.43767230627831577, 0.48025257772584107, 0.4386941792059661, 0.44074106148375647, 0.4782580486231153, 0.475569892249908, 0.47429544403470714, 0.0866588231598836, 0.10213458862062585, 0.12460326317710624, 0.11454335559374862, 0.12079534553495086, 0.11611269399543744, 0.10943056728332035, 0.11017343778765099, 0.1376131154599134, 0.17417278919942203, 0.35551915987873073, 0.19080632113313234, 0.2282561214185116, 0.3230928698755281, 0.18149107382495622, 0.1634621571462318, 0.20751628533207744, 0.20322392602670047, 0.30768708914898, 0.2577904451834109, 0.2658503820592416, 0.3262681693108004, 0.27659121961664856, 0.35383413588309887, 0.34339496556032345, 0.32512378968005373, 0.3285146841471268, 0.2099742148881174, 0.27417458156774044, 0.24365334020560137, 0.2318800773644326, 0.19278210970556242, 0.19338822137685097, 0.20445187727695835, 0.28133042463911007, 0.2660463654129033, 0.22308103206593333, 0.19538648782604473, 0.21029712560870073, 0.23717521249176288, 0.21691926147107132, 0.2300536910474127, 0.22165601428780957, 0.19977374976755258, 0.20630476937390008, 0.3400705844200764, 0.20360831615174668, 0.32746188023010947, 0.20709011457132942, 0.19523983938853107, 0.20202145579099717, 0.20077669161273293, 0.20663718142912335, 0.2130000203624567, 0.18350175317746786, 0.7584005925050084, 0.15298564383514224, 0.7241458064629391, 0.7723482125362169, 0.7189554248395237, 0.17378993212782368, 0.16062160832515515, 0.722960274380845, 0.7084259072593007, 0.20723776118593606, 0.07315639529220275, 0.4341048426793508, 0.16590577561563913, 0.7017958908713697, 0.20732955327703206, 0.1635866311840316, 0.6027232780741927, 0.18735720458248484, 0.18632458858674017, 0.19131568496729356, 0.18686657736860257, 0.19495184889273065, 0.19013741938937057, 0.18345670327572128, 0.19251556124325342, 0.19350220112408734, 0.08414915536103074, 0.07955142339040433, 0.07733783269296579, 0.08795833407973896, 0.08536630284822333, 0.08701999227570667, 0.09133574808056999, 0.08576135941653573, 0.10730433940267359]}, "mutation_prompt": null}
{"id": "17a0e461-54aa-4607-869a-12d0b100f825", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = 0.4\n        self.c1 = 2.0\n        self.c2 = 1.5\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "A hybrid algorithm blending DE and PSO with adaptive mutation strategy and velocity clamping for enhanced convergence and diversity.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5cffdc24-c79a-4027-933f-d3ab0455a8d3", "metadata": {"aucs": [0.8663894624309121, 0.8658012229388158, 0.8661528021745976, 0.8586228099286441, 0.8648093805719617, 0.8556301161544284, 0.8654521329077659, 0.8669039728225536, 0.8749261013633505, 0.7422126132989326, 0.7148586516064801, 0.7152684130891758, 0.7041028326772641, 0.7060004019009218, 0.6815726146662209, 0.6915240564883898, 0.6775629583707989, 0.6738187125955629, 0.1103085570771718, 0.18297461247508773, 0.15109602381588572, 0.15244640866801018, 0.1189252176548733, 0.1130802045983621, 0.11937760287315413, 0.14646611585183167, 0.12225276287875053, 0.18072031690173096, 0.1088417656577958, 0.14159548963362245, 0.13387091663099904, 0.1142898339818883, 0.08941605069442682, 0.13503427558710812, 0.1372277051625984, 0.10841102876876108, 0.9557350390722396, 0.9563270502703295, 0.9551792730462396, 0.9246066191177164, 0.9451837335813965, 0.9231091887031462, 0.9450388841815119, 0.9519086322383847, 0.9557618928457144, 0.5549863226200631, 0.6149825997830911, 0.5929941705391057, 0.6265752550905291, 0.610253571382019, 0.6490799873777237, 0.5946391465979857, 0.5597635243785605, 0.5902849221319537, 0.8336816542961284, 0.22833827909897186, 0.17053073775819683, 0.27788694284294047, 0.19317971380019228, 0.27880137756365386, 0.2335604706608474, 0.2430760046478777, 0.22067940237598793, 0.13430011142003406, 0.18932321525368545, 0.20143500252666813, 0.18490256297013674, 0.1933893707485993, 0.17672468041909528, 0.17905089391135331, 0.25627601371572906, 0.21165019073152536, 0.2267957531143303, 0.1930752021976645, 0.22936690709952468, 0.19359906783542302, 0.1621800478209542, 0.23654770933456892, 0.16603595540941474, 0.14842726029219888, 0.17749710606390312, 0.05117828704458993, 0.061742143856876486, 0.0004973303577575638, 0.05003751496819242, 9.999999999998899e-05, 0.008914844181407866, 0.014901434486843002, 9.999999999998899e-05, 0.0021291064895166967, 0.09765028356242966, 0.20087974028030642, 0.11254723473811046, 0.08089374869090893, 0.07130867126860707, 0.08120735135232826, 0.06410054123183961, 0.12542194428511833, 0.14383339563967312, 0.11880311752106754, 0.05720400398726344, 0.11943041537935895, 0.1185383932228451, 0.10343308793304407, 0.3225186860827529, 0.0963650483763866, 0.3039587706816085, 0.0936567432733606, 0.1854412800373756, 0.13498791914891406, 0.1755767274912925, 0.10408723440538559, 0.04135430710342958, 0.13315739234977841, 0.14718106801412445, 0.10024413096213525, 0.08198520135077902, 0.5678178066785194, 0.51849717289344, 0.5218720993924234, 0.5529077856321603, 0.543542511854904, 0.5774009569256447, 0.5793373976232661, 0.5980265923556152, 0.592513553895978, 0.11990570746315499, 0.14303574903874927, 0.12852617323878002, 0.10775752035702735, 0.15152507428642237, 0.1765637930221544, 0.13788461617642678, 0.09858974028858358, 0.15798973614876266, 0.1809532178375749, 0.20291741910285244, 0.3628644599837674, 0.22991275777113973, 0.23243359631158755, 0.25489938654650146, 0.20818580407552822, 0.23272315112528918, 0.20933906509056155, 0.3496402162069485, 0.40113744240615656, 0.32537079914848, 0.4265536023235281, 0.5256443149496921, 0.46966945532993043, 0.33109285546228273, 0.5930764373774111, 0.3664740675975089, 0.24612998344670756, 0.3263306591633154, 0.2666835116449644, 0.24581509852944727, 0.32430281590954646, 0.28181716856039296, 0.3815750736389327, 0.47251957508845066, 0.21601296866627462, 0.2206159936445673, 0.23121183302368586, 0.23068739269752792, 0.25379887933044576, 0.2691548778689199, 0.20351405670159328, 0.20357321119807847, 0.1999536343343521, 0.2309003507148496, 0.22411817372964837, 0.22194078923575622, 0.1840194741436456, 0.18667533202982323, 0.1915743152378132, 0.2217392801523289, 0.22411380615400545, 0.2059247123111908, 0.19258412839617267, 0.16784369943168675, 0.19953992780121754, 0.18652679414020756, 0.902905944313183, 0.19913907920696705, 0.8730540438467387, 0.16971082622311662, 0.15236614458347264, 0.8926857318762406, 0.6208093895999642, 0.21157050432608404, 0.7157249171297029, 0.8727216036158011, 0.7108569298776647, 0.15533261461381875, 0.16744117010502102, 0.10406796436526566, 0.8886507064490605, 0.19453367465922433, 0.20252241978775753, 0.19537681072656143, 0.20328843501909444, 0.22544863611418897, 0.19390215198151706, 0.2016059702586286, 0.18045278867883296, 0.18746661288917044, 0.0996081071557936, 0.09478611929860403, 0.08817989551481586, 0.13520299326132645, 0.09813606111365247, 0.09747460331221847, 0.09845638122577727, 0.10826098343889112, 0.11349461409329231]}, "mutation_prompt": null}
{"id": "735269c8-b27f-49f3-98d4-695ffa7a6355", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = 0.4\n        self.c1 = 2.0\n        self.c2 = 1.5\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "A hybrid algorithm blending DE and PSO with adaptive mutation strategy and velocity clamping for enhanced convergence and diversity.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5cffdc24-c79a-4027-933f-d3ab0455a8d3", "metadata": {"aucs": [0.8663894624309121, 0.8658012229388158, 0.8661528021745976, 0.8586228099286441, 0.8648093805719617, 0.8556301161544284, 0.8654521329077659, 0.8669039728225536, 0.8749261013633505, 0.7422126132989326, 0.7148586516064801, 0.7152684130891758, 0.7041028326772641, 0.7060004019009218, 0.6815726146662209, 0.6915240564883898, 0.6775629583707989, 0.6738187125955629, 0.1103085570771718, 0.18297461247508773, 0.15109602381588572, 0.15244640866801018, 0.1189252176548733, 0.1130802045983621, 0.11937760287315413, 0.14646611585183167, 0.12225276287875053, 0.18072031690173096, 0.1088417656577958, 0.14159548963362245, 0.13387091663099904, 0.1142898339818883, 0.08941605069442682, 0.13503427558710812, 0.1372277051625984, 0.10841102876876108, 0.9557350390722396, 0.9563270502703295, 0.9551792730462396, 0.9246066191177164, 0.9451837335813965, 0.9231091887031462, 0.9450388841815119, 0.9519086322383847, 0.9557618928457144, 0.5549863226200631, 0.6149825997830911, 0.5929941705391057, 0.6265752550905291, 0.610253571382019, 0.6490799873777237, 0.5946391465979857, 0.5597635243785605, 0.5902849221319537, 0.8336816542961284, 0.22833827909897186, 0.17053073775819683, 0.27788694284294047, 0.19317971380019228, 0.27880137756365386, 0.2335604706608474, 0.2430760046478777, 0.22067940237598793, 0.13430011142003406, 0.18932321525368545, 0.20143500252666813, 0.18490256297013674, 0.1933893707485993, 0.17672468041909528, 0.17905089391135331, 0.25627601371572906, 0.21165019073152536, 0.2267957531143303, 0.1930752021976645, 0.22936690709952468, 0.19359906783542302, 0.1621800478209542, 0.23654770933456892, 0.16603595540941474, 0.14842726029219888, 0.17749710606390312, 0.05117828704458993, 0.061742143856876486, 0.0004973303577575638, 0.05003751496819242, 9.999999999998899e-05, 0.008914844181407866, 0.014901434486843002, 9.999999999998899e-05, 0.0021291064895166967, 0.09765028356242966, 0.20087974028030642, 0.11254723473811046, 0.08089374869090893, 0.07130867126860707, 0.08120735135232826, 0.06410054123183961, 0.12542194428511833, 0.14383339563967312, 0.11880311752106754, 0.05720400398726344, 0.11943041537935895, 0.1185383932228451, 0.10343308793304407, 0.3225186860827529, 0.0963650483763866, 0.3039587706816085, 0.0936567432733606, 0.1854412800373756, 0.13498791914891406, 0.1755767274912925, 0.10408723440538559, 0.04135430710342958, 0.13315739234977841, 0.14718106801412445, 0.10024413096213525, 0.08198520135077902, 0.5678178066785194, 0.51849717289344, 0.5218720993924234, 0.5529077856321603, 0.543542511854904, 0.5774009569256447, 0.5793373976232661, 0.5980265923556152, 0.592513553895978, 0.11990570746315499, 0.14303574903874927, 0.12852617323878002, 0.10775752035702735, 0.15152507428642237, 0.1765637930221544, 0.13788461617642678, 0.09858974028858358, 0.15798973614876266, 0.1809532178375749, 0.20291741910285244, 0.3628644599837674, 0.22991275777113973, 0.23243359631158755, 0.25489938654650146, 0.20818580407552822, 0.23272315112528918, 0.20933906509056155, 0.3496402162069485, 0.40113744240615656, 0.32537079914848, 0.4265536023235281, 0.5256443149496921, 0.46966945532993043, 0.33109285546228273, 0.5930764373774111, 0.3664740675975089, 0.24612998344670756, 0.3263306591633154, 0.2666835116449644, 0.24581509852944727, 0.32430281590954646, 0.28181716856039296, 0.3815750736389327, 0.47251957508845066, 0.21601296866627462, 0.2206159936445673, 0.23121183302368586, 0.23068739269752792, 0.25379887933044576, 0.2691548778689199, 0.20351405670159328, 0.20357321119807847, 0.1999536343343521, 0.2309003507148496, 0.22411817372964837, 0.22194078923575622, 0.1840194741436456, 0.18667533202982323, 0.1915743152378132, 0.2217392801523289, 0.22411380615400545, 0.2059247123111908, 0.19258412839617267, 0.16784369943168675, 0.19953992780121754, 0.18652679414020756, 0.902905944313183, 0.19913907920696705, 0.8730540438467387, 0.16971082622311662, 0.15236614458347264, 0.8926857318762406, 0.6208093895999642, 0.21157050432608404, 0.7157249171297029, 0.8727216036158011, 0.7108569298776647, 0.15533261461381875, 0.16744117010502102, 0.10406796436526566, 0.8886507064490605, 0.19453367465922433, 0.20252241978775753, 0.19537681072656143, 0.20328843501909444, 0.22544863611418897, 0.19390215198151706, 0.2016059702586286, 0.18045278867883296, 0.18746661288917044, 0.0996081071557936, 0.09478611929860403, 0.08817989551481586, 0.13520299326132645, 0.09813606111365247, 0.09747460331221847, 0.09845638122577727, 0.10826098343889112, 0.11349461409329231]}, "mutation_prompt": null}
{"id": "aadde3c8-d7e3-46e4-ac27-165a1d7f7337", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = 0.4\n        self.c1 = 2.0\n        self.c2 = 1.5\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "A hybrid algorithm blending DE and PSO with adaptive mutation strategy and velocity clamping for enhanced convergence and diversity.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5cffdc24-c79a-4027-933f-d3ab0455a8d3", "metadata": {"aucs": [0.8663894624309121, 0.8658012229388158, 0.8661528021745976, 0.8586228099286441, 0.8648093805719617, 0.8556301161544284, 0.8654521329077659, 0.8669039728225536, 0.8749261013633505, 0.7422126132989326, 0.7148586516064801, 0.7152684130891758, 0.7041028326772641, 0.7060004019009218, 0.6815726146662209, 0.6915240564883898, 0.6775629583707989, 0.6738187125955629, 0.1103085570771718, 0.18297461247508773, 0.15109602381588572, 0.15244640866801018, 0.1189252176548733, 0.1130802045983621, 0.11937760287315413, 0.14646611585183167, 0.12225276287875053, 0.18072031690173096, 0.1088417656577958, 0.14159548963362245, 0.13387091663099904, 0.1142898339818883, 0.08941605069442682, 0.13503427558710812, 0.1372277051625984, 0.10841102876876108, 0.9557350390722396, 0.9563270502703295, 0.9551792730462396, 0.9246066191177164, 0.9451837335813965, 0.9231091887031462, 0.9450388841815119, 0.9519086322383847, 0.9557618928457144, 0.5549863226200631, 0.6149825997830911, 0.5929941705391057, 0.6265752550905291, 0.610253571382019, 0.6490799873777237, 0.5946391465979857, 0.5597635243785605, 0.5902849221319537, 0.8336816542961284, 0.22833827909897186, 0.17053073775819683, 0.27788694284294047, 0.19317971380019228, 0.27880137756365386, 0.2335604706608474, 0.2430760046478777, 0.22067940237598793, 0.13430011142003406, 0.18932321525368545, 0.20143500252666813, 0.18490256297013674, 0.1933893707485993, 0.17672468041909528, 0.17905089391135331, 0.25627601371572906, 0.21165019073152536, 0.2267957531143303, 0.1930752021976645, 0.22936690709952468, 0.19359906783542302, 0.1621800478209542, 0.23654770933456892, 0.16603595540941474, 0.14842726029219888, 0.17749710606390312, 0.05117828704458993, 0.061742143856876486, 0.0004973303577575638, 0.05003751496819242, 9.999999999998899e-05, 0.008914844181407866, 0.014901434486843002, 9.999999999998899e-05, 0.0021291064895166967, 0.09765028356242966, 0.20087974028030642, 0.11254723473811046, 0.08089374869090893, 0.07130867126860707, 0.08120735135232826, 0.06410054123183961, 0.12542194428511833, 0.14383339563967312, 0.11880311752106754, 0.05720400398726344, 0.11943041537935895, 0.1185383932228451, 0.10343308793304407, 0.3225186860827529, 0.0963650483763866, 0.3039587706816085, 0.0936567432733606, 0.1854412800373756, 0.13498791914891406, 0.1755767274912925, 0.10408723440538559, 0.04135430710342958, 0.13315739234977841, 0.14718106801412445, 0.10024413096213525, 0.08198520135077902, 0.5678178066785194, 0.51849717289344, 0.5218720993924234, 0.5529077856321603, 0.543542511854904, 0.5774009569256447, 0.5793373976232661, 0.5980265923556152, 0.592513553895978, 0.11990570746315499, 0.14303574903874927, 0.12852617323878002, 0.10775752035702735, 0.15152507428642237, 0.1765637930221544, 0.13788461617642678, 0.09858974028858358, 0.15798973614876266, 0.1809532178375749, 0.20291741910285244, 0.3628644599837674, 0.22991275777113973, 0.23243359631158755, 0.25489938654650146, 0.20818580407552822, 0.23272315112528918, 0.20933906509056155, 0.3496402162069485, 0.40113744240615656, 0.32537079914848, 0.4265536023235281, 0.5256443149496921, 0.46966945532993043, 0.33109285546228273, 0.5930764373774111, 0.3664740675975089, 0.24612998344670756, 0.3263306591633154, 0.2666835116449644, 0.24581509852944727, 0.32430281590954646, 0.28181716856039296, 0.3815750736389327, 0.47251957508845066, 0.21601296866627462, 0.2206159936445673, 0.23121183302368586, 0.23068739269752792, 0.25379887933044576, 0.2691548778689199, 0.20351405670159328, 0.20357321119807847, 0.1999536343343521, 0.2309003507148496, 0.22411817372964837, 0.22194078923575622, 0.1840194741436456, 0.18667533202982323, 0.1915743152378132, 0.2217392801523289, 0.22411380615400545, 0.2059247123111908, 0.19258412839617267, 0.16784369943168675, 0.19953992780121754, 0.18652679414020756, 0.902905944313183, 0.19913907920696705, 0.8730540438467387, 0.16971082622311662, 0.15236614458347264, 0.8926857318762406, 0.6208093895999642, 0.21157050432608404, 0.7157249171297029, 0.8727216036158011, 0.7108569298776647, 0.15533261461381875, 0.16744117010502102, 0.10406796436526566, 0.8886507064490605, 0.19453367465922433, 0.20252241978775753, 0.19537681072656143, 0.20328843501909444, 0.22544863611418897, 0.19390215198151706, 0.2016059702586286, 0.18045278867883296, 0.18746661288917044, 0.0996081071557936, 0.09478611929860403, 0.08817989551481586, 0.13520299326132645, 0.09813606111365247, 0.09747460331221847, 0.09845638122577727, 0.10826098343889112, 0.11349461409329231]}, "mutation_prompt": null}
{"id": "58c55633-10f1-4cfa-9e7d-61149acea5ee", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with dynamic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.4, 0.9)  # Dynamic scaling factor\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with adaptive parameters and dynamic mutation strategy for improved convergence.", "configspace": "", "generation": 41, "fitness": 0.3242041302796507, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "5cffdc24-c79a-4027-933f-d3ab0455a8d3", "metadata": {"aucs": [0.8096940132456864, 0.8783704304557981, 0.8543492183114244, 0.8195770914487226, 0.8653949639031051, 0.8442028959929802, 0.7939809193691281, 0.8730990253091601, 0.8555038588158299, 0.5860160189923068, 0.727239092036281, 0.6944788983715643, 9.999999999998899e-05, 0.7247574775565298, 0.7088414552973993, 0.5505389141201504, 0.6889405116587493, 0.7016120447271142, 0.15765467626353602, 0.14733126911351213, 0.14125279294110515, 0.1374432112208417, 0.12795052133239737, 0.12992273171947522, 0.14762387843080438, 0.14157717241732792, 0.14937934049102297, 0.10342055378627846, 0.12387779979324709, 0.11135341110135122, 0.11993941449443535, 0.15251154063369665, 0.11071697493867427, 0.11622672320350069, 0.10122003920541611, 0.14418885202462717, 0.9440177485571697, 0.9404509236189162, 0.9547936901632903, 0.9585930990925834, 0.9554321964573628, 0.9634984535222196, 0.9641769553953, 0.947509882786065, 0.9451965311177623, 0.4670515375975599, 0.6729157157273042, 0.6587874446887421, 0.4747110428656519, 0.6864402029191414, 0.6547235059170867, 0.45349715518547473, 0.6876644795498377, 0.6633986646366832, 0.6947720342452942, 0.37941439736363736, 0.8602766216309361, 0.789615624840504, 0.3770723310757488, 0.37404249292678216, 0.8372744524357343, 0.21230939035072804, 0.2211748002847428, 0.20457723809562944, 0.13155029090899206, 0.12265060525324456, 0.18405741025950262, 0.16052263056687965, 0.12347037644987635, 0.20463596255927186, 0.23814144348122712, 0.2054606761068425, 0.12918327606683233, 0.13823362806847272, 0.2017068464755425, 0.20257368568376455, 0.19048965065710188, 0.2906076042153215, 0.23774756984350975, 0.17362496405020267, 0.19132872853057026, 9.999999999998899e-05, 0.045098163075595, 0.05118276552907686, 9.999999999998899e-05, 9.999999999998899e-05, 0.02489190772103378, 0.011706543670382041, 0.07423615437106379, 9.999999999998899e-05, 0.15003530465346482, 0.1354481700462702, 0.09779135582524645, 0.08691120693019916, 0.07089861141938059, 0.06218839463619674, 0.13562397540999827, 0.12111350189643966, 0.15343968508636785, 0.12408235539614965, 0.05849247727230089, 0.11905184872024588, 0.11838274188650644, 0.07830328449420454, 0.19481208691786, 0.20077155403040392, 0.09495378433488799, 0.16325252154605074, 0.09162912884097318, 0.4303301709435754, 0.11618298938284932, 0.11275091178091168, 0.0834725829657611, 0.18197270092520113, 0.04870209832155159, 0.13670957558288754, 0.08257134847308056, 0.5547650896202186, 0.5450756643889382, 0.5326511720933338, 0.4984722622020963, 0.5782402899292003, 0.5549193045263602, 0.5457199826549551, 0.5972870067402829, 0.5620804754909198, 0.12401883996989327, 0.14710523759361716, 0.1354032617870201, 0.3950602627102787, 0.13942955616443165, 0.1524152948860581, 0.14640725646204322, 0.15015503102218986, 0.10743701519285809, 0.1669130494864921, 0.33367318617286834, 0.5835892531575861, 0.2009441326403667, 0.1732113372052687, 0.5332691430840195, 0.25522608427625926, 0.19736088320192136, 0.4299750477043235, 0.39805154473850635, 0.5879621496359073, 0.4755260985926142, 0.4192141874562647, 0.3771436877620673, 0.5201811329089108, 0.4607404902068082, 0.24263403848513931, 0.5698958477385827, 0.3523612197145459, 0.3191010739807473, 0.37529406249084196, 0.3325561926152871, 0.25234887657199867, 0.18957974427040403, 0.34377567195031444, 0.1921105479602897, 0.2845817368452864, 0.22110688553147695, 0.2523760820734515, 0.23288911369165832, 0.22410292149057354, 0.22645442762058032, 0.21805579472864678, 0.24422731869679026, 0.1862666907606002, 0.2601076866669271, 0.21996591113455877, 0.2037167364393505, 0.22090542070215324, 0.21555590293682148, 0.20079912443594938, 0.1767195316506528, 0.2100714770883142, 0.20679909620987058, 0.20567301191987808, 0.18562020113765942, 0.9006950495231985, 0.18738257642333722, 0.19867389899215226, 0.8150579646182925, 0.16742405140927274, 0.15862649629288683, 0.831630416362783, 0.1725256200525419, 0.5168192936904756, 0.6103734839576287, 0.21034181966525933, 0.2060260201875872, 0.20841116338737842, 0.127236402981593, 0.5723935608268631, 0.16462099359364324, 0.15649148875025998, 0.1841075584937969, 0.20078136153572357, 0.20623262469498438, 0.17499032801070658, 0.18309666275780934, 0.196981904675414, 0.18363809420277366, 0.2133216137406897, 0.20075732296650806, 0.08793499216210932, 0.100791658706742, 0.09052924853055067, 0.10122717982680152, 0.10245902178837474, 0.10244969560215722, 0.08611385953333428, 0.1077180694369978, 0.08790228678535428]}, "mutation_prompt": null}
{"id": "c6efacf6-77d5-49f3-975a-e55f2109a2b5", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with dynamic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.4, 0.9)  # Dynamic scaling factor\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with adaptive parameters and dynamic mutation strategy for improved convergence.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "58c55633-10f1-4cfa-9e7d-61149acea5ee", "metadata": {"aucs": [0.8096940132456864, 0.8783704304557981, 0.8543492183114244, 0.8195770914487226, 0.8653949639031051, 0.8442028959929802, 0.7939809193691281, 0.8730990253091601, 0.8555038588158299, 0.5860160189923068, 0.727239092036281, 0.6944788983715643, 9.999999999998899e-05, 0.7247574775565298, 0.7088414552973993, 0.5505389141201504, 0.6889405116587493, 0.7016120447271142, 0.15765467626353602, 0.14733126911351213, 0.14125279294110515, 0.1374432112208417, 0.12795052133239737, 0.12992273171947522, 0.14762387843080438, 0.14157717241732792, 0.14937934049102297, 0.10342055378627846, 0.12387779979324709, 0.11135341110135122, 0.11993941449443535, 0.15251154063369665, 0.11071697493867427, 0.11622672320350069, 0.10122003920541611, 0.14418885202462717, 0.9440177485571697, 0.9404509236189162, 0.9547936901632903, 0.9585930990925834, 0.9554321964573628, 0.9634984535222196, 0.9641769553953, 0.947509882786065, 0.9451965311177623, 0.4670515375975599, 0.6729157157273042, 0.6587874446887421, 0.4747110428656519, 0.6864402029191414, 0.6547235059170867, 0.45349715518547473, 0.6876644795498377, 0.6633986646366832, 0.6947720342452942, 0.37941439736363736, 0.8602766216309361, 0.789615624840504, 0.3770723310757488, 0.37404249292678216, 0.8372744524357343, 0.21230939035072804, 0.2211748002847428, 0.20457723809562944, 0.13155029090899206, 0.12265060525324456, 0.18405741025950262, 0.16052263056687965, 0.12347037644987635, 0.20463596255927186, 0.23814144348122712, 0.2054606761068425, 0.12918327606683233, 0.13823362806847272, 0.2017068464755425, 0.20257368568376455, 0.19048965065710188, 0.2906076042153215, 0.23774756984350975, 0.17362496405020267, 0.19132872853057026, 9.999999999998899e-05, 0.045098163075595, 0.05118276552907686, 9.999999999998899e-05, 9.999999999998899e-05, 0.02489190772103378, 0.011706543670382041, 0.07423615437106379, 9.999999999998899e-05, 0.15003530465346482, 0.1354481700462702, 0.09779135582524645, 0.08691120693019916, 0.07089861141938059, 0.06218839463619674, 0.13562397540999827, 0.12111350189643966, 0.15343968508636785, 0.12408235539614965, 0.05849247727230089, 0.11905184872024588, 0.11838274188650644, 0.07830328449420454, 0.19481208691786, 0.20077155403040392, 0.09495378433488799, 0.16325252154605074, 0.09162912884097318, 0.4303301709435754, 0.11618298938284932, 0.11275091178091168, 0.0834725829657611, 0.18197270092520113, 0.04870209832155159, 0.13670957558288754, 0.08257134847308056, 0.5547650896202186, 0.5450756643889382, 0.5326511720933338, 0.4984722622020963, 0.5782402899292003, 0.5549193045263602, 0.5457199826549551, 0.5972870067402829, 0.5620804754909198, 0.12401883996989327, 0.14710523759361716, 0.1354032617870201, 0.3950602627102787, 0.13942955616443165, 0.1524152948860581, 0.14640725646204322, 0.15015503102218986, 0.10743701519285809, 0.1669130494864921, 0.33367318617286834, 0.5835892531575861, 0.2009441326403667, 0.1732113372052687, 0.5332691430840195, 0.25522608427625926, 0.19736088320192136, 0.4299750477043235, 0.39805154473850635, 0.5879621496359073, 0.4755260985926142, 0.4192141874562647, 0.3771436877620673, 0.5201811329089108, 0.4607404902068082, 0.24263403848513931, 0.5698958477385827, 0.3523612197145459, 0.3191010739807473, 0.37529406249084196, 0.3325561926152871, 0.25234887657199867, 0.18957974427040403, 0.34377567195031444, 0.1921105479602897, 0.2845817368452864, 0.22110688553147695, 0.2523760820734515, 0.23288911369165832, 0.22410292149057354, 0.22645442762058032, 0.21805579472864678, 0.24422731869679026, 0.1862666907606002, 0.2601076866669271, 0.21996591113455877, 0.2037167364393505, 0.22090542070215324, 0.21555590293682148, 0.20079912443594938, 0.1767195316506528, 0.2100714770883142, 0.20679909620987058, 0.20567301191987808, 0.18562020113765942, 0.9006950495231985, 0.18738257642333722, 0.19867389899215226, 0.8150579646182925, 0.16742405140927274, 0.15862649629288683, 0.831630416362783, 0.1725256200525419, 0.5168192936904756, 0.6103734839576287, 0.21034181966525933, 0.2060260201875872, 0.20841116338737842, 0.127236402981593, 0.5723935608268631, 0.16462099359364324, 0.15649148875025998, 0.1841075584937969, 0.20078136153572357, 0.20623262469498438, 0.17499032801070658, 0.18309666275780934, 0.196981904675414, 0.18363809420277366, 0.2133216137406897, 0.20075732296650806, 0.08793499216210932, 0.100791658706742, 0.09052924853055067, 0.10122717982680152, 0.10245902178837474, 0.10244969560215722, 0.08611385953333428, 0.1077180694369978, 0.08790228678535428]}, "mutation_prompt": null}
{"id": "c9ce3796-1990-48c3-9740-c1528ae132a4", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Initial DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with adaptive scaling\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.3, 1.0)  # Wider dynamic scaling factor\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Adaptive inertia and Particle Swarm Optimization\n            convergence_rate = np.linalg.norm(global_best - np.mean(personal_best, axis=0))\n            self.w = 0.4 + 0.5 * np.exp(-convergence_rate)  # Adaptive inertia based on convergence rate\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Improved hybrid algorithm by introducing adaptive scaling and inertia based on convergence rate.", "configspace": "", "generation": 43, "fitness": 0.2297395528158572, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.19.", "error": "", "parent_id": "58c55633-10f1-4cfa-9e7d-61149acea5ee", "metadata": {"aucs": [0.36930778063241587, 0.4381527840044567, 0.45940195433855346, 0.3751818902400921, 0.49291922321555426, 0.44673883938841874, 0.38274708827813253, 0.46478278303727516, 0.4666663039204695, 0.20730948470654043, 0.2813718297114841, 0.03811193329691154, 0.24749097128286024, 0.25178288761726875, 0.044629972321878486, 0.21460927771558946, 0.26896897181007495, 0.28765068653388814, 0.11835443530847611, 0.1295629413281234, 0.13010433114784759, 0.13770998769032616, 0.21371984056340698, 0.16164259727254027, 0.13732541264118814, 0.1390468187307612, 0.1520148567976075, 0.1009319319179407, 0.13388858436247975, 0.12715619302135384, 0.11909823772510575, 0.10048511815709626, 0.10746302055720458, 0.10182900435225462, 0.11915783068574493, 0.1267536190237757, 0.936389931741987, 0.9438975269898957, 0.9600253450834244, 0.9492603717240101, 0.9397167388060899, 0.9635260177003068, 0.9624096638837953, 0.9449030586299008, 0.9354266171031873, 0.3022271529541909, 0.3360529875188426, 0.3236361159204182, 0.27210522135069226, 0.3154585142199098, 0.34398714814446985, 0.27084648235288844, 0.3237537977925916, 0.3331707463363903, 0.4333907050358833, 0.3306558167945276, 0.3367074098764078, 0.36428911793407015, 0.21197472514153926, 0.36288414688708737, 0.3482958638142425, 0.2704260049328966, 0.34789850810851697, 0.1487925932529368, 0.1522303096417963, 0.11071757250482239, 0.16208606353721566, 0.17399823264874448, 0.15384390420367688, 0.1311458741177357, 0.15326174598242015, 0.15395545465127347, 0.13092692183875532, 0.13949931154185846, 0.12625305491501182, 0.13761376836663497, 0.1254364800864619, 0.20275028461163802, 0.16605224219590342, 0.17316477339958414, 0.1675932969430065, 9.999999999998899e-05, 0.03037688229623603, 0.02115377674193386, 9.999999999998899e-05, 9.999999999998899e-05, 0.05731163137736295, 9.999999999998899e-05, 0.00763123584909986, 0.006624764456435672, 0.06392453700458467, 0.1339859132885205, 0.03649683508399304, 0.10318170917984026, 0.17344446122046542, 0.040915032528285655, 0.1606810336927854, 0.10344697165413452, 0.17486484107261346, 9.999999999998899e-05, 0.00032266103486400244, 0.0015130084375561959, 9.999999999998899e-05, 9.999999999998899e-05, 0.025913299610122342, 9.999999999998899e-05, 0.00012560180365817075, 0.024415728423816674, 0.09163118096786471, 0.07078295687495006, 0.07351074004181024, 0.07817955147876998, 0.0828330276388004, 0.1189330042163157, 0.0736543163028488, 0.10465892790974252, 0.06974311042706105, 0.35686212414326457, 0.4015523097232043, 0.42466062293346285, 0.3668927038507581, 0.42418776113795986, 0.43189045952937843, 0.3701128676711075, 0.3839503350314374, 0.4164355005669427, 0.11093793049058454, 0.131279796966148, 0.14223899565426967, 0.11025728394861745, 0.11437786789519122, 0.09184342610147067, 0.11405893834411307, 0.11795434080212419, 0.12480333825114065, 0.21854352807914534, 0.22632433278562836, 0.16241960693552626, 0.20845150006744695, 0.20996466241073863, 0.29887349656726925, 0.14743956718511997, 0.19004744802666884, 0.26663248257060546, 0.26923769487243043, 0.278196656670223, 0.27976912648609187, 0.271746375150971, 0.2876155373304916, 0.2900978390501794, 0.29115173210191336, 0.23592987178054559, 0.3085047914668335, 0.20841401398577208, 0.23479961999797383, 0.18201935494012889, 0.21036206266289015, 0.21224234915150075, 0.23369652949326936, 0.22833432574830492, 0.1749623022083615, 0.18325859346725015, 0.21294121634441632, 0.2241927651772826, 0.19986399670182964, 0.2172567352214172, 0.22079661729820177, 0.2292493280307748, 0.24426354693899688, 0.22147606827907407, 0.20831415538867326, 0.19717644272739154, 0.24613126740350977, 0.2359227672992502, 0.19464680536807477, 0.2192603746576377, 0.20625066916456813, 0.22513695415225798, 0.21327512022203376, 0.3293233173502411, 0.1845994597578502, 0.7602966274993781, 0.18667780867748585, 0.1954953344977639, 0.659507887331586, 0.16755455836122746, 0.15756019597605886, 0.209987534435221, 0.17208736643711164, 0.12640244670306944, 0.5733355007289774, 0.2098729983877362, 0.16832776130331217, 0.2097975840314399, 0.12632145490470015, 0.4668010323816375, 0.16484079170289534, 0.15620884149763237, 0.18058047147544132, 0.20924741306877415, 0.21097187905652237, 0.19640365210444588, 0.19492856677308612, 0.21103962886510386, 0.18865394578307382, 0.1959305039407957, 0.2054666645454215, 0.09059751113635106, 0.09494143753641637, 0.08280073006617694, 0.10463521278292087, 0.09479634879093224, 0.11207693433293187, 0.09777935695752915, 0.08458588319860483, 0.08605814606824203]}, "mutation_prompt": null}
{"id": "83f8edbc-4e45-4fa7-a898-38cee158c772", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)\n        self.c1 = np.random.uniform(1.5, 2.5)\n        self.c2 = np.random.uniform(1.0, 2.0)\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        stagnation_counter = 0  # Track lack of improvements\n        best_fitness = fitness[global_best_idx]\n\n        while budget_used < self.budget:\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                diversity_factor = np.std(population)  # Adapt mutation based on diversity\n                f_dynamic = np.random.uniform(0.4, 0.9) * diversity_factor\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            if best_fitness - fitness[global_best_idx] < 1e-8:\n                stagnation_counter += 1\n            else:\n                stagnation_counter = 0\n            best_fitness = fitness[global_best_idx]\n            if stagnation_counter > 5:  # Trigger exploration mechanism\n                r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n                velocities = np.clip(\n                    self.w * velocities\n                    + (1.5 * self.c1) * r1 * (personal_best - population)\n                    + (0.5 * self.c2) * r2 * (global_best - population),\n                    -self.v_max, self.v_max\n                )\n            else:\n                r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n                velocities = np.clip(\n                    self.w * velocities\n                    + self.c1 * r1 * (personal_best - population)\n                    + self.c2 * r2 * (global_best - population),\n                    -self.v_max, self.v_max\n                )\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with adaptive learning based on population diversity and dynamic mutation for improved exploration-exploitation balance.", "configspace": "", "generation": 44, "fitness": 0.30696767510961337, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "58c55633-10f1-4cfa-9e7d-61149acea5ee", "metadata": {"aucs": [0.7873271371040511, 0.8634534376695214, 0.8624524949637589, 0.7807499950407722, 0.8396345071671727, 0.8465527421519322, 0.7721517366530181, 0.85259169733463, 0.8409338429359694, 0.5549438195895873, 0.7312578278232844, 0.6742943815211101, 0.5589557913043879, 0.7021128173664037, 0.6588673975462056, 0.5131166871761768, 0.6646060947267549, 0.6474929880070819, 0.1294518267287964, 0.15475852843843751, 0.15504607328964193, 0.13048425142610665, 0.518985953496878, 0.1210259465676099, 0.14044831692736515, 0.15432449497948963, 0.10692610827936055, 0.12389832256662014, 0.10703919087159197, 0.10006111453847644, 0.11873606241113122, 0.112796644223086, 0.12927829456560558, 0.12230331469678934, 0.12336890755178809, 0.12522161595625425, 0.9636078843136647, 0.9468998342420433, 0.9700765418475479, 0.9910731235375039, 0.9764750642653365, 0.9589602505992967, 0.9750198473148409, 0.9771557773919637, 0.9535314226286511, 0.4468685461847969, 0.5618382875564714, 0.618481655059085, 0.32587926445405824, 0.5787273773024242, 0.588964391921108, 0.4255637350014977, 0.5731772513065061, 0.6018978019005079, 0.2231175138505871, 0.22712591856104503, 0.22737687080579116, 0.20963013157223864, 0.2083604110206142, 0.2714792713947344, 0.24069860806699883, 0.43727607670107826, 0.8502551795411645, 0.2517723154125334, 0.21881780123738048, 0.2334877609870103, 0.18094964629025068, 0.12921658101875177, 0.10501515585786914, 0.1717857282011197, 0.18706205720459945, 0.19215873404585104, 0.11220719809445767, 0.13185833297104632, 0.15873425181752232, 0.24196519828781404, 0.165695709393062, 0.16633418117272958, 0.19305529260485443, 0.17607318388734894, 0.2593788668882392, 9.999999999998899e-05, 0.006984240360214833, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05897359850052075, 0.0018743271638477221, 9.999999999998899e-05, 0.030328524328416595, 0.13496757354930777, 0.0889514702433305, 0.10593389255889873, 0.06236983908341753, 0.09256676601455516, 0.059522745177249425, 0.08310654590261202, 0.06918351372051113, 0.1539188322933045, 0.11252520464957039, 0.08022326482052666, 0.10818387867503021, 0.1475520539060894, 0.21546045151172277, 0.07166579137122975, 0.297482837288468, 0.0928471299950987, 0.10633846650511192, 0.08673842611533222, 0.17451889650702046, 0.173715625969322, 0.22726770185076595, 0.1211619283411679, 0.15064111183895657, 0.04683536284598144, 0.14088722484065297, 0.05574172101330954, 0.5028328403440694, 0.5335046451994201, 0.5366152677422265, 0.5040216410270387, 0.5548831443567505, 0.5375653417905615, 0.5313549440750676, 0.5431427842941461, 0.557106592908065, 0.12022577343510599, 0.10052387985414557, 0.11073689741565662, 0.14263202478299375, 0.13093237634141275, 0.14098880042312156, 0.1319992721840163, 0.13559672960068403, 0.13120480647751553, 0.1536709808932858, 0.17183649758437192, 0.22583728921034674, 0.16629001344966987, 0.14235855445777523, 0.19417305970300802, 0.1766516068910754, 0.16776547384702478, 0.4698170670678202, 0.3936679705258551, 0.48708199999395696, 0.3124944500460448, 0.4557111571527809, 0.2609847785106596, 0.3056940239547644, 0.34979082893707236, 0.2938551892408727, 0.40649683835421324, 0.20288460055993973, 0.23795448621391435, 0.23835453795842998, 0.34705308461895334, 0.3175974693693313, 0.3724461470809426, 0.28586641399910184, 0.2101973874730686, 0.26665575327667024, 0.20864347047698262, 0.201704369250718, 0.20129591089167476, 0.2315063540087129, 0.21488543008013727, 0.28694747710247115, 0.21474352577088351, 0.20980789314155868, 0.22734418418209867, 0.22607862742616358, 0.18855959966850921, 0.19453381565632732, 0.3232122232147224, 0.1998171048510874, 0.18871180468879645, 0.20965631463158785, 0.19791938626783712, 0.2423033066448269, 0.17152331389611386, 0.17162769197064331, 0.17144674276268412, 0.8708749843704059, 0.7330942396286629, 0.16794472000383553, 0.5494860768648981, 0.8447713833189701, 0.16713111781183543, 0.12633302072572317, 0.7201303018687919, 0.20379937828763417, 0.15274686373702284, 0.7367623694932659, 0.6423189364362627, 0.6323531861550105, 0.21065615725187037, 0.15607968850987508, 0.1911930240831835, 0.19318262226281613, 0.19728675200550227, 0.18719141100732684, 0.19894376979563855, 0.20497573573753802, 0.20231787486438302, 0.1705781328451319, 0.18795235593101967, 0.09310198845425821, 0.08717399978354623, 0.09612079350010294, 0.10833366681222256, 0.10377648176515808, 0.08263969298708196, 0.08023509912692406, 0.08842306031692426, 0.08607962447379247]}, "mutation_prompt": null}
{"id": "17d92a2e-fa53-4a5f-92dd-767278a5b805", "solution": "import numpy as np\n\nclass ImprovedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w_max, self.w_min = 0.9, 0.4  # Dynamic inertia weight range\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with dynamic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.6, 0.9)  # Adjusted scaling factor\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization with dynamic inertia\n            inertia_weight = self.w_max - (self.w_max - self.w_min) * (budget_used / self.budget)\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                inertia_weight * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "ImprovedHybridDEPSO", "description": "ImprovedHybridDEPSO introduces adaptive control of both exploration and exploitation phases using a dynamic inertia weight and mutation strategy for enhanced convergence.", "configspace": "", "generation": 45, "fitness": 0.2225518584217413, "feedback": "The algorithm ImprovedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "58c55633-10f1-4cfa-9e7d-61149acea5ee", "metadata": {"aucs": [0.46463086782383667, 0.49052718431870734, 0.43460105511650504, 0.47426767867448116, 0.4301847020759103, 0.5086209360202398, 0.46291041221798535, 0.4712642390521662, 0.4896032135056353, 0.13174288969955938, 0.11455339765963457, 0.09676594212360345, 0.12345054461647065, 0.13420171160675387, 0.13931798987843813, 0.15847991731033084, 0.1377963808784347, 0.11685569748473679, 0.11556976216396542, 0.1090547347506361, 0.14266554179359792, 0.12150128968681706, 0.12160641251901894, 0.11619000223224063, 0.10843681097982294, 0.1116241625036013, 0.10555855240638101, 0.11224321778359403, 0.10033481851012005, 0.10558398905910726, 0.07948177229894537, 0.08908848122158253, 0.0907393530683065, 0.11465051403999482, 0.10524555181524775, 0.11846204083716516, 0.955443716450924, 0.9736509677697665, 0.9629024172071242, 0.9629551586186402, 0.9554646203697353, 0.9736857385807904, 0.971314005766363, 0.9584580744969668, 0.9722666419463016, 0.21533173178428, 0.26126701092386884, 0.22045774797931994, 0.26389571638056064, 0.14551626942914153, 0.2378516186789127, 0.22991042622381352, 0.2050104745371275, 0.2518528439272921, 0.25746972496718257, 0.254592735342578, 0.2635275967056516, 0.4159775228791338, 0.2914623467490818, 0.386494249288891, 0.2986447677903722, 0.2764112010374271, 0.24764070438291796, 0.13850106817890973, 0.1375959708675455, 0.14324203825533877, 0.13259646935664948, 0.10307754049263718, 0.09825365657686636, 0.1480874522595912, 0.13445642573562488, 0.13214182502594118, 0.010156045271275116, 0.14596541867329238, 0.14405273500268945, 0.12141505717360612, 0.11150252698780838, 0.15065908375622716, 0.14801624845684713, 0.13442811420236445, 0.17351913470688318, 0.010761959133324894, 9.999999999998899e-05, 0.019924485324655183, 0.02051616966565617, 0.004323533981211547, 9.999999999998899e-05, 0.0019103324162719204, 9.999999999998899e-05, 9.999999999998899e-05, 0.07602148490714644, 0.10261188996423376, 0.1326421356991666, 0.07170896434061413, 0.08394047791938497, 0.04000652898256285, 0.06904538123768367, 0.07261810995271423, 0.06511296564334879, 0.017467358845591807, 0.01166270987263085, 0.014976757661406048, 0.01825665842916291, 0.02088133409726356, 0.027303850382360162, 0.026486277841184513, 0.015810819986046054, 0.02931344235394373, 0.10219400420178149, 0.03655471791808318, 0.09781776256636454, 0.06794371179771219, 0.0799965244130344, 0.10492279665841286, 0.05028277171165496, 0.043501394764091095, 0.06414117130498143, 0.386966071801765, 0.4107149980250935, 0.35856100172903504, 0.4205856521885979, 0.41448600519217493, 0.37749491985013206, 0.40926452483839626, 0.3725393074386112, 0.4067352651729572, 0.11783790114515502, 0.09440597509241144, 0.09832733594484855, 0.0937137943564963, 0.10488440388732911, 0.10802744979912726, 0.10226841160888511, 0.09397393525237874, 0.09560272240906686, 0.1597463360502236, 0.19496792534183283, 0.22333919921743794, 0.1888655304337683, 0.1557731494010961, 0.16219799178271188, 0.15635559167612378, 0.16241450004429936, 0.19938526592490247, 0.3012468410525573, 0.26873887813888453, 0.26911248460335324, 0.26504870602809294, 0.2685805889290602, 0.2885394166797358, 0.2693726446181549, 0.2812095604309409, 0.2726814885093015, 0.23356363967261018, 0.20762120793300554, 0.21766698295949838, 0.1794790653352959, 0.19000615610198412, 0.2261079901461034, 0.23903776735234472, 0.20619764953778197, 0.25325233544287207, 0.20680426673243668, 0.2063683534262406, 0.20046592296534105, 0.22354736467244252, 0.1965346604356606, 0.21943343517703162, 0.18603203682590874, 0.2061915876243886, 0.2013089321230549, 0.21772231585681023, 0.1782368234870828, 0.18085714265455122, 0.3183603592118518, 0.20103302619057062, 0.2759059631599664, 0.2503721692597952, 0.20973942767646436, 0.3048726771959922, 0.5903912901319917, 0.585656695145186, 0.1600214109035385, 0.6266904922265726, 0.1954666995590374, 0.16201775349224878, 0.6421666401270925, 0.15468509105813866, 0.5553576123699209, 0.45675325382837473, 0.20469107827673783, 0.2022640879508648, 0.20152923598545436, 0.19333396388530455, 0.1659551827631609, 0.44970969083962875, 0.4845471512878359, 0.423502699429984, 0.19042688004815356, 0.18193366039821113, 0.18484624888104684, 0.21797046524842212, 0.181574239956643, 0.18604539244087526, 0.19585806819915075, 0.1789918931961043, 0.18108151938561912, 0.07699843152561092, 0.08531530379621033, 0.06963612519922935, 0.0903453395664614, 0.08548865020598517, 0.08720835037898755, 0.09376571059112626, 0.08517164553899004, 0.08712533862467986]}, "mutation_prompt": null}
{"id": "08401c57-79c7-46d8-bc73-d5c48c1635e2", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with dynamic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.4, 0.9)  # Dynamic scaling factor\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with adaptive parameters and dynamic mutation strategy for improved convergence.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "58c55633-10f1-4cfa-9e7d-61149acea5ee", "metadata": {"aucs": [0.8096940132456864, 0.8783704304557981, 0.8543492183114244, 0.8195770914487226, 0.8653949639031051, 0.8442028959929802, 0.7939809193691281, 0.8730990253091601, 0.8555038588158299, 0.5860160189923068, 0.727239092036281, 0.6944788983715643, 9.999999999998899e-05, 0.7247574775565298, 0.7088414552973993, 0.5505389141201504, 0.6889405116587493, 0.7016120447271142, 0.15765467626353602, 0.14733126911351213, 0.14125279294110515, 0.1374432112208417, 0.12795052133239737, 0.12992273171947522, 0.14762387843080438, 0.14157717241732792, 0.14937934049102297, 0.10342055378627846, 0.12387779979324709, 0.11135341110135122, 0.11993941449443535, 0.15251154063369665, 0.11071697493867427, 0.11622672320350069, 0.10122003920541611, 0.14418885202462717, 0.9440177485571697, 0.9404509236189162, 0.9547936901632903, 0.9585930990925834, 0.9554321964573628, 0.9634984535222196, 0.9641769553953, 0.947509882786065, 0.9451965311177623, 0.4670515375975599, 0.6729157157273042, 0.6587874446887421, 0.4747110428656519, 0.6864402029191414, 0.6547235059170867, 0.45349715518547473, 0.6876644795498377, 0.6633986646366832, 0.6947720342452942, 0.37941439736363736, 0.8602766216309361, 0.789615624840504, 0.3770723310757488, 0.37404249292678216, 0.8372744524357343, 0.21230939035072804, 0.2211748002847428, 0.20457723809562944, 0.13155029090899206, 0.12265060525324456, 0.18405741025950262, 0.16052263056687965, 0.12347037644987635, 0.20463596255927186, 0.23814144348122712, 0.2054606761068425, 0.12918327606683233, 0.13823362806847272, 0.2017068464755425, 0.20257368568376455, 0.19048965065710188, 0.2906076042153215, 0.23774756984350975, 0.17362496405020267, 0.19132872853057026, 9.999999999998899e-05, 0.045098163075595, 0.05118276552907686, 9.999999999998899e-05, 9.999999999998899e-05, 0.02489190772103378, 0.011706543670382041, 0.07423615437106379, 9.999999999998899e-05, 0.15003530465346482, 0.1354481700462702, 0.09779135582524645, 0.08691120693019916, 0.07089861141938059, 0.06218839463619674, 0.13562397540999827, 0.12111350189643966, 0.15343968508636785, 0.12408235539614965, 0.05849247727230089, 0.11905184872024588, 0.11838274188650644, 0.07830328449420454, 0.19481208691786, 0.20077155403040392, 0.09495378433488799, 0.16325252154605074, 0.09162912884097318, 0.4303301709435754, 0.11618298938284932, 0.11275091178091168, 0.0834725829657611, 0.18197270092520113, 0.04870209832155159, 0.13670957558288754, 0.08257134847308056, 0.5547650896202186, 0.5450756643889382, 0.5326511720933338, 0.4984722622020963, 0.5782402899292003, 0.5549193045263602, 0.5457199826549551, 0.5972870067402829, 0.5620804754909198, 0.12401883996989327, 0.14710523759361716, 0.1354032617870201, 0.3950602627102787, 0.13942955616443165, 0.1524152948860581, 0.14640725646204322, 0.15015503102218986, 0.10743701519285809, 0.1669130494864921, 0.33367318617286834, 0.5835892531575861, 0.2009441326403667, 0.1732113372052687, 0.5332691430840195, 0.25522608427625926, 0.19736088320192136, 0.4299750477043235, 0.39805154473850635, 0.5879621496359073, 0.4755260985926142, 0.4192141874562647, 0.3771436877620673, 0.5201811329089108, 0.4607404902068082, 0.24263403848513931, 0.5698958477385827, 0.3523612197145459, 0.3191010739807473, 0.37529406249084196, 0.3325561926152871, 0.25234887657199867, 0.18957974427040403, 0.34377567195031444, 0.1921105479602897, 0.2845817368452864, 0.22110688553147695, 0.2523760820734515, 0.23288911369165832, 0.22410292149057354, 0.22645442762058032, 0.21805579472864678, 0.24422731869679026, 0.1862666907606002, 0.2601076866669271, 0.21996591113455877, 0.2037167364393505, 0.22090542070215324, 0.21555590293682148, 0.20079912443594938, 0.1767195316506528, 0.2100714770883142, 0.20679909620987058, 0.20567301191987808, 0.18562020113765942, 0.9006950495231985, 0.18738257642333722, 0.19867389899215226, 0.8150579646182925, 0.16742405140927274, 0.15862649629288683, 0.831630416362783, 0.1725256200525419, 0.5168192936904756, 0.6103734839576287, 0.21034181966525933, 0.2060260201875872, 0.20841116338737842, 0.127236402981593, 0.5723935608268631, 0.16462099359364324, 0.15649148875025998, 0.1841075584937969, 0.20078136153572357, 0.20623262469498438, 0.17499032801070658, 0.18309666275780934, 0.196981904675414, 0.18363809420277366, 0.2133216137406897, 0.20075732296650806, 0.08793499216210932, 0.100791658706742, 0.09052924853055067, 0.10122717982680152, 0.10245902178837474, 0.10244969560215722, 0.08611385953333428, 0.1077180694369978, 0.08790228678535428]}, "mutation_prompt": null}
{"id": "3190c15d-7d91-4393-ac21-05c100bf2eb5", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (6 * dim)))  # Adjusted population size\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with self-adaptive crossover\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.4, 0.9)  # Dynamic scaling factor\n                self.cr = 0.8 + 0.2 * np.sin(budget_used / self.budget * np.pi)  # Self-adaptive crossover rate\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with self-adaptive crossover rate and dynamic population scaling for better exploration-exploitation balance.", "configspace": "", "generation": 47, "fitness": 0.2950921041398342, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "58c55633-10f1-4cfa-9e7d-61149acea5ee", "metadata": {"aucs": [0.7807204237802243, 0.8740082431930972, 0.8560704507949668, 0.7859801801280489, 0.873529377807068, 0.848976999822351, 0.8249736205927196, 0.8652769694008097, 0.8559867858644353, 0.5992001468559249, 0.7121290042309835, 0.6963969554065106, 0.5896181161978882, 0.723102701185325, 0.6647994728083555, 0.5595311488379644, 0.05757624018990337, 0.6700969156763731, 0.16806246216313392, 0.14570515927135097, 0.11746607431571376, 0.12219364072384864, 0.1661519505635244, 0.15284434749474962, 0.13593973434615514, 0.1496300739723767, 0.13876218403441598, 0.1175833080883596, 0.1478460956145804, 0.10676208669020526, 0.13588508434872038, 0.11361444158782774, 0.10678713641788695, 0.11747109458502203, 0.10363457823197297, 0.1410282833989822, 0.9506202209060161, 0.9533077604913567, 0.964120236645911, 0.9530270780521148, 0.9460067588061609, 0.9383692705831268, 0.9571661222349087, 0.9617378963301885, 0.9545922235373163, 0.4682479814084237, 0.6586874597239343, 0.7063782561591425, 0.48505328405674175, 0.6932976889444693, 0.6616294470423668, 0.3867490991654544, 0.6709969197555647, 0.6732103403140615, 0.36631010301340916, 0.22670381760277236, 0.22713544373089067, 0.19212584005502575, 0.27614870091762445, 0.21906136755977634, 0.24347167745321052, 0.3640547479327242, 0.7896412276461183, 0.1281833990523692, 0.4425972162903553, 0.12767413535995387, 0.19314083510875357, 0.17616722826112163, 0.2537989239873689, 0.19909535562586123, 0.1602365778771393, 0.19117567195590546, 0.2198033275427952, 0.14023304812215975, 0.2309996002823813, 0.17834002560748363, 0.1310872702250243, 0.20573233458563267, 0.22124228702974835, 0.18071449023689123, 0.1286376969649573, 0.03255695790741886, 0.009638363586181753, 0.05329182416726985, 9.999999999998899e-05, 0.026545519086623948, 0.0017554622942425047, 0.09267489546883112, 0.01296034449190242, 0.0021214013852586255, 0.07691781073647541, 0.16003804638784425, 0.10073950002907572, 0.146244751881644, 0.06633376646201083, 0.058516049727311836, 0.14631731078144672, 0.12405068506455896, 0.08760431967085147, 0.044305670894589144, 0.06826231241847891, 0.09165420921688383, 0.147426224807924, 0.17143124815046973, 0.20525462637964498, 0.10016717559752508, 0.09779367763537616, 0.20445671242546803, 0.07103633971507495, 0.0708196134538599, 0.13142086064795, 0.08953080342439712, 0.0725855482506006, 0.09075070331302737, 0.07831583417322596, 0.08630814342224657, 0.13325350197363406, 0.5038215325558801, 0.5549599058538265, 0.5551756503005197, 0.4960536355427556, 0.5952715226614629, 0.612273302184791, 0.534789261958579, 0.5820362858496587, 0.6065086940181704, 0.09303858825865796, 0.13946180231950878, 0.09789898704894695, 0.14773862551907602, 0.10769178031480497, 0.0950463146014221, 0.1406153691070453, 0.14461897113570832, 0.07290808497176526, 0.17496781668615458, 0.1628930407794047, 0.1769383417788858, 0.2558237077251363, 0.21822415031239184, 0.26106957552775034, 0.18130504973221828, 0.2601392722268143, 0.20790071923688924, 0.3381380583796588, 0.3985345395435699, 0.2773548072123747, 0.42604520713017513, 0.2738551310551983, 0.2667687394778493, 0.47002325058684624, 0.5755019852371899, 0.4673260254947531, 0.31761030592735906, 0.19288368755109564, 0.3053838257206327, 0.2479367225871768, 0.38009143457133154, 0.18135579204384433, 0.19137360202963616, 0.1678313629184346, 0.22660888720874783, 0.23342673253288126, 0.2121916250043231, 0.21518909789278273, 0.22932373518537075, 0.2785758798357617, 0.24793184945886704, 0.22066590464339297, 0.24370902536979488, 0.23663109308946007, 0.19705807536069564, 0.19456976074120036, 0.19536349752182136, 0.2113136208879447, 0.19454566398662332, 0.17716064719671432, 0.2156815365737712, 0.20547153791317663, 0.22130970783956871, 0.18623990422779946, 0.2055733445665171, 0.18711972302837188, 0.1977458985212175, 0.16136202644438669, 0.1675590548738617, 0.15854783216129797, 0.8860936033925274, 0.17251654628563462, 0.126906532180171, 0.6957033152330805, 0.21024554179823118, 0.16777189874937393, 0.21017589078267296, 0.12646165582416924, 0.6240690521267325, 0.10396776723374446, 0.156575767249708, 0.2009987529772257, 0.2115283015919538, 0.20623262469498438, 0.1852622584672956, 0.19360048458529278, 0.18347402640968757, 0.17369478039816044, 0.1904398410948871, 0.20731739309187347, 0.0914216060209273, 0.08969880501017125, 0.10453071908379186, 0.09539229765585389, 0.09739836443381211, 0.10472249674296197, 0.0840513548538172, 0.09363671290443454, 0.09271387775349327]}, "mutation_prompt": null}
{"id": "e58526ff-0a3e-49b8-b454-f3a6b88e177f", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with dynamic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.4, 0.9)  # Dynamic scaling factor\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with adaptive parameters and dynamic mutation strategy for improved convergence.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "58c55633-10f1-4cfa-9e7d-61149acea5ee", "metadata": {"aucs": [0.8096940132456864, 0.8783704304557981, 0.8543492183114244, 0.8195770914487226, 0.8653949639031051, 0.8442028959929802, 0.7939809193691281, 0.8730990253091601, 0.8555038588158299, 0.5860160189923068, 0.727239092036281, 0.6944788983715643, 9.999999999998899e-05, 0.7247574775565298, 0.7088414552973993, 0.5505389141201504, 0.6889405116587493, 0.7016120447271142, 0.15765467626353602, 0.14733126911351213, 0.14125279294110515, 0.1374432112208417, 0.12795052133239737, 0.12992273171947522, 0.14762387843080438, 0.14157717241732792, 0.14937934049102297, 0.10342055378627846, 0.12387779979324709, 0.11135341110135122, 0.11993941449443535, 0.15251154063369665, 0.11071697493867427, 0.11622672320350069, 0.10122003920541611, 0.14418885202462717, 0.9440177485571697, 0.9404509236189162, 0.9547936901632903, 0.9585930990925834, 0.9554321964573628, 0.9634984535222196, 0.9641769553953, 0.947509882786065, 0.9451965311177623, 0.4670515375975599, 0.6729157157273042, 0.6587874446887421, 0.4747110428656519, 0.6864402029191414, 0.6547235059170867, 0.45349715518547473, 0.6876644795498377, 0.6633986646366832, 0.6947720342452942, 0.37941439736363736, 0.8602766216309361, 0.789615624840504, 0.3770723310757488, 0.37404249292678216, 0.8372744524357343, 0.21230939035072804, 0.2211748002847428, 0.20457723809562944, 0.13155029090899206, 0.12265060525324456, 0.18405741025950262, 0.16052263056687965, 0.12347037644987635, 0.20463596255927186, 0.23814144348122712, 0.2054606761068425, 0.12918327606683233, 0.13823362806847272, 0.2017068464755425, 0.20257368568376455, 0.19048965065710188, 0.2906076042153215, 0.23774756984350975, 0.17362496405020267, 0.19132872853057026, 9.999999999998899e-05, 0.045098163075595, 0.05118276552907686, 9.999999999998899e-05, 9.999999999998899e-05, 0.02489190772103378, 0.011706543670382041, 0.07423615437106379, 9.999999999998899e-05, 0.15003530465346482, 0.1354481700462702, 0.09779135582524645, 0.08691120693019916, 0.07089861141938059, 0.06218839463619674, 0.13562397540999827, 0.12111350189643966, 0.15343968508636785, 0.12408235539614965, 0.05849247727230089, 0.11905184872024588, 0.11838274188650644, 0.07830328449420454, 0.19481208691786, 0.20077155403040392, 0.09495378433488799, 0.16325252154605074, 0.09162912884097318, 0.4303301709435754, 0.11618298938284932, 0.11275091178091168, 0.0834725829657611, 0.18197270092520113, 0.04870209832155159, 0.13670957558288754, 0.08257134847308056, 0.5547650896202186, 0.5450756643889382, 0.5326511720933338, 0.4984722622020963, 0.5782402899292003, 0.5549193045263602, 0.5457199826549551, 0.5972870067402829, 0.5620804754909198, 0.12401883996989327, 0.14710523759361716, 0.1354032617870201, 0.3950602627102787, 0.13942955616443165, 0.1524152948860581, 0.14640725646204322, 0.15015503102218986, 0.10743701519285809, 0.1669130494864921, 0.33367318617286834, 0.5835892531575861, 0.2009441326403667, 0.1732113372052687, 0.5332691430840195, 0.25522608427625926, 0.19736088320192136, 0.4299750477043235, 0.39805154473850635, 0.5879621496359073, 0.4755260985926142, 0.4192141874562647, 0.3771436877620673, 0.5201811329089108, 0.4607404902068082, 0.24263403848513931, 0.5698958477385827, 0.3523612197145459, 0.3191010739807473, 0.37529406249084196, 0.3325561926152871, 0.25234887657199867, 0.18957974427040403, 0.34377567195031444, 0.1921105479602897, 0.2845817368452864, 0.22110688553147695, 0.2523760820734515, 0.23288911369165832, 0.22410292149057354, 0.22645442762058032, 0.21805579472864678, 0.24422731869679026, 0.1862666907606002, 0.2601076866669271, 0.21996591113455877, 0.2037167364393505, 0.22090542070215324, 0.21555590293682148, 0.20079912443594938, 0.1767195316506528, 0.2100714770883142, 0.20679909620987058, 0.20567301191987808, 0.18562020113765942, 0.9006950495231985, 0.18738257642333722, 0.19867389899215226, 0.8150579646182925, 0.16742405140927274, 0.15862649629288683, 0.831630416362783, 0.1725256200525419, 0.5168192936904756, 0.6103734839576287, 0.21034181966525933, 0.2060260201875872, 0.20841116338737842, 0.127236402981593, 0.5723935608268631, 0.16462099359364324, 0.15649148875025998, 0.1841075584937969, 0.20078136153572357, 0.20623262469498438, 0.17499032801070658, 0.18309666275780934, 0.196981904675414, 0.18363809420277366, 0.2133216137406897, 0.20075732296650806, 0.08793499216210932, 0.100791658706742, 0.09052924853055067, 0.10122717982680152, 0.10245902178837474, 0.10244969560215722, 0.08611385953333428, 0.1077180694369978, 0.08790228678535428]}, "mutation_prompt": null}
{"id": "2eb39560-08ad-49b0-ae9c-e39a6054add7", "solution": "import numpy as np\n\nclass ImprovedAdaptiveHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5\n        self.cr = 0.9\n        self.w = np.random.uniform(0.4, 0.7)  # Adjusted inertia weight range\n        self.c1 = np.random.uniform(1.4, 2.4)  # Adjusted cognitive coefficient\n        self.c2 = np.random.uniform(1.2, 2.2)  # Adjusted social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with enhanced exploration\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.3, 0.8)  # More dynamic scaling factor\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization with dynamic inertia\n            self.w = np.random.uniform(0.4, 0.7 - 0.3 * (budget_used / self.budget))  # Dynamic inertia update\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "ImprovedAdaptiveHybridDEPSO", "description": "ImprovedAdaptiveHybridDEPSO with enhanced exploration-exploitation balance and dynamic inertia adjustment for better convergence.", "configspace": "", "generation": 49, "fitness": 0.3205795939456748, "feedback": "The algorithm ImprovedAdaptiveHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "58c55633-10f1-4cfa-9e7d-61149acea5ee", "metadata": {"aucs": [0.7493150861781726, 0.8292174123885512, 0.815269349914004, 0.7723075269717791, 0.8155482078262364, 0.8110791732949104, 0.750439048484948, 0.8210420792863294, 0.8033904285911873, 0.5016958609449915, 0.6350807529490881, 0.612112408285074, 0.5365237499752588, 0.6416153562993323, 0.6143672886045467, 0.5197500932124075, 0.5982155302318066, 0.6042583074265219, 0.3092047458671665, 0.3194115543668651, 0.18362306679874396, 0.44030031727532937, 0.1564719798973072, 0.5948607441218743, 0.2860284529572855, 0.13328792513148346, 0.1489520608102961, 0.12473812334545642, 0.12643154200590911, 0.1440297581328448, 0.11373293806419893, 0.12791125365870337, 0.11055734306228682, 0.12102872311179746, 0.14457096577113004, 0.14393020339103368, 0.9676943173630406, 0.9542989075699843, 0.9461689898233453, 0.9551186411580213, 0.9367687313175451, 0.9403134336652292, 0.9680828573405789, 0.9501726720561852, 0.9467264975472316, 0.3934216349430508, 0.575020101735438, 0.5809131319708493, 0.3417852493595014, 0.58109456603635, 0.6241170624290004, 0.4028347158313652, 0.5757349461254511, 0.5840047675294379, 0.3509806871254998, 0.8354111351293482, 0.7765368299081906, 0.2531556672576346, 0.2615864217970063, 0.27014186002610374, 0.24383806366996774, 0.22802505171315313, 0.6931829719917353, 0.1759085504836032, 0.22331163504973273, 0.19204225068929714, 0.12752735323472242, 0.17645536153202068, 0.11634554020427912, 0.1283740028729644, 0.20005674974874343, 0.21174607528685607, 0.21324164543285962, 0.19812629507737023, 0.23385880978304707, 0.12103167488335931, 0.2315195428811616, 0.26452445662244994, 0.2099069780344841, 0.2380639977016734, 0.2545945980787284, 9.999999999998899e-05, 0.0020827556876179543, 9.999999999998899e-05, 0.01104517229340396, 0.03189081159283558, 0.004890935654809581, 9.999999999998899e-05, 9.999999999998899e-05, 0.1991002875213218, 0.12199257344795966, 0.1132863409695889, 0.08347448474425767, 0.1337900353778252, 0.07808680635413057, 0.03193544963776951, 0.06106986937561143, 0.08777595621543388, 0.11425563410760109, 0.1266590589519334, 0.029899723845734694, 0.14434555491982215, 0.07669276977959094, 0.07182373283757348, 0.19482604974752227, 0.13997998878142537, 0.13087575138733443, 0.2731513813204868, 0.08414452712905351, 0.14878205998044236, 0.23263698008215106, 0.09230498889882421, 0.24281737574980877, 0.06918160984161237, 0.07888079762388012, 0.19806495149136683, 0.07938388382999695, 0.4908499362962431, 0.5918513623878713, 0.5480025250763139, 0.524171656937436, 0.5842030407245546, 0.5421944662543596, 0.5176595536964992, 0.5832450080312938, 0.5494170533781524, 0.1027763758758965, 0.1106863413321274, 0.13646761929350937, 0.11117623660837084, 0.1274645720723745, 0.10625150387902271, 0.11011888037438078, 0.1316344089421969, 0.13862863279102489, 0.19791893286599438, 0.30940659839696827, 0.1970128660680861, 0.18160745662871958, 0.1721217627386068, 0.36514821760080773, 0.22404400945962077, 0.24321426351254272, 0.19360958909153236, 0.4021735439092823, 0.43424563258257587, 0.3929984045560144, 0.3972279180986831, 0.49757554240981205, 0.44809305107868036, 0.42252616674666177, 0.5285029521516095, 0.5211058985449254, 0.2850596267399975, 0.24498210088194305, 0.33200797510922053, 0.22014176656555606, 0.23911093460250432, 0.25321558970605884, 0.2463576610278937, 0.22857690509006434, 0.320992032066183, 0.20960220346550795, 0.22348606386183056, 0.2225029393273481, 0.19867497937966427, 0.19525744720976712, 0.2488852493949505, 0.20497864142730704, 0.19946202924329992, 0.24165818528549354, 0.20553456841563655, 0.19735465390760887, 0.2441643233323576, 0.18338735295577158, 0.19943239077066122, 0.6628971725614008, 0.41086549482104917, 0.20087194288401622, 0.2070863528345408, 0.17046236534434778, 0.18671824837985895, 0.1868305937723942, 0.1973424789157311, 0.8427533870088603, 0.16723633275966676, 0.17056218831813408, 0.8895016779227848, 0.8822849661151313, 0.12689975625105276, 0.6484094459797491, 0.21042795801115843, 0.16797913516649043, 0.21267769981236084, 0.7948996370107679, 0.6587917136968291, 0.6350626663363493, 0.1560700787197853, 0.1938904375265098, 0.20110309874425758, 0.19049520285309907, 0.17998831280461713, 0.1950789476034155, 0.19295835781116089, 0.19098829179896282, 0.21239059282666517, 0.18102952911727865, 0.08487269841244438, 0.10749572500786564, 0.10174813797006954, 0.10778773231089112, 0.09816097555609649, 0.12575256540972768, 0.08903390056880489, 0.09969086519383052, 0.12234494013704755]}, "mutation_prompt": null}
{"id": "e4a7bd8e-7dc3-4330-9233-a6ff8f3db0c0", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with dynamic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.5, 0.8)  # Adjusted dynamic scaling factor\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            if np.std(fitness) < 0.001:  # Diversity maintenance condition\n                velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Reinitialize velocities\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Improved EnhancedHybridDEPSO with diversity maintenance and adaptive parameter tuning for robust convergence.", "configspace": "", "generation": 50, "fitness": 0.2872170717393626, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "58c55633-10f1-4cfa-9e7d-61149acea5ee", "metadata": {"aucs": [0.5814569765164939, 0.6157387150494165, 0.5416522664313929, 0.5552041159765371, 0.5693194703404045, 0.5675775140408199, 0.5336802873879403, 0.5486249192632053, 0.5325980420071816, 0.46785850455274336, 0.4983371376530076, 0.4189853343283184, 0.40340537451052016, 0.48565358463079034, 0.45257293243711527, 0.4298297256694592, 0.4808592057362303, 0.4426897388764274, 0.13844304236844296, 0.15199681776134588, 0.48595778903591913, 0.1618574126353145, 0.17981722006793444, 0.13310511016724325, 0.13973831080424315, 0.15023188233719953, 0.15148807472654113, 0.1334676017933102, 0.10775955408143922, 0.14036635822200327, 0.11263387689947957, 0.13568613862402368, 0.12352463981671002, 0.13436216521029198, 0.1154260976332907, 0.10068099698708544, 0.9472300079051084, 0.9359462116952888, 0.958548081941613, 0.9561318618668594, 0.9309665363667167, 0.9625011197433668, 0.9658941005592317, 0.9550509420740462, 0.9544088593168787, 0.45090758805286224, 0.4999878927594442, 0.5054456479701241, 0.46224865060610587, 0.5295168508510654, 0.48381902287186407, 0.4276542849713917, 0.46968781925428205, 0.54160092377242, 0.7585853538829309, 0.3874614225246782, 0.7991470824570881, 0.43061533046628087, 0.2789937471707786, 0.29888252564042406, 0.24516803227928108, 0.7961922764330585, 0.384398909054221, 0.16170250148050724, 0.20279835731748186, 0.12033937103020087, 0.18087417450034882, 0.1805865255970388, 0.1294061337034771, 0.47328704024833657, 0.15837504816316017, 0.24006198728254902, 0.2090334012619084, 0.2046235312183291, 0.20449337966754488, 0.19563863193401954, 0.25102575477736777, 0.21262793146980297, 0.18947942314746513, 0.1630577071459478, 0.27403038235070676, 0.009829841736629485, 0.056922329383334525, 0.007945049944960925, 0.00022070513332583808, 9.999999999998899e-05, 0.03829169339828642, 0.04856095099494451, 0.006202017964562989, 9.999999999998899e-05, 0.14243441285098235, 0.11594036072458058, 0.05492996731380151, 0.09041112496178338, 0.0770719984120618, 0.09528695215214744, 0.05447551069779488, 0.10946348109907578, 0.13150998977702, 0.06521618004204521, 0.08504304489773096, 0.07612221954047049, 0.15953555444404388, 0.14885299380146066, 0.11969309398508776, 0.10492566200699982, 0.09735625025864536, 0.18048023659944956, 0.1772663501035584, 0.1713472453783259, 0.22864329608330392, 0.10740276079069266, 0.15499180609000174, 0.17843577375112796, 0.2687812288498771, 0.17168282648515576, 0.22607114851045562, 0.5161866547077589, 0.5430562173813405, 0.5048869161315745, 0.4944564277090787, 0.5388591994160263, 0.5002401916872959, 0.5444644694816156, 0.5718383579978392, 0.47447613596783367, 0.11128322935709278, 0.11145166334773948, 0.15230066851844803, 0.14153561208303178, 0.14768434300083666, 0.09573883521459936, 0.14430189501217427, 0.10775219089480703, 0.09074337666436028, 0.2753881842935775, 0.2654974099027826, 0.15895366495134144, 0.27953900296486456, 0.22638471840385055, 0.24617296592865456, 0.22517102505420472, 0.22098420496079196, 0.3384557981769951, 0.34310354459609005, 0.36357236777534796, 0.36793901507372717, 0.2806529372017986, 0.30710489374090055, 0.4370052156500124, 0.4316693178527554, 0.45145349066855645, 0.4496876976921229, 0.33249039333544006, 0.26109055522985736, 0.24795806888444827, 0.23028787620137614, 0.28863122892984316, 0.27349553147757677, 0.3241293851629319, 0.22868934791625006, 0.19985575778968734, 0.19533616760367456, 0.21085300811401975, 0.2497499031323691, 0.2024457905840974, 0.24303280139540262, 0.21317729057352408, 0.2336255841410081, 0.23992710952525886, 0.24076004913387228, 0.21737934705122486, 0.21841097088403905, 0.18306080169867645, 0.20882945672376596, 0.21881285016513075, 0.18049740682684057, 0.21742397504105315, 0.21545729961709426, 0.24547404599857314, 0.18647919525500245, 0.6607859193874807, 0.18717857641311775, 0.19770921214517068, 0.1605608229149178, 0.16782503955208428, 0.15884420048709214, 0.1690593214153594, 0.17775875159251953, 0.12634024302584512, 0.5437909022905678, 0.2108734664959634, 0.16764769750801167, 0.20866963332581645, 0.1268086105320062, 0.6125811848876015, 0.1678417975505868, 0.7101212869689859, 0.17709481170931285, 0.18712297458739613, 0.20904128564008417, 0.18204009676352773, 0.18705299949093002, 0.19365296330411907, 0.19246089170529568, 0.185927844289126, 0.1861575207641245, 0.08405014459846405, 0.09569229775638888, 0.09723013603027408, 0.12137354367646913, 0.08710534019248894, 0.09521709585865734, 0.09460360303179605, 0.09950653127048681, 0.0892443531592444]}, "mutation_prompt": null}
{"id": "8d365a1b-4f7c-4f07-bc6e-2142109f98e8", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5\n        self.cr = 0.9\n        self.w = 0.5  # Fixed inertia weight for better stability\n        self.c1 = 2.0  # Fixed cognitive coefficient\n        self.c2 = 2.0  # Fixed social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with adaptive mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.5, 0.8)  # Adjusted scaling factor range\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization with dynamic inertia weight\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.w = 0.5 + 0.5 * (1 - (budget_used / self.budget))  # Dynamic inertia weight\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Enhanced Hybrid DEPSO with improved exploration-exploitation balance through adaptive DE mutation and dynamic PSO weight adjustments.", "configspace": "", "generation": 51, "fitness": 0.19679051136542913, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.20.", "error": "", "parent_id": "58c55633-10f1-4cfa-9e7d-61149acea5ee", "metadata": {"aucs": [0.36594014740586167, 0.37939662862589085, 0.3910923221954097, 0.37855089491145355, 0.3836688827147612, 0.3649586702334181, 0.35898231866247654, 0.37870658281680813, 0.3865363557033453, 0.051464420120147625, 0.056508137273651116, 0.014567180379067346, 0.021326520812507077, 0.04131719136545875, 0.04599826028541343, 0.061178777849724475, 0.005210768681202738, 0.05297098946359824, 0.08454431818379293, 0.0963155371026182, 0.08725497515223524, 0.10234297854772956, 0.08896898241963846, 0.09155674504927414, 0.09534887619163634, 0.10650149433146161, 0.09737182519267462, 0.09036586955773762, 0.09932295556902826, 0.09098603164268737, 0.08561155552637756, 0.08187132941928177, 0.0795490296981397, 0.08944806573322561, 0.08610971325261163, 0.07417364769635093, 0.9582442394303491, 0.9635825998566043, 0.9638525477199472, 0.9625764153143019, 0.9592612086647471, 0.9737229879286369, 0.9631524156152862, 0.9516980548514993, 0.9649197498558224, 0.21666846784663718, 0.2162647170512364, 0.19910656326653797, 0.20630417947064328, 0.14229665930391733, 0.14423763811193935, 0.21731913579832574, 0.22982372994067368, 0.08708386728513617, 0.23542290472148242, 0.30309448960614693, 0.2592176419828057, 0.1902152757313973, 0.26748815005313253, 0.18166443470214055, 0.2915628862296866, 0.2776993013945117, 0.26475949420017164, 0.12353127499231031, 0.1150217599784128, 0.11988531618393883, 0.1212016135010412, 0.11161910422954702, 0.0943124031318866, 0.13356169839886256, 0.11697913501076729, 0.11834190165305358, 0.11876913575506953, 0.10703569674598767, 0.13346471550524053, 0.12891809128860277, 0.10872498993997781, 0.12843940804818654, 0.13602233931558183, 0.1267699726988023, 0.10146821988159138, 9.999999999998899e-05, 9.999999999998899e-05, 0.00017345642919663895, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0062374440755618155, 0.007114036400145074, 0.02845954686948937, 0.07632644536295374, 0.07555103020591591, 0.09833022340946806, 0.11902272347033926, 0.09294376096819812, 0.05497619175367219, 0.11255424461033547, 0.02934715504006269, 0.008566384644553393, 9.999999999998899e-05, 9.999999999998899e-05, 0.002985489161545729, 0.013365761276665555, 0.000248917495928036, 0.011170248859599274, 0.007346875605939718, 0.005810424606365605, 0.056520885426692424, 0.06931201820082211, 0.0573350387332191, 0.05215130623569586, 0.057437399229340325, 0.0536270504254579, 0.06651309900076008, 0.04389624056178143, 0.05638743683799663, 0.35429776783542133, 0.35650559039541896, 0.3711900510603373, 0.34527526086622606, 0.3484197523085496, 0.36389770556223244, 0.3521471476711524, 0.3327012062086325, 0.35733755529054156, 0.08730741645912454, 0.08526147412091944, 0.08758272204194906, 0.08641141853869072, 0.10551473202775874, 0.10203294075734881, 0.09985840847943184, 0.09082592419380597, 0.09042784375009127, 0.17208766973164125, 0.16908881160175493, 0.15665098889648765, 0.17434643442088582, 0.1410483460677202, 0.16427831242760127, 0.15724471068714996, 0.16904899468400003, 0.17230563655841358, 0.26591587343843437, 0.253150196497007, 0.23554908475202452, 0.2482756153578235, 0.25471547663666794, 0.24954791300191315, 0.24579857527954763, 0.24525368319235807, 0.2579447605877253, 0.19244821752184127, 0.19029384034431573, 0.2153812287644088, 0.19360745003856272, 0.2096482853754722, 0.19477477090892859, 0.18992369028385703, 0.1852340175159396, 0.17007051587853927, 0.2175548386925804, 0.19134533890497452, 0.21667566282260609, 0.21452590156529838, 0.21965709200907624, 0.18057291901923234, 0.1925462141479225, 0.20798053760647484, 0.21491724741034457, 0.18860220411608264, 0.21140050684091216, 0.1793362424508601, 0.1973515149541818, 0.20277478313783148, 0.18222266719745306, 0.1769595443833608, 0.1935440398255569, 0.17024553076560756, 0.18316366776448345, 0.46506494140422405, 0.15077089017724832, 0.19026919853304536, 0.18944452060688766, 0.542420325429378, 0.5122187866262555, 0.15719181157511863, 0.5335255777944814, 0.44100881520116264, 0.1997072861095769, 0.2924176474839384, 0.3395804470925544, 0.19688623066871036, 0.31579219653368695, 0.37314671104471764, 0.4491742321141503, 0.1608237698347188, 0.2013624555772935, 0.19015162379434136, 0.20126274225118823, 0.1811142293655057, 0.18689403282811667, 0.18711016687011373, 0.18401706259933015, 0.18293148497240552, 0.18748033993683388, 0.07248584443624773, 0.08321959416036329, 0.07189363589688169, 0.08234854738537545, 0.08253038783764877, 0.07132812336682715, 0.07463884294273138, 0.07350819004137843, 0.0851889439497896]}, "mutation_prompt": null}
{"id": "f3e5c538-5624-43e7-b813-d1deb5117d69", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        restart_threshold = 0.1 * self.budget  # Adding restart mechanism\n        last_improvement = 0  # Track steps since last improvement\n\n        while budget_used < self.budget:\n            # Differential Evolution with dynamic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.4, 0.9)  # Dynamic scaling factor\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n                            last_improvement = budget_used\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n                        last_improvement = budget_used\n\n            if budget_used - last_improvement > restart_threshold:  # Restart if no improvement\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n                velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                personal_best = population.copy()\n                personal_best_fitness = fitness.copy()\n                global_best_idx = np.argmin(fitness)\n                global_best = population[global_best_idx].copy()\n                last_improvement = budget_used\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with adaptive restart mechanism and improved velocity handling for faster convergence.", "configspace": "", "generation": 52, "fitness": 0.323644927087429, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "58c55633-10f1-4cfa-9e7d-61149acea5ee", "metadata": {"aucs": [0.8096940132456864, 0.8783704304557981, 0.8543492183114244, 0.8195770914487226, 0.8653949639031051, 0.8442028959929802, 0.7939809193691281, 0.8730990253091601, 0.8555038588158299, 0.5860160189923068, 0.727239092036281, 0.6944788983715643, 9.999999999998899e-05, 0.7247574775565298, 0.7088414552973993, 0.5505389141201504, 0.6889405116587493, 0.7016120447271142, 0.15765467626353602, 0.14733126911351213, 0.14125279294110515, 0.1374432112208417, 0.12795052133239737, 0.12992273171947522, 0.14762387843080438, 0.14157717241732792, 0.1366439682403312, 0.10342055378627846, 0.12387779979324709, 0.11135341110135122, 0.11788219861591409, 0.14783232367322385, 0.11071697493867427, 0.11622359490675083, 0.10122003920541611, 0.14418885202462717, 0.9440177485571697, 0.9404509236189162, 0.9547936901632903, 0.9585930990925834, 0.9554321964573628, 0.9634984535222196, 0.9641769553953, 0.947509882786065, 0.9451965311177623, 0.42900744581600325, 0.6729157157273042, 0.6587874446887421, 0.4277630173311642, 0.6864402029191414, 0.6547235059170867, 0.3823310054853981, 0.6876644795498377, 0.6633986646366832, 0.3426325357917833, 0.6263172729316377, 0.8602766216309361, 0.789615624840504, 0.5333725153525538, 0.6620843554114049, 0.8372744524357343, 0.39103535027526437, 0.4044326248077674, 0.17232747085090283, 0.13155029090899206, 0.12265060525324456, 0.18405741025950262, 0.16052263056687965, 0.12347037644987635, 0.20350431529440327, 0.23814144348122712, 0.2054606761068425, 0.13837171866716802, 0.13823362806847272, 0.2017068464755425, 0.20257368568376455, 0.19048965065710188, 0.2906076042153215, 0.23774756984350975, 0.17362496405020267, 0.19132872853057026, 9.999999999998899e-05, 0.045080276114794704, 0.010076807114453357, 0.0002725927853840515, 9.999999999998899e-05, 0.02489119605309098, 9.999999999998899e-05, 0.07357072131995168, 0.007480143679416296, 0.12583909422263184, 0.12493314006829481, 0.08666559111493932, 0.0820378337574621, 0.06025493145370742, 0.06069282598704995, 0.1325615921082577, 0.11396217255983632, 0.13416464369392833, 0.12408235539614965, 0.05849247727230089, 0.11905184872024588, 0.11838273107405695, 0.07830328449420454, 0.19481208691786, 0.20077155403040392, 0.09495378433488799, 0.16325252154605074, 0.09162912884097318, 0.4303301709435754, 0.11618298938284932, 0.11275091178091168, 0.0834725829657611, 0.18197270092520113, 0.048703489356305196, 0.13670957558288754, 0.08257134847308056, 0.5547650896202186, 0.5384895281381323, 0.5326511720933338, 0.4984722622020963, 0.5698052009090522, 0.5523876803580716, 0.5379490784840637, 0.5947851507608362, 0.5620804754909198, 0.1476847586742016, 0.14710523759361716, 0.1354032617870201, 0.3950602627102787, 0.13942955616443165, 0.1524152948860581, 0.14640520379123423, 0.15015503102218986, 0.10743701519285809, 0.1669130494864921, 0.19310173329770064, 0.5835892531575861, 0.19240110530464583, 0.13765462514257087, 0.5332691430840195, 0.23730766622157096, 0.21668671480720247, 0.4299750477043235, 0.39805154473850635, 0.5879621496359073, 0.4752679258572331, 0.4192141874562647, 0.3771399409093713, 0.5201811329089108, 0.4607404902068082, 0.24263403848513931, 0.5698958477385827, 0.3513126405705356, 0.3191010739807473, 0.37529406249084196, 0.3325561926152871, 0.23346837050109048, 0.18957974427040403, 0.34363047763518195, 0.18912077590050114, 0.2845817368452864, 0.2094963686201008, 0.21352401724136194, 0.2209222779944272, 0.22796510676368786, 0.21490462426399248, 0.20783878711307313, 0.21655061262743525, 0.21834541187302658, 0.23948031329140074, 0.21996591113455877, 0.2037167364393505, 0.22090542070215324, 0.21555590293682148, 0.20079912443594938, 0.18394967570095266, 0.20984048614347617, 0.20679909620987058, 0.20653661750823527, 0.18562020113765942, 0.9006950495231985, 0.18948736848122172, 0.19867389899215226, 0.8150579646182925, 0.16742405140927274, 0.1588548775402645, 0.831630416362783, 0.1725256200525419, 0.5168192936904756, 0.5778858604791095, 0.21034181966525933, 0.2060260201875872, 0.20841116338737842, 0.12966579566994663, 0.44349438710618194, 0.16462099359364324, 0.23703359765565546, 0.17907961218558743, 0.1872932283541363, 0.2070435953132307, 0.17915051761579603, 0.1858030446801825, 0.18170748068768272, 0.17729866268039574, 0.1864353946412538, 0.19481172996820995, 0.08493388322129358, 0.09313395138207559, 0.09337770137018653, 0.09842958753274778, 0.0938919269522892, 0.08896120189612922, 0.0865255806775409, 0.10063805528515146, 0.0841784600261739]}, "mutation_prompt": null}
{"id": "ff7434d9-6f3c-4613-9856-65dfb32ccba8", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with dynamic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.4, 0.9)  # Dynamic scaling factor\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with adaptive parameters and dynamic mutation strategy for improved convergence.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "58c55633-10f1-4cfa-9e7d-61149acea5ee", "metadata": {"aucs": [0.8096940132456864, 0.8783704304557981, 0.8543492183114244, 0.8195770914487226, 0.8653949639031051, 0.8442028959929802, 0.7939809193691281, 0.8730990253091601, 0.8555038588158299, 0.5860160189923068, 0.727239092036281, 0.6944788983715643, 9.999999999998899e-05, 0.7247574775565298, 0.7088414552973993, 0.5505389141201504, 0.6889405116587493, 0.7016120447271142, 0.15765467626353602, 0.14733126911351213, 0.14125279294110515, 0.1374432112208417, 0.12795052133239737, 0.12992273171947522, 0.14762387843080438, 0.14157717241732792, 0.14937934049102297, 0.10342055378627846, 0.12387779979324709, 0.11135341110135122, 0.11993941449443535, 0.15251154063369665, 0.11071697493867427, 0.11622672320350069, 0.10122003920541611, 0.14418885202462717, 0.9440177485571697, 0.9404509236189162, 0.9547936901632903, 0.9585930990925834, 0.9554321964573628, 0.9634984535222196, 0.9641769553953, 0.947509882786065, 0.9451965311177623, 0.4670515375975599, 0.6729157157273042, 0.6587874446887421, 0.4747110428656519, 0.6864402029191414, 0.6547235059170867, 0.45349715518547473, 0.6876644795498377, 0.6633986646366832, 0.6947720342452942, 0.37941439736363736, 0.8602766216309361, 0.789615624840504, 0.3770723310757488, 0.37404249292678216, 0.8372744524357343, 0.21230939035072804, 0.2211748002847428, 0.20457723809562944, 0.13155029090899206, 0.12265060525324456, 0.18405741025950262, 0.16052263056687965, 0.12347037644987635, 0.20463596255927186, 0.23814144348122712, 0.2054606761068425, 0.12918327606683233, 0.13823362806847272, 0.2017068464755425, 0.20257368568376455, 0.19048965065710188, 0.2906076042153215, 0.23774756984350975, 0.17362496405020267, 0.19132872853057026, 9.999999999998899e-05, 0.045098163075595, 0.05118276552907686, 9.999999999998899e-05, 9.999999999998899e-05, 0.02489190772103378, 0.011706543670382041, 0.07423615437106379, 9.999999999998899e-05, 0.15003530465346482, 0.1354481700462702, 0.09779135582524645, 0.08691120693019916, 0.07089861141938059, 0.06218839463619674, 0.13562397540999827, 0.12111350189643966, 0.15343968508636785, 0.12408235539614965, 0.05849247727230089, 0.11905184872024588, 0.11838274188650644, 0.07830328449420454, 0.19481208691786, 0.20077155403040392, 0.09495378433488799, 0.16325252154605074, 0.09162912884097318, 0.4303301709435754, 0.11618298938284932, 0.11275091178091168, 0.0834725829657611, 0.18197270092520113, 0.04870209832155159, 0.13670957558288754, 0.08257134847308056, 0.5547650896202186, 0.5450756643889382, 0.5326511720933338, 0.4984722622020963, 0.5782402899292003, 0.5549193045263602, 0.5457199826549551, 0.5972870067402829, 0.5620804754909198, 0.12401883996989327, 0.14710523759361716, 0.1354032617870201, 0.3950602627102787, 0.13942955616443165, 0.1524152948860581, 0.14640725646204322, 0.15015503102218986, 0.10743701519285809, 0.1669130494864921, 0.33367318617286834, 0.5835892531575861, 0.2009441326403667, 0.1732113372052687, 0.5332691430840195, 0.25522608427625926, 0.19736088320192136, 0.4299750477043235, 0.39805154473850635, 0.5879621496359073, 0.4755260985926142, 0.4192141874562647, 0.3771436877620673, 0.5201811329089108, 0.4607404902068082, 0.24263403848513931, 0.5698958477385827, 0.3523612197145459, 0.3191010739807473, 0.37529406249084196, 0.3325561926152871, 0.25234887657199867, 0.18957974427040403, 0.34377567195031444, 0.1921105479602897, 0.2845817368452864, 0.22110688553147695, 0.2523760820734515, 0.23288911369165832, 0.22410292149057354, 0.22645442762058032, 0.21805579472864678, 0.24422731869679026, 0.1862666907606002, 0.2601076866669271, 0.21996591113455877, 0.2037167364393505, 0.22090542070215324, 0.21555590293682148, 0.20079912443594938, 0.1767195316506528, 0.2100714770883142, 0.20679909620987058, 0.20567301191987808, 0.18562020113765942, 0.9006950495231985, 0.18738257642333722, 0.19867389899215226, 0.8150579646182925, 0.16742405140927274, 0.15862649629288683, 0.831630416362783, 0.1725256200525419, 0.5168192936904756, 0.6103734839576287, 0.21034181966525933, 0.2060260201875872, 0.20841116338737842, 0.127236402981593, 0.5723935608268631, 0.16462099359364324, 0.15649148875025998, 0.1841075584937969, 0.20078136153572357, 0.20623262469498438, 0.17499032801070658, 0.18309666275780934, 0.196981904675414, 0.18363809420277366, 0.2133216137406897, 0.20075732296650806, 0.08793499216210932, 0.100791658706742, 0.09052924853055067, 0.10122717982680152, 0.10245902178837474, 0.10244969560215722, 0.08611385953333428, 0.1077180694369978, 0.08790228678535428]}, "mutation_prompt": null}
{"id": "a149bd03-87e4-4c00-b777-ecb5d4b42348", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with dynamic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.4, 0.9)  # Dynamic scaling factor\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with adaptive parameters and dynamic mutation strategy for improved convergence.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "58c55633-10f1-4cfa-9e7d-61149acea5ee", "metadata": {"aucs": [0.8096940132456864, 0.8783704304557981, 0.8543492183114244, 0.8195770914487226, 0.8653949639031051, 0.8442028959929802, 0.7939809193691281, 0.8730990253091601, 0.8555038588158299, 0.5860160189923068, 0.727239092036281, 0.6944788983715643, 9.999999999998899e-05, 0.7247574775565298, 0.7088414552973993, 0.5505389141201504, 0.6889405116587493, 0.7016120447271142, 0.15765467626353602, 0.14733126911351213, 0.14125279294110515, 0.1374432112208417, 0.12795052133239737, 0.12992273171947522, 0.14762387843080438, 0.14157717241732792, 0.14937934049102297, 0.10342055378627846, 0.12387779979324709, 0.11135341110135122, 0.11993941449443535, 0.15251154063369665, 0.11071697493867427, 0.11622672320350069, 0.10122003920541611, 0.14418885202462717, 0.9440177485571697, 0.9404509236189162, 0.9547936901632903, 0.9585930990925834, 0.9554321964573628, 0.9634984535222196, 0.9641769553953, 0.947509882786065, 0.9451965311177623, 0.4670515375975599, 0.6729157157273042, 0.6587874446887421, 0.4747110428656519, 0.6864402029191414, 0.6547235059170867, 0.45349715518547473, 0.6876644795498377, 0.6633986646366832, 0.6947720342452942, 0.37941439736363736, 0.8602766216309361, 0.789615624840504, 0.3770723310757488, 0.37404249292678216, 0.8372744524357343, 0.21230939035072804, 0.2211748002847428, 0.20457723809562944, 0.13155029090899206, 0.12265060525324456, 0.18405741025950262, 0.16052263056687965, 0.12347037644987635, 0.20463596255927186, 0.23814144348122712, 0.2054606761068425, 0.12918327606683233, 0.13823362806847272, 0.2017068464755425, 0.20257368568376455, 0.19048965065710188, 0.2906076042153215, 0.23774756984350975, 0.17362496405020267, 0.19132872853057026, 9.999999999998899e-05, 0.045098163075595, 0.05118276552907686, 9.999999999998899e-05, 9.999999999998899e-05, 0.02489190772103378, 0.011706543670382041, 0.07423615437106379, 9.999999999998899e-05, 0.15003530465346482, 0.1354481700462702, 0.09779135582524645, 0.08691120693019916, 0.07089861141938059, 0.06218839463619674, 0.13562397540999827, 0.12111350189643966, 0.15343968508636785, 0.12408235539614965, 0.05849247727230089, 0.11905184872024588, 0.11838274188650644, 0.07830328449420454, 0.19481208691786, 0.20077155403040392, 0.09495378433488799, 0.16325252154605074, 0.09162912884097318, 0.4303301709435754, 0.11618298938284932, 0.11275091178091168, 0.0834725829657611, 0.18197270092520113, 0.04870209832155159, 0.13670957558288754, 0.08257134847308056, 0.5547650896202186, 0.5450756643889382, 0.5326511720933338, 0.4984722622020963, 0.5782402899292003, 0.5549193045263602, 0.5457199826549551, 0.5972870067402829, 0.5620804754909198, 0.12401883996989327, 0.14710523759361716, 0.1354032617870201, 0.3950602627102787, 0.13942955616443165, 0.1524152948860581, 0.14640725646204322, 0.15015503102218986, 0.10743701519285809, 0.1669130494864921, 0.33367318617286834, 0.5835892531575861, 0.2009441326403667, 0.1732113372052687, 0.5332691430840195, 0.25522608427625926, 0.19736088320192136, 0.4299750477043235, 0.39805154473850635, 0.5879621496359073, 0.4755260985926142, 0.4192141874562647, 0.3771436877620673, 0.5201811329089108, 0.4607404902068082, 0.24263403848513931, 0.5698958477385827, 0.3523612197145459, 0.3191010739807473, 0.37529406249084196, 0.3325561926152871, 0.25234887657199867, 0.18957974427040403, 0.34377567195031444, 0.1921105479602897, 0.2845817368452864, 0.22110688553147695, 0.2523760820734515, 0.23288911369165832, 0.22410292149057354, 0.22645442762058032, 0.21805579472864678, 0.24422731869679026, 0.1862666907606002, 0.2601076866669271, 0.21996591113455877, 0.2037167364393505, 0.22090542070215324, 0.21555590293682148, 0.20079912443594938, 0.1767195316506528, 0.2100714770883142, 0.20679909620987058, 0.20567301191987808, 0.18562020113765942, 0.9006950495231985, 0.18738257642333722, 0.19867389899215226, 0.8150579646182925, 0.16742405140927274, 0.15862649629288683, 0.831630416362783, 0.1725256200525419, 0.5168192936904756, 0.6103734839576287, 0.21034181966525933, 0.2060260201875872, 0.20841116338737842, 0.127236402981593, 0.5723935608268631, 0.16462099359364324, 0.15649148875025998, 0.1841075584937969, 0.20078136153572357, 0.20623262469498438, 0.17499032801070658, 0.18309666275780934, 0.196981904675414, 0.18363809420277366, 0.2133216137406897, 0.20075732296650806, 0.08793499216210932, 0.100791658706742, 0.09052924853055067, 0.10122717982680152, 0.10245902178837474, 0.10244969560215722, 0.08611385953333428, 0.1077180694369978, 0.08790228678535428]}, "mutation_prompt": null}
{"id": "96c99265-a663-44bf-b30a-0daed3cf4dd1", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = 0.9  # Increased inertia weight for exploration\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        # Chaotic population initialization\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.pop_size, self.dim)\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with dynamic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.4, 0.9)  # Dynamic scaling factor\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Refined EnhancedHybridDEPSO with adaptive inertia weight adjustment and enhanced exploration via chaotic initialization for improved performance.", "configspace": "", "generation": 55, "fitness": 0.18486306027956032, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": "58c55633-10f1-4cfa-9e7d-61149acea5ee", "metadata": {"aucs": [0.36778989384545435, 0.3146358048145732, 0.3425828646667296, 0.3465762733030999, 0.32714789381437015, 0.40931793199037647, 0.32265719087184186, 0.31234228609167136, 0.3883672530937803, 9.999999999998899e-05, 0.01229722407661904, 0.0020937426952010174, 0.0057835036530968775, 0.012256313744838931, 0.016387407953771582, 0.0025211031952552254, 0.030527575832903664, 0.028044395531637956, 0.08284823673639152, 0.07441216212136259, 0.09235011448012587, 0.0978106927199226, 0.09324365729105177, 0.08482952985650605, 0.07714354966518933, 0.09507233645861468, 0.10092571872104672, 0.08765299568642348, 0.07291200659899333, 0.08007073359969052, 0.08012752427880132, 0.0855990656874599, 0.07999319072075561, 0.07041526314019808, 0.07060094831969277, 0.08796954438516436, 0.9647987626834877, 0.9657230121538467, 0.9536908272365869, 0.9718564169153588, 0.9616005364145185, 0.9707562278301802, 0.957158680585031, 0.9549140460879316, 0.9594829840403178, 0.18101090781645846, 0.16297769507634186, 0.17263539379383275, 0.17777817389217232, 0.19566008505683075, 0.20211788798580843, 0.20006498349780666, 0.18269388390337482, 0.19938717088671587, 0.21369553214677228, 0.24496844477204482, 0.22014419816874187, 0.18512702736116515, 0.2781251945223884, 0.25975566707218645, 0.25762060616059457, 0.2276222045149453, 0.3112934595747332, 0.13420465865925157, 0.0894843518665921, 0.12628930956046136, 0.10577461723481374, 0.10809910043723248, 0.17193710845030086, 0.11704791826656313, 0.08806132743685524, 0.11989495593700739, 0.11126905011141064, 0.1157096860677691, 0.12004369045762164, 0.12671418160420322, 0.10590154277861552, 0.12709196637027798, 0.10608376053993385, 0.07909825186130182, 0.12224388077861437, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0034430228684705355, 9.999999999998899e-05, 0.06719858458460859, 0.06030692475659183, 0.0784681396813468, 0.08442225849481932, 0.03154883184792634, 0.07309591860103481, 0.09127982173181592, 0.08740784786464462, 0.13371655574854902, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03488098622103575, 0.04710452772874163, 0.08626207797258467, 0.06133889183955976, 0.03901201609654015, 0.060311726405485544, 0.040290182232617044, 0.0564253759578347, 0.05069159200009454, 0.30330072334773917, 0.30542231334804715, 0.3241603296350447, 0.31089513384628076, 0.3680165701584598, 0.31863941578002664, 0.3254779553845861, 0.35619519262856936, 0.37889615350792794, 0.08186140667180952, 0.08758669691448506, 0.07613287202131525, 0.09619999016046787, 0.10804296046660078, 0.081062435726444, 0.08304351819750444, 0.08715845156102497, 0.08385090534091211, 0.1624668921987883, 0.16050280612686052, 0.1300695615875186, 0.17664206009927108, 0.13651730088439795, 0.14288928689504243, 0.1612313839159495, 0.14039110300185353, 0.15514452671306422, 0.23171748613223564, 0.23142032749530617, 0.2595370189798436, 0.23407329535132115, 0.2553284828272615, 0.25532363750838116, 0.23612504897020803, 0.2358204010858611, 0.22972050124632803, 0.1994826632123029, 0.18734145171798489, 0.1787485883975356, 0.17013315383264838, 0.19969912803449996, 0.18793402671819093, 0.18703762874218433, 0.17545931936456094, 0.19141364568972452, 0.2007569221854758, 0.1802881757057717, 0.19183949985289916, 0.21361012885452124, 0.19487411300990476, 0.19344560495315732, 0.2015954447645657, 0.2020403433193234, 0.20302918100442358, 0.18331499134729767, 0.18252146704387573, 0.169909834211302, 0.18378560892364626, 0.17943638177755505, 0.18412242089109943, 0.18379354636962764, 0.18216769956427636, 0.18158864027596122, 0.17164500044454578, 0.17314806759014778, 0.18015098426833553, 0.16294297050421247, 0.16756714057516298, 0.40501911236796573, 0.16788198860557713, 0.15843157328770086, 0.41603583792898857, 0.20311686283694685, 0.43562113294899896, 0.3971356515528123, 0.16571151047755972, 0.20117212699972653, 0.3262137418804263, 0.35764151375870656, 0.34999024177049043, 0.1526743908435637, 0.18283156673122758, 0.18902873851136437, 0.1878618752768686, 0.1895164849050398, 0.18000820139316853, 0.1871024771893124, 0.17977802589456693, 0.19417527374597843, 0.18219087103383091, 0.07556953692368729, 0.07390555639329088, 0.07676357518442023, 0.08290342299636899, 0.07681996651532741, 0.08852519441377005, 0.07788808379216494, 0.08494412310141874, 0.07635386141438716]}, "mutation_prompt": null}
{"id": "7d8db966-1aa3-40e3-aee1-7c1bef6ff497", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with dynamic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.4, 0.9)  # Dynamic scaling factor\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with adaptive parameters and dynamic mutation strategy for improved convergence.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "58c55633-10f1-4cfa-9e7d-61149acea5ee", "metadata": {"aucs": [0.8096940132456864, 0.8783704304557981, 0.8543492183114244, 0.8195770914487226, 0.8653949639031051, 0.8442028959929802, 0.7939809193691281, 0.8730990253091601, 0.8555038588158299, 0.5860160189923068, 0.727239092036281, 0.6944788983715643, 9.999999999998899e-05, 0.7247574775565298, 0.7088414552973993, 0.5505389141201504, 0.6889405116587493, 0.7016120447271142, 0.15765467626353602, 0.14733126911351213, 0.14125279294110515, 0.1374432112208417, 0.12795052133239737, 0.12992273171947522, 0.14762387843080438, 0.14157717241732792, 0.14937934049102297, 0.10342055378627846, 0.12387779979324709, 0.11135341110135122, 0.11993941449443535, 0.15251154063369665, 0.11071697493867427, 0.11622672320350069, 0.10122003920541611, 0.14418885202462717, 0.9440177485571697, 0.9404509236189162, 0.9547936901632903, 0.9585930990925834, 0.9554321964573628, 0.9634984535222196, 0.9641769553953, 0.947509882786065, 0.9451965311177623, 0.4670515375975599, 0.6729157157273042, 0.6587874446887421, 0.4747110428656519, 0.6864402029191414, 0.6547235059170867, 0.45349715518547473, 0.6876644795498377, 0.6633986646366832, 0.6947720342452942, 0.37941439736363736, 0.8602766216309361, 0.789615624840504, 0.3770723310757488, 0.37404249292678216, 0.8372744524357343, 0.21230939035072804, 0.2211748002847428, 0.20457723809562944, 0.13155029090899206, 0.12265060525324456, 0.18405741025950262, 0.16052263056687965, 0.12347037644987635, 0.20463596255927186, 0.23814144348122712, 0.2054606761068425, 0.12918327606683233, 0.13823362806847272, 0.2017068464755425, 0.20257368568376455, 0.19048965065710188, 0.2906076042153215, 0.23774756984350975, 0.17362496405020267, 0.19132872853057026, 9.999999999998899e-05, 0.045098163075595, 0.05118276552907686, 9.999999999998899e-05, 9.999999999998899e-05, 0.02489190772103378, 0.011706543670382041, 0.07423615437106379, 9.999999999998899e-05, 0.15003530465346482, 0.1354481700462702, 0.09779135582524645, 0.08691120693019916, 0.07089861141938059, 0.06218839463619674, 0.13562397540999827, 0.12111350189643966, 0.15343968508636785, 0.12408235539614965, 0.05849247727230089, 0.11905184872024588, 0.11838274188650644, 0.07830328449420454, 0.19481208691786, 0.20077155403040392, 0.09495378433488799, 0.16325252154605074, 0.09162912884097318, 0.4303301709435754, 0.11618298938284932, 0.11275091178091168, 0.0834725829657611, 0.18197270092520113, 0.04870209832155159, 0.13670957558288754, 0.08257134847308056, 0.5547650896202186, 0.5450756643889382, 0.5326511720933338, 0.4984722622020963, 0.5782402899292003, 0.5549193045263602, 0.5457199826549551, 0.5972870067402829, 0.5620804754909198, 0.12401883996989327, 0.14710523759361716, 0.1354032617870201, 0.3950602627102787, 0.13942955616443165, 0.1524152948860581, 0.14640725646204322, 0.15015503102218986, 0.10743701519285809, 0.1669130494864921, 0.33367318617286834, 0.5835892531575861, 0.2009441326403667, 0.1732113372052687, 0.5332691430840195, 0.25522608427625926, 0.19736088320192136, 0.4299750477043235, 0.39805154473850635, 0.5879621496359073, 0.4755260985926142, 0.4192141874562647, 0.3771436877620673, 0.5201811329089108, 0.4607404902068082, 0.24263403848513931, 0.5698958477385827, 0.3523612197145459, 0.3191010739807473, 0.37529406249084196, 0.3325561926152871, 0.25234887657199867, 0.18957974427040403, 0.34377567195031444, 0.1921105479602897, 0.2845817368452864, 0.22110688553147695, 0.2523760820734515, 0.23288911369165832, 0.22410292149057354, 0.22645442762058032, 0.21805579472864678, 0.24422731869679026, 0.1862666907606002, 0.2601076866669271, 0.21996591113455877, 0.2037167364393505, 0.22090542070215324, 0.21555590293682148, 0.20079912443594938, 0.1767195316506528, 0.2100714770883142, 0.20679909620987058, 0.20567301191987808, 0.18562020113765942, 0.9006950495231985, 0.18738257642333722, 0.19867389899215226, 0.8150579646182925, 0.16742405140927274, 0.15862649629288683, 0.831630416362783, 0.1725256200525419, 0.5168192936904756, 0.6103734839576287, 0.21034181966525933, 0.2060260201875872, 0.20841116338737842, 0.127236402981593, 0.5723935608268631, 0.16462099359364324, 0.15649148875025998, 0.1841075584937969, 0.20078136153572357, 0.20623262469498438, 0.17499032801070658, 0.18309666275780934, 0.196981904675414, 0.18363809420277366, 0.2133216137406897, 0.20075732296650806, 0.08793499216210932, 0.100791658706742, 0.09052924853055067, 0.10122717982680152, 0.10245902178837474, 0.10244969560215722, 0.08611385953333428, 0.1077180694369978, 0.08790228678535428]}, "mutation_prompt": null}
{"id": "4b224b34-7ef9-47a1-a6e7-1ec6f3a3f33b", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with dynamic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.4, 0.9)  # Dynamic scaling factor\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with adaptive parameters and dynamic mutation strategy for improved convergence.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "58c55633-10f1-4cfa-9e7d-61149acea5ee", "metadata": {"aucs": [0.8096940132456864, 0.8783704304557981, 0.8543492183114244, 0.8195770914487226, 0.8653949639031051, 0.8442028959929802, 0.7939809193691281, 0.8730990253091601, 0.8555038588158299, 0.5860160189923068, 0.727239092036281, 0.6944788983715643, 9.999999999998899e-05, 0.7247574775565298, 0.7088414552973993, 0.5505389141201504, 0.6889405116587493, 0.7016120447271142, 0.15765467626353602, 0.14733126911351213, 0.14125279294110515, 0.1374432112208417, 0.12795052133239737, 0.12992273171947522, 0.14762387843080438, 0.14157717241732792, 0.14937934049102297, 0.10342055378627846, 0.12387779979324709, 0.11135341110135122, 0.11993941449443535, 0.15251154063369665, 0.11071697493867427, 0.11622672320350069, 0.10122003920541611, 0.14418885202462717, 0.9440177485571697, 0.9404509236189162, 0.9547936901632903, 0.9585930990925834, 0.9554321964573628, 0.9634984535222196, 0.9641769553953, 0.947509882786065, 0.9451965311177623, 0.4670515375975599, 0.6729157157273042, 0.6587874446887421, 0.4747110428656519, 0.6864402029191414, 0.6547235059170867, 0.45349715518547473, 0.6876644795498377, 0.6633986646366832, 0.6947720342452942, 0.37941439736363736, 0.8602766216309361, 0.789615624840504, 0.3770723310757488, 0.37404249292678216, 0.8372744524357343, 0.21230939035072804, 0.2211748002847428, 0.20457723809562944, 0.13155029090899206, 0.12265060525324456, 0.18405741025950262, 0.16052263056687965, 0.12347037644987635, 0.20463596255927186, 0.23814144348122712, 0.2054606761068425, 0.12918327606683233, 0.13823362806847272, 0.2017068464755425, 0.20257368568376455, 0.19048965065710188, 0.2906076042153215, 0.23774756984350975, 0.17362496405020267, 0.19132872853057026, 9.999999999998899e-05, 0.045098163075595, 0.05118276552907686, 9.999999999998899e-05, 9.999999999998899e-05, 0.02489190772103378, 0.011706543670382041, 0.07423615437106379, 9.999999999998899e-05, 0.15003530465346482, 0.1354481700462702, 0.09779135582524645, 0.08691120693019916, 0.07089861141938059, 0.06218839463619674, 0.13562397540999827, 0.12111350189643966, 0.15343968508636785, 0.12408235539614965, 0.05849247727230089, 0.11905184872024588, 0.11838274188650644, 0.07830328449420454, 0.19481208691786, 0.20077155403040392, 0.09495378433488799, 0.16325252154605074, 0.09162912884097318, 0.4303301709435754, 0.11618298938284932, 0.11275091178091168, 0.0834725829657611, 0.18197270092520113, 0.04870209832155159, 0.13670957558288754, 0.08257134847308056, 0.5547650896202186, 0.5450756643889382, 0.5326511720933338, 0.4984722622020963, 0.5782402899292003, 0.5549193045263602, 0.5457199826549551, 0.5972870067402829, 0.5620804754909198, 0.12401883996989327, 0.14710523759361716, 0.1354032617870201, 0.3950602627102787, 0.13942955616443165, 0.1524152948860581, 0.14640725646204322, 0.15015503102218986, 0.10743701519285809, 0.1669130494864921, 0.33367318617286834, 0.5835892531575861, 0.2009441326403667, 0.1732113372052687, 0.5332691430840195, 0.25522608427625926, 0.19736088320192136, 0.4299750477043235, 0.39805154473850635, 0.5879621496359073, 0.4755260985926142, 0.4192141874562647, 0.3771436877620673, 0.5201811329089108, 0.4607404902068082, 0.24263403848513931, 0.5698958477385827, 0.3523612197145459, 0.3191010739807473, 0.37529406249084196, 0.3325561926152871, 0.25234887657199867, 0.18957974427040403, 0.34377567195031444, 0.1921105479602897, 0.2845817368452864, 0.22110688553147695, 0.2523760820734515, 0.23288911369165832, 0.22410292149057354, 0.22645442762058032, 0.21805579472864678, 0.24422731869679026, 0.1862666907606002, 0.2601076866669271, 0.21996591113455877, 0.2037167364393505, 0.22090542070215324, 0.21555590293682148, 0.20079912443594938, 0.1767195316506528, 0.2100714770883142, 0.20679909620987058, 0.20567301191987808, 0.18562020113765942, 0.9006950495231985, 0.18738257642333722, 0.19867389899215226, 0.8150579646182925, 0.16742405140927274, 0.15862649629288683, 0.831630416362783, 0.1725256200525419, 0.5168192936904756, 0.6103734839576287, 0.21034181966525933, 0.2060260201875872, 0.20841116338737842, 0.127236402981593, 0.5723935608268631, 0.16462099359364324, 0.15649148875025998, 0.1841075584937969, 0.20078136153572357, 0.20623262469498438, 0.17499032801070658, 0.18309666275780934, 0.196981904675414, 0.18363809420277366, 0.2133216137406897, 0.20075732296650806, 0.08793499216210932, 0.100791658706742, 0.09052924853055067, 0.10122717982680152, 0.10245902178837474, 0.10244969560215722, 0.08611385953333428, 0.1077180694369978, 0.08790228678535428]}, "mutation_prompt": null}
{"id": "a23b1554-338f-408b-958e-450accc81528", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5\n        self.cr = 0.9\n        self.w = 0.6  # Fixed initial inertia weight\n        self.c1 = np.random.uniform(1.5, 2.5)\n        self.c2 = np.random.uniform(1.0, 2.0)\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with dynamic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.4, 0.9)\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization with adaptive inertia weight and local search\n            self.w = 0.9 - 0.5 * (budget_used / self.budget)  # Adaptive inertia weight\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n                # Local search strategy\n                if np.random.rand() < 0.1 and budget_used < self.budget:  # Perform local search with low probability\n                    local_ind = population[i] + np.random.normal(0, 0.1, self.dim)\n                    local_ind = np.clip(local_ind, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_ind)\n                    budget_used += 1\n                    if local_fitness < fitness[i]:\n                        fitness[i] = local_fitness\n                        personal_best[i] = local_ind\n                        personal_best_fitness[i] = local_fitness\n                        if local_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = local_ind\n                            global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with self-adaptive inertia weight and local search for balanced exploration-exploitation.", "configspace": "", "generation": 58, "fitness": 0.24578396450033224, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "58c55633-10f1-4cfa-9e7d-61149acea5ee", "metadata": {"aucs": [0.49760738192088294, 0.509055626284515, 0.6241393506353192, 0.5062400418777048, 0.5451839953335865, 0.6519990371325353, 0.5113309467447218, 0.498425226453894, 0.6490955747048941, 0.12545308934201893, 0.17816297728852604, 0.3045948706426955, 0.19770504092560182, 0.17941271766002265, 0.3250085799851943, 0.15140828019152341, 0.030981868182075267, 0.29614562171705194, 0.10302043377238879, 0.1121831543960996, 0.12185766027660538, 0.1144112756310024, 0.14692484129061034, 0.12657049171276247, 0.13425299344931207, 0.13407839730729798, 0.1467033296300384, 0.09648494019666598, 0.09158560047033859, 0.09926168306813032, 0.10283315230060452, 0.10811260214400842, 0.11677291498374853, 0.10748413807564972, 0.10183440130719223, 0.1231562644504336, 0.9602392638656223, 0.9818425634282839, 0.9479889957496156, 0.9710871661651465, 0.9631326325575296, 0.9626286910092505, 0.9551072480797305, 0.9686315690539024, 0.9588606594147281, 0.24774758199060154, 0.2640871289144878, 0.3844038607244038, 0.2811303990439581, 0.25753912426234093, 0.3659898234828566, 0.2793382431515731, 0.2594731254165077, 0.36018324503760546, 0.5252690105094127, 0.4509930615384976, 0.5542437832252309, 0.5120039379695278, 0.2490462275761791, 0.5960838858949304, 0.437644140938803, 0.3509748481888709, 0.507439658506042, 0.16013235412246762, 0.14371855091450947, 0.1537583376545747, 0.10511515450505793, 0.14614239990239764, 0.18597727201142356, 0.1316951354169561, 0.115088413686803, 0.2011635468472548, 0.11472546334335387, 0.1753083435532532, 0.1304566095528571, 0.151480097455983, 0.15234729452065987, 0.15269742774218664, 0.14451200697718392, 0.16597407592616398, 0.12173877092553298, 9.999999999998899e-05, 0.0035198882656126695, 0.028698876621773506, 0.003406747343619676, 0.008799633255374806, 0.05378558566911129, 9.999999999998899e-05, 9.999999999998899e-05, 0.014144515195403828, 0.10559051236969719, 0.06286007207638045, 0.11050213677813647, 0.0617790348699262, 0.05083381800189035, 0.05413391343575025, 0.0934718179727071, 0.12039040444779747, 0.1217595980656917, 0.026379586478083916, 0.022834450047890864, 0.01923266009026081, 0.021688144320065272, 0.048419273059174706, 0.040829010140753796, 0.07129949945928715, 0.020166841469336783, 0.07252765491943969, 0.13016209433536663, 0.1211255453510075, 0.12017260773448524, 0.11134750814946093, 0.05232210579862462, 0.11820624618438647, 0.06631828358554792, 0.06586536570725221, 0.14016027588993907, 0.40094942268611655, 0.40333492119825787, 0.4354764843562532, 0.3980096554870688, 0.4135692956812309, 0.4808962040392035, 0.3989441752787408, 0.4054060966214462, 0.4606348580258569, 0.0921763905269034, 0.094381625060445, 0.09359609325704754, 0.0857053474470888, 0.08628608357310441, 0.09696706279004008, 0.10823735531461876, 0.08706998353861928, 0.10570496955253694, 0.15477013195872624, 0.19290859086016277, 0.21372861285445233, 0.17632162207059388, 0.23859533525035237, 0.17189342610433944, 0.21710194288342277, 0.28060931586748916, 0.2541911477682136, 0.28365448309665897, 0.27024829476896484, 0.3408449843117176, 0.28514913981227397, 0.32032761495876205, 0.3585709423849196, 0.33711907874389413, 0.30614280660207394, 0.35762454754533124, 0.23753505009269593, 0.2190096428248537, 0.23927589191630794, 0.1994839925933114, 0.21878665052654533, 0.1994817270569974, 0.18006410457895494, 0.21117263441473044, 0.2274668953065876, 0.19727122297021182, 0.21109924391380286, 0.210364749082935, 0.20863971503830192, 0.1972377197977142, 0.20648837234642858, 0.19312142972171265, 0.20191503521160314, 0.2550217039489322, 0.19048958922999903, 0.24794813145141614, 0.34341353936993524, 0.19329510406170758, 0.1968300028626141, 0.22410167617898458, 0.1992953758132141, 0.19890960885666042, 0.2029022237886945, 0.5484394444956624, 0.18220829378308068, 0.17017564965952903, 0.19069245493456044, 0.6647831613960058, 0.16892890420555684, 0.16244873221641154, 0.16085612855132125, 0.7033000660889224, 0.20417566383618002, 0.396292584017107, 0.5944455536714702, 0.1998478153795049, 0.19907218894344691, 0.16394939760985694, 0.4217000612586381, 0.5826876348961447, 0.5091360728406182, 0.18817453905440829, 0.1800655572278549, 0.18638926830637925, 0.1918635432132474, 0.1819828760399812, 0.1754751213644673, 0.184248109690757, 0.18619837945614304, 0.178855024922837, 0.09151649033855369, 0.07929824460730328, 0.08370205350280302, 0.08330032185864944, 0.07948066796482711, 0.09299424136118828, 0.0810523591999317, 0.08052889992140733, 0.0856484116950853]}, "mutation_prompt": null}
{"id": "7bc41b60-cdcb-4ed1-ad1e-98be74a6aa9d", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        def gradient_search(individual):\n            gradient_step = 0.01\n            new_individual = individual.copy()\n            for d in range(self.dim):\n                if budget_used >= self.budget:\n                    break\n                perturbation = np.zeros(self.dim)\n                perturbation[d] = gradient_step\n                potential_ind = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n                potential_fitness = func(potential_ind)\n                if potential_fitness < fitness[i]:\n                    new_individual = potential_ind\n                    fitness[i] = potential_fitness\n            return new_individual\n\n        while budget_used < self.budget:\n            # Differential Evolution with improved mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.5, 0.8)  # Improved dynamic scaling factor\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                population[i] = gradient_search(population[i])  # Apply local search\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with gradient-based local search and improved mutation strategy for better exploitation and exploration balance.", "configspace": "", "generation": 59, "fitness": 0.15991955709407743, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.16.", "error": "", "parent_id": "58c55633-10f1-4cfa-9e7d-61149acea5ee", "metadata": {"aucs": [0.3282790789415775, 0.3242944139019993, 0.3737772806095664, 0.3012635701613795, 0.2937141925452552, 0.340047919580046, 0.30051040216818314, 0.2836181672479845, 0.3532308452645785, 0.0027198542534033754, 0.02410180479787216, 0.02090456298081922, 0.008030694880238665, 0.016742122833441342, 0.0029127711511529597, 9.999999999998899e-05, 9.999999999998899e-05, 0.01699528690009211, 0.07862421066808833, 0.07469729796869418, 0.09006613219863358, 0.07953522184859407, 0.07126409746871942, 0.0929478621028933, 0.08800164815387657, 0.09477071278830063, 0.08919014214293075, 0.07267948667870716, 0.058763789692152346, 0.06576125388247112, 0.06135812724256484, 0.08130379463822734, 0.06915873664528294, 0.07058386263509742, 0.06020420553393191, 0.0661500554536002, 0.7676806621984849, 0.711288576511265, 0.840778254633346, 0.8477278437456015, 0.77752157957158, 0.8351041308349636, 0.904156804608857, 0.8283792548019024, 0.7148760695408108, 0.14536248615966396, 0.11509755627872598, 0.17914643723062385, 0.14560981413785157, 0.14383558874184166, 0.15723087838354355, 0.1409541692473797, 0.14212584969961461, 0.16275818677500953, 0.1791092822614726, 0.21792961928643306, 0.2366110547665694, 0.2103383401252894, 0.18090190801567874, 0.1959071201438649, 0.20046815372552262, 0.1745674998630733, 0.19584934241053054, 0.07364462909251068, 0.09278324477766242, 0.12532000606992078, 0.0894871266649736, 0.06942205671700363, 0.09354664234996235, 0.08027626122198694, 0.10197778216574938, 0.1118485657820456, 0.08607162248445055, 0.07306787561249273, 0.11941860933693971, 0.06934874245977407, 0.08991118175479973, 0.11082341513968208, 0.0908074701706606, 0.078128445656368, 0.07666721480755878, 9.999999999998899e-05, 0.006370138373788192, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10593497053419088, 0.04324712347971549, 0.15634074301955603, 0.09301933689851738, 0.04431633672739188, 0.017545968539991907, 0.054009421964446136, 0.08637547107215304, 0.1146290802079184, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.028471737449488832, 0.03532819176610247, 0.04319238165566153, 0.03591899628377837, 0.03092747115886363, 0.05795775391509883, 0.048298367275596, 0.0471262339581483, 0.0703163011174256, 0.2770356366690594, 0.3059252468704625, 0.31520672652702186, 0.27187327990287125, 0.3177915562777637, 0.32464833827800743, 0.2766634477988412, 0.267173047159042, 0.30633053577467495, 0.07697147909362234, 0.06815893348361501, 0.08872681266649884, 0.09000982052344297, 0.07139052231733256, 0.08986749201319322, 0.06941978535087512, 0.07419760177448131, 0.08339233226955733, 0.13867467082351126, 0.13114830946880196, 0.15554991589475942, 0.13786454700071749, 0.13218746128141645, 0.1332024263987882, 0.13598706410752437, 0.11503346341248011, 0.132827258243152, 0.21359451297838672, 0.2277800565362863, 0.22614659869958864, 0.21620978082907372, 0.21404990523711154, 0.23696391634373826, 0.21517737378038815, 0.2097349762235463, 0.24445646743816962, 0.16289010828934336, 0.17178770502128538, 0.1692170851750603, 0.14447861667120465, 0.14967077305782694, 0.15561379529871644, 0.1462712855398518, 0.14707310034696386, 0.17399568932744114, 0.18686838403135764, 0.19156978210902154, 0.2205278205185076, 0.20815212086476964, 0.18344233141088118, 0.1958299586729907, 0.19456403823411905, 0.18426646391365598, 0.19847262474899574, 0.16928672985442605, 0.16986939284898195, 0.1763852006588973, 0.16820397385735997, 0.16967188368170938, 0.16133152903092685, 0.1887761700979237, 0.1625003132052325, 0.16338277045508598, 0.1432302176486715, 0.2058060647084914, 0.34317658931640294, 0.18362687648533005, 0.1661847921229711, 0.16269922921072089, 0.36638023970316946, 0.1578981478963114, 0.26666406652399477, 0.17218558803208817, 0.26238093086510317, 0.19105097337852728, 0.16381069885234079, 0.15997169554453772, 0.11857562422324441, 0.17688868772256805, 0.13276770279925454, 0.15778017188969007, 0.1765486056362845, 0.17110045873667767, 0.1917327405050624, 0.18379287192322136, 0.19377929753571066, 0.17607110388698655, 0.16852775855973723, 0.17140244102756896, 0.17011617400590806, 0.05969355989356573, 0.07349233874450967, 0.07438837299311873, 0.07430642241325458, 0.07557787924986459, 0.07005741834788226, 0.06971351124969882, 0.07003504483112788, 0.07444210216456082]}, "mutation_prompt": null}
{"id": "fd1b4749-290e-44c0-a721-8ef1144788d6", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with dynamic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.4, 0.9)  # Dynamic scaling factor\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with adaptive parameters and dynamic mutation strategy for improved convergence.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "58c55633-10f1-4cfa-9e7d-61149acea5ee", "metadata": {"aucs": [0.8096940132456864, 0.8783704304557981, 0.8543492183114244, 0.8195770914487226, 0.8653949639031051, 0.8442028959929802, 0.7939809193691281, 0.8730990253091601, 0.8555038588158299, 0.5860160189923068, 0.727239092036281, 0.6944788983715643, 9.999999999998899e-05, 0.7247574775565298, 0.7088414552973993, 0.5505389141201504, 0.6889405116587493, 0.7016120447271142, 0.15765467626353602, 0.14733126911351213, 0.14125279294110515, 0.1374432112208417, 0.12795052133239737, 0.12992273171947522, 0.14762387843080438, 0.14157717241732792, 0.14937934049102297, 0.10342055378627846, 0.12387779979324709, 0.11135341110135122, 0.11993941449443535, 0.15251154063369665, 0.11071697493867427, 0.11622672320350069, 0.10122003920541611, 0.14418885202462717, 0.9440177485571697, 0.9404509236189162, 0.9547936901632903, 0.9585930990925834, 0.9554321964573628, 0.9634984535222196, 0.9641769553953, 0.947509882786065, 0.9451965311177623, 0.4670515375975599, 0.6729157157273042, 0.6587874446887421, 0.4747110428656519, 0.6864402029191414, 0.6547235059170867, 0.45349715518547473, 0.6876644795498377, 0.6633986646366832, 0.6947720342452942, 0.37941439736363736, 0.8602766216309361, 0.789615624840504, 0.3770723310757488, 0.37404249292678216, 0.8372744524357343, 0.21230939035072804, 0.2211748002847428, 0.20457723809562944, 0.13155029090899206, 0.12265060525324456, 0.18405741025950262, 0.16052263056687965, 0.12347037644987635, 0.20463596255927186, 0.23814144348122712, 0.2054606761068425, 0.12918327606683233, 0.13823362806847272, 0.2017068464755425, 0.20257368568376455, 0.19048965065710188, 0.2906076042153215, 0.23774756984350975, 0.17362496405020267, 0.19132872853057026, 9.999999999998899e-05, 0.045098163075595, 0.05118276552907686, 9.999999999998899e-05, 9.999999999998899e-05, 0.02489190772103378, 0.011706543670382041, 0.07423615437106379, 9.999999999998899e-05, 0.15003530465346482, 0.1354481700462702, 0.09779135582524645, 0.08691120693019916, 0.07089861141938059, 0.06218839463619674, 0.13562397540999827, 0.12111350189643966, 0.15343968508636785, 0.12408235539614965, 0.05849247727230089, 0.11905184872024588, 0.11838274188650644, 0.07830328449420454, 0.19481208691786, 0.20077155403040392, 0.09495378433488799, 0.16325252154605074, 0.09162912884097318, 0.4303301709435754, 0.11618298938284932, 0.11275091178091168, 0.0834725829657611, 0.18197270092520113, 0.04870209832155159, 0.13670957558288754, 0.08257134847308056, 0.5547650896202186, 0.5450756643889382, 0.5326511720933338, 0.4984722622020963, 0.5782402899292003, 0.5549193045263602, 0.5457199826549551, 0.5972870067402829, 0.5620804754909198, 0.12401883996989327, 0.14710523759361716, 0.1354032617870201, 0.3950602627102787, 0.13942955616443165, 0.1524152948860581, 0.14640725646204322, 0.15015503102218986, 0.10743701519285809, 0.1669130494864921, 0.33367318617286834, 0.5835892531575861, 0.2009441326403667, 0.1732113372052687, 0.5332691430840195, 0.25522608427625926, 0.19736088320192136, 0.4299750477043235, 0.39805154473850635, 0.5879621496359073, 0.4755260985926142, 0.4192141874562647, 0.3771436877620673, 0.5201811329089108, 0.4607404902068082, 0.24263403848513931, 0.5698958477385827, 0.3523612197145459, 0.3191010739807473, 0.37529406249084196, 0.3325561926152871, 0.25234887657199867, 0.18957974427040403, 0.34377567195031444, 0.1921105479602897, 0.2845817368452864, 0.22110688553147695, 0.2523760820734515, 0.23288911369165832, 0.22410292149057354, 0.22645442762058032, 0.21805579472864678, 0.24422731869679026, 0.1862666907606002, 0.2601076866669271, 0.21996591113455877, 0.2037167364393505, 0.22090542070215324, 0.21555590293682148, 0.20079912443594938, 0.1767195316506528, 0.2100714770883142, 0.20679909620987058, 0.20567301191987808, 0.18562020113765942, 0.9006950495231985, 0.18738257642333722, 0.19867389899215226, 0.8150579646182925, 0.16742405140927274, 0.15862649629288683, 0.831630416362783, 0.1725256200525419, 0.5168192936904756, 0.6103734839576287, 0.21034181966525933, 0.2060260201875872, 0.20841116338737842, 0.127236402981593, 0.5723935608268631, 0.16462099359364324, 0.15649148875025998, 0.1841075584937969, 0.20078136153572357, 0.20623262469498438, 0.17499032801070658, 0.18309666275780934, 0.196981904675414, 0.18363809420277366, 0.2133216137406897, 0.20075732296650806, 0.08793499216210932, 0.100791658706742, 0.09052924853055067, 0.10122717982680152, 0.10245902178837474, 0.10244969560215722, 0.08611385953333428, 0.1077180694369978, 0.08790228678535428]}, "mutation_prompt": null}
{"id": "29233f91-3d07-4833-8fe8-e9423dcf35ae", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f_min = 0.4  # Minimum DE scaling factor\n        self.f_max = 0.9  # Maximum DE scaling factor\n        self.w_min = 0.4  # Minimum inertia weight\n        self.w_max = 0.8  # Maximum inertia weight\n        self.c1 = np.random.uniform(1.5, 2.5)\n        self.c2 = np.random.uniform(1.0, 2.0)\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with dynamic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(self.f_min, self.f_max)  # Dynamic scaling factor with refined range\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization with adaptive inertia weight\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.w = np.random.uniform(self.w_min, self.w_max)  # Adaptive and dynamic inertia weight\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with adaptive inertia and dynamic scaling factors fine-tuned for increased exploration and exploitation balance.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'EnhancedHybridDEPSO' object has no attribute 'cr'\").", "error": "AttributeError(\"'EnhancedHybridDEPSO' object has no attribute 'cr'\")", "parent_id": "58c55633-10f1-4cfa-9e7d-61149acea5ee", "metadata": {}, "mutation_prompt": null}
{"id": "5b21a776-9766-46a9-83d3-3b816bb8211a", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with dynamic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.4, 0.9)  # Dynamic scaling factor\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with adaptive parameters and dynamic mutation strategy for improved convergence.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "58c55633-10f1-4cfa-9e7d-61149acea5ee", "metadata": {"aucs": [0.8096940132456864, 0.8783704304557981, 0.8543492183114244, 0.8195770914487226, 0.8653949639031051, 0.8442028959929802, 0.7939809193691281, 0.8730990253091601, 0.8555038588158299, 0.5860160189923068, 0.727239092036281, 0.6944788983715643, 9.999999999998899e-05, 0.7247574775565298, 0.7088414552973993, 0.5505389141201504, 0.6889405116587493, 0.7016120447271142, 0.15765467626353602, 0.14733126911351213, 0.14125279294110515, 0.1374432112208417, 0.12795052133239737, 0.12992273171947522, 0.14762387843080438, 0.14157717241732792, 0.14937934049102297, 0.10342055378627846, 0.12387779979324709, 0.11135341110135122, 0.11993941449443535, 0.15251154063369665, 0.11071697493867427, 0.11622672320350069, 0.10122003920541611, 0.14418885202462717, 0.9440177485571697, 0.9404509236189162, 0.9547936901632903, 0.9585930990925834, 0.9554321964573628, 0.9634984535222196, 0.9641769553953, 0.947509882786065, 0.9451965311177623, 0.4670515375975599, 0.6729157157273042, 0.6587874446887421, 0.4747110428656519, 0.6864402029191414, 0.6547235059170867, 0.45349715518547473, 0.6876644795498377, 0.6633986646366832, 0.6947720342452942, 0.37941439736363736, 0.8602766216309361, 0.789615624840504, 0.3770723310757488, 0.37404249292678216, 0.8372744524357343, 0.21230939035072804, 0.2211748002847428, 0.20457723809562944, 0.13155029090899206, 0.12265060525324456, 0.18405741025950262, 0.16052263056687965, 0.12347037644987635, 0.20463596255927186, 0.23814144348122712, 0.2054606761068425, 0.12918327606683233, 0.13823362806847272, 0.2017068464755425, 0.20257368568376455, 0.19048965065710188, 0.2906076042153215, 0.23774756984350975, 0.17362496405020267, 0.19132872853057026, 9.999999999998899e-05, 0.045098163075595, 0.05118276552907686, 9.999999999998899e-05, 9.999999999998899e-05, 0.02489190772103378, 0.011706543670382041, 0.07423615437106379, 9.999999999998899e-05, 0.15003530465346482, 0.1354481700462702, 0.09779135582524645, 0.08691120693019916, 0.07089861141938059, 0.06218839463619674, 0.13562397540999827, 0.12111350189643966, 0.15343968508636785, 0.12408235539614965, 0.05849247727230089, 0.11905184872024588, 0.11838274188650644, 0.07830328449420454, 0.19481208691786, 0.20077155403040392, 0.09495378433488799, 0.16325252154605074, 0.09162912884097318, 0.4303301709435754, 0.11618298938284932, 0.11275091178091168, 0.0834725829657611, 0.18197270092520113, 0.04870209832155159, 0.13670957558288754, 0.08257134847308056, 0.5547650896202186, 0.5450756643889382, 0.5326511720933338, 0.4984722622020963, 0.5782402899292003, 0.5549193045263602, 0.5457199826549551, 0.5972870067402829, 0.5620804754909198, 0.12401883996989327, 0.14710523759361716, 0.1354032617870201, 0.3950602627102787, 0.13942955616443165, 0.1524152948860581, 0.14640725646204322, 0.15015503102218986, 0.10743701519285809, 0.1669130494864921, 0.33367318617286834, 0.5835892531575861, 0.2009441326403667, 0.1732113372052687, 0.5332691430840195, 0.25522608427625926, 0.19736088320192136, 0.4299750477043235, 0.39805154473850635, 0.5879621496359073, 0.4755260985926142, 0.4192141874562647, 0.3771436877620673, 0.5201811329089108, 0.4607404902068082, 0.24263403848513931, 0.5698958477385827, 0.3523612197145459, 0.3191010739807473, 0.37529406249084196, 0.3325561926152871, 0.25234887657199867, 0.18957974427040403, 0.34377567195031444, 0.1921105479602897, 0.2845817368452864, 0.22110688553147695, 0.2523760820734515, 0.23288911369165832, 0.22410292149057354, 0.22645442762058032, 0.21805579472864678, 0.24422731869679026, 0.1862666907606002, 0.2601076866669271, 0.21996591113455877, 0.2037167364393505, 0.22090542070215324, 0.21555590293682148, 0.20079912443594938, 0.1767195316506528, 0.2100714770883142, 0.20679909620987058, 0.20567301191987808, 0.18562020113765942, 0.9006950495231985, 0.18738257642333722, 0.19867389899215226, 0.8150579646182925, 0.16742405140927274, 0.15862649629288683, 0.831630416362783, 0.1725256200525419, 0.5168192936904756, 0.6103734839576287, 0.21034181966525933, 0.2060260201875872, 0.20841116338737842, 0.127236402981593, 0.5723935608268631, 0.16462099359364324, 0.15649148875025998, 0.1841075584937969, 0.20078136153572357, 0.20623262469498438, 0.17499032801070658, 0.18309666275780934, 0.196981904675414, 0.18363809420277366, 0.2133216137406897, 0.20075732296650806, 0.08793499216210932, 0.100791658706742, 0.09052924853055067, 0.10122717982680152, 0.10245902178837474, 0.10244969560215722, 0.08611385953333428, 0.1077180694369978, 0.08790228678535428]}, "mutation_prompt": null}
{"id": "a2052c17-609e-4100-a435-68e3f8622628", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.4, 0.7)  # Adjusted adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.5, 2.5)  # Adjusted adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with dynamic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.3, 0.8)  # Adjusted dynamic scaling factor\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization with adaptive learning\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with adaptive exploration strategies and dynamic learning factors for robust optimization.", "configspace": "", "generation": 63, "fitness": 0.2867809730460437, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "58c55633-10f1-4cfa-9e7d-61149acea5ee", "metadata": {"aucs": [0.5474840389104194, 0.7914176308818994, 0.7922627482640836, 0.5642837676739594, 0.7811480054995205, 0.7357090563104342, 0.6016279008720209, 0.7952470133869296, 0.7740538162984756, 0.25042317102145994, 0.5371909484224602, 0.49429545053653523, 0.2769686228959999, 0.545506624275357, 0.36730259674001076, 0.2550684569181153, 0.5171118480068964, 0.4618027179789379, 0.10458440795728152, 0.14861623967777682, 0.3707055380525096, 0.12922495301013026, 0.1602849276719267, 0.13799576372443045, 0.12539994315675917, 0.15175914074879093, 0.11736089879169631, 0.12394802738469568, 0.11007564666014003, 0.12759315747452638, 0.09925074660492916, 0.1306076375325812, 0.12586332886184814, 0.11283984589167084, 0.12650523071257902, 0.09928562275601183, 0.9365464374871868, 0.9535311478075177, 0.9581866366971122, 0.9596469469665209, 0.9503927806986949, 0.9453702911631421, 0.9566576177302019, 0.9477092767615395, 0.9309511114712917, 0.2943750348581511, 0.43711989805922813, 0.43417819912928335, 0.2691704543111788, 0.4136484083298049, 0.4354696889876465, 0.2702002759227021, 0.43672655778317027, 0.4181312610634407, 0.3056025496426169, 0.749363620733843, 0.8013099224434648, 0.20692666129276727, 0.21605415031997077, 0.35054422903589544, 0.508662459940291, 0.6250973376469673, 0.46969977941584706, 0.1475773951946059, 0.18458504632184325, 0.1827178665764735, 0.15708514308108645, 0.18345565373789574, 0.11095058698706783, 0.1671580668664041, 0.18081562300966758, 0.1923681163322054, 0.17213610704172788, 0.21714111412630677, 0.21264327973567254, 0.15188295767019555, 0.13403021193972586, 0.1629522378297673, 0.16170473182281297, 0.20706556228762718, 0.22245499052278117, 0.008424383290201676, 0.000516206099018035, 0.031160587723619182, 9.999999999998899e-05, 0.08674274841619556, 0.024445151471831794, 9.999999999998899e-05, 0.05068609634230237, 0.03694910493967196, 0.08161357392912616, 0.1393766740839838, 0.14855002985612842, 0.10749788014122097, 0.07854884938269657, 0.07957056606115953, 0.2102768261654182, 0.0875072163489895, 0.09442156876282826, 0.03868766849979455, 0.11765891952796814, 0.22946902411224002, 0.05603380814057346, 0.09352325471705158, 0.1439306518365664, 0.05078123762303799, 0.10377095549513937, 0.07965009020432023, 0.13871717259982397, 0.05131603690604336, 0.1439813648841477, 0.12074617816146094, 0.14342454455600673, 0.16902612599040678, 0.07848354958873227, 0.20920024700798534, 0.10512383119113566, 0.42333095384061314, 0.5008446212586142, 0.5417552543055919, 0.4235094224088942, 0.4977632550701465, 0.515429338839984, 0.45620826388818736, 0.5131635590976069, 0.5168001444339952, 0.08617226830230862, 0.14235680729520772, 0.13195643038733174, 0.12299360886719057, 0.12032087818652104, 0.12360636610121623, 0.11548786368329689, 0.17015915969126438, 0.14011301854890645, 0.2436010128247894, 0.16196771654879483, 0.22499639307008623, 0.16837268255541749, 0.18728455945248434, 0.15359189054062394, 0.24139710537315484, 0.26492571514664265, 0.18320414826003484, 0.2914946330948275, 0.39093947674280694, 0.4330722865440305, 0.31606104152286096, 0.3859875494129815, 0.26983532725986814, 0.2999018541004762, 0.41343096084692366, 0.4259830155216061, 0.27387998467310726, 0.19145661575181583, 0.2796860830556187, 0.23033385807819418, 0.22619913881200038, 0.3063595477090173, 0.1774276721614173, 0.20060873618078678, 0.28234294640400226, 0.21215523023208283, 0.20615238185526064, 0.19693017754514686, 0.2127435782092374, 0.24362741809408206, 0.21321614333314842, 0.22665219003493142, 0.19708997345669865, 0.1964920254837108, 0.22210691660463933, 0.20028624892866875, 0.19097243492616234, 0.19016394251868118, 0.2209472332028204, 0.1770295407011283, 0.2935598334002111, 0.4426834971469079, 0.49770321455364697, 0.181521329999616, 0.12234037202347603, 0.18595374717994195, 0.1985314762533955, 0.7505537491630939, 0.16759152822241707, 0.6763530777583477, 0.8644348787009075, 0.8536920877776111, 0.4481006071571122, 0.5254565486031864, 0.20790009985684654, 0.16728865732236975, 0.21067815135575974, 0.20989582180488386, 0.45175538665538784, 0.6449296158653485, 0.155841813068477, 0.19414407407843093, 0.17406356679691903, 0.2009823403708294, 0.18192716587642122, 0.18448813219867477, 0.19728028685984123, 0.209525205895438, 0.1815846474776982, 0.20826568653729172, 0.08302759194681897, 0.082805088284295, 0.08764651378071908, 0.11138640255552423, 0.09099264586211142, 0.07644309403271288, 0.08972657646889004, 0.09011768473901105, 0.10982435693325843]}, "mutation_prompt": null}
{"id": "f8c4104b-7fb2-488e-aee9-30eb73c8fc4d", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.7  # Adjusted DE scaling factor\n        self.cr = 0.85  # Adjusted crossover rate\n        self.w = np.random.uniform(0.4, 0.7)  # Enhanced adaptive inertia weight range\n        self.c1 = np.random.uniform(1.7, 2.5)  # Enhanced adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.2, 2.2)  # Enhanced adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.5, 0.9)  # Fine-tuned dynamic scaling factor\n                mutant = a + f_dynamic * (b - c)\n                gaussian_mutation = np.random.normal(0, 0.1, self.dim)  # New Gaussian mutation\n                mutant = np.clip(mutant + gaussian_mutation, self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Fine-tuned EnhancedHybridDEPSO using adaptive parameter tuning and Gaussian mutation for improved exploration and convergence.", "configspace": "", "generation": 64, "fitness": 0.29690406607845143, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "58c55633-10f1-4cfa-9e7d-61149acea5ee", "metadata": {"aucs": [0.6885114460983621, 0.78453780894134, 0.7804362251860397, 0.6300092651049861, 0.8117069757385026, 0.7488215799187993, 0.6368076593372958, 0.8146097114600903, 0.785472433227763, 0.313856295380587, 0.44935201796625046, 0.5229917113020524, 0.2981809147450437, 0.5425607218996407, 0.5046656388512776, 0.26617682302086065, 0.5307453794168087, 0.4721879212675423, 0.21763910332639047, 0.17529146513225646, 0.15490607405097057, 0.14358475354267464, 0.1659676145796537, 0.21540096138774323, 0.12600557636818233, 0.144254580057378, 0.1269505674792284, 0.1257378966445527, 0.11008844246047667, 0.11194137754243327, 0.10088255904621679, 0.13323298845664522, 0.10837869480871654, 0.10260115082252652, 0.11509171652637629, 0.09905527772491862, 0.9556981950665454, 0.9569723271571345, 0.955937209739407, 0.9547888966325284, 0.9729675297654296, 0.9699904171862049, 0.9718594453525734, 0.9632597813505868, 0.9436956931818636, 0.3010246884312128, 0.45505656024133956, 0.46898396256360875, 0.3367579578047577, 0.48772567633001596, 0.4515179422294944, 0.32130552368186593, 0.4513714327096541, 0.4404669942772129, 0.38139106738421347, 0.22602067758699307, 0.5286079110469694, 0.24821748975614966, 0.7938301557785983, 0.8283881354182334, 0.6171557259780316, 0.7473208380603754, 0.242914035671269, 0.15342573496566325, 0.1689396968891016, 0.16708018113074208, 0.1646206919728027, 0.09958984300173956, 0.17317135882782264, 0.11198212031826282, 0.17240119613157145, 0.16418793119894692, 0.1614690345129608, 0.12689781016780943, 0.2392962959408209, 0.1256094520753006, 0.1976424781073064, 0.17388838528578976, 0.20191063701518597, 0.21636925584296263, 0.20405105278177538, 9.999999999998899e-05, 0.0009787483876382286, 9.999999999998899e-05, 0.003708772450175646, 0.03983709965812854, 0.016047288430418694, 9.999999999998899e-05, 9.999999999998899e-05, 0.00024299622920898045, 0.13882067528879272, 0.10625593136990974, 0.1217803006988668, 0.09573154344425494, 0.08116855988298499, 0.1271085100279995, 0.15909735763248334, 0.10373179976576063, 0.20074028427146717, 0.09430716404051931, 0.040815459106581686, 0.09120967502443178, 0.06224484793659335, 0.1247160390169314, 0.19937264378945396, 0.06695029933275842, 0.13390413293823422, 0.08234315679886117, 0.10575404711830538, 0.12897984837445076, 0.10713184759491157, 0.17260697161443184, 0.19299019888951374, 0.06918858792852967, 0.07917744571064522, 0.10900885453046794, 0.0836483150516627, 0.5168885705457131, 0.5056932552549488, 0.49850576803545343, 0.4659743849984127, 0.4992930583171662, 0.5232287093544863, 0.4433329608944643, 0.5198668350398035, 0.5239249093830218, 0.1090218104312708, 0.14001728172315542, 0.13481560896384248, 0.09441395636025096, 0.14836311568022098, 0.10530322520235513, 0.12132844082882843, 0.11684333137201208, 0.15663728148737155, 0.16508415993943837, 0.23939339097179924, 0.2802883655340521, 0.3477900727579345, 0.14708551206765952, 0.24803010347020749, 0.2170759847303415, 0.2400230350761755, 0.28700304895467277, 0.3689463118821322, 0.4320179381082516, 0.306434380158746, 0.3514123903002667, 0.39165355557532755, 0.44208630690585216, 0.343659316162941, 0.43206595908680234, 0.47374042080358925, 0.2111381216430832, 0.2217403320877286, 0.2566750160183514, 0.24062452529058587, 0.2037295683543231, 0.280681977559172, 0.2116143961254493, 0.21853196166793165, 0.3097226410145696, 0.2137632027157652, 0.2283651808326922, 0.21093214881954347, 0.2127246356993514, 0.20815195557793598, 0.23180923475969217, 0.21886922986187252, 0.23914782567596338, 0.24743146649804715, 0.18104713890889224, 0.2159266131891907, 0.24016845230054118, 0.1986765185158581, 0.5873186623399467, 0.23054532866994437, 0.26567895928862684, 0.23719542587895026, 0.20530734913785553, 0.17078164979303023, 0.171353608513658, 0.1872520524472976, 0.7974832775760141, 0.16123174733127887, 0.1679496043326928, 0.15283108276116708, 0.7717402125593642, 0.7939282666896026, 0.457470127227002, 0.6364639244135128, 0.5801116761174738, 0.2081465600804494, 0.20962510846309856, 0.5323589418409218, 0.6399155278580932, 0.6782958667416874, 0.15550386202388566, 0.20431544522131406, 0.19311373189546732, 0.19664183440192606, 0.17748445617952802, 0.21451543971487586, 0.18987169553443106, 0.19606685530165358, 0.18979769122145385, 0.19254864983839393, 0.09123501086316843, 0.08976235997200421, 0.08395580796535795, 0.12469083761627386, 0.08984675905721373, 0.07751864506240469, 0.0911995381267301, 0.09737643804665508, 0.0997331976607937]}, "mutation_prompt": null}
{"id": "1613ac7b-782d-4be7-a061-9158d9c49cef", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with dynamic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.4, 0.9)  # Dynamic scaling factor\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with adaptive parameters and dynamic mutation strategy for improved convergence.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "58c55633-10f1-4cfa-9e7d-61149acea5ee", "metadata": {"aucs": [0.8096940132456864, 0.8783704304557981, 0.8543492183114244, 0.8195770914487226, 0.8653949639031051, 0.8442028959929802, 0.7939809193691281, 0.8730990253091601, 0.8555038588158299, 0.5860160189923068, 0.727239092036281, 0.6944788983715643, 9.999999999998899e-05, 0.7247574775565298, 0.7088414552973993, 0.5505389141201504, 0.6889405116587493, 0.7016120447271142, 0.15765467626353602, 0.14733126911351213, 0.14125279294110515, 0.1374432112208417, 0.12795052133239737, 0.12992273171947522, 0.14762387843080438, 0.14157717241732792, 0.14937934049102297, 0.10342055378627846, 0.12387779979324709, 0.11135341110135122, 0.11993941449443535, 0.15251154063369665, 0.11071697493867427, 0.11622672320350069, 0.10122003920541611, 0.14418885202462717, 0.9440177485571697, 0.9404509236189162, 0.9547936901632903, 0.9585930990925834, 0.9554321964573628, 0.9634984535222196, 0.9641769553953, 0.947509882786065, 0.9451965311177623, 0.4670515375975599, 0.6729157157273042, 0.6587874446887421, 0.4747110428656519, 0.6864402029191414, 0.6547235059170867, 0.45349715518547473, 0.6876644795498377, 0.6633986646366832, 0.6947720342452942, 0.37941439736363736, 0.8602766216309361, 0.789615624840504, 0.3770723310757488, 0.37404249292678216, 0.8372744524357343, 0.21230939035072804, 0.2211748002847428, 0.20457723809562944, 0.13155029090899206, 0.12265060525324456, 0.18405741025950262, 0.16052263056687965, 0.12347037644987635, 0.20463596255927186, 0.23814144348122712, 0.2054606761068425, 0.12918327606683233, 0.13823362806847272, 0.2017068464755425, 0.20257368568376455, 0.19048965065710188, 0.2906076042153215, 0.23774756984350975, 0.17362496405020267, 0.19132872853057026, 9.999999999998899e-05, 0.045098163075595, 0.05118276552907686, 9.999999999998899e-05, 9.999999999998899e-05, 0.02489190772103378, 0.011706543670382041, 0.07423615437106379, 9.999999999998899e-05, 0.15003530465346482, 0.1354481700462702, 0.09779135582524645, 0.08691120693019916, 0.07089861141938059, 0.06218839463619674, 0.13562397540999827, 0.12111350189643966, 0.15343968508636785, 0.12408235539614965, 0.05849247727230089, 0.11905184872024588, 0.11838274188650644, 0.07830328449420454, 0.19481208691786, 0.20077155403040392, 0.09495378433488799, 0.16325252154605074, 0.09162912884097318, 0.4303301709435754, 0.11618298938284932, 0.11275091178091168, 0.0834725829657611, 0.18197270092520113, 0.04870209832155159, 0.13670957558288754, 0.08257134847308056, 0.5547650896202186, 0.5450756643889382, 0.5326511720933338, 0.4984722622020963, 0.5782402899292003, 0.5549193045263602, 0.5457199826549551, 0.5972870067402829, 0.5620804754909198, 0.12401883996989327, 0.14710523759361716, 0.1354032617870201, 0.3950602627102787, 0.13942955616443165, 0.1524152948860581, 0.14640725646204322, 0.15015503102218986, 0.10743701519285809, 0.1669130494864921, 0.33367318617286834, 0.5835892531575861, 0.2009441326403667, 0.1732113372052687, 0.5332691430840195, 0.25522608427625926, 0.19736088320192136, 0.4299750477043235, 0.39805154473850635, 0.5879621496359073, 0.4755260985926142, 0.4192141874562647, 0.3771436877620673, 0.5201811329089108, 0.4607404902068082, 0.24263403848513931, 0.5698958477385827, 0.3523612197145459, 0.3191010739807473, 0.37529406249084196, 0.3325561926152871, 0.25234887657199867, 0.18957974427040403, 0.34377567195031444, 0.1921105479602897, 0.2845817368452864, 0.22110688553147695, 0.2523760820734515, 0.23288911369165832, 0.22410292149057354, 0.22645442762058032, 0.21805579472864678, 0.24422731869679026, 0.1862666907606002, 0.2601076866669271, 0.21996591113455877, 0.2037167364393505, 0.22090542070215324, 0.21555590293682148, 0.20079912443594938, 0.1767195316506528, 0.2100714770883142, 0.20679909620987058, 0.20567301191987808, 0.18562020113765942, 0.9006950495231985, 0.18738257642333722, 0.19867389899215226, 0.8150579646182925, 0.16742405140927274, 0.15862649629288683, 0.831630416362783, 0.1725256200525419, 0.5168192936904756, 0.6103734839576287, 0.21034181966525933, 0.2060260201875872, 0.20841116338737842, 0.127236402981593, 0.5723935608268631, 0.16462099359364324, 0.15649148875025998, 0.1841075584937969, 0.20078136153572357, 0.20623262469498438, 0.17499032801070658, 0.18309666275780934, 0.196981904675414, 0.18363809420277366, 0.2133216137406897, 0.20075732296650806, 0.08793499216210932, 0.100791658706742, 0.09052924853055067, 0.10122717982680152, 0.10245902178837474, 0.10244969560215722, 0.08611385953333428, 0.1077180694369978, 0.08790228678535428]}, "mutation_prompt": null}
{"id": "db8ebfdf-0f83-49f6-aada-6b530ab01aee", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSOPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.4, 0.9)  # Increased range for adaptive inertia weight\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.4, 0.9)  # Dynamic scaling factor\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n                else:\n                    chaotic_search = population[i] + np.random.uniform(-0.1, 0.1, self.dim)  # Chaotic Local Search\n                    chaotic_search = np.clip(chaotic_search, self.lower_bound, self.upper_bound)\n                    chaotic_fitness = func(chaotic_search)\n                    budget_used += 1\n                    if chaotic_fitness < fitness[i]:\n                        population[i] = chaotic_search\n                        fitness[i] = chaotic_fitness\n                        personal_best[i] = chaotic_search\n                        personal_best_fitness[i] = chaotic_fitness\n                        if chaotic_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = chaotic_search\n                            global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSOPlus", "description": "EnhancedHybridDEPSO+ with adaptive learning rates and chaotic local search for improved exploration and convergence.", "configspace": "", "generation": 66, "fitness": 0.26264930429512656, "feedback": "The algorithm EnhancedHybridDEPSOPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "58c55633-10f1-4cfa-9e7d-61149acea5ee", "metadata": {"aucs": [0.5076990734451706, 0.7302562292809537, 0.7188368371520899, 0.48082777886459926, 0.7326001440954089, 0.7029968536055995, 0.47823045817873167, 0.7133841329623214, 0.660922966062919, 0.15656573214076652, 0.3482086684205866, 0.2693539420127279, 0.16583299900664317, 0.3576399262230264, 0.3807178367986701, 0.04062499078450654, 0.3497510704581639, 0.354322801826773, 0.10757544806139774, 0.21353684029886044, 0.14396137720368551, 0.11352868760486567, 0.11404142087766644, 0.13627795502648365, 0.10939191960924166, 0.3259648332167693, 0.1474837835577768, 0.08670242337140921, 0.09111178053793445, 0.11204253488491445, 0.10638032992765079, 0.11839636845879709, 0.11201344827304072, 0.09607994090850425, 0.12674421205514885, 0.10126656986932214, 0.9599867582001952, 0.9514438195523262, 0.9606169630848732, 0.9642126374169789, 0.9446922218994358, 0.9477281230940235, 0.9652197869272194, 0.9425862504004683, 0.9440041580625198, 0.2527189928536535, 0.3649921348036843, 0.375036345302477, 0.2894783799010493, 0.3622561501960735, 0.3516168052415555, 0.2630269371369123, 0.3811891199221541, 0.3758645232773914, 0.22386561525922677, 0.318708058988874, 0.2234367122811205, 0.37121107133879716, 0.718622945671498, 0.7933457773202528, 0.37713929643457733, 0.566263375071746, 0.3390343036005624, 0.16899147158631933, 0.18376042270905257, 0.09739220107663149, 0.1204499046781331, 0.16471771961815485, 0.18917263347946878, 0.1397734700868194, 0.19765719981774432, 0.18551472843726213, 0.1446189373167912, 0.20300572276339135, 0.19219572359937764, 0.1467482597188604, 0.18089664064581756, 0.18728231408358498, 0.14345038279963374, 0.21452610990849874, 0.18600607335137465, 0.00259047463044515, 9.999999999998899e-05, 9.999999999998899e-05, 0.01734937866209041, 9.999999999998899e-05, 0.04130271052384704, 0.041413610693749825, 0.04152478362089984, 0.0031747455578347017, 0.10830198079098607, 0.13216193718118607, 0.10226415789702681, 0.1116690917089983, 0.07245615160219898, 0.1278447453465651, 0.0941987491727817, 0.09949720905809534, 0.14259624529362336, 0.0061296754798070285, 0.023553865090202297, 0.10446726808719597, 0.032075047129843215, 0.0950672839754445, 0.05545730626731271, 0.01596954758738356, 0.07689034157210117, 0.06997637847864768, 0.11376069323429527, 0.118359912392484, 0.13076480951353298, 0.07186399251611741, 0.1706625642049736, 0.12509456874912905, 0.06323966442586004, 0.13612005574581432, 0.0863582720403574, 0.41193138041900923, 0.4975832050431014, 0.4728657490111351, 0.42364888630348163, 0.48251650367670496, 0.5166342655843296, 0.4180419186125711, 0.532632497949356, 0.5341813144162839, 0.10334580151384198, 0.13664384536803176, 0.10681559234005655, 0.10036092152970322, 0.1294871503321463, 0.11669756355273042, 0.10359572956657792, 0.0926760129657499, 0.10165931592931698, 0.16567105422688688, 0.17145563972760391, 0.2586265602417641, 0.12596421549547288, 0.18049308039613476, 0.2934368714306598, 0.16643074343736075, 0.29747571135952844, 0.14572425371992648, 0.26835799530901505, 0.33567198565009826, 0.2658030449829767, 0.29035281937389856, 0.29541087044295744, 0.38804513201429147, 0.3077230702957595, 0.3633397593442974, 0.3676180571461586, 0.17051411232603586, 0.25616695770938336, 0.21679974489823362, 0.25424078751055346, 0.2698728840943414, 0.19550090063981063, 0.25228314705651456, 0.18035168138899693, 0.21226841495172033, 0.2207811415942037, 0.20458233380777635, 0.21782759767730775, 0.22673956900156278, 0.23163172047709335, 0.2028228236855304, 0.23427108974229516, 0.21588577657703667, 0.201373000971949, 0.19824317759827026, 0.39760547953728986, 0.18991818660990234, 0.19015105947841426, 0.22392396618846755, 0.1794045274005901, 0.20562344709383296, 0.22895812926170833, 0.23044944013337298, 0.1818401231621889, 0.7948146865613445, 0.7701536378764413, 0.19492831412964307, 0.7263692871415788, 0.16654818361850043, 0.155928111639149, 0.1613398855450623, 0.17080320205590616, 0.1259675148126138, 0.5016515636992043, 0.2078562226805586, 0.35682533932620386, 0.3667674792116661, 0.6104950288790143, 0.4055233901005213, 0.48564497529730954, 0.15468300292240833, 0.1706866203485643, 0.18876469962661124, 0.18129982095497954, 0.18816869685400783, 0.19991145033735658, 0.18634523628332433, 0.18205621695302754, 0.19572961596309502, 0.19080820001168908, 0.0725815364083886, 0.09873445775255563, 0.08655044631619457, 0.09866202611142094, 0.07897419022581631, 0.08712279968326908, 0.09369245904823054, 0.09036883904046977, 0.10635613883738804]}, "mutation_prompt": null}
{"id": "18049154-f5a2-4eb2-bf61-fdb6bfa09dea", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with dynamic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.5, 1.0)  # Dynamic scaling factor adjusted\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Adjust learning rates adaptively\n            self.c1 = np.random.uniform(1.5, 2.5) * (1 - budget_used / self.budget)\n            self.c2 = np.random.uniform(1.0, 2.0) * (budget_used / self.budget)\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with adaptive dynamic mutation and learning rates for improved exploration-exploitation balance.", "configspace": "", "generation": 67, "fitness": 0.33806515228612816, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "58c55633-10f1-4cfa-9e7d-61149acea5ee", "metadata": {"aucs": [0.7872157191955759, 0.6574420632864659, 0.7917917591512056, 0.7958922074998774, 0.7989257932831402, 0.7957125243014036, 0.7913616875990871, 0.8006239380012781, 0.7950122900103148, 0.6685762701644444, 0.6528604630991643, 0.6847840749129286, 0.6509466541406084, 0.6663042841064887, 0.6776041870070177, 0.6708931169229703, 0.6834945226566687, 0.6858885159899506, 0.3713838590715587, 0.1065861809744374, 0.12633426848173512, 0.4193346031898535, 0.13174388798721248, 0.3344121603327349, 0.14632011059915817, 0.13226424293579198, 0.15330449796962387, 0.09463165870779411, 0.11215615640788623, 0.12460206783685535, 0.09788278166761188, 0.11379501566691075, 0.1036165697478304, 0.10529493402851298, 0.09986580338265227, 0.1273541087203266, 0.8532473986231971, 0.7894845214296657, 0.8883589297175674, 0.8525379384805328, 0.8098064405182981, 0.9147975753566133, 0.9721760664875496, 0.8870031984920934, 0.7552926669364651, 0.6205184432249731, 0.3385136408348116, 0.6406739670952531, 0.5959279573243443, 0.468270332257404, 0.6399169468896835, 0.5471395500511218, 0.43924148141035435, 0.19467311568366696, 0.7353279218732238, 0.7871464869440143, 0.7614457815122746, 0.7754836232762475, 0.7689870171028226, 0.7779376664619236, 0.7564630320586203, 0.7152732442927155, 0.7034226265593142, 0.14067098638089282, 0.1656723091567368, 0.21135549584402546, 0.20436532724392165, 0.13804315054005123, 0.11604567509639507, 0.16132673633558314, 0.144285228530191, 0.1426739312070704, 0.13921864915513738, 0.2965621400918138, 0.3217173645114876, 0.1350886449013502, 0.15990241082106005, 0.14148005213699943, 0.11842000657651175, 0.15866391833266713, 0.17215978609974592, 0.047411562963892706, 0.05168700376970814, 0.12627377673485862, 0.053159901362740625, 0.0033864544242520056, 0.03270404536671212, 0.030217225057243002, 0.07297954710310428, 0.02899883830409089, 0.11488837280691389, 0.1407303282081821, 0.12951262300214528, 0.13399519669279614, 0.12102030348970749, 0.10018383718379287, 0.13832813503874553, 0.2062956162398779, 0.12969816555700886, 0.1730931979226007, 0.04231499348826251, 0.0804195689508711, 0.21532986241963303, 0.18807125152386706, 0.11927586420379088, 0.25570255899608696, 0.2175705571032499, 0.11438920698614419, 0.10014969782956906, 0.22591218823419112, 0.24087660062864857, 0.22876031031316302, 0.15143648404829058, 0.24977639051303224, 0.19751840497560924, 0.3409170516342398, 0.19307960393545143, 0.518014720971101, 0.5985645179616477, 0.5238363535947699, 0.49814423972946564, 0.5465658751910167, 0.5783322148754144, 0.5247232937136073, 0.5462736162644704, 0.5264967263203234, 0.12465381289832622, 0.14620648442735218, 0.12963340841476145, 0.10762507173349056, 0.10644366080268486, 0.11457176098934874, 0.15034157466436993, 0.1258723067042825, 0.12339421391261951, 0.18687950036442835, 0.15519500135246056, 0.17127369110966406, 0.1734231298434894, 0.18076832272845422, 0.15482790024530313, 0.16739160596818203, 0.18270314996918535, 0.1783682352743614, 0.4463004531587097, 0.3639901913537147, 0.4669289143643418, 0.46955394460224564, 0.4072494696452368, 0.3081003720529306, 0.33671504126356233, 0.3666887796514411, 0.5194828226165522, 0.29527694733133814, 0.3335895165554904, 0.23665079012393664, 0.3255827952284198, 0.3991321585784261, 0.35609195444961794, 0.2911788758122168, 0.20876507948999812, 0.2672160934101536, 0.21954388553323412, 0.22262914530289568, 0.22822301912482867, 0.21223886614070286, 0.21465838602765475, 0.21929271898810365, 0.21083422277214647, 0.2146004720843262, 0.25380583428983905, 0.18042059547937295, 0.20240672267539117, 0.2198421427783931, 0.2082563294843488, 0.19604210477941575, 0.22710719259153545, 0.19747399426613166, 0.17613578183401246, 0.20139685593687495, 0.7385223026739401, 0.7331910064875534, 0.8032437570145959, 0.692390874590616, 0.1894563991342021, 0.6665536315438595, 0.6820408702343952, 0.18763394046024706, 0.7422384641503671, 0.5286578067569395, 0.20064933239398197, 0.7038089536003094, 0.7053220776157942, 0.4277690926916078, 0.6614121988563331, 0.7016551360874844, 0.14932361336082833, 0.19363519262304674, 0.18924742620707746, 0.2032409188424219, 0.19695001896225162, 0.18987463017972595, 0.19254598129092693, 0.19464306221711958, 0.1867119189557438, 0.17939569105229003, 0.21516816256738447, 0.09214593297702067, 0.08700924470776594, 0.08221678144331657, 0.11160965224590402, 0.09051815489802817, 0.09733232953929238, 0.0803706170518439, 0.08641385720910166, 0.08624991347229227]}, "mutation_prompt": null}
{"id": "0903f5fc-bb82-4f48-8f12-efcf6dc9e066", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with dynamic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.5, 1.2)  # Increased dynamic scaling factor range\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Adjust learning rates adaptively\n            self.c1 = np.random.uniform(1.5, 2.5) * (1 - budget_used / self.budget)\n            self.c2 = np.random.uniform(1.0, 2.0) * (budget_used / self.budget)\n\n            # Particle Swarm Optimization with diversity enhancement\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )\n            # Adaptive velocity range adjustment\n            if np.std(fitness) < 0.1:\n                velocities *= 1.2  # Promote exploration\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with adaptive velocity adjustment and population diversity promotion to improve convergence.", "configspace": "", "generation": 68, "fitness": 0.3335918949699907, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "18049154-f5a2-4eb2-bf61-fdb6bfa09dea", "metadata": {"aucs": [0.7830675856219472, 0.7899816141799497, 0.7913272841110097, 0.7897844969789325, 0.8008911699205198, 0.7958572517795801, 0.7887888262844476, 0.7987691300680959, 0.793181520336655, 0.6520906407887228, 0.6642271677988888, 0.6728014601212993, 0.6407478689375901, 0.6302193836278662, 0.6429540471216326, 0.6354514934214474, 0.6516653053846303, 0.6377573253497243, 0.10175045644036729, 0.15886954946612475, 0.1433467169407031, 0.10660642547272414, 0.42435396037322126, 0.13293199591853078, 0.33044492014213156, 0.13431100121760775, 0.1543110512056357, 0.0991592003056545, 0.11261085758973277, 0.09910315467805575, 0.12568236042698588, 0.12795390856592948, 0.09878663244069352, 0.09417303595002291, 0.10269568710786259, 0.11569753740565702, 0.9134297735092991, 0.8852480808983347, 0.9277976309512517, 0.912064659483231, 0.8546426773431577, 0.9353309457872332, 0.9493399637747604, 0.8976271018828484, 0.8940746628430888, 0.6053656843495974, 0.5766449739540234, 0.6239266212631437, 0.5613396843289431, 0.651713676388375, 0.607206885487777, 0.5683980003222511, 0.5829454134941094, 0.5060280543860565, 0.7526774390124011, 0.3544069262272487, 0.7277792341319546, 0.744381970907706, 0.774884488663396, 0.757880940270022, 0.7956534373357667, 0.6951362289650299, 0.7671156753165125, 0.11764931676248047, 0.11692694811485438, 0.35378910995019286, 0.15556252867455644, 0.16498744724615444, 0.11558656690035929, 0.16585275835532975, 0.14792146857985566, 0.15921938744064812, 0.10767105538709743, 0.126644805803387, 0.44470301312764127, 0.21251575078162532, 0.1518074690128529, 0.2475133497488764, 0.2066120038892132, 0.20403831632455627, 0.18983969356508712, 0.06461344116143042, 0.06470641652816589, 0.04392311437347529, 0.008523985808802204, 0.022983241811502908, 0.06698037908833154, 9.999999999998899e-05, 0.006084358928725275, 0.029058140091898887, 0.11523291864101881, 0.09644064808889963, 0.14160069484177307, 0.1271931292093712, 0.1746872115975615, 0.11237954936419714, 0.13922501574289126, 0.11945487619251849, 0.16119447665635922, 0.0793031269951836, 0.1652127998777172, 0.1532818844086834, 0.11277261819565176, 0.13645077591290045, 0.08176479133260095, 0.16871407445027276, 0.10535743936955189, 0.16002098034949996, 0.1867387911901469, 0.2937896668802349, 0.1513653798396859, 0.23425890255087733, 0.1751303628864691, 0.20493620963810022, 0.15319874597920147, 0.29587951047561334, 0.21197385221566534, 0.5583797641436662, 0.5033749159645786, 0.547979400172417, 0.5324481929796634, 0.5714926861512377, 0.5228552808810205, 0.5467634160579162, 0.515211878735008, 0.5503656818986649, 0.12364900417219271, 0.1129302106982566, 0.12631791288165783, 0.11800280790394113, 0.13110235556257033, 0.13935519243019767, 0.14888696271999302, 0.11977908534790949, 0.11719109307722742, 0.1651002074210095, 0.178647402626105, 0.24519282514786522, 0.19505444428255425, 0.1830947524086075, 0.1589554821334055, 0.17795043212359318, 0.23977692059641265, 0.18846294119941298, 0.4405607532265262, 0.3985622878873756, 0.4130964778002316, 0.324754951177755, 0.5186739091808659, 0.33112662915406066, 0.38504774688431853, 0.4270011600025293, 0.5513677624927454, 0.22731667644612785, 0.26964109770603595, 0.3125618525160745, 0.2865857219328287, 0.2233706956559598, 0.2900294164209145, 0.2654452985741351, 0.3344391959903641, 0.32273273282994486, 0.1987861842448294, 0.21129427610280627, 0.22641837695839473, 0.20784395978496772, 0.21358196557578824, 0.21863389823403, 0.21509942814872307, 0.20969904232024372, 0.20698493335239088, 0.1680473196678528, 0.1923222301231553, 0.2027053623918078, 0.18113013140022793, 0.19336650432396796, 0.17970674347568605, 0.20022700432582785, 0.22110658742500366, 0.18939119161914442, 0.7312960375412391, 0.7631200205998723, 0.6398777317324479, 0.19095204701757718, 0.20105772699226587, 0.18681454327402036, 0.7493583952199063, 0.7648103785873828, 0.17167019235444492, 0.19991567695838441, 0.6858897569941402, 0.6377009990764153, 0.5684328458175971, 0.5360287741343315, 0.1981504614368268, 0.7561022033666458, 0.19963589436026075, 0.20360272478486197, 0.2023617759333315, 0.187586360948085, 0.19316873165237425, 0.18576898153257204, 0.1932543157204033, 0.19141382918491845, 0.18851374519126152, 0.19752031443378892, 0.19744005335212322, 0.12426072473155125, 0.0851837460087771, 0.08939112737148847, 0.10625401206639562, 0.09621983699254, 0.08758715649368021, 0.0906888603114896, 0.09524945494256098, 0.08382376623346444]}, "mutation_prompt": null}
{"id": "360a6f1f-94b0-4a49-bc70-ba7f69564bca", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with dynamic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.5, 1.0)  # Dynamic scaling factor adjusted\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Adjust learning rates adaptively\n            self.c1 = np.random.uniform(1.5, 2.5) * (1 - budget_used / self.budget)\n            self.c2 = np.random.uniform(1.0, 2.0) * (budget_used / self.budget)\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with adaptive dynamic mutation and learning rates for improved exploration-exploitation balance.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "18049154-f5a2-4eb2-bf61-fdb6bfa09dea", "metadata": {"aucs": [0.7872157191955759, 0.6574420632864659, 0.7917917591512056, 0.7958922074998774, 0.7989257932831402, 0.7957125243014036, 0.7913616875990871, 0.8006239380012781, 0.7950122900103148, 0.6685762701644444, 0.6528604630991643, 0.6847840749129286, 0.6509466541406084, 0.6663042841064887, 0.6776041870070177, 0.6708931169229703, 0.6834945226566687, 0.6858885159899506, 0.3713838590715587, 0.1065861809744374, 0.12633426848173512, 0.4193346031898535, 0.13174388798721248, 0.3344121603327349, 0.14632011059915817, 0.13226424293579198, 0.15330449796962387, 0.09463165870779411, 0.11215615640788623, 0.12460206783685535, 0.09788278166761188, 0.11379501566691075, 0.1036165697478304, 0.10529493402851298, 0.09986580338265227, 0.1273541087203266, 0.8532473986231971, 0.7894845214296657, 0.8883589297175674, 0.8525379384805328, 0.8098064405182981, 0.9147975753566133, 0.9721760664875496, 0.8870031984920934, 0.7552926669364651, 0.6205184432249731, 0.3385136408348116, 0.6406739670952531, 0.5959279573243443, 0.468270332257404, 0.6399169468896835, 0.5471395500511218, 0.43924148141035435, 0.19467311568366696, 0.7353279218732238, 0.7871464869440143, 0.7614457815122746, 0.7754836232762475, 0.7689870171028226, 0.7779376664619236, 0.7564630320586203, 0.7152732442927155, 0.7034226265593142, 0.14067098638089282, 0.1656723091567368, 0.21135549584402546, 0.20436532724392165, 0.13804315054005123, 0.11604567509639507, 0.16132673633558314, 0.144285228530191, 0.1426739312070704, 0.13921864915513738, 0.2965621400918138, 0.3217173645114876, 0.1350886449013502, 0.15990241082106005, 0.14148005213699943, 0.11842000657651175, 0.15866391833266713, 0.17215978609974592, 0.047411562963892706, 0.05168700376970814, 0.12627377673485862, 0.053159901362740625, 0.0033864544242520056, 0.03270404536671212, 0.030217225057243002, 0.07297954710310428, 0.02899883830409089, 0.11488837280691389, 0.1407303282081821, 0.12951262300214528, 0.13399519669279614, 0.12102030348970749, 0.10018383718379287, 0.13832813503874553, 0.2062956162398779, 0.12969816555700886, 0.1730931979226007, 0.04231499348826251, 0.0804195689508711, 0.21532986241963303, 0.18807125152386706, 0.11927586420379088, 0.25570255899608696, 0.2175705571032499, 0.11438920698614419, 0.10014969782956906, 0.22591218823419112, 0.24087660062864857, 0.22876031031316302, 0.15143648404829058, 0.24977639051303224, 0.19751840497560924, 0.3409170516342398, 0.19307960393545143, 0.518014720971101, 0.5985645179616477, 0.5238363535947699, 0.49814423972946564, 0.5465658751910167, 0.5783322148754144, 0.5247232937136073, 0.5462736162644704, 0.5264967263203234, 0.12465381289832622, 0.14620648442735218, 0.12963340841476145, 0.10762507173349056, 0.10644366080268486, 0.11457176098934874, 0.15034157466436993, 0.1258723067042825, 0.12339421391261951, 0.18687950036442835, 0.15519500135246056, 0.17127369110966406, 0.1734231298434894, 0.18076832272845422, 0.15482790024530313, 0.16739160596818203, 0.18270314996918535, 0.1783682352743614, 0.4463004531587097, 0.3639901913537147, 0.4669289143643418, 0.46955394460224564, 0.4072494696452368, 0.3081003720529306, 0.33671504126356233, 0.3666887796514411, 0.5194828226165522, 0.29527694733133814, 0.3335895165554904, 0.23665079012393664, 0.3255827952284198, 0.3991321585784261, 0.35609195444961794, 0.2911788758122168, 0.20876507948999812, 0.2672160934101536, 0.21954388553323412, 0.22262914530289568, 0.22822301912482867, 0.21223886614070286, 0.21465838602765475, 0.21929271898810365, 0.21083422277214647, 0.2146004720843262, 0.25380583428983905, 0.18042059547937295, 0.20240672267539117, 0.2198421427783931, 0.2082563294843488, 0.19604210477941575, 0.22710719259153545, 0.19747399426613166, 0.17613578183401246, 0.20139685593687495, 0.7385223026739401, 0.7331910064875534, 0.8032437570145959, 0.692390874590616, 0.1894563991342021, 0.6665536315438595, 0.6820408702343952, 0.18763394046024706, 0.7422384641503671, 0.5286578067569395, 0.20064933239398197, 0.7038089536003094, 0.7053220776157942, 0.4277690926916078, 0.6614121988563331, 0.7016551360874844, 0.14932361336082833, 0.19363519262304674, 0.18924742620707746, 0.2032409188424219, 0.19695001896225162, 0.18987463017972595, 0.19254598129092693, 0.19464306221711958, 0.1867119189557438, 0.17939569105229003, 0.21516816256738447, 0.09214593297702067, 0.08700924470776594, 0.08221678144331657, 0.11160965224590402, 0.09051815489802817, 0.09733232953929238, 0.0803706170518439, 0.08641385720910166, 0.08624991347229227]}, "mutation_prompt": null}
{"id": "41245321-a5fa-48b6-a77c-ccf389ad63d8", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with dynamic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.5, 1.0)  # Dynamic scaling factor adjusted\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Adjust learning rates adaptively\n            self.c1 = np.random.uniform(1.5, 2.5) * (1 - budget_used / self.budget)\n            self.c2 = np.random.uniform(1.0, 2.0) * (budget_used / self.budget)\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with adaptive dynamic mutation and learning rates for improved exploration-exploitation balance.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "18049154-f5a2-4eb2-bf61-fdb6bfa09dea", "metadata": {"aucs": [0.7872157191955759, 0.6574420632864659, 0.7917917591512056, 0.7958922074998774, 0.7989257932831402, 0.7957125243014036, 0.7913616875990871, 0.8006239380012781, 0.7950122900103148, 0.6685762701644444, 0.6528604630991643, 0.6847840749129286, 0.6509466541406084, 0.6663042841064887, 0.6776041870070177, 0.6708931169229703, 0.6834945226566687, 0.6858885159899506, 0.3713838590715587, 0.1065861809744374, 0.12633426848173512, 0.4193346031898535, 0.13174388798721248, 0.3344121603327349, 0.14632011059915817, 0.13226424293579198, 0.15330449796962387, 0.09463165870779411, 0.11215615640788623, 0.12460206783685535, 0.09788278166761188, 0.11379501566691075, 0.1036165697478304, 0.10529493402851298, 0.09986580338265227, 0.1273541087203266, 0.8532473986231971, 0.7894845214296657, 0.8883589297175674, 0.8525379384805328, 0.8098064405182981, 0.9147975753566133, 0.9721760664875496, 0.8870031984920934, 0.7552926669364651, 0.6205184432249731, 0.3385136408348116, 0.6406739670952531, 0.5959279573243443, 0.468270332257404, 0.6399169468896835, 0.5471395500511218, 0.43924148141035435, 0.19467311568366696, 0.7353279218732238, 0.7871464869440143, 0.7614457815122746, 0.7754836232762475, 0.7689870171028226, 0.7779376664619236, 0.7564630320586203, 0.7152732442927155, 0.7034226265593142, 0.14067098638089282, 0.1656723091567368, 0.21135549584402546, 0.20436532724392165, 0.13804315054005123, 0.11604567509639507, 0.16132673633558314, 0.144285228530191, 0.1426739312070704, 0.13921864915513738, 0.2965621400918138, 0.3217173645114876, 0.1350886449013502, 0.15990241082106005, 0.14148005213699943, 0.11842000657651175, 0.15866391833266713, 0.17215978609974592, 0.047411562963892706, 0.05168700376970814, 0.12627377673485862, 0.053159901362740625, 0.0033864544242520056, 0.03270404536671212, 0.030217225057243002, 0.07297954710310428, 0.02899883830409089, 0.11488837280691389, 0.1407303282081821, 0.12951262300214528, 0.13399519669279614, 0.12102030348970749, 0.10018383718379287, 0.13832813503874553, 0.2062956162398779, 0.12969816555700886, 0.1730931979226007, 0.04231499348826251, 0.0804195689508711, 0.21532986241963303, 0.18807125152386706, 0.11927586420379088, 0.25570255899608696, 0.2175705571032499, 0.11438920698614419, 0.10014969782956906, 0.22591218823419112, 0.24087660062864857, 0.22876031031316302, 0.15143648404829058, 0.24977639051303224, 0.19751840497560924, 0.3409170516342398, 0.19307960393545143, 0.518014720971101, 0.5985645179616477, 0.5238363535947699, 0.49814423972946564, 0.5465658751910167, 0.5783322148754144, 0.5247232937136073, 0.5462736162644704, 0.5264967263203234, 0.12465381289832622, 0.14620648442735218, 0.12963340841476145, 0.10762507173349056, 0.10644366080268486, 0.11457176098934874, 0.15034157466436993, 0.1258723067042825, 0.12339421391261951, 0.18687950036442835, 0.15519500135246056, 0.17127369110966406, 0.1734231298434894, 0.18076832272845422, 0.15482790024530313, 0.16739160596818203, 0.18270314996918535, 0.1783682352743614, 0.4463004531587097, 0.3639901913537147, 0.4669289143643418, 0.46955394460224564, 0.4072494696452368, 0.3081003720529306, 0.33671504126356233, 0.3666887796514411, 0.5194828226165522, 0.29527694733133814, 0.3335895165554904, 0.23665079012393664, 0.3255827952284198, 0.3991321585784261, 0.35609195444961794, 0.2911788758122168, 0.20876507948999812, 0.2672160934101536, 0.21954388553323412, 0.22262914530289568, 0.22822301912482867, 0.21223886614070286, 0.21465838602765475, 0.21929271898810365, 0.21083422277214647, 0.2146004720843262, 0.25380583428983905, 0.18042059547937295, 0.20240672267539117, 0.2198421427783931, 0.2082563294843488, 0.19604210477941575, 0.22710719259153545, 0.19747399426613166, 0.17613578183401246, 0.20139685593687495, 0.7385223026739401, 0.7331910064875534, 0.8032437570145959, 0.692390874590616, 0.1894563991342021, 0.6665536315438595, 0.6820408702343952, 0.18763394046024706, 0.7422384641503671, 0.5286578067569395, 0.20064933239398197, 0.7038089536003094, 0.7053220776157942, 0.4277690926916078, 0.6614121988563331, 0.7016551360874844, 0.14932361336082833, 0.19363519262304674, 0.18924742620707746, 0.2032409188424219, 0.19695001896225162, 0.18987463017972595, 0.19254598129092693, 0.19464306221711958, 0.1867119189557438, 0.17939569105229003, 0.21516816256738447, 0.09214593297702067, 0.08700924470776594, 0.08221678144331657, 0.11160965224590402, 0.09051815489802817, 0.09733232953929238, 0.0803706170518439, 0.08641385720910166, 0.08624991347229227]}, "mutation_prompt": null}
{"id": "a27b70a8-6e41-4902-8aa1-731198524328", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with dynamic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.5, 1.0)  # Dynamic scaling factor adjusted\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Adjust learning rates adaptively\n            self.c1 = np.random.uniform(1.5, 2.5) * (1 - budget_used / self.budget)\n            self.c2 = np.random.uniform(1.0, 2.0) * (budget_used / self.budget)\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with adaptive dynamic mutation and learning rates for improved exploration-exploitation balance.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "18049154-f5a2-4eb2-bf61-fdb6bfa09dea", "metadata": {"aucs": [0.7872157191955759, 0.6574420632864659, 0.7917917591512056, 0.7958922074998774, 0.7989257932831402, 0.7957125243014036, 0.7913616875990871, 0.8006239380012781, 0.7950122900103148, 0.6685762701644444, 0.6528604630991643, 0.6847840749129286, 0.6509466541406084, 0.6663042841064887, 0.6776041870070177, 0.6708931169229703, 0.6834945226566687, 0.6858885159899506, 0.3713838590715587, 0.1065861809744374, 0.12633426848173512, 0.4193346031898535, 0.13174388798721248, 0.3344121603327349, 0.14632011059915817, 0.13226424293579198, 0.15330449796962387, 0.09463165870779411, 0.11215615640788623, 0.12460206783685535, 0.09788278166761188, 0.11379501566691075, 0.1036165697478304, 0.10529493402851298, 0.09986580338265227, 0.1273541087203266, 0.8532473986231971, 0.7894845214296657, 0.8883589297175674, 0.8525379384805328, 0.8098064405182981, 0.9147975753566133, 0.9721760664875496, 0.8870031984920934, 0.7552926669364651, 0.6205184432249731, 0.3385136408348116, 0.6406739670952531, 0.5959279573243443, 0.468270332257404, 0.6399169468896835, 0.5471395500511218, 0.43924148141035435, 0.19467311568366696, 0.7353279218732238, 0.7871464869440143, 0.7614457815122746, 0.7754836232762475, 0.7689870171028226, 0.7779376664619236, 0.7564630320586203, 0.7152732442927155, 0.7034226265593142, 0.14067098638089282, 0.1656723091567368, 0.21135549584402546, 0.20436532724392165, 0.13804315054005123, 0.11604567509639507, 0.16132673633558314, 0.144285228530191, 0.1426739312070704, 0.13921864915513738, 0.2965621400918138, 0.3217173645114876, 0.1350886449013502, 0.15990241082106005, 0.14148005213699943, 0.11842000657651175, 0.15866391833266713, 0.17215978609974592, 0.047411562963892706, 0.05168700376970814, 0.12627377673485862, 0.053159901362740625, 0.0033864544242520056, 0.03270404536671212, 0.030217225057243002, 0.07297954710310428, 0.02899883830409089, 0.11488837280691389, 0.1407303282081821, 0.12951262300214528, 0.13399519669279614, 0.12102030348970749, 0.10018383718379287, 0.13832813503874553, 0.2062956162398779, 0.12969816555700886, 0.1730931979226007, 0.04231499348826251, 0.0804195689508711, 0.21532986241963303, 0.18807125152386706, 0.11927586420379088, 0.25570255899608696, 0.2175705571032499, 0.11438920698614419, 0.10014969782956906, 0.22591218823419112, 0.24087660062864857, 0.22876031031316302, 0.15143648404829058, 0.24977639051303224, 0.19751840497560924, 0.3409170516342398, 0.19307960393545143, 0.518014720971101, 0.5985645179616477, 0.5238363535947699, 0.49814423972946564, 0.5465658751910167, 0.5783322148754144, 0.5247232937136073, 0.5462736162644704, 0.5264967263203234, 0.12465381289832622, 0.14620648442735218, 0.12963340841476145, 0.10762507173349056, 0.10644366080268486, 0.11457176098934874, 0.15034157466436993, 0.1258723067042825, 0.12339421391261951, 0.18687950036442835, 0.15519500135246056, 0.17127369110966406, 0.1734231298434894, 0.18076832272845422, 0.15482790024530313, 0.16739160596818203, 0.18270314996918535, 0.1783682352743614, 0.4463004531587097, 0.3639901913537147, 0.4669289143643418, 0.46955394460224564, 0.4072494696452368, 0.3081003720529306, 0.33671504126356233, 0.3666887796514411, 0.5194828226165522, 0.29527694733133814, 0.3335895165554904, 0.23665079012393664, 0.3255827952284198, 0.3991321585784261, 0.35609195444961794, 0.2911788758122168, 0.20876507948999812, 0.2672160934101536, 0.21954388553323412, 0.22262914530289568, 0.22822301912482867, 0.21223886614070286, 0.21465838602765475, 0.21929271898810365, 0.21083422277214647, 0.2146004720843262, 0.25380583428983905, 0.18042059547937295, 0.20240672267539117, 0.2198421427783931, 0.2082563294843488, 0.19604210477941575, 0.22710719259153545, 0.19747399426613166, 0.17613578183401246, 0.20139685593687495, 0.7385223026739401, 0.7331910064875534, 0.8032437570145959, 0.692390874590616, 0.1894563991342021, 0.6665536315438595, 0.6820408702343952, 0.18763394046024706, 0.7422384641503671, 0.5286578067569395, 0.20064933239398197, 0.7038089536003094, 0.7053220776157942, 0.4277690926916078, 0.6614121988563331, 0.7016551360874844, 0.14932361336082833, 0.19363519262304674, 0.18924742620707746, 0.2032409188424219, 0.19695001896225162, 0.18987463017972595, 0.19254598129092693, 0.19464306221711958, 0.1867119189557438, 0.17939569105229003, 0.21516816256738447, 0.09214593297702067, 0.08700924470776594, 0.08221678144331657, 0.11160965224590402, 0.09051815489802817, 0.09733232953929238, 0.0803706170518439, 0.08641385720910166, 0.08624991347229227]}, "mutation_prompt": null}
{"id": "ef9aa339-bbde-4a7f-9f82-ff1d075d336f", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with dynamic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.5, 1.0)  # Dynamic scaling factor adjusted\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Adjust learning rates adaptively\n            self.c1 = np.random.uniform(1.5, 2.5) * (1 - budget_used / self.budget)\n            self.c2 = np.random.uniform(1.0, 2.0) * (budget_used / self.budget)\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with adaptive dynamic mutation and learning rates for improved exploration-exploitation balance.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "18049154-f5a2-4eb2-bf61-fdb6bfa09dea", "metadata": {"aucs": [0.7872157191955759, 0.6574420632864659, 0.7917917591512056, 0.7958922074998774, 0.7989257932831402, 0.7957125243014036, 0.7913616875990871, 0.8006239380012781, 0.7950122900103148, 0.6685762701644444, 0.6528604630991643, 0.6847840749129286, 0.6509466541406084, 0.6663042841064887, 0.6776041870070177, 0.6708931169229703, 0.6834945226566687, 0.6858885159899506, 0.3713838590715587, 0.1065861809744374, 0.12633426848173512, 0.4193346031898535, 0.13174388798721248, 0.3344121603327349, 0.14632011059915817, 0.13226424293579198, 0.15330449796962387, 0.09463165870779411, 0.11215615640788623, 0.12460206783685535, 0.09788278166761188, 0.11379501566691075, 0.1036165697478304, 0.10529493402851298, 0.09986580338265227, 0.1273541087203266, 0.8532473986231971, 0.7894845214296657, 0.8883589297175674, 0.8525379384805328, 0.8098064405182981, 0.9147975753566133, 0.9721760664875496, 0.8870031984920934, 0.7552926669364651, 0.6205184432249731, 0.3385136408348116, 0.6406739670952531, 0.5959279573243443, 0.468270332257404, 0.6399169468896835, 0.5471395500511218, 0.43924148141035435, 0.19467311568366696, 0.7353279218732238, 0.7871464869440143, 0.7614457815122746, 0.7754836232762475, 0.7689870171028226, 0.7779376664619236, 0.7564630320586203, 0.7152732442927155, 0.7034226265593142, 0.14067098638089282, 0.1656723091567368, 0.21135549584402546, 0.20436532724392165, 0.13804315054005123, 0.11604567509639507, 0.16132673633558314, 0.144285228530191, 0.1426739312070704, 0.13921864915513738, 0.2965621400918138, 0.3217173645114876, 0.1350886449013502, 0.15990241082106005, 0.14148005213699943, 0.11842000657651175, 0.15866391833266713, 0.17215978609974592, 0.047411562963892706, 0.05168700376970814, 0.12627377673485862, 0.053159901362740625, 0.0033864544242520056, 0.03270404536671212, 0.030217225057243002, 0.07297954710310428, 0.02899883830409089, 0.11488837280691389, 0.1407303282081821, 0.12951262300214528, 0.13399519669279614, 0.12102030348970749, 0.10018383718379287, 0.13832813503874553, 0.2062956162398779, 0.12969816555700886, 0.1730931979226007, 0.04231499348826251, 0.0804195689508711, 0.21532986241963303, 0.18807125152386706, 0.11927586420379088, 0.25570255899608696, 0.2175705571032499, 0.11438920698614419, 0.10014969782956906, 0.22591218823419112, 0.24087660062864857, 0.22876031031316302, 0.15143648404829058, 0.24977639051303224, 0.19751840497560924, 0.3409170516342398, 0.19307960393545143, 0.518014720971101, 0.5985645179616477, 0.5238363535947699, 0.49814423972946564, 0.5465658751910167, 0.5783322148754144, 0.5247232937136073, 0.5462736162644704, 0.5264967263203234, 0.12465381289832622, 0.14620648442735218, 0.12963340841476145, 0.10762507173349056, 0.10644366080268486, 0.11457176098934874, 0.15034157466436993, 0.1258723067042825, 0.12339421391261951, 0.18687950036442835, 0.15519500135246056, 0.17127369110966406, 0.1734231298434894, 0.18076832272845422, 0.15482790024530313, 0.16739160596818203, 0.18270314996918535, 0.1783682352743614, 0.4463004531587097, 0.3639901913537147, 0.4669289143643418, 0.46955394460224564, 0.4072494696452368, 0.3081003720529306, 0.33671504126356233, 0.3666887796514411, 0.5194828226165522, 0.29527694733133814, 0.3335895165554904, 0.23665079012393664, 0.3255827952284198, 0.3991321585784261, 0.35609195444961794, 0.2911788758122168, 0.20876507948999812, 0.2672160934101536, 0.21954388553323412, 0.22262914530289568, 0.22822301912482867, 0.21223886614070286, 0.21465838602765475, 0.21929271898810365, 0.21083422277214647, 0.2146004720843262, 0.25380583428983905, 0.18042059547937295, 0.20240672267539117, 0.2198421427783931, 0.2082563294843488, 0.19604210477941575, 0.22710719259153545, 0.19747399426613166, 0.17613578183401246, 0.20139685593687495, 0.7385223026739401, 0.7331910064875534, 0.8032437570145959, 0.692390874590616, 0.1894563991342021, 0.6665536315438595, 0.6820408702343952, 0.18763394046024706, 0.7422384641503671, 0.5286578067569395, 0.20064933239398197, 0.7038089536003094, 0.7053220776157942, 0.4277690926916078, 0.6614121988563331, 0.7016551360874844, 0.14932361336082833, 0.19363519262304674, 0.18924742620707746, 0.2032409188424219, 0.19695001896225162, 0.18987463017972595, 0.19254598129092693, 0.19464306221711958, 0.1867119189557438, 0.17939569105229003, 0.21516816256738447, 0.09214593297702067, 0.08700924470776594, 0.08221678144331657, 0.11160965224590402, 0.09051815489802817, 0.09733232953929238, 0.0803706170518439, 0.08641385720910166, 0.08624991347229227]}, "mutation_prompt": null}
{"id": "807f0924-3814-45b3-b8a8-f7fb0e0719c3", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with dynamic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.5, 1.0)  # Dynamic scaling factor adjusted\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Adjust learning rates adaptively\n            self.c1 = np.random.uniform(1.5, 2.5) * (1 - budget_used / self.budget)\n            self.c2 = np.random.uniform(1.0, 2.0) * (budget_used / self.budget)\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with adaptive dynamic mutation and learning rates for improved exploration-exploitation balance.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "18049154-f5a2-4eb2-bf61-fdb6bfa09dea", "metadata": {"aucs": [0.7872157191955759, 0.6574420632864659, 0.7917917591512056, 0.7958922074998774, 0.7989257932831402, 0.7957125243014036, 0.7913616875990871, 0.8006239380012781, 0.7950122900103148, 0.6685762701644444, 0.6528604630991643, 0.6847840749129286, 0.6509466541406084, 0.6663042841064887, 0.6776041870070177, 0.6708931169229703, 0.6834945226566687, 0.6858885159899506, 0.3713838590715587, 0.1065861809744374, 0.12633426848173512, 0.4193346031898535, 0.13174388798721248, 0.3344121603327349, 0.14632011059915817, 0.13226424293579198, 0.15330449796962387, 0.09463165870779411, 0.11215615640788623, 0.12460206783685535, 0.09788278166761188, 0.11379501566691075, 0.1036165697478304, 0.10529493402851298, 0.09986580338265227, 0.1273541087203266, 0.8532473986231971, 0.7894845214296657, 0.8883589297175674, 0.8525379384805328, 0.8098064405182981, 0.9147975753566133, 0.9721760664875496, 0.8870031984920934, 0.7552926669364651, 0.6205184432249731, 0.3385136408348116, 0.6406739670952531, 0.5959279573243443, 0.468270332257404, 0.6399169468896835, 0.5471395500511218, 0.43924148141035435, 0.19467311568366696, 0.7353279218732238, 0.7871464869440143, 0.7614457815122746, 0.7754836232762475, 0.7689870171028226, 0.7779376664619236, 0.7564630320586203, 0.7152732442927155, 0.7034226265593142, 0.14067098638089282, 0.1656723091567368, 0.21135549584402546, 0.20436532724392165, 0.13804315054005123, 0.11604567509639507, 0.16132673633558314, 0.144285228530191, 0.1426739312070704, 0.13921864915513738, 0.2965621400918138, 0.3217173645114876, 0.1350886449013502, 0.15990241082106005, 0.14148005213699943, 0.11842000657651175, 0.15866391833266713, 0.17215978609974592, 0.047411562963892706, 0.05168700376970814, 0.12627377673485862, 0.053159901362740625, 0.0033864544242520056, 0.03270404536671212, 0.030217225057243002, 0.07297954710310428, 0.02899883830409089, 0.11488837280691389, 0.1407303282081821, 0.12951262300214528, 0.13399519669279614, 0.12102030348970749, 0.10018383718379287, 0.13832813503874553, 0.2062956162398779, 0.12969816555700886, 0.1730931979226007, 0.04231499348826251, 0.0804195689508711, 0.21532986241963303, 0.18807125152386706, 0.11927586420379088, 0.25570255899608696, 0.2175705571032499, 0.11438920698614419, 0.10014969782956906, 0.22591218823419112, 0.24087660062864857, 0.22876031031316302, 0.15143648404829058, 0.24977639051303224, 0.19751840497560924, 0.3409170516342398, 0.19307960393545143, 0.518014720971101, 0.5985645179616477, 0.5238363535947699, 0.49814423972946564, 0.5465658751910167, 0.5783322148754144, 0.5247232937136073, 0.5462736162644704, 0.5264967263203234, 0.12465381289832622, 0.14620648442735218, 0.12963340841476145, 0.10762507173349056, 0.10644366080268486, 0.11457176098934874, 0.15034157466436993, 0.1258723067042825, 0.12339421391261951, 0.18687950036442835, 0.15519500135246056, 0.17127369110966406, 0.1734231298434894, 0.18076832272845422, 0.15482790024530313, 0.16739160596818203, 0.18270314996918535, 0.1783682352743614, 0.4463004531587097, 0.3639901913537147, 0.4669289143643418, 0.46955394460224564, 0.4072494696452368, 0.3081003720529306, 0.33671504126356233, 0.3666887796514411, 0.5194828226165522, 0.29527694733133814, 0.3335895165554904, 0.23665079012393664, 0.3255827952284198, 0.3991321585784261, 0.35609195444961794, 0.2911788758122168, 0.20876507948999812, 0.2672160934101536, 0.21954388553323412, 0.22262914530289568, 0.22822301912482867, 0.21223886614070286, 0.21465838602765475, 0.21929271898810365, 0.21083422277214647, 0.2146004720843262, 0.25380583428983905, 0.18042059547937295, 0.20240672267539117, 0.2198421427783931, 0.2082563294843488, 0.19604210477941575, 0.22710719259153545, 0.19747399426613166, 0.17613578183401246, 0.20139685593687495, 0.7385223026739401, 0.7331910064875534, 0.8032437570145959, 0.692390874590616, 0.1894563991342021, 0.6665536315438595, 0.6820408702343952, 0.18763394046024706, 0.7422384641503671, 0.5286578067569395, 0.20064933239398197, 0.7038089536003094, 0.7053220776157942, 0.4277690926916078, 0.6614121988563331, 0.7016551360874844, 0.14932361336082833, 0.19363519262304674, 0.18924742620707746, 0.2032409188424219, 0.19695001896225162, 0.18987463017972595, 0.19254598129092693, 0.19464306221711958, 0.1867119189557438, 0.17939569105229003, 0.21516816256738447, 0.09214593297702067, 0.08700924470776594, 0.08221678144331657, 0.11160965224590402, 0.09051815489802817, 0.09733232953929238, 0.0803706170518439, 0.08641385720910166, 0.08624991347229227]}, "mutation_prompt": null}
{"id": "2dcae5c8-6406-47c3-b781-d7ee30734627", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.initial_pop_size = self.pop_size\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        while budget_used < self.budget:\n            # Dynamic population resizing\n            self.pop_size = max(10, self.initial_pop_size - budget_used // (self.budget // 10))\n            population = population[:self.pop_size]\n            velocities = velocities[:self.pop_size]\n            fitness = fitness[:self.pop_size]\n            personal_best = personal_best[:self.pop_size]\n            personal_best_fitness = personal_best_fitness[:self.pop_size]\n\n            # Differential Evolution with dynamic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.5, 1.0)  # Dynamic scaling factor adjusted\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Adjust learning rates adaptively\n            self.c1 = np.random.uniform(1.5, 2.5) * (1 - budget_used / self.budget)\n            self.c2 = np.random.uniform(1.0, 2.0) * (budget_used / self.budget)\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with dynamic population resizing and adaptive inertia for improved convergence.", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 46').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 46')", "parent_id": "18049154-f5a2-4eb2-bf61-fdb6bfa09dea", "metadata": {}, "mutation_prompt": null}
{"id": "06a526e0-4576-4c00-bde4-b875dc1bc07b", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with dynamic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.5, 1.0)  # Dynamic scaling factor adjusted\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Adjust learning rates adaptively\n            self.c1 = np.random.uniform(1.5, 2.5) * (1 - budget_used / self.budget)\n            self.c2 = np.random.uniform(1.0, 2.0) * (budget_used / self.budget)\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with adaptive dynamic mutation and learning rates for improved exploration-exploitation balance.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "18049154-f5a2-4eb2-bf61-fdb6bfa09dea", "metadata": {"aucs": [0.7872157191955759, 0.6574420632864659, 0.7917917591512056, 0.7958922074998774, 0.7989257932831402, 0.7957125243014036, 0.7913616875990871, 0.8006239380012781, 0.7950122900103148, 0.6685762701644444, 0.6528604630991643, 0.6847840749129286, 0.6509466541406084, 0.6663042841064887, 0.6776041870070177, 0.6708931169229703, 0.6834945226566687, 0.6858885159899506, 0.3713838590715587, 0.1065861809744374, 0.12633426848173512, 0.4193346031898535, 0.13174388798721248, 0.3344121603327349, 0.14632011059915817, 0.13226424293579198, 0.15330449796962387, 0.09463165870779411, 0.11215615640788623, 0.12460206783685535, 0.09788278166761188, 0.11379501566691075, 0.1036165697478304, 0.10529493402851298, 0.09986580338265227, 0.1273541087203266, 0.8532473986231971, 0.7894845214296657, 0.8883589297175674, 0.8525379384805328, 0.8098064405182981, 0.9147975753566133, 0.9721760664875496, 0.8870031984920934, 0.7552926669364651, 0.6205184432249731, 0.3385136408348116, 0.6406739670952531, 0.5959279573243443, 0.468270332257404, 0.6399169468896835, 0.5471395500511218, 0.43924148141035435, 0.19467311568366696, 0.7353279218732238, 0.7871464869440143, 0.7614457815122746, 0.7754836232762475, 0.7689870171028226, 0.7779376664619236, 0.7564630320586203, 0.7152732442927155, 0.7034226265593142, 0.14067098638089282, 0.1656723091567368, 0.21135549584402546, 0.20436532724392165, 0.13804315054005123, 0.11604567509639507, 0.16132673633558314, 0.144285228530191, 0.1426739312070704, 0.13921864915513738, 0.2965621400918138, 0.3217173645114876, 0.1350886449013502, 0.15990241082106005, 0.14148005213699943, 0.11842000657651175, 0.15866391833266713, 0.17215978609974592, 0.047411562963892706, 0.05168700376970814, 0.12627377673485862, 0.053159901362740625, 0.0033864544242520056, 0.03270404536671212, 0.030217225057243002, 0.07297954710310428, 0.02899883830409089, 0.11488837280691389, 0.1407303282081821, 0.12951262300214528, 0.13399519669279614, 0.12102030348970749, 0.10018383718379287, 0.13832813503874553, 0.2062956162398779, 0.12969816555700886, 0.1730931979226007, 0.04231499348826251, 0.0804195689508711, 0.21532986241963303, 0.18807125152386706, 0.11927586420379088, 0.25570255899608696, 0.2175705571032499, 0.11438920698614419, 0.10014969782956906, 0.22591218823419112, 0.24087660062864857, 0.22876031031316302, 0.15143648404829058, 0.24977639051303224, 0.19751840497560924, 0.3409170516342398, 0.19307960393545143, 0.518014720971101, 0.5985645179616477, 0.5238363535947699, 0.49814423972946564, 0.5465658751910167, 0.5783322148754144, 0.5247232937136073, 0.5462736162644704, 0.5264967263203234, 0.12465381289832622, 0.14620648442735218, 0.12963340841476145, 0.10762507173349056, 0.10644366080268486, 0.11457176098934874, 0.15034157466436993, 0.1258723067042825, 0.12339421391261951, 0.18687950036442835, 0.15519500135246056, 0.17127369110966406, 0.1734231298434894, 0.18076832272845422, 0.15482790024530313, 0.16739160596818203, 0.18270314996918535, 0.1783682352743614, 0.4463004531587097, 0.3639901913537147, 0.4669289143643418, 0.46955394460224564, 0.4072494696452368, 0.3081003720529306, 0.33671504126356233, 0.3666887796514411, 0.5194828226165522, 0.29527694733133814, 0.3335895165554904, 0.23665079012393664, 0.3255827952284198, 0.3991321585784261, 0.35609195444961794, 0.2911788758122168, 0.20876507948999812, 0.2672160934101536, 0.21954388553323412, 0.22262914530289568, 0.22822301912482867, 0.21223886614070286, 0.21465838602765475, 0.21929271898810365, 0.21083422277214647, 0.2146004720843262, 0.25380583428983905, 0.18042059547937295, 0.20240672267539117, 0.2198421427783931, 0.2082563294843488, 0.19604210477941575, 0.22710719259153545, 0.19747399426613166, 0.17613578183401246, 0.20139685593687495, 0.7385223026739401, 0.7331910064875534, 0.8032437570145959, 0.692390874590616, 0.1894563991342021, 0.6665536315438595, 0.6820408702343952, 0.18763394046024706, 0.7422384641503671, 0.5286578067569395, 0.20064933239398197, 0.7038089536003094, 0.7053220776157942, 0.4277690926916078, 0.6614121988563331, 0.7016551360874844, 0.14932361336082833, 0.19363519262304674, 0.18924742620707746, 0.2032409188424219, 0.19695001896225162, 0.18987463017972595, 0.19254598129092693, 0.19464306221711958, 0.1867119189557438, 0.17939569105229003, 0.21516816256738447, 0.09214593297702067, 0.08700924470776594, 0.08221678144331657, 0.11160965224590402, 0.09051815489802817, 0.09733232953929238, 0.0803706170518439, 0.08641385720910166, 0.08624991347229227]}, "mutation_prompt": null}
{"id": "01f5f91d-fbd2-443b-a3bd-8e8808be497f", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with dynamic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.5, 1.0)  # Dynamic scaling factor adjusted\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Adjust learning rates adaptively\n            diversity = np.std(fitness) / (np.mean(fitness) + 1e-9)\n            self.c1 = np.random.uniform(1.5, 2.5) * (1 - diversity)\n            self.c2 = np.random.uniform(1.0, 2.0) * diversity\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Improved adaptive DE-PSO algorithm with enhanced local search through fitness diversity and dynamic parameter adjustment.", "configspace": "", "generation": 76, "fitness": 0.22531326686770914, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "18049154-f5a2-4eb2-bf61-fdb6bfa09dea", "metadata": {"aucs": [0.46597511903408273, 0.48316215371221893, 0.5142083703151508, 0.4694049483639763, 0.4625933296988163, 0.4471151385272125, 0.4230130616873117, 0.43922580927109567, 0.40989571942249414, 0.04538441045425934, 0.07948548711466596, 0.06788049432601984, 0.07190602873306251, 0.08462957418461359, 0.054884400435997516, 0.08307908543219233, 0.10214389581334071, 0.06993446237998036, 0.08647991835097091, 0.08656783089321962, 0.08904101935400754, 0.13366574077671722, 0.141793246346279, 0.18103144866042786, 0.12661149228327473, 0.1258891436027001, 0.13518644155083626, 0.0810663353759099, 0.08301287646337552, 0.07420354713000066, 0.0949429229100317, 0.10594028007456124, 0.12109526089021694, 0.10451177301916892, 0.09931794805722438, 0.11666254738193094, 0.9553544255400725, 0.9460399389755042, 0.9510726016612249, 0.8911447086740713, 0.8609974122931019, 0.8752482062268463, 0.9723009363476557, 0.9145661229417142, 0.8539218030517197, 0.11554367965076506, 0.14745315173614104, 0.17321919374882777, 0.12367313238331845, 0.2384598769551105, 0.3139350123398118, 0.2244500142675666, 0.16534961959552696, 0.19556751440657294, 0.42506013536043885, 0.4157399930991523, 0.4261318063112104, 0.4960245345908306, 0.6151769099051407, 0.5589348137907477, 0.6534287681183117, 0.7120507248828815, 0.6137441835799811, 0.11569023697171577, 0.2051258584283988, 0.3138412515446036, 0.13895017011986732, 0.08322501078302702, 0.10989027139605001, 0.23856505171060438, 0.22856730036579187, 0.18364892534054866, 0.17961916331320393, 0.1607498932827035, 0.1833468753132076, 0.2273761404226069, 0.19234242187375172, 0.19535626971158593, 0.17011969074934807, 0.16115144784358604, 0.2629304583870672, 0.027382461980481998, 0.03507929299271639, 0.028811770822412153, 0.02623171709174299, 0.005233654861973469, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02441206745908553, 0.06547509447113009, 0.04628388519890614, 0.042048725582595425, 0.03862791765966267, 0.05847170102111232, 0.0030513361868111932, 0.020819492573679432, 0.07128847379563663, 0.10048378583339923, 0.03148748905364973, 0.013063139118598466, 0.04286637034915597, 0.048901881233005096, 0.02222845150846564, 0.037294230685876895, 0.18167296496193852, 0.13232454098126945, 0.09138167140308451, 0.23887564314427745, 0.2597065158995526, 0.19139234147277628, 0.07097857255841122, 0.04600925252826349, 0.0822108254228564, 0.14328934921008762, 0.0885711339373183, 0.07421627391097152, 0.41563030347613505, 0.4275620240338258, 0.40495036394337613, 0.3752820720117993, 0.37425523422750595, 0.3631129160441525, 0.4064150243671073, 0.4237795560502552, 0.4333531524816583, 0.07905814071161588, 0.09767747625248757, 0.09113912188598239, 0.09948395947451172, 0.14105765765283307, 0.10245917933175064, 0.07216905696757547, 0.05773196178596185, 0.06226570776717566, 0.1784190540703392, 0.16631417508288182, 0.17411395174172994, 0.16383015093235265, 0.18823073272832913, 0.1863499623404451, 0.16917585012236014, 0.17189583165201805, 0.16856276737435816, 0.21505174375342961, 0.20827514555401505, 0.20929058470756579, 0.2705718703879113, 0.24627012023640904, 0.26137695368619895, 0.241973000556841, 0.23164466424499452, 0.2464303967687692, 0.1551672443582207, 0.14155272912674832, 0.13867586846966773, 0.23783465532286951, 0.2477973466329194, 0.23220032360010756, 0.16428021798835868, 0.19182522142168423, 0.1787778600808, 0.1717558812915173, 0.19469366666777765, 0.21010666520576404, 0.19986745067206624, 0.2146329830634739, 0.209315113847792, 0.2372981257266098, 0.19981239928259642, 0.2230952979061398, 0.17553639876007843, 0.17202772836718083, 0.18519088202525036, 0.18936529236760136, 0.16936336107276928, 0.1944291873148305, 0.1965036445282089, 0.19962219184841956, 0.18238743897569065, 0.7143837536453619, 0.5097739600727572, 0.7428805796122537, 0.19415712047810252, 0.41877883112852465, 0.16689601159783052, 0.22151494792783144, 0.41424182867951465, 0.1969738772052838, 0.18423132473863768, 0.185045722640231, 0.226892815765798, 0.2294056745457258, 0.197339601845273, 0.19465907991217324, 0.196984928147804, 0.19157175244186675, 0.20027423607670714, 0.1977639826307811, 0.1825734462132288, 0.19449778993187117, 0.21112202877923314, 0.193978066192948, 0.1749322815203812, 0.20572466193209205, 0.2156898099463791, 0.21748887558183883, 0.08865407349405197, 0.081994467283104, 0.089646304732661, 0.08822290992320136, 0.0892523086414958, 0.07948050375760796, 0.0974510772779218, 0.10364745616461801, 0.09476556769811173]}, "mutation_prompt": null}
{"id": "ac2aa215-4ab8-4111-b282-fe866fd1e625", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with dynamic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.5, 1.0)  # Dynamic scaling factor adjusted\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Adjust learning rates adaptively\n            self.c1 = np.random.uniform(1.5, 2.5) * (1 - budget_used / self.budget)\n            self.c2 = np.random.uniform(1.0, 2.0) * (budget_used / self.budget)\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with adaptive dynamic mutation and learning rates for improved exploration-exploitation balance.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "18049154-f5a2-4eb2-bf61-fdb6bfa09dea", "metadata": {"aucs": [0.7872157191955759, 0.6574420632864659, 0.7917917591512056, 0.7958922074998774, 0.7989257932831402, 0.7957125243014036, 0.7913616875990871, 0.8006239380012781, 0.7950122900103148, 0.6685762701644444, 0.6528604630991643, 0.6847840749129286, 0.6509466541406084, 0.6663042841064887, 0.6776041870070177, 0.6708931169229703, 0.6834945226566687, 0.6858885159899506, 0.3713838590715587, 0.1065861809744374, 0.12633426848173512, 0.4193346031898535, 0.13174388798721248, 0.3344121603327349, 0.14632011059915817, 0.13226424293579198, 0.15330449796962387, 0.09463165870779411, 0.11215615640788623, 0.12460206783685535, 0.09788278166761188, 0.11379501566691075, 0.1036165697478304, 0.10529493402851298, 0.09986580338265227, 0.1273541087203266, 0.8532473986231971, 0.7894845214296657, 0.8883589297175674, 0.8525379384805328, 0.8098064405182981, 0.9147975753566133, 0.9721760664875496, 0.8870031984920934, 0.7552926669364651, 0.6205184432249731, 0.3385136408348116, 0.6406739670952531, 0.5959279573243443, 0.468270332257404, 0.6399169468896835, 0.5471395500511218, 0.43924148141035435, 0.19467311568366696, 0.7353279218732238, 0.7871464869440143, 0.7614457815122746, 0.7754836232762475, 0.7689870171028226, 0.7779376664619236, 0.7564630320586203, 0.7152732442927155, 0.7034226265593142, 0.14067098638089282, 0.1656723091567368, 0.21135549584402546, 0.20436532724392165, 0.13804315054005123, 0.11604567509639507, 0.16132673633558314, 0.144285228530191, 0.1426739312070704, 0.13921864915513738, 0.2965621400918138, 0.3217173645114876, 0.1350886449013502, 0.15990241082106005, 0.14148005213699943, 0.11842000657651175, 0.15866391833266713, 0.17215978609974592, 0.047411562963892706, 0.05168700376970814, 0.12627377673485862, 0.053159901362740625, 0.0033864544242520056, 0.03270404536671212, 0.030217225057243002, 0.07297954710310428, 0.02899883830409089, 0.11488837280691389, 0.1407303282081821, 0.12951262300214528, 0.13399519669279614, 0.12102030348970749, 0.10018383718379287, 0.13832813503874553, 0.2062956162398779, 0.12969816555700886, 0.1730931979226007, 0.04231499348826251, 0.0804195689508711, 0.21532986241963303, 0.18807125152386706, 0.11927586420379088, 0.25570255899608696, 0.2175705571032499, 0.11438920698614419, 0.10014969782956906, 0.22591218823419112, 0.24087660062864857, 0.22876031031316302, 0.15143648404829058, 0.24977639051303224, 0.19751840497560924, 0.3409170516342398, 0.19307960393545143, 0.518014720971101, 0.5985645179616477, 0.5238363535947699, 0.49814423972946564, 0.5465658751910167, 0.5783322148754144, 0.5247232937136073, 0.5462736162644704, 0.5264967263203234, 0.12465381289832622, 0.14620648442735218, 0.12963340841476145, 0.10762507173349056, 0.10644366080268486, 0.11457176098934874, 0.15034157466436993, 0.1258723067042825, 0.12339421391261951, 0.18687950036442835, 0.15519500135246056, 0.17127369110966406, 0.1734231298434894, 0.18076832272845422, 0.15482790024530313, 0.16739160596818203, 0.18270314996918535, 0.1783682352743614, 0.4463004531587097, 0.3639901913537147, 0.4669289143643418, 0.46955394460224564, 0.4072494696452368, 0.3081003720529306, 0.33671504126356233, 0.3666887796514411, 0.5194828226165522, 0.29527694733133814, 0.3335895165554904, 0.23665079012393664, 0.3255827952284198, 0.3991321585784261, 0.35609195444961794, 0.2911788758122168, 0.20876507948999812, 0.2672160934101536, 0.21954388553323412, 0.22262914530289568, 0.22822301912482867, 0.21223886614070286, 0.21465838602765475, 0.21929271898810365, 0.21083422277214647, 0.2146004720843262, 0.25380583428983905, 0.18042059547937295, 0.20240672267539117, 0.2198421427783931, 0.2082563294843488, 0.19604210477941575, 0.22710719259153545, 0.19747399426613166, 0.17613578183401246, 0.20139685593687495, 0.7385223026739401, 0.7331910064875534, 0.8032437570145959, 0.692390874590616, 0.1894563991342021, 0.6665536315438595, 0.6820408702343952, 0.18763394046024706, 0.7422384641503671, 0.5286578067569395, 0.20064933239398197, 0.7038089536003094, 0.7053220776157942, 0.4277690926916078, 0.6614121988563331, 0.7016551360874844, 0.14932361336082833, 0.19363519262304674, 0.18924742620707746, 0.2032409188424219, 0.19695001896225162, 0.18987463017972595, 0.19254598129092693, 0.19464306221711958, 0.1867119189557438, 0.17939569105229003, 0.21516816256738447, 0.09214593297702067, 0.08700924470776594, 0.08221678144331657, 0.11160965224590402, 0.09051815489802817, 0.09733232953929238, 0.0803706170518439, 0.08641385720910166, 0.08624991347229227]}, "mutation_prompt": null}
{"id": "60bc5328-aed2-4fb8-b831-071ab9ee5b8f", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n        self.elite_archive = []\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n                            # Elite archiving\n                            self.elite_archive.append(global_best)\n\n            self.c1 = np.random.uniform(1.5, 2.5) * (1 - budget_used / self.budget)\n            self.c2 = np.random.uniform(1.0, 2.0) * (budget_used / self.budget)\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n                        # Local search refinement\n                        population[i] = 0.5 * (population[i] + global_best)\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Refined EnhancedHybridDEPSO by integrating local search and elite archiving for intensified global convergence.", "configspace": "", "generation": 78, "fitness": 0.33806515228612816, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "18049154-f5a2-4eb2-bf61-fdb6bfa09dea", "metadata": {"aucs": [0.7872157191955759, 0.6574420632864659, 0.7917917591512056, 0.7958922074998774, 0.7989257932831402, 0.7957125243014036, 0.7913616875990871, 0.8006239380012781, 0.7950122900103148, 0.6685762701644444, 0.6528604630991643, 0.6847840749129286, 0.6509466541406084, 0.6663042841064887, 0.6776041870070177, 0.6708931169229703, 0.6834945226566687, 0.6858885159899506, 0.3713838590715587, 0.1065861809744374, 0.12633426848173512, 0.4193346031898535, 0.13174388798721248, 0.3344121603327349, 0.14632011059915817, 0.13226424293579198, 0.15330449796962387, 0.09463165870779411, 0.11215615640788623, 0.12460206783685535, 0.09788278166761188, 0.11379501566691075, 0.1036165697478304, 0.10529493402851298, 0.09986580338265227, 0.1273541087203266, 0.8532473986231971, 0.7894845214296657, 0.8883589297175674, 0.8525379384805328, 0.8098064405182981, 0.9147975753566133, 0.9721760664875496, 0.8870031984920934, 0.7552926669364651, 0.6205184432249731, 0.3385136408348116, 0.6406739670952531, 0.5959279573243443, 0.468270332257404, 0.6399169468896835, 0.5471395500511218, 0.43924148141035435, 0.19467311568366696, 0.7353279218732238, 0.7871464869440143, 0.7614457815122746, 0.7754836232762475, 0.7689870171028226, 0.7779376664619236, 0.7564630320586203, 0.7152732442927155, 0.7034226265593142, 0.14067098638089282, 0.1656723091567368, 0.21135549584402546, 0.20436532724392165, 0.13804315054005123, 0.11604567509639507, 0.16132673633558314, 0.144285228530191, 0.1426739312070704, 0.13921864915513738, 0.2965621400918138, 0.3217173645114876, 0.1350886449013502, 0.15990241082106005, 0.14148005213699943, 0.11842000657651175, 0.15866391833266713, 0.17215978609974592, 0.047411562963892706, 0.05168700376970814, 0.12627377673485862, 0.053159901362740625, 0.0033864544242520056, 0.03270404536671212, 0.030217225057243002, 0.07297954710310428, 0.02899883830409089, 0.11488837280691389, 0.1407303282081821, 0.12951262300214528, 0.13399519669279614, 0.12102030348970749, 0.10018383718379287, 0.13832813503874553, 0.2062956162398779, 0.12969816555700886, 0.1730931979226007, 0.04231499348826251, 0.0804195689508711, 0.21532986241963303, 0.18807125152386706, 0.11927586420379088, 0.25570255899608696, 0.2175705571032499, 0.11438920698614419, 0.10014969782956906, 0.22591218823419112, 0.24087660062864857, 0.22876031031316302, 0.15143648404829058, 0.24977639051303224, 0.19751840497560924, 0.3409170516342398, 0.19307960393545143, 0.518014720971101, 0.5985645179616477, 0.5238363535947699, 0.49814423972946564, 0.5465658751910167, 0.5783322148754144, 0.5247232937136073, 0.5462736162644704, 0.5264967263203234, 0.12465381289832622, 0.14620648442735218, 0.12963340841476145, 0.10762507173349056, 0.10644366080268486, 0.11457176098934874, 0.15034157466436993, 0.1258723067042825, 0.12339421391261951, 0.18687950036442835, 0.15519500135246056, 0.17127369110966406, 0.1734231298434894, 0.18076832272845422, 0.15482790024530313, 0.16739160596818203, 0.18270314996918535, 0.1783682352743614, 0.4463004531587097, 0.3639901913537147, 0.4669289143643418, 0.46955394460224564, 0.4072494696452368, 0.3081003720529306, 0.33671504126356233, 0.3666887796514411, 0.5194828226165522, 0.29527694733133814, 0.3335895165554904, 0.23665079012393664, 0.3255827952284198, 0.3991321585784261, 0.35609195444961794, 0.2911788758122168, 0.20876507948999812, 0.2672160934101536, 0.21954388553323412, 0.22262914530289568, 0.22822301912482867, 0.21223886614070286, 0.21465838602765475, 0.21929271898810365, 0.21083422277214647, 0.2146004720843262, 0.25380583428983905, 0.18042059547937295, 0.20240672267539117, 0.2198421427783931, 0.2082563294843488, 0.19604210477941575, 0.22710719259153545, 0.19747399426613166, 0.17613578183401246, 0.20139685593687495, 0.7385223026739401, 0.7331910064875534, 0.8032437570145959, 0.692390874590616, 0.1894563991342021, 0.6665536315438595, 0.6820408702343952, 0.18763394046024706, 0.7422384641503671, 0.5286578067569395, 0.20064933239398197, 0.7038089536003094, 0.7053220776157942, 0.4277690926916078, 0.6614121988563331, 0.7016551360874844, 0.14932361336082833, 0.19363519262304674, 0.18924742620707746, 0.2032409188424219, 0.19695001896225162, 0.18987463017972595, 0.19254598129092693, 0.19464306221711958, 0.1867119189557438, 0.17939569105229003, 0.21516816256738447, 0.09214593297702067, 0.08700924470776594, 0.08221678144331657, 0.11160965224590402, 0.09051815489802817, 0.09733232953929238, 0.0803706170518439, 0.08641385720910166, 0.08624991347229227]}, "mutation_prompt": null}
{"id": "d185e7a4-acf5-497c-bc70-5cccceb56145", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with dynamic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.5, 1.0)  # Dynamic scaling factor adjusted\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Adjust learning rates adaptively\n            self.c1 = np.random.uniform(1.5, 2.5) * (1 - budget_used / self.budget)\n            self.c2 = np.random.uniform(1.0, 2.0) * (budget_used / self.budget)\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with adaptive dynamic mutation and learning rates for improved exploration-exploitation balance.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "18049154-f5a2-4eb2-bf61-fdb6bfa09dea", "metadata": {"aucs": [0.7872157191955759, 0.6574420632864659, 0.7917917591512056, 0.7958922074998774, 0.7989257932831402, 0.7957125243014036, 0.7913616875990871, 0.8006239380012781, 0.7950122900103148, 0.6685762701644444, 0.6528604630991643, 0.6847840749129286, 0.6509466541406084, 0.6663042841064887, 0.6776041870070177, 0.6708931169229703, 0.6834945226566687, 0.6858885159899506, 0.3713838590715587, 0.1065861809744374, 0.12633426848173512, 0.4193346031898535, 0.13174388798721248, 0.3344121603327349, 0.14632011059915817, 0.13226424293579198, 0.15330449796962387, 0.09463165870779411, 0.11215615640788623, 0.12460206783685535, 0.09788278166761188, 0.11379501566691075, 0.1036165697478304, 0.10529493402851298, 0.09986580338265227, 0.1273541087203266, 0.8532473986231971, 0.7894845214296657, 0.8883589297175674, 0.8525379384805328, 0.8098064405182981, 0.9147975753566133, 0.9721760664875496, 0.8870031984920934, 0.7552926669364651, 0.6205184432249731, 0.3385136408348116, 0.6406739670952531, 0.5959279573243443, 0.468270332257404, 0.6399169468896835, 0.5471395500511218, 0.43924148141035435, 0.19467311568366696, 0.7353279218732238, 0.7871464869440143, 0.7614457815122746, 0.7754836232762475, 0.7689870171028226, 0.7779376664619236, 0.7564630320586203, 0.7152732442927155, 0.7034226265593142, 0.14067098638089282, 0.1656723091567368, 0.21135549584402546, 0.20436532724392165, 0.13804315054005123, 0.11604567509639507, 0.16132673633558314, 0.144285228530191, 0.1426739312070704, 0.13921864915513738, 0.2965621400918138, 0.3217173645114876, 0.1350886449013502, 0.15990241082106005, 0.14148005213699943, 0.11842000657651175, 0.15866391833266713, 0.17215978609974592, 0.047411562963892706, 0.05168700376970814, 0.12627377673485862, 0.053159901362740625, 0.0033864544242520056, 0.03270404536671212, 0.030217225057243002, 0.07297954710310428, 0.02899883830409089, 0.11488837280691389, 0.1407303282081821, 0.12951262300214528, 0.13399519669279614, 0.12102030348970749, 0.10018383718379287, 0.13832813503874553, 0.2062956162398779, 0.12969816555700886, 0.1730931979226007, 0.04231499348826251, 0.0804195689508711, 0.21532986241963303, 0.18807125152386706, 0.11927586420379088, 0.25570255899608696, 0.2175705571032499, 0.11438920698614419, 0.10014969782956906, 0.22591218823419112, 0.24087660062864857, 0.22876031031316302, 0.15143648404829058, 0.24977639051303224, 0.19751840497560924, 0.3409170516342398, 0.19307960393545143, 0.518014720971101, 0.5985645179616477, 0.5238363535947699, 0.49814423972946564, 0.5465658751910167, 0.5783322148754144, 0.5247232937136073, 0.5462736162644704, 0.5264967263203234, 0.12465381289832622, 0.14620648442735218, 0.12963340841476145, 0.10762507173349056, 0.10644366080268486, 0.11457176098934874, 0.15034157466436993, 0.1258723067042825, 0.12339421391261951, 0.18687950036442835, 0.15519500135246056, 0.17127369110966406, 0.1734231298434894, 0.18076832272845422, 0.15482790024530313, 0.16739160596818203, 0.18270314996918535, 0.1783682352743614, 0.4463004531587097, 0.3639901913537147, 0.4669289143643418, 0.46955394460224564, 0.4072494696452368, 0.3081003720529306, 0.33671504126356233, 0.3666887796514411, 0.5194828226165522, 0.29527694733133814, 0.3335895165554904, 0.23665079012393664, 0.3255827952284198, 0.3991321585784261, 0.35609195444961794, 0.2911788758122168, 0.20876507948999812, 0.2672160934101536, 0.21954388553323412, 0.22262914530289568, 0.22822301912482867, 0.21223886614070286, 0.21465838602765475, 0.21929271898810365, 0.21083422277214647, 0.2146004720843262, 0.25380583428983905, 0.18042059547937295, 0.20240672267539117, 0.2198421427783931, 0.2082563294843488, 0.19604210477941575, 0.22710719259153545, 0.19747399426613166, 0.17613578183401246, 0.20139685593687495, 0.7385223026739401, 0.7331910064875534, 0.8032437570145959, 0.692390874590616, 0.1894563991342021, 0.6665536315438595, 0.6820408702343952, 0.18763394046024706, 0.7422384641503671, 0.5286578067569395, 0.20064933239398197, 0.7038089536003094, 0.7053220776157942, 0.4277690926916078, 0.6614121988563331, 0.7016551360874844, 0.14932361336082833, 0.19363519262304674, 0.18924742620707746, 0.2032409188424219, 0.19695001896225162, 0.18987463017972595, 0.19254598129092693, 0.19464306221711958, 0.1867119189557438, 0.17939569105229003, 0.21516816256738447, 0.09214593297702067, 0.08700924470776594, 0.08221678144331657, 0.11160965224590402, 0.09051815489802817, 0.09733232953929238, 0.0803706170518439, 0.08641385720910166, 0.08624991347229227]}, "mutation_prompt": null}
{"id": "24918c55-a255-4d7d-897e-8a3ff2c14ea2", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with dynamic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.5, 1.0)  # Dynamic scaling factor adjusted\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Adjust learning rates adaptively\n            self.c1 = np.random.uniform(1.5, 2.5) * (1 - budget_used / self.budget)\n            self.c2 = np.random.uniform(1.0, 2.0) * (budget_used / self.budget)\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with adaptive dynamic mutation and learning rates for improved exploration-exploitation balance.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "18049154-f5a2-4eb2-bf61-fdb6bfa09dea", "metadata": {"aucs": [0.7872157191955759, 0.6574420632864659, 0.7917917591512056, 0.7958922074998774, 0.7989257932831402, 0.7957125243014036, 0.7913616875990871, 0.8006239380012781, 0.7950122900103148, 0.6685762701644444, 0.6528604630991643, 0.6847840749129286, 0.6509466541406084, 0.6663042841064887, 0.6776041870070177, 0.6708931169229703, 0.6834945226566687, 0.6858885159899506, 0.3713838590715587, 0.1065861809744374, 0.12633426848173512, 0.4193346031898535, 0.13174388798721248, 0.3344121603327349, 0.14632011059915817, 0.13226424293579198, 0.15330449796962387, 0.09463165870779411, 0.11215615640788623, 0.12460206783685535, 0.09788278166761188, 0.11379501566691075, 0.1036165697478304, 0.10529493402851298, 0.09986580338265227, 0.1273541087203266, 0.8532473986231971, 0.7894845214296657, 0.8883589297175674, 0.8525379384805328, 0.8098064405182981, 0.9147975753566133, 0.9721760664875496, 0.8870031984920934, 0.7552926669364651, 0.6205184432249731, 0.3385136408348116, 0.6406739670952531, 0.5959279573243443, 0.468270332257404, 0.6399169468896835, 0.5471395500511218, 0.43924148141035435, 0.19467311568366696, 0.7353279218732238, 0.7871464869440143, 0.7614457815122746, 0.7754836232762475, 0.7689870171028226, 0.7779376664619236, 0.7564630320586203, 0.7152732442927155, 0.7034226265593142, 0.14067098638089282, 0.1656723091567368, 0.21135549584402546, 0.20436532724392165, 0.13804315054005123, 0.11604567509639507, 0.16132673633558314, 0.144285228530191, 0.1426739312070704, 0.13921864915513738, 0.2965621400918138, 0.3217173645114876, 0.1350886449013502, 0.15990241082106005, 0.14148005213699943, 0.11842000657651175, 0.15866391833266713, 0.17215978609974592, 0.047411562963892706, 0.05168700376970814, 0.12627377673485862, 0.053159901362740625, 0.0033864544242520056, 0.03270404536671212, 0.030217225057243002, 0.07297954710310428, 0.02899883830409089, 0.11488837280691389, 0.1407303282081821, 0.12951262300214528, 0.13399519669279614, 0.12102030348970749, 0.10018383718379287, 0.13832813503874553, 0.2062956162398779, 0.12969816555700886, 0.1730931979226007, 0.04231499348826251, 0.0804195689508711, 0.21532986241963303, 0.18807125152386706, 0.11927586420379088, 0.25570255899608696, 0.2175705571032499, 0.11438920698614419, 0.10014969782956906, 0.22591218823419112, 0.24087660062864857, 0.22876031031316302, 0.15143648404829058, 0.24977639051303224, 0.19751840497560924, 0.3409170516342398, 0.19307960393545143, 0.518014720971101, 0.5985645179616477, 0.5238363535947699, 0.49814423972946564, 0.5465658751910167, 0.5783322148754144, 0.5247232937136073, 0.5462736162644704, 0.5264967263203234, 0.12465381289832622, 0.14620648442735218, 0.12963340841476145, 0.10762507173349056, 0.10644366080268486, 0.11457176098934874, 0.15034157466436993, 0.1258723067042825, 0.12339421391261951, 0.18687950036442835, 0.15519500135246056, 0.17127369110966406, 0.1734231298434894, 0.18076832272845422, 0.15482790024530313, 0.16739160596818203, 0.18270314996918535, 0.1783682352743614, 0.4463004531587097, 0.3639901913537147, 0.4669289143643418, 0.46955394460224564, 0.4072494696452368, 0.3081003720529306, 0.33671504126356233, 0.3666887796514411, 0.5194828226165522, 0.29527694733133814, 0.3335895165554904, 0.23665079012393664, 0.3255827952284198, 0.3991321585784261, 0.35609195444961794, 0.2911788758122168, 0.20876507948999812, 0.2672160934101536, 0.21954388553323412, 0.22262914530289568, 0.22822301912482867, 0.21223886614070286, 0.21465838602765475, 0.21929271898810365, 0.21083422277214647, 0.2146004720843262, 0.25380583428983905, 0.18042059547937295, 0.20240672267539117, 0.2198421427783931, 0.2082563294843488, 0.19604210477941575, 0.22710719259153545, 0.19747399426613166, 0.17613578183401246, 0.20139685593687495, 0.7385223026739401, 0.7331910064875534, 0.8032437570145959, 0.692390874590616, 0.1894563991342021, 0.6665536315438595, 0.6820408702343952, 0.18763394046024706, 0.7422384641503671, 0.5286578067569395, 0.20064933239398197, 0.7038089536003094, 0.7053220776157942, 0.4277690926916078, 0.6614121988563331, 0.7016551360874844, 0.14932361336082833, 0.19363519262304674, 0.18924742620707746, 0.2032409188424219, 0.19695001896225162, 0.18987463017972595, 0.19254598129092693, 0.19464306221711958, 0.1867119189557438, 0.17939569105229003, 0.21516816256738447, 0.09214593297702067, 0.08700924470776594, 0.08221678144331657, 0.11160965224590402, 0.09051815489802817, 0.09733232953929238, 0.0803706170518439, 0.08641385720910166, 0.08624991347229227]}, "mutation_prompt": null}
{"id": "e50e0818-7af4-4081-a39d-307c05508323", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with dynamic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                f_dynamic = np.random.uniform(0.5, 1.0)  # Dynamic scaling factor adjusted\n                mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Adjust learning rates adaptively\n            self.c1 = np.random.uniform(1.5, 2.5) * (1 - budget_used / self.budget)\n            self.c2 = np.random.uniform(1.0, 2.0) * (budget_used / self.budget)\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with adaptive dynamic mutation and learning rates for improved exploration-exploitation balance.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "18049154-f5a2-4eb2-bf61-fdb6bfa09dea", "metadata": {"aucs": [0.7872157191955759, 0.6574420632864659, 0.7917917591512056, 0.7958922074998774, 0.7989257932831402, 0.7957125243014036, 0.7913616875990871, 0.8006239380012781, 0.7950122900103148, 0.6685762701644444, 0.6528604630991643, 0.6847840749129286, 0.6509466541406084, 0.6663042841064887, 0.6776041870070177, 0.6708931169229703, 0.6834945226566687, 0.6858885159899506, 0.3713838590715587, 0.1065861809744374, 0.12633426848173512, 0.4193346031898535, 0.13174388798721248, 0.3344121603327349, 0.14632011059915817, 0.13226424293579198, 0.15330449796962387, 0.09463165870779411, 0.11215615640788623, 0.12460206783685535, 0.09788278166761188, 0.11379501566691075, 0.1036165697478304, 0.10529493402851298, 0.09986580338265227, 0.1273541087203266, 0.8532473986231971, 0.7894845214296657, 0.8883589297175674, 0.8525379384805328, 0.8098064405182981, 0.9147975753566133, 0.9721760664875496, 0.8870031984920934, 0.7552926669364651, 0.6205184432249731, 0.3385136408348116, 0.6406739670952531, 0.5959279573243443, 0.468270332257404, 0.6399169468896835, 0.5471395500511218, 0.43924148141035435, 0.19467311568366696, 0.7353279218732238, 0.7871464869440143, 0.7614457815122746, 0.7754836232762475, 0.7689870171028226, 0.7779376664619236, 0.7564630320586203, 0.7152732442927155, 0.7034226265593142, 0.14067098638089282, 0.1656723091567368, 0.21135549584402546, 0.20436532724392165, 0.13804315054005123, 0.11604567509639507, 0.16132673633558314, 0.144285228530191, 0.1426739312070704, 0.13921864915513738, 0.2965621400918138, 0.3217173645114876, 0.1350886449013502, 0.15990241082106005, 0.14148005213699943, 0.11842000657651175, 0.15866391833266713, 0.17215978609974592, 0.047411562963892706, 0.05168700376970814, 0.12627377673485862, 0.053159901362740625, 0.0033864544242520056, 0.03270404536671212, 0.030217225057243002, 0.07297954710310428, 0.02899883830409089, 0.11488837280691389, 0.1407303282081821, 0.12951262300214528, 0.13399519669279614, 0.12102030348970749, 0.10018383718379287, 0.13832813503874553, 0.2062956162398779, 0.12969816555700886, 0.1730931979226007, 0.04231499348826251, 0.0804195689508711, 0.21532986241963303, 0.18807125152386706, 0.11927586420379088, 0.25570255899608696, 0.2175705571032499, 0.11438920698614419, 0.10014969782956906, 0.22591218823419112, 0.24087660062864857, 0.22876031031316302, 0.15143648404829058, 0.24977639051303224, 0.19751840497560924, 0.3409170516342398, 0.19307960393545143, 0.518014720971101, 0.5985645179616477, 0.5238363535947699, 0.49814423972946564, 0.5465658751910167, 0.5783322148754144, 0.5247232937136073, 0.5462736162644704, 0.5264967263203234, 0.12465381289832622, 0.14620648442735218, 0.12963340841476145, 0.10762507173349056, 0.10644366080268486, 0.11457176098934874, 0.15034157466436993, 0.1258723067042825, 0.12339421391261951, 0.18687950036442835, 0.15519500135246056, 0.17127369110966406, 0.1734231298434894, 0.18076832272845422, 0.15482790024530313, 0.16739160596818203, 0.18270314996918535, 0.1783682352743614, 0.4463004531587097, 0.3639901913537147, 0.4669289143643418, 0.46955394460224564, 0.4072494696452368, 0.3081003720529306, 0.33671504126356233, 0.3666887796514411, 0.5194828226165522, 0.29527694733133814, 0.3335895165554904, 0.23665079012393664, 0.3255827952284198, 0.3991321585784261, 0.35609195444961794, 0.2911788758122168, 0.20876507948999812, 0.2672160934101536, 0.21954388553323412, 0.22262914530289568, 0.22822301912482867, 0.21223886614070286, 0.21465838602765475, 0.21929271898810365, 0.21083422277214647, 0.2146004720843262, 0.25380583428983905, 0.18042059547937295, 0.20240672267539117, 0.2198421427783931, 0.2082563294843488, 0.19604210477941575, 0.22710719259153545, 0.19747399426613166, 0.17613578183401246, 0.20139685593687495, 0.7385223026739401, 0.7331910064875534, 0.8032437570145959, 0.692390874590616, 0.1894563991342021, 0.6665536315438595, 0.6820408702343952, 0.18763394046024706, 0.7422384641503671, 0.5286578067569395, 0.20064933239398197, 0.7038089536003094, 0.7053220776157942, 0.4277690926916078, 0.6614121988563331, 0.7016551360874844, 0.14932361336082833, 0.19363519262304674, 0.18924742620707746, 0.2032409188424219, 0.19695001896225162, 0.18987463017972595, 0.19254598129092693, 0.19464306221711958, 0.1867119189557438, 0.17939569105229003, 0.21516816256738447, 0.09214593297702067, 0.08700924470776594, 0.08221678144331657, 0.11160965224590402, 0.09051815489802817, 0.09733232953929238, 0.0803706170518439, 0.08641385720910166, 0.08624991347229227]}, "mutation_prompt": null}
{"id": "a315cc62-4211-4c05-9b85-884aee96b2a0", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with probabilistic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                if np.random.rand() < 0.7:  # Probabilistic selection of mutation strategy\n                    mutant = np.clip(a + np.random.uniform(0.5, 1.0) * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(global_best + np.random.uniform(0.5, 1.0) * (b - a), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Adjust learning rates adaptively\n            self.c1 = np.random.uniform(1.5, 2.5) * (1 - budget_used / self.budget)\n            self.c2 = np.random.uniform(1.0, 2.0) * (budget_used / self.budget)\n\n            # Memory-based inertia adjustment\n            historic_best = fitness.min()\n            self.w = 0.4 + 0.5 * (historic_best - fitness.mean()) / (historic_best + 1e-9)\n            self.w = np.clip(self.w, 0.1, 0.6)\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with a novel probabilistic mutation strategy and memory-based inertia to boost convergence.", "configspace": "", "generation": 82, "fitness": 0.3650401127431899, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.27.", "error": "", "parent_id": "18049154-f5a2-4eb2-bf61-fdb6bfa09dea", "metadata": {"aucs": [0.8121739212131376, 0.8065504339741629, 0.808399126283219, 0.8268055411872113, 0.8186815464693457, 0.8156334146654408, 0.8220552149930658, 0.8124049249076453, 0.8032268113097001, 0.7046280867720519, 0.6797475460651222, 0.6689062809577883, 0.6910455401206312, 0.6850238268144604, 0.6877765437437522, 0.6887565143309139, 0.6663419762615517, 0.6855238815820668, 0.15246120122247864, 0.11683198159661823, 0.46391636675205805, 0.1425181536026634, 0.12020496710916795, 0.11476130132680251, 0.136090768698093, 0.14233109149753986, 0.13949966178337836, 0.13220181510018303, 0.0989961504989868, 0.12262834847665605, 0.09576847178152348, 0.1200934073934743, 0.10816318970047356, 0.12866360291139756, 0.11100495892402173, 0.12031800871830378, 0.9848280941692072, 0.9822096723588887, 0.9774313603946428, 0.9386843349351494, 0.9589911559124588, 0.967211790471227, 0.9787196364572956, 0.9761154648983643, 0.9647994043597012, 0.6785308116303539, 0.6413761774110052, 0.6738818445652499, 0.6416038301470284, 0.6575097141084004, 0.6680975859187039, 0.700167883351968, 0.6533078578283935, 0.7002097842438726, 0.788050754280684, 0.7794321633431516, 0.749582474564737, 0.8041958647379287, 0.7722436972554009, 0.7946624158953679, 0.767825407707804, 0.7610777605585773, 0.7739740594813861, 0.2569147037612117, 0.1226358436968239, 0.21890620088931656, 0.19546072592136765, 0.3509404156492355, 0.33361262046321416, 0.268451112673213, 0.24292966720000853, 0.29276638115666487, 0.12141452906815486, 0.2645288711804815, 0.19965935448102567, 0.28821731278731877, 0.26662269271967665, 0.24525035029122344, 0.24772400246786952, 0.381046377240579, 0.24655731166167338, 0.09575359082215074, 0.11062088086858035, 0.05356385546906117, 0.09598271889022802, 0.031038744428861342, 0.06779060465136011, 0.07257432756391313, 0.06127718672449989, 0.061224301975332684, 0.14141692224504387, 0.1523871382578159, 0.14887025814600352, 0.11983357237070691, 0.1319130198094577, 0.09906770218417427, 0.170864265392079, 0.16638895100904116, 0.1735677115134413, 0.14211442154789033, 0.06081954472944506, 0.09149390479355024, 0.08419039056049427, 0.2120793546633265, 0.12477713716235717, 0.10720914082520772, 0.08952722823789994, 0.1552473307456399, 0.1305200171584715, 0.2525567114997973, 0.19394581490364804, 0.18918399797529883, 0.20966865965238668, 0.18723689694118462, 0.20505474417297886, 0.1355889778927598, 0.1889124740224548, 0.5518676926251205, 0.5794095976198712, 0.5509254567617179, 0.6008500163484372, 0.5845106666896442, 0.5541974402289712, 0.54059802549404, 0.6061015609614535, 0.6016192971689202, 0.12215067079788244, 0.11400157920915521, 0.1306091623317529, 0.12017813384565257, 0.13885021142724852, 0.12548306302287238, 0.12738106556838324, 0.12070000092306277, 0.15662761509075174, 0.13676879245608908, 0.2795002386171952, 0.2570928346418746, 0.22481391768428893, 0.19622611379731825, 0.22637763674948674, 0.17455574877067848, 0.21375624974474516, 0.2090544779322785, 0.4781188304898959, 0.4706852853225697, 0.3613414926455826, 0.5847708362194299, 0.3943568970780186, 0.3871403545525409, 0.5032323318182257, 0.517904805576054, 0.47639286825100824, 0.28371214123592015, 0.35243508182284444, 0.34154310500325646, 0.4791932320251987, 0.3731029313006833, 0.20295282003577564, 0.2395926267550582, 0.3778314242206092, 0.4242984725427531, 0.2058278302547354, 0.21398499699774698, 0.2101893998518053, 0.22885964144983495, 0.1987041452340853, 0.20213312129127303, 0.23661415061485536, 0.21837681408466036, 0.2152725528459395, 0.5955409461084353, 0.19908883297725766, 0.20096083779354645, 0.2105381681472952, 0.19509509921945756, 0.2271834293298841, 0.18958242052823848, 0.18734619629501703, 0.21117657825525116, 0.17091183269029497, 0.17146960123148713, 0.7982405561256902, 0.19086529341935887, 0.6880989932576556, 0.7898513216729918, 0.7446715279231841, 0.7976054554625447, 0.2080731308390853, 0.7836948902192584, 0.7529207216973023, 0.7241875514599532, 0.20055355024549326, 0.688634414191002, 0.7403679303605467, 0.20694068132047183, 0.7155006718783228, 0.1649845036455193, 0.20564488259111713, 0.21813352730676994, 0.21329997743853368, 0.19337149385289, 0.19315447584219492, 0.18885233377136568, 0.18294903348347014, 0.18717399207401675, 0.2355658498197687, 0.09224745515881883, 0.09594281848693431, 0.09367572787432288, 0.08905313280666394, 0.08992300156664257, 0.0846441214770357, 0.08557967919571097, 0.09119505560898056, 0.08864064900235391]}, "mutation_prompt": null}
{"id": "1d096d2b-625b-4980-8a73-8c47434eb952", "solution": "import numpy as np\nfrom sklearn.cluster import KMeans\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = np.random.uniform(0.4, 0.9)  # Dynamically adjusted DE scaling factor\n        self.cr = 0.8 + 0.1 * np.random.rand()  # Slightly reduced crossover probability\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                if np.random.rand() < 0.7:\n                    mutant = np.clip(a + np.random.uniform(0.5, 1.0) * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(global_best + np.random.uniform(0.5, 1.0) * (b - a), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            self.c1 = np.random.uniform(1.5, 2.5) * (1 - budget_used / self.budget)\n            self.c2 = np.random.uniform(1.0, 2.0) * (budget_used / self.budget)\n\n            historic_best = fitness.min()\n            self.w = 0.4 + 0.5 * (historic_best - fitness.mean()) / (historic_best + 1e-9)\n            self.w = np.clip(self.w, 0.1, 0.6)\n\n            kmeans = KMeans(n_clusters=3, random_state=0).fit(population)  # Clustering to enhance exploration\n            cluster_centers = kmeans.cluster_centers_\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - cluster_centers[kmeans.labels_]),\n                -self.v_max, self.v_max\n            )\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with adaptive control parameter tuning and dynamic clustering to improve exploration and exploitation balance.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: ModuleNotFoundError(\"No module named 'sklearn'\").", "error": "ModuleNotFoundError(\"No module named 'sklearn'\")", "parent_id": "a315cc62-4211-4c05-9b85-884aee96b2a0", "metadata": {}, "mutation_prompt": null}
{"id": "82ca7f35-e955-42d4-ab13-41812462a22c", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.7  # Increased DE scaling factor for exploration\n        self.cr = 0.9\n        self.w = np.random.uniform(0.4, 0.7)  # Adjusted adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            mutation_probability = 0.5 + 0.5 * np.cos(np.pi * budget_used / self.budget)  # Time-varying probability\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                if np.random.rand() < mutation_probability:\n                    mutant = np.clip(a + np.random.uniform(0.6, 1.0) * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(global_best + np.random.uniform(0.6, 1.0) * (b - a), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            self.c1 = np.random.uniform(1.5, 2.5) * (1 - budget_used / self.budget)\n            self.c2 = np.random.uniform(1.0, 2.0) * (budget_used / self.budget)\n\n            historic_best = fitness.min()\n            self.w = 0.4 + 0.5 * (historic_best - fitness.mean()) / (historic_best + 1e-9)\n            self.w = np.clip(self.w, 0.1, 0.7)  # Adjusted upper bound\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Improved Dynamic Adaptive Hybrid DEPSO with time-varying strategy selection and refined velocity update for enhanced exploration-exploitation balance.", "configspace": "", "generation": 84, "fitness": 0.350473847271002, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.27.", "error": "", "parent_id": "a315cc62-4211-4c05-9b85-884aee96b2a0", "metadata": {"aucs": [0.7953374482458717, 0.7851327822112141, 0.8015546016670952, 0.80080468980952, 0.78028060547681, 0.8006520466711382, 0.7900976669873875, 0.7880996779907687, 0.7936276765015704, 0.6596261694774166, 0.6400000669198518, 0.6677996846802916, 0.6449582363267646, 0.651172951848013, 0.6603905456082677, 0.652258920229201, 0.6342695585723787, 0.656845581206431, 0.12458981268118752, 0.12612629331901504, 0.4536671993536333, 0.1275151480419643, 0.12875346220363004, 0.13582989554908254, 0.11265729527105883, 0.09586876969346325, 0.15152215646746847, 0.1058039139400726, 0.11541790638800231, 0.14109348024089963, 0.09810972967782705, 0.1110879311638655, 0.0917236745091915, 0.11568964475860499, 0.12033886788825043, 0.09963945990609024, 0.9650555598988485, 0.921011169558667, 0.9671486254307122, 0.8764894020685309, 0.8996860333492145, 0.950688225932868, 0.9075056311830695, 0.9115205062555848, 0.8638675954058096, 0.6230006394990567, 0.6543294925142351, 0.6354735706594228, 0.6447983990152586, 0.6302965561060605, 0.6365542620099347, 0.6036620876886503, 0.6560737976496265, 0.6463948453914201, 0.7884632295124228, 0.7298401363917386, 0.7038067229657359, 0.7637347299255763, 0.7440746332498539, 0.8020556563686899, 0.7232413863483897, 0.7392773839426339, 0.6765584447188483, 0.2568773659228746, 0.2757893672952405, 0.21114846432501377, 0.2453755763288179, 0.2683744624968317, 0.35810669422375097, 0.21753162208240429, 0.25772387367930805, 0.11636458482602974, 0.2192512574103419, 0.18256176118222078, 0.22706463473248373, 0.2397481893186848, 0.2486877905857271, 0.14561582161536857, 0.2408351410899282, 0.2565472813847466, 0.2972919616680969, 0.10928371661609948, 0.048055906603100995, 0.06505109198670944, 0.10112636162572708, 0.1284729546296015, 0.11354133954174173, 0.028772735252561743, 0.05826190177300883, 0.05663821706823291, 0.11630158795206758, 0.13911185882698862, 0.12644824440832692, 0.09496182469833714, 0.07891012198557001, 0.049361401556379136, 0.13112315100626726, 0.12232233831870676, 0.12144983524632302, 0.09872246252491457, 0.05802520781683507, 0.07674998347526074, 0.12972987134889258, 0.10283282786160475, 0.1632804074299915, 0.16185723461421897, 0.09134630572846314, 0.19018963482603468, 0.1626280231072318, 0.21726452349242076, 0.2240321823142314, 0.19962188397074776, 0.2447162653356979, 0.2257708155988425, 0.1165626521476395, 0.31007418838162426, 0.12875116380258278, 0.5585342872557608, 0.6002090588644793, 0.556587472315017, 0.5245309761506756, 0.5709322067875701, 0.5878644848244228, 0.6282626004972994, 0.5571190506602366, 0.5654679906591031, 0.1315302801858681, 0.13396073810334896, 0.1271221388088527, 0.10628013981240769, 0.12797137330038189, 0.1159099593305778, 0.1270941386020138, 0.11172261310759113, 0.12171123606468481, 0.18500189419212698, 0.23861805999950658, 0.20973038073935069, 0.1615238121949586, 0.17858168600327717, 0.17964717841235212, 0.15830392685243355, 0.22588086220890113, 0.1930729094104705, 0.30350418886678, 0.5933108545239649, 0.38838034971617086, 0.4788803880270236, 0.4630114810900088, 0.5075677987691669, 0.4894736272808238, 0.4114650717375057, 0.517011665245124, 0.3451019202969674, 0.3073023101987993, 0.273746607053724, 0.29725389735389174, 0.2487432091910584, 0.33318008073156147, 0.2522354379437929, 0.29969876333281076, 0.26177295574473736, 0.22270164753209065, 0.21799208562404404, 0.19792415831100507, 0.20431813034477242, 0.21679393299411343, 0.23726946686644879, 0.18483004185643936, 0.22595966376800736, 0.2169524609411777, 0.18535876684792774, 0.1894215936692426, 0.19401453355399512, 0.18650350200223342, 0.17760650643809062, 0.23361747684655143, 0.2074218088391403, 0.18155169361981804, 0.18814323022253443, 0.16783297006228548, 0.16621194281122809, 0.7857949299820433, 0.1789166473358308, 0.7595692451748541, 0.7514774372492943, 0.16379696666253207, 0.7601485055658507, 0.7222309128039868, 0.7786971623558113, 0.7720432313560261, 0.5661298238302142, 0.6720973934643412, 0.7134263030062062, 0.6738544233631424, 0.7212830481813826, 0.20580846872172565, 0.15241312843223864, 0.19014443905177603, 0.18932618106431376, 0.2182217268767872, 0.19048125812177297, 0.1983451584656747, 0.18760523829876186, 0.1799009432337172, 0.19173833361905313, 0.19642642500900742, 0.09980273202016166, 0.09554522607900962, 0.09358944446316397, 0.09029564537742096, 0.07814185312827815, 0.1210239141717735, 0.07994289167230584, 0.0930810260495013, 0.09461492318474285]}, "mutation_prompt": null}
{"id": "61efac68-1985-44c2-b710-34f9b41fdb71", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with probabilistic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                if np.random.rand() < 0.7:  # Probabilistic selection of mutation strategy\n                    mutant = np.clip(a + np.random.uniform(0.5, 1.0) * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(global_best + np.random.uniform(0.5, 1.0) * (b - a), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Adjust learning rates adaptively\n            self.c1 = np.random.uniform(1.5, 2.5) * (1 - budget_used / self.budget)\n            self.c2 = np.random.uniform(1.0, 2.0) * (budget_used / self.budget)\n\n            # Memory-based inertia adjustment\n            historic_best = fitness.min()\n            self.w = 0.4 + 0.5 * (historic_best - fitness.mean()) / (historic_best + 1e-9)\n            self.w = np.clip(self.w, 0.1, 0.6)\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with a novel probabilistic mutation strategy and memory-based inertia to boost convergence.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a315cc62-4211-4c05-9b85-884aee96b2a0", "metadata": {"aucs": [0.8121739212131376, 0.8065504339741629, 0.808399126283219, 0.8268055411872113, 0.8186815464693457, 0.8156334146654408, 0.8220552149930658, 0.8124049249076453, 0.8032268113097001, 0.7046280867720519, 0.6797475460651222, 0.6689062809577883, 0.6910455401206312, 0.6850238268144604, 0.6877765437437522, 0.6887565143309139, 0.6663419762615517, 0.6855238815820668, 0.15246120122247864, 0.11683198159661823, 0.46391636675205805, 0.1425181536026634, 0.12020496710916795, 0.11476130132680251, 0.136090768698093, 0.14233109149753986, 0.13949966178337836, 0.13220181510018303, 0.0989961504989868, 0.12262834847665605, 0.09576847178152348, 0.1200934073934743, 0.10816318970047356, 0.12866360291139756, 0.11100495892402173, 0.12031800871830378, 0.9848280941692072, 0.9822096723588887, 0.9774313603946428, 0.9386843349351494, 0.9589911559124588, 0.967211790471227, 0.9787196364572956, 0.9761154648983643, 0.9647994043597012, 0.6785308116303539, 0.6413761774110052, 0.6738818445652499, 0.6416038301470284, 0.6575097141084004, 0.6680975859187039, 0.700167883351968, 0.6533078578283935, 0.7002097842438726, 0.788050754280684, 0.7794321633431516, 0.749582474564737, 0.8041958647379287, 0.7722436972554009, 0.7946624158953679, 0.767825407707804, 0.7610777605585773, 0.7739740594813861, 0.2569147037612117, 0.1226358436968239, 0.21890620088931656, 0.19546072592136765, 0.3509404156492355, 0.33361262046321416, 0.268451112673213, 0.24292966720000853, 0.29276638115666487, 0.12141452906815486, 0.2645288711804815, 0.19965935448102567, 0.28821731278731877, 0.26662269271967665, 0.24525035029122344, 0.24772400246786952, 0.381046377240579, 0.24655731166167338, 0.09575359082215074, 0.11062088086858035, 0.05356385546906117, 0.09598271889022802, 0.031038744428861342, 0.06779060465136011, 0.07257432756391313, 0.06127718672449989, 0.061224301975332684, 0.14141692224504387, 0.1523871382578159, 0.14887025814600352, 0.11983357237070691, 0.1319130198094577, 0.09906770218417427, 0.170864265392079, 0.16638895100904116, 0.1735677115134413, 0.14211442154789033, 0.06081954472944506, 0.09149390479355024, 0.08419039056049427, 0.2120793546633265, 0.12477713716235717, 0.10720914082520772, 0.08952722823789994, 0.1552473307456399, 0.1305200171584715, 0.2525567114997973, 0.19394581490364804, 0.18918399797529883, 0.20966865965238668, 0.18723689694118462, 0.20505474417297886, 0.1355889778927598, 0.1889124740224548, 0.5518676926251205, 0.5794095976198712, 0.5509254567617179, 0.6008500163484372, 0.5845106666896442, 0.5541974402289712, 0.54059802549404, 0.6061015609614535, 0.6016192971689202, 0.12215067079788244, 0.11400157920915521, 0.1306091623317529, 0.12017813384565257, 0.13885021142724852, 0.12548306302287238, 0.12738106556838324, 0.12070000092306277, 0.15662761509075174, 0.13676879245608908, 0.2795002386171952, 0.2570928346418746, 0.22481391768428893, 0.19622611379731825, 0.22637763674948674, 0.17455574877067848, 0.21375624974474516, 0.2090544779322785, 0.4781188304898959, 0.4706852853225697, 0.3613414926455826, 0.5847708362194299, 0.3943568970780186, 0.3871403545525409, 0.5032323318182257, 0.517904805576054, 0.47639286825100824, 0.28371214123592015, 0.35243508182284444, 0.34154310500325646, 0.4791932320251987, 0.3731029313006833, 0.20295282003577564, 0.2395926267550582, 0.3778314242206092, 0.4242984725427531, 0.2058278302547354, 0.21398499699774698, 0.2101893998518053, 0.22885964144983495, 0.1987041452340853, 0.20213312129127303, 0.23661415061485536, 0.21837681408466036, 0.2152725528459395, 0.5955409461084353, 0.19908883297725766, 0.20096083779354645, 0.2105381681472952, 0.19509509921945756, 0.2271834293298841, 0.18958242052823848, 0.18734619629501703, 0.21117657825525116, 0.17091183269029497, 0.17146960123148713, 0.7982405561256902, 0.19086529341935887, 0.6880989932576556, 0.7898513216729918, 0.7446715279231841, 0.7976054554625447, 0.2080731308390853, 0.7836948902192584, 0.7529207216973023, 0.7241875514599532, 0.20055355024549326, 0.688634414191002, 0.7403679303605467, 0.20694068132047183, 0.7155006718783228, 0.1649845036455193, 0.20564488259111713, 0.21813352730676994, 0.21329997743853368, 0.19337149385289, 0.19315447584219492, 0.18885233377136568, 0.18294903348347014, 0.18717399207401675, 0.2355658498197687, 0.09224745515881883, 0.09594281848693431, 0.09367572787432288, 0.08905313280666394, 0.08992300156664257, 0.0846441214770357, 0.08557967919571097, 0.09119505560898056, 0.08864064900235391]}, "mutation_prompt": null}
{"id": "61c9b5cb-9bf4-4c0a-9bf1-885da8e4acda", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (6 * dim)))  # Adjusted pop size for more diversity\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with integrated mutation strategy\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.f * (b - c) + self.f * (global_best - a), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Adjust learning rates adaptively\n            self.c1 = np.random.uniform(1.5, 2.5) * (1 - budget_used / self.budget)\n            self.c2 = np.random.uniform(1.0, 2.0) * (budget_used / self.budget)\n\n            # Memory-based inertia adjustment\n            historic_best = fitness.min()\n            self.w = 0.4 + 0.5 * (historic_best - fitness.mean()) / (historic_best + 1e-9)\n            self.w = np.clip(self.w, 0.1, 0.6)\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Refined EnhancedHybridDEPSO with adaptive population size and an integrated mutation strategy for improved exploration and convergence.", "configspace": "", "generation": 86, "fitness": 0.35246849346906395, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.28.", "error": "", "parent_id": "a315cc62-4211-4c05-9b85-884aee96b2a0", "metadata": {"aucs": [0.8879283183702722, 0.8842984023288305, 0.8841199928394179, 0.8897156080113102, 0.8867236294564542, 0.8913148071597423, 0.8852151409721967, 0.8892873301420768, 0.8856218386386367, 0.8000077455052614, 0.757486887496447, 0.07623471162015172, 0.777838846236641, 0.18426313057670674, 0.7929525556786069, 0.45951363803650125, 0.0818821819932416, 0.1992936791697858, 0.5954353130592275, 0.6673437237377169, 0.13614740491291943, 0.15494181158583742, 0.17300862951524432, 0.15346453100378643, 0.14625379173744735, 0.17416315239343805, 0.15319368665129007, 0.1253955284366084, 0.1237287323165609, 0.11182674984972074, 0.10670939890079667, 0.10815497057673751, 0.11088856752132437, 0.1181929980748384, 0.11983117816799116, 0.10574310933174025, 0.8603549596869134, 0.7330686539267787, 0.9299099570349856, 0.8768325980958398, 0.9746544866803574, 0.857113043614212, 0.9331186408919757, 0.9771357396160686, 0.973881281884422, 0.7879795343784282, 0.43724186219597905, 0.5716896736184544, 0.28636111500221195, 0.7908641291979754, 0.704586232453777, 0.32478838490919604, 0.6894870075763244, 0.7630348198652604, 0.8982987803345115, 0.8719214183140066, 0.8721864746077675, 0.27114620200507955, 0.8926630059317076, 0.8977065672200953, 0.8800967043730141, 0.22211471354104428, 0.8870792953200926, 0.287604716752896, 0.13177694138003937, 0.20801607384314846, 0.14467243882165493, 0.1436217405220367, 0.23959877706795019, 0.1659025078435774, 0.1381599797520443, 0.13219331961121683, 0.1457487540650929, 0.17116348832129313, 0.1481323354114682, 0.21111005118213533, 0.15252124301467507, 0.20873616453617583, 0.2619890750778797, 0.18473337265661716, 0.15911726956534944, 0.06500260873424357, 0.07152805977261267, 0.09468373005387387, 0.05523740942870914, 0.07739788615091725, 0.009949770779177247, 0.030975301437848213, 0.2124854932593203, 0.03876738766210053, 0.24291853675599484, 0.2127555003913204, 0.06829988532013542, 0.15352543110108274, 0.19184604521637538, 0.09406362961069048, 0.22975636238680586, 0.19165622123400683, 0.16291961162162283, 0.11623658050202812, 0.21092174461327307, 0.06633934346789594, 0.12453591533224773, 0.2225366677502909, 0.1156759925756623, 0.11707042909734988, 0.1619297087305256, 0.25848039030668324, 0.3328193521152544, 0.2093989054487364, 0.30768061733330376, 0.20518070181815606, 0.22484208893508995, 0.2377909801391872, 0.11756135199435125, 0.08230542163293508, 0.09088499678277018, 0.6272604824869518, 0.580165102798939, 0.6557706642247022, 0.5990032551121255, 0.43434370167361824, 0.6638780747620323, 0.6127480703079178, 0.5657323329086841, 0.6156515783253009, 0.13227987882764392, 0.16105998333814242, 0.10135175854276945, 0.13946187285928913, 0.1376226711447378, 0.09042628258186791, 0.14756344239519825, 0.1354678341284683, 0.11948132248682208, 0.28277873720918467, 0.19316597263764557, 0.1782478568147151, 0.22168385295117365, 0.21841385654079415, 0.3923206521694901, 0.1841611467259907, 0.1820893117911806, 0.20187397112161676, 0.41590346905775255, 0.5147919396956417, 0.5262850526387304, 0.5424204483657686, 0.35771604332397444, 0.4292112074829524, 0.5905126123825251, 0.4023850663903473, 0.48369507103457376, 0.2295228332918906, 0.3655433992931266, 0.3207775855103646, 0.41887635897017206, 0.23187140103657, 0.3454133058476997, 0.6080643183443186, 0.384767760791079, 0.535812422463187, 0.23782978701868962, 0.24094266240340156, 0.22603067694644474, 0.22653608411189152, 0.23427267589904233, 0.21186081122711264, 0.23812239789555456, 0.2781530121175808, 0.23923045811413512, 0.18902246613852725, 0.20015247042846018, 0.20433758540504443, 0.20273659854443427, 0.185718350217556, 0.18365334923644228, 0.21968343658398626, 0.19450096392524296, 0.21069960636657503, 0.8476182635931915, 0.17089581725117098, 0.911589128445484, 0.1957756403497931, 0.15985836906392037, 0.1678659145789646, 0.7410385439170387, 0.166824141596433, 0.8751837711758859, 0.8295886166394626, 0.8641579424678181, 0.8487729132070869, 0.20711317198635915, 0.20878117636343418, 0.20815697941365197, 0.8885448438429085, 0.16334955773164817, 0.5689845733342012, 0.19700414130828203, 0.19058808665779692, 0.19935856463319712, 0.19656584179204706, 0.20420874756930174, 0.18090372426504653, 0.2239459388766759, 0.1853968744329172, 0.19902830605573074, 0.09376836458760973, 0.08344725710590861, 0.10062830272917656, 0.1020614591100164, 0.07936835494141758, 0.0919676655691486, 0.08594144944301318, 0.08995629769174629, 0.09970317902271841]}, "mutation_prompt": null}
{"id": "12d4e650-2227-45df-bc4e-cf652ceab411", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with probabilistic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                if np.random.rand() < 0.8:  # Increased probability for mutation strategy\n                    mutant = np.clip(a + np.random.uniform(0.6, 1.2) * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(global_best + np.random.uniform(0.6, 1.2) * (b - a), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Adjust learning rates adaptively\n            self.c1 = np.random.uniform(1.5, 2.5) * (1 - budget_used / self.budget)\n            self.c2 = np.random.uniform(1.0, 2.0) * (budget_used / self.budget)\n\n            # Adaptive inertia based on fitness improvement\n            self.w = 0.5 + 0.3 * np.tanh((global_best_fitness - fitness.min()) / (historic_best + 1e-9))\n            self.w = np.clip(self.w, 0.2, 0.7)\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "Enhanced Differential Evolution with Adaptive Mutation and Swarm Intelligence for Efficient Search.", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'global_best_fitness' is not defined\").", "error": "NameError(\"name 'global_best_fitness' is not defined\")", "parent_id": "a315cc62-4211-4c05-9b85-884aee96b2a0", "metadata": {}, "mutation_prompt": null}
{"id": "622bc470-492c-43cb-ac14-c264a5661b45", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with probabilistic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                if np.random.rand() < 0.7:  # Probabilistic selection of mutation strategy\n                    mutant = np.clip(a + np.random.uniform(0.5, 1.0) * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(global_best + np.random.uniform(0.5, 1.0) * (b - a), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Adjust learning rates adaptively\n            self.c1 = np.random.uniform(1.5, 2.5) * (1 - budget_used / self.budget)\n            self.c2 = np.random.uniform(1.0, 2.0) * (budget_used / self.budget)\n\n            # Memory-based inertia adjustment\n            historic_best = fitness.min()\n            self.w = 0.4 + 0.5 * (historic_best - fitness.mean()) / (historic_best + 1e-9)\n            self.w = np.clip(self.w, 0.1, 0.6)\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with a novel probabilistic mutation strategy and memory-based inertia to boost convergence.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a315cc62-4211-4c05-9b85-884aee96b2a0", "metadata": {"aucs": [0.8121739212131376, 0.8065504339741629, 0.808399126283219, 0.8268055411872113, 0.8186815464693457, 0.8156334146654408, 0.8220552149930658, 0.8124049249076453, 0.8032268113097001, 0.7046280867720519, 0.6797475460651222, 0.6689062809577883, 0.6910455401206312, 0.6850238268144604, 0.6877765437437522, 0.6887565143309139, 0.6663419762615517, 0.6855238815820668, 0.15246120122247864, 0.11683198159661823, 0.46391636675205805, 0.1425181536026634, 0.12020496710916795, 0.11476130132680251, 0.136090768698093, 0.14233109149753986, 0.13949966178337836, 0.13220181510018303, 0.0989961504989868, 0.12262834847665605, 0.09576847178152348, 0.1200934073934743, 0.10816318970047356, 0.12866360291139756, 0.11100495892402173, 0.12031800871830378, 0.9848280941692072, 0.9822096723588887, 0.9774313603946428, 0.9386843349351494, 0.9589911559124588, 0.967211790471227, 0.9787196364572956, 0.9761154648983643, 0.9647994043597012, 0.6785308116303539, 0.6413761774110052, 0.6738818445652499, 0.6416038301470284, 0.6575097141084004, 0.6680975859187039, 0.700167883351968, 0.6533078578283935, 0.7002097842438726, 0.788050754280684, 0.7794321633431516, 0.749582474564737, 0.8041958647379287, 0.7722436972554009, 0.7946624158953679, 0.767825407707804, 0.7610777605585773, 0.7739740594813861, 0.2569147037612117, 0.1226358436968239, 0.21890620088931656, 0.19546072592136765, 0.3509404156492355, 0.33361262046321416, 0.268451112673213, 0.24292966720000853, 0.29276638115666487, 0.12141452906815486, 0.2645288711804815, 0.19965935448102567, 0.28821731278731877, 0.26662269271967665, 0.24525035029122344, 0.24772400246786952, 0.381046377240579, 0.24655731166167338, 0.09575359082215074, 0.11062088086858035, 0.05356385546906117, 0.09598271889022802, 0.031038744428861342, 0.06779060465136011, 0.07257432756391313, 0.06127718672449989, 0.061224301975332684, 0.14141692224504387, 0.1523871382578159, 0.14887025814600352, 0.11983357237070691, 0.1319130198094577, 0.09906770218417427, 0.170864265392079, 0.16638895100904116, 0.1735677115134413, 0.14211442154789033, 0.06081954472944506, 0.09149390479355024, 0.08419039056049427, 0.2120793546633265, 0.12477713716235717, 0.10720914082520772, 0.08952722823789994, 0.1552473307456399, 0.1305200171584715, 0.2525567114997973, 0.19394581490364804, 0.18918399797529883, 0.20966865965238668, 0.18723689694118462, 0.20505474417297886, 0.1355889778927598, 0.1889124740224548, 0.5518676926251205, 0.5794095976198712, 0.5509254567617179, 0.6008500163484372, 0.5845106666896442, 0.5541974402289712, 0.54059802549404, 0.6061015609614535, 0.6016192971689202, 0.12215067079788244, 0.11400157920915521, 0.1306091623317529, 0.12017813384565257, 0.13885021142724852, 0.12548306302287238, 0.12738106556838324, 0.12070000092306277, 0.15662761509075174, 0.13676879245608908, 0.2795002386171952, 0.2570928346418746, 0.22481391768428893, 0.19622611379731825, 0.22637763674948674, 0.17455574877067848, 0.21375624974474516, 0.2090544779322785, 0.4781188304898959, 0.4706852853225697, 0.3613414926455826, 0.5847708362194299, 0.3943568970780186, 0.3871403545525409, 0.5032323318182257, 0.517904805576054, 0.47639286825100824, 0.28371214123592015, 0.35243508182284444, 0.34154310500325646, 0.4791932320251987, 0.3731029313006833, 0.20295282003577564, 0.2395926267550582, 0.3778314242206092, 0.4242984725427531, 0.2058278302547354, 0.21398499699774698, 0.2101893998518053, 0.22885964144983495, 0.1987041452340853, 0.20213312129127303, 0.23661415061485536, 0.21837681408466036, 0.2152725528459395, 0.5955409461084353, 0.19908883297725766, 0.20096083779354645, 0.2105381681472952, 0.19509509921945756, 0.2271834293298841, 0.18958242052823848, 0.18734619629501703, 0.21117657825525116, 0.17091183269029497, 0.17146960123148713, 0.7982405561256902, 0.19086529341935887, 0.6880989932576556, 0.7898513216729918, 0.7446715279231841, 0.7976054554625447, 0.2080731308390853, 0.7836948902192584, 0.7529207216973023, 0.7241875514599532, 0.20055355024549326, 0.688634414191002, 0.7403679303605467, 0.20694068132047183, 0.7155006718783228, 0.1649845036455193, 0.20564488259111713, 0.21813352730676994, 0.21329997743853368, 0.19337149385289, 0.19315447584219492, 0.18885233377136568, 0.18294903348347014, 0.18717399207401675, 0.2355658498197687, 0.09224745515881883, 0.09594281848693431, 0.09367572787432288, 0.08905313280666394, 0.08992300156664257, 0.0846441214770357, 0.08557967919571097, 0.09119505560898056, 0.08864064900235391]}, "mutation_prompt": null}
{"id": "e730b3b7-7404-4ffc-b123-fac2caa70672", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with probabilistic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                if np.random.rand() < 0.7:  # Probabilistic selection of mutation strategy\n                    mutant = np.clip(a + np.random.uniform(0.5, 1.0) * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(global_best + np.random.uniform(0.5, 1.0) * (b - a), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Adjust learning rates adaptively\n            self.c1 = np.random.uniform(1.5, 2.5) * (1 - budget_used / self.budget)\n            self.c2 = np.random.uniform(1.0, 2.0) * (budget_used / self.budget)\n\n            # Memory-based inertia adjustment\n            historic_best = fitness.min()\n            self.w = 0.4 + 0.5 * (historic_best - fitness.mean()) / (historic_best + 1e-9)\n            self.w = np.clip(self.w, 0.1, 0.6)\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with a novel probabilistic mutation strategy and memory-based inertia to boost convergence.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a315cc62-4211-4c05-9b85-884aee96b2a0", "metadata": {"aucs": [0.8121739212131376, 0.8065504339741629, 0.808399126283219, 0.8268055411872113, 0.8186815464693457, 0.8156334146654408, 0.8220552149930658, 0.8124049249076453, 0.8032268113097001, 0.7046280867720519, 0.6797475460651222, 0.6689062809577883, 0.6910455401206312, 0.6850238268144604, 0.6877765437437522, 0.6887565143309139, 0.6663419762615517, 0.6855238815820668, 0.15246120122247864, 0.11683198159661823, 0.46391636675205805, 0.1425181536026634, 0.12020496710916795, 0.11476130132680251, 0.136090768698093, 0.14233109149753986, 0.13949966178337836, 0.13220181510018303, 0.0989961504989868, 0.12262834847665605, 0.09576847178152348, 0.1200934073934743, 0.10816318970047356, 0.12866360291139756, 0.11100495892402173, 0.12031800871830378, 0.9848280941692072, 0.9822096723588887, 0.9774313603946428, 0.9386843349351494, 0.9589911559124588, 0.967211790471227, 0.9787196364572956, 0.9761154648983643, 0.9647994043597012, 0.6785308116303539, 0.6413761774110052, 0.6738818445652499, 0.6416038301470284, 0.6575097141084004, 0.6680975859187039, 0.700167883351968, 0.6533078578283935, 0.7002097842438726, 0.788050754280684, 0.7794321633431516, 0.749582474564737, 0.8041958647379287, 0.7722436972554009, 0.7946624158953679, 0.767825407707804, 0.7610777605585773, 0.7739740594813861, 0.2569147037612117, 0.1226358436968239, 0.21890620088931656, 0.19546072592136765, 0.3509404156492355, 0.33361262046321416, 0.268451112673213, 0.24292966720000853, 0.29276638115666487, 0.12141452906815486, 0.2645288711804815, 0.19965935448102567, 0.28821731278731877, 0.26662269271967665, 0.24525035029122344, 0.24772400246786952, 0.381046377240579, 0.24655731166167338, 0.09575359082215074, 0.11062088086858035, 0.05356385546906117, 0.09598271889022802, 0.031038744428861342, 0.06779060465136011, 0.07257432756391313, 0.06127718672449989, 0.061224301975332684, 0.14141692224504387, 0.1523871382578159, 0.14887025814600352, 0.11983357237070691, 0.1319130198094577, 0.09906770218417427, 0.170864265392079, 0.16638895100904116, 0.1735677115134413, 0.14211442154789033, 0.06081954472944506, 0.09149390479355024, 0.08419039056049427, 0.2120793546633265, 0.12477713716235717, 0.10720914082520772, 0.08952722823789994, 0.1552473307456399, 0.1305200171584715, 0.2525567114997973, 0.19394581490364804, 0.18918399797529883, 0.20966865965238668, 0.18723689694118462, 0.20505474417297886, 0.1355889778927598, 0.1889124740224548, 0.5518676926251205, 0.5794095976198712, 0.5509254567617179, 0.6008500163484372, 0.5845106666896442, 0.5541974402289712, 0.54059802549404, 0.6061015609614535, 0.6016192971689202, 0.12215067079788244, 0.11400157920915521, 0.1306091623317529, 0.12017813384565257, 0.13885021142724852, 0.12548306302287238, 0.12738106556838324, 0.12070000092306277, 0.15662761509075174, 0.13676879245608908, 0.2795002386171952, 0.2570928346418746, 0.22481391768428893, 0.19622611379731825, 0.22637763674948674, 0.17455574877067848, 0.21375624974474516, 0.2090544779322785, 0.4781188304898959, 0.4706852853225697, 0.3613414926455826, 0.5847708362194299, 0.3943568970780186, 0.3871403545525409, 0.5032323318182257, 0.517904805576054, 0.47639286825100824, 0.28371214123592015, 0.35243508182284444, 0.34154310500325646, 0.4791932320251987, 0.3731029313006833, 0.20295282003577564, 0.2395926267550582, 0.3778314242206092, 0.4242984725427531, 0.2058278302547354, 0.21398499699774698, 0.2101893998518053, 0.22885964144983495, 0.1987041452340853, 0.20213312129127303, 0.23661415061485536, 0.21837681408466036, 0.2152725528459395, 0.5955409461084353, 0.19908883297725766, 0.20096083779354645, 0.2105381681472952, 0.19509509921945756, 0.2271834293298841, 0.18958242052823848, 0.18734619629501703, 0.21117657825525116, 0.17091183269029497, 0.17146960123148713, 0.7982405561256902, 0.19086529341935887, 0.6880989932576556, 0.7898513216729918, 0.7446715279231841, 0.7976054554625447, 0.2080731308390853, 0.7836948902192584, 0.7529207216973023, 0.7241875514599532, 0.20055355024549326, 0.688634414191002, 0.7403679303605467, 0.20694068132047183, 0.7155006718783228, 0.1649845036455193, 0.20564488259111713, 0.21813352730676994, 0.21329997743853368, 0.19337149385289, 0.19315447584219492, 0.18885233377136568, 0.18294903348347014, 0.18717399207401675, 0.2355658498197687, 0.09224745515881883, 0.09594281848693431, 0.09367572787432288, 0.08905313280666394, 0.08992300156664257, 0.0846441214770357, 0.08557967919571097, 0.09119505560898056, 0.08864064900235391]}, "mutation_prompt": null}
{"id": "43c510c9-5a80-45d8-be9e-f94ddde16549", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with probabilistic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                if np.random.rand() < 0.7:  # Probabilistic selection of mutation strategy\n                    mutant = np.clip(a + np.random.uniform(0.5, 1.0) * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(global_best + np.random.uniform(0.5, 1.0) * (b - a), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial += np.random.normal(0, 0.1, self.dim)  # Stochastic perturbation\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Adjust learning rates adaptively with focus on exploration\n            self.c1 = np.random.uniform(1.5, 2.5) * (1 - (budget_used / self.budget) ** 2)\n            self.c2 = np.random.uniform(1.0, 2.0) * (budget_used / self.budget) ** 2\n\n            # Memory-based inertia adjustment\n            historic_best = fitness.min()\n            self.w = 0.4 + 0.5 * (historic_best - fitness.mean()) / (historic_best + 1e-9)\n            self.w = np.clip(self.w, 0.1, 0.6)\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with adaptive learning strategy and stochastic perturbation for improved exploration.", "configspace": "", "generation": 90, "fitness": 0.2717143779507876, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "a315cc62-4211-4c05-9b85-884aee96b2a0", "metadata": {"aucs": [0.6396843714141361, 0.6226301590477585, 0.5562034424095352, 0.6931948741412446, 0.6461615996432173, 0.6017146668041414, 0.6005143713115375, 0.5458534894848976, 0.5764554360707344, 0.07471673493715902, 0.04355905120393422, 0.056453737783278335, 0.09588623586159373, 0.1085105091829015, 0.12802846484087116, 0.08976186992438995, 0.16106072192819443, 0.12797162950122243, 0.12276235338247865, 0.12756346037210553, 0.12763029771374457, 0.11401772473895466, 0.13949736603071583, 0.1279596544306807, 0.12017336654309962, 0.13751270299500684, 0.13566076009186345, 0.10846580651104853, 0.09584222264733766, 0.09932171716203197, 0.11166044333021397, 0.09707925283222629, 0.10114945355484706, 0.12614780758614086, 0.10744622455361608, 0.10791968637304672, 0.9507787001164426, 0.9709025909992087, 0.9096725395931622, 0.9466548480448764, 0.9237803985475931, 0.9509554447433455, 0.9592706491582311, 0.9589460754962653, 0.9277237901819674, 0.28957640411954766, 0.289437741930086, 0.2872029581121588, 0.2542550098617167, 0.2690799037677516, 0.27536396029880206, 0.28205627396614474, 0.2776820092450607, 0.2886645176750612, 0.6355929505032911, 0.6101723559669141, 0.6349511397435843, 0.613791517300594, 0.6119918724474087, 0.6353383997483606, 0.6799303293982246, 0.4756035586984111, 0.6932477380577393, 0.14031780721181009, 0.16719226066807036, 0.138329814744252, 0.16178465937289388, 0.15451569245635144, 0.14175817342217156, 0.15833541040222576, 0.14828247773626368, 0.15269733812466513, 0.10784567827905578, 0.12487329333032826, 0.16035488584117574, 0.22523233279094135, 0.11369754380477026, 0.16086254732654093, 0.13542399004309336, 0.14385125362872442, 0.1946728189717376, 9.999999999998899e-05, 0.03167170356570792, 0.046947018387055506, 0.04053909593045901, 0.04855490137034901, 0.027706396251709675, 0.07905385012334498, 0.03263882740787016, 0.05221785207013219, 0.12015439795849103, 0.13648039881316565, 0.13287179247998715, 0.208404814851743, 0.09756474769494905, 0.10207969563828667, 0.12457505207747877, 0.12577112483926245, 0.1298016779447435, 0.02531077583131225, 0.12167872318641693, 0.07793089802283615, 0.09720541839799113, 0.10940897788571602, 0.18249881245787813, 0.11985274696984893, 0.09084846012115266, 0.0282134890728426, 0.19296977576762753, 0.17608762714098336, 0.1572456837643771, 0.17277825954734305, 0.177936120599003, 0.2731753180912878, 0.12927516753777113, 0.14982635162360203, 0.19703869625973447, 0.46652989262900113, 0.45876284887785845, 0.462583994395242, 0.5080599557200637, 0.4374893389674659, 0.49546666863135025, 0.42656980840820535, 0.46878464229801253, 0.4691278136961501, 0.10131152208231087, 0.12016186840863852, 0.10879060431034526, 0.09709602280050988, 0.10326298816741042, 0.11246131882385912, 0.10357333109790545, 0.11206190761825185, 0.13422328908165804, 0.14648833148821538, 0.1667851945572787, 0.16790273264920252, 0.1833142984778362, 0.2197541532150662, 0.15337492737267788, 0.1992800723470356, 0.1730488655520852, 0.18749839739848517, 0.34717998783992343, 0.29102216188282415, 0.3223585075574894, 0.3195998363508066, 0.3184615919753192, 0.3757990123124798, 0.34426333723152713, 0.2894826356446998, 0.31675894820612216, 0.26696854406298576, 0.28554051218426424, 0.22744960071974418, 0.2592400106445436, 0.26347915202705174, 0.24660562966956623, 0.25352799979262797, 0.2463133034534053, 0.271389210636522, 0.2020967048939668, 0.23667703086273473, 0.21630626054018753, 0.22609555908599144, 0.22379698223143563, 0.22112021838241946, 0.21833517345532927, 0.22925632028595888, 0.2107496119210781, 0.18153247176060716, 0.1761910656743153, 0.18705369578473074, 0.20862668601953493, 0.1971306324898373, 0.22008599094784032, 0.3437243277443225, 0.195450703597705, 0.19440086401566792, 0.1624709572595353, 0.7342551553170797, 0.7234327379693937, 0.6627961746320945, 0.6476153305167509, 0.19224843865415775, 0.2004595214304934, 0.6766203294407183, 0.7213272917770337, 0.5324564330623882, 0.6282762907859691, 0.6439417094674434, 0.2015258914783149, 0.20048249197481938, 0.19194658561527667, 0.7226296685970934, 0.42181521705376357, 0.15453937898752734, 0.19333957607643204, 0.1995361758682116, 0.2009744587196194, 0.18923990596614282, 0.1818370516713811, 0.18777681198873242, 0.18287815862085255, 0.20458588329369032, 0.21392537069847672, 0.08084992600270635, 0.08248031639158415, 0.08589770975161959, 0.09166452524584079, 0.10064989357757514, 0.08654964375666929, 0.09229468872740032, 0.06880208074734218, 0.08511081338893034]}, "mutation_prompt": null}
{"id": "7f5be509-5c5a-4dfd-ae3f-2d08825e39e3", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with probabilistic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                if np.random.rand() < 0.7:  # Probabilistic selection of mutation strategy\n                    mutant = np.clip(a + np.random.uniform(0.5, 1.0) * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(global_best + np.random.uniform(0.5, 1.0) * (b - a), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Adjust learning rates adaptively\n            self.c1 = np.random.uniform(1.5, 2.5) * (1 - budget_used / self.budget)\n            self.c2 = np.random.uniform(1.0, 2.0) * (budget_used / self.budget)\n\n            # Memory-based inertia adjustment\n            historic_best = fitness.min()\n            self.w = 0.4 + 0.5 * (historic_best - fitness.mean()) / (historic_best + 1e-9)\n            self.w = np.clip(self.w, 0.1, 0.6)\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with a novel probabilistic mutation strategy and memory-based inertia to boost convergence.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a315cc62-4211-4c05-9b85-884aee96b2a0", "metadata": {"aucs": [0.8121739212131376, 0.8065504339741629, 0.808399126283219, 0.8268055411872113, 0.8186815464693457, 0.8156334146654408, 0.8220552149930658, 0.8124049249076453, 0.8032268113097001, 0.7046280867720519, 0.6797475460651222, 0.6689062809577883, 0.6910455401206312, 0.6850238268144604, 0.6877765437437522, 0.6887565143309139, 0.6663419762615517, 0.6855238815820668, 0.15246120122247864, 0.11683198159661823, 0.46391636675205805, 0.1425181536026634, 0.12020496710916795, 0.11476130132680251, 0.136090768698093, 0.14233109149753986, 0.13949966178337836, 0.13220181510018303, 0.0989961504989868, 0.12262834847665605, 0.09576847178152348, 0.1200934073934743, 0.10816318970047356, 0.12866360291139756, 0.11100495892402173, 0.12031800871830378, 0.9848280941692072, 0.9822096723588887, 0.9774313603946428, 0.9386843349351494, 0.9589911559124588, 0.967211790471227, 0.9787196364572956, 0.9761154648983643, 0.9647994043597012, 0.6785308116303539, 0.6413761774110052, 0.6738818445652499, 0.6416038301470284, 0.6575097141084004, 0.6680975859187039, 0.700167883351968, 0.6533078578283935, 0.7002097842438726, 0.788050754280684, 0.7794321633431516, 0.749582474564737, 0.8041958647379287, 0.7722436972554009, 0.7946624158953679, 0.767825407707804, 0.7610777605585773, 0.7739740594813861, 0.2569147037612117, 0.1226358436968239, 0.21890620088931656, 0.19546072592136765, 0.3509404156492355, 0.33361262046321416, 0.268451112673213, 0.24292966720000853, 0.29276638115666487, 0.12141452906815486, 0.2645288711804815, 0.19965935448102567, 0.28821731278731877, 0.26662269271967665, 0.24525035029122344, 0.24772400246786952, 0.381046377240579, 0.24655731166167338, 0.09575359082215074, 0.11062088086858035, 0.05356385546906117, 0.09598271889022802, 0.031038744428861342, 0.06779060465136011, 0.07257432756391313, 0.06127718672449989, 0.061224301975332684, 0.14141692224504387, 0.1523871382578159, 0.14887025814600352, 0.11983357237070691, 0.1319130198094577, 0.09906770218417427, 0.170864265392079, 0.16638895100904116, 0.1735677115134413, 0.14211442154789033, 0.06081954472944506, 0.09149390479355024, 0.08419039056049427, 0.2120793546633265, 0.12477713716235717, 0.10720914082520772, 0.08952722823789994, 0.1552473307456399, 0.1305200171584715, 0.2525567114997973, 0.19394581490364804, 0.18918399797529883, 0.20966865965238668, 0.18723689694118462, 0.20505474417297886, 0.1355889778927598, 0.1889124740224548, 0.5518676926251205, 0.5794095976198712, 0.5509254567617179, 0.6008500163484372, 0.5845106666896442, 0.5541974402289712, 0.54059802549404, 0.6061015609614535, 0.6016192971689202, 0.12215067079788244, 0.11400157920915521, 0.1306091623317529, 0.12017813384565257, 0.13885021142724852, 0.12548306302287238, 0.12738106556838324, 0.12070000092306277, 0.15662761509075174, 0.13676879245608908, 0.2795002386171952, 0.2570928346418746, 0.22481391768428893, 0.19622611379731825, 0.22637763674948674, 0.17455574877067848, 0.21375624974474516, 0.2090544779322785, 0.4781188304898959, 0.4706852853225697, 0.3613414926455826, 0.5847708362194299, 0.3943568970780186, 0.3871403545525409, 0.5032323318182257, 0.517904805576054, 0.47639286825100824, 0.28371214123592015, 0.35243508182284444, 0.34154310500325646, 0.4791932320251987, 0.3731029313006833, 0.20295282003577564, 0.2395926267550582, 0.3778314242206092, 0.4242984725427531, 0.2058278302547354, 0.21398499699774698, 0.2101893998518053, 0.22885964144983495, 0.1987041452340853, 0.20213312129127303, 0.23661415061485536, 0.21837681408466036, 0.2152725528459395, 0.5955409461084353, 0.19908883297725766, 0.20096083779354645, 0.2105381681472952, 0.19509509921945756, 0.2271834293298841, 0.18958242052823848, 0.18734619629501703, 0.21117657825525116, 0.17091183269029497, 0.17146960123148713, 0.7982405561256902, 0.19086529341935887, 0.6880989932576556, 0.7898513216729918, 0.7446715279231841, 0.7976054554625447, 0.2080731308390853, 0.7836948902192584, 0.7529207216973023, 0.7241875514599532, 0.20055355024549326, 0.688634414191002, 0.7403679303605467, 0.20694068132047183, 0.7155006718783228, 0.1649845036455193, 0.20564488259111713, 0.21813352730676994, 0.21329997743853368, 0.19337149385289, 0.19315447584219492, 0.18885233377136568, 0.18294903348347014, 0.18717399207401675, 0.2355658498197687, 0.09224745515881883, 0.09594281848693431, 0.09367572787432288, 0.08905313280666394, 0.08992300156664257, 0.0846441214770357, 0.08557967919571097, 0.09119505560898056, 0.08864064900235391]}, "mutation_prompt": null}
{"id": "b0bfd8c3-8f30-4dd1-b033-0a156410ffbc", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.8  # Modified DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.7)  # Extended inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with adaptive mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutation_factor = 0.5 + 0.5 * (budget_used / self.budget)  # Adaptive mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Adjust learning rates adaptively\n            self.c1 = np.random.uniform(1.5, 2.5) * (1 - budget_used / self.budget)\n            self.c2 = np.random.uniform(1.0, 2.0) * (budget_used / self.budget)\n\n            # Dynamic inertia scaling\n            self.w = 0.6 - (0.4 * budget_used / self.budget)  # Linearly decrease inertia over time\n            self.w = np.clip(self.w, 0.1, 0.6)\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with adaptive DE mutation and dynamic inertia scaling for improved exploration-exploitation balance.", "configspace": "", "generation": 92, "fitness": 0.3389464902028338, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "a315cc62-4211-4c05-9b85-884aee96b2a0", "metadata": {"aucs": [0.8146289453988018, 0.815601537257033, 0.8193141180179495, 0.8088583035213641, 0.8176620546540486, 0.8050256236919723, 0.8158130960056276, 0.8008096844292375, 0.8117316005804353, 0.6830042308812785, 0.6855239078091814, 0.6499612800203389, 0.6874128871243306, 0.6798551209093802, 0.6812850413063908, 0.6837065017857398, 0.6654194642162711, 0.6883783817779676, 0.1278967665660311, 0.14984120491160413, 0.13362782143310592, 0.4277232965068263, 0.1397136775191382, 0.1452298812233881, 0.1503442610736736, 0.12599482718128385, 0.1447584044010788, 0.1310138845344303, 0.10466920622027265, 0.11024022184749005, 0.11415270685274304, 0.12457917378431516, 0.11075355554947797, 0.11510732140275193, 0.12000529254555936, 0.10915263403567865, 0.8905301856803883, 0.8675942107711974, 0.9469666972419581, 0.8986017475604045, 0.8959303416922914, 0.8804789206312902, 0.8965686846237548, 0.8588750176634024, 0.780442247072399, 0.5618559541184422, 0.4556020760360888, 0.25351510851888825, 0.6414957855734966, 0.6627097572538216, 0.3500232985099513, 0.2541038220718531, 0.295837077171041, 0.6710702491753338, 0.7657952714798597, 0.7959581877936857, 0.8043327806942966, 0.7947633772662519, 0.7900589882561619, 0.34848500688952544, 0.8068236833283948, 0.7695017884591602, 0.7957773374400231, 0.15974598356770908, 0.17106359368846336, 0.14626033530986882, 0.12023069590523028, 0.12067181663228765, 0.16787182468495354, 0.16846085404006605, 0.13894551149815548, 0.21848971074123602, 0.23888572040804035, 0.1781574069583174, 0.21257403084044202, 0.17162338916462194, 0.1706270084131254, 0.23873325937358403, 0.1560561016559966, 0.14035619152358592, 0.1482848166540771, 0.0536438670572148, 0.061694456130945596, 0.05829195189512304, 0.00615782621458727, 0.08978558021231597, 0.17005361618512893, 0.027780951425735334, 0.04927748336022464, 0.03833904545293065, 0.10653897248490007, 0.1315150674169001, 0.14969869961536986, 0.13832016719483686, 0.1180495020671467, 0.09122686923217038, 0.11956130875807025, 0.12715202653456859, 0.14428829780705832, 0.09835144404740037, 0.22816991409457565, 0.1208675262039367, 0.12033082441647935, 0.06624345985234281, 0.1668540497042288, 0.13026571391051311, 0.1464292729021669, 0.1460445400276279, 0.2117954859464547, 0.19479784983555204, 0.2511048038529642, 0.14073482443659635, 0.17482257789610045, 0.17219589674699742, 0.10090296007062949, 0.19944672273569697, 0.3131225476974606, 0.5671382875159006, 0.5398112610812157, 0.5671309896847695, 0.5327254335964585, 0.5413627064880118, 0.589124289748078, 0.5543944645180674, 0.567430113365075, 0.5730606861873837, 0.43836555829957247, 0.1629528998708043, 0.11672996697012605, 0.13333438738901837, 0.13536185640084242, 0.12431651582779724, 0.12308737155003324, 0.15343971954143742, 0.10436875996886863, 0.21087846648004593, 0.20974226117440353, 0.18103116675960307, 0.18227503777476717, 0.1702931507222305, 0.1739025027036556, 0.1695317883162456, 0.16384842930052712, 0.1500001159546166, 0.3543927976173614, 0.5386520210079463, 0.4475930923163687, 0.6161864745247458, 0.4996739312088728, 0.5004715102942744, 0.4689205858095311, 0.4752082083057344, 0.5528074431788661, 0.3516079910791451, 0.28548900168053626, 0.3026679181776085, 0.28194678571599674, 0.3215323619432163, 0.2587579416202732, 0.4146712923596896, 0.3240542890568805, 0.46586036002685693, 0.19978811929359075, 0.20026151786598156, 0.21309843684026142, 0.2208222988334524, 0.1984948744455518, 0.24617400997198535, 0.252773973615404, 0.2300352036388431, 0.2397306382698916, 0.20809503084437841, 0.18895453659208483, 0.19678575330715908, 0.18434717157133684, 0.20135911270693796, 0.1799100126090154, 0.2100325096270822, 0.2455200507392622, 0.20265380254311072, 0.17353958088748145, 0.17939399775738418, 0.7931270535556887, 0.1913899473756021, 0.6498587072476787, 0.69664121212644, 0.5532987174219166, 0.7833401248568012, 0.6964769791302844, 0.7069372816690453, 0.3620951643505189, 0.5607972812561177, 0.5024343735233177, 0.3122354142856226, 0.6985149396323372, 0.20605573228359364, 0.20880687604556736, 0.47758170550955736, 0.1960549206338198, 0.19636827110382993, 0.20074114881098581, 0.2024214480542651, 0.1944370648575927, 0.20835485937774179, 0.1778800265516195, 0.2126248390043285, 0.18499386298247422, 0.080626761647007, 0.09281888396670124, 0.09788247150765583, 0.08207595873330598, 0.096728919455498, 0.0814632189261052, 0.0921910001781695, 0.0952813072898151, 0.08861471095517859]}, "mutation_prompt": null}
{"id": "f09a1a0d-fc3b-49dd-bdc3-3b81e47129d0", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with probabilistic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                if np.random.rand() < 0.7:  # Probabilistic selection of mutation strategy\n                    mutant = np.clip(a + np.random.uniform(0.5, 1.0) * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(global_best + np.random.uniform(0.5, 1.0) * (b - a), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Adjust learning rates adaptively\n            self.c1 = np.random.uniform(1.5, 2.5) * (1 - budget_used / self.budget)\n            self.c2 = np.random.uniform(1.0, 2.0) * (budget_used / self.budget)\n\n            # Memory-based inertia adjustment\n            historic_best = fitness.min()\n            self.w = 0.4 + 0.5 * (historic_best - fitness.mean()) / (historic_best + 1e-9)\n            self.w = np.clip(self.w, 0.1, 0.6)\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with a novel probabilistic mutation strategy and memory-based inertia to boost convergence.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a315cc62-4211-4c05-9b85-884aee96b2a0", "metadata": {"aucs": [0.8121739212131376, 0.8065504339741629, 0.808399126283219, 0.8268055411872113, 0.8186815464693457, 0.8156334146654408, 0.8220552149930658, 0.8124049249076453, 0.8032268113097001, 0.7046280867720519, 0.6797475460651222, 0.6689062809577883, 0.6910455401206312, 0.6850238268144604, 0.6877765437437522, 0.6887565143309139, 0.6663419762615517, 0.6855238815820668, 0.15246120122247864, 0.11683198159661823, 0.46391636675205805, 0.1425181536026634, 0.12020496710916795, 0.11476130132680251, 0.136090768698093, 0.14233109149753986, 0.13949966178337836, 0.13220181510018303, 0.0989961504989868, 0.12262834847665605, 0.09576847178152348, 0.1200934073934743, 0.10816318970047356, 0.12866360291139756, 0.11100495892402173, 0.12031800871830378, 0.9848280941692072, 0.9822096723588887, 0.9774313603946428, 0.9386843349351494, 0.9589911559124588, 0.967211790471227, 0.9787196364572956, 0.9761154648983643, 0.9647994043597012, 0.6785308116303539, 0.6413761774110052, 0.6738818445652499, 0.6416038301470284, 0.6575097141084004, 0.6680975859187039, 0.700167883351968, 0.6533078578283935, 0.7002097842438726, 0.788050754280684, 0.7794321633431516, 0.749582474564737, 0.8041958647379287, 0.7722436972554009, 0.7946624158953679, 0.767825407707804, 0.7610777605585773, 0.7739740594813861, 0.2569147037612117, 0.1226358436968239, 0.21890620088931656, 0.19546072592136765, 0.3509404156492355, 0.33361262046321416, 0.268451112673213, 0.24292966720000853, 0.29276638115666487, 0.12141452906815486, 0.2645288711804815, 0.19965935448102567, 0.28821731278731877, 0.26662269271967665, 0.24525035029122344, 0.24772400246786952, 0.381046377240579, 0.24655731166167338, 0.09575359082215074, 0.11062088086858035, 0.05356385546906117, 0.09598271889022802, 0.031038744428861342, 0.06779060465136011, 0.07257432756391313, 0.06127718672449989, 0.061224301975332684, 0.14141692224504387, 0.1523871382578159, 0.14887025814600352, 0.11983357237070691, 0.1319130198094577, 0.09906770218417427, 0.170864265392079, 0.16638895100904116, 0.1735677115134413, 0.14211442154789033, 0.06081954472944506, 0.09149390479355024, 0.08419039056049427, 0.2120793546633265, 0.12477713716235717, 0.10720914082520772, 0.08952722823789994, 0.1552473307456399, 0.1305200171584715, 0.2525567114997973, 0.19394581490364804, 0.18918399797529883, 0.20966865965238668, 0.18723689694118462, 0.20505474417297886, 0.1355889778927598, 0.1889124740224548, 0.5518676926251205, 0.5794095976198712, 0.5509254567617179, 0.6008500163484372, 0.5845106666896442, 0.5541974402289712, 0.54059802549404, 0.6061015609614535, 0.6016192971689202, 0.12215067079788244, 0.11400157920915521, 0.1306091623317529, 0.12017813384565257, 0.13885021142724852, 0.12548306302287238, 0.12738106556838324, 0.12070000092306277, 0.15662761509075174, 0.13676879245608908, 0.2795002386171952, 0.2570928346418746, 0.22481391768428893, 0.19622611379731825, 0.22637763674948674, 0.17455574877067848, 0.21375624974474516, 0.2090544779322785, 0.4781188304898959, 0.4706852853225697, 0.3613414926455826, 0.5847708362194299, 0.3943568970780186, 0.3871403545525409, 0.5032323318182257, 0.517904805576054, 0.47639286825100824, 0.28371214123592015, 0.35243508182284444, 0.34154310500325646, 0.4791932320251987, 0.3731029313006833, 0.20295282003577564, 0.2395926267550582, 0.3778314242206092, 0.4242984725427531, 0.2058278302547354, 0.21398499699774698, 0.2101893998518053, 0.22885964144983495, 0.1987041452340853, 0.20213312129127303, 0.23661415061485536, 0.21837681408466036, 0.2152725528459395, 0.5955409461084353, 0.19908883297725766, 0.20096083779354645, 0.2105381681472952, 0.19509509921945756, 0.2271834293298841, 0.18958242052823848, 0.18734619629501703, 0.21117657825525116, 0.17091183269029497, 0.17146960123148713, 0.7982405561256902, 0.19086529341935887, 0.6880989932576556, 0.7898513216729918, 0.7446715279231841, 0.7976054554625447, 0.2080731308390853, 0.7836948902192584, 0.7529207216973023, 0.7241875514599532, 0.20055355024549326, 0.688634414191002, 0.7403679303605467, 0.20694068132047183, 0.7155006718783228, 0.1649845036455193, 0.20564488259111713, 0.21813352730676994, 0.21329997743853368, 0.19337149385289, 0.19315447584219492, 0.18885233377136568, 0.18294903348347014, 0.18717399207401675, 0.2355658498197687, 0.09224745515881883, 0.09594281848693431, 0.09367572787432288, 0.08905313280666394, 0.08992300156664257, 0.0846441214770357, 0.08557967919571097, 0.09119505560898056, 0.08864064900235391]}, "mutation_prompt": null}
{"id": "fa6e3d76-9b38-41a7-a678-5945782c397c", "solution": "import numpy as np\n\nclass ImprovedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with probabilistic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                if np.random.rand() < 0.7:  # Probabilistic selection of mutation strategy\n                    mutant = np.clip(a + np.random.uniform(0.5, 1.0) * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(global_best + np.random.uniform(0.5, 1.0) * (b - a), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Adjust learning rates adaptively\n            self.c1 = np.random.uniform(1.5, 2.5) * (1 - budget_used / self.budget)\n            self.c2 = np.random.uniform(1.0, 2.0) * (budget_used / self.budget)\n\n            # Memory-based inertia adjustment\n            historic_best = fitness.min()\n            self.w = 0.4 + 0.5 * (historic_best - fitness.mean()) / (historic_best + 1e-9)\n            self.w = np.clip(self.w, 0.1, 0.6)\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n            \n            # Adaptive population resizing\n            if budget_used / self.budget > 0.5:\n                self.pop_size = min(self.pop_size + 1, 100)\n\n        return global_best", "name": "ImprovedHybridDEPSO", "description": "ImprovedHybridDEPSO incorporates adaptive population resizing and enhanced boundary handling to improve convergence performance.", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 50 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 50 is out of bounds for axis 0 with size 50')", "parent_id": "a315cc62-4211-4c05-9b85-884aee96b2a0", "metadata": {}, "mutation_prompt": null}
{"id": "a1a635e1-c74d-4ce3-b63b-d28600bbe443", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with probabilistic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                if np.random.rand() < 0.7:  # Probabilistic selection of mutation strategy\n                    mutant = np.clip(a + np.random.uniform(0.5, 1.0) * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(global_best + np.random.uniform(0.5, 1.0) * (b - a), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Adjust learning rates adaptively\n            self.c1 = np.random.uniform(1.5, 2.5) * (1 - budget_used / self.budget)\n            self.c2 = np.random.uniform(1.0, 2.0) * (budget_used / self.budget)\n\n            # Memory-based inertia adjustment\n            historic_best = fitness.min()\n            self.w = 0.4 + 0.5 * (historic_best - fitness.mean()) / (historic_best + 1e-9)\n            self.w = np.clip(self.w, 0.1, 0.6)\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with a novel probabilistic mutation strategy and memory-based inertia to boost convergence.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a315cc62-4211-4c05-9b85-884aee96b2a0", "metadata": {"aucs": [0.8121739212131376, 0.8065504339741629, 0.808399126283219, 0.8268055411872113, 0.8186815464693457, 0.8156334146654408, 0.8220552149930658, 0.8124049249076453, 0.8032268113097001, 0.7046280867720519, 0.6797475460651222, 0.6689062809577883, 0.6910455401206312, 0.6850238268144604, 0.6877765437437522, 0.6887565143309139, 0.6663419762615517, 0.6855238815820668, 0.15246120122247864, 0.11683198159661823, 0.46391636675205805, 0.1425181536026634, 0.12020496710916795, 0.11476130132680251, 0.136090768698093, 0.14233109149753986, 0.13949966178337836, 0.13220181510018303, 0.0989961504989868, 0.12262834847665605, 0.09576847178152348, 0.1200934073934743, 0.10816318970047356, 0.12866360291139756, 0.11100495892402173, 0.12031800871830378, 0.9848280941692072, 0.9822096723588887, 0.9774313603946428, 0.9386843349351494, 0.9589911559124588, 0.967211790471227, 0.9787196364572956, 0.9761154648983643, 0.9647994043597012, 0.6785308116303539, 0.6413761774110052, 0.6738818445652499, 0.6416038301470284, 0.6575097141084004, 0.6680975859187039, 0.700167883351968, 0.6533078578283935, 0.7002097842438726, 0.788050754280684, 0.7794321633431516, 0.749582474564737, 0.8041958647379287, 0.7722436972554009, 0.7946624158953679, 0.767825407707804, 0.7610777605585773, 0.7739740594813861, 0.2569147037612117, 0.1226358436968239, 0.21890620088931656, 0.19546072592136765, 0.3509404156492355, 0.33361262046321416, 0.268451112673213, 0.24292966720000853, 0.29276638115666487, 0.12141452906815486, 0.2645288711804815, 0.19965935448102567, 0.28821731278731877, 0.26662269271967665, 0.24525035029122344, 0.24772400246786952, 0.381046377240579, 0.24655731166167338, 0.09575359082215074, 0.11062088086858035, 0.05356385546906117, 0.09598271889022802, 0.031038744428861342, 0.06779060465136011, 0.07257432756391313, 0.06127718672449989, 0.061224301975332684, 0.14141692224504387, 0.1523871382578159, 0.14887025814600352, 0.11983357237070691, 0.1319130198094577, 0.09906770218417427, 0.170864265392079, 0.16638895100904116, 0.1735677115134413, 0.14211442154789033, 0.06081954472944506, 0.09149390479355024, 0.08419039056049427, 0.2120793546633265, 0.12477713716235717, 0.10720914082520772, 0.08952722823789994, 0.1552473307456399, 0.1305200171584715, 0.2525567114997973, 0.19394581490364804, 0.18918399797529883, 0.20966865965238668, 0.18723689694118462, 0.20505474417297886, 0.1355889778927598, 0.1889124740224548, 0.5518676926251205, 0.5794095976198712, 0.5509254567617179, 0.6008500163484372, 0.5845106666896442, 0.5541974402289712, 0.54059802549404, 0.6061015609614535, 0.6016192971689202, 0.12215067079788244, 0.11400157920915521, 0.1306091623317529, 0.12017813384565257, 0.13885021142724852, 0.12548306302287238, 0.12738106556838324, 0.12070000092306277, 0.15662761509075174, 0.13676879245608908, 0.2795002386171952, 0.2570928346418746, 0.22481391768428893, 0.19622611379731825, 0.22637763674948674, 0.17455574877067848, 0.21375624974474516, 0.2090544779322785, 0.4781188304898959, 0.4706852853225697, 0.3613414926455826, 0.5847708362194299, 0.3943568970780186, 0.3871403545525409, 0.5032323318182257, 0.517904805576054, 0.47639286825100824, 0.28371214123592015, 0.35243508182284444, 0.34154310500325646, 0.4791932320251987, 0.3731029313006833, 0.20295282003577564, 0.2395926267550582, 0.3778314242206092, 0.4242984725427531, 0.2058278302547354, 0.21398499699774698, 0.2101893998518053, 0.22885964144983495, 0.1987041452340853, 0.20213312129127303, 0.23661415061485536, 0.21837681408466036, 0.2152725528459395, 0.5955409461084353, 0.19908883297725766, 0.20096083779354645, 0.2105381681472952, 0.19509509921945756, 0.2271834293298841, 0.18958242052823848, 0.18734619629501703, 0.21117657825525116, 0.17091183269029497, 0.17146960123148713, 0.7982405561256902, 0.19086529341935887, 0.6880989932576556, 0.7898513216729918, 0.7446715279231841, 0.7976054554625447, 0.2080731308390853, 0.7836948902192584, 0.7529207216973023, 0.7241875514599532, 0.20055355024549326, 0.688634414191002, 0.7403679303605467, 0.20694068132047183, 0.7155006718783228, 0.1649845036455193, 0.20564488259111713, 0.21813352730676994, 0.21329997743853368, 0.19337149385289, 0.19315447584219492, 0.18885233377136568, 0.18294903348347014, 0.18717399207401675, 0.2355658498197687, 0.09224745515881883, 0.09594281848693431, 0.09367572787432288, 0.08905313280666394, 0.08992300156664257, 0.0846441214770357, 0.08557967919571097, 0.09119505560898056, 0.08864064900235391]}, "mutation_prompt": null}
{"id": "cec423d5-928a-40dd-81de-497546055841", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with probabilistic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                if np.random.rand() < 0.7:  # Probabilistic selection of mutation strategy\n                    mutant = np.clip(a + np.random.uniform(0.5, 1.0) * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(global_best + np.random.uniform(0.5, 1.0) * (b - a), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Adjust learning rates adaptively\n            self.c1 = np.random.uniform(1.5, 2.5) * (1 - budget_used / self.budget)\n            self.c2 = np.random.uniform(1.0, 2.0) * (budget_used / self.budget)\n\n            # Memory-based inertia adjustment\n            historic_best = fitness.min()\n            self.w = 0.4 + 0.5 * (historic_best - fitness.mean()) / (historic_best + 1e-9)\n            self.w = np.clip(self.w, 0.1, 0.6)\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with a novel probabilistic mutation strategy and memory-based inertia to boost convergence.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a315cc62-4211-4c05-9b85-884aee96b2a0", "metadata": {"aucs": [0.8121739212131376, 0.8065504339741629, 0.808399126283219, 0.8268055411872113, 0.8186815464693457, 0.8156334146654408, 0.8220552149930658, 0.8124049249076453, 0.8032268113097001, 0.7046280867720519, 0.6797475460651222, 0.6689062809577883, 0.6910455401206312, 0.6850238268144604, 0.6877765437437522, 0.6887565143309139, 0.6663419762615517, 0.6855238815820668, 0.15246120122247864, 0.11683198159661823, 0.46391636675205805, 0.1425181536026634, 0.12020496710916795, 0.11476130132680251, 0.136090768698093, 0.14233109149753986, 0.13949966178337836, 0.13220181510018303, 0.0989961504989868, 0.12262834847665605, 0.09576847178152348, 0.1200934073934743, 0.10816318970047356, 0.12866360291139756, 0.11100495892402173, 0.12031800871830378, 0.9848280941692072, 0.9822096723588887, 0.9774313603946428, 0.9386843349351494, 0.9589911559124588, 0.967211790471227, 0.9787196364572956, 0.9761154648983643, 0.9647994043597012, 0.6785308116303539, 0.6413761774110052, 0.6738818445652499, 0.6416038301470284, 0.6575097141084004, 0.6680975859187039, 0.700167883351968, 0.6533078578283935, 0.7002097842438726, 0.788050754280684, 0.7794321633431516, 0.749582474564737, 0.8041958647379287, 0.7722436972554009, 0.7946624158953679, 0.767825407707804, 0.7610777605585773, 0.7739740594813861, 0.2569147037612117, 0.1226358436968239, 0.21890620088931656, 0.19546072592136765, 0.3509404156492355, 0.33361262046321416, 0.268451112673213, 0.24292966720000853, 0.29276638115666487, 0.12141452906815486, 0.2645288711804815, 0.19965935448102567, 0.28821731278731877, 0.26662269271967665, 0.24525035029122344, 0.24772400246786952, 0.381046377240579, 0.24655731166167338, 0.09575359082215074, 0.11062088086858035, 0.05356385546906117, 0.09598271889022802, 0.031038744428861342, 0.06779060465136011, 0.07257432756391313, 0.06127718672449989, 0.061224301975332684, 0.14141692224504387, 0.1523871382578159, 0.14887025814600352, 0.11983357237070691, 0.1319130198094577, 0.09906770218417427, 0.170864265392079, 0.16638895100904116, 0.1735677115134413, 0.14211442154789033, 0.06081954472944506, 0.09149390479355024, 0.08419039056049427, 0.2120793546633265, 0.12477713716235717, 0.10720914082520772, 0.08952722823789994, 0.1552473307456399, 0.1305200171584715, 0.2525567114997973, 0.19394581490364804, 0.18918399797529883, 0.20966865965238668, 0.18723689694118462, 0.20505474417297886, 0.1355889778927598, 0.1889124740224548, 0.5518676926251205, 0.5794095976198712, 0.5509254567617179, 0.6008500163484372, 0.5845106666896442, 0.5541974402289712, 0.54059802549404, 0.6061015609614535, 0.6016192971689202, 0.12215067079788244, 0.11400157920915521, 0.1306091623317529, 0.12017813384565257, 0.13885021142724852, 0.12548306302287238, 0.12738106556838324, 0.12070000092306277, 0.15662761509075174, 0.13676879245608908, 0.2795002386171952, 0.2570928346418746, 0.22481391768428893, 0.19622611379731825, 0.22637763674948674, 0.17455574877067848, 0.21375624974474516, 0.2090544779322785, 0.4781188304898959, 0.4706852853225697, 0.3613414926455826, 0.5847708362194299, 0.3943568970780186, 0.3871403545525409, 0.5032323318182257, 0.517904805576054, 0.47639286825100824, 0.28371214123592015, 0.35243508182284444, 0.34154310500325646, 0.4791932320251987, 0.3731029313006833, 0.20295282003577564, 0.2395926267550582, 0.3778314242206092, 0.4242984725427531, 0.2058278302547354, 0.21398499699774698, 0.2101893998518053, 0.22885964144983495, 0.1987041452340853, 0.20213312129127303, 0.23661415061485536, 0.21837681408466036, 0.2152725528459395, 0.5955409461084353, 0.19908883297725766, 0.20096083779354645, 0.2105381681472952, 0.19509509921945756, 0.2271834293298841, 0.18958242052823848, 0.18734619629501703, 0.21117657825525116, 0.17091183269029497, 0.17146960123148713, 0.7982405561256902, 0.19086529341935887, 0.6880989932576556, 0.7898513216729918, 0.7446715279231841, 0.7976054554625447, 0.2080731308390853, 0.7836948902192584, 0.7529207216973023, 0.7241875514599532, 0.20055355024549326, 0.688634414191002, 0.7403679303605467, 0.20694068132047183, 0.7155006718783228, 0.1649845036455193, 0.20564488259111713, 0.21813352730676994, 0.21329997743853368, 0.19337149385289, 0.19315447584219492, 0.18885233377136568, 0.18294903348347014, 0.18717399207401675, 0.2355658498197687, 0.09224745515881883, 0.09594281848693431, 0.09367572787432288, 0.08905313280666394, 0.08992300156664257, 0.0846441214770357, 0.08557967919571097, 0.09119505560898056, 0.08864064900235391]}, "mutation_prompt": null}
{"id": "9efd617f-c169-4c63-a4a4-593f4bc3130d", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with probabilistic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                if np.random.rand() < 0.7:  # Probabilistic selection of mutation strategy\n                    mutant = np.clip(a + np.random.uniform(0.5, 1.0) * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(global_best + np.random.uniform(0.5, 1.0) * (b - a), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Adjust learning rates adaptively\n            self.c1 = np.random.uniform(1.5, 2.5) * (1 - budget_used / self.budget)\n            self.c2 = np.random.uniform(1.0, 2.0) * (budget_used / self.budget)\n\n            # Memory-based inertia adjustment\n            historic_best = fitness.min()\n            self.w = 0.4 + 0.5 * (historic_best - fitness.mean()) / (historic_best + 1e-9)\n            self.w = np.clip(self.w, 0.1, 0.6)\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with a novel probabilistic mutation strategy and memory-based inertia to boost convergence.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a315cc62-4211-4c05-9b85-884aee96b2a0", "metadata": {"aucs": [0.8121739212131376, 0.8065504339741629, 0.808399126283219, 0.8268055411872113, 0.8186815464693457, 0.8156334146654408, 0.8220552149930658, 0.8124049249076453, 0.8032268113097001, 0.7046280867720519, 0.6797475460651222, 0.6689062809577883, 0.6910455401206312, 0.6850238268144604, 0.6877765437437522, 0.6887565143309139, 0.6663419762615517, 0.6855238815820668, 0.15246120122247864, 0.11683198159661823, 0.46391636675205805, 0.1425181536026634, 0.12020496710916795, 0.11476130132680251, 0.136090768698093, 0.14233109149753986, 0.13949966178337836, 0.13220181510018303, 0.0989961504989868, 0.12262834847665605, 0.09576847178152348, 0.1200934073934743, 0.10816318970047356, 0.12866360291139756, 0.11100495892402173, 0.12031800871830378, 0.9848280941692072, 0.9822096723588887, 0.9774313603946428, 0.9386843349351494, 0.9589911559124588, 0.967211790471227, 0.9787196364572956, 0.9761154648983643, 0.9647994043597012, 0.6785308116303539, 0.6413761774110052, 0.6738818445652499, 0.6416038301470284, 0.6575097141084004, 0.6680975859187039, 0.700167883351968, 0.6533078578283935, 0.7002097842438726, 0.788050754280684, 0.7794321633431516, 0.749582474564737, 0.8041958647379287, 0.7722436972554009, 0.7946624158953679, 0.767825407707804, 0.7610777605585773, 0.7739740594813861, 0.2569147037612117, 0.1226358436968239, 0.21890620088931656, 0.19546072592136765, 0.3509404156492355, 0.33361262046321416, 0.268451112673213, 0.24292966720000853, 0.29276638115666487, 0.12141452906815486, 0.2645288711804815, 0.19965935448102567, 0.28821731278731877, 0.26662269271967665, 0.24525035029122344, 0.24772400246786952, 0.381046377240579, 0.24655731166167338, 0.09575359082215074, 0.11062088086858035, 0.05356385546906117, 0.09598271889022802, 0.031038744428861342, 0.06779060465136011, 0.07257432756391313, 0.06127718672449989, 0.061224301975332684, 0.14141692224504387, 0.1523871382578159, 0.14887025814600352, 0.11983357237070691, 0.1319130198094577, 0.09906770218417427, 0.170864265392079, 0.16638895100904116, 0.1735677115134413, 0.14211442154789033, 0.06081954472944506, 0.09149390479355024, 0.08419039056049427, 0.2120793546633265, 0.12477713716235717, 0.10720914082520772, 0.08952722823789994, 0.1552473307456399, 0.1305200171584715, 0.2525567114997973, 0.19394581490364804, 0.18918399797529883, 0.20966865965238668, 0.18723689694118462, 0.20505474417297886, 0.1355889778927598, 0.1889124740224548, 0.5518676926251205, 0.5794095976198712, 0.5509254567617179, 0.6008500163484372, 0.5845106666896442, 0.5541974402289712, 0.54059802549404, 0.6061015609614535, 0.6016192971689202, 0.12215067079788244, 0.11400157920915521, 0.1306091623317529, 0.12017813384565257, 0.13885021142724852, 0.12548306302287238, 0.12738106556838324, 0.12070000092306277, 0.15662761509075174, 0.13676879245608908, 0.2795002386171952, 0.2570928346418746, 0.22481391768428893, 0.19622611379731825, 0.22637763674948674, 0.17455574877067848, 0.21375624974474516, 0.2090544779322785, 0.4781188304898959, 0.4706852853225697, 0.3613414926455826, 0.5847708362194299, 0.3943568970780186, 0.3871403545525409, 0.5032323318182257, 0.517904805576054, 0.47639286825100824, 0.28371214123592015, 0.35243508182284444, 0.34154310500325646, 0.4791932320251987, 0.3731029313006833, 0.20295282003577564, 0.2395926267550582, 0.3778314242206092, 0.4242984725427531, 0.2058278302547354, 0.21398499699774698, 0.2101893998518053, 0.22885964144983495, 0.1987041452340853, 0.20213312129127303, 0.23661415061485536, 0.21837681408466036, 0.2152725528459395, 0.5955409461084353, 0.19908883297725766, 0.20096083779354645, 0.2105381681472952, 0.19509509921945756, 0.2271834293298841, 0.18958242052823848, 0.18734619629501703, 0.21117657825525116, 0.17091183269029497, 0.17146960123148713, 0.7982405561256902, 0.19086529341935887, 0.6880989932576556, 0.7898513216729918, 0.7446715279231841, 0.7976054554625447, 0.2080731308390853, 0.7836948902192584, 0.7529207216973023, 0.7241875514599532, 0.20055355024549326, 0.688634414191002, 0.7403679303605467, 0.20694068132047183, 0.7155006718783228, 0.1649845036455193, 0.20564488259111713, 0.21813352730676994, 0.21329997743853368, 0.19337149385289, 0.19315447584219492, 0.18885233377136568, 0.18294903348347014, 0.18717399207401675, 0.2355658498197687, 0.09224745515881883, 0.09594281848693431, 0.09367572787432288, 0.08905313280666394, 0.08992300156664257, 0.0846441214770357, 0.08557967919571097, 0.09119505560898056, 0.08864064900235391]}, "mutation_prompt": null}
{"id": "acb435af-305b-461c-be98-6b5663b2c7d7", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with probabilistic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                if np.random.rand() < 0.7:  # Probabilistic selection of mutation strategy\n                    mutant = np.clip(a + np.random.uniform(0.5, 1.0) * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(global_best + np.random.uniform(0.5, 1.0) * (b - a), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Adjust learning rates adaptively\n            self.c1 = np.random.uniform(1.5, 2.5) * (1 - budget_used / self.budget)\n            self.c2 = np.random.uniform(1.0, 2.0) * (budget_used / self.budget)\n\n            # Memory-based inertia adjustment\n            historic_best = fitness.min()\n            self.w = 0.4 + 0.5 * (historic_best - fitness.mean()) / (historic_best + 1e-9)\n            self.w = np.clip(self.w, 0.1, 0.6)\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with a novel probabilistic mutation strategy and memory-based inertia to boost convergence.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a315cc62-4211-4c05-9b85-884aee96b2a0", "metadata": {"aucs": [0.8121739212131376, 0.8065504339741629, 0.808399126283219, 0.8268055411872113, 0.8186815464693457, 0.8156334146654408, 0.8220552149930658, 0.8124049249076453, 0.8032268113097001, 0.7046280867720519, 0.6797475460651222, 0.6689062809577883, 0.6910455401206312, 0.6850238268144604, 0.6877765437437522, 0.6887565143309139, 0.6663419762615517, 0.6855238815820668, 0.15246120122247864, 0.11683198159661823, 0.46391636675205805, 0.1425181536026634, 0.12020496710916795, 0.11476130132680251, 0.136090768698093, 0.14233109149753986, 0.13949966178337836, 0.13220181510018303, 0.0989961504989868, 0.12262834847665605, 0.09576847178152348, 0.1200934073934743, 0.10816318970047356, 0.12866360291139756, 0.11100495892402173, 0.12031800871830378, 0.9848280941692072, 0.9822096723588887, 0.9774313603946428, 0.9386843349351494, 0.9589911559124588, 0.967211790471227, 0.9787196364572956, 0.9761154648983643, 0.9647994043597012, 0.6785308116303539, 0.6413761774110052, 0.6738818445652499, 0.6416038301470284, 0.6575097141084004, 0.6680975859187039, 0.700167883351968, 0.6533078578283935, 0.7002097842438726, 0.788050754280684, 0.7794321633431516, 0.749582474564737, 0.8041958647379287, 0.7722436972554009, 0.7946624158953679, 0.767825407707804, 0.7610777605585773, 0.7739740594813861, 0.2569147037612117, 0.1226358436968239, 0.21890620088931656, 0.19546072592136765, 0.3509404156492355, 0.33361262046321416, 0.268451112673213, 0.24292966720000853, 0.29276638115666487, 0.12141452906815486, 0.2645288711804815, 0.19965935448102567, 0.28821731278731877, 0.26662269271967665, 0.24525035029122344, 0.24772400246786952, 0.381046377240579, 0.24655731166167338, 0.09575359082215074, 0.11062088086858035, 0.05356385546906117, 0.09598271889022802, 0.031038744428861342, 0.06779060465136011, 0.07257432756391313, 0.06127718672449989, 0.061224301975332684, 0.14141692224504387, 0.1523871382578159, 0.14887025814600352, 0.11983357237070691, 0.1319130198094577, 0.09906770218417427, 0.170864265392079, 0.16638895100904116, 0.1735677115134413, 0.14211442154789033, 0.06081954472944506, 0.09149390479355024, 0.08419039056049427, 0.2120793546633265, 0.12477713716235717, 0.10720914082520772, 0.08952722823789994, 0.1552473307456399, 0.1305200171584715, 0.2525567114997973, 0.19394581490364804, 0.18918399797529883, 0.20966865965238668, 0.18723689694118462, 0.20505474417297886, 0.1355889778927598, 0.1889124740224548, 0.5518676926251205, 0.5794095976198712, 0.5509254567617179, 0.6008500163484372, 0.5845106666896442, 0.5541974402289712, 0.54059802549404, 0.6061015609614535, 0.6016192971689202, 0.12215067079788244, 0.11400157920915521, 0.1306091623317529, 0.12017813384565257, 0.13885021142724852, 0.12548306302287238, 0.12738106556838324, 0.12070000092306277, 0.15662761509075174, 0.13676879245608908, 0.2795002386171952, 0.2570928346418746, 0.22481391768428893, 0.19622611379731825, 0.22637763674948674, 0.17455574877067848, 0.21375624974474516, 0.2090544779322785, 0.4781188304898959, 0.4706852853225697, 0.3613414926455826, 0.5847708362194299, 0.3943568970780186, 0.3871403545525409, 0.5032323318182257, 0.517904805576054, 0.47639286825100824, 0.28371214123592015, 0.35243508182284444, 0.34154310500325646, 0.4791932320251987, 0.3731029313006833, 0.20295282003577564, 0.2395926267550582, 0.3778314242206092, 0.4242984725427531, 0.2058278302547354, 0.21398499699774698, 0.2101893998518053, 0.22885964144983495, 0.1987041452340853, 0.20213312129127303, 0.23661415061485536, 0.21837681408466036, 0.2152725528459395, 0.5955409461084353, 0.19908883297725766, 0.20096083779354645, 0.2105381681472952, 0.19509509921945756, 0.2271834293298841, 0.18958242052823848, 0.18734619629501703, 0.21117657825525116, 0.17091183269029497, 0.17146960123148713, 0.7982405561256902, 0.19086529341935887, 0.6880989932576556, 0.7898513216729918, 0.7446715279231841, 0.7976054554625447, 0.2080731308390853, 0.7836948902192584, 0.7529207216973023, 0.7241875514599532, 0.20055355024549326, 0.688634414191002, 0.7403679303605467, 0.20694068132047183, 0.7155006718783228, 0.1649845036455193, 0.20564488259111713, 0.21813352730676994, 0.21329997743853368, 0.19337149385289, 0.19315447584219492, 0.18885233377136568, 0.18294903348347014, 0.18717399207401675, 0.2355658498197687, 0.09224745515881883, 0.09594281848693431, 0.09367572787432288, 0.08905313280666394, 0.08992300156664257, 0.0846441214770357, 0.08557967919571097, 0.09119505560898056, 0.08864064900235391]}, "mutation_prompt": null}
{"id": "e797bd7d-d420-4fcb-bb2b-ab623628425e", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(50, max(10, budget // (8 * dim)))\n        self.f = 0.5  # Reduced DE scaling factor\n        self.cr = 0.9\n        self.w = np.random.uniform(0.3, 0.6)  # Adaptive inertia weight range\n        self.c1 = np.random.uniform(1.5, 2.5)  # Adaptive cognitive coefficient\n        self.c2 = np.random.uniform(1.0, 2.0)  # Adaptive social coefficient\n        self.v_max = (self.upper_bound - self.lower_bound) / 5.0  # Max velocity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-self.v_max, self.v_max, (self.pop_size, self.dim))  # Initialize velocities\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.pop_size\n\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        while budget_used < self.budget:\n            # Differential Evolution with probabilistic mutation\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                if np.random.rand() < 0.7:  # Probabilistic selection of mutation strategy\n                    mutant = np.clip(a + np.random.uniform(0.5, 1.0) * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(global_best + np.random.uniform(0.5, 1.0) * (b - a), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < personal_best_fitness[global_best_idx]:\n                            global_best = trial\n                            global_best_idx = i\n\n            # Adjust learning rates adaptively\n            self.c1 = np.random.uniform(1.5, 2.5) * (1 - budget_used / self.budget)\n            self.c2 = np.random.uniform(1.0, 2.0) * (budget_used / self.budget)\n\n            # Memory-based inertia adjustment\n            historic_best = fitness.min()\n            self.w = 0.4 + 0.5 * (historic_best - fitness.mean()) / (historic_best + 1e-9)\n            self.w = np.clip(self.w, 0.1, 0.6)\n\n            # Particle Swarm Optimization\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocities = np.clip(\n                self.w * velocities \n                + self.c1 * r1 * (personal_best - population) \n                + self.c2 * r2 * (global_best - population),\n                -self.v_max, self.v_max\n            )  # Velocity clamping\n            population = np.clip(population + velocities, self.lower_bound, self.upper_bound)\n            for i in range(self.pop_size):\n                if budget_used >= self.budget:\n                    break\n                new_fitness = func(population[i])\n                budget_used += 1\n                if new_fitness < fitness[i]:\n                    fitness[i] = new_fitness\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = new_fitness\n                    if new_fitness < personal_best_fitness[global_best_idx]:\n                        global_best = population[i]\n                        global_best_idx = i\n\n        return global_best", "name": "EnhancedHybridDEPSO", "description": "EnhancedHybridDEPSO with a novel probabilistic mutation strategy and memory-based inertia to boost convergence.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a315cc62-4211-4c05-9b85-884aee96b2a0", "metadata": {"aucs": [0.8121739212131376, 0.8065504339741629, 0.808399126283219, 0.8268055411872113, 0.8186815464693457, 0.8156334146654408, 0.8220552149930658, 0.8124049249076453, 0.8032268113097001, 0.7046280867720519, 0.6797475460651222, 0.6689062809577883, 0.6910455401206312, 0.6850238268144604, 0.6877765437437522, 0.6887565143309139, 0.6663419762615517, 0.6855238815820668, 0.15246120122247864, 0.11683198159661823, 0.46391636675205805, 0.1425181536026634, 0.12020496710916795, 0.11476130132680251, 0.136090768698093, 0.14233109149753986, 0.13949966178337836, 0.13220181510018303, 0.0989961504989868, 0.12262834847665605, 0.09576847178152348, 0.1200934073934743, 0.10816318970047356, 0.12866360291139756, 0.11100495892402173, 0.12031800871830378, 0.9848280941692072, 0.9822096723588887, 0.9774313603946428, 0.9386843349351494, 0.9589911559124588, 0.967211790471227, 0.9787196364572956, 0.9761154648983643, 0.9647994043597012, 0.6785308116303539, 0.6413761774110052, 0.6738818445652499, 0.6416038301470284, 0.6575097141084004, 0.6680975859187039, 0.700167883351968, 0.6533078578283935, 0.7002097842438726, 0.788050754280684, 0.7794321633431516, 0.749582474564737, 0.8041958647379287, 0.7722436972554009, 0.7946624158953679, 0.767825407707804, 0.7610777605585773, 0.7739740594813861, 0.2569147037612117, 0.1226358436968239, 0.21890620088931656, 0.19546072592136765, 0.3509404156492355, 0.33361262046321416, 0.268451112673213, 0.24292966720000853, 0.29276638115666487, 0.12141452906815486, 0.2645288711804815, 0.19965935448102567, 0.28821731278731877, 0.26662269271967665, 0.24525035029122344, 0.24772400246786952, 0.381046377240579, 0.24655731166167338, 0.09575359082215074, 0.11062088086858035, 0.05356385546906117, 0.09598271889022802, 0.031038744428861342, 0.06779060465136011, 0.07257432756391313, 0.06127718672449989, 0.061224301975332684, 0.14141692224504387, 0.1523871382578159, 0.14887025814600352, 0.11983357237070691, 0.1319130198094577, 0.09906770218417427, 0.170864265392079, 0.16638895100904116, 0.1735677115134413, 0.14211442154789033, 0.06081954472944506, 0.09149390479355024, 0.08419039056049427, 0.2120793546633265, 0.12477713716235717, 0.10720914082520772, 0.08952722823789994, 0.1552473307456399, 0.1305200171584715, 0.2525567114997973, 0.19394581490364804, 0.18918399797529883, 0.20966865965238668, 0.18723689694118462, 0.20505474417297886, 0.1355889778927598, 0.1889124740224548, 0.5518676926251205, 0.5794095976198712, 0.5509254567617179, 0.6008500163484372, 0.5845106666896442, 0.5541974402289712, 0.54059802549404, 0.6061015609614535, 0.6016192971689202, 0.12215067079788244, 0.11400157920915521, 0.1306091623317529, 0.12017813384565257, 0.13885021142724852, 0.12548306302287238, 0.12738106556838324, 0.12070000092306277, 0.15662761509075174, 0.13676879245608908, 0.2795002386171952, 0.2570928346418746, 0.22481391768428893, 0.19622611379731825, 0.22637763674948674, 0.17455574877067848, 0.21375624974474516, 0.2090544779322785, 0.4781188304898959, 0.4706852853225697, 0.3613414926455826, 0.5847708362194299, 0.3943568970780186, 0.3871403545525409, 0.5032323318182257, 0.517904805576054, 0.47639286825100824, 0.28371214123592015, 0.35243508182284444, 0.34154310500325646, 0.4791932320251987, 0.3731029313006833, 0.20295282003577564, 0.2395926267550582, 0.3778314242206092, 0.4242984725427531, 0.2058278302547354, 0.21398499699774698, 0.2101893998518053, 0.22885964144983495, 0.1987041452340853, 0.20213312129127303, 0.23661415061485536, 0.21837681408466036, 0.2152725528459395, 0.5955409461084353, 0.19908883297725766, 0.20096083779354645, 0.2105381681472952, 0.19509509921945756, 0.2271834293298841, 0.18958242052823848, 0.18734619629501703, 0.21117657825525116, 0.17091183269029497, 0.17146960123148713, 0.7982405561256902, 0.19086529341935887, 0.6880989932576556, 0.7898513216729918, 0.7446715279231841, 0.7976054554625447, 0.2080731308390853, 0.7836948902192584, 0.7529207216973023, 0.7241875514599532, 0.20055355024549326, 0.688634414191002, 0.7403679303605467, 0.20694068132047183, 0.7155006718783228, 0.1649845036455193, 0.20564488259111713, 0.21813352730676994, 0.21329997743853368, 0.19337149385289, 0.19315447584219492, 0.18885233377136568, 0.18294903348347014, 0.18717399207401675, 0.2355658498197687, 0.09224745515881883, 0.09594281848693431, 0.09367572787432288, 0.08905313280666394, 0.08992300156664257, 0.0846441214770357, 0.08557967919571097, 0.09119505560898056, 0.08864064900235391]}, "mutation_prompt": null}
