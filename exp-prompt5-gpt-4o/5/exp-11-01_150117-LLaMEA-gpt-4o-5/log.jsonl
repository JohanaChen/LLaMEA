{"id": "9675a700-84af-4acc-8bee-d1e8d6dfc6f0", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                mutant_vector = clip(a + self.mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                pop_velocity[i] = (self.inertia_weight * pop_velocity[i] +\n                                   self.cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   self.social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n        return global_best", "name": "HybridDEPSO", "description": "A hybrid algorithm combining Differential Evolution and Particle Swarm Optimization to adaptively explore and exploit the search space.", "configspace": "", "generation": 0, "fitness": 0.2153626456248827, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": null, "metadata": {"aucs": [0.49359690897353903, 0.423466647821918, 0.4904313076973955, 0.5399445428692773, 0.181594438735444, 0.529907115832577, 0.4788543557496733, 0.3889281815872391, 0.4748108764457787, 0.02462703992727422, 0.15632238845618918, 0.03464988852114714, 0.17537783812313423, 0.11873286752427781, 9.999999999998899e-05, 0.02872069595970328, 0.14561497385933075, 0.07664895355952017, 0.10058861183172507, 0.1172712969484131, 0.13831394931871943, 0.11008231197992713, 0.12037468289044317, 0.09941870897605276, 0.11444650213441432, 0.12745155766209226, 0.11805211050030939, 0.08907696505693763, 0.12528650322015278, 0.09379441325408988, 0.10217643341766858, 0.0995072949560406, 0.1027182346111869, 0.08928291750501449, 0.10404105573499178, 0.08623011214588228, 0.9850242586520188, 0.9889053672630709, 0.9825441153344384, 0.989009954630518, 0.984639251900144, 0.9833619857748379, 0.9844257217934012, 0.9851662466072517, 0.9841836724688188, 0.20508200393579534, 0.29532048169588354, 0.26394828900444467, 0.1473018441123679, 0.14274199737759863, 0.3072522118090365, 0.301415091776734, 0.24700967502833648, 0.22001021029603574, 0.2751934108746865, 0.2239009182858861, 0.28191354305300287, 0.29480063692474223, 0.2636902962625781, 0.32003930538491776, 0.36295339310793073, 0.4783232155670335, 0.16822656790983292, 0.12212208462625762, 0.15420694056443884, 0.13132188537498335, 0.1492855596941638, 0.08034728360681509, 0.09283803745749797, 0.13432827192961072, 0.12670592883296028, 0.13601137008629471, 0.21852471482334246, 0.11795966991759721, 0.14314434645059193, 0.12915941110321016, 0.09837774599939453, 0.17698393132810342, 0.14082205554179872, 0.1377512124485455, 0.14963818404117224, 9.999999999998899e-05, 9.999999999998899e-05, 0.025679629912407242, 0.00023106227350022657, 9.999999999998899e-05, 9.999999999998899e-05, 0.020205971920513544, 9.999999999998899e-05, 0.029672305878390537, 0.05666779566052593, 0.05435507349957658, 0.13389423748597395, 0.07485807618064777, 0.01251998982726732, 0.046875117470099426, 0.0682728954716002, 0.011951757576963762, 0.027769333062774404, 0.014924198173002168, 9.999999999998899e-05, 0.025947114750569877, 0.03656732463764334, 0.013899325930192052, 0.020705009495106008, 0.04434114109576914, 0.03114890673165105, 0.008597185468196433, 0.10348852776275597, 0.09663048178510292, 0.0273733543219572, 0.09034171693068604, 0.11195355856037836, 0.049021305747247945, 0.1399110936136434, 0.06989657907814706, 0.06552145585724667, 0.3867707978746173, 0.40549252895553134, 0.4101238962448125, 0.4449072546816384, 0.42302075044992526, 0.45706211937681995, 0.4201320344348456, 0.3790346296689432, 0.4210133590039077, 0.0964287319961713, 0.08718890537426482, 0.06396283006104297, 0.12471530061681768, 0.1093430827109505, 0.10397156841283373, 0.1324611977245822, 0.09837566511143159, 0.12606387841069178, 0.17225872628203565, 0.17460509784458922, 0.16937627054594118, 0.23519864592519601, 0.24000644940898264, 0.17973697907126263, 0.1912533005280529, 0.27393912464833126, 0.14858299720344126, 0.32385442316068747, 0.27320177474758134, 0.26171061447416555, 0.2897102777665186, 0.2300796351994352, 0.24563374630205415, 0.27241304679918843, 0.35265940349160896, 0.24445540340727823, 0.18446108336443034, 0.20563716062116977, 0.18990090961221273, 0.17573361237181195, 0.2055686497605982, 0.2016353962573647, 0.21933938740285375, 0.2500980544393747, 0.2167680090213795, 0.2500038803883573, 0.1992979006892831, 0.17428604845809026, 0.17095921565812844, 0.24230605202390176, 0.1939121215409355, 0.19415218811150248, 0.21254590599228163, 0.19506933467561183, 0.19558184170843274, 0.1896940817527628, 0.18778847816105393, 0.22331742585792957, 0.18342713512167697, 0.2470013296181589, 0.17604438088349417, 0.1922603644288854, 0.2007701389469273, 0.16269320190791237, 0.13880822818263427, 0.1512659200820804, 0.6502334570710687, 0.19770129845749418, 0.4819760050301771, 0.1909589317080037, 0.16680127103989817, 0.19570148142426314, 0.5596323868807596, 0.20477624058432842, 0.394728621530151, 0.19690125815315318, 0.4117818133844334, 0.14663427201744472, 0.20376777858180228, 0.3694822765293512, 0.4336102872675538, 0.18845789212321074, 0.18380627489468215, 0.18467371373657793, 0.18919213306199467, 0.20330887456581326, 0.187627098389755, 0.19891205405676404, 0.19895435476633017, 0.20787517022841817, 0.08444540334443851, 0.07360515094260422, 0.08146682850503528, 0.08239152008805017, 0.08035127641452633, 0.1068446949564602, 0.090634878135599, 0.07147503552895684, 0.0803733260130135]}, "mutation_prompt": null}
{"id": "d0c3df90-ad1a-4b46-b993-2326dd4d8af1", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                mutant_vector = clip(a + self.mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                pop_velocity[i] = (self.inertia_weight * pop_velocity[i] +\n                                   self.cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   self.social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n        return global_best", "name": "HybridDEPSO", "description": "A hybrid algorithm combining Differential Evolution and Particle Swarm Optimization to adaptively explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9675a700-84af-4acc-8bee-d1e8d6dfc6f0", "metadata": {"aucs": [0.49359690897353903, 0.423466647821918, 0.4904313076973955, 0.5399445428692773, 0.181594438735444, 0.529907115832577, 0.4788543557496733, 0.3889281815872391, 0.4748108764457787, 0.02462703992727422, 0.15632238845618918, 0.03464988852114714, 0.17537783812313423, 0.11873286752427781, 9.999999999998899e-05, 0.02872069595970328, 0.14561497385933075, 0.07664895355952017, 0.10058861183172507, 0.1172712969484131, 0.13831394931871943, 0.11008231197992713, 0.12037468289044317, 0.09941870897605276, 0.11444650213441432, 0.12745155766209226, 0.11805211050030939, 0.08907696505693763, 0.12528650322015278, 0.09379441325408988, 0.10217643341766858, 0.0995072949560406, 0.1027182346111869, 0.08928291750501449, 0.10404105573499178, 0.08623011214588228, 0.9850242586520188, 0.9889053672630709, 0.9825441153344384, 0.989009954630518, 0.984639251900144, 0.9833619857748379, 0.9844257217934012, 0.9851662466072517, 0.9841836724688188, 0.20508200393579534, 0.29532048169588354, 0.26394828900444467, 0.1473018441123679, 0.14274199737759863, 0.3072522118090365, 0.301415091776734, 0.24700967502833648, 0.22001021029603574, 0.2751934108746865, 0.2239009182858861, 0.28191354305300287, 0.29480063692474223, 0.2636902962625781, 0.32003930538491776, 0.36295339310793073, 0.4783232155670335, 0.16822656790983292, 0.12212208462625762, 0.15420694056443884, 0.13132188537498335, 0.1492855596941638, 0.08034728360681509, 0.09283803745749797, 0.13432827192961072, 0.12670592883296028, 0.13601137008629471, 0.21852471482334246, 0.11795966991759721, 0.14314434645059193, 0.12915941110321016, 0.09837774599939453, 0.17698393132810342, 0.14082205554179872, 0.1377512124485455, 0.14963818404117224, 9.999999999998899e-05, 9.999999999998899e-05, 0.025679629912407242, 0.00023106227350022657, 9.999999999998899e-05, 9.999999999998899e-05, 0.020205971920513544, 9.999999999998899e-05, 0.029672305878390537, 0.05666779566052593, 0.05435507349957658, 0.13389423748597395, 0.07485807618064777, 0.01251998982726732, 0.046875117470099426, 0.0682728954716002, 0.011951757576963762, 0.027769333062774404, 0.014924198173002168, 9.999999999998899e-05, 0.025947114750569877, 0.03656732463764334, 0.013899325930192052, 0.020705009495106008, 0.04434114109576914, 0.03114890673165105, 0.008597185468196433, 0.10348852776275597, 0.09663048178510292, 0.0273733543219572, 0.09034171693068604, 0.11195355856037836, 0.049021305747247945, 0.1399110936136434, 0.06989657907814706, 0.06552145585724667, 0.3867707978746173, 0.40549252895553134, 0.4101238962448125, 0.4449072546816384, 0.42302075044992526, 0.45706211937681995, 0.4201320344348456, 0.3790346296689432, 0.4210133590039077, 0.0964287319961713, 0.08718890537426482, 0.06396283006104297, 0.12471530061681768, 0.1093430827109505, 0.10397156841283373, 0.1324611977245822, 0.09837566511143159, 0.12606387841069178, 0.17225872628203565, 0.17460509784458922, 0.16937627054594118, 0.23519864592519601, 0.24000644940898264, 0.17973697907126263, 0.1912533005280529, 0.27393912464833126, 0.14858299720344126, 0.32385442316068747, 0.27320177474758134, 0.26171061447416555, 0.2897102777665186, 0.2300796351994352, 0.24563374630205415, 0.27241304679918843, 0.35265940349160896, 0.24445540340727823, 0.18446108336443034, 0.20563716062116977, 0.18990090961221273, 0.17573361237181195, 0.2055686497605982, 0.2016353962573647, 0.21933938740285375, 0.2500980544393747, 0.2167680090213795, 0.2500038803883573, 0.1992979006892831, 0.17428604845809026, 0.17095921565812844, 0.24230605202390176, 0.1939121215409355, 0.19415218811150248, 0.21254590599228163, 0.19506933467561183, 0.19558184170843274, 0.1896940817527628, 0.18778847816105393, 0.22331742585792957, 0.18342713512167697, 0.2470013296181589, 0.17604438088349417, 0.1922603644288854, 0.2007701389469273, 0.16269320190791237, 0.13880822818263427, 0.1512659200820804, 0.6502334570710687, 0.19770129845749418, 0.4819760050301771, 0.1909589317080037, 0.16680127103989817, 0.19570148142426314, 0.5596323868807596, 0.20477624058432842, 0.394728621530151, 0.19690125815315318, 0.4117818133844334, 0.14663427201744472, 0.20376777858180228, 0.3694822765293512, 0.4336102872675538, 0.18845789212321074, 0.18380627489468215, 0.18467371373657793, 0.18919213306199467, 0.20330887456581326, 0.187627098389755, 0.19891205405676404, 0.19895435476633017, 0.20787517022841817, 0.08444540334443851, 0.07360515094260422, 0.08146682850503528, 0.08239152008805017, 0.08035127641452633, 0.1068446949564602, 0.090634878135599, 0.07147503552895684, 0.0803733260130135]}, "mutation_prompt": null}
{"id": "2bef7b07-5dfe-4ecc-8f0f-e5c16179b238", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                mutant_vector = clip(a + self.mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                pop_velocity[i] = (self.inertia_weight * pop_velocity[i] +\n                                   self.cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   self.social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n        return global_best", "name": "HybridDEPSO", "description": "A hybrid algorithm combining Differential Evolution and Particle Swarm Optimization to adaptively explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9675a700-84af-4acc-8bee-d1e8d6dfc6f0", "metadata": {"aucs": [0.49359690897353903, 0.423466647821918, 0.4904313076973955, 0.5399445428692773, 0.181594438735444, 0.529907115832577, 0.4788543557496733, 0.3889281815872391, 0.4748108764457787, 0.02462703992727422, 0.15632238845618918, 0.03464988852114714, 0.17537783812313423, 0.11873286752427781, 9.999999999998899e-05, 0.02872069595970328, 0.14561497385933075, 0.07664895355952017, 0.10058861183172507, 0.1172712969484131, 0.13831394931871943, 0.11008231197992713, 0.12037468289044317, 0.09941870897605276, 0.11444650213441432, 0.12745155766209226, 0.11805211050030939, 0.08907696505693763, 0.12528650322015278, 0.09379441325408988, 0.10217643341766858, 0.0995072949560406, 0.1027182346111869, 0.08928291750501449, 0.10404105573499178, 0.08623011214588228, 0.9850242586520188, 0.9889053672630709, 0.9825441153344384, 0.989009954630518, 0.984639251900144, 0.9833619857748379, 0.9844257217934012, 0.9851662466072517, 0.9841836724688188, 0.20508200393579534, 0.29532048169588354, 0.26394828900444467, 0.1473018441123679, 0.14274199737759863, 0.3072522118090365, 0.301415091776734, 0.24700967502833648, 0.22001021029603574, 0.2751934108746865, 0.2239009182858861, 0.28191354305300287, 0.29480063692474223, 0.2636902962625781, 0.32003930538491776, 0.36295339310793073, 0.4783232155670335, 0.16822656790983292, 0.12212208462625762, 0.15420694056443884, 0.13132188537498335, 0.1492855596941638, 0.08034728360681509, 0.09283803745749797, 0.13432827192961072, 0.12670592883296028, 0.13601137008629471, 0.21852471482334246, 0.11795966991759721, 0.14314434645059193, 0.12915941110321016, 0.09837774599939453, 0.17698393132810342, 0.14082205554179872, 0.1377512124485455, 0.14963818404117224, 9.999999999998899e-05, 9.999999999998899e-05, 0.025679629912407242, 0.00023106227350022657, 9.999999999998899e-05, 9.999999999998899e-05, 0.020205971920513544, 9.999999999998899e-05, 0.029672305878390537, 0.05666779566052593, 0.05435507349957658, 0.13389423748597395, 0.07485807618064777, 0.01251998982726732, 0.046875117470099426, 0.0682728954716002, 0.011951757576963762, 0.027769333062774404, 0.014924198173002168, 9.999999999998899e-05, 0.025947114750569877, 0.03656732463764334, 0.013899325930192052, 0.020705009495106008, 0.04434114109576914, 0.03114890673165105, 0.008597185468196433, 0.10348852776275597, 0.09663048178510292, 0.0273733543219572, 0.09034171693068604, 0.11195355856037836, 0.049021305747247945, 0.1399110936136434, 0.06989657907814706, 0.06552145585724667, 0.3867707978746173, 0.40549252895553134, 0.4101238962448125, 0.4449072546816384, 0.42302075044992526, 0.45706211937681995, 0.4201320344348456, 0.3790346296689432, 0.4210133590039077, 0.0964287319961713, 0.08718890537426482, 0.06396283006104297, 0.12471530061681768, 0.1093430827109505, 0.10397156841283373, 0.1324611977245822, 0.09837566511143159, 0.12606387841069178, 0.17225872628203565, 0.17460509784458922, 0.16937627054594118, 0.23519864592519601, 0.24000644940898264, 0.17973697907126263, 0.1912533005280529, 0.27393912464833126, 0.14858299720344126, 0.32385442316068747, 0.27320177474758134, 0.26171061447416555, 0.2897102777665186, 0.2300796351994352, 0.24563374630205415, 0.27241304679918843, 0.35265940349160896, 0.24445540340727823, 0.18446108336443034, 0.20563716062116977, 0.18990090961221273, 0.17573361237181195, 0.2055686497605982, 0.2016353962573647, 0.21933938740285375, 0.2500980544393747, 0.2167680090213795, 0.2500038803883573, 0.1992979006892831, 0.17428604845809026, 0.17095921565812844, 0.24230605202390176, 0.1939121215409355, 0.19415218811150248, 0.21254590599228163, 0.19506933467561183, 0.19558184170843274, 0.1896940817527628, 0.18778847816105393, 0.22331742585792957, 0.18342713512167697, 0.2470013296181589, 0.17604438088349417, 0.1922603644288854, 0.2007701389469273, 0.16269320190791237, 0.13880822818263427, 0.1512659200820804, 0.6502334570710687, 0.19770129845749418, 0.4819760050301771, 0.1909589317080037, 0.16680127103989817, 0.19570148142426314, 0.5596323868807596, 0.20477624058432842, 0.394728621530151, 0.19690125815315318, 0.4117818133844334, 0.14663427201744472, 0.20376777858180228, 0.3694822765293512, 0.4336102872675538, 0.18845789212321074, 0.18380627489468215, 0.18467371373657793, 0.18919213306199467, 0.20330887456581326, 0.187627098389755, 0.19891205405676404, 0.19895435476633017, 0.20787517022841817, 0.08444540334443851, 0.07360515094260422, 0.08146682850503528, 0.08239152008805017, 0.08035127641452633, 0.1068446949564602, 0.090634878135599, 0.07147503552895684, 0.0803733260130135]}, "mutation_prompt": null}
{"id": "9f69b681-899b-43ce-b81e-789f8330a45d", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                mutant_vector = clip(a + self.mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                pop_velocity[i] = (self.inertia_weight * pop_velocity[i] +\n                                   self.cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   self.social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n        return global_best", "name": "HybridDEPSO", "description": "A hybrid algorithm combining Differential Evolution and Particle Swarm Optimization to adaptively explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9675a700-84af-4acc-8bee-d1e8d6dfc6f0", "metadata": {"aucs": [0.49359690897353903, 0.423466647821918, 0.4904313076973955, 0.5399445428692773, 0.181594438735444, 0.529907115832577, 0.4788543557496733, 0.3889281815872391, 0.4748108764457787, 0.02462703992727422, 0.15632238845618918, 0.03464988852114714, 0.17537783812313423, 0.11873286752427781, 9.999999999998899e-05, 0.02872069595970328, 0.14561497385933075, 0.07664895355952017, 0.10058861183172507, 0.1172712969484131, 0.13831394931871943, 0.11008231197992713, 0.12037468289044317, 0.09941870897605276, 0.11444650213441432, 0.12745155766209226, 0.11805211050030939, 0.08907696505693763, 0.12528650322015278, 0.09379441325408988, 0.10217643341766858, 0.0995072949560406, 0.1027182346111869, 0.08928291750501449, 0.10404105573499178, 0.08623011214588228, 0.9850242586520188, 0.9889053672630709, 0.9825441153344384, 0.989009954630518, 0.984639251900144, 0.9833619857748379, 0.9844257217934012, 0.9851662466072517, 0.9841836724688188, 0.20508200393579534, 0.29532048169588354, 0.26394828900444467, 0.1473018441123679, 0.14274199737759863, 0.3072522118090365, 0.301415091776734, 0.24700967502833648, 0.22001021029603574, 0.2751934108746865, 0.2239009182858861, 0.28191354305300287, 0.29480063692474223, 0.2636902962625781, 0.32003930538491776, 0.36295339310793073, 0.4783232155670335, 0.16822656790983292, 0.12212208462625762, 0.15420694056443884, 0.13132188537498335, 0.1492855596941638, 0.08034728360681509, 0.09283803745749797, 0.13432827192961072, 0.12670592883296028, 0.13601137008629471, 0.21852471482334246, 0.11795966991759721, 0.14314434645059193, 0.12915941110321016, 0.09837774599939453, 0.17698393132810342, 0.14082205554179872, 0.1377512124485455, 0.14963818404117224, 9.999999999998899e-05, 9.999999999998899e-05, 0.025679629912407242, 0.00023106227350022657, 9.999999999998899e-05, 9.999999999998899e-05, 0.020205971920513544, 9.999999999998899e-05, 0.029672305878390537, 0.05666779566052593, 0.05435507349957658, 0.13389423748597395, 0.07485807618064777, 0.01251998982726732, 0.046875117470099426, 0.0682728954716002, 0.011951757576963762, 0.027769333062774404, 0.014924198173002168, 9.999999999998899e-05, 0.025947114750569877, 0.03656732463764334, 0.013899325930192052, 0.020705009495106008, 0.04434114109576914, 0.03114890673165105, 0.008597185468196433, 0.10348852776275597, 0.09663048178510292, 0.0273733543219572, 0.09034171693068604, 0.11195355856037836, 0.049021305747247945, 0.1399110936136434, 0.06989657907814706, 0.06552145585724667, 0.3867707978746173, 0.40549252895553134, 0.4101238962448125, 0.4449072546816384, 0.42302075044992526, 0.45706211937681995, 0.4201320344348456, 0.3790346296689432, 0.4210133590039077, 0.0964287319961713, 0.08718890537426482, 0.06396283006104297, 0.12471530061681768, 0.1093430827109505, 0.10397156841283373, 0.1324611977245822, 0.09837566511143159, 0.12606387841069178, 0.17225872628203565, 0.17460509784458922, 0.16937627054594118, 0.23519864592519601, 0.24000644940898264, 0.17973697907126263, 0.1912533005280529, 0.27393912464833126, 0.14858299720344126, 0.32385442316068747, 0.27320177474758134, 0.26171061447416555, 0.2897102777665186, 0.2300796351994352, 0.24563374630205415, 0.27241304679918843, 0.35265940349160896, 0.24445540340727823, 0.18446108336443034, 0.20563716062116977, 0.18990090961221273, 0.17573361237181195, 0.2055686497605982, 0.2016353962573647, 0.21933938740285375, 0.2500980544393747, 0.2167680090213795, 0.2500038803883573, 0.1992979006892831, 0.17428604845809026, 0.17095921565812844, 0.24230605202390176, 0.1939121215409355, 0.19415218811150248, 0.21254590599228163, 0.19506933467561183, 0.19558184170843274, 0.1896940817527628, 0.18778847816105393, 0.22331742585792957, 0.18342713512167697, 0.2470013296181589, 0.17604438088349417, 0.1922603644288854, 0.2007701389469273, 0.16269320190791237, 0.13880822818263427, 0.1512659200820804, 0.6502334570710687, 0.19770129845749418, 0.4819760050301771, 0.1909589317080037, 0.16680127103989817, 0.19570148142426314, 0.5596323868807596, 0.20477624058432842, 0.394728621530151, 0.19690125815315318, 0.4117818133844334, 0.14663427201744472, 0.20376777858180228, 0.3694822765293512, 0.4336102872675538, 0.18845789212321074, 0.18380627489468215, 0.18467371373657793, 0.18919213306199467, 0.20330887456581326, 0.187627098389755, 0.19891205405676404, 0.19895435476633017, 0.20787517022841817, 0.08444540334443851, 0.07360515094260422, 0.08146682850503528, 0.08239152008805017, 0.08035127641452633, 0.1068446949564602, 0.090634878135599, 0.07147503552895684, 0.0803733260130135]}, "mutation_prompt": null}
{"id": "ed065e16-f8b3-4ba3-afeb-a1ac12fa00de", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                # Adjust mutation factor dynamically\n                dynamic_mutation_factor = self.mutation_factor * (1 - evals / self.budget)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                pop_velocity[i] = (self.inertia_weight * pop_velocity[i] +\n                                   self.cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   self.social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhancing the balance between exploration and exploitation by adjusting mutation factor dynamically based on convergence progress.", "configspace": "", "generation": 4, "fitness": 0.22393066938755452, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "9675a700-84af-4acc-8bee-d1e8d6dfc6f0", "metadata": {"aucs": [0.4487090383855591, 0.48376053165069366, 0.49051883211732583, 0.5191073894931888, 0.5295810503331426, 0.5640924829760268, 0.54932635617427, 0.5050345860496668, 0.47859121292750884, 0.060893277099361875, 0.02840392760746313, 0.19664488549821746, 0.04572240973035646, 0.14133661820932142, 0.1454183599459259, 0.03848145694635674, 0.13524881763498198, 0.13235031484121484, 0.13196872883146082, 0.11641368969712806, 0.14273628304077624, 0.09974391892341405, 0.09397439057224943, 0.1132764461471577, 0.1342224082779474, 0.10576972444707866, 0.10338881315587245, 0.08524418902231412, 0.12914542420896924, 0.1060544148275312, 0.10508950333934952, 0.10706524707430343, 0.09600158804424752, 0.12009810510408714, 0.09447836114216845, 0.09676600525719459, 0.9850242572572986, 0.9889040103379279, 0.9825427056209189, 0.9890092736548499, 0.9846386560727541, 0.9833613469047584, 0.9844236793742612, 0.9851651135098385, 0.9842020523073369, 0.29097453315992816, 0.27508744766455817, 0.2514156927259038, 0.2599749167462705, 0.1433767640554413, 0.25198643656259667, 0.31481726013081757, 0.24566323440759563, 0.04969795954782219, 0.16894712230568243, 0.3439523817855159, 0.33708333357680687, 0.5464669598843508, 0.46329425513714195, 0.20194779811056685, 0.4002925564929758, 0.557470659300547, 0.2091567058116367, 0.1032473214092382, 0.2006639460127626, 0.10318263478338563, 0.1416089275056629, 0.10490169268848026, 0.08046932043576305, 0.15446341154560628, 0.14304758594534983, 0.12040107749729723, 0.15272505363614475, 0.1563602465434647, 0.11960107395781305, 0.15626345730428415, 0.16470291916305446, 0.14244086007052925, 0.12758448417179502, 0.14101901065114053, 0.1447535259545908, 9.999999999998899e-05, 9.999999999998899e-05, 0.03786069953110782, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.056980725936550014, 0.10344165990262266, 0.057103083087775675, 0.07452521124943401, 0.01990940481726755, 0.021594813696481863, 0.06724060301192147, 0.015873217158128727, 0.04437156679282739, 9.999999999998899e-05, 0.006309811186269831, 0.02274826060966917, 0.028183051401907466, 0.034964819586566054, 0.028449183340277018, 0.05670321857186922, 0.03045902352968899, 0.03101146690377643, 0.10272222941255349, 0.03262410025927709, 0.07194807755454136, 0.10037602221763953, 0.0952674147730107, 0.004378855423083028, 0.106530737874857, 0.0955819784885722, 0.06653251803853888, 0.42853953612144446, 0.40953976527368463, 0.4161717978648479, 0.45345075174212157, 0.35817621626736296, 0.4657530525497505, 0.4377325961112445, 0.3890262804634659, 0.38666247079050886, 0.12853799448653536, 0.09590449638289444, 0.06159191017594079, 0.1041446904863833, 0.09878109756406206, 0.10558143647558482, 0.11042982453195904, 0.09452241107904935, 0.11135380754198254, 0.13882504218511582, 0.1929258219014095, 0.2471056434124823, 0.2229254466990117, 0.16201065773336742, 0.20415443525084787, 0.19081365762740876, 0.2784380739459843, 0.1719173206228748, 0.27000809988993757, 0.2636161214580406, 0.35000144295273117, 0.27330869348199505, 0.26439693018886257, 0.277002469033253, 0.29640959256339383, 0.3686107718446938, 0.32087029550430246, 0.21026935827821203, 0.20098592954074912, 0.2088089181658822, 0.178349098274171, 0.18863795263791205, 0.24111969878242712, 0.2142539833715409, 0.22406539161819905, 0.20322715178379647, 0.20332445282221923, 0.18234375434488648, 0.17890338793509797, 0.22945669118595957, 0.20055789884799602, 0.19649911246607676, 0.1811917319089975, 0.20319319484710485, 0.20586967522647015, 0.22467235467283875, 0.19032525134397482, 0.18919728581528428, 0.19537148570846707, 0.18231670491166185, 0.19664758001863414, 0.26522822108951993, 0.20309986192349816, 0.22217507507649925, 0.6069104544089867, 0.6099032604777648, 0.15165415083687894, 0.6563192521151979, 0.19688066602989773, 0.1915079502421707, 0.18802372558102565, 0.16690809245016913, 0.19644774164519163, 0.543486276704851, 0.20479379649118779, 0.32070565151297037, 0.1978457664416109, 0.4637656053361964, 0.14716124391494845, 0.20783098312689519, 0.5106832950177121, 0.2080431495389039, 0.17569587848092327, 0.19423037048368252, 0.17829865620683072, 0.1793027549417351, 0.17534526320748534, 0.19543458571331307, 0.1930885219388624, 0.17322169046663694, 0.17605711542489066, 0.09183070393640336, 0.0713729133859411, 0.08540438210118284, 0.0848003645202341, 0.08658577844445281, 0.0816379450240845, 0.08773344038023712, 0.08449937321296053, 0.09071772835423564]}, "mutation_prompt": null}
{"id": "d45de975-ec84-4d69-9cec-cc1cc34e8c53", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                # Adjust mutation factor dynamically\n                dynamic_mutation_factor = self.mutation_factor * (1 - evals / self.budget)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                # Adaptive crossover rate\n                adaptive_crossover_rate = self.crossover_rate * (1 - evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                pop_velocity[i] = (self.inertia_weight * pop_velocity[i] +\n                                   self.cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   self.social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n        return global_best", "name": "HybridDEPSO", "description": "Introduce adaptive crossover rate in DE phase based on convergence progress to enhance exploration.", "configspace": "", "generation": 5, "fitness": 0.21406013317262215, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.20.", "error": "", "parent_id": "ed065e16-f8b3-4ba3-afeb-a1ac12fa00de", "metadata": {"aucs": [0.45544228314013746, 0.5095970705712111, 0.4509520026933067, 0.5039108808607465, 0.5358284427740663, 0.5309819720148381, 0.5078384883559259, 0.4409488736826688, 0.5288753035011726, 0.02939989889716199, 0.1300531521506577, 0.14009489496869265, 0.04693072262804221, 0.1354110692151007, 0.08919540835014617, 0.07449013689083972, 0.13800174597634252, 0.0648776125910503, 0.10703525460291763, 0.11788162765726806, 0.13949334763971544, 0.12465444133521886, 0.11017113860966032, 0.13434224048006893, 0.1280902935518543, 0.11477649265149048, 0.10534147258479465, 0.09484811664395187, 0.1236384347342766, 0.08691511352444814, 0.10342069315904578, 0.14956555766405832, 0.11308145685289783, 0.09673156287826545, 0.09172739048393064, 0.07219688060871432, 0.9850242572572986, 0.9889040103379279, 0.9825427056209189, 0.9890092736548499, 0.9846386560727541, 0.978322937794107, 0.9848935008870647, 0.9851651135098385, 0.9846919212760419, 0.20876551118291065, 0.25186475866429514, 0.2755869361458494, 0.14648167624532193, 0.24645131082848448, 0.2754287576562172, 0.30089485364248936, 0.2461153958878748, 0.08413373976057903, 0.16848142326138238, 0.23233193447328282, 0.1634103328779971, 0.2484966921726839, 0.25104398480470114, 0.18435173028696095, 0.632291974533495, 0.2301108102159516, 0.2010227067516568, 0.12800429330992047, 0.2321142805694857, 0.13504484497810554, 0.11700672157026037, 0.14640670746897955, 0.07748120467474873, 0.15678213534675756, 0.11015756073753635, 0.11969059851785968, 0.15147629452641453, 0.13337647136107733, 0.15551504188090226, 0.14078765565226403, 0.112300465660509, 0.12063447901641544, 0.1543011547153419, 0.13212572705293224, 0.13488410291028408, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02265366302992844, 9.999999999998899e-05, 0.016879571270955074, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.014249711578106172, 0.10877491657666871, 0.07171835850557218, 0.13802479231727371, 0.02864997869601771, 0.04719548449982103, 0.03534260489831664, 0.0467551888156702, 0.02904441105292721, 0.02376389358641484, 9.999999999998899e-05, 0.019836639472584627, 0.034257767692606245, 0.052414315171862236, 0.03984150059384628, 0.02756246536559681, 0.02718923314673516, 0.02156486179006767, 0.10515013284284414, 0.037131936191634685, 0.039719347912288705, 0.1209639520913941, 0.19173761316070226, 0.05988094125064325, 0.16549543525663046, 0.09026726201469515, 0.06809655671238524, 0.4117644835209445, 0.4129000096496521, 0.42357135549564795, 0.46755130317159177, 0.40717751367115484, 0.3771528012281451, 0.40844347729401254, 0.39839325011146165, 0.4278804832651891, 0.08666223842268261, 0.10289711029839255, 0.09746941547374643, 0.09999630678278515, 0.08187456571963525, 0.10713975705288414, 0.09706935492881874, 0.0880899973960031, 0.11063105906183668, 0.14968463984756286, 0.21378621131647402, 0.1994756463396088, 0.21945051707486352, 0.13635848719168064, 0.18465623240949913, 0.24685515021761983, 0.3128838101273236, 0.1742995153774467, 0.23726916410194, 0.27395432730981306, 0.3383390368120396, 0.2611826161439508, 0.27251659814828955, 0.31590402500614667, 0.2795318750211022, 0.3180315464834269, 0.32260964907721257, 0.23749460914418674, 0.22780482719243755, 0.2109802225418883, 0.1859887627761172, 0.22747853910666027, 0.16546975387525142, 0.21996932651446854, 0.22483783398931123, 0.22085245579813184, 0.22789848329460494, 0.19597063667150394, 0.18700027263940067, 0.2042228415803744, 0.2126024458154997, 0.230603395768314, 0.19223110357096573, 0.18130230700462358, 0.21796013183364416, 0.2147305967314146, 0.1847677976936205, 0.2233273137696522, 0.19904182682680394, 0.19863935961664714, 0.19140676407635837, 0.19624780669600106, 0.23645384203115183, 0.20904269636581163, 0.17903075987904127, 0.4727058211614099, 0.15199311295204154, 0.17525796209202193, 0.19971024999637388, 0.19076900036686473, 0.19347440481710032, 0.16780609797905777, 0.1976404053195241, 0.5102315642801484, 0.20528047936062854, 0.34498150133779304, 0.20013142936657125, 0.3935934990352691, 0.14759359211822753, 0.20471630866085844, 0.18806691249020224, 0.3280020413751127, 0.1938369755462961, 0.1853260058298658, 0.18296915083559062, 0.18695709707665986, 0.18831618980110498, 0.18032535310662823, 0.2055863590548752, 0.1985744725733123, 0.16993853623543187, 0.07785451418571154, 0.08669371028430761, 0.08379119503582333, 0.07661898207623474, 0.08220117927106496, 0.0784181538818024, 0.07678710242664, 0.08547943257895385, 0.0782990732507991]}, "mutation_prompt": null}
{"id": "06898b5d-c9db-4998-a011-73f497a750be", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                # Adjust mutation factor dynamically\n                dynamic_mutation_factor = self.mutation_factor * (1 - evals / self.budget)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)  # Adjust inertia weight\n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   self.cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   self.social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n        return global_best", "name": "HybridDEPSO", "description": "Optimizing convergence by introducing adaptive inertia weight to enhance the PSO phase.", "configspace": "", "generation": 6, "fitness": 0.29483384105752397, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "ed065e16-f8b3-4ba3-afeb-a1ac12fa00de", "metadata": {"aucs": [0.748260469100382, 0.7268020955708574, 0.7430673782448722, 0.7346799800222439, 0.7385840848853411, 0.7875025710281117, 0.7695665829021081, 0.747190104147122, 0.7350335175534479, 0.5517470569924229, 0.5318911417299728, 0.5587145590578568, 0.05590661260624019, 0.4854396802983201, 0.4856488531702088, 0.0441983292122915, 0.5186846788772616, 0.5659499556562251, 0.1422509445765323, 0.14043439113296718, 0.1660738273862935, 0.14070751412582083, 0.1350356810474448, 0.1486505741233325, 0.12322453950608492, 0.13149882852003703, 0.13661816077670208, 0.11382094084754191, 0.10989730476354487, 0.12083257013396054, 0.10211724298251734, 0.09990864470407756, 0.10852995453549885, 0.12563386284461753, 0.13207162364992886, 0.11851026407759091, 0.9850242572572986, 0.9889040103379279, 0.982544541636965, 0.9890092736548499, 0.9846383016326082, 0.9833607448141505, 0.9844191245458058, 0.9851646534798302, 0.9843988267958412, 0.5728418604191847, 0.5592500417608038, 0.5348151778543937, 0.14916169977555094, 0.5872977688876785, 0.5693202485303035, 0.5897303497451049, 0.5411850841765886, 0.08335525912998232, 0.22117628473552697, 0.22344933899225972, 0.6699763847153917, 0.7164405429229739, 0.690787373522413, 0.35243946468529286, 0.2185106542594012, 0.22366420095988504, 0.222395684283353, 0.1970559906053373, 0.1947738641683363, 0.205143322975328, 0.20300766178035567, 0.19627963753454758, 0.09793245406478657, 0.19641984393734624, 0.1806705140114273, 0.24784838280268828, 0.18792980475561305, 0.16951100153777987, 0.21416670626996848, 0.12369181096294601, 0.17983351168903505, 0.200832107114557, 0.22504859744145433, 0.19218227600227533, 0.12244548180182124, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02670566547838571, 9.999999999998899e-05, 9.999999999998899e-05, 0.041390632481861256, 0.06609272923573806, 0.09627305973481326, 0.07923251361695327, 0.009901409806150507, 0.022598407733514403, 0.11185106923885291, 0.030890772713547787, 0.05498973184268341, 9.999999999998899e-05, 0.029463689449603758, 0.043745211410813334, 0.1395680432371007, 0.08855769546360193, 0.06381619643920144, 0.08174449364806569, 0.07402483215108646, 0.07357322777823683, 0.14337973368864276, 0.05466075724210473, 0.07083612101652637, 0.03560952521446159, 0.2802742859619003, 0.1029745614787635, 0.3084313377342899, 0.16763210103404347, 0.07706883899437367, 0.4878620894789014, 0.4947625170056259, 0.4932135180593049, 0.535831788795364, 0.48633955238261184, 0.551692898305147, 0.5292448129571543, 0.5258749573504293, 0.490279751082496, 0.09227762853521215, 0.10162863283535717, 0.11095546726593641, 0.6144727211679959, 0.11008276139048467, 0.14149190816244062, 0.11098455121600459, 0.1005162237816799, 0.11059541365245185, 0.22362596910385413, 0.25101000825897146, 0.18450137401939837, 0.22902804295901347, 0.2308238233199601, 0.1697249657319968, 0.19259027553771446, 0.34540617177349064, 0.24403543738079003, 0.4189415334482446, 0.3322659488981622, 0.4615339917050153, 0.37028601305500064, 0.39920458150694216, 0.41276378164301675, 0.47270142503070167, 0.46939504055392045, 0.46115875630714764, 0.21273693396903715, 0.2929458379703901, 0.23146285321361615, 0.2879894407670518, 0.1850720449650819, 0.22875204809517713, 0.18226644983885976, 0.2768509816854591, 0.22487832781428163, 0.22181952937318383, 0.21584320394182432, 0.20228663763955312, 0.18248195129336942, 0.19604325224395047, 0.2375372981559195, 0.24060019369928676, 0.18275843228373356, 0.2277225542030401, 0.20111056393778104, 0.6256794427565957, 0.19810273973842563, 0.22255877560662352, 0.18793177451772314, 0.5973497171041123, 0.19802689458784828, 0.20086758128484083, 0.21671157046917022, 0.1813144047855909, 0.6601994462041716, 0.1519176989894624, 0.8196199823036002, 0.19858804469628422, 0.1826801596416462, 0.194396568885973, 0.16812118135212062, 0.1976197692752527, 0.7427026153471545, 0.20756060621835792, 0.6158809040872736, 0.6230455403841224, 0.6958336278962061, 0.14940013934923158, 0.2063650365881462, 0.6675098644096767, 0.6973965055317786, 0.21994107377321448, 0.1973926514064025, 0.20557348506346984, 0.19273589395044788, 0.19930705238805446, 0.1989009340835146, 0.1814976230187093, 0.19521725812714852, 0.18109893946844868, 0.0917278523509083, 0.0820810083530974, 0.09032033436164688, 0.09157648478851499, 0.07222312293026334, 0.09451564958975067, 0.08503375936666346, 0.08204389911263155, 0.09837389795029194]}, "mutation_prompt": null}
{"id": "eaa7b84d-8861-4a51-9b2f-fbfe2d3c65dd", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                # Adjust mutation factor dynamically\n                dynamic_mutation_factor = self.mutation_factor * (1 - evals / self.budget)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)  # Adjust inertia weight\n                # Decay social constant over time\n                adaptive_social_constant = self.social_constant * (1 - evals / self.budget)\n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   self.cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   adaptive_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n        return global_best", "name": "HybridDEPSO", "description": "Introducing a decay factor to the PSO phase's social constant to enhance convergence.", "configspace": "", "generation": 7, "fitness": 0.2819410632725682, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.25.", "error": "", "parent_id": "06898b5d-c9db-4998-a011-73f497a750be", "metadata": {"aucs": [0.7797646995993813, 0.7409138547137208, 0.7615720363487829, 0.7611807074464012, 0.7709654305435253, 0.738353160093026, 0.7902592063466635, 0.7763469495313651, 0.7711656370383287, 0.5141229511760692, 0.5672879409274475, 0.5142490533011674, 0.562339252697915, 0.5729167317895004, 0.579647465151857, 0.518216584905768, 0.6169952297046013, 0.6098257598321095, 0.1555973431429537, 0.15356191867534708, 0.1450059848951647, 0.12120985145368612, 0.1490055402753484, 0.13185018515329283, 0.11455496438483947, 0.31052609219282457, 0.143077320843368, 0.13128478557073886, 0.0826568043448862, 0.1032417212844331, 0.12621741708110945, 0.11277624855613044, 0.10086195732952052, 0.11843058500747772, 0.12426056208433456, 0.12825667031315058, 0.9850107622027926, 0.9889008503554653, 0.9825521458793021, 0.988992739366612, 0.9846287145872616, 0.9833537695659106, 0.9844013893157382, 0.9851657322731983, 0.9841717572399483, 0.5176687692615101, 0.5112341391071011, 0.5470149916247864, 0.5220271090707861, 0.5671609393617161, 0.6314221364716488, 0.5939321418145191, 0.08878197750505568, 0.08327111951670962, 0.21752569043754433, 0.22157899818648807, 0.7195494330465282, 0.19020137734388654, 0.26595531386033266, 0.2668841509371601, 0.22477945733821725, 0.36019849442387764, 0.19996756350075495, 0.20598962502115514, 0.11816790533407073, 0.16141821694278025, 0.1685374368307141, 0.11716644011444854, 0.10970676632648779, 0.18103470484779505, 0.19452251039441637, 0.1776945816311416, 0.17623317652129078, 0.1906634475890685, 0.2076927277537688, 0.12248520667336182, 0.17473682827412507, 0.11892085746075687, 0.20110799562043957, 0.1269642464335008, 0.22770679424275952, 9.999999999998899e-05, 9.999999999998899e-05, 0.037505719192635456, 0.03853929220157226, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005064835140347057, 0.012459580208914134, 9.999999999998899e-05, 0.030161074566154467, 0.030824946658787322, 0.07715389753759405, 0.13627919753307582, 0.020477100324794217, 0.04688501521243793, 0.05377151567775329, 0.12805120286871774, 0.1025283422597546, 9.999999999998899e-05, 0.02871804944372347, 0.04428235898530697, 0.07417651966379513, 0.08246618872126332, 0.07838115832844383, 0.08103753155272408, 0.08114225368751615, 0.08136464815074362, 0.1570828064499601, 0.0811044670413743, 0.068072828208107, 0.11648082414778005, 0.06218678128127664, 0.05814829510324393, 0.08171084077245627, 0.08900377421476025, 0.07641676058303926, 0.5121436780788375, 0.5383295732712539, 0.5209897371114416, 0.5566344446289035, 0.48528946160732545, 0.4999695742413146, 0.509601199429917, 0.5089450375265784, 0.5194767264763555, 0.10341642022371067, 0.0903672761484553, 0.08078958133799863, 0.10968051296891423, 0.1440142552172856, 0.10675973879017842, 0.12303111017290247, 0.10326190837667815, 0.13520251651793935, 0.14121607630146915, 0.16114551906259456, 0.20746698061614766, 0.18080592516602756, 0.24230577282654142, 0.1960609625321874, 0.16796061444613353, 0.17531909567220683, 0.16529882318143352, 0.2577791609719283, 0.47645051513251724, 0.5147601676491544, 0.5075743837750819, 0.3486940410510442, 0.3726219291984234, 0.5057361971429334, 0.5076944272461326, 0.5218885075650221, 0.1872202320608487, 0.22350586351237756, 0.25963076675406216, 0.27501840940268507, 0.21825448366953948, 0.22734632034443225, 0.1925015733692681, 0.38754318596279136, 0.26799357378413724, 0.20613164319285626, 0.21957201751105104, 0.2277223095562757, 0.21849466453304478, 0.21491319530862718, 0.21896809568625508, 0.2334474949157952, 0.20706971716763578, 0.24208748690494009, 0.6131259853259506, 0.19861736292594367, 0.20264905952505274, 0.19637690117466322, 0.21263370387634473, 0.21333539063419615, 0.23186922090028106, 0.2148794394003699, 0.6368436595889195, 0.16428188722065262, 0.1865945038290805, 0.152412979036761, 0.8030588540621756, 0.19854441850208882, 0.19323873169006633, 0.19338705582823312, 0.16744912547836865, 0.1985445808534403, 0.45601765147226425, 0.20832937658363537, 0.1500554065429729, 0.20262030989904256, 0.6141803575988064, 0.14905730098039827, 0.2009356616683735, 0.7364496352317045, 0.20472839663351938, 0.17868517911753445, 0.1838445881209788, 0.17956421165490033, 0.19846085636452238, 0.17950000317416348, 0.18566192450637398, 0.17850833166632507, 0.1870019331199384, 0.203339482173174, 0.07589070568361822, 0.08465592505781605, 0.08322476207776108, 0.08403326338790251, 0.09017833005182563, 0.09800807973538173, 0.07854018071428504, 0.09048307723910709, 0.08026980183131416]}, "mutation_prompt": null}
{"id": "6d054ff1-1685-4671-9268-252dd5778718", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                # Adjust mutation factor dynamically\n                dynamic_mutation_factor = self.mutation_factor * (1 - evals / self.budget)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)  # Adjust inertia weight\n                # Adjust cognitive and social constants dynamically\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhancing HybridDEPSO by dynamically adjusting both the cognitive and social constants for improved exploration and exploitation balance.", "configspace": "", "generation": 8, "fitness": 0.32198147110416026, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "06898b5d-c9db-4998-a011-73f497a750be", "metadata": {"aucs": [0.8029760188557739, 0.8030050152449342, 0.8344221888078622, 0.8050472650303084, 0.8082521414204733, 0.8228148038577843, 0.7855583064045766, 0.8010076014228147, 0.8032501426376691, 0.5807592647584046, 0.6422143429317811, 0.5760100480651696, 0.5722644974490178, 0.6100768213422402, 0.6222513193713893, 0.6555060953046308, 0.5966894034350217, 0.6414184230554888, 0.13563265166095606, 0.14138413398106464, 0.10954306800028679, 0.14762793685858233, 0.17098720546955104, 0.14460252631438375, 0.10964646045418669, 0.1516653713658228, 0.14416994789829518, 0.1675569059159363, 0.08875270811514346, 0.10714235287526408, 0.10678087212157383, 0.15002908517776703, 0.07094978661432338, 0.10631135524331659, 0.13051474993296908, 0.1352742504382164, 0.9734453328945732, 0.9754627545668335, 0.9754279887834217, 0.9673889186674913, 0.9686174053678678, 0.9730111207078063, 0.9711310910931762, 0.9827076357998039, 0.976548505672848, 0.670959274216222, 0.704274195565449, 0.7021109595435175, 0.7110830161323067, 0.7022130581576579, 0.6993101354786122, 0.7199021204768581, 0.6882982672337952, 0.6746597886173464, 0.22405872573544716, 0.22702062386624688, 0.36739800349461793, 0.2698806565137942, 0.26764572736014136, 0.27216259506738893, 0.85963171606324, 0.7819590733051504, 0.31366548538460215, 0.22608752378732666, 0.2200500958196394, 0.10000815651183781, 0.21275066498073625, 0.12615244584336893, 0.19853308201285136, 0.3381494934922564, 0.22444794282001346, 0.23204353537317102, 0.22892776934254622, 0.23462440916902705, 0.21497433030795954, 0.22145868960840187, 0.2613628980039495, 0.23555229013394796, 0.12509859604337759, 0.12233385960310383, 0.23548853397316627, 0.005174908109006893, 0.003495925584528048, 0.006007255196528005, 0.0053477325620000515, 0.02189902023976631, 9.999999999998899e-05, 0.013188491953689874, 9.999999999998899e-05, 9.999999999998899e-05, 0.059077220060322566, 0.09913790091413144, 0.10833744577129623, 0.11138096867548697, 0.0029266691028082548, 0.07456095692605891, 0.08255912566273815, 0.06383201521713422, 0.1339221323731017, 0.051554606303504946, 0.06922881621682586, 0.04826629755143552, 0.18311375541342045, 0.07874237144470442, 0.06560049384507038, 0.12067649048453788, 0.12072616888066146, 0.15356615775481242, 0.06204700767267535, 0.14833944573612212, 0.08006553254344106, 0.18253650234600638, 0.16920499822654278, 0.1305509368721237, 0.17019212343856904, 0.1860183217717346, 0.1056072112787606, 0.5203001220236152, 0.5201685202528988, 0.5207336194363035, 0.5050848302152431, 0.5435725619387243, 0.5922919141748197, 0.5826022587167843, 0.5378387081665275, 0.5460550214477707, 0.11220307812995767, 0.12249114813953399, 0.07931426842396128, 0.12196105172254212, 0.12243663867267263, 0.10950393776232159, 0.1761399539989732, 0.10100687352826476, 0.13402975125834304, 0.1756619980561629, 0.21227633012833835, 0.4288808533354622, 0.2310009667354327, 0.22384790967877477, 0.46561699238068566, 0.19690391315125744, 0.2045509592765492, 0.2690831715706007, 0.24385852704675748, 0.39803550349493644, 0.45176474690171353, 0.40106151383441024, 0.24542748859755215, 0.39821165636100353, 0.6497453227457664, 0.43693075741181686, 0.45228480735356036, 0.45497843722078757, 0.17936151640864573, 0.2809042135757196, 0.35786690203058036, 0.34395945213144163, 0.20352945634504926, 0.1931969114225518, 0.3555091674432962, 0.4046445856213964, 0.24698100630340547, 0.20346089338514683, 0.20821513452185858, 0.2265241576488095, 0.22124599823223112, 0.22079770960860956, 0.2355844089356044, 0.20763839926384386, 0.22278109577434757, 0.24051851036209593, 0.20934911954286395, 0.23986949259383095, 0.20687499806661358, 0.21783765638534958, 0.1943857710379806, 0.21962899705749006, 0.18256516916346288, 0.18115188705974528, 0.18700331885342425, 0.18523762436359048, 0.1502958240912129, 0.1492478125639829, 0.1987861147582375, 0.20734770009743775, 0.8498050244660879, 0.8542061578482952, 0.1997213618244622, 0.8121005580985392, 0.16874914280012143, 0.671387893319636, 0.6326582856828716, 0.16766137374301648, 0.16514821120199719, 0.6922167356111125, 0.7049932503792677, 0.8150857812569982, 0.20730401073616223, 0.20841643461981452, 0.21408799918374488, 0.18417998560021698, 0.2015711076704203, 0.20867482345124633, 0.2005223371844962, 0.1924568766776299, 0.19217359351465502, 0.0906920384429879, 0.08976536476705699, 0.08613979734119381, 0.09939270557987201, 0.10176768542820247, 0.1076636834403143, 0.0896937048287898, 0.10680959677523261, 0.08549655252806643]}, "mutation_prompt": null}
{"id": "6e35a1bf-165f-440b-9614-0d9b861c1d1e", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * (1 - evals / self.budget)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Improve convergence by implementing a dynamic population size strategy to balance exploration and exploitation.", "configspace": "", "generation": 9, "fitness": 0.3244925109938204, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "6d054ff1-1685-4671-9268-252dd5778718", "metadata": {"aucs": [0.838219559866757, 0.8356259710224565, 0.8434308157602466, 0.8057664586557362, 0.8226609578583792, 0.8340859113183443, 0.8320592301430555, 0.835804738148955, 0.8260049373667719, 0.6914294949102411, 0.6437561073438337, 0.6963491252872581, 0.6721571988400773, 0.677190702560813, 0.6898999418121012, 0.6592643635244493, 0.6435034322565195, 0.6816612896511116, 0.13382327121952475, 0.1150833916198073, 0.13775843712030578, 0.13709615872095204, 0.13470427998648304, 0.17197604210770479, 0.1267431633425078, 0.11443522034248343, 0.11159905238497125, 0.10430247375312263, 0.08594796391481163, 0.11661182466764952, 0.10326736484859012, 0.10609243535322765, 0.10915917277733733, 0.12594843793273958, 0.08711564785040915, 0.10261788283573225, 0.9638935672514, 0.9774257365423846, 0.975575736376211, 0.9646832184964033, 0.9763280262847283, 0.9699208812332638, 0.9720979375259196, 0.9772997710654082, 0.97558681268676, 0.7608075486116868, 0.7224278481035113, 0.7493556304770205, 0.724516966359491, 0.6938624454456874, 0.7302634874516224, 0.7426322662423326, 0.7488311260513352, 0.08570743530133373, 0.844844060194216, 0.20611642483115455, 0.3686269889314423, 0.2787960350053782, 0.2733443345861125, 0.1596889283713412, 0.3771809531654383, 0.2326638102722559, 0.23306530009768844, 0.23259169094780097, 0.23298052436307604, 0.17259810360834182, 0.24376879665606743, 0.1250889078357299, 0.22042386526770597, 0.2238857857187635, 0.23585687445061998, 0.22325299757813843, 0.2366511020802139, 0.20816774692586282, 0.23914166640355916, 0.2503738788232156, 0.12627280845891442, 0.2681024858135165, 0.23226203982408, 0.22704883368076012, 0.24570573673486928, 0.012722676155140111, 0.006805796379252715, 0.07395380116541361, 0.026881430031883813, 0.05308304739113867, 9.999999999998899e-05, 0.010967772741739878, 0.012411954980764861, 0.03311158826745819, 0.014339829631120682, 0.06686817640321063, 0.08765595816203275, 0.0959429011687416, 0.06385792439689653, 0.06956129909258102, 0.09272172239649057, 0.08327010686834257, 0.057486233211643256, 0.10503454030395587, 0.0444653457107812, 0.07343706671132655, 0.25080190577620964, 0.11903074856049356, 0.07894834490059421, 0.1567934902516468, 0.11926608164596197, 0.08960665132648338, 0.04108761983972142, 0.3722143202286675, 0.22686358951568375, 0.13796115821195254, 0.11419092769706762, 0.07206417272713883, 0.20641008726633625, 0.15039349918274625, 0.10330130429875595, 0.5236040055711821, 0.5676129135190826, 0.5316982260201883, 0.5591251472037287, 0.5476403738120039, 0.5479879364039093, 0.5546053118976031, 0.5415500307594008, 0.5341889730083786, 0.14107501256321897, 0.11146783954713357, 0.10191166416203978, 0.11644098177807083, 0.1342957327055888, 0.09645905816879874, 0.0824378735800323, 0.10997317002136353, 0.13761907599412893, 0.2867720501778733, 0.20847863726109594, 0.190110188977058, 0.3005984649883895, 0.2920342129108596, 0.37383119846371826, 0.14534033971080085, 0.13804718904764213, 0.20605196104560308, 0.29959587393697895, 0.4288528966969075, 0.28974033790130127, 0.5850293214719848, 0.46775047615420406, 0.5109672447810876, 0.46425875277097817, 0.5649325566827976, 0.5346317828789562, 0.25620949629141354, 0.2412505923027276, 0.2738177257544888, 0.2650821919697186, 0.30773554293903294, 0.2252995150559276, 0.19343465907583168, 0.29759130374024, 0.2926865451013134, 0.27687795537328885, 0.23535724814567294, 0.2369768644015282, 0.23875522120983783, 0.2269814263933796, 0.2017395854929076, 0.23285839566717426, 0.23649766825719454, 0.25375521338938023, 0.21972215124974626, 0.19732263053477594, 0.18553778073899818, 0.18894753498717332, 0.18869810037936097, 0.20270941764403938, 0.7539674896524837, 0.696159776810124, 0.2232246200301239, 0.18639883926878364, 0.18377606418694337, 0.15278718334312602, 0.17498471133356475, 0.19896725376111601, 0.8712535944811433, 0.7739476496566491, 0.8314684093305071, 0.20079534552200273, 0.7928387110774869, 0.16916730738036823, 0.7673378359307677, 0.45426336525434785, 0.16826749030608368, 0.16513236637503337, 0.10405295319796204, 0.16471870841144898, 0.8299447221160402, 0.19498582095333872, 0.20137519164340045, 0.1899704443776704, 0.20426332414495485, 0.20345636114334842, 0.18049366524953603, 0.19267912551194044, 0.18174885084419634, 0.194259088248376, 0.09076045507675756, 0.10958789017008963, 0.08871265184805177, 0.10140028968961301, 0.07809415736467451, 0.13851603712954896, 0.09495313370336844, 0.17214297504243992, 0.10048428459094882]}, "mutation_prompt": null}
{"id": "335f5609-678f-40a5-8fc5-3c19a717a5a9", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * (1 - evals / self.budget)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Improve convergence by implementing a dynamic population size strategy to balance exploration and exploitation.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6e35a1bf-165f-440b-9614-0d9b861c1d1e", "metadata": {"aucs": [0.838219559866757, 0.8356259710224565, 0.8434308157602466, 0.8057664586557362, 0.8226609578583792, 0.8340859113183443, 0.8320592301430555, 0.835804738148955, 0.8260049373667719, 0.6914294949102411, 0.6437561073438337, 0.6963491252872581, 0.6721571988400773, 0.677190702560813, 0.6898999418121012, 0.6592643635244493, 0.6435034322565195, 0.6816612896511116, 0.13382327121952475, 0.1150833916198073, 0.13775843712030578, 0.13709615872095204, 0.13470427998648304, 0.17197604210770479, 0.1267431633425078, 0.11443522034248343, 0.11159905238497125, 0.10430247375312263, 0.08594796391481163, 0.11661182466764952, 0.10326736484859012, 0.10609243535322765, 0.10915917277733733, 0.12594843793273958, 0.08711564785040915, 0.10261788283573225, 0.9638935672514, 0.9774257365423846, 0.975575736376211, 0.9646832184964033, 0.9763280262847283, 0.9699208812332638, 0.9720979375259196, 0.9772997710654082, 0.97558681268676, 0.7608075486116868, 0.7224278481035113, 0.7493556304770205, 0.724516966359491, 0.6938624454456874, 0.7302634874516224, 0.7426322662423326, 0.7488311260513352, 0.08570743530133373, 0.844844060194216, 0.20611642483115455, 0.3686269889314423, 0.2787960350053782, 0.2733443345861125, 0.1596889283713412, 0.3771809531654383, 0.2326638102722559, 0.23306530009768844, 0.23259169094780097, 0.23298052436307604, 0.17259810360834182, 0.24376879665606743, 0.1250889078357299, 0.22042386526770597, 0.2238857857187635, 0.23585687445061998, 0.22325299757813843, 0.2366511020802139, 0.20816774692586282, 0.23914166640355916, 0.2503738788232156, 0.12627280845891442, 0.2681024858135165, 0.23226203982408, 0.22704883368076012, 0.24570573673486928, 0.012722676155140111, 0.006805796379252715, 0.07395380116541361, 0.026881430031883813, 0.05308304739113867, 9.999999999998899e-05, 0.010967772741739878, 0.012411954980764861, 0.03311158826745819, 0.014339829631120682, 0.06686817640321063, 0.08765595816203275, 0.0959429011687416, 0.06385792439689653, 0.06956129909258102, 0.09272172239649057, 0.08327010686834257, 0.057486233211643256, 0.10503454030395587, 0.0444653457107812, 0.07343706671132655, 0.25080190577620964, 0.11903074856049356, 0.07894834490059421, 0.1567934902516468, 0.11926608164596197, 0.08960665132648338, 0.04108761983972142, 0.3722143202286675, 0.22686358951568375, 0.13796115821195254, 0.11419092769706762, 0.07206417272713883, 0.20641008726633625, 0.15039349918274625, 0.10330130429875595, 0.5236040055711821, 0.5676129135190826, 0.5316982260201883, 0.5591251472037287, 0.5476403738120039, 0.5479879364039093, 0.5546053118976031, 0.5415500307594008, 0.5341889730083786, 0.14107501256321897, 0.11146783954713357, 0.10191166416203978, 0.11644098177807083, 0.1342957327055888, 0.09645905816879874, 0.0824378735800323, 0.10997317002136353, 0.13761907599412893, 0.2867720501778733, 0.20847863726109594, 0.190110188977058, 0.3005984649883895, 0.2920342129108596, 0.37383119846371826, 0.14534033971080085, 0.13804718904764213, 0.20605196104560308, 0.29959587393697895, 0.4288528966969075, 0.28974033790130127, 0.5850293214719848, 0.46775047615420406, 0.5109672447810876, 0.46425875277097817, 0.5649325566827976, 0.5346317828789562, 0.25620949629141354, 0.2412505923027276, 0.2738177257544888, 0.2650821919697186, 0.30773554293903294, 0.2252995150559276, 0.19343465907583168, 0.29759130374024, 0.2926865451013134, 0.27687795537328885, 0.23535724814567294, 0.2369768644015282, 0.23875522120983783, 0.2269814263933796, 0.2017395854929076, 0.23285839566717426, 0.23649766825719454, 0.25375521338938023, 0.21972215124974626, 0.19732263053477594, 0.18553778073899818, 0.18894753498717332, 0.18869810037936097, 0.20270941764403938, 0.7539674896524837, 0.696159776810124, 0.2232246200301239, 0.18639883926878364, 0.18377606418694337, 0.15278718334312602, 0.17498471133356475, 0.19896725376111601, 0.8712535944811433, 0.7739476496566491, 0.8314684093305071, 0.20079534552200273, 0.7928387110774869, 0.16916730738036823, 0.7673378359307677, 0.45426336525434785, 0.16826749030608368, 0.16513236637503337, 0.10405295319796204, 0.16471870841144898, 0.8299447221160402, 0.19498582095333872, 0.20137519164340045, 0.1899704443776704, 0.20426332414495485, 0.20345636114334842, 0.18049366524953603, 0.19267912551194044, 0.18174885084419634, 0.194259088248376, 0.09076045507675756, 0.10958789017008963, 0.08871265184805177, 0.10140028968961301, 0.07809415736467451, 0.13851603712954896, 0.09495313370336844, 0.17214297504243992, 0.10048428459094882]}, "mutation_prompt": null}
{"id": "be78c16f-d170-4b32-966a-d40ba5501e29", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * (1 - evals / self.budget)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Improve convergence by implementing a dynamic population size strategy to balance exploration and exploitation.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6e35a1bf-165f-440b-9614-0d9b861c1d1e", "metadata": {"aucs": [0.838219559866757, 0.8356259710224565, 0.8434308157602466, 0.8057664586557362, 0.8226609578583792, 0.8340859113183443, 0.8320592301430555, 0.835804738148955, 0.8260049373667719, 0.6914294949102411, 0.6437561073438337, 0.6963491252872581, 0.6721571988400773, 0.677190702560813, 0.6898999418121012, 0.6592643635244493, 0.6435034322565195, 0.6816612896511116, 0.13382327121952475, 0.1150833916198073, 0.13775843712030578, 0.13709615872095204, 0.13470427998648304, 0.17197604210770479, 0.1267431633425078, 0.11443522034248343, 0.11159905238497125, 0.10430247375312263, 0.08594796391481163, 0.11661182466764952, 0.10326736484859012, 0.10609243535322765, 0.10915917277733733, 0.12594843793273958, 0.08711564785040915, 0.10261788283573225, 0.9638935672514, 0.9774257365423846, 0.975575736376211, 0.9646832184964033, 0.9763280262847283, 0.9699208812332638, 0.9720979375259196, 0.9772997710654082, 0.97558681268676, 0.7608075486116868, 0.7224278481035113, 0.7493556304770205, 0.724516966359491, 0.6938624454456874, 0.7302634874516224, 0.7426322662423326, 0.7488311260513352, 0.08570743530133373, 0.844844060194216, 0.20611642483115455, 0.3686269889314423, 0.2787960350053782, 0.2733443345861125, 0.1596889283713412, 0.3771809531654383, 0.2326638102722559, 0.23306530009768844, 0.23259169094780097, 0.23298052436307604, 0.17259810360834182, 0.24376879665606743, 0.1250889078357299, 0.22042386526770597, 0.2238857857187635, 0.23585687445061998, 0.22325299757813843, 0.2366511020802139, 0.20816774692586282, 0.23914166640355916, 0.2503738788232156, 0.12627280845891442, 0.2681024858135165, 0.23226203982408, 0.22704883368076012, 0.24570573673486928, 0.012722676155140111, 0.006805796379252715, 0.07395380116541361, 0.026881430031883813, 0.05308304739113867, 9.999999999998899e-05, 0.010967772741739878, 0.012411954980764861, 0.03311158826745819, 0.014339829631120682, 0.06686817640321063, 0.08765595816203275, 0.0959429011687416, 0.06385792439689653, 0.06956129909258102, 0.09272172239649057, 0.08327010686834257, 0.057486233211643256, 0.10503454030395587, 0.0444653457107812, 0.07343706671132655, 0.25080190577620964, 0.11903074856049356, 0.07894834490059421, 0.1567934902516468, 0.11926608164596197, 0.08960665132648338, 0.04108761983972142, 0.3722143202286675, 0.22686358951568375, 0.13796115821195254, 0.11419092769706762, 0.07206417272713883, 0.20641008726633625, 0.15039349918274625, 0.10330130429875595, 0.5236040055711821, 0.5676129135190826, 0.5316982260201883, 0.5591251472037287, 0.5476403738120039, 0.5479879364039093, 0.5546053118976031, 0.5415500307594008, 0.5341889730083786, 0.14107501256321897, 0.11146783954713357, 0.10191166416203978, 0.11644098177807083, 0.1342957327055888, 0.09645905816879874, 0.0824378735800323, 0.10997317002136353, 0.13761907599412893, 0.2867720501778733, 0.20847863726109594, 0.190110188977058, 0.3005984649883895, 0.2920342129108596, 0.37383119846371826, 0.14534033971080085, 0.13804718904764213, 0.20605196104560308, 0.29959587393697895, 0.4288528966969075, 0.28974033790130127, 0.5850293214719848, 0.46775047615420406, 0.5109672447810876, 0.46425875277097817, 0.5649325566827976, 0.5346317828789562, 0.25620949629141354, 0.2412505923027276, 0.2738177257544888, 0.2650821919697186, 0.30773554293903294, 0.2252995150559276, 0.19343465907583168, 0.29759130374024, 0.2926865451013134, 0.27687795537328885, 0.23535724814567294, 0.2369768644015282, 0.23875522120983783, 0.2269814263933796, 0.2017395854929076, 0.23285839566717426, 0.23649766825719454, 0.25375521338938023, 0.21972215124974626, 0.19732263053477594, 0.18553778073899818, 0.18894753498717332, 0.18869810037936097, 0.20270941764403938, 0.7539674896524837, 0.696159776810124, 0.2232246200301239, 0.18639883926878364, 0.18377606418694337, 0.15278718334312602, 0.17498471133356475, 0.19896725376111601, 0.8712535944811433, 0.7739476496566491, 0.8314684093305071, 0.20079534552200273, 0.7928387110774869, 0.16916730738036823, 0.7673378359307677, 0.45426336525434785, 0.16826749030608368, 0.16513236637503337, 0.10405295319796204, 0.16471870841144898, 0.8299447221160402, 0.19498582095333872, 0.20137519164340045, 0.1899704443776704, 0.20426332414495485, 0.20345636114334842, 0.18049366524953603, 0.19267912551194044, 0.18174885084419634, 0.194259088248376, 0.09076045507675756, 0.10958789017008963, 0.08871265184805177, 0.10140028968961301, 0.07809415736467451, 0.13851603712954896, 0.09495313370336844, 0.17214297504243992, 0.10048428459094882]}, "mutation_prompt": null}
{"id": "3a0c90c5-49b0-46b5-9ade-67a206574e54", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * (1 - evals / self.budget)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.9 + 0.1 * evals / self.budget)  # Changed\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate  # Changed\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance exploration by introducing adaptive crossover and mutation strategies.", "configspace": "", "generation": 12, "fitness": 0.3236586242983717, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "6e35a1bf-165f-440b-9614-0d9b861c1d1e", "metadata": {"aucs": [0.8261977198060434, 0.839848865896085, 0.8344155581813965, 0.8120904706017745, 0.8367583100812506, 0.8396481645668614, 0.8430248419087196, 0.8365878864218924, 0.8295960907216575, 0.6471926970782139, 0.6808886258013301, 0.6791442266224437, 0.6273872680961139, 0.6372514679964442, 0.7130525921110451, 0.6622914317312055, 0.7009070859336826, 0.7085391485567629, 0.08383273841733985, 0.145432972037977, 0.17797702434405038, 0.1513796547569255, 0.1543077331084396, 0.16838404916846172, 0.13166086876116223, 0.12018661742788006, 0.12599901409069503, 0.13207587277196164, 0.13395996063872795, 0.09588053866455926, 0.13972944032465728, 0.11244732997126616, 0.17004970258485663, 0.10441397166970512, 0.09144634608100655, 0.13470878999929714, 0.9681624848600466, 0.9774257365423846, 0.9715860944486236, 0.9642632669742988, 0.9763280262847283, 0.9643969577051285, 0.9722103335146832, 0.9772997710654082, 0.9776386265581414, 0.7350234914285048, 0.7070892776760433, 0.7513006087776942, 0.743817038919089, 0.7191519829685822, 0.7310621974737725, 0.7450920397946244, 0.7355593540919689, 0.7286092110027312, 0.22477536444461466, 0.8325865821738722, 0.22407868711498002, 0.21353714553977932, 0.36798703962947676, 0.18830196711752745, 0.17222957459667487, 0.8390185972125753, 0.2256339814931625, 0.2306870466101213, 0.14352103941982242, 0.12385441920728879, 0.10719683780756262, 0.11970262516686614, 0.2287932077772944, 0.12567903193249463, 0.2279343825059439, 0.21239749370196492, 0.23713667112476378, 0.19266711793896552, 0.2292163393577239, 0.2674291316676668, 0.28446609211909013, 0.23860439802669076, 0.24443033875887799, 0.12569146985499224, 0.25831277331770874, 9.999999999998899e-05, 0.03589957286531664, 0.0037551618115881924, 0.009678410641588364, 9.999999999998899e-05, 0.032441734278229495, 0.03970917353526837, 9.999999999998899e-05, 0.010691407398333519, 0.20706859576538295, 0.03936651327861218, 0.07591288077281966, 0.08180036114176115, 0.028896684155559016, 0.08457313154128099, 0.14369406850150934, 0.09051110356251268, 0.05824902501751239, 0.033897220267444905, 0.03263422961879037, 0.29294017004514217, 0.1324197058409814, 0.2507225511379546, 0.12157495432793353, 0.09999557048718233, 0.08925487306785285, 0.1161962421903574, 0.07998039527622347, 0.08199256223979157, 0.14192110202939479, 0.17059138028184184, 0.1689917053747313, 0.13409496650914443, 0.3029432625906354, 0.1918828236700444, 0.08382562304508956, 0.5167319417326934, 0.6205233758091381, 0.5550285937239292, 0.5515899937970947, 0.5702752463350705, 0.36107659416565985, 0.5817643864156992, 0.5549019759296006, 0.5826963436864326, 0.09445089279746122, 0.11092126218165432, 0.06471899618746213, 0.09366298529338601, 0.15071611863303902, 0.15283889500833936, 0.1010134532001391, 0.17327927161610057, 0.12652566044608338, 0.31036636902371084, 0.22134935782760612, 0.19848086637156137, 0.2432509201345754, 0.331967495351714, 0.29966920401258734, 0.26874732185835837, 0.19690206196188909, 0.172650970047724, 0.4091651839866963, 0.24421791687876848, 0.32882332943630865, 0.4696006072616975, 0.5264974616926431, 0.32626044794923237, 0.4779965981692028, 0.5444693894024293, 0.5656086082874265, 0.2877770718134194, 0.1754202907057979, 0.35035385619713233, 0.31752839022266954, 0.4662670500412298, 0.21486002407934812, 0.15676536230087001, 0.29019143162938754, 0.4250484551234899, 0.22481436275975153, 0.2334464446618566, 0.21829923267624107, 0.2216538376463385, 0.19902441913065372, 0.23481587726638675, 0.24443566303944964, 0.1918607788466795, 0.23198516539484348, 0.24111760622895595, 0.21853722700979306, 0.19042357015002853, 0.2198504452507204, 0.22611132694632552, 0.21913930877449872, 0.19011910676874477, 0.19327853380873394, 0.2201012981221513, 0.18578347193204003, 0.16577022776958272, 0.15252085878142263, 0.17460261300912516, 0.8921243055691115, 0.84383445355659, 0.14208377053994936, 0.8506892871592822, 0.19963288163535653, 0.7833855807062564, 0.21070291856724366, 0.7275038125925364, 0.20866068747526467, 0.16827225425228665, 0.15459392828131624, 0.10425521523933345, 0.16484081556589458, 0.7860855719478306, 0.17907977877185732, 0.18862596399998566, 0.1891941959537895, 0.20042844529451953, 0.19853496990607944, 0.2107038479623018, 0.18259715500789664, 0.2046567412843282, 0.21037403627385542, 0.0914213063553172, 0.08875014089925282, 0.08748448156907418, 0.0992905775139068, 0.09540069547867747, 0.08942493528912654, 0.09290954331336543, 0.14562000930212438, 0.10946904157914628]}, "mutation_prompt": null}
{"id": "463465a2-723d-49f3-81ab-9ec91340fe7c", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * (1 - evals / self.budget)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                learning_rate = 0.9 * np.random.rand() + 0.1  # New adaptive learning rate\n                pop[i] = clip(pop[i] + learning_rate * pop_velocity[i])  # Apply learning rate\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance global exploration and convergence by integrating a stochasticity-based adaptive learning rate.", "configspace": "", "generation": 13, "fitness": 0.3073405559065268, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "6e35a1bf-165f-440b-9614-0d9b861c1d1e", "metadata": {"aucs": [0.8368715124793352, 0.8344837409787914, 0.8475888337899339, 0.8131271985558959, 0.8256438532573251, 0.841360071418367, 0.8222774973400309, 0.8279163355477772, 0.8414045350148417, 0.3516957734351902, 0.6656827964003214, 0.29660497880719705, 0.5801930442998865, 0.33190330099468135, 0.27195879814187607, 0.2544841404488538, 0.6688773923872429, 0.6987099633485137, 0.1292761622745744, 0.17416179305646096, 0.12321226651411166, 0.12468863281972864, 0.11506656087645639, 0.14650001571989146, 0.10195494449865616, 0.1363499433801415, 0.11316843088449391, 0.10315841033341144, 0.14972522633501628, 0.10580023868587429, 0.11264349261958484, 0.10780702248366758, 0.11930604464268613, 0.0961623505013024, 0.1460586676421599, 0.08745722540557965, 0.9634367860849, 0.9619569818539375, 0.9692705460631258, 0.9484431372520786, 0.9659240331244334, 0.965546790819039, 0.9659120204379454, 0.9618341773775464, 0.9695291284482795, 0.5945728037241523, 0.48946894656206064, 0.7410217791605858, 0.2948026361603501, 0.19129702139994442, 0.45320378458655464, 0.6865990236125088, 0.5803262259466281, 0.5589040138349284, 0.22621015622148666, 0.8378074645395492, 0.2123056620070377, 0.27574001575752094, 0.2732930192806373, 0.2690092640384446, 0.23163848220788374, 0.23170635682969154, 0.3776532909972258, 0.12239860800458724, 0.17552040262736135, 0.1861562825306855, 0.36621097640267, 0.1301816531446207, 0.2411664516798394, 0.15710766936605014, 0.2859788114735441, 0.18715665759293965, 0.19185759287312476, 0.17605658364168597, 0.1505166002804743, 0.27029301435795616, 0.12599639204149682, 0.17681313735857007, 0.21648141861508396, 0.14848766882887288, 0.19085754002387856, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009186552379251367, 9.999999999998899e-05, 9.999999999998899e-05, 0.05142739582924716, 0.03756882749260748, 0.10334999649634447, 0.0882501582514118, 0.049080868485325446, 0.0961170528549945, 0.02109559170207742, 0.019568501619356304, 0.11129964108660972, 0.05571988853807397, 0.09581112286074167, 0.07916675079472912, 0.10410467521898059, 0.03337041022250109, 0.2215262897979019, 0.09372014398163553, 0.08715859859117303, 0.08585722147224883, 0.22571077823241192, 0.16056375229624353, 0.12564074204054632, 0.12949030429723696, 0.12841328278404107, 0.15507418756048774, 0.11790460680278703, 0.22230814345483718, 0.127766989911425, 0.11721220364122875, 0.07915768390477074, 0.07972148376533439, 0.4939891938820682, 0.5554494644039945, 0.5030913362773177, 0.5013011973046508, 0.5327887355607563, 0.5485611563706407, 0.6018886497442233, 0.5323264577739315, 0.5019454656716007, 0.12451879558488888, 0.1265861180922957, 0.13449217274783498, 0.09899722021140134, 0.11542295078944176, 0.12174026462517251, 0.12717015847011504, 0.0969516315135599, 0.11812229654858764, 0.18089852872182166, 0.4873056202363717, 0.19130797912958208, 0.2039153545807928, 0.24227079488027448, 0.38987589799914113, 0.1766961270348717, 0.24129200027220055, 0.2925462657391664, 0.4054670047081107, 0.4630302701797122, 0.28886568602482243, 0.36859380789802154, 0.2571772126575572, 0.37328632867270106, 0.4674516299922289, 0.7299072408831508, 0.4049535169841617, 0.2589311100631023, 0.3079395355005706, 0.3113026406907172, 0.24513814512039211, 0.2024076467303345, 0.2955941302720825, 0.20586471530862216, 0.35623291668091983, 0.1968324496569871, 0.23397364351968586, 0.24039357468075762, 0.221991788973683, 0.22570501177364366, 0.20390699596754347, 0.245494113859845, 0.2541533481108258, 0.19682071434278148, 0.20094203358928542, 0.22130134856812833, 0.19348355373358217, 0.1820509493726148, 0.1940732176879053, 0.19655736620987618, 0.2183571806192529, 0.1859207665635345, 0.20519523995473277, 0.20606069515750092, 0.18633938525538163, 0.18772223778278796, 0.15135919767773065, 0.8795513600479128, 0.1985605961086121, 0.862614664114917, 0.8715220657393014, 0.858842616818273, 0.19977227734022918, 0.8331039394473057, 0.21097819861046418, 0.8158166899949162, 0.33478099966619934, 0.15236142991216095, 0.15344391966169058, 0.6228944756841961, 0.7281705186993819, 0.7516083045517236, 0.19426818746996033, 0.18880520821601487, 0.1815355921362356, 0.21403665808806183, 0.20661122891265438, 0.19204184614049735, 0.1932444214660114, 0.18591441377189788, 0.18218247440613, 0.08796381689413424, 0.07747909949300957, 0.0972855415271735, 0.09100645227304682, 0.09276609144698489, 0.09628943447220595, 0.09845193541262565, 0.09934498965552063, 0.08730439118003519]}, "mutation_prompt": null}
{"id": "071ecca2-c3ef-4a89-9237-8218a9eeca60", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * (1 - evals / self.budget)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Improve convergence by implementing a dynamic population size strategy to balance exploration and exploitation.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6e35a1bf-165f-440b-9614-0d9b861c1d1e", "metadata": {"aucs": [0.838219559866757, 0.8356259710224565, 0.8434308157602466, 0.8057664586557362, 0.8226609578583792, 0.8340859113183443, 0.8320592301430555, 0.835804738148955, 0.8260049373667719, 0.6914294949102411, 0.6437561073438337, 0.6963491252872581, 0.6721571988400773, 0.677190702560813, 0.6898999418121012, 0.6592643635244493, 0.6435034322565195, 0.6816612896511116, 0.13382327121952475, 0.1150833916198073, 0.13775843712030578, 0.13709615872095204, 0.13470427998648304, 0.17197604210770479, 0.1267431633425078, 0.11443522034248343, 0.11159905238497125, 0.10430247375312263, 0.08594796391481163, 0.11661182466764952, 0.10326736484859012, 0.10609243535322765, 0.10915917277733733, 0.12594843793273958, 0.08711564785040915, 0.10261788283573225, 0.9638935672514, 0.9774257365423846, 0.975575736376211, 0.9646832184964033, 0.9763280262847283, 0.9699208812332638, 0.9720979375259196, 0.9772997710654082, 0.97558681268676, 0.7608075486116868, 0.7224278481035113, 0.7493556304770205, 0.724516966359491, 0.6938624454456874, 0.7302634874516224, 0.7426322662423326, 0.7488311260513352, 0.08570743530133373, 0.844844060194216, 0.20611642483115455, 0.3686269889314423, 0.2787960350053782, 0.2733443345861125, 0.1596889283713412, 0.3771809531654383, 0.2326638102722559, 0.23306530009768844, 0.23259169094780097, 0.23298052436307604, 0.17259810360834182, 0.24376879665606743, 0.1250889078357299, 0.22042386526770597, 0.2238857857187635, 0.23585687445061998, 0.22325299757813843, 0.2366511020802139, 0.20816774692586282, 0.23914166640355916, 0.2503738788232156, 0.12627280845891442, 0.2681024858135165, 0.23226203982408, 0.22704883368076012, 0.24570573673486928, 0.012722676155140111, 0.006805796379252715, 0.07395380116541361, 0.026881430031883813, 0.05308304739113867, 9.999999999998899e-05, 0.010967772741739878, 0.012411954980764861, 0.03311158826745819, 0.014339829631120682, 0.06686817640321063, 0.08765595816203275, 0.0959429011687416, 0.06385792439689653, 0.06956129909258102, 0.09272172239649057, 0.08327010686834257, 0.057486233211643256, 0.10503454030395587, 0.0444653457107812, 0.07343706671132655, 0.25080190577620964, 0.11903074856049356, 0.07894834490059421, 0.1567934902516468, 0.11926608164596197, 0.08960665132648338, 0.04108761983972142, 0.3722143202286675, 0.22686358951568375, 0.13796115821195254, 0.11419092769706762, 0.07206417272713883, 0.20641008726633625, 0.15039349918274625, 0.10330130429875595, 0.5236040055711821, 0.5676129135190826, 0.5316982260201883, 0.5591251472037287, 0.5476403738120039, 0.5479879364039093, 0.5546053118976031, 0.5415500307594008, 0.5341889730083786, 0.14107501256321897, 0.11146783954713357, 0.10191166416203978, 0.11644098177807083, 0.1342957327055888, 0.09645905816879874, 0.0824378735800323, 0.10997317002136353, 0.13761907599412893, 0.2867720501778733, 0.20847863726109594, 0.190110188977058, 0.3005984649883895, 0.2920342129108596, 0.37383119846371826, 0.14534033971080085, 0.13804718904764213, 0.20605196104560308, 0.29959587393697895, 0.4288528966969075, 0.28974033790130127, 0.5850293214719848, 0.46775047615420406, 0.5109672447810876, 0.46425875277097817, 0.5649325566827976, 0.5346317828789562, 0.25620949629141354, 0.2412505923027276, 0.2738177257544888, 0.2650821919697186, 0.30773554293903294, 0.2252995150559276, 0.19343465907583168, 0.29759130374024, 0.2926865451013134, 0.27687795537328885, 0.23535724814567294, 0.2369768644015282, 0.23875522120983783, 0.2269814263933796, 0.2017395854929076, 0.23285839566717426, 0.23649766825719454, 0.25375521338938023, 0.21972215124974626, 0.19732263053477594, 0.18553778073899818, 0.18894753498717332, 0.18869810037936097, 0.20270941764403938, 0.7539674896524837, 0.696159776810124, 0.2232246200301239, 0.18639883926878364, 0.18377606418694337, 0.15278718334312602, 0.17498471133356475, 0.19896725376111601, 0.8712535944811433, 0.7739476496566491, 0.8314684093305071, 0.20079534552200273, 0.7928387110774869, 0.16916730738036823, 0.7673378359307677, 0.45426336525434785, 0.16826749030608368, 0.16513236637503337, 0.10405295319796204, 0.16471870841144898, 0.8299447221160402, 0.19498582095333872, 0.20137519164340045, 0.1899704443776704, 0.20426332414495485, 0.20345636114334842, 0.18049366524953603, 0.19267912551194044, 0.18174885084419634, 0.194259088248376, 0.09076045507675756, 0.10958789017008963, 0.08871265184805177, 0.10140028968961301, 0.07809415736467451, 0.13851603712954896, 0.09495313370336844, 0.17214297504243992, 0.10048428459094882]}, "mutation_prompt": null}
{"id": "0f22ab21-bf94-484a-9c67-ac60876cc860", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * (1 - evals / self.budget)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Improve convergence by implementing a dynamic population size strategy to balance exploration and exploitation.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6e35a1bf-165f-440b-9614-0d9b861c1d1e", "metadata": {"aucs": [0.838219559866757, 0.8356259710224565, 0.8434308157602466, 0.8057664586557362, 0.8226609578583792, 0.8340859113183443, 0.8320592301430555, 0.835804738148955, 0.8260049373667719, 0.6914294949102411, 0.6437561073438337, 0.6963491252872581, 0.6721571988400773, 0.677190702560813, 0.6898999418121012, 0.6592643635244493, 0.6435034322565195, 0.6816612896511116, 0.13382327121952475, 0.1150833916198073, 0.13775843712030578, 0.13709615872095204, 0.13470427998648304, 0.17197604210770479, 0.1267431633425078, 0.11443522034248343, 0.11159905238497125, 0.10430247375312263, 0.08594796391481163, 0.11661182466764952, 0.10326736484859012, 0.10609243535322765, 0.10915917277733733, 0.12594843793273958, 0.08711564785040915, 0.10261788283573225, 0.9638935672514, 0.9774257365423846, 0.975575736376211, 0.9646832184964033, 0.9763280262847283, 0.9699208812332638, 0.9720979375259196, 0.9772997710654082, 0.97558681268676, 0.7608075486116868, 0.7224278481035113, 0.7493556304770205, 0.724516966359491, 0.6938624454456874, 0.7302634874516224, 0.7426322662423326, 0.7488311260513352, 0.08570743530133373, 0.844844060194216, 0.20611642483115455, 0.3686269889314423, 0.2787960350053782, 0.2733443345861125, 0.1596889283713412, 0.3771809531654383, 0.2326638102722559, 0.23306530009768844, 0.23259169094780097, 0.23298052436307604, 0.17259810360834182, 0.24376879665606743, 0.1250889078357299, 0.22042386526770597, 0.2238857857187635, 0.23585687445061998, 0.22325299757813843, 0.2366511020802139, 0.20816774692586282, 0.23914166640355916, 0.2503738788232156, 0.12627280845891442, 0.2681024858135165, 0.23226203982408, 0.22704883368076012, 0.24570573673486928, 0.012722676155140111, 0.006805796379252715, 0.07395380116541361, 0.026881430031883813, 0.05308304739113867, 9.999999999998899e-05, 0.010967772741739878, 0.012411954980764861, 0.03311158826745819, 0.014339829631120682, 0.06686817640321063, 0.08765595816203275, 0.0959429011687416, 0.06385792439689653, 0.06956129909258102, 0.09272172239649057, 0.08327010686834257, 0.057486233211643256, 0.10503454030395587, 0.0444653457107812, 0.07343706671132655, 0.25080190577620964, 0.11903074856049356, 0.07894834490059421, 0.1567934902516468, 0.11926608164596197, 0.08960665132648338, 0.04108761983972142, 0.3722143202286675, 0.22686358951568375, 0.13796115821195254, 0.11419092769706762, 0.07206417272713883, 0.20641008726633625, 0.15039349918274625, 0.10330130429875595, 0.5236040055711821, 0.5676129135190826, 0.5316982260201883, 0.5591251472037287, 0.5476403738120039, 0.5479879364039093, 0.5546053118976031, 0.5415500307594008, 0.5341889730083786, 0.14107501256321897, 0.11146783954713357, 0.10191166416203978, 0.11644098177807083, 0.1342957327055888, 0.09645905816879874, 0.0824378735800323, 0.10997317002136353, 0.13761907599412893, 0.2867720501778733, 0.20847863726109594, 0.190110188977058, 0.3005984649883895, 0.2920342129108596, 0.37383119846371826, 0.14534033971080085, 0.13804718904764213, 0.20605196104560308, 0.29959587393697895, 0.4288528966969075, 0.28974033790130127, 0.5850293214719848, 0.46775047615420406, 0.5109672447810876, 0.46425875277097817, 0.5649325566827976, 0.5346317828789562, 0.25620949629141354, 0.2412505923027276, 0.2738177257544888, 0.2650821919697186, 0.30773554293903294, 0.2252995150559276, 0.19343465907583168, 0.29759130374024, 0.2926865451013134, 0.27687795537328885, 0.23535724814567294, 0.2369768644015282, 0.23875522120983783, 0.2269814263933796, 0.2017395854929076, 0.23285839566717426, 0.23649766825719454, 0.25375521338938023, 0.21972215124974626, 0.19732263053477594, 0.18553778073899818, 0.18894753498717332, 0.18869810037936097, 0.20270941764403938, 0.7539674896524837, 0.696159776810124, 0.2232246200301239, 0.18639883926878364, 0.18377606418694337, 0.15278718334312602, 0.17498471133356475, 0.19896725376111601, 0.8712535944811433, 0.7739476496566491, 0.8314684093305071, 0.20079534552200273, 0.7928387110774869, 0.16916730738036823, 0.7673378359307677, 0.45426336525434785, 0.16826749030608368, 0.16513236637503337, 0.10405295319796204, 0.16471870841144898, 0.8299447221160402, 0.19498582095333872, 0.20137519164340045, 0.1899704443776704, 0.20426332414495485, 0.20345636114334842, 0.18049366524953603, 0.19267912551194044, 0.18174885084419634, 0.194259088248376, 0.09076045507675756, 0.10958789017008963, 0.08871265184805177, 0.10140028968961301, 0.07809415736467451, 0.13851603712954896, 0.09495313370336844, 0.17214297504243992, 0.10048428459094882]}, "mutation_prompt": null}
{"id": "c6468408-e67c-4cf9-a932-44d564cdec9f", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * (1 - evals / self.budget)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Improve convergence by implementing a dynamic population size strategy to balance exploration and exploitation.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6e35a1bf-165f-440b-9614-0d9b861c1d1e", "metadata": {"aucs": [0.838219559866757, 0.8356259710224565, 0.8434308157602466, 0.8057664586557362, 0.8226609578583792, 0.8340859113183443, 0.8320592301430555, 0.835804738148955, 0.8260049373667719, 0.6914294949102411, 0.6437561073438337, 0.6963491252872581, 0.6721571988400773, 0.677190702560813, 0.6898999418121012, 0.6592643635244493, 0.6435034322565195, 0.6816612896511116, 0.13382327121952475, 0.1150833916198073, 0.13775843712030578, 0.13709615872095204, 0.13470427998648304, 0.17197604210770479, 0.1267431633425078, 0.11443522034248343, 0.11159905238497125, 0.10430247375312263, 0.08594796391481163, 0.11661182466764952, 0.10326736484859012, 0.10609243535322765, 0.10915917277733733, 0.12594843793273958, 0.08711564785040915, 0.10261788283573225, 0.9638935672514, 0.9774257365423846, 0.975575736376211, 0.9646832184964033, 0.9763280262847283, 0.9699208812332638, 0.9720979375259196, 0.9772997710654082, 0.97558681268676, 0.7608075486116868, 0.7224278481035113, 0.7493556304770205, 0.724516966359491, 0.6938624454456874, 0.7302634874516224, 0.7426322662423326, 0.7488311260513352, 0.08570743530133373, 0.844844060194216, 0.20611642483115455, 0.3686269889314423, 0.2787960350053782, 0.2733443345861125, 0.1596889283713412, 0.3771809531654383, 0.2326638102722559, 0.23306530009768844, 0.23259169094780097, 0.23298052436307604, 0.17259810360834182, 0.24376879665606743, 0.1250889078357299, 0.22042386526770597, 0.2238857857187635, 0.23585687445061998, 0.22325299757813843, 0.2366511020802139, 0.20816774692586282, 0.23914166640355916, 0.2503738788232156, 0.12627280845891442, 0.2681024858135165, 0.23226203982408, 0.22704883368076012, 0.24570573673486928, 0.012722676155140111, 0.006805796379252715, 0.07395380116541361, 0.026881430031883813, 0.05308304739113867, 9.999999999998899e-05, 0.010967772741739878, 0.012411954980764861, 0.03311158826745819, 0.014339829631120682, 0.06686817640321063, 0.08765595816203275, 0.0959429011687416, 0.06385792439689653, 0.06956129909258102, 0.09272172239649057, 0.08327010686834257, 0.057486233211643256, 0.10503454030395587, 0.0444653457107812, 0.07343706671132655, 0.25080190577620964, 0.11903074856049356, 0.07894834490059421, 0.1567934902516468, 0.11926608164596197, 0.08960665132648338, 0.04108761983972142, 0.3722143202286675, 0.22686358951568375, 0.13796115821195254, 0.11419092769706762, 0.07206417272713883, 0.20641008726633625, 0.15039349918274625, 0.10330130429875595, 0.5236040055711821, 0.5676129135190826, 0.5316982260201883, 0.5591251472037287, 0.5476403738120039, 0.5479879364039093, 0.5546053118976031, 0.5415500307594008, 0.5341889730083786, 0.14107501256321897, 0.11146783954713357, 0.10191166416203978, 0.11644098177807083, 0.1342957327055888, 0.09645905816879874, 0.0824378735800323, 0.10997317002136353, 0.13761907599412893, 0.2867720501778733, 0.20847863726109594, 0.190110188977058, 0.3005984649883895, 0.2920342129108596, 0.37383119846371826, 0.14534033971080085, 0.13804718904764213, 0.20605196104560308, 0.29959587393697895, 0.4288528966969075, 0.28974033790130127, 0.5850293214719848, 0.46775047615420406, 0.5109672447810876, 0.46425875277097817, 0.5649325566827976, 0.5346317828789562, 0.25620949629141354, 0.2412505923027276, 0.2738177257544888, 0.2650821919697186, 0.30773554293903294, 0.2252995150559276, 0.19343465907583168, 0.29759130374024, 0.2926865451013134, 0.27687795537328885, 0.23535724814567294, 0.2369768644015282, 0.23875522120983783, 0.2269814263933796, 0.2017395854929076, 0.23285839566717426, 0.23649766825719454, 0.25375521338938023, 0.21972215124974626, 0.19732263053477594, 0.18553778073899818, 0.18894753498717332, 0.18869810037936097, 0.20270941764403938, 0.7539674896524837, 0.696159776810124, 0.2232246200301239, 0.18639883926878364, 0.18377606418694337, 0.15278718334312602, 0.17498471133356475, 0.19896725376111601, 0.8712535944811433, 0.7739476496566491, 0.8314684093305071, 0.20079534552200273, 0.7928387110774869, 0.16916730738036823, 0.7673378359307677, 0.45426336525434785, 0.16826749030608368, 0.16513236637503337, 0.10405295319796204, 0.16471870841144898, 0.8299447221160402, 0.19498582095333872, 0.20137519164340045, 0.1899704443776704, 0.20426332414495485, 0.20345636114334842, 0.18049366524953603, 0.19267912551194044, 0.18174885084419634, 0.194259088248376, 0.09076045507675756, 0.10958789017008963, 0.08871265184805177, 0.10140028968961301, 0.07809415736467451, 0.13851603712954896, 0.09495313370336844, 0.17214297504243992, 0.10048428459094882]}, "mutation_prompt": null}
{"id": "655d6849-5cb1-4963-804f-3ac4ed90266a", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * (1 - evals / self.budget)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Improve convergence by implementing a dynamic population size strategy to balance exploration and exploitation.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6e35a1bf-165f-440b-9614-0d9b861c1d1e", "metadata": {"aucs": [0.838219559866757, 0.8356259710224565, 0.8434308157602466, 0.8057664586557362, 0.8226609578583792, 0.8340859113183443, 0.8320592301430555, 0.835804738148955, 0.8260049373667719, 0.6914294949102411, 0.6437561073438337, 0.6963491252872581, 0.6721571988400773, 0.677190702560813, 0.6898999418121012, 0.6592643635244493, 0.6435034322565195, 0.6816612896511116, 0.13382327121952475, 0.1150833916198073, 0.13775843712030578, 0.13709615872095204, 0.13470427998648304, 0.17197604210770479, 0.1267431633425078, 0.11443522034248343, 0.11159905238497125, 0.10430247375312263, 0.08594796391481163, 0.11661182466764952, 0.10326736484859012, 0.10609243535322765, 0.10915917277733733, 0.12594843793273958, 0.08711564785040915, 0.10261788283573225, 0.9638935672514, 0.9774257365423846, 0.975575736376211, 0.9646832184964033, 0.9763280262847283, 0.9699208812332638, 0.9720979375259196, 0.9772997710654082, 0.97558681268676, 0.7608075486116868, 0.7224278481035113, 0.7493556304770205, 0.724516966359491, 0.6938624454456874, 0.7302634874516224, 0.7426322662423326, 0.7488311260513352, 0.08570743530133373, 0.844844060194216, 0.20611642483115455, 0.3686269889314423, 0.2787960350053782, 0.2733443345861125, 0.1596889283713412, 0.3771809531654383, 0.2326638102722559, 0.23306530009768844, 0.23259169094780097, 0.23298052436307604, 0.17259810360834182, 0.24376879665606743, 0.1250889078357299, 0.22042386526770597, 0.2238857857187635, 0.23585687445061998, 0.22325299757813843, 0.2366511020802139, 0.20816774692586282, 0.23914166640355916, 0.2503738788232156, 0.12627280845891442, 0.2681024858135165, 0.23226203982408, 0.22704883368076012, 0.24570573673486928, 0.012722676155140111, 0.006805796379252715, 0.07395380116541361, 0.026881430031883813, 0.05308304739113867, 9.999999999998899e-05, 0.010967772741739878, 0.012411954980764861, 0.03311158826745819, 0.014339829631120682, 0.06686817640321063, 0.08765595816203275, 0.0959429011687416, 0.06385792439689653, 0.06956129909258102, 0.09272172239649057, 0.08327010686834257, 0.057486233211643256, 0.10503454030395587, 0.0444653457107812, 0.07343706671132655, 0.25080190577620964, 0.11903074856049356, 0.07894834490059421, 0.1567934902516468, 0.11926608164596197, 0.08960665132648338, 0.04108761983972142, 0.3722143202286675, 0.22686358951568375, 0.13796115821195254, 0.11419092769706762, 0.07206417272713883, 0.20641008726633625, 0.15039349918274625, 0.10330130429875595, 0.5236040055711821, 0.5676129135190826, 0.5316982260201883, 0.5591251472037287, 0.5476403738120039, 0.5479879364039093, 0.5546053118976031, 0.5415500307594008, 0.5341889730083786, 0.14107501256321897, 0.11146783954713357, 0.10191166416203978, 0.11644098177807083, 0.1342957327055888, 0.09645905816879874, 0.0824378735800323, 0.10997317002136353, 0.13761907599412893, 0.2867720501778733, 0.20847863726109594, 0.190110188977058, 0.3005984649883895, 0.2920342129108596, 0.37383119846371826, 0.14534033971080085, 0.13804718904764213, 0.20605196104560308, 0.29959587393697895, 0.4288528966969075, 0.28974033790130127, 0.5850293214719848, 0.46775047615420406, 0.5109672447810876, 0.46425875277097817, 0.5649325566827976, 0.5346317828789562, 0.25620949629141354, 0.2412505923027276, 0.2738177257544888, 0.2650821919697186, 0.30773554293903294, 0.2252995150559276, 0.19343465907583168, 0.29759130374024, 0.2926865451013134, 0.27687795537328885, 0.23535724814567294, 0.2369768644015282, 0.23875522120983783, 0.2269814263933796, 0.2017395854929076, 0.23285839566717426, 0.23649766825719454, 0.25375521338938023, 0.21972215124974626, 0.19732263053477594, 0.18553778073899818, 0.18894753498717332, 0.18869810037936097, 0.20270941764403938, 0.7539674896524837, 0.696159776810124, 0.2232246200301239, 0.18639883926878364, 0.18377606418694337, 0.15278718334312602, 0.17498471133356475, 0.19896725376111601, 0.8712535944811433, 0.7739476496566491, 0.8314684093305071, 0.20079534552200273, 0.7928387110774869, 0.16916730738036823, 0.7673378359307677, 0.45426336525434785, 0.16826749030608368, 0.16513236637503337, 0.10405295319796204, 0.16471870841144898, 0.8299447221160402, 0.19498582095333872, 0.20137519164340045, 0.1899704443776704, 0.20426332414495485, 0.20345636114334842, 0.18049366524953603, 0.19267912551194044, 0.18174885084419634, 0.194259088248376, 0.09076045507675756, 0.10958789017008963, 0.08871265184805177, 0.10140028968961301, 0.07809415736467451, 0.13851603712954896, 0.09495313370336844, 0.17214297504243992, 0.10048428459094882]}, "mutation_prompt": null}
{"id": "1bcf4763-d5f4-40ca-9e47-cbc043da1c75", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * (1 - evals / self.budget)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Improve convergence by implementing a dynamic population size strategy to balance exploration and exploitation.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6e35a1bf-165f-440b-9614-0d9b861c1d1e", "metadata": {"aucs": [0.838219559866757, 0.8356259710224565, 0.8434308157602466, 0.8057664586557362, 0.8226609578583792, 0.8340859113183443, 0.8320592301430555, 0.835804738148955, 0.8260049373667719, 0.6914294949102411, 0.6437561073438337, 0.6963491252872581, 0.6721571988400773, 0.677190702560813, 0.6898999418121012, 0.6592643635244493, 0.6435034322565195, 0.6816612896511116, 0.13382327121952475, 0.1150833916198073, 0.13775843712030578, 0.13709615872095204, 0.13470427998648304, 0.17197604210770479, 0.1267431633425078, 0.11443522034248343, 0.11159905238497125, 0.10430247375312263, 0.08594796391481163, 0.11661182466764952, 0.10326736484859012, 0.10609243535322765, 0.10915917277733733, 0.12594843793273958, 0.08711564785040915, 0.10261788283573225, 0.9638935672514, 0.9774257365423846, 0.975575736376211, 0.9646832184964033, 0.9763280262847283, 0.9699208812332638, 0.9720979375259196, 0.9772997710654082, 0.97558681268676, 0.7608075486116868, 0.7224278481035113, 0.7493556304770205, 0.724516966359491, 0.6938624454456874, 0.7302634874516224, 0.7426322662423326, 0.7488311260513352, 0.08570743530133373, 0.844844060194216, 0.20611642483115455, 0.3686269889314423, 0.2787960350053782, 0.2733443345861125, 0.1596889283713412, 0.3771809531654383, 0.2326638102722559, 0.23306530009768844, 0.23259169094780097, 0.23298052436307604, 0.17259810360834182, 0.24376879665606743, 0.1250889078357299, 0.22042386526770597, 0.2238857857187635, 0.23585687445061998, 0.22325299757813843, 0.2366511020802139, 0.20816774692586282, 0.23914166640355916, 0.2503738788232156, 0.12627280845891442, 0.2681024858135165, 0.23226203982408, 0.22704883368076012, 0.24570573673486928, 0.012722676155140111, 0.006805796379252715, 0.07395380116541361, 0.026881430031883813, 0.05308304739113867, 9.999999999998899e-05, 0.010967772741739878, 0.012411954980764861, 0.03311158826745819, 0.014339829631120682, 0.06686817640321063, 0.08765595816203275, 0.0959429011687416, 0.06385792439689653, 0.06956129909258102, 0.09272172239649057, 0.08327010686834257, 0.057486233211643256, 0.10503454030395587, 0.0444653457107812, 0.07343706671132655, 0.25080190577620964, 0.11903074856049356, 0.07894834490059421, 0.1567934902516468, 0.11926608164596197, 0.08960665132648338, 0.04108761983972142, 0.3722143202286675, 0.22686358951568375, 0.13796115821195254, 0.11419092769706762, 0.07206417272713883, 0.20641008726633625, 0.15039349918274625, 0.10330130429875595, 0.5236040055711821, 0.5676129135190826, 0.5316982260201883, 0.5591251472037287, 0.5476403738120039, 0.5479879364039093, 0.5546053118976031, 0.5415500307594008, 0.5341889730083786, 0.14107501256321897, 0.11146783954713357, 0.10191166416203978, 0.11644098177807083, 0.1342957327055888, 0.09645905816879874, 0.0824378735800323, 0.10997317002136353, 0.13761907599412893, 0.2867720501778733, 0.20847863726109594, 0.190110188977058, 0.3005984649883895, 0.2920342129108596, 0.37383119846371826, 0.14534033971080085, 0.13804718904764213, 0.20605196104560308, 0.29959587393697895, 0.4288528966969075, 0.28974033790130127, 0.5850293214719848, 0.46775047615420406, 0.5109672447810876, 0.46425875277097817, 0.5649325566827976, 0.5346317828789562, 0.25620949629141354, 0.2412505923027276, 0.2738177257544888, 0.2650821919697186, 0.30773554293903294, 0.2252995150559276, 0.19343465907583168, 0.29759130374024, 0.2926865451013134, 0.27687795537328885, 0.23535724814567294, 0.2369768644015282, 0.23875522120983783, 0.2269814263933796, 0.2017395854929076, 0.23285839566717426, 0.23649766825719454, 0.25375521338938023, 0.21972215124974626, 0.19732263053477594, 0.18553778073899818, 0.18894753498717332, 0.18869810037936097, 0.20270941764403938, 0.7539674896524837, 0.696159776810124, 0.2232246200301239, 0.18639883926878364, 0.18377606418694337, 0.15278718334312602, 0.17498471133356475, 0.19896725376111601, 0.8712535944811433, 0.7739476496566491, 0.8314684093305071, 0.20079534552200273, 0.7928387110774869, 0.16916730738036823, 0.7673378359307677, 0.45426336525434785, 0.16826749030608368, 0.16513236637503337, 0.10405295319796204, 0.16471870841144898, 0.8299447221160402, 0.19498582095333872, 0.20137519164340045, 0.1899704443776704, 0.20426332414495485, 0.20345636114334842, 0.18049366524953603, 0.19267912551194044, 0.18174885084419634, 0.194259088248376, 0.09076045507675756, 0.10958789017008963, 0.08871265184805177, 0.10140028968961301, 0.07809415736467451, 0.13851603712954896, 0.09495313370336844, 0.17214297504243992, 0.10048428459094882]}, "mutation_prompt": null}
{"id": "69d9bf62-3864-49c1-abc1-673882773ca4", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * (1 - evals / self.budget)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Improve convergence by implementing a dynamic population size strategy to balance exploration and exploitation.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6e35a1bf-165f-440b-9614-0d9b861c1d1e", "metadata": {"aucs": [0.838219559866757, 0.8356259710224565, 0.8434308157602466, 0.8057664586557362, 0.8226609578583792, 0.8340859113183443, 0.8320592301430555, 0.835804738148955, 0.8260049373667719, 0.6914294949102411, 0.6437561073438337, 0.6963491252872581, 0.6721571988400773, 0.677190702560813, 0.6898999418121012, 0.6592643635244493, 0.6435034322565195, 0.6816612896511116, 0.13382327121952475, 0.1150833916198073, 0.13775843712030578, 0.13709615872095204, 0.13470427998648304, 0.17197604210770479, 0.1267431633425078, 0.11443522034248343, 0.11159905238497125, 0.10430247375312263, 0.08594796391481163, 0.11661182466764952, 0.10326736484859012, 0.10609243535322765, 0.10915917277733733, 0.12594843793273958, 0.08711564785040915, 0.10261788283573225, 0.9638935672514, 0.9774257365423846, 0.975575736376211, 0.9646832184964033, 0.9763280262847283, 0.9699208812332638, 0.9720979375259196, 0.9772997710654082, 0.97558681268676, 0.7608075486116868, 0.7224278481035113, 0.7493556304770205, 0.724516966359491, 0.6938624454456874, 0.7302634874516224, 0.7426322662423326, 0.7488311260513352, 0.08570743530133373, 0.844844060194216, 0.20611642483115455, 0.3686269889314423, 0.2787960350053782, 0.2733443345861125, 0.1596889283713412, 0.3771809531654383, 0.2326638102722559, 0.23306530009768844, 0.23259169094780097, 0.23298052436307604, 0.17259810360834182, 0.24376879665606743, 0.1250889078357299, 0.22042386526770597, 0.2238857857187635, 0.23585687445061998, 0.22325299757813843, 0.2366511020802139, 0.20816774692586282, 0.23914166640355916, 0.2503738788232156, 0.12627280845891442, 0.2681024858135165, 0.23226203982408, 0.22704883368076012, 0.24570573673486928, 0.012722676155140111, 0.006805796379252715, 0.07395380116541361, 0.026881430031883813, 0.05308304739113867, 9.999999999998899e-05, 0.010967772741739878, 0.012411954980764861, 0.03311158826745819, 0.014339829631120682, 0.06686817640321063, 0.08765595816203275, 0.0959429011687416, 0.06385792439689653, 0.06956129909258102, 0.09272172239649057, 0.08327010686834257, 0.057486233211643256, 0.10503454030395587, 0.0444653457107812, 0.07343706671132655, 0.25080190577620964, 0.11903074856049356, 0.07894834490059421, 0.1567934902516468, 0.11926608164596197, 0.08960665132648338, 0.04108761983972142, 0.3722143202286675, 0.22686358951568375, 0.13796115821195254, 0.11419092769706762, 0.07206417272713883, 0.20641008726633625, 0.15039349918274625, 0.10330130429875595, 0.5236040055711821, 0.5676129135190826, 0.5316982260201883, 0.5591251472037287, 0.5476403738120039, 0.5479879364039093, 0.5546053118976031, 0.5415500307594008, 0.5341889730083786, 0.14107501256321897, 0.11146783954713357, 0.10191166416203978, 0.11644098177807083, 0.1342957327055888, 0.09645905816879874, 0.0824378735800323, 0.10997317002136353, 0.13761907599412893, 0.2867720501778733, 0.20847863726109594, 0.190110188977058, 0.3005984649883895, 0.2920342129108596, 0.37383119846371826, 0.14534033971080085, 0.13804718904764213, 0.20605196104560308, 0.29959587393697895, 0.4288528966969075, 0.28974033790130127, 0.5850293214719848, 0.46775047615420406, 0.5109672447810876, 0.46425875277097817, 0.5649325566827976, 0.5346317828789562, 0.25620949629141354, 0.2412505923027276, 0.2738177257544888, 0.2650821919697186, 0.30773554293903294, 0.2252995150559276, 0.19343465907583168, 0.29759130374024, 0.2926865451013134, 0.27687795537328885, 0.23535724814567294, 0.2369768644015282, 0.23875522120983783, 0.2269814263933796, 0.2017395854929076, 0.23285839566717426, 0.23649766825719454, 0.25375521338938023, 0.21972215124974626, 0.19732263053477594, 0.18553778073899818, 0.18894753498717332, 0.18869810037936097, 0.20270941764403938, 0.7539674896524837, 0.696159776810124, 0.2232246200301239, 0.18639883926878364, 0.18377606418694337, 0.15278718334312602, 0.17498471133356475, 0.19896725376111601, 0.8712535944811433, 0.7739476496566491, 0.8314684093305071, 0.20079534552200273, 0.7928387110774869, 0.16916730738036823, 0.7673378359307677, 0.45426336525434785, 0.16826749030608368, 0.16513236637503337, 0.10405295319796204, 0.16471870841144898, 0.8299447221160402, 0.19498582095333872, 0.20137519164340045, 0.1899704443776704, 0.20426332414495485, 0.20345636114334842, 0.18049366524953603, 0.19267912551194044, 0.18174885084419634, 0.194259088248376, 0.09076045507675756, 0.10958789017008963, 0.08871265184805177, 0.10140028968961301, 0.07809415736467451, 0.13851603712954896, 0.09495313370336844, 0.17214297504243992, 0.10048428459094882]}, "mutation_prompt": null}
{"id": "cef2cd4e-b48d-41c1-9b4f-c8ff208dcc84", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * (1 - evals / self.budget)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Improve convergence by implementing a dynamic population size strategy to balance exploration and exploitation.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6e35a1bf-165f-440b-9614-0d9b861c1d1e", "metadata": {"aucs": [0.838219559866757, 0.8356259710224565, 0.8434308157602466, 0.8057664586557362, 0.8226609578583792, 0.8340859113183443, 0.8320592301430555, 0.835804738148955, 0.8260049373667719, 0.6914294949102411, 0.6437561073438337, 0.6963491252872581, 0.6721571988400773, 0.677190702560813, 0.6898999418121012, 0.6592643635244493, 0.6435034322565195, 0.6816612896511116, 0.13382327121952475, 0.1150833916198073, 0.13775843712030578, 0.13709615872095204, 0.13470427998648304, 0.17197604210770479, 0.1267431633425078, 0.11443522034248343, 0.11159905238497125, 0.10430247375312263, 0.08594796391481163, 0.11661182466764952, 0.10326736484859012, 0.10609243535322765, 0.10915917277733733, 0.12594843793273958, 0.08711564785040915, 0.10261788283573225, 0.9638935672514, 0.9774257365423846, 0.975575736376211, 0.9646832184964033, 0.9763280262847283, 0.9699208812332638, 0.9720979375259196, 0.9772997710654082, 0.97558681268676, 0.7608075486116868, 0.7224278481035113, 0.7493556304770205, 0.724516966359491, 0.6938624454456874, 0.7302634874516224, 0.7426322662423326, 0.7488311260513352, 0.08570743530133373, 0.844844060194216, 0.20611642483115455, 0.3686269889314423, 0.2787960350053782, 0.2733443345861125, 0.1596889283713412, 0.3771809531654383, 0.2326638102722559, 0.23306530009768844, 0.23259169094780097, 0.23298052436307604, 0.17259810360834182, 0.24376879665606743, 0.1250889078357299, 0.22042386526770597, 0.2238857857187635, 0.23585687445061998, 0.22325299757813843, 0.2366511020802139, 0.20816774692586282, 0.23914166640355916, 0.2503738788232156, 0.12627280845891442, 0.2681024858135165, 0.23226203982408, 0.22704883368076012, 0.24570573673486928, 0.012722676155140111, 0.006805796379252715, 0.07395380116541361, 0.026881430031883813, 0.05308304739113867, 9.999999999998899e-05, 0.010967772741739878, 0.012411954980764861, 0.03311158826745819, 0.014339829631120682, 0.06686817640321063, 0.08765595816203275, 0.0959429011687416, 0.06385792439689653, 0.06956129909258102, 0.09272172239649057, 0.08327010686834257, 0.057486233211643256, 0.10503454030395587, 0.0444653457107812, 0.07343706671132655, 0.25080190577620964, 0.11903074856049356, 0.07894834490059421, 0.1567934902516468, 0.11926608164596197, 0.08960665132648338, 0.04108761983972142, 0.3722143202286675, 0.22686358951568375, 0.13796115821195254, 0.11419092769706762, 0.07206417272713883, 0.20641008726633625, 0.15039349918274625, 0.10330130429875595, 0.5236040055711821, 0.5676129135190826, 0.5316982260201883, 0.5591251472037287, 0.5476403738120039, 0.5479879364039093, 0.5546053118976031, 0.5415500307594008, 0.5341889730083786, 0.14107501256321897, 0.11146783954713357, 0.10191166416203978, 0.11644098177807083, 0.1342957327055888, 0.09645905816879874, 0.0824378735800323, 0.10997317002136353, 0.13761907599412893, 0.2867720501778733, 0.20847863726109594, 0.190110188977058, 0.3005984649883895, 0.2920342129108596, 0.37383119846371826, 0.14534033971080085, 0.13804718904764213, 0.20605196104560308, 0.29959587393697895, 0.4288528966969075, 0.28974033790130127, 0.5850293214719848, 0.46775047615420406, 0.5109672447810876, 0.46425875277097817, 0.5649325566827976, 0.5346317828789562, 0.25620949629141354, 0.2412505923027276, 0.2738177257544888, 0.2650821919697186, 0.30773554293903294, 0.2252995150559276, 0.19343465907583168, 0.29759130374024, 0.2926865451013134, 0.27687795537328885, 0.23535724814567294, 0.2369768644015282, 0.23875522120983783, 0.2269814263933796, 0.2017395854929076, 0.23285839566717426, 0.23649766825719454, 0.25375521338938023, 0.21972215124974626, 0.19732263053477594, 0.18553778073899818, 0.18894753498717332, 0.18869810037936097, 0.20270941764403938, 0.7539674896524837, 0.696159776810124, 0.2232246200301239, 0.18639883926878364, 0.18377606418694337, 0.15278718334312602, 0.17498471133356475, 0.19896725376111601, 0.8712535944811433, 0.7739476496566491, 0.8314684093305071, 0.20079534552200273, 0.7928387110774869, 0.16916730738036823, 0.7673378359307677, 0.45426336525434785, 0.16826749030608368, 0.16513236637503337, 0.10405295319796204, 0.16471870841144898, 0.8299447221160402, 0.19498582095333872, 0.20137519164340045, 0.1899704443776704, 0.20426332414495485, 0.20345636114334842, 0.18049366524953603, 0.19267912551194044, 0.18174885084419634, 0.194259088248376, 0.09076045507675756, 0.10958789017008963, 0.08871265184805177, 0.10140028968961301, 0.07809415736467451, 0.13851603712954896, 0.09495313370336844, 0.17214297504243992, 0.10048428459094882]}, "mutation_prompt": null}
{"id": "66acb5f3-ac29-4daf-9e8d-e8840240aaf4", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * (1 - evals / self.budget)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Improve convergence by implementing a dynamic population size strategy to balance exploration and exploitation.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6e35a1bf-165f-440b-9614-0d9b861c1d1e", "metadata": {"aucs": [0.838219559866757, 0.8356259710224565, 0.8434308157602466, 0.8057664586557362, 0.8226609578583792, 0.8340859113183443, 0.8320592301430555, 0.835804738148955, 0.8260049373667719, 0.6914294949102411, 0.6437561073438337, 0.6963491252872581, 0.6721571988400773, 0.677190702560813, 0.6898999418121012, 0.6592643635244493, 0.6435034322565195, 0.6816612896511116, 0.13382327121952475, 0.1150833916198073, 0.13775843712030578, 0.13709615872095204, 0.13470427998648304, 0.17197604210770479, 0.1267431633425078, 0.11443522034248343, 0.11159905238497125, 0.10430247375312263, 0.08594796391481163, 0.11661182466764952, 0.10326736484859012, 0.10609243535322765, 0.10915917277733733, 0.12594843793273958, 0.08711564785040915, 0.10261788283573225, 0.9638935672514, 0.9774257365423846, 0.975575736376211, 0.9646832184964033, 0.9763280262847283, 0.9699208812332638, 0.9720979375259196, 0.9772997710654082, 0.97558681268676, 0.7608075486116868, 0.7224278481035113, 0.7493556304770205, 0.724516966359491, 0.6938624454456874, 0.7302634874516224, 0.7426322662423326, 0.7488311260513352, 0.08570743530133373, 0.844844060194216, 0.20611642483115455, 0.3686269889314423, 0.2787960350053782, 0.2733443345861125, 0.1596889283713412, 0.3771809531654383, 0.2326638102722559, 0.23306530009768844, 0.23259169094780097, 0.23298052436307604, 0.17259810360834182, 0.24376879665606743, 0.1250889078357299, 0.22042386526770597, 0.2238857857187635, 0.23585687445061998, 0.22325299757813843, 0.2366511020802139, 0.20816774692586282, 0.23914166640355916, 0.2503738788232156, 0.12627280845891442, 0.2681024858135165, 0.23226203982408, 0.22704883368076012, 0.24570573673486928, 0.012722676155140111, 0.006805796379252715, 0.07395380116541361, 0.026881430031883813, 0.05308304739113867, 9.999999999998899e-05, 0.010967772741739878, 0.012411954980764861, 0.03311158826745819, 0.014339829631120682, 0.06686817640321063, 0.08765595816203275, 0.0959429011687416, 0.06385792439689653, 0.06956129909258102, 0.09272172239649057, 0.08327010686834257, 0.057486233211643256, 0.10503454030395587, 0.0444653457107812, 0.07343706671132655, 0.25080190577620964, 0.11903074856049356, 0.07894834490059421, 0.1567934902516468, 0.11926608164596197, 0.08960665132648338, 0.04108761983972142, 0.3722143202286675, 0.22686358951568375, 0.13796115821195254, 0.11419092769706762, 0.07206417272713883, 0.20641008726633625, 0.15039349918274625, 0.10330130429875595, 0.5236040055711821, 0.5676129135190826, 0.5316982260201883, 0.5591251472037287, 0.5476403738120039, 0.5479879364039093, 0.5546053118976031, 0.5415500307594008, 0.5341889730083786, 0.14107501256321897, 0.11146783954713357, 0.10191166416203978, 0.11644098177807083, 0.1342957327055888, 0.09645905816879874, 0.0824378735800323, 0.10997317002136353, 0.13761907599412893, 0.2867720501778733, 0.20847863726109594, 0.190110188977058, 0.3005984649883895, 0.2920342129108596, 0.37383119846371826, 0.14534033971080085, 0.13804718904764213, 0.20605196104560308, 0.29959587393697895, 0.4288528966969075, 0.28974033790130127, 0.5850293214719848, 0.46775047615420406, 0.5109672447810876, 0.46425875277097817, 0.5649325566827976, 0.5346317828789562, 0.25620949629141354, 0.2412505923027276, 0.2738177257544888, 0.2650821919697186, 0.30773554293903294, 0.2252995150559276, 0.19343465907583168, 0.29759130374024, 0.2926865451013134, 0.27687795537328885, 0.23535724814567294, 0.2369768644015282, 0.23875522120983783, 0.2269814263933796, 0.2017395854929076, 0.23285839566717426, 0.23649766825719454, 0.25375521338938023, 0.21972215124974626, 0.19732263053477594, 0.18553778073899818, 0.18894753498717332, 0.18869810037936097, 0.20270941764403938, 0.7539674896524837, 0.696159776810124, 0.2232246200301239, 0.18639883926878364, 0.18377606418694337, 0.15278718334312602, 0.17498471133356475, 0.19896725376111601, 0.8712535944811433, 0.7739476496566491, 0.8314684093305071, 0.20079534552200273, 0.7928387110774869, 0.16916730738036823, 0.7673378359307677, 0.45426336525434785, 0.16826749030608368, 0.16513236637503337, 0.10405295319796204, 0.16471870841144898, 0.8299447221160402, 0.19498582095333872, 0.20137519164340045, 0.1899704443776704, 0.20426332414495485, 0.20345636114334842, 0.18049366524953603, 0.19267912551194044, 0.18174885084419634, 0.194259088248376, 0.09076045507675756, 0.10958789017008963, 0.08871265184805177, 0.10140028968961301, 0.07809415736467451, 0.13851603712954896, 0.09495313370336844, 0.17214297504243992, 0.10048428459094882]}, "mutation_prompt": null}
{"id": "bdb5c2ab-b2a3-4831-adc2-c9958e95e7a0", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * (1 - evals / self.budget)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (0.5 + 0.5 * (1 - evals / self.budget))\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance exploitation by introducing an adaptive crossover rate and inertia weight for better balance between exploration and exploitation.", "configspace": "", "generation": 22, "fitness": 0.31052386853146124, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.27.", "error": "", "parent_id": "6e35a1bf-165f-440b-9614-0d9b861c1d1e", "metadata": {"aucs": [0.8170828278152392, 0.7862256132114721, 0.7976337995043064, 0.828935266714004, 0.7939458256626686, 0.8176604462101139, 0.8096888763093482, 0.8184418457768217, 0.8056449990346931, 0.5630639562070099, 0.60627448906256, 0.6323819121234487, 0.6147974237105097, 0.6374637895939237, 0.6392543280989621, 0.5447731066834591, 0.5959266365260714, 0.6430875425264373, 0.129488476160181, 0.13569931156497772, 0.13633385075380033, 0.1547712770914712, 0.1422769369055228, 0.12297994278863067, 0.1648859704906357, 0.13728850042567753, 0.1452836397605075, 0.13224677467778678, 0.08784289268992795, 0.08934571497608323, 0.11253301765924884, 0.12879458700332658, 0.1025796487433086, 0.1312823856547447, 0.1024552414369333, 0.11953123060144566, 0.9706869914852672, 0.977884749788537, 0.9753795394043064, 0.970542246829852, 0.9644940295536533, 0.9644289412436832, 0.9706486607892372, 0.9582135767361997, 0.9759035458379746, 0.7212935399182847, 0.7245415805837272, 0.6599010182264331, 0.7430859598720296, 0.7215003463537053, 0.68351433300929, 0.7130876960489279, 0.675276833656645, 0.6106852734638107, 0.8084461610443904, 0.1689377100246653, 0.17112241444282605, 0.2739031793162381, 0.27031462138593165, 0.8474790425032963, 0.2280654969447331, 0.8215476228247338, 0.21711433017415827, 0.2581833353636366, 0.18723729974656478, 0.23778092291583008, 0.2347118365547437, 0.13166277845408436, 0.13096623895933646, 0.2595089112313922, 0.25620483290447194, 0.12672127013583234, 0.2669577930522722, 0.25266282923599315, 0.2616273840896318, 0.12558725650522173, 0.288283079060652, 0.2736993126540299, 0.25558477953534253, 0.23985059529154773, 0.27012158278068865, 9.999999999998899e-05, 9.999999999998899e-05, 0.003132754454422848, 0.010758661618748055, 0.03940107965149542, 9.999999999998899e-05, 0.0036095034188925457, 0.00809213126487407, 0.07125383354947445, 0.09933711023461544, 0.03435462666271705, 0.11683645934755282, 0.06667213713833375, 0.02688379418417919, 0.06606616719006397, 0.07507666996353668, 0.13836277940448272, 0.05908720465661188, 0.062497444312260675, 0.03183135904997836, 0.2395323539934895, 0.06482271982292753, 0.08074779403151655, 0.07085001923892142, 0.1422150822833952, 0.09050005485524926, 0.08572803175291155, 0.12591642907431633, 0.10328728337094273, 0.13578369401132773, 0.16228498013262782, 0.062428223302463226, 0.10111727423148098, 0.19135087242175497, 0.053143008929235624, 0.07788691620130417, 0.5034380575302231, 0.5114655981172755, 0.5196540810273815, 0.5203422691637665, 0.5756931852930196, 0.5549822800656048, 0.5586476293868738, 0.567943698237779, 0.5373700487366121, 0.0888481818742275, 0.09881179406953433, 0.13184090727806397, 0.1262585820751445, 0.10709568727284002, 0.10618483736689299, 0.11150028429516334, 0.12616022071695565, 0.13455782990599818, 0.19359183397679747, 0.3358885575479601, 0.3246817696262214, 0.24623461458545337, 0.47431763305766994, 0.2586757263117333, 0.24409769055104102, 0.18169187241098106, 0.22640982275945976, 0.4126390825856713, 0.2500975923914155, 0.29331764146787365, 0.4031013726898016, 0.2754367459145025, 0.28281021578196364, 0.27375834847111336, 0.2762639016292059, 0.36437231109497936, 0.252017265201977, 0.2813519688541525, 0.17325572292336933, 0.23595916858561394, 0.1744860476280088, 0.30261075588336006, 0.24390153077121435, 0.2524275304273135, 0.21208418483113767, 0.21181046217336674, 0.20123357861784974, 0.19971770670903433, 0.20861673235413658, 0.20515201287890938, 0.2102468343835171, 0.2182241713367019, 0.19808121990190142, 0.21404299969096097, 0.2166692356150003, 0.21465918693241037, 0.20405178563375415, 0.19790268836391267, 0.17797283003280884, 0.18695245668102567, 0.20151269596759858, 0.19196085950920427, 0.1960286212662219, 0.1415735788793978, 0.16758013888822298, 0.16460661369265506, 0.8647327768422446, 0.1980922346358649, 0.16438245125941298, 0.14215072932490724, 0.8202830860431276, 0.19584028100115625, 0.7758367973454146, 0.2105758722240183, 0.7789616112025715, 0.2088311776421654, 0.1678529457008675, 0.15371480701828732, 0.1050061274740578, 0.7956752551843158, 0.7952260623640653, 0.18926143741755097, 0.18570167683299565, 0.18750471234735322, 0.19136222053054663, 0.24453466787638845, 0.18516292315026361, 0.23769411832687737, 0.20127905292079018, 0.1819609554090622, 0.08307222706578554, 0.09982903639185492, 0.08678988770665019, 0.08848434486142454, 0.0964580122955494, 0.14220897670919408, 0.09346787160925452, 0.08336175939321055, 0.08858499896128325]}, "mutation_prompt": null}
{"id": "5273d491-240a-48a5-88e8-765993bf3d31", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            pop_std = np.std(pop, axis=0)  # Calculate standard deviation for diversity\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * (1 - evals / self.budget) * (1 + np.mean(pop_std))  # Adapt mutation factor based on diversity\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance convergence by adapting the mutation factor dynamically with respect to population diversity and improve exploration-exploitation balance.", "configspace": "", "generation": 23, "fitness": 0.3161959373151482, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "6e35a1bf-165f-440b-9614-0d9b861c1d1e", "metadata": {"aucs": [0.8254956069472268, 0.8306429229144731, 0.8421119409693515, 0.8283551173249706, 0.8149655339684349, 0.8315191799192287, 0.8207620198837116, 0.8280295514882087, 0.8251853650090482, 0.6871534029994809, 0.6676098083165392, 0.6513517463937435, 0.6558456886059586, 0.621626791294959, 0.6866122868956575, 0.6294866549887996, 0.6550588824512524, 0.6946901703977013, 0.1358626375506634, 0.1253796940064874, 0.14399807787203978, 0.1706724969127783, 0.17826946433971969, 0.1150135783829237, 0.1075403445850156, 0.12938921245209944, 0.17294722271074092, 0.14776917084226548, 0.08475513737074203, 0.13125723667890865, 0.14594247240419556, 0.11367820708137677, 0.10875867662648975, 0.13040703790590835, 0.084662332791818, 0.12520009551238165, 0.9705366275864772, 0.9783041105930284, 0.9779383479856103, 0.9767087604772264, 0.9850164460647007, 0.9733476623460692, 0.9769630346066088, 0.9943817091979421, 0.9785345337367258, 0.7225062801207756, 0.7322280475374817, 0.7442385374408174, 0.7162095042466232, 0.7219694225161761, 0.7125984356018875, 0.7241095648107034, 0.7399368551802696, 0.7114811617521899, 0.2287730695372978, 0.8092950625708286, 0.8000127717050972, 0.2104814325010601, 0.34436643390612864, 0.36333568200617417, 0.770814401930872, 0.22121888312384475, 0.23426727187802332, 0.12725968430863033, 0.19328768957058706, 0.14888290209144817, 0.1173954591355496, 0.2923635877636548, 0.1599575249514883, 0.13125500816263103, 0.24413130354123413, 0.2103075037342731, 0.22394352484767766, 0.23357967119370715, 0.22018183404272385, 0.28128258544840634, 0.25967205981290864, 0.26738816573933055, 0.23926076312997913, 0.2383748638117439, 0.21598856540005318, 0.006619070018381357, 0.0018998386187948357, 0.10253607377818208, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003838566663110443, 9.999999999998899e-05, 0.0056540334219810084, 0.11691575436808166, 0.06647434946234876, 0.12870123450130033, 0.07982893532678281, 0.05843405191721163, 0.04648813802725704, 0.03794702600007627, 0.11889943294083682, 0.13068827529343985, 0.0832169707729139, 0.03166233539278218, 0.19586408836446545, 0.08608606939982177, 0.06773924512657614, 0.06709054022902006, 0.18573459921718372, 0.13221501428223126, 0.18614975718320537, 0.13420386608328772, 0.10396687494824763, 0.15000127261379148, 0.03596004962699173, 0.1418159143648844, 0.06702311063605759, 0.07012213760003105, 0.07123812146162511, 0.08268616602483603, 0.49913635721165484, 0.5145606766147317, 0.574174138228227, 0.5336595730943547, 0.5266572038052171, 0.5405193081198797, 0.53978754282949, 0.5666066755045682, 0.5874467143051845, 0.0923801743247552, 0.14710671319136814, 0.0864501590952208, 0.14646242791407227, 0.11038331689028713, 0.11309007572966367, 0.1176609802403158, 0.16161151816015829, 0.10547267102097901, 0.20905257016260737, 0.16149935141952887, 0.17239804538024694, 0.2247140541057857, 0.38607857285598834, 0.18660219467396255, 0.18566518778330632, 0.22675654069849827, 0.16453113470403036, 0.4434362730551633, 0.3938437335349152, 0.45644071790348584, 0.2679820926466995, 0.36297157061463237, 0.3555502762634606, 0.4833762919920095, 0.505592713603106, 0.5583895509905804, 0.18331253751689236, 0.3214874350935881, 0.25688613528276016, 0.2657527972193998, 0.21102439435058273, 0.24460598126556998, 0.22793508350654712, 0.3741137494829423, 0.2408504654192024, 0.23755247196416718, 0.19766827158200617, 0.23991891898098605, 0.2450981125625975, 0.22119940156114393, 0.2101798854732142, 0.225509006931234, 0.21222207925381142, 0.2003805756129995, 0.22404817432558244, 0.2150521082693394, 0.18985779422675209, 0.19599024977124369, 0.2083963444745497, 0.19736881306062926, 0.17808336853620932, 0.17759008420362699, 0.1970557713334784, 0.20935901967456194, 0.1848843605194248, 0.8857565470356878, 0.849791412316461, 0.19910362679613314, 0.1969376918534571, 0.7346743008769931, 0.1680365150767822, 0.20198773523514368, 0.8642070541579778, 0.16863906092995062, 0.6318218816367808, 0.11229344721491374, 0.1675646249739663, 0.14762108186263412, 0.15169023608218501, 0.15300500372752557, 0.20777550662915933, 0.19204407977554905, 0.18049689067855923, 0.2037149279626964, 0.1800392492149625, 0.18336588868640524, 0.200178131841669, 0.20399256854178305, 0.18317868865616194, 0.19433550067022876, 0.09572110394056055, 0.1000144268365235, 0.10233006101863362, 0.08837856968798496, 0.08239232967594978, 0.09197973853200725, 0.1014348912744163, 0.12448035980728345, 0.07771540863401094]}, "mutation_prompt": null}
{"id": "c0fb1650-22da-4423-a3d1-43a71f874462", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance exploration by dynamically adjusting the mutation factor and incorporating a random search mechanism.", "configspace": "", "generation": 24, "fitness": 0.32949455260151367, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.27.", "error": "", "parent_id": "6e35a1bf-165f-440b-9614-0d9b861c1d1e", "metadata": {"aucs": [0.8435671376499423, 0.813821965027232, 0.8193146984381393, 0.8238782588528325, 0.8181580590960307, 0.8330929086778752, 0.8136430829651737, 0.8384596763249165, 0.830620455315433, 0.641523478823466, 0.6334803739832614, 0.6787732472158599, 0.6766782098441542, 0.6647111389199246, 0.6874039247988899, 0.666113388487388, 0.7247818405100646, 0.6808620463564657, 0.15381816764210876, 0.10730306727407768, 0.1513548449000498, 0.13362576832755435, 0.14870619424370346, 0.12175465429781884, 0.13610837638633133, 0.10806379913823516, 0.13567477396292538, 0.13634594884004914, 0.10437262336038455, 0.1501534467257989, 0.09175279595147623, 0.13431504204396694, 0.10217962512553791, 0.07479616648097231, 0.14234335946848642, 0.09574871249464578, 0.9715157854306803, 0.9777150148128568, 0.9650024427569011, 0.97743136410035, 0.9776450522793793, 0.9755389901383664, 0.9620280141543381, 0.9749482147631842, 0.9708676842966437, 0.7248570437952826, 0.7245999368622097, 0.7159431301021904, 0.2960383646999396, 0.7238507904862093, 0.7353638451629269, 0.7418072636575859, 0.7236286021881666, 0.7210752079739926, 0.8260082805660651, 0.3684367245803063, 0.2265877846719957, 0.27127286907523396, 0.2156498207277442, 0.748038263824488, 0.3753203045986836, 0.8077175844646098, 0.21798590718578648, 0.12110131116225398, 0.21978053308536383, 0.24120360894986048, 0.2619910211260046, 0.22528903460913285, 0.21654558541046554, 0.22231231405218355, 0.12439082676438995, 0.23797658929057597, 0.23789442261611227, 0.22540470737372664, 0.22447764367435297, 0.2824316182765436, 0.259348712130535, 0.247081588615374, 0.26197434719588464, 0.24656725175168426, 0.29432761621260084, 0.0026981267947514542, 0.05081632747825915, 9.999999999998899e-05, 0.04648319092598918, 0.00422665797700339, 9.999999999998899e-05, 0.08360862800964752, 0.0003568427059310597, 0.08237697534844157, 0.11894191880761151, 0.02591471398663725, 0.15121248575941793, 0.047802049512069456, 0.0023428444631268253, 0.025186182385502076, 0.08350270573646124, 0.05507664411122659, 0.11572490654796042, 0.02946698152652194, 0.22041967137598129, 0.2033304599834238, 0.10754233476136854, 0.08271940482310602, 0.06926531962922922, 0.15795400774111035, 0.06354727714908859, 0.07539068624484957, 0.04081449751588917, 0.05565604536908808, 0.2966901789462909, 0.1743302465660892, 0.07503780420997663, 0.15497168921260873, 0.2800814106027122, 0.20592406067700564, 0.07896588555325179, 0.5430952779215492, 0.5384963511061253, 0.5281062025666394, 0.5667886470541659, 0.5611380933507836, 0.5303285569442668, 0.5404958577614134, 0.5778534820593042, 0.5654961856373926, 0.12577386625423803, 0.12566879600555625, 0.10663697722092269, 0.1065041775682748, 0.12398041584692221, 0.09342787720545853, 0.13696148778654837, 0.12389710313395186, 0.12152475786419714, 0.18376180599804492, 0.5101699007019496, 0.23169275893521968, 0.2877383336165973, 0.35302289475876825, 0.2315164934379479, 0.2762474747073598, 0.21323431725103725, 0.2066090551230627, 0.4934793320833283, 0.31669116264172015, 0.34323238670760337, 0.36387338364411304, 0.32471497100192215, 0.36180838665251636, 0.36761837740606074, 0.5843938197584961, 0.3718103184237872, 0.25769776842533365, 0.2620220402057061, 0.328349630780821, 0.27783787655050085, 0.29413693921292716, 0.3178693925192393, 0.2835468856932234, 0.27503622289142526, 0.19279798483142596, 0.2474218376738334, 0.3018299048241444, 0.20863914060362465, 0.23791585611638433, 0.20340104099926914, 0.19715179796740068, 0.2259692635040168, 0.2232387716902513, 0.2579239898170259, 0.2456753298806056, 0.1902811214442841, 0.18943284315543873, 0.7561172435791639, 0.20555384564009593, 0.21817437453583532, 0.21176309184146969, 0.24454063291816197, 0.20590540145935043, 0.17173112789367007, 0.18195190898626712, 0.19949494974920934, 0.18626665443892043, 0.19820117460347642, 0.19788735380195044, 0.14171195967638928, 0.1691325984734383, 0.8278805916572685, 0.8049670823941989, 0.2079848631983151, 0.7242092442775575, 0.8554615841343303, 0.6249773520163429, 0.7848240218268692, 0.10449232459355184, 0.2088978400800705, 0.7958257966008164, 0.2092587607887213, 0.18960480966482451, 0.21053414806662252, 0.18869934478001194, 0.19146274795339768, 0.1955500159927892, 0.19168384946902228, 0.18309229106107405, 0.1900456638082546, 0.08295195910305286, 0.09910789531412845, 0.12855562819188104, 0.0927854248785761, 0.08167573283111229, 0.10671309347222613, 0.10110077159988795, 0.09846178225754065, 0.09276805935100785]}, "mutation_prompt": null}
{"id": "f18590e0-64f6-4917-9d29-fa023a33118f", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                # Adaptive crossover rate\n                dynamic_crossover_rate = self.crossover_rate * (1 - evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < dynamic_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase with elitism\n            pop = np.vstack((pop, [global_best]))  # Add the best solution back into the population\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Improve exploration by introducing adaptive crossover and integrating elitism to preserve the best solution.", "configspace": "", "generation": 25, "fitness": 0.3246752515113198, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.28.", "error": "", "parent_id": "c0fb1650-22da-4423-a3d1-43a71f874462", "metadata": {"aucs": [0.8564700339991727, 0.8549647467314214, 0.8657405028563084, 0.8508605451184215, 0.8581253678396803, 0.8661236338134288, 0.852326093406501, 0.85800141301228, 0.8584968392468959, 0.7038422584909423, 0.6866276103623867, 0.6766882430862415, 0.7052898805487183, 0.6700988544910624, 0.7403036816542365, 0.7324469715119357, 0.7345550528117948, 0.7161189318477413, 0.15376179010477609, 0.13932356170882798, 0.17746431647280259, 0.11790042614966567, 0.15484380669328435, 0.15274810563309016, 0.15352774440428762, 0.15149175854296204, 0.15205851923743774, 0.08970598006977326, 0.1121705029686404, 0.11194205446068117, 0.09774242503364616, 0.11269229751058263, 0.11049068403683082, 0.13652167554248096, 0.09978350495526778, 0.14595809803413307, 0.9715157854306803, 0.9779288551198984, 0.9650024427569011, 0.97743136410035, 0.9776450522793793, 0.9755389901383664, 0.9620140017966387, 0.9749482147631842, 0.9706044878989804, 0.7532822972318818, 0.7336315499416928, 0.727869399354304, 0.7338258743615682, 0.7552779774231, 0.7551006104121809, 0.7619371531797303, 0.7728225179305099, 0.7760217574871345, 0.876420990886009, 0.22442515310946975, 0.2242468779230824, 0.27237451885438424, 0.27623182498195353, 0.273139572674716, 0.38157737884259624, 0.3504950246125508, 0.2281635774595624, 0.23648881266962485, 0.21184435817316127, 0.21390374568236248, 0.20854260547970827, 0.24120587096538548, 0.221968436640807, 0.12842907140232418, 0.20890743785711718, 0.2404170302161307, 0.2376271763385689, 0.22402017118923967, 0.230571699323046, 0.2567867467132625, 0.23377906980595697, 0.2558490637927302, 0.2511257072274855, 0.26945818113423425, 0.2634413465507539, 0.005993520174090161, 0.013294198759261078, 9.999999999998899e-05, 0.06824872351379685, 9.999999999998899e-05, 9.999999999998899e-05, 0.05235600079112612, 9.999999999998899e-05, 0.01981128136576049, 0.12398519181535506, 0.043642328300504185, 0.13120704859183263, 0.044454519283191773, 0.0057748985816863385, 0.007112823486469688, 0.04652778021166737, 0.06458927736836739, 0.08063006301304254, 0.032805928948473784, 0.2396483906678618, 0.10682547269072895, 0.08255801778986349, 0.07419970914317131, 0.0734922577545527, 0.2496166998295466, 0.07844140410493616, 0.12467710636555007, 0.0872507024662027, 0.04206001675206794, 0.20577885825240338, 0.04122854281435395, 0.15232364844077007, 0.1541600353018635, 0.055027658087099196, 0.1543477774353933, 0.082437729392562, 0.5271051012125529, 0.547558780208171, 0.6136588472289729, 0.5949516902458805, 0.5112239469953055, 0.5162293477962635, 0.5766707881474037, 0.5788685899095551, 0.5685301573885129, 0.15616558510871204, 0.10125651443719674, 0.10812217676582969, 0.12643002505428302, 0.08935458745551716, 0.10828122287176667, 0.10532066323138423, 0.10170929236460924, 0.10941177556818837, 0.1788408699309454, 0.2847174626726976, 0.2183502959379302, 0.305137376108235, 0.23759922560208546, 0.2279272541720494, 0.27153884837952313, 0.24348047323486433, 0.1615146961506, 0.3321455842779636, 0.3812234471863528, 0.5548389793087374, 0.28802051638557913, 0.45841835898502725, 0.3756123320054221, 0.3505037364307555, 0.46529693227014646, 0.5204887012608082, 0.27780460225176173, 0.2409056927945612, 0.31506548265379575, 0.19407286190731565, 0.36018811337229173, 0.2935485315149209, 0.3349849414350553, 0.2212352910828671, 0.29122720537052116, 0.20759343696488008, 0.22433138116966345, 0.18165898218914733, 0.23689661657764816, 0.20366766559002658, 0.23366705463851778, 0.2241862932943508, 0.20711774444410846, 0.21569425802074105, 0.18575394315936677, 0.20021442145816082, 0.21429666957723437, 0.20868266530941415, 0.24839468692808442, 0.24823942625291795, 0.21485267022917576, 0.20669681005851837, 0.21993702890277178, 0.8796638920821896, 0.18707855138670237, 0.19903249065104278, 0.18637425488291837, 0.19950220757054338, 0.19846253126372937, 0.14212541708939497, 0.16920147268723362, 0.1525653956726779, 0.7919180340090877, 0.21177769879711128, 0.7036114938132265, 0.7449132411198223, 0.6059894276101073, 0.7032353876510871, 0.10472866276503279, 0.20621032735114864, 0.7978602355170161, 0.1946936465641831, 0.18530862859863328, 0.18003707720636664, 0.21637048948360726, 0.17970098722245076, 0.19220354625011726, 0.23765270589874066, 0.1847085450099768, 0.19539421773631072, 0.09640582465460468, 0.09955267001936519, 0.1272834534099775, 0.09886132800411851, 0.08664956065952578, 0.10566663445317792, 0.1004374187505267, 0.09713217715721745, 0.09417072801387372]}, "mutation_prompt": null}
{"id": "02549007-5cbd-4593-8873-07f7c3978074", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance exploration by dynamically adjusting the mutation factor and incorporating a random search mechanism.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c0fb1650-22da-4423-a3d1-43a71f874462", "metadata": {"aucs": [0.8435671376499423, 0.813821965027232, 0.8193146984381393, 0.8238782588528325, 0.8181580590960307, 0.8330929086778752, 0.8136430829651737, 0.8384596763249165, 0.830620455315433, 0.641523478823466, 0.6334803739832614, 0.6787732472158599, 0.6766782098441542, 0.6647111389199246, 0.6874039247988899, 0.666113388487388, 0.7247818405100646, 0.6808620463564657, 0.15381816764210876, 0.10730306727407768, 0.1513548449000498, 0.13362576832755435, 0.14870619424370346, 0.12175465429781884, 0.13610837638633133, 0.10806379913823516, 0.13567477396292538, 0.13634594884004914, 0.10437262336038455, 0.1501534467257989, 0.09175279595147623, 0.13431504204396694, 0.10217962512553791, 0.07479616648097231, 0.14234335946848642, 0.09574871249464578, 0.9715157854306803, 0.9777150148128568, 0.9650024427569011, 0.97743136410035, 0.9776450522793793, 0.9755389901383664, 0.9620280141543381, 0.9749482147631842, 0.9708676842966437, 0.7248570437952826, 0.7245999368622097, 0.7159431301021904, 0.2960383646999396, 0.7238507904862093, 0.7353638451629269, 0.7418072636575859, 0.7236286021881666, 0.7210752079739926, 0.8260082805660651, 0.3684367245803063, 0.2265877846719957, 0.27127286907523396, 0.2156498207277442, 0.748038263824488, 0.3753203045986836, 0.8077175844646098, 0.21798590718578648, 0.12110131116225398, 0.21978053308536383, 0.24120360894986048, 0.2619910211260046, 0.22528903460913285, 0.21654558541046554, 0.22231231405218355, 0.12439082676438995, 0.23797658929057597, 0.23789442261611227, 0.22540470737372664, 0.22447764367435297, 0.2824316182765436, 0.259348712130535, 0.247081588615374, 0.26197434719588464, 0.24656725175168426, 0.29432761621260084, 0.0026981267947514542, 0.05081632747825915, 9.999999999998899e-05, 0.04648319092598918, 0.00422665797700339, 9.999999999998899e-05, 0.08360862800964752, 0.0003568427059310597, 0.08237697534844157, 0.11894191880761151, 0.02591471398663725, 0.15121248575941793, 0.047802049512069456, 0.0023428444631268253, 0.025186182385502076, 0.08350270573646124, 0.05507664411122659, 0.11572490654796042, 0.02946698152652194, 0.22041967137598129, 0.2033304599834238, 0.10754233476136854, 0.08271940482310602, 0.06926531962922922, 0.15795400774111035, 0.06354727714908859, 0.07539068624484957, 0.04081449751588917, 0.05565604536908808, 0.2966901789462909, 0.1743302465660892, 0.07503780420997663, 0.15497168921260873, 0.2800814106027122, 0.20592406067700564, 0.07896588555325179, 0.5430952779215492, 0.5384963511061253, 0.5281062025666394, 0.5667886470541659, 0.5611380933507836, 0.5303285569442668, 0.5404958577614134, 0.5778534820593042, 0.5654961856373926, 0.12577386625423803, 0.12566879600555625, 0.10663697722092269, 0.1065041775682748, 0.12398041584692221, 0.09342787720545853, 0.13696148778654837, 0.12389710313395186, 0.12152475786419714, 0.18376180599804492, 0.5101699007019496, 0.23169275893521968, 0.2877383336165973, 0.35302289475876825, 0.2315164934379479, 0.2762474747073598, 0.21323431725103725, 0.2066090551230627, 0.4934793320833283, 0.31669116264172015, 0.34323238670760337, 0.36387338364411304, 0.32471497100192215, 0.36180838665251636, 0.36761837740606074, 0.5843938197584961, 0.3718103184237872, 0.25769776842533365, 0.2620220402057061, 0.328349630780821, 0.27783787655050085, 0.29413693921292716, 0.3178693925192393, 0.2835468856932234, 0.27503622289142526, 0.19279798483142596, 0.2474218376738334, 0.3018299048241444, 0.20863914060362465, 0.23791585611638433, 0.20340104099926914, 0.19715179796740068, 0.2259692635040168, 0.2232387716902513, 0.2579239898170259, 0.2456753298806056, 0.1902811214442841, 0.18943284315543873, 0.7561172435791639, 0.20555384564009593, 0.21817437453583532, 0.21176309184146969, 0.24454063291816197, 0.20590540145935043, 0.17173112789367007, 0.18195190898626712, 0.19949494974920934, 0.18626665443892043, 0.19820117460347642, 0.19788735380195044, 0.14171195967638928, 0.1691325984734383, 0.8278805916572685, 0.8049670823941989, 0.2079848631983151, 0.7242092442775575, 0.8554615841343303, 0.6249773520163429, 0.7848240218268692, 0.10449232459355184, 0.2088978400800705, 0.7958257966008164, 0.2092587607887213, 0.18960480966482451, 0.21053414806662252, 0.18869934478001194, 0.19146274795339768, 0.1955500159927892, 0.19168384946902228, 0.18309229106107405, 0.1900456638082546, 0.08295195910305286, 0.09910789531412845, 0.12855562819188104, 0.0927854248785761, 0.08167573283111229, 0.10671309347222613, 0.10110077159988795, 0.09846178225754065, 0.09276805935100785]}, "mutation_prompt": null}
{"id": "7bfb142e-1680-48fa-8aba-1299fa45ab6b", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment with a nonlinear function\n            self.population_size = max(20, int(40 * (1 - (evals / self.budget)**2)))  # Nonlinear adjustment\n\n        return global_best", "name": "HybridDEPSO", "description": "Improve convergence by introducing a nonlinear dynamic adjustment of population size based on the budget utilization.", "configspace": "", "generation": 27, "fitness": 0.32312959363141147, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "c0fb1650-22da-4423-a3d1-43a71f874462", "metadata": {"aucs": [0.8174592117322288, 0.8183739646808105, 0.820923205423385, 0.8263515212649244, 0.8313013021017681, 0.8321173380516208, 0.8167591230935223, 0.8243767952062533, 0.8350269576581537, 0.6261183905757205, 0.6453344450470687, 0.6224707539079237, 0.6572225996376639, 0.6190737257202519, 0.6566813676834689, 0.6111735564521626, 0.6447506543994379, 0.6503790294021645, 0.11506487888224548, 0.15829011546434435, 0.12436862166208373, 0.6138425031918247, 0.10849863594236231, 0.10866159745266524, 0.11819882501560242, 0.13792040872349665, 0.1725610207467867, 0.09385167322135313, 0.09682692587724906, 0.17300011684544347, 0.14957198981241382, 0.10241218033276656, 0.10014495926078815, 0.12510306515887004, 0.13261193391737747, 0.13118744621752398, 0.9718439612077383, 0.9777150148128568, 0.9697821779163166, 0.97743136410035, 0.9776450522793793, 0.9755389901383664, 0.9592108154984215, 0.9749482147631842, 0.9708018851972279, 0.7196193986298708, 0.7028553457069369, 0.7003834484435024, 0.6966919460092085, 0.6592277540249578, 0.6919942144534446, 0.7037034054973272, 0.7138024771628282, 0.7105827093786145, 0.37454186899675934, 0.3477228451745267, 0.20599652717377115, 0.3225232780787418, 0.2658798233067513, 0.18875525505547863, 0.7932778632952112, 0.34671368229963384, 0.7947476884239407, 0.21107356813292721, 0.21142670299071276, 0.2457427523222977, 0.2277515756542221, 0.21752041272102174, 0.2182512004749152, 0.340203218760465, 0.21430393056243624, 0.23883023990239882, 0.21441649014814246, 0.2399629282699267, 0.29451158818436773, 0.260097369931798, 0.25850361322188375, 0.25240686258223954, 0.2164358279123063, 0.24994232857928644, 0.2542066477668108, 0.035890955669814706, 0.03100390694823696, 0.020923064597712093, 0.0507056458157662, 9.999999999998899e-05, 9.999999999998899e-05, 0.05808399626482463, 0.003931938155377401, 0.08603538293405577, 0.16385117680686234, 0.0697942035923923, 0.07842734725491896, 0.03896239107168131, 0.011863583396511834, 0.022024533446586614, 0.06923708133138973, 0.07313237195936051, 0.07380381402973668, 9.999999999998899e-05, 0.1334462690703504, 0.2628148639282555, 0.06688634694660545, 0.06703401483851301, 0.06602210551940446, 0.13545606555305134, 0.06775158912404478, 0.06429297508862764, 0.10926367637447243, 0.042443693974743346, 0.13206648515847297, 0.029094623240523476, 0.2205523965695434, 0.17457491270390124, 0.14836506077159206, 0.140095982811819, 0.08055823068082646, 0.5200210882929852, 0.5697255025280794, 0.5543295695019821, 0.5317480155011615, 0.5642281777375705, 0.48902502995453256, 0.5771499543587225, 0.5417288968626353, 0.5262146645842262, 0.15133890997894672, 0.10008145236093657, 0.06403141628094167, 0.11127603312055345, 0.12298161226252613, 0.10611064466801834, 0.17545288857103336, 0.09611869634188319, 0.1253851779666747, 0.2692690933396764, 0.22080857141100874, 0.20682250085422527, 0.3027600919601605, 0.3427273981614901, 0.17559077597579276, 0.23893149349075116, 0.1811779828361476, 0.26792116778483055, 0.4096915082060595, 0.3533850818568931, 0.4032913302014156, 0.3584498893608453, 0.43845014874108357, 0.42874145675487607, 0.4664436973967163, 0.45788125178005257, 0.514940321499592, 0.26890181215306996, 0.3298393706442335, 0.29151209637138875, 0.25452122075762296, 0.2848917849776642, 0.3199405003469773, 0.2986050984879537, 0.22392869051787145, 0.20311738898289744, 0.2514539092301955, 0.23774539195940392, 0.2205496789521212, 0.21584440642648217, 0.21343359015675056, 0.23416943537449064, 0.21505388406125392, 0.2037608577025838, 0.21077008862092061, 0.713083287548099, 0.21933814636221127, 0.19771541853302899, 0.21679173328592438, 0.20094093248148137, 0.18199607384712002, 0.20614221642865516, 0.19215580029868828, 0.1953093345451744, 0.17030313339089298, 0.1846461315343928, 0.20034148184568357, 0.18516120111070666, 0.19819094683798477, 0.19814764664675766, 0.1405653348649707, 0.16902497774415404, 0.15051311064021977, 0.7817427960236261, 0.20773244543832103, 0.6853320090460167, 0.8291734475453973, 0.7646649475458445, 0.698618027994494, 0.10452116201203265, 0.2008059774778127, 0.750447918376083, 0.1846516580312204, 0.22451664410806305, 0.1911009157896415, 0.18675601963784927, 0.1876980307496089, 0.19380843504261458, 0.20025196191054717, 0.18645448636525552, 0.21062717933098862, 0.10165962305419451, 0.09549123120026792, 0.0872102542186598, 0.09414115729734107, 0.091471437431203, 0.08052272447756859, 0.09448280995149616, 0.09622930382851813, 0.09701622380794739]}, "mutation_prompt": null}
{"id": "38c64514-f2cd-4fdd-a9a3-876a8ee61e47", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance exploration by dynamically adjusting the mutation factor and incorporating a random search mechanism.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c0fb1650-22da-4423-a3d1-43a71f874462", "metadata": {"aucs": [0.8435671376499423, 0.813821965027232, 0.8193146984381393, 0.8238782588528325, 0.8181580590960307, 0.8330929086778752, 0.8136430829651737, 0.8384596763249165, 0.830620455315433, 0.641523478823466, 0.6334803739832614, 0.6787732472158599, 0.6766782098441542, 0.6647111389199246, 0.6874039247988899, 0.666113388487388, 0.7247818405100646, 0.6808620463564657, 0.15381816764210876, 0.10730306727407768, 0.1513548449000498, 0.13362576832755435, 0.14870619424370346, 0.12175465429781884, 0.13610837638633133, 0.10806379913823516, 0.13567477396292538, 0.13634594884004914, 0.10437262336038455, 0.1501534467257989, 0.09175279595147623, 0.13431504204396694, 0.10217962512553791, 0.07479616648097231, 0.14234335946848642, 0.09574871249464578, 0.9715157854306803, 0.9777150148128568, 0.9650024427569011, 0.97743136410035, 0.9776450522793793, 0.9755389901383664, 0.9620280141543381, 0.9749482147631842, 0.9708676842966437, 0.7248570437952826, 0.7245999368622097, 0.7159431301021904, 0.2960383646999396, 0.7238507904862093, 0.7353638451629269, 0.7418072636575859, 0.7236286021881666, 0.7210752079739926, 0.8260082805660651, 0.3684367245803063, 0.2265877846719957, 0.27127286907523396, 0.2156498207277442, 0.748038263824488, 0.3753203045986836, 0.8077175844646098, 0.21798590718578648, 0.12110131116225398, 0.21978053308536383, 0.24120360894986048, 0.2619910211260046, 0.22528903460913285, 0.21654558541046554, 0.22231231405218355, 0.12439082676438995, 0.23797658929057597, 0.23789442261611227, 0.22540470737372664, 0.22447764367435297, 0.2824316182765436, 0.259348712130535, 0.247081588615374, 0.26197434719588464, 0.24656725175168426, 0.29432761621260084, 0.0026981267947514542, 0.05081632747825915, 9.999999999998899e-05, 0.04648319092598918, 0.00422665797700339, 9.999999999998899e-05, 0.08360862800964752, 0.0003568427059310597, 0.08237697534844157, 0.11894191880761151, 0.02591471398663725, 0.15121248575941793, 0.047802049512069456, 0.0023428444631268253, 0.025186182385502076, 0.08350270573646124, 0.05507664411122659, 0.11572490654796042, 0.02946698152652194, 0.22041967137598129, 0.2033304599834238, 0.10754233476136854, 0.08271940482310602, 0.06926531962922922, 0.15795400774111035, 0.06354727714908859, 0.07539068624484957, 0.04081449751588917, 0.05565604536908808, 0.2966901789462909, 0.1743302465660892, 0.07503780420997663, 0.15497168921260873, 0.2800814106027122, 0.20592406067700564, 0.07896588555325179, 0.5430952779215492, 0.5384963511061253, 0.5281062025666394, 0.5667886470541659, 0.5611380933507836, 0.5303285569442668, 0.5404958577614134, 0.5778534820593042, 0.5654961856373926, 0.12577386625423803, 0.12566879600555625, 0.10663697722092269, 0.1065041775682748, 0.12398041584692221, 0.09342787720545853, 0.13696148778654837, 0.12389710313395186, 0.12152475786419714, 0.18376180599804492, 0.5101699007019496, 0.23169275893521968, 0.2877383336165973, 0.35302289475876825, 0.2315164934379479, 0.2762474747073598, 0.21323431725103725, 0.2066090551230627, 0.4934793320833283, 0.31669116264172015, 0.34323238670760337, 0.36387338364411304, 0.32471497100192215, 0.36180838665251636, 0.36761837740606074, 0.5843938197584961, 0.3718103184237872, 0.25769776842533365, 0.2620220402057061, 0.328349630780821, 0.27783787655050085, 0.29413693921292716, 0.3178693925192393, 0.2835468856932234, 0.27503622289142526, 0.19279798483142596, 0.2474218376738334, 0.3018299048241444, 0.20863914060362465, 0.23791585611638433, 0.20340104099926914, 0.19715179796740068, 0.2259692635040168, 0.2232387716902513, 0.2579239898170259, 0.2456753298806056, 0.1902811214442841, 0.18943284315543873, 0.7561172435791639, 0.20555384564009593, 0.21817437453583532, 0.21176309184146969, 0.24454063291816197, 0.20590540145935043, 0.17173112789367007, 0.18195190898626712, 0.19949494974920934, 0.18626665443892043, 0.19820117460347642, 0.19788735380195044, 0.14171195967638928, 0.1691325984734383, 0.8278805916572685, 0.8049670823941989, 0.2079848631983151, 0.7242092442775575, 0.8554615841343303, 0.6249773520163429, 0.7848240218268692, 0.10449232459355184, 0.2088978400800705, 0.7958257966008164, 0.2092587607887213, 0.18960480966482451, 0.21053414806662252, 0.18869934478001194, 0.19146274795339768, 0.1955500159927892, 0.19168384946902228, 0.18309229106107405, 0.1900456638082546, 0.08295195910305286, 0.09910789531412845, 0.12855562819188104, 0.0927854248785761, 0.08167573283111229, 0.10671309347222613, 0.10110077159988795, 0.09846178225754065, 0.09276805935100785]}, "mutation_prompt": null}
{"id": "1fd0a435-3e17-4011-8c8f-3f7e8a69c433", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5) * (1 - evals / self.budget)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                dynamic_crossover_rate = self.crossover_rate * (0.5 + 0.5 * (evals / self.budget))\n                crossover_mask = np.random.rand(self.dim) < dynamic_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Introduce adaptive crossover rate and mutation factor based on evaluation progress to enhance convergence.", "configspace": "", "generation": 29, "fitness": 0.32732811147756175, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "c0fb1650-22da-4423-a3d1-43a71f874462", "metadata": {"aucs": [0.8293271216762297, 0.8334656378042631, 0.8270623724695618, 0.8311387880917548, 0.8245470563370698, 0.8393346186503098, 0.8190623359585144, 0.8500772968356959, 0.8074384497742446, 0.6776977775524835, 0.6687598581265874, 0.6513122393311741, 0.6413096857981485, 0.5281293119767526, 0.6564918242221537, 0.7112696176425719, 0.6895353856180798, 0.7099018294843826, 0.1263429330030822, 0.11564582301198112, 0.1491918598595856, 0.1339716056301471, 0.1473681390020316, 0.15048149764387875, 0.1762982578908201, 0.10630761182329573, 0.6187915904943823, 0.10718009147886354, 0.10707800746440355, 0.12091003526984401, 0.14654112310336553, 0.10997361488418445, 0.08931490427906941, 0.10731948909518307, 0.13312856583655197, 0.10395437065725621, 0.9741536959182685, 0.9714016077594689, 0.970797541563602, 0.9640243629254522, 0.9706397510047222, 0.9690507169534647, 0.9755157222453866, 0.9744206354334194, 0.9701038618611078, 0.7635023055771564, 0.7287388362161616, 0.7389612619721402, 0.7666229214052088, 0.7517583837752706, 0.7138072275763649, 0.7283331734245027, 0.7380166226298787, 0.7382091301292667, 0.2257745303239067, 0.22487281664284497, 0.2246018839522118, 0.8612654547322096, 0.36762526924894445, 0.2755304532521574, 0.23553093543137504, 0.8288852365714133, 0.22428048276618107, 0.16240572254346897, 0.2040647297984649, 0.18901075887708763, 0.13928701263690668, 0.20365836290450545, 0.2501812082110174, 0.19275065549136294, 0.23005776289603697, 0.22774613458354198, 0.22558743570603756, 0.22200038833731683, 0.23917914498075443, 0.25264413375764405, 0.2344784814077281, 0.26276471217540154, 0.25573214780278597, 0.24779733100426615, 0.25153816152323594, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.052801005726452965, 9.999999999998899e-05, 9.999999999998899e-05, 0.006157988679585058, 9.999999999998899e-05, 0.006911863430249632, 0.11591421068694785, 0.040658730914407304, 0.11597362175927084, 0.06740581730806372, 0.010873811391323263, 0.03340004537558561, 0.04973302302014648, 0.08767909554063058, 0.045854582886248885, 0.04622019698318158, 0.23652027542907206, 0.20138536204615676, 0.16069786613007786, 0.09008591086455875, 0.07165408331415923, 0.17186107260419725, 0.1408486019877071, 0.1338172483651684, 0.18303318273439184, 0.01113288730686035, 0.043959103923570386, 0.006163855346719371, 0.16831504768578687, 0.04623522955058179, 0.05679480256327918, 0.12246915367071975, 0.08114571094485978, 0.5616293881856343, 0.5230838062981202, 0.5386448625734, 0.6034870699759569, 0.6009779023147004, 0.506992494878698, 0.544049998631654, 0.5404581377947033, 0.5511419283146737, 0.15044249708019575, 0.09806499321459172, 0.07613881985017557, 0.10824892717623824, 0.10831612779299138, 0.1279329021520742, 0.07594225255788534, 0.11552986281978261, 0.12631286501876637, 0.1544946452671473, 0.1600809965245409, 0.2092907688058505, 0.25495364788695063, 0.29574723261169167, 0.253445103569816, 0.2164827683797289, 0.23671936057470178, 0.3432393583900233, 0.592620965798063, 0.3835875704229432, 0.5210279289607838, 0.4065828679602681, 0.25538145237537957, 0.25523002809751105, 0.38863857921221656, 0.48711657032502564, 0.36778020385921084, 0.23696128158099994, 0.28420745133286107, 0.2725756625484568, 0.2114027006121244, 0.22708427158699973, 0.3758690084034746, 0.2596611603095861, 0.3246728609241444, 0.22667053762709244, 0.22358473039103488, 0.18838431809482103, 0.21583808298096174, 0.26983520565417385, 0.23729018923587963, 0.23731223839266136, 0.23713236393340642, 0.20768640536967953, 0.20496745690533558, 0.19652497793894563, 0.2067692033075268, 0.2509456036622125, 0.742642342552172, 0.7797495541158945, 0.1894681535568391, 0.24635440512968232, 0.22046300311080858, 0.22321633918164274, 0.8775135421167107, 0.19933291788346508, 0.17319765225087524, 0.8855074955255359, 0.19876102469382406, 0.14738369641338867, 0.14195384400085875, 0.16887673588376806, 0.1526364054114523, 0.8736380246738586, 0.21207024491157733, 0.20921392352828805, 0.8732144593897567, 0.1666772280446126, 0.7588111361908929, 0.10472804333785368, 0.10452311432147798, 0.8618867899726986, 0.18648394534822588, 0.20248795260545938, 0.20097566307138548, 0.19619173505037324, 0.19029842308050549, 0.2030690404732266, 0.1958266463336975, 0.19070480030755788, 0.19810295423643265, 0.085580539302204, 0.07218531626085056, 0.11177654967830297, 0.08376195760708616, 0.10274823547139167, 0.15938134137929338, 0.0969015645482334, 0.16408358300524706, 0.09602793687394029]}, "mutation_prompt": null}
{"id": "e8c959a7-c8a9-41d2-8724-11f3b5768448", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance exploration by dynamically adjusting the mutation factor and incorporating a random search mechanism.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c0fb1650-22da-4423-a3d1-43a71f874462", "metadata": {"aucs": [0.8435671376499423, 0.813821965027232, 0.8193146984381393, 0.8238782588528325, 0.8181580590960307, 0.8330929086778752, 0.8136430829651737, 0.8384596763249165, 0.830620455315433, 0.641523478823466, 0.6334803739832614, 0.6787732472158599, 0.6766782098441542, 0.6647111389199246, 0.6874039247988899, 0.666113388487388, 0.7247818405100646, 0.6808620463564657, 0.15381816764210876, 0.10730306727407768, 0.1513548449000498, 0.13362576832755435, 0.14870619424370346, 0.12175465429781884, 0.13610837638633133, 0.10806379913823516, 0.13567477396292538, 0.13634594884004914, 0.10437262336038455, 0.1501534467257989, 0.09175279595147623, 0.13431504204396694, 0.10217962512553791, 0.07479616648097231, 0.14234335946848642, 0.09574871249464578, 0.9715157854306803, 0.9777150148128568, 0.9650024427569011, 0.97743136410035, 0.9776450522793793, 0.9755389901383664, 0.9620280141543381, 0.9749482147631842, 0.9708676842966437, 0.7248570437952826, 0.7245999368622097, 0.7159431301021904, 0.2960383646999396, 0.7238507904862093, 0.7353638451629269, 0.7418072636575859, 0.7236286021881666, 0.7210752079739926, 0.8260082805660651, 0.3684367245803063, 0.2265877846719957, 0.27127286907523396, 0.2156498207277442, 0.748038263824488, 0.3753203045986836, 0.8077175844646098, 0.21798590718578648, 0.12110131116225398, 0.21978053308536383, 0.24120360894986048, 0.2619910211260046, 0.22528903460913285, 0.21654558541046554, 0.22231231405218355, 0.12439082676438995, 0.23797658929057597, 0.23789442261611227, 0.22540470737372664, 0.22447764367435297, 0.2824316182765436, 0.259348712130535, 0.247081588615374, 0.26197434719588464, 0.24656725175168426, 0.29432761621260084, 0.0026981267947514542, 0.05081632747825915, 9.999999999998899e-05, 0.04648319092598918, 0.00422665797700339, 9.999999999998899e-05, 0.08360862800964752, 0.0003568427059310597, 0.08237697534844157, 0.11894191880761151, 0.02591471398663725, 0.15121248575941793, 0.047802049512069456, 0.0023428444631268253, 0.025186182385502076, 0.08350270573646124, 0.05507664411122659, 0.11572490654796042, 0.02946698152652194, 0.22041967137598129, 0.2033304599834238, 0.10754233476136854, 0.08271940482310602, 0.06926531962922922, 0.15795400774111035, 0.06354727714908859, 0.07539068624484957, 0.04081449751588917, 0.05565604536908808, 0.2966901789462909, 0.1743302465660892, 0.07503780420997663, 0.15497168921260873, 0.2800814106027122, 0.20592406067700564, 0.07896588555325179, 0.5430952779215492, 0.5384963511061253, 0.5281062025666394, 0.5667886470541659, 0.5611380933507836, 0.5303285569442668, 0.5404958577614134, 0.5778534820593042, 0.5654961856373926, 0.12577386625423803, 0.12566879600555625, 0.10663697722092269, 0.1065041775682748, 0.12398041584692221, 0.09342787720545853, 0.13696148778654837, 0.12389710313395186, 0.12152475786419714, 0.18376180599804492, 0.5101699007019496, 0.23169275893521968, 0.2877383336165973, 0.35302289475876825, 0.2315164934379479, 0.2762474747073598, 0.21323431725103725, 0.2066090551230627, 0.4934793320833283, 0.31669116264172015, 0.34323238670760337, 0.36387338364411304, 0.32471497100192215, 0.36180838665251636, 0.36761837740606074, 0.5843938197584961, 0.3718103184237872, 0.25769776842533365, 0.2620220402057061, 0.328349630780821, 0.27783787655050085, 0.29413693921292716, 0.3178693925192393, 0.2835468856932234, 0.27503622289142526, 0.19279798483142596, 0.2474218376738334, 0.3018299048241444, 0.20863914060362465, 0.23791585611638433, 0.20340104099926914, 0.19715179796740068, 0.2259692635040168, 0.2232387716902513, 0.2579239898170259, 0.2456753298806056, 0.1902811214442841, 0.18943284315543873, 0.7561172435791639, 0.20555384564009593, 0.21817437453583532, 0.21176309184146969, 0.24454063291816197, 0.20590540145935043, 0.17173112789367007, 0.18195190898626712, 0.19949494974920934, 0.18626665443892043, 0.19820117460347642, 0.19788735380195044, 0.14171195967638928, 0.1691325984734383, 0.8278805916572685, 0.8049670823941989, 0.2079848631983151, 0.7242092442775575, 0.8554615841343303, 0.6249773520163429, 0.7848240218268692, 0.10449232459355184, 0.2088978400800705, 0.7958257966008164, 0.2092587607887213, 0.18960480966482451, 0.21053414806662252, 0.18869934478001194, 0.19146274795339768, 0.1955500159927892, 0.19168384946902228, 0.18309229106107405, 0.1900456638082546, 0.08295195910305286, 0.09910789531412845, 0.12855562819188104, 0.0927854248785761, 0.08167573283111229, 0.10671309347222613, 0.10110077159988795, 0.09846178225754065, 0.09276805935100785]}, "mutation_prompt": null}
{"id": "7a1ec342-8505-4862-9458-19d51f8d6749", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)  # Change 1\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate  # Change 2\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Introduce adaptive crossover and mutation rates based on convergence rate for enhanced balance between exploration and exploitation.", "configspace": "", "generation": 31, "fitness": 0.32574853480141774, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "c0fb1650-22da-4423-a3d1-43a71f874462", "metadata": {"aucs": [0.8188728356366037, 0.8360943283216513, 0.816160358767902, 0.8290674379536025, 0.8285981232900183, 0.8417398474311254, 0.8195972443502358, 0.8448566904551208, 0.8363667322746791, 0.6752648353728081, 0.6953596497992319, 0.6490405625530884, 0.6660629224698292, 0.6037301301683529, 0.707897239084025, 0.672714494860629, 0.6717494215165607, 0.7042834291808667, 0.1148886813922092, 0.12274434495713926, 0.11849175810062496, 0.17660886711743518, 0.11762316641866943, 0.6504834292216028, 0.1369648228120488, 0.14881075364711227, 0.1326732484665798, 0.11329990910942866, 0.13392847147207176, 0.10316829363936741, 0.150529400839026, 0.10303460658377694, 0.11018713651013712, 0.12605396777005717, 0.1115737880263572, 0.11016004428694781, 0.974153984618168, 0.9706685489864835, 0.9707951123000333, 0.9640530246601036, 0.9706440299845491, 0.9690584968525532, 0.9755187178690252, 0.9714283061060324, 0.9701146064778828, 0.7630191047006334, 0.7388513078500542, 0.7051754723942487, 0.7400386842512012, 0.703706839170432, 0.739781257560455, 0.702369297915751, 0.7159254690277346, 0.7467086523799082, 0.37474656468866596, 0.3612992118046383, 0.20412021129502045, 0.27578290270949724, 0.21164976388130852, 0.8072871163847534, 0.21855975670313077, 0.3797997287689141, 0.1760087157902821, 0.2671271598406374, 0.22456650123124633, 0.2404768272201636, 0.2180159310000206, 0.4257466406924504, 0.12991467775422716, 0.2314969419027637, 0.18685906758571402, 0.21710818108858843, 0.2312139947747841, 0.18585183923909288, 0.12124317126444095, 0.2655075475284938, 0.24734083587820843, 0.2844096761769658, 0.33792043022537765, 0.21521928679891011, 0.23981079000504302, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04948407448146097, 9.999999999998899e-05, 9.999999999998899e-05, 0.0076856162019326435, 9.999999999998899e-05, 0.007813997860595223, 0.08526462851164884, 0.027001507397641178, 0.12665342251469303, 0.08547087699057587, 0.032152145129762943, 0.06249971477039762, 0.05322848991547513, 0.04184042597446136, 0.05232985202939089, 0.041860975599109396, 0.24030997304400037, 0.18327156594227734, 0.12982791434350016, 0.1248064620352286, 0.07937329997953768, 0.23317870333707547, 0.10696140677516064, 0.14778462332748565, 0.23515564806153322, 0.014066482429673455, 0.07188817022587557, 0.010971548113677287, 0.13028916873071772, 0.03478486983276874, 0.05446112098469147, 0.4281849340093027, 0.08146116743218135, 0.5483179960079142, 0.539393883138575, 0.5475891548689373, 0.5428138626006308, 0.5371395637148675, 0.5447470151995211, 0.5641737431932703, 0.5834732975211931, 0.5566061389366743, 0.11368882793199608, 0.08454600735388684, 0.09784890441116845, 0.12238264569577129, 0.10613406873362696, 0.13639828343300198, 0.15343829421380473, 0.0898583588618671, 0.16769932951919198, 0.27019559735653753, 0.2158494377399569, 0.23490420150390423, 0.18129045309916259, 0.38071542738086994, 0.26181033449518354, 0.2366153296490141, 0.21148713119869145, 0.2096769517412964, 0.32076546350473656, 0.43266309785724466, 0.4082569986373442, 0.4899370385104498, 0.25481887528034763, 0.21652451359884883, 0.25460362103979794, 0.32447861789986154, 0.40769663796080136, 0.19911884644008992, 0.3851570466307941, 0.21536487404233562, 0.1908076056043736, 0.23561532737970514, 0.3480442822140323, 0.32684759425705134, 0.3206396791546602, 0.23469217332028125, 0.21422941590872902, 0.19997458169314464, 0.24010208051153603, 0.21657358852507713, 0.23305148853150504, 0.23001212100014834, 0.22748269007128552, 0.22204997758844702, 0.2244142542972848, 0.19675268789547695, 0.2415208240742388, 0.22344450857786502, 0.1963545696020692, 0.22304175125925063, 0.19440584047696596, 0.24641311143845468, 0.7545886394606645, 0.23938260788150267, 0.868506391973671, 0.19940446835065995, 0.8201026130906937, 0.8758350962981455, 0.19867957184413, 0.1473521428565815, 0.14193781237649528, 0.16884727227891216, 0.15217752096074233, 0.8611303276555835, 0.2118529407545099, 0.20818592430452587, 0.7753758415012069, 0.16673883612551477, 0.6836559456484956, 0.10472649482134389, 0.1044564851090497, 0.8599430000032697, 0.19398679555003717, 0.18059885564942646, 0.2016988166396827, 0.1918323041554273, 0.19181318469286224, 0.20062709475112883, 0.21403665204357225, 0.1796292716329384, 0.18397544609190486, 0.09842170195733779, 0.06789107484773649, 0.11677135729642163, 0.09389282529709331, 0.09562504179929143, 0.1201584942549544, 0.10967754780885097, 0.10094937819591887, 0.09212957168384694]}, "mutation_prompt": null}
{"id": "0ab8ce45-86d5-454c-b647-ae7fbba8477f", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5) * (1 - evals / self.budget)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * (1 - evals / self.budget))\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Refine exploration by introducing a mutation factor decay and enhance local search through adaptive cognitive dynamics.", "configspace": "", "generation": 32, "fitness": 0.3270345221901877, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.27.", "error": "", "parent_id": "c0fb1650-22da-4423-a3d1-43a71f874462", "metadata": {"aucs": [0.8304861522961009, 0.7966795641574462, 0.8278772099462073, 0.8396155090983135, 0.8383725638185662, 0.8214204089593122, 0.8123043415719924, 0.8051062014487802, 0.8210615727851003, 0.6783545924752599, 0.690490018404466, 0.5782816896030236, 0.6827689324370694, 0.6811774233979668, 0.6925615457349958, 0.6441349094446451, 0.7042570560696904, 0.6328221043554203, 0.11877451883067824, 0.1457861920862208, 0.1647836132956889, 0.16400938782508745, 0.12773832793224338, 0.1701162541399197, 0.6036315369124613, 0.15256984969354437, 0.16963029790760853, 0.10687814253431793, 0.10104808252790176, 0.13255439782495582, 0.1366934319408738, 0.10893436929306588, 0.13854633374446368, 0.1070248775996675, 0.11877934704084181, 0.1271202612097384, 0.982567679896593, 0.9763137628645854, 0.9760705021300455, 0.9817164789280519, 0.976248603300258, 0.9753525486359382, 0.9778224218383723, 0.9737130260358654, 0.9765817996322377, 0.7180582385359228, 0.7169802575696043, 0.7177009649109649, 0.7201266154114281, 0.7321399550047288, 0.6996348773791283, 0.7378572438336775, 0.7234114783056735, 0.7246499887202805, 0.2219446142362722, 0.36840308896085283, 0.36982794818074494, 0.27853333651144185, 0.2749820530666951, 0.20615907897806596, 0.36496202901674757, 0.8307317085411985, 0.7946313333442143, 0.22781112847984297, 0.20539384518112536, 0.2149491067061413, 0.12607708566291276, 0.2308239228823119, 0.12710236911289063, 0.21461429186093095, 0.21688751937162543, 0.22397499142495259, 0.20590054440496353, 0.17891094797828022, 0.21657175074950508, 0.28266421346341475, 0.24413689183457665, 0.2527737415491048, 0.24798661400423605, 0.24013787487893734, 0.25467609907651156, 9.999999999998899e-05, 0.031958835652278195, 0.04995330449591384, 0.041692436616847184, 0.0062481625122190465, 9.999999999998899e-05, 0.08511984975064191, 0.19781551037489775, 0.00499243165344343, 0.12099614270698278, 0.045559323432174614, 0.15378632620342136, 0.09644998397820803, 0.0015353541617083577, 0.05450025314407991, 0.0344592715426284, 0.07778584437418046, 0.05552597719271979, 0.2565427100423674, 0.17051495959665186, 0.21136312663407475, 0.1003354818407246, 0.19385782992338574, 0.06925893845658937, 0.3190425915464773, 0.08870119849149871, 0.06421743009041925, 0.07206852453524715, 0.04018828042359435, 0.1757700444730761, 0.10029372216830434, 0.07449564052506286, 0.29228174435662024, 0.2108865811028564, 0.09028640789843523, 0.0811219253399057, 0.5277152438800404, 0.5421956880552337, 0.5371848597601263, 0.5539056642269482, 0.5194735384640599, 0.5561588441038776, 0.5596542965361134, 0.5583250450221192, 0.6056028992205758, 0.12865932397585222, 0.1377480013449709, 0.10661486218745286, 0.12827603914926, 0.13122349783755838, 0.14619667282929327, 0.10342573843772229, 0.13309652482005674, 0.10599802144848836, 0.2804696129167026, 0.15523819689051865, 0.23137948533948682, 0.3103027656763435, 0.32366898149245826, 0.1724643850980987, 0.30675539039382915, 0.17958348981977212, 0.25822253932543804, 0.3777144416742314, 0.6531099387698198, 0.3896845130152219, 0.4382177254960442, 0.5085018703744697, 0.4705087446487778, 0.4441790112514672, 0.50363718874942, 0.2862630252511683, 0.2448635044868499, 0.226943815768896, 0.36937710407362345, 0.2895107551544235, 0.37651197896845356, 0.20433650021898453, 0.18551878593971327, 0.3956593907814244, 0.503896439953034, 0.21358816585724993, 0.2583008942748568, 0.22612018085201202, 0.2177340544026356, 0.214179398761572, 0.20696022327622587, 0.2223383202174125, 0.24746274983525196, 0.2711488037599096, 0.24175111509147107, 0.2168874507365145, 0.24006926911487214, 0.1983052752163893, 0.19736071981838388, 0.18718801196898172, 0.22025356451460787, 0.19027900009963494, 0.21882776643777213, 0.20758994726667446, 0.18587207005126116, 0.19930773026847992, 0.18419083090956967, 0.1984075824684267, 0.19889566474766174, 0.14118732720071026, 0.1681645371203545, 0.8616710583960943, 0.7812504804342197, 0.21091261415817175, 0.5144094792756709, 0.20640759885015625, 0.16639172076427744, 0.6936700776304761, 0.10466214596643408, 0.205772443469171, 0.7841487474485777, 0.19477983716558922, 0.18371567165250524, 0.19695340599983124, 0.18363600431026694, 0.20333335578847578, 0.21149152234217583, 0.20804873414990566, 0.1957629606976482, 0.1975172061452095, 0.0966100013127914, 0.09657697365999574, 0.09305140170210457, 0.08225933978806155, 0.09018269266368006, 0.09449675359299692, 0.1000508379678855, 0.09853347068726404, 0.09210352399047028]}, "mutation_prompt": null}
{"id": "675b19e2-e800-4b84-8817-605d0075f855", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance exploration by dynamically adjusting the mutation factor and incorporating a random search mechanism.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c0fb1650-22da-4423-a3d1-43a71f874462", "metadata": {"aucs": [0.8435671376499423, 0.813821965027232, 0.8193146984381393, 0.8238782588528325, 0.8181580590960307, 0.8330929086778752, 0.8136430829651737, 0.8384596763249165, 0.830620455315433, 0.641523478823466, 0.6334803739832614, 0.6787732472158599, 0.6766782098441542, 0.6647111389199246, 0.6874039247988899, 0.666113388487388, 0.7247818405100646, 0.6808620463564657, 0.15381816764210876, 0.10730306727407768, 0.1513548449000498, 0.13362576832755435, 0.14870619424370346, 0.12175465429781884, 0.13610837638633133, 0.10806379913823516, 0.13567477396292538, 0.13634594884004914, 0.10437262336038455, 0.1501534467257989, 0.09175279595147623, 0.13431504204396694, 0.10217962512553791, 0.07479616648097231, 0.14234335946848642, 0.09574871249464578, 0.9715157854306803, 0.9777150148128568, 0.9650024427569011, 0.97743136410035, 0.9776450522793793, 0.9755389901383664, 0.9620280141543381, 0.9749482147631842, 0.9708676842966437, 0.7248570437952826, 0.7245999368622097, 0.7159431301021904, 0.2960383646999396, 0.7238507904862093, 0.7353638451629269, 0.7418072636575859, 0.7236286021881666, 0.7210752079739926, 0.8260082805660651, 0.3684367245803063, 0.2265877846719957, 0.27127286907523396, 0.2156498207277442, 0.748038263824488, 0.3753203045986836, 0.8077175844646098, 0.21798590718578648, 0.12110131116225398, 0.21978053308536383, 0.24120360894986048, 0.2619910211260046, 0.22528903460913285, 0.21654558541046554, 0.22231231405218355, 0.12439082676438995, 0.23797658929057597, 0.23789442261611227, 0.22540470737372664, 0.22447764367435297, 0.2824316182765436, 0.259348712130535, 0.247081588615374, 0.26197434719588464, 0.24656725175168426, 0.29432761621260084, 0.0026981267947514542, 0.05081632747825915, 9.999999999998899e-05, 0.04648319092598918, 0.00422665797700339, 9.999999999998899e-05, 0.08360862800964752, 0.0003568427059310597, 0.08237697534844157, 0.11894191880761151, 0.02591471398663725, 0.15121248575941793, 0.047802049512069456, 0.0023428444631268253, 0.025186182385502076, 0.08350270573646124, 0.05507664411122659, 0.11572490654796042, 0.02946698152652194, 0.22041967137598129, 0.2033304599834238, 0.10754233476136854, 0.08271940482310602, 0.06926531962922922, 0.15795400774111035, 0.06354727714908859, 0.07539068624484957, 0.04081449751588917, 0.05565604536908808, 0.2966901789462909, 0.1743302465660892, 0.07503780420997663, 0.15497168921260873, 0.2800814106027122, 0.20592406067700564, 0.07896588555325179, 0.5430952779215492, 0.5384963511061253, 0.5281062025666394, 0.5667886470541659, 0.5611380933507836, 0.5303285569442668, 0.5404958577614134, 0.5778534820593042, 0.5654961856373926, 0.12577386625423803, 0.12566879600555625, 0.10663697722092269, 0.1065041775682748, 0.12398041584692221, 0.09342787720545853, 0.13696148778654837, 0.12389710313395186, 0.12152475786419714, 0.18376180599804492, 0.5101699007019496, 0.23169275893521968, 0.2877383336165973, 0.35302289475876825, 0.2315164934379479, 0.2762474747073598, 0.21323431725103725, 0.2066090551230627, 0.4934793320833283, 0.31669116264172015, 0.34323238670760337, 0.36387338364411304, 0.32471497100192215, 0.36180838665251636, 0.36761837740606074, 0.5843938197584961, 0.3718103184237872, 0.25769776842533365, 0.2620220402057061, 0.328349630780821, 0.27783787655050085, 0.29413693921292716, 0.3178693925192393, 0.2835468856932234, 0.27503622289142526, 0.19279798483142596, 0.2474218376738334, 0.3018299048241444, 0.20863914060362465, 0.23791585611638433, 0.20340104099926914, 0.19715179796740068, 0.2259692635040168, 0.2232387716902513, 0.2579239898170259, 0.2456753298806056, 0.1902811214442841, 0.18943284315543873, 0.7561172435791639, 0.20555384564009593, 0.21817437453583532, 0.21176309184146969, 0.24454063291816197, 0.20590540145935043, 0.17173112789367007, 0.18195190898626712, 0.19949494974920934, 0.18626665443892043, 0.19820117460347642, 0.19788735380195044, 0.14171195967638928, 0.1691325984734383, 0.8278805916572685, 0.8049670823941989, 0.2079848631983151, 0.7242092442775575, 0.8554615841343303, 0.6249773520163429, 0.7848240218268692, 0.10449232459355184, 0.2088978400800705, 0.7958257966008164, 0.2092587607887213, 0.18960480966482451, 0.21053414806662252, 0.18869934478001194, 0.19146274795339768, 0.1955500159927892, 0.19168384946902228, 0.18309229106107405, 0.1900456638082546, 0.08295195910305286, 0.09910789531412845, 0.12855562819188104, 0.0927854248785761, 0.08167573283111229, 0.10671309347222613, 0.10110077159988795, 0.09846178225754065, 0.09276805935100785]}, "mutation_prompt": null}
{"id": "ccabbca5-2d6c-4d78-b155-dc7cd65d0cbd", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            population_diversity = np.std(pop, axis=0).mean()  # Calculate population diversity\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * (0.5 + 1.5 * population_diversity)  # Adaptive mutation\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < (self.crossover_rate * population_diversity)  # Adaptive crossover\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Improve convergence by introducing a self-adaptive mutation and crossover strategy based on population diversity.", "configspace": "", "generation": 34, "fitness": 0.3136772989263602, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.27.", "error": "", "parent_id": "c0fb1650-22da-4423-a3d1-43a71f874462", "metadata": {"aucs": [0.8266852891153552, 0.8468041541931554, 0.8341037855858902, 0.8250237885622502, 0.8298581996361835, 0.8438310606775561, 0.8306285937019335, 0.8466153317684975, 0.8199300577040912, 0.6261941090845012, 0.6159040825081035, 0.6845267359748596, 0.6572769516922548, 0.6367362474526495, 0.6388767668706202, 0.6606133085369559, 0.6363979444089363, 0.6317158560805347, 0.7365658307485129, 0.1281976958769837, 0.11628359426141777, 0.13382398880096114, 0.14697037255940626, 0.16561996786180877, 0.6751584940662243, 0.14690055153579673, 0.1503293960237685, 0.10669136426247527, 0.10501947343849038, 0.1716715810489604, 0.13409534078232987, 0.13985277823316233, 0.10926705910225742, 0.10590934066031821, 0.12701331012653772, 0.11196426210827082, 0.9784607765868285, 0.977142217067169, 0.9739821763404698, 0.9750283595969647, 0.9931761892042398, 0.9614568146656565, 0.9955451163428266, 0.9945332385415184, 0.9956526331721679, 0.7144420265275104, 0.721645362198262, 0.718498960799881, 0.7272510588228782, 0.7358618774691104, 0.6991262552767241, 0.7633058735623234, 0.6637614092306517, 0.7087888155129658, 0.8034298486706568, 0.3612214182066946, 0.3403626852819033, 0.21866586780912733, 0.2096873480779089, 0.3661275813298579, 0.22385895389608268, 0.8491028317177374, 0.2192353958714447, 0.12885583954257696, 0.19933169613003843, 0.21938939964259496, 0.13565117976442798, 0.22456581135850706, 0.21631511069328557, 0.19300955115672846, 0.1858299335524055, 0.21150496905488791, 0.19870418802103662, 0.02114643597124799, 0.2329072358399149, 0.26084045987911386, 0.212165302759445, 0.2607186072390998, 0.23516580678740184, 0.2283500061770264, 0.25712854143151775, 9.999999999998899e-05, 9.999999999998899e-05, 0.053044590443983575, 9.999999999998899e-05, 0.0030902720151158025, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08352707246435931, 0.05524688589735671, 0.10384306724309522, 0.06225492062124138, 0.057177263551361324, 0.05264692007953198, 0.03885891455733703, 0.06893945691330483, 0.06348844658011588, 0.03210279846191866, 0.05980462706627365, 0.11685397554967769, 0.15839170580157225, 0.23438307545920434, 0.07444826177104513, 0.2030415567947783, 0.08905266509078225, 0.20391207598381356, 0.0651302772324096, 0.09513490827607152, 0.2309599184741311, 0.09811603965002469, 0.05272210459215598, 0.12962640306944218, 0.04635570073643447, 0.12071683300372293, 0.09399914023058498, 0.5337007671815649, 0.5060201342854513, 0.5464703816409592, 0.547352970612325, 0.5048562287924607, 0.5188457506881172, 0.5414345795920322, 0.5623085064123974, 0.5420799081387646, 0.07968912538297734, 0.11837648580548499, 0.14896410227693613, 0.14977701399872767, 0.14588206073554377, 0.13805693032280175, 0.13396629053797182, 0.11978833276558343, 0.15263515369436687, 0.1690706866545465, 0.20668647154304942, 0.15411594769277703, 0.43627071625375624, 0.17518813474879447, 0.14201572700140186, 0.28719581860327803, 0.1515067091865825, 0.18233038490141973, 0.28791244765801105, 0.16532593530431294, 0.35504127743990876, 0.4580007649355704, 0.45018717503541306, 0.3900030234714402, 0.4967106170854315, 0.4666776575152115, 0.7003445372462611, 0.1829389138087778, 0.2783705391070551, 0.2713962588703547, 0.22895095006871835, 0.31398401690837263, 0.26904792821263546, 0.1972505681669493, 0.3875135947520425, 0.24172753222888843, 0.24763946600512354, 0.1835374740832284, 0.209632566939419, 0.2016108821877335, 0.22683747866451687, 0.20795592723498524, 0.22831038260098468, 0.223741425722923, 0.22712680994652024, 0.1983594079358797, 0.19670546505053343, 0.20232283207002355, 0.22122369505139916, 0.24176842245820807, 0.22145223860582441, 0.18983154301136362, 0.20633972271991963, 0.23555112619275287, 0.1648118956262843, 0.1676634982200671, 0.1516156036108488, 0.8308151774422322, 0.1968946852689034, 0.19764814742677173, 0.14192845287171296, 0.16857067117836033, 0.1687367866822267, 0.6242571572116382, 0.2107846388396052, 0.20326396924388557, 0.20935597574652398, 0.5574754334772729, 0.6764636331053715, 0.11172751033036399, 0.20695744314331865, 0.1957076080960043, 0.19919962279708114, 0.20144337054086647, 0.19249838973401956, 0.19387455641728857, 0.18730005369325253, 0.19295693663307678, 0.1928933110737464, 0.17442714155448924, 0.16488650923698733, 0.09061197061109794, 0.09985971481806244, 0.08736166084957186, 0.08606022525794765, 0.10368744513509986, 0.1522316236709006, 0.08598546260778295, 0.09099054000316131, 0.10587611274754194]}, "mutation_prompt": null}
{"id": "7695fa75-6815-4cdd-a5d0-56b01d61db32", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance exploration by dynamically adjusting the mutation factor and incorporating a random search mechanism.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c0fb1650-22da-4423-a3d1-43a71f874462", "metadata": {"aucs": [0.8435671376499423, 0.813821965027232, 0.8193146984381393, 0.8238782588528325, 0.8181580590960307, 0.8330929086778752, 0.8136430829651737, 0.8384596763249165, 0.830620455315433, 0.641523478823466, 0.6334803739832614, 0.6787732472158599, 0.6766782098441542, 0.6647111389199246, 0.6874039247988899, 0.666113388487388, 0.7247818405100646, 0.6808620463564657, 0.15381816764210876, 0.10730306727407768, 0.1513548449000498, 0.13362576832755435, 0.14870619424370346, 0.12175465429781884, 0.13610837638633133, 0.10806379913823516, 0.13567477396292538, 0.13634594884004914, 0.10437262336038455, 0.1501534467257989, 0.09175279595147623, 0.13431504204396694, 0.10217962512553791, 0.07479616648097231, 0.14234335946848642, 0.09574871249464578, 0.9715157854306803, 0.9777150148128568, 0.9650024427569011, 0.97743136410035, 0.9776450522793793, 0.9755389901383664, 0.9620280141543381, 0.9749482147631842, 0.9708676842966437, 0.7248570437952826, 0.7245999368622097, 0.7159431301021904, 0.2960383646999396, 0.7238507904862093, 0.7353638451629269, 0.7418072636575859, 0.7236286021881666, 0.7210752079739926, 0.8260082805660651, 0.3684367245803063, 0.2265877846719957, 0.27127286907523396, 0.2156498207277442, 0.748038263824488, 0.3753203045986836, 0.8077175844646098, 0.21798590718578648, 0.12110131116225398, 0.21978053308536383, 0.24120360894986048, 0.2619910211260046, 0.22528903460913285, 0.21654558541046554, 0.22231231405218355, 0.12439082676438995, 0.23797658929057597, 0.23789442261611227, 0.22540470737372664, 0.22447764367435297, 0.2824316182765436, 0.259348712130535, 0.247081588615374, 0.26197434719588464, 0.24656725175168426, 0.29432761621260084, 0.0026981267947514542, 0.05081632747825915, 9.999999999998899e-05, 0.04648319092598918, 0.00422665797700339, 9.999999999998899e-05, 0.08360862800964752, 0.0003568427059310597, 0.08237697534844157, 0.11894191880761151, 0.02591471398663725, 0.15121248575941793, 0.047802049512069456, 0.0023428444631268253, 0.025186182385502076, 0.08350270573646124, 0.05507664411122659, 0.11572490654796042, 0.02946698152652194, 0.22041967137598129, 0.2033304599834238, 0.10754233476136854, 0.08271940482310602, 0.06926531962922922, 0.15795400774111035, 0.06354727714908859, 0.07539068624484957, 0.04081449751588917, 0.05565604536908808, 0.2966901789462909, 0.1743302465660892, 0.07503780420997663, 0.15497168921260873, 0.2800814106027122, 0.20592406067700564, 0.07896588555325179, 0.5430952779215492, 0.5384963511061253, 0.5281062025666394, 0.5667886470541659, 0.5611380933507836, 0.5303285569442668, 0.5404958577614134, 0.5778534820593042, 0.5654961856373926, 0.12577386625423803, 0.12566879600555625, 0.10663697722092269, 0.1065041775682748, 0.12398041584692221, 0.09342787720545853, 0.13696148778654837, 0.12389710313395186, 0.12152475786419714, 0.18376180599804492, 0.5101699007019496, 0.23169275893521968, 0.2877383336165973, 0.35302289475876825, 0.2315164934379479, 0.2762474747073598, 0.21323431725103725, 0.2066090551230627, 0.4934793320833283, 0.31669116264172015, 0.34323238670760337, 0.36387338364411304, 0.32471497100192215, 0.36180838665251636, 0.36761837740606074, 0.5843938197584961, 0.3718103184237872, 0.25769776842533365, 0.2620220402057061, 0.328349630780821, 0.27783787655050085, 0.29413693921292716, 0.3178693925192393, 0.2835468856932234, 0.27503622289142526, 0.19279798483142596, 0.2474218376738334, 0.3018299048241444, 0.20863914060362465, 0.23791585611638433, 0.20340104099926914, 0.19715179796740068, 0.2259692635040168, 0.2232387716902513, 0.2579239898170259, 0.2456753298806056, 0.1902811214442841, 0.18943284315543873, 0.7561172435791639, 0.20555384564009593, 0.21817437453583532, 0.21176309184146969, 0.24454063291816197, 0.20590540145935043, 0.17173112789367007, 0.18195190898626712, 0.19949494974920934, 0.18626665443892043, 0.19820117460347642, 0.19788735380195044, 0.14171195967638928, 0.1691325984734383, 0.8278805916572685, 0.8049670823941989, 0.2079848631983151, 0.7242092442775575, 0.8554615841343303, 0.6249773520163429, 0.7848240218268692, 0.10449232459355184, 0.2088978400800705, 0.7958257966008164, 0.2092587607887213, 0.18960480966482451, 0.21053414806662252, 0.18869934478001194, 0.19146274795339768, 0.1955500159927892, 0.19168384946902228, 0.18309229106107405, 0.1900456638082546, 0.08295195910305286, 0.09910789531412845, 0.12855562819188104, 0.0927854248785761, 0.08167573283111229, 0.10671309347222613, 0.10110077159988795, 0.09846178225754065, 0.09276805935100785]}, "mutation_prompt": null}
{"id": "8b8fba41-c08a-4782-bfd2-2327120ee917", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (1 - evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Introduce adaptive crossover rate scaling and enhance velocity update strategy to improve convergence speed.", "configspace": "", "generation": 36, "fitness": 0.3251214145970208, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.27.", "error": "", "parent_id": "c0fb1650-22da-4423-a3d1-43a71f874462", "metadata": {"aucs": [0.8465244936149876, 0.8251614033144392, 0.8192128408128357, 0.8359083723926406, 0.8270651536521, 0.8426615044356205, 0.8281145871813471, 0.8320360411114563, 0.8195434148816373, 0.6287533794180693, 0.677143609129109, 0.6554073728329206, 0.6816857542043206, 0.6809644031793154, 0.6861385364364665, 0.6670431355436, 0.6895360261950816, 0.7057196996820146, 0.1113615157034541, 0.1401917380678438, 0.15120674058100558, 0.16996299901826073, 0.14996479296331422, 0.12150121175819606, 0.12998897966107703, 0.13397820375793035, 0.14847508542751964, 0.11349127322701369, 0.14680266126129882, 0.14872632559420473, 0.11470951253261796, 0.13407891780469794, 0.14366473533306723, 0.11301290954509169, 0.12196636036716813, 0.1291797233070774, 0.9715157854306803, 0.9779288551198984, 0.9650024427569011, 0.97743136410035, 0.9776450522793793, 0.9755389901383664, 0.9620140017966387, 0.9749482147631842, 0.9706044878989804, 0.7530986509962446, 0.7404022580116547, 0.7284758959143052, 0.5360166138274483, 0.7382544760349274, 0.7241189851386802, 0.7471162240455487, 0.7144671791993191, 0.7473189956936768, 0.3759584576126753, 0.16571407814453598, 0.22447015721734576, 0.7857115661607003, 0.8539822693453345, 0.3663324550839706, 0.3415998768133536, 0.22837393889741342, 0.22572284837108514, 0.12210029881253015, 0.1660306210674074, 0.2057962261213493, 0.20747578766546326, 0.21647996357596888, 0.22036628630817323, 0.21336507788717773, 0.24020578896721012, 0.20529874105292734, 0.22436839730367086, 0.26811401923422506, 0.20950060945638738, 0.2681310868565113, 0.21848673845790456, 0.13056348895450787, 0.24973500053242847, 0.25283217210846154, 0.23235241026147047, 0.043325959743344855, 0.016525120003915483, 9.999999999998899e-05, 0.03470996232935064, 9.999999999998899e-05, 9.999999999998899e-05, 0.03446151727688118, 0.009394431631245204, 0.042835527934629636, 0.1153368766059546, 0.020639143174883468, 0.12785679372218273, 0.042322502797020545, 0.024179279515668006, 0.03294718404926267, 0.0418872064182908, 0.06159277039294231, 0.04316511602139994, 0.051827292706190575, 0.16935282738739932, 0.14120114152008623, 0.11527399011606954, 0.08654132622789168, 0.06799012536728755, 0.17493450538803013, 0.07488044401907046, 0.12036851079604571, 0.079981633045492, 0.0537225203219297, 0.26790785640085013, 0.3550708739092002, 0.041273173384803186, 0.18550877442490632, 0.05408984987568233, 0.30988805837124644, 0.08416884612316844, 0.49567573530945364, 0.5167969433145112, 0.5411553172343748, 0.5678820902398667, 0.5118414889323553, 0.5075274165336418, 0.5596314200568167, 0.5574302386769795, 0.5312255642360306, 0.11388754827074044, 0.10673452885781753, 0.10714930480939433, 0.10563421142178342, 0.10572011223984268, 0.15087517660781702, 0.11759162013940128, 0.11158012658639926, 0.09790166143146306, 0.21779248384476746, 0.2553679971911479, 0.22781331615934486, 0.2853173202659973, 0.27130781205025556, 0.36172185036876425, 0.27134594569099957, 0.1503247657321144, 0.3012887032496063, 0.375966530070476, 0.33901179645893664, 0.303929550409451, 0.30131068850337084, 0.40000661519686453, 0.5606899186316445, 0.34378876850052176, 0.3106364956548908, 0.42824666735968386, 0.2015707532566724, 0.2921802485803189, 0.2717083691457446, 0.1940806652743018, 0.3036099290749926, 0.2989742789179496, 0.29135323383313205, 0.27718564992387906, 0.2614118112810787, 0.2361753370839893, 0.25566293781831395, 0.21236479712004686, 0.23417328225944234, 0.22323698509399303, 0.22916655667437924, 0.2172732359013354, 0.20654186567022048, 0.24262701954511146, 0.20814618025632747, 0.21133642722173673, 0.2158379439689302, 0.7442224591060898, 0.1889327369436029, 0.24459861565931174, 0.21409049531635072, 0.7578646050323951, 0.20568437916326587, 0.8827787512200298, 0.18201154263168118, 0.19876457894146227, 0.18603834392910712, 0.19834950581440358, 0.19840328934428475, 0.14166347311082494, 0.16913883307285593, 0.15190163553580116, 0.8636597262527058, 0.20807470094601555, 0.49454490813818086, 0.7921167053280103, 0.4400619209039891, 0.7610785073933871, 0.10447049445648648, 0.20620976793490797, 0.7643134754340852, 0.1849600953841004, 0.20034368462635121, 0.1922675401489342, 0.1884841158323457, 0.18794020836596725, 0.21053937699693892, 0.23496583762995982, 0.19326766437968557, 0.20122116739564877, 0.10054676070364399, 0.10089694333591781, 0.10761001716045615, 0.08880564262289448, 0.09507560141288574, 0.08915850889656518, 0.0868101070308056, 0.0812070963996685, 0.08911510453756655]}, "mutation_prompt": null}
{"id": "2e6169ae-eb6e-43ef-b785-b3ddb18ea1ca", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance exploration by dynamically adjusting the mutation factor and incorporating a random search mechanism.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c0fb1650-22da-4423-a3d1-43a71f874462", "metadata": {"aucs": [0.8435671376499423, 0.813821965027232, 0.8193146984381393, 0.8238782588528325, 0.8181580590960307, 0.8330929086778752, 0.8136430829651737, 0.8384596763249165, 0.830620455315433, 0.641523478823466, 0.6334803739832614, 0.6787732472158599, 0.6766782098441542, 0.6647111389199246, 0.6874039247988899, 0.666113388487388, 0.7247818405100646, 0.6808620463564657, 0.15381816764210876, 0.10730306727407768, 0.1513548449000498, 0.13362576832755435, 0.14870619424370346, 0.12175465429781884, 0.13610837638633133, 0.10806379913823516, 0.13567477396292538, 0.13634594884004914, 0.10437262336038455, 0.1501534467257989, 0.09175279595147623, 0.13431504204396694, 0.10217962512553791, 0.07479616648097231, 0.14234335946848642, 0.09574871249464578, 0.9715157854306803, 0.9777150148128568, 0.9650024427569011, 0.97743136410035, 0.9776450522793793, 0.9755389901383664, 0.9620280141543381, 0.9749482147631842, 0.9708676842966437, 0.7248570437952826, 0.7245999368622097, 0.7159431301021904, 0.2960383646999396, 0.7238507904862093, 0.7353638451629269, 0.7418072636575859, 0.7236286021881666, 0.7210752079739926, 0.8260082805660651, 0.3684367245803063, 0.2265877846719957, 0.27127286907523396, 0.2156498207277442, 0.748038263824488, 0.3753203045986836, 0.8077175844646098, 0.21798590718578648, 0.12110131116225398, 0.21978053308536383, 0.24120360894986048, 0.2619910211260046, 0.22528903460913285, 0.21654558541046554, 0.22231231405218355, 0.12439082676438995, 0.23797658929057597, 0.23789442261611227, 0.22540470737372664, 0.22447764367435297, 0.2824316182765436, 0.259348712130535, 0.247081588615374, 0.26197434719588464, 0.24656725175168426, 0.29432761621260084, 0.0026981267947514542, 0.05081632747825915, 9.999999999998899e-05, 0.04648319092598918, 0.00422665797700339, 9.999999999998899e-05, 0.08360862800964752, 0.0003568427059310597, 0.08237697534844157, 0.11894191880761151, 0.02591471398663725, 0.15121248575941793, 0.047802049512069456, 0.0023428444631268253, 0.025186182385502076, 0.08350270573646124, 0.05507664411122659, 0.11572490654796042, 0.02946698152652194, 0.22041967137598129, 0.2033304599834238, 0.10754233476136854, 0.08271940482310602, 0.06926531962922922, 0.15795400774111035, 0.06354727714908859, 0.07539068624484957, 0.04081449751588917, 0.05565604536908808, 0.2966901789462909, 0.1743302465660892, 0.07503780420997663, 0.15497168921260873, 0.2800814106027122, 0.20592406067700564, 0.07896588555325179, 0.5430952779215492, 0.5384963511061253, 0.5281062025666394, 0.5667886470541659, 0.5611380933507836, 0.5303285569442668, 0.5404958577614134, 0.5778534820593042, 0.5654961856373926, 0.12577386625423803, 0.12566879600555625, 0.10663697722092269, 0.1065041775682748, 0.12398041584692221, 0.09342787720545853, 0.13696148778654837, 0.12389710313395186, 0.12152475786419714, 0.18376180599804492, 0.5101699007019496, 0.23169275893521968, 0.2877383336165973, 0.35302289475876825, 0.2315164934379479, 0.2762474747073598, 0.21323431725103725, 0.2066090551230627, 0.4934793320833283, 0.31669116264172015, 0.34323238670760337, 0.36387338364411304, 0.32471497100192215, 0.36180838665251636, 0.36761837740606074, 0.5843938197584961, 0.3718103184237872, 0.25769776842533365, 0.2620220402057061, 0.328349630780821, 0.27783787655050085, 0.29413693921292716, 0.3178693925192393, 0.2835468856932234, 0.27503622289142526, 0.19279798483142596, 0.2474218376738334, 0.3018299048241444, 0.20863914060362465, 0.23791585611638433, 0.20340104099926914, 0.19715179796740068, 0.2259692635040168, 0.2232387716902513, 0.2579239898170259, 0.2456753298806056, 0.1902811214442841, 0.18943284315543873, 0.7561172435791639, 0.20555384564009593, 0.21817437453583532, 0.21176309184146969, 0.24454063291816197, 0.20590540145935043, 0.17173112789367007, 0.18195190898626712, 0.19949494974920934, 0.18626665443892043, 0.19820117460347642, 0.19788735380195044, 0.14171195967638928, 0.1691325984734383, 0.8278805916572685, 0.8049670823941989, 0.2079848631983151, 0.7242092442775575, 0.8554615841343303, 0.6249773520163429, 0.7848240218268692, 0.10449232459355184, 0.2088978400800705, 0.7958257966008164, 0.2092587607887213, 0.18960480966482451, 0.21053414806662252, 0.18869934478001194, 0.19146274795339768, 0.1955500159927892, 0.19168384946902228, 0.18309229106107405, 0.1900456638082546, 0.08295195910305286, 0.09910789531412845, 0.12855562819188104, 0.0927854248785761, 0.08167573283111229, 0.10671309347222613, 0.10110077159988795, 0.09846178225754065, 0.09276805935100785]}, "mutation_prompt": null}
{"id": "09435ac7-a20d-4616-b0c3-b4f4f3dddce5", "solution": "import numpy as np\nfrom scipy.stats import levy_stable\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                levy_mutation_factor = levy_stable.rvs(alpha=1.5, beta=0, size=1)[0]  # Levy flight adjustment\n                mutant_vector = clip(a + levy_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance exploration in the DE phase by incorporating Levy flight distribution for mutation factor adjustment.", "configspace": "", "generation": 38, "fitness": 0.3153911402552287, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "c0fb1650-22da-4423-a3d1-43a71f874462", "metadata": {"aucs": [0.8306062434070673, 0.8243236451981663, 0.8245177055708148, 0.8319608902084674, 0.8356171153784493, 0.8259659342535887, 0.8250383977661642, 0.8232828416047093, 0.8386232644994094, 0.6930547003768285, 0.6084605345959451, 0.6594759302098937, 0.6505831336888613, 0.6692283999054205, 0.6919040718716185, 9.999999999998899e-05, 0.6285353043149372, 0.6708357279305401, 0.09269095282061879, 0.10697685576617111, 0.11740457139182292, 0.14938414031033276, 0.11181937253845808, 0.13503784692460397, 0.17634476929096565, 0.1351541586216577, 0.11367437964748661, 0.11023358136515438, 0.11301208814787111, 0.14599372658324972, 0.12397279630873814, 0.1342336197850249, 0.11049158267857295, 0.09223227505081721, 0.11147871494404626, 0.10266285387714835, 0.9708885033361264, 0.978058658124797, 0.9713354781849548, 0.9765684918577561, 0.9779914967461583, 0.9730008988000759, 0.9763866175248199, 0.973755026967609, 0.9773295006668251, 0.7421443573853822, 0.7208999473033234, 0.7265295931824026, 0.7314066522864342, 0.14693434838818198, 0.7561540641679367, 0.7012755251372329, 0.7324342681914545, 0.7461139063576232, 0.22285780626829677, 0.168680856952787, 0.22463294707487302, 0.3635790868971097, 0.8579289261355463, 0.20915556329963259, 0.13643703594306988, 0.7022383629351825, 0.22978950049278657, 0.3120500514142661, 0.21521718137672574, 0.22687951209818813, 0.2365362374574329, 0.1259840715681092, 0.11858724341048532, 0.21563204446555406, 0.20421458607439058, 0.20551165307370878, 0.2441180077572972, 0.2559563472921441, 0.22005756765934525, 0.12839220020020403, 0.2486523955292015, 0.26518800497246264, 0.12779896507259547, 0.24387295846944013, 0.25910839729912893, 9.999999999998899e-05, 9.999999999998899e-05, 0.10144336081100991, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10666646837996563, 0.08162648233783198, 0.046948729556769875, 0.10355702255612087, 0.05322606159753285, 0.0341937374557445, 0.04679250640437238, 0.08588213294834646, 0.05113960811535034, 0.10704904522009906, 0.19720436280823295, 0.05967207241483374, 0.1052568032010468, 0.0715995984286345, 0.07228016033739515, 0.15621352172408298, 0.30980713325914244, 0.09230511938413277, 0.08650994227404551, 0.22892175998837505, 0.15108652394030264, 0.18099141642031868, 0.006157216347408068, 0.09035232182891428, 0.0061573214181250835, 0.08183655809069823, 0.06997123358135249, 0.10694938279631083, 0.5611621118115233, 0.5493780974792217, 0.5323403683249368, 0.5196045887442604, 0.5419854282320896, 0.5544100294362199, 0.5461813997919935, 0.566474523153657, 0.5624982694869711, 0.09938410859874713, 0.17957482266509162, 0.12203747864610681, 0.13948399545219603, 0.11617450058616974, 0.09113341874586278, 0.12175649811129774, 0.12322329577881697, 0.1471622201214201, 0.3288787461008942, 0.20769479661800982, 0.18616412319221431, 0.35887366024704537, 0.23968007468621, 0.22554648673135158, 0.3272346896868801, 0.2516053326839054, 0.25808940236717204, 0.3728559421403066, 0.45823216287004453, 0.359595224141378, 0.4079054888754775, 0.4307878138760681, 0.37057162623182904, 0.559585177581251, 0.561620352018393, 0.45395293161437034, 0.18382212269807985, 0.4462142313536157, 0.3121855501528066, 0.2704670044474009, 0.18778539195791444, 0.3059939503212925, 0.23724299102130852, 0.3528133543337615, 0.2747364220587928, 0.2279275997410365, 0.1942148002724683, 0.24841472795128805, 0.23795076025564554, 0.20906323586518094, 0.23689805285237175, 0.21783538468167907, 0.2067062864654009, 0.2274911574768268, 0.1918343149741385, 0.20752023189304714, 0.7066340431571623, 0.20641382457520163, 0.19742974703352223, 0.2057262341470666, 0.18881564462658984, 0.24173108358906958, 0.21648526582936212, 0.17651312438971167, 0.8399091002417528, 0.14625436937816594, 0.8915309831957972, 0.1989431148317331, 0.19850254316335947, 0.14176591667639582, 0.16886433691375657, 0.8633769286769285, 0.7624869876859284, 0.2093594366002417, 0.20619017115251626, 0.21072078293973773, 0.1681450377378263, 0.15323428175114417, 0.8539582853325794, 0.10449722438969544, 0.2038936765398789, 0.19669674476441967, 0.221245322243125, 0.17891048819511401, 0.19120308677735431, 0.22108664775297437, 0.19306650579617612, 0.1908411619470749, 0.19034260177334505, 0.18621118109541768, 0.11319200978836219, 0.09976125799887503, 0.1000669018794762, 0.09605257245201393, 0.09952434608754379, 0.1043409916410295, 0.09107038595247308, 0.12729344849006974, 0.09656716207682314]}, "mutation_prompt": null}
{"id": "2a5792b1-cfb9-4cbb-9f8e-2f71592bb4cb", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance exploration by dynamically adjusting the mutation factor and incorporating a random search mechanism.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c0fb1650-22da-4423-a3d1-43a71f874462", "metadata": {"aucs": [0.8435671376499423, 0.813821965027232, 0.8193146984381393, 0.8238782588528325, 0.8181580590960307, 0.8330929086778752, 0.8136430829651737, 0.8384596763249165, 0.830620455315433, 0.641523478823466, 0.6334803739832614, 0.6787732472158599, 0.6766782098441542, 0.6647111389199246, 0.6874039247988899, 0.666113388487388, 0.7247818405100646, 0.6808620463564657, 0.15381816764210876, 0.10730306727407768, 0.1513548449000498, 0.13362576832755435, 0.14870619424370346, 0.12175465429781884, 0.13610837638633133, 0.10806379913823516, 0.13567477396292538, 0.13634594884004914, 0.10437262336038455, 0.1501534467257989, 0.09175279595147623, 0.13431504204396694, 0.10217962512553791, 0.07479616648097231, 0.14234335946848642, 0.09574871249464578, 0.9715157854306803, 0.9777150148128568, 0.9650024427569011, 0.97743136410035, 0.9776450522793793, 0.9755389901383664, 0.9620280141543381, 0.9749482147631842, 0.9708676842966437, 0.7248570437952826, 0.7245999368622097, 0.7159431301021904, 0.2960383646999396, 0.7238507904862093, 0.7353638451629269, 0.7418072636575859, 0.7236286021881666, 0.7210752079739926, 0.8260082805660651, 0.3684367245803063, 0.2265877846719957, 0.27127286907523396, 0.2156498207277442, 0.748038263824488, 0.3753203045986836, 0.8077175844646098, 0.21798590718578648, 0.12110131116225398, 0.21978053308536383, 0.24120360894986048, 0.2619910211260046, 0.22528903460913285, 0.21654558541046554, 0.22231231405218355, 0.12439082676438995, 0.23797658929057597, 0.23789442261611227, 0.22540470737372664, 0.22447764367435297, 0.2824316182765436, 0.259348712130535, 0.247081588615374, 0.26197434719588464, 0.24656725175168426, 0.29432761621260084, 0.0026981267947514542, 0.05081632747825915, 9.999999999998899e-05, 0.04648319092598918, 0.00422665797700339, 9.999999999998899e-05, 0.08360862800964752, 0.0003568427059310597, 0.08237697534844157, 0.11894191880761151, 0.02591471398663725, 0.15121248575941793, 0.047802049512069456, 0.0023428444631268253, 0.025186182385502076, 0.08350270573646124, 0.05507664411122659, 0.11572490654796042, 0.02946698152652194, 0.22041967137598129, 0.2033304599834238, 0.10754233476136854, 0.08271940482310602, 0.06926531962922922, 0.15795400774111035, 0.06354727714908859, 0.07539068624484957, 0.04081449751588917, 0.05565604536908808, 0.2966901789462909, 0.1743302465660892, 0.07503780420997663, 0.15497168921260873, 0.2800814106027122, 0.20592406067700564, 0.07896588555325179, 0.5430952779215492, 0.5384963511061253, 0.5281062025666394, 0.5667886470541659, 0.5611380933507836, 0.5303285569442668, 0.5404958577614134, 0.5778534820593042, 0.5654961856373926, 0.12577386625423803, 0.12566879600555625, 0.10663697722092269, 0.1065041775682748, 0.12398041584692221, 0.09342787720545853, 0.13696148778654837, 0.12389710313395186, 0.12152475786419714, 0.18376180599804492, 0.5101699007019496, 0.23169275893521968, 0.2877383336165973, 0.35302289475876825, 0.2315164934379479, 0.2762474747073598, 0.21323431725103725, 0.2066090551230627, 0.4934793320833283, 0.31669116264172015, 0.34323238670760337, 0.36387338364411304, 0.32471497100192215, 0.36180838665251636, 0.36761837740606074, 0.5843938197584961, 0.3718103184237872, 0.25769776842533365, 0.2620220402057061, 0.328349630780821, 0.27783787655050085, 0.29413693921292716, 0.3178693925192393, 0.2835468856932234, 0.27503622289142526, 0.19279798483142596, 0.2474218376738334, 0.3018299048241444, 0.20863914060362465, 0.23791585611638433, 0.20340104099926914, 0.19715179796740068, 0.2259692635040168, 0.2232387716902513, 0.2579239898170259, 0.2456753298806056, 0.1902811214442841, 0.18943284315543873, 0.7561172435791639, 0.20555384564009593, 0.21817437453583532, 0.21176309184146969, 0.24454063291816197, 0.20590540145935043, 0.17173112789367007, 0.18195190898626712, 0.19949494974920934, 0.18626665443892043, 0.19820117460347642, 0.19788735380195044, 0.14171195967638928, 0.1691325984734383, 0.8278805916572685, 0.8049670823941989, 0.2079848631983151, 0.7242092442775575, 0.8554615841343303, 0.6249773520163429, 0.7848240218268692, 0.10449232459355184, 0.2088978400800705, 0.7958257966008164, 0.2092587607887213, 0.18960480966482451, 0.21053414806662252, 0.18869934478001194, 0.19146274795339768, 0.1955500159927892, 0.19168384946902228, 0.18309229106107405, 0.1900456638082546, 0.08295195910305286, 0.09910789531412845, 0.12855562819188104, 0.0927854248785761, 0.08167573283111229, 0.10671309347222613, 0.10110077159988795, 0.09846178225754065, 0.09276805935100785]}, "mutation_prompt": null}
{"id": "1c03b5cb-8d83-4b9f-ace4-71c1e1306dd9", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n        position_history = np.copy(pop)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (1 - evals / self.budget) # Added adaptive crossover rate\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i] + 0.1 * (position_history[i] - pop[i]))) # Introduced position history\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n            position_history = np.copy(pop) # Update position history\n\n        return global_best", "name": "HybridDEPSO", "description": "Introduce adaptive adjustment of crossover rate and integrate a convergence acceleration mechanism based on position history.", "configspace": "", "generation": 40, "fitness": 0.3251214145970208, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.27.", "error": "", "parent_id": "c0fb1650-22da-4423-a3d1-43a71f874462", "metadata": {"aucs": [0.8465244936149876, 0.8251614033144392, 0.8192128408128357, 0.8359083723926406, 0.8270651536521, 0.8426615044356205, 0.8281145871813471, 0.8320360411114563, 0.8195434148816373, 0.6287533794180693, 0.677143609129109, 0.6554073728329206, 0.6816857542043206, 0.6809644031793154, 0.6861385364364665, 0.6670431355436, 0.6895360261950816, 0.7057196996820146, 0.1113615157034541, 0.1401917380678438, 0.15120674058100558, 0.16996299901826073, 0.14996479296331422, 0.12150121175819606, 0.12998897966107703, 0.13397820375793035, 0.14847508542751964, 0.11349127322701369, 0.14680266126129882, 0.14872632559420473, 0.11470951253261796, 0.13407891780469794, 0.14366473533306723, 0.11301290954509169, 0.12196636036716813, 0.1291797233070774, 0.9715157854306803, 0.9779288551198984, 0.9650024427569011, 0.97743136410035, 0.9776450522793793, 0.9755389901383664, 0.9620140017966387, 0.9749482147631842, 0.9706044878989804, 0.7530986509962446, 0.7404022580116547, 0.7284758959143052, 0.5360166138274483, 0.7382544760349274, 0.7241189851386802, 0.7471162240455487, 0.7144671791993191, 0.7473189956936768, 0.3759584576126753, 0.16571407814453598, 0.22447015721734576, 0.7857115661607003, 0.8539822693453345, 0.3663324550839706, 0.3415998768133536, 0.22837393889741342, 0.22572284837108514, 0.12210029881253015, 0.1660306210674074, 0.2057962261213493, 0.20747578766546326, 0.21647996357596888, 0.22036628630817323, 0.21336507788717773, 0.24020578896721012, 0.20529874105292734, 0.22436839730367086, 0.26811401923422506, 0.20950060945638738, 0.2681310868565113, 0.21848673845790456, 0.13056348895450787, 0.24973500053242847, 0.25283217210846154, 0.23235241026147047, 0.043325959743344855, 0.016525120003915483, 9.999999999998899e-05, 0.03470996232935064, 9.999999999998899e-05, 9.999999999998899e-05, 0.03446151727688118, 0.009394431631245204, 0.042835527934629636, 0.1153368766059546, 0.020639143174883468, 0.12785679372218273, 0.042322502797020545, 0.024179279515668006, 0.03294718404926267, 0.0418872064182908, 0.06159277039294231, 0.04316511602139994, 0.051827292706190575, 0.16935282738739932, 0.14120114152008623, 0.11527399011606954, 0.08654132622789168, 0.06799012536728755, 0.17493450538803013, 0.07488044401907046, 0.12036851079604571, 0.079981633045492, 0.0537225203219297, 0.26790785640085013, 0.3550708739092002, 0.041273173384803186, 0.18550877442490632, 0.05408984987568233, 0.30988805837124644, 0.08416884612316844, 0.49567573530945364, 0.5167969433145112, 0.5411553172343748, 0.5678820902398667, 0.5118414889323553, 0.5075274165336418, 0.5596314200568167, 0.5574302386769795, 0.5312255642360306, 0.11388754827074044, 0.10673452885781753, 0.10714930480939433, 0.10563421142178342, 0.10572011223984268, 0.15087517660781702, 0.11759162013940128, 0.11158012658639926, 0.09790166143146306, 0.21779248384476746, 0.2553679971911479, 0.22781331615934486, 0.2853173202659973, 0.27130781205025556, 0.36172185036876425, 0.27134594569099957, 0.1503247657321144, 0.3012887032496063, 0.375966530070476, 0.33901179645893664, 0.303929550409451, 0.30131068850337084, 0.40000661519686453, 0.5606899186316445, 0.34378876850052176, 0.3106364956548908, 0.42824666735968386, 0.2015707532566724, 0.2921802485803189, 0.2717083691457446, 0.1940806652743018, 0.3036099290749926, 0.2989742789179496, 0.29135323383313205, 0.27718564992387906, 0.2614118112810787, 0.2361753370839893, 0.25566293781831395, 0.21236479712004686, 0.23417328225944234, 0.22323698509399303, 0.22916655667437924, 0.2172732359013354, 0.20654186567022048, 0.24262701954511146, 0.20814618025632747, 0.21133642722173673, 0.2158379439689302, 0.7442224591060898, 0.1889327369436029, 0.24459861565931174, 0.21409049531635072, 0.7578646050323951, 0.20568437916326587, 0.8827787512200298, 0.18201154263168118, 0.19876457894146227, 0.18603834392910712, 0.19834950581440358, 0.19840328934428475, 0.14166347311082494, 0.16913883307285593, 0.15190163553580116, 0.8636597262527058, 0.20807470094601555, 0.49454490813818086, 0.7921167053280103, 0.4400619209039891, 0.7610785073933871, 0.10447049445648648, 0.20620976793490797, 0.7643134754340852, 0.1849600953841004, 0.20034368462635121, 0.1922675401489342, 0.1884841158323457, 0.18794020836596725, 0.21053937699693892, 0.23496583762995982, 0.19326766437968557, 0.20122116739564877, 0.10054676070364399, 0.10089694333591781, 0.10761001716045615, 0.08880564262289448, 0.09507560141288574, 0.08915850889656518, 0.0868101070308056, 0.0812070963996685, 0.08911510453756655]}, "mutation_prompt": null}
{"id": "71a55c8d-c24b-4249-a421-da1c3f4771d3", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance exploration by dynamically adjusting the mutation factor and incorporating a random search mechanism.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c0fb1650-22da-4423-a3d1-43a71f874462", "metadata": {"aucs": [0.8435671376499423, 0.813821965027232, 0.8193146984381393, 0.8238782588528325, 0.8181580590960307, 0.8330929086778752, 0.8136430829651737, 0.8384596763249165, 0.830620455315433, 0.641523478823466, 0.6334803739832614, 0.6787732472158599, 0.6766782098441542, 0.6647111389199246, 0.6874039247988899, 0.666113388487388, 0.7247818405100646, 0.6808620463564657, 0.15381816764210876, 0.10730306727407768, 0.1513548449000498, 0.13362576832755435, 0.14870619424370346, 0.12175465429781884, 0.13610837638633133, 0.10806379913823516, 0.13567477396292538, 0.13634594884004914, 0.10437262336038455, 0.1501534467257989, 0.09175279595147623, 0.13431504204396694, 0.10217962512553791, 0.07479616648097231, 0.14234335946848642, 0.09574871249464578, 0.9715157854306803, 0.9777150148128568, 0.9650024427569011, 0.97743136410035, 0.9776450522793793, 0.9755389901383664, 0.9620280141543381, 0.9749482147631842, 0.9708676842966437, 0.7248570437952826, 0.7245999368622097, 0.7159431301021904, 0.2960383646999396, 0.7238507904862093, 0.7353638451629269, 0.7418072636575859, 0.7236286021881666, 0.7210752079739926, 0.8260082805660651, 0.3684367245803063, 0.2265877846719957, 0.27127286907523396, 0.2156498207277442, 0.748038263824488, 0.3753203045986836, 0.8077175844646098, 0.21798590718578648, 0.12110131116225398, 0.21978053308536383, 0.24120360894986048, 0.2619910211260046, 0.22528903460913285, 0.21654558541046554, 0.22231231405218355, 0.12439082676438995, 0.23797658929057597, 0.23789442261611227, 0.22540470737372664, 0.22447764367435297, 0.2824316182765436, 0.259348712130535, 0.247081588615374, 0.26197434719588464, 0.24656725175168426, 0.29432761621260084, 0.0026981267947514542, 0.05081632747825915, 9.999999999998899e-05, 0.04648319092598918, 0.00422665797700339, 9.999999999998899e-05, 0.08360862800964752, 0.0003568427059310597, 0.08237697534844157, 0.11894191880761151, 0.02591471398663725, 0.15121248575941793, 0.047802049512069456, 0.0023428444631268253, 0.025186182385502076, 0.08350270573646124, 0.05507664411122659, 0.11572490654796042, 0.02946698152652194, 0.22041967137598129, 0.2033304599834238, 0.10754233476136854, 0.08271940482310602, 0.06926531962922922, 0.15795400774111035, 0.06354727714908859, 0.07539068624484957, 0.04081449751588917, 0.05565604536908808, 0.2966901789462909, 0.1743302465660892, 0.07503780420997663, 0.15497168921260873, 0.2800814106027122, 0.20592406067700564, 0.07896588555325179, 0.5430952779215492, 0.5384963511061253, 0.5281062025666394, 0.5667886470541659, 0.5611380933507836, 0.5303285569442668, 0.5404958577614134, 0.5778534820593042, 0.5654961856373926, 0.12577386625423803, 0.12566879600555625, 0.10663697722092269, 0.1065041775682748, 0.12398041584692221, 0.09342787720545853, 0.13696148778654837, 0.12389710313395186, 0.12152475786419714, 0.18376180599804492, 0.5101699007019496, 0.23169275893521968, 0.2877383336165973, 0.35302289475876825, 0.2315164934379479, 0.2762474747073598, 0.21323431725103725, 0.2066090551230627, 0.4934793320833283, 0.31669116264172015, 0.34323238670760337, 0.36387338364411304, 0.32471497100192215, 0.36180838665251636, 0.36761837740606074, 0.5843938197584961, 0.3718103184237872, 0.25769776842533365, 0.2620220402057061, 0.328349630780821, 0.27783787655050085, 0.29413693921292716, 0.3178693925192393, 0.2835468856932234, 0.27503622289142526, 0.19279798483142596, 0.2474218376738334, 0.3018299048241444, 0.20863914060362465, 0.23791585611638433, 0.20340104099926914, 0.19715179796740068, 0.2259692635040168, 0.2232387716902513, 0.2579239898170259, 0.2456753298806056, 0.1902811214442841, 0.18943284315543873, 0.7561172435791639, 0.20555384564009593, 0.21817437453583532, 0.21176309184146969, 0.24454063291816197, 0.20590540145935043, 0.17173112789367007, 0.18195190898626712, 0.19949494974920934, 0.18626665443892043, 0.19820117460347642, 0.19788735380195044, 0.14171195967638928, 0.1691325984734383, 0.8278805916572685, 0.8049670823941989, 0.2079848631983151, 0.7242092442775575, 0.8554615841343303, 0.6249773520163429, 0.7848240218268692, 0.10449232459355184, 0.2088978400800705, 0.7958257966008164, 0.2092587607887213, 0.18960480966482451, 0.21053414806662252, 0.18869934478001194, 0.19146274795339768, 0.1955500159927892, 0.19168384946902228, 0.18309229106107405, 0.1900456638082546, 0.08295195910305286, 0.09910789531412845, 0.12855562819188104, 0.0927854248785761, 0.08167573283111229, 0.10671309347222613, 0.10110077159988795, 0.09846178225754065, 0.09276805935100785]}, "mutation_prompt": null}
{"id": "a796ae0c-3643-4814-aa50-d608026639b5", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance exploration by dynamically adjusting the mutation factor and incorporating a random search mechanism.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c0fb1650-22da-4423-a3d1-43a71f874462", "metadata": {"aucs": [0.8435671376499423, 0.813821965027232, 0.8193146984381393, 0.8238782588528325, 0.8181580590960307, 0.8330929086778752, 0.8136430829651737, 0.8384596763249165, 0.830620455315433, 0.641523478823466, 0.6334803739832614, 0.6787732472158599, 0.6766782098441542, 0.6647111389199246, 0.6874039247988899, 0.666113388487388, 0.7247818405100646, 0.6808620463564657, 0.15381816764210876, 0.10730306727407768, 0.1513548449000498, 0.13362576832755435, 0.14870619424370346, 0.12175465429781884, 0.13610837638633133, 0.10806379913823516, 0.13567477396292538, 0.13634594884004914, 0.10437262336038455, 0.1501534467257989, 0.09175279595147623, 0.13431504204396694, 0.10217962512553791, 0.07479616648097231, 0.14234335946848642, 0.09574871249464578, 0.9715157854306803, 0.9777150148128568, 0.9650024427569011, 0.97743136410035, 0.9776450522793793, 0.9755389901383664, 0.9620280141543381, 0.9749482147631842, 0.9708676842966437, 0.7248570437952826, 0.7245999368622097, 0.7159431301021904, 0.2960383646999396, 0.7238507904862093, 0.7353638451629269, 0.7418072636575859, 0.7236286021881666, 0.7210752079739926, 0.8260082805660651, 0.3684367245803063, 0.2265877846719957, 0.27127286907523396, 0.2156498207277442, 0.748038263824488, 0.3753203045986836, 0.8077175844646098, 0.21798590718578648, 0.12110131116225398, 0.21978053308536383, 0.24120360894986048, 0.2619910211260046, 0.22528903460913285, 0.21654558541046554, 0.22231231405218355, 0.12439082676438995, 0.23797658929057597, 0.23789442261611227, 0.22540470737372664, 0.22447764367435297, 0.2824316182765436, 0.259348712130535, 0.247081588615374, 0.26197434719588464, 0.24656725175168426, 0.29432761621260084, 0.0026981267947514542, 0.05081632747825915, 9.999999999998899e-05, 0.04648319092598918, 0.00422665797700339, 9.999999999998899e-05, 0.08360862800964752, 0.0003568427059310597, 0.08237697534844157, 0.11894191880761151, 0.02591471398663725, 0.15121248575941793, 0.047802049512069456, 0.0023428444631268253, 0.025186182385502076, 0.08350270573646124, 0.05507664411122659, 0.11572490654796042, 0.02946698152652194, 0.22041967137598129, 0.2033304599834238, 0.10754233476136854, 0.08271940482310602, 0.06926531962922922, 0.15795400774111035, 0.06354727714908859, 0.07539068624484957, 0.04081449751588917, 0.05565604536908808, 0.2966901789462909, 0.1743302465660892, 0.07503780420997663, 0.15497168921260873, 0.2800814106027122, 0.20592406067700564, 0.07896588555325179, 0.5430952779215492, 0.5384963511061253, 0.5281062025666394, 0.5667886470541659, 0.5611380933507836, 0.5303285569442668, 0.5404958577614134, 0.5778534820593042, 0.5654961856373926, 0.12577386625423803, 0.12566879600555625, 0.10663697722092269, 0.1065041775682748, 0.12398041584692221, 0.09342787720545853, 0.13696148778654837, 0.12389710313395186, 0.12152475786419714, 0.18376180599804492, 0.5101699007019496, 0.23169275893521968, 0.2877383336165973, 0.35302289475876825, 0.2315164934379479, 0.2762474747073598, 0.21323431725103725, 0.2066090551230627, 0.4934793320833283, 0.31669116264172015, 0.34323238670760337, 0.36387338364411304, 0.32471497100192215, 0.36180838665251636, 0.36761837740606074, 0.5843938197584961, 0.3718103184237872, 0.25769776842533365, 0.2620220402057061, 0.328349630780821, 0.27783787655050085, 0.29413693921292716, 0.3178693925192393, 0.2835468856932234, 0.27503622289142526, 0.19279798483142596, 0.2474218376738334, 0.3018299048241444, 0.20863914060362465, 0.23791585611638433, 0.20340104099926914, 0.19715179796740068, 0.2259692635040168, 0.2232387716902513, 0.2579239898170259, 0.2456753298806056, 0.1902811214442841, 0.18943284315543873, 0.7561172435791639, 0.20555384564009593, 0.21817437453583532, 0.21176309184146969, 0.24454063291816197, 0.20590540145935043, 0.17173112789367007, 0.18195190898626712, 0.19949494974920934, 0.18626665443892043, 0.19820117460347642, 0.19788735380195044, 0.14171195967638928, 0.1691325984734383, 0.8278805916572685, 0.8049670823941989, 0.2079848631983151, 0.7242092442775575, 0.8554615841343303, 0.6249773520163429, 0.7848240218268692, 0.10449232459355184, 0.2088978400800705, 0.7958257966008164, 0.2092587607887213, 0.18960480966482451, 0.21053414806662252, 0.18869934478001194, 0.19146274795339768, 0.1955500159927892, 0.19168384946902228, 0.18309229106107405, 0.1900456638082546, 0.08295195910305286, 0.09910789531412845, 0.12855562819188104, 0.0927854248785761, 0.08167573283111229, 0.10671309347222613, 0.10110077159988795, 0.09846178225754065, 0.09276805935100785]}, "mutation_prompt": null}
{"id": "6effd79e-1de6-4ad0-9094-7a183937c72a", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance exploration by dynamically adjusting the mutation factor and incorporating a random search mechanism.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c0fb1650-22da-4423-a3d1-43a71f874462", "metadata": {"aucs": [0.8435671376499423, 0.813821965027232, 0.8193146984381393, 0.8238782588528325, 0.8181580590960307, 0.8330929086778752, 0.8136430829651737, 0.8384596763249165, 0.830620455315433, 0.641523478823466, 0.6334803739832614, 0.6787732472158599, 0.6766782098441542, 0.6647111389199246, 0.6874039247988899, 0.666113388487388, 0.7247818405100646, 0.6808620463564657, 0.15381816764210876, 0.10730306727407768, 0.1513548449000498, 0.13362576832755435, 0.14870619424370346, 0.12175465429781884, 0.13610837638633133, 0.10806379913823516, 0.13567477396292538, 0.13634594884004914, 0.10437262336038455, 0.1501534467257989, 0.09175279595147623, 0.13431504204396694, 0.10217962512553791, 0.07479616648097231, 0.14234335946848642, 0.09574871249464578, 0.9715157854306803, 0.9777150148128568, 0.9650024427569011, 0.97743136410035, 0.9776450522793793, 0.9755389901383664, 0.9620280141543381, 0.9749482147631842, 0.9708676842966437, 0.7248570437952826, 0.7245999368622097, 0.7159431301021904, 0.2960383646999396, 0.7238507904862093, 0.7353638451629269, 0.7418072636575859, 0.7236286021881666, 0.7210752079739926, 0.8260082805660651, 0.3684367245803063, 0.2265877846719957, 0.27127286907523396, 0.2156498207277442, 0.748038263824488, 0.3753203045986836, 0.8077175844646098, 0.21798590718578648, 0.12110131116225398, 0.21978053308536383, 0.24120360894986048, 0.2619910211260046, 0.22528903460913285, 0.21654558541046554, 0.22231231405218355, 0.12439082676438995, 0.23797658929057597, 0.23789442261611227, 0.22540470737372664, 0.22447764367435297, 0.2824316182765436, 0.259348712130535, 0.247081588615374, 0.26197434719588464, 0.24656725175168426, 0.29432761621260084, 0.0026981267947514542, 0.05081632747825915, 9.999999999998899e-05, 0.04648319092598918, 0.00422665797700339, 9.999999999998899e-05, 0.08360862800964752, 0.0003568427059310597, 0.08237697534844157, 0.11894191880761151, 0.02591471398663725, 0.15121248575941793, 0.047802049512069456, 0.0023428444631268253, 0.025186182385502076, 0.08350270573646124, 0.05507664411122659, 0.11572490654796042, 0.02946698152652194, 0.22041967137598129, 0.2033304599834238, 0.10754233476136854, 0.08271940482310602, 0.06926531962922922, 0.15795400774111035, 0.06354727714908859, 0.07539068624484957, 0.04081449751588917, 0.05565604536908808, 0.2966901789462909, 0.1743302465660892, 0.07503780420997663, 0.15497168921260873, 0.2800814106027122, 0.20592406067700564, 0.07896588555325179, 0.5430952779215492, 0.5384963511061253, 0.5281062025666394, 0.5667886470541659, 0.5611380933507836, 0.5303285569442668, 0.5404958577614134, 0.5778534820593042, 0.5654961856373926, 0.12577386625423803, 0.12566879600555625, 0.10663697722092269, 0.1065041775682748, 0.12398041584692221, 0.09342787720545853, 0.13696148778654837, 0.12389710313395186, 0.12152475786419714, 0.18376180599804492, 0.5101699007019496, 0.23169275893521968, 0.2877383336165973, 0.35302289475876825, 0.2315164934379479, 0.2762474747073598, 0.21323431725103725, 0.2066090551230627, 0.4934793320833283, 0.31669116264172015, 0.34323238670760337, 0.36387338364411304, 0.32471497100192215, 0.36180838665251636, 0.36761837740606074, 0.5843938197584961, 0.3718103184237872, 0.25769776842533365, 0.2620220402057061, 0.328349630780821, 0.27783787655050085, 0.29413693921292716, 0.3178693925192393, 0.2835468856932234, 0.27503622289142526, 0.19279798483142596, 0.2474218376738334, 0.3018299048241444, 0.20863914060362465, 0.23791585611638433, 0.20340104099926914, 0.19715179796740068, 0.2259692635040168, 0.2232387716902513, 0.2579239898170259, 0.2456753298806056, 0.1902811214442841, 0.18943284315543873, 0.7561172435791639, 0.20555384564009593, 0.21817437453583532, 0.21176309184146969, 0.24454063291816197, 0.20590540145935043, 0.17173112789367007, 0.18195190898626712, 0.19949494974920934, 0.18626665443892043, 0.19820117460347642, 0.19788735380195044, 0.14171195967638928, 0.1691325984734383, 0.8278805916572685, 0.8049670823941989, 0.2079848631983151, 0.7242092442775575, 0.8554615841343303, 0.6249773520163429, 0.7848240218268692, 0.10449232459355184, 0.2088978400800705, 0.7958257966008164, 0.2092587607887213, 0.18960480966482451, 0.21053414806662252, 0.18869934478001194, 0.19146274795339768, 0.1955500159927892, 0.19168384946902228, 0.18309229106107405, 0.1900456638082546, 0.08295195910305286, 0.09910789531412845, 0.12855562819188104, 0.0927854248785761, 0.08167573283111229, 0.10671309347222613, 0.10110077159988795, 0.09846178225754065, 0.09276805935100785]}, "mutation_prompt": null}
{"id": "55273270-798e-467d-b1f2-0b2e32c1df41", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                dynamic_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < dynamic_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Integrate adaptive crossover strategy and adjust learning rates over time.", "configspace": "", "generation": 44, "fitness": 0.3269693780439684, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "c0fb1650-22da-4423-a3d1-43a71f874462", "metadata": {"aucs": [0.8188728356366037, 0.8360943283216513, 0.816160358767902, 0.8290674379536025, 0.8300997731991934, 0.8294790662626017, 0.8195972443502358, 0.8448566904551208, 0.8401875513792034, 0.6752683332012587, 0.6964984061030601, 0.6546477338220225, 0.6660629224698292, 0.5978878333455049, 0.7137485211549739, 0.6426687507895472, 0.6717559112483174, 0.7042834291808667, 0.11488873974803226, 0.12274434497198672, 0.14753755285960612, 0.17660906180531688, 0.11762316641866943, 0.6504353944462431, 0.1369648228120488, 0.1358831568609603, 0.1326732484665798, 0.11329990910942866, 0.13392795634706012, 0.10316829295666319, 0.15052873128775368, 0.0941849184431045, 0.11018626238887796, 0.12605396777005717, 0.11162084856441579, 0.11013304953224756, 0.974153984618168, 0.9706685489864835, 0.9707951123000333, 0.9640530246601036, 0.9706440299845491, 0.9690584968525532, 0.9755187178690252, 0.9714283061060324, 0.9701146064778828, 0.7630191047006334, 0.7388776403550525, 0.7143360662996194, 0.7610349242461952, 0.7375090417176916, 0.7397353229922334, 0.7293919082014142, 0.7159254690277346, 0.7467086523799082, 0.37488791083331496, 0.3612992118046383, 0.20412021129502045, 0.27578290270949724, 0.21164976388130852, 0.8072871163847534, 0.21855975670313077, 0.3797997287689141, 0.1760087157902821, 0.26808334540146106, 0.22598954092893786, 0.24004080851326093, 0.2140824219119365, 0.4225324484306532, 0.12991426905135317, 0.22617694847869074, 0.18764628814700535, 0.23712877372015817, 0.23400024037315081, 0.18550211104447445, 0.1212689480675635, 0.26550732423575096, 0.24731282396407428, 0.2658509517590719, 0.4082153330174375, 0.21467947256334508, 0.2538853336369399, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.049466907699751594, 9.999999999998899e-05, 9.999999999998899e-05, 0.00636267557603265, 9.999999999998899e-05, 0.0025934259995070708, 0.08526462851164884, 0.027001497757762394, 0.13143661312197108, 0.08547089440834021, 0.032152145129762943, 0.06249971477039762, 0.05322848991547513, 0.04184042597446136, 0.052542156502182524, 0.041860975599109396, 0.24030896876073815, 0.17968644830451208, 0.12982759031978097, 0.12480683255559011, 0.079569076091621, 0.23317676285516165, 0.1069406308752403, 0.14778436008187068, 0.23515564806153322, 0.013883170304745729, 0.07173722526731252, 0.010971532294490993, 0.14401946965592893, 0.030093464582930607, 0.05446112099291589, 0.42820204202772816, 0.08134012509927457, 0.5527519523779392, 0.5393746707369893, 0.5591765092902883, 0.5428138626006308, 0.5371395637148675, 0.5240361529598538, 0.5580666917831955, 0.5650603038470767, 0.5275931635980836, 0.11368882793199608, 0.08454600735388684, 0.09784890441116845, 0.12238272512756487, 0.10613406873362696, 0.1369485798757092, 0.15343829421380473, 0.0898583588618671, 0.16769932951919198, 0.27050952968360453, 0.21584942692880515, 0.23490419518811312, 0.18129045309916259, 0.41522829959059815, 0.26194774992770486, 0.2366151398198698, 0.3140836108446089, 0.20967695238337136, 0.32334515365295313, 0.43266309785724466, 0.4082569986373442, 0.43435407486056665, 0.24868813743903861, 0.2165256926694713, 0.25460362103979794, 0.32447861789986154, 0.40769663796080136, 0.21721253845874666, 0.3903512079441631, 0.20805007284428523, 0.1908076056043736, 0.29783323228854863, 0.36481858447010684, 0.3281881172820915, 0.32100544257045216, 0.24272709719912178, 0.21422941590872902, 0.19997458169314464, 0.25635543948524786, 0.21657358852507713, 0.24451257877072885, 0.23001212100014834, 0.2403018263099177, 0.2263599337528136, 0.2244142542972848, 0.19675268972838122, 0.2415208240742388, 0.22344452095679623, 0.22247214548255767, 0.2230417512562366, 0.194400510387282, 0.24641311649930642, 0.7545886394606645, 0.2393797221384204, 0.8685141556373367, 0.19940278759228836, 0.815617770854227, 0.871629561140645, 0.19867957184413, 0.14735214288074328, 0.14193781237649528, 0.16884727227891383, 0.15220329138246558, 0.8611303276555835, 0.2118529407545099, 0.2081859505228012, 0.7083978561137751, 0.16673883612551477, 0.6836559456484956, 0.10472619223587121, 0.10445648510906236, 0.8607021863478275, 0.1947752564129741, 0.18059885564942646, 0.2016988166396827, 0.1918323041554273, 0.19181318469286224, 0.20062709475112883, 0.21403665204357225, 0.1796292716329384, 0.18201762837249735, 0.09842170195733779, 0.07449624834645419, 0.11677134173812354, 0.09389282529709331, 0.09562504179929143, 0.10717370232693679, 0.1096775497716942, 0.10094937819591887, 0.09212957168384694]}, "mutation_prompt": null}
{"id": "d8373ec6-7715-4308-8426-cc85c1540037", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance exploration by dynamically adjusting the mutation factor and incorporating a random search mechanism.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c0fb1650-22da-4423-a3d1-43a71f874462", "metadata": {"aucs": [0.8435671376499423, 0.813821965027232, 0.8193146984381393, 0.8238782588528325, 0.8181580590960307, 0.8330929086778752, 0.8136430829651737, 0.8384596763249165, 0.830620455315433, 0.641523478823466, 0.6334803739832614, 0.6787732472158599, 0.6766782098441542, 0.6647111389199246, 0.6874039247988899, 0.666113388487388, 0.7247818405100646, 0.6808620463564657, 0.15381816764210876, 0.10730306727407768, 0.1513548449000498, 0.13362576832755435, 0.14870619424370346, 0.12175465429781884, 0.13610837638633133, 0.10806379913823516, 0.13567477396292538, 0.13634594884004914, 0.10437262336038455, 0.1501534467257989, 0.09175279595147623, 0.13431504204396694, 0.10217962512553791, 0.07479616648097231, 0.14234335946848642, 0.09574871249464578, 0.9715157854306803, 0.9777150148128568, 0.9650024427569011, 0.97743136410035, 0.9776450522793793, 0.9755389901383664, 0.9620280141543381, 0.9749482147631842, 0.9708676842966437, 0.7248570437952826, 0.7245999368622097, 0.7159431301021904, 0.2960383646999396, 0.7238507904862093, 0.7353638451629269, 0.7418072636575859, 0.7236286021881666, 0.7210752079739926, 0.8260082805660651, 0.3684367245803063, 0.2265877846719957, 0.27127286907523396, 0.2156498207277442, 0.748038263824488, 0.3753203045986836, 0.8077175844646098, 0.21798590718578648, 0.12110131116225398, 0.21978053308536383, 0.24120360894986048, 0.2619910211260046, 0.22528903460913285, 0.21654558541046554, 0.22231231405218355, 0.12439082676438995, 0.23797658929057597, 0.23789442261611227, 0.22540470737372664, 0.22447764367435297, 0.2824316182765436, 0.259348712130535, 0.247081588615374, 0.26197434719588464, 0.24656725175168426, 0.29432761621260084, 0.0026981267947514542, 0.05081632747825915, 9.999999999998899e-05, 0.04648319092598918, 0.00422665797700339, 9.999999999998899e-05, 0.08360862800964752, 0.0003568427059310597, 0.08237697534844157, 0.11894191880761151, 0.02591471398663725, 0.15121248575941793, 0.047802049512069456, 0.0023428444631268253, 0.025186182385502076, 0.08350270573646124, 0.05507664411122659, 0.11572490654796042, 0.02946698152652194, 0.22041967137598129, 0.2033304599834238, 0.10754233476136854, 0.08271940482310602, 0.06926531962922922, 0.15795400774111035, 0.06354727714908859, 0.07539068624484957, 0.04081449751588917, 0.05565604536908808, 0.2966901789462909, 0.1743302465660892, 0.07503780420997663, 0.15497168921260873, 0.2800814106027122, 0.20592406067700564, 0.07896588555325179, 0.5430952779215492, 0.5384963511061253, 0.5281062025666394, 0.5667886470541659, 0.5611380933507836, 0.5303285569442668, 0.5404958577614134, 0.5778534820593042, 0.5654961856373926, 0.12577386625423803, 0.12566879600555625, 0.10663697722092269, 0.1065041775682748, 0.12398041584692221, 0.09342787720545853, 0.13696148778654837, 0.12389710313395186, 0.12152475786419714, 0.18376180599804492, 0.5101699007019496, 0.23169275893521968, 0.2877383336165973, 0.35302289475876825, 0.2315164934379479, 0.2762474747073598, 0.21323431725103725, 0.2066090551230627, 0.4934793320833283, 0.31669116264172015, 0.34323238670760337, 0.36387338364411304, 0.32471497100192215, 0.36180838665251636, 0.36761837740606074, 0.5843938197584961, 0.3718103184237872, 0.25769776842533365, 0.2620220402057061, 0.328349630780821, 0.27783787655050085, 0.29413693921292716, 0.3178693925192393, 0.2835468856932234, 0.27503622289142526, 0.19279798483142596, 0.2474218376738334, 0.3018299048241444, 0.20863914060362465, 0.23791585611638433, 0.20340104099926914, 0.19715179796740068, 0.2259692635040168, 0.2232387716902513, 0.2579239898170259, 0.2456753298806056, 0.1902811214442841, 0.18943284315543873, 0.7561172435791639, 0.20555384564009593, 0.21817437453583532, 0.21176309184146969, 0.24454063291816197, 0.20590540145935043, 0.17173112789367007, 0.18195190898626712, 0.19949494974920934, 0.18626665443892043, 0.19820117460347642, 0.19788735380195044, 0.14171195967638928, 0.1691325984734383, 0.8278805916572685, 0.8049670823941989, 0.2079848631983151, 0.7242092442775575, 0.8554615841343303, 0.6249773520163429, 0.7848240218268692, 0.10449232459355184, 0.2088978400800705, 0.7958257966008164, 0.2092587607887213, 0.18960480966482451, 0.21053414806662252, 0.18869934478001194, 0.19146274795339768, 0.1955500159927892, 0.19168384946902228, 0.18309229106107405, 0.1900456638082546, 0.08295195910305286, 0.09910789531412845, 0.12855562819188104, 0.0927854248785761, 0.08167573283111229, 0.10671309347222613, 0.10110077159988795, 0.09846178225754065, 0.09276805935100785]}, "mutation_prompt": null}
{"id": "aaacd8ef-004b-4152-864c-65576333f7b1", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                # Updated line: Dynamic crossover rate adjustment\n                dynamic_crossover_rate = self.crossover_rate * (1 - evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < dynamic_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Incorporate dynamic crossover rate adjustment in the DE phase for improved exploration and exploitation balance.", "configspace": "", "generation": 46, "fitness": 0.3251214145970208, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.27.", "error": "", "parent_id": "c0fb1650-22da-4423-a3d1-43a71f874462", "metadata": {"aucs": [0.8465244936149876, 0.8251614033144392, 0.8192128408128357, 0.8359083723926406, 0.8270651536521, 0.8426615044356205, 0.8281145871813471, 0.8320360411114563, 0.8195434148816373, 0.6287533794180693, 0.677143609129109, 0.6554073728329206, 0.6816857542043206, 0.6809644031793154, 0.6861385364364665, 0.6670431355436, 0.6895360261950816, 0.7057196996820146, 0.1113615157034541, 0.1401917380678438, 0.15120674058100558, 0.16996299901826073, 0.14996479296331422, 0.12150121175819606, 0.12998897966107703, 0.13397820375793035, 0.14847508542751964, 0.11349127322701369, 0.14680266126129882, 0.14872632559420473, 0.11470951253261796, 0.13407891780469794, 0.14366473533306723, 0.11301290954509169, 0.12196636036716813, 0.1291797233070774, 0.9715157854306803, 0.9779288551198984, 0.9650024427569011, 0.97743136410035, 0.9776450522793793, 0.9755389901383664, 0.9620140017966387, 0.9749482147631842, 0.9706044878989804, 0.7530986509962446, 0.7404022580116547, 0.7284758959143052, 0.5360166138274483, 0.7382544760349274, 0.7241189851386802, 0.7471162240455487, 0.7144671791993191, 0.7473189956936768, 0.3759584576126753, 0.16571407814453598, 0.22447015721734576, 0.7857115661607003, 0.8539822693453345, 0.3663324550839706, 0.3415998768133536, 0.22837393889741342, 0.22572284837108514, 0.12210029881253015, 0.1660306210674074, 0.2057962261213493, 0.20747578766546326, 0.21647996357596888, 0.22036628630817323, 0.21336507788717773, 0.24020578896721012, 0.20529874105292734, 0.22436839730367086, 0.26811401923422506, 0.20950060945638738, 0.2681310868565113, 0.21848673845790456, 0.13056348895450787, 0.24973500053242847, 0.25283217210846154, 0.23235241026147047, 0.043325959743344855, 0.016525120003915483, 9.999999999998899e-05, 0.03470996232935064, 9.999999999998899e-05, 9.999999999998899e-05, 0.03446151727688118, 0.009394431631245204, 0.042835527934629636, 0.1153368766059546, 0.020639143174883468, 0.12785679372218273, 0.042322502797020545, 0.024179279515668006, 0.03294718404926267, 0.0418872064182908, 0.06159277039294231, 0.04316511602139994, 0.051827292706190575, 0.16935282738739932, 0.14120114152008623, 0.11527399011606954, 0.08654132622789168, 0.06799012536728755, 0.17493450538803013, 0.07488044401907046, 0.12036851079604571, 0.079981633045492, 0.0537225203219297, 0.26790785640085013, 0.3550708739092002, 0.041273173384803186, 0.18550877442490632, 0.05408984987568233, 0.30988805837124644, 0.08416884612316844, 0.49567573530945364, 0.5167969433145112, 0.5411553172343748, 0.5678820902398667, 0.5118414889323553, 0.5075274165336418, 0.5596314200568167, 0.5574302386769795, 0.5312255642360306, 0.11388754827074044, 0.10673452885781753, 0.10714930480939433, 0.10563421142178342, 0.10572011223984268, 0.15087517660781702, 0.11759162013940128, 0.11158012658639926, 0.09790166143146306, 0.21779248384476746, 0.2553679971911479, 0.22781331615934486, 0.2853173202659973, 0.27130781205025556, 0.36172185036876425, 0.27134594569099957, 0.1503247657321144, 0.3012887032496063, 0.375966530070476, 0.33901179645893664, 0.303929550409451, 0.30131068850337084, 0.40000661519686453, 0.5606899186316445, 0.34378876850052176, 0.3106364956548908, 0.42824666735968386, 0.2015707532566724, 0.2921802485803189, 0.2717083691457446, 0.1940806652743018, 0.3036099290749926, 0.2989742789179496, 0.29135323383313205, 0.27718564992387906, 0.2614118112810787, 0.2361753370839893, 0.25566293781831395, 0.21236479712004686, 0.23417328225944234, 0.22323698509399303, 0.22916655667437924, 0.2172732359013354, 0.20654186567022048, 0.24262701954511146, 0.20814618025632747, 0.21133642722173673, 0.2158379439689302, 0.7442224591060898, 0.1889327369436029, 0.24459861565931174, 0.21409049531635072, 0.7578646050323951, 0.20568437916326587, 0.8827787512200298, 0.18201154263168118, 0.19876457894146227, 0.18603834392910712, 0.19834950581440358, 0.19840328934428475, 0.14166347311082494, 0.16913883307285593, 0.15190163553580116, 0.8636597262527058, 0.20807470094601555, 0.49454490813818086, 0.7921167053280103, 0.4400619209039891, 0.7610785073933871, 0.10447049445648648, 0.20620976793490797, 0.7643134754340852, 0.1849600953841004, 0.20034368462635121, 0.1922675401489342, 0.1884841158323457, 0.18794020836596725, 0.21053937699693892, 0.23496583762995982, 0.19326766437968557, 0.20122116739564877, 0.10054676070364399, 0.10089694333591781, 0.10761001716045615, 0.08880564262289448, 0.09507560141288574, 0.08915850889656518, 0.0868101070308056, 0.0812070963996685, 0.08911510453756655]}, "mutation_prompt": null}
{"id": "6edc3a91-da58-409b-9bae-91dbac663e28", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance exploration by dynamically adjusting the mutation factor and incorporating a random search mechanism.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c0fb1650-22da-4423-a3d1-43a71f874462", "metadata": {"aucs": [0.8435671376499423, 0.813821965027232, 0.8193146984381393, 0.8238782588528325, 0.8181580590960307, 0.8330929086778752, 0.8136430829651737, 0.8384596763249165, 0.830620455315433, 0.641523478823466, 0.6334803739832614, 0.6787732472158599, 0.6766782098441542, 0.6647111389199246, 0.6874039247988899, 0.666113388487388, 0.7247818405100646, 0.6808620463564657, 0.15381816764210876, 0.10730306727407768, 0.1513548449000498, 0.13362576832755435, 0.14870619424370346, 0.12175465429781884, 0.13610837638633133, 0.10806379913823516, 0.13567477396292538, 0.13634594884004914, 0.10437262336038455, 0.1501534467257989, 0.09175279595147623, 0.13431504204396694, 0.10217962512553791, 0.07479616648097231, 0.14234335946848642, 0.09574871249464578, 0.9715157854306803, 0.9777150148128568, 0.9650024427569011, 0.97743136410035, 0.9776450522793793, 0.9755389901383664, 0.9620280141543381, 0.9749482147631842, 0.9708676842966437, 0.7248570437952826, 0.7245999368622097, 0.7159431301021904, 0.2960383646999396, 0.7238507904862093, 0.7353638451629269, 0.7418072636575859, 0.7236286021881666, 0.7210752079739926, 0.8260082805660651, 0.3684367245803063, 0.2265877846719957, 0.27127286907523396, 0.2156498207277442, 0.748038263824488, 0.3753203045986836, 0.8077175844646098, 0.21798590718578648, 0.12110131116225398, 0.21978053308536383, 0.24120360894986048, 0.2619910211260046, 0.22528903460913285, 0.21654558541046554, 0.22231231405218355, 0.12439082676438995, 0.23797658929057597, 0.23789442261611227, 0.22540470737372664, 0.22447764367435297, 0.2824316182765436, 0.259348712130535, 0.247081588615374, 0.26197434719588464, 0.24656725175168426, 0.29432761621260084, 0.0026981267947514542, 0.05081632747825915, 9.999999999998899e-05, 0.04648319092598918, 0.00422665797700339, 9.999999999998899e-05, 0.08360862800964752, 0.0003568427059310597, 0.08237697534844157, 0.11894191880761151, 0.02591471398663725, 0.15121248575941793, 0.047802049512069456, 0.0023428444631268253, 0.025186182385502076, 0.08350270573646124, 0.05507664411122659, 0.11572490654796042, 0.02946698152652194, 0.22041967137598129, 0.2033304599834238, 0.10754233476136854, 0.08271940482310602, 0.06926531962922922, 0.15795400774111035, 0.06354727714908859, 0.07539068624484957, 0.04081449751588917, 0.05565604536908808, 0.2966901789462909, 0.1743302465660892, 0.07503780420997663, 0.15497168921260873, 0.2800814106027122, 0.20592406067700564, 0.07896588555325179, 0.5430952779215492, 0.5384963511061253, 0.5281062025666394, 0.5667886470541659, 0.5611380933507836, 0.5303285569442668, 0.5404958577614134, 0.5778534820593042, 0.5654961856373926, 0.12577386625423803, 0.12566879600555625, 0.10663697722092269, 0.1065041775682748, 0.12398041584692221, 0.09342787720545853, 0.13696148778654837, 0.12389710313395186, 0.12152475786419714, 0.18376180599804492, 0.5101699007019496, 0.23169275893521968, 0.2877383336165973, 0.35302289475876825, 0.2315164934379479, 0.2762474747073598, 0.21323431725103725, 0.2066090551230627, 0.4934793320833283, 0.31669116264172015, 0.34323238670760337, 0.36387338364411304, 0.32471497100192215, 0.36180838665251636, 0.36761837740606074, 0.5843938197584961, 0.3718103184237872, 0.25769776842533365, 0.2620220402057061, 0.328349630780821, 0.27783787655050085, 0.29413693921292716, 0.3178693925192393, 0.2835468856932234, 0.27503622289142526, 0.19279798483142596, 0.2474218376738334, 0.3018299048241444, 0.20863914060362465, 0.23791585611638433, 0.20340104099926914, 0.19715179796740068, 0.2259692635040168, 0.2232387716902513, 0.2579239898170259, 0.2456753298806056, 0.1902811214442841, 0.18943284315543873, 0.7561172435791639, 0.20555384564009593, 0.21817437453583532, 0.21176309184146969, 0.24454063291816197, 0.20590540145935043, 0.17173112789367007, 0.18195190898626712, 0.19949494974920934, 0.18626665443892043, 0.19820117460347642, 0.19788735380195044, 0.14171195967638928, 0.1691325984734383, 0.8278805916572685, 0.8049670823941989, 0.2079848631983151, 0.7242092442775575, 0.8554615841343303, 0.6249773520163429, 0.7848240218268692, 0.10449232459355184, 0.2088978400800705, 0.7958257966008164, 0.2092587607887213, 0.18960480966482451, 0.21053414806662252, 0.18869934478001194, 0.19146274795339768, 0.1955500159927892, 0.19168384946902228, 0.18309229106107405, 0.1900456638082546, 0.08295195910305286, 0.09910789531412845, 0.12855562819188104, 0.0927854248785761, 0.08167573283111229, 0.10671309347222613, 0.10110077159988795, 0.09846178225754065, 0.09276805935100785]}, "mutation_prompt": null}
{"id": "c41962d0-bbe9-4f0f-856c-891686b23b94", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance exploration by dynamically adjusting the mutation factor and incorporating a random search mechanism.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c0fb1650-22da-4423-a3d1-43a71f874462", "metadata": {"aucs": [0.8435671376499423, 0.813821965027232, 0.8193146984381393, 0.8238782588528325, 0.8181580590960307, 0.8330929086778752, 0.8136430829651737, 0.8384596763249165, 0.830620455315433, 0.641523478823466, 0.6334803739832614, 0.6787732472158599, 0.6766782098441542, 0.6647111389199246, 0.6874039247988899, 0.666113388487388, 0.7247818405100646, 0.6808620463564657, 0.15381816764210876, 0.10730306727407768, 0.1513548449000498, 0.13362576832755435, 0.14870619424370346, 0.12175465429781884, 0.13610837638633133, 0.10806379913823516, 0.13567477396292538, 0.13634594884004914, 0.10437262336038455, 0.1501534467257989, 0.09175279595147623, 0.13431504204396694, 0.10217962512553791, 0.07479616648097231, 0.14234335946848642, 0.09574871249464578, 0.9715157854306803, 0.9777150148128568, 0.9650024427569011, 0.97743136410035, 0.9776450522793793, 0.9755389901383664, 0.9620280141543381, 0.9749482147631842, 0.9708676842966437, 0.7248570437952826, 0.7245999368622097, 0.7159431301021904, 0.2960383646999396, 0.7238507904862093, 0.7353638451629269, 0.7418072636575859, 0.7236286021881666, 0.7210752079739926, 0.8260082805660651, 0.3684367245803063, 0.2265877846719957, 0.27127286907523396, 0.2156498207277442, 0.748038263824488, 0.3753203045986836, 0.8077175844646098, 0.21798590718578648, 0.12110131116225398, 0.21978053308536383, 0.24120360894986048, 0.2619910211260046, 0.22528903460913285, 0.21654558541046554, 0.22231231405218355, 0.12439082676438995, 0.23797658929057597, 0.23789442261611227, 0.22540470737372664, 0.22447764367435297, 0.2824316182765436, 0.259348712130535, 0.247081588615374, 0.26197434719588464, 0.24656725175168426, 0.29432761621260084, 0.0026981267947514542, 0.05081632747825915, 9.999999999998899e-05, 0.04648319092598918, 0.00422665797700339, 9.999999999998899e-05, 0.08360862800964752, 0.0003568427059310597, 0.08237697534844157, 0.11894191880761151, 0.02591471398663725, 0.15121248575941793, 0.047802049512069456, 0.0023428444631268253, 0.025186182385502076, 0.08350270573646124, 0.05507664411122659, 0.11572490654796042, 0.02946698152652194, 0.22041967137598129, 0.2033304599834238, 0.10754233476136854, 0.08271940482310602, 0.06926531962922922, 0.15795400774111035, 0.06354727714908859, 0.07539068624484957, 0.04081449751588917, 0.05565604536908808, 0.2966901789462909, 0.1743302465660892, 0.07503780420997663, 0.15497168921260873, 0.2800814106027122, 0.20592406067700564, 0.07896588555325179, 0.5430952779215492, 0.5384963511061253, 0.5281062025666394, 0.5667886470541659, 0.5611380933507836, 0.5303285569442668, 0.5404958577614134, 0.5778534820593042, 0.5654961856373926, 0.12577386625423803, 0.12566879600555625, 0.10663697722092269, 0.1065041775682748, 0.12398041584692221, 0.09342787720545853, 0.13696148778654837, 0.12389710313395186, 0.12152475786419714, 0.18376180599804492, 0.5101699007019496, 0.23169275893521968, 0.2877383336165973, 0.35302289475876825, 0.2315164934379479, 0.2762474747073598, 0.21323431725103725, 0.2066090551230627, 0.4934793320833283, 0.31669116264172015, 0.34323238670760337, 0.36387338364411304, 0.32471497100192215, 0.36180838665251636, 0.36761837740606074, 0.5843938197584961, 0.3718103184237872, 0.25769776842533365, 0.2620220402057061, 0.328349630780821, 0.27783787655050085, 0.29413693921292716, 0.3178693925192393, 0.2835468856932234, 0.27503622289142526, 0.19279798483142596, 0.2474218376738334, 0.3018299048241444, 0.20863914060362465, 0.23791585611638433, 0.20340104099926914, 0.19715179796740068, 0.2259692635040168, 0.2232387716902513, 0.2579239898170259, 0.2456753298806056, 0.1902811214442841, 0.18943284315543873, 0.7561172435791639, 0.20555384564009593, 0.21817437453583532, 0.21176309184146969, 0.24454063291816197, 0.20590540145935043, 0.17173112789367007, 0.18195190898626712, 0.19949494974920934, 0.18626665443892043, 0.19820117460347642, 0.19788735380195044, 0.14171195967638928, 0.1691325984734383, 0.8278805916572685, 0.8049670823941989, 0.2079848631983151, 0.7242092442775575, 0.8554615841343303, 0.6249773520163429, 0.7848240218268692, 0.10449232459355184, 0.2088978400800705, 0.7958257966008164, 0.2092587607887213, 0.18960480966482451, 0.21053414806662252, 0.18869934478001194, 0.19146274795339768, 0.1955500159927892, 0.19168384946902228, 0.18309229106107405, 0.1900456638082546, 0.08295195910305286, 0.09910789531412845, 0.12855562819188104, 0.0927854248785761, 0.08167573283111229, 0.10671309347222613, 0.10110077159988795, 0.09846178225754065, 0.09276805935100785]}, "mutation_prompt": null}
{"id": "9115be41-845d-45c3-8e35-abe96994b77d", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / self.budget)))  # Adjusts based on remaining budget\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance exploration by dynamically adjusting the mutation factor and incorporating a random search mechanism.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c0fb1650-22da-4423-a3d1-43a71f874462", "metadata": {"aucs": [0.8435671376499423, 0.813821965027232, 0.8193146984381393, 0.8238782588528325, 0.8181580590960307, 0.8330929086778752, 0.8136430829651737, 0.8384596763249165, 0.830620455315433, 0.641523478823466, 0.6334803739832614, 0.6787732472158599, 0.6766782098441542, 0.6647111389199246, 0.6874039247988899, 0.666113388487388, 0.7247818405100646, 0.6808620463564657, 0.15381816764210876, 0.10730306727407768, 0.1513548449000498, 0.13362576832755435, 0.14870619424370346, 0.12175465429781884, 0.13610837638633133, 0.10806379913823516, 0.13567477396292538, 0.13634594884004914, 0.10437262336038455, 0.1501534467257989, 0.09175279595147623, 0.13431504204396694, 0.10217962512553791, 0.07479616648097231, 0.14234335946848642, 0.09574871249464578, 0.9715157854306803, 0.9777150148128568, 0.9650024427569011, 0.97743136410035, 0.9776450522793793, 0.9755389901383664, 0.9620280141543381, 0.9749482147631842, 0.9708676842966437, 0.7248570437952826, 0.7245999368622097, 0.7159431301021904, 0.2960383646999396, 0.7238507904862093, 0.7353638451629269, 0.7418072636575859, 0.7236286021881666, 0.7210752079739926, 0.8260082805660651, 0.3684367245803063, 0.2265877846719957, 0.27127286907523396, 0.2156498207277442, 0.748038263824488, 0.3753203045986836, 0.8077175844646098, 0.21798590718578648, 0.12110131116225398, 0.21978053308536383, 0.24120360894986048, 0.2619910211260046, 0.22528903460913285, 0.21654558541046554, 0.22231231405218355, 0.12439082676438995, 0.23797658929057597, 0.23789442261611227, 0.22540470737372664, 0.22447764367435297, 0.2824316182765436, 0.259348712130535, 0.247081588615374, 0.26197434719588464, 0.24656725175168426, 0.29432761621260084, 0.0026981267947514542, 0.05081632747825915, 9.999999999998899e-05, 0.04648319092598918, 0.00422665797700339, 9.999999999998899e-05, 0.08360862800964752, 0.0003568427059310597, 0.08237697534844157, 0.11894191880761151, 0.02591471398663725, 0.15121248575941793, 0.047802049512069456, 0.0023428444631268253, 0.025186182385502076, 0.08350270573646124, 0.05507664411122659, 0.11572490654796042, 0.02946698152652194, 0.22041967137598129, 0.2033304599834238, 0.10754233476136854, 0.08271940482310602, 0.06926531962922922, 0.15795400774111035, 0.06354727714908859, 0.07539068624484957, 0.04081449751588917, 0.05565604536908808, 0.2966901789462909, 0.1743302465660892, 0.07503780420997663, 0.15497168921260873, 0.2800814106027122, 0.20592406067700564, 0.07896588555325179, 0.5430952779215492, 0.5384963511061253, 0.5281062025666394, 0.5667886470541659, 0.5611380933507836, 0.5303285569442668, 0.5404958577614134, 0.5778534820593042, 0.5654961856373926, 0.12577386625423803, 0.12566879600555625, 0.10663697722092269, 0.1065041775682748, 0.12398041584692221, 0.09342787720545853, 0.13696148778654837, 0.12389710313395186, 0.12152475786419714, 0.18376180599804492, 0.5101699007019496, 0.23169275893521968, 0.2877383336165973, 0.35302289475876825, 0.2315164934379479, 0.2762474747073598, 0.21323431725103725, 0.2066090551230627, 0.4934793320833283, 0.31669116264172015, 0.34323238670760337, 0.36387338364411304, 0.32471497100192215, 0.36180838665251636, 0.36761837740606074, 0.5843938197584961, 0.3718103184237872, 0.25769776842533365, 0.2620220402057061, 0.328349630780821, 0.27783787655050085, 0.29413693921292716, 0.3178693925192393, 0.2835468856932234, 0.27503622289142526, 0.19279798483142596, 0.2474218376738334, 0.3018299048241444, 0.20863914060362465, 0.23791585611638433, 0.20340104099926914, 0.19715179796740068, 0.2259692635040168, 0.2232387716902513, 0.2579239898170259, 0.2456753298806056, 0.1902811214442841, 0.18943284315543873, 0.7561172435791639, 0.20555384564009593, 0.21817437453583532, 0.21176309184146969, 0.24454063291816197, 0.20590540145935043, 0.17173112789367007, 0.18195190898626712, 0.19949494974920934, 0.18626665443892043, 0.19820117460347642, 0.19788735380195044, 0.14171195967638928, 0.1691325984734383, 0.8278805916572685, 0.8049670823941989, 0.2079848631983151, 0.7242092442775575, 0.8554615841343303, 0.6249773520163429, 0.7848240218268692, 0.10449232459355184, 0.2088978400800705, 0.7958257966008164, 0.2092587607887213, 0.18960480966482451, 0.21053414806662252, 0.18869934478001194, 0.19146274795339768, 0.1955500159927892, 0.19168384946902228, 0.18309229106107405, 0.1900456638082546, 0.08295195910305286, 0.09910789531412845, 0.12855562819188104, 0.0927854248785761, 0.08167573283111229, 0.10671309347222613, 0.10110077159988795, 0.09846178225754065, 0.09276805935100785]}, "mutation_prompt": null}
{"id": "2dadcdad-01c1-403a-bff9-fed3c1495637", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / (2 * self.budget))))  # Adjusts based on convergence\n\n        return global_best", "name": "HybridDEPSO", "description": "Introduce adaptive crossover rate and enhance exploration by adaptively updating the population size based on convergence.", "configspace": "", "generation": 50, "fitness": 0.3321237684713529, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "c0fb1650-22da-4423-a3d1-43a71f874462", "metadata": {"aucs": [0.8359344413819497, 0.8340020473636771, 0.8177542711523587, 0.8282637876571906, 0.8272468883972396, 0.8296198977328977, 0.8453163689613803, 0.8298710928367996, 0.8086930057290679, 0.6300650824211467, 0.5243839758318625, 0.6480287619233989, 0.6293383597844323, 0.5661979305507592, 0.6327004966143543, 0.6609175176278232, 0.6673560545920878, 0.661990063393395, 0.15047509578713958, 0.12997097041522743, 0.12620484931474307, 0.13756588336602615, 0.14403952733366965, 0.13829661227842793, 0.12631748607174997, 0.14042619794064792, 0.679913523619764, 0.1348929289905143, 0.10025521190385789, 0.08915599729795376, 0.12174548146873587, 0.11203967860189701, 0.14694400466350943, 0.13602685798117276, 0.13293448702184618, 0.12842920639109634, 0.9716577286457261, 0.9704854374227017, 0.9700121311361274, 0.9638062100940954, 0.970532483939913, 0.9629986958369492, 0.9755187178690252, 0.9731786009342139, 0.9677615403300047, 0.7455288209443123, 0.7078318408839777, 0.741965831501826, 0.7247124619072475, 0.7001765537054596, 0.7173970378873546, 0.7250746051997472, 0.7147823537715927, 0.7147702163688576, 0.7753744346780321, 0.8275717282747095, 0.22423005123800555, 0.7713891017561286, 0.3498806077231317, 0.27154681615585263, 0.8244896619222833, 0.8656253127153338, 0.22184002709514916, 0.1888047299915805, 0.2068870084009269, 0.2181633004292346, 0.2171470204039957, 0.2298967387244627, 0.23327798867867033, 0.2251430100614974, 0.27247767217355034, 0.22943578865809489, 0.23894088856678464, 0.12813436811567003, 0.14322705647211265, 0.24789311992593532, 0.22223316206366184, 0.25644521533794795, 0.2634509502082456, 0.25485136381451967, 0.2580310884366892, 9.999999999998899e-05, 0.04905010372085161, 9.999999999998899e-05, 0.031124022545261143, 0.00010009251651721396, 0.0676408433591692, 0.004121327247791462, 9.999999999998899e-05, 0.004048934944478111, 0.07228794955288886, 0.025207162494297886, 0.11613800131198515, 0.08790078192921469, 0.02005366371679207, 0.03177561475707502, 0.05994418904005583, 0.08292395334092795, 0.039132227159612065, 0.14370720647068724, 0.2762296473981354, 0.08342813776121327, 0.30440753749415506, 0.08950069127576898, 0.07175084741362314, 0.15204631577118577, 0.09046531786762813, 0.07377413301538072, 0.07945697552627684, 0.012230241887086546, 0.05535991908341986, 0.052080239077988866, 0.10503265122564753, 0.051718218946512184, 0.05499692758606256, 0.09889989631300689, 0.08879616287047976, 0.5438819781871052, 0.5110996258505001, 0.5191495041697142, 0.6043964776592872, 0.5218077945518597, 0.5449463362848045, 0.5166776003563157, 0.5235545718584635, 0.5348459588109533, 0.12334462956345593, 0.11905734543592084, 0.11164586859489589, 0.14761233292301346, 0.15118319459240448, 0.12378084021430635, 0.11344946489117069, 0.10625827763004525, 0.15321125099271415, 0.4320761069241412, 0.18977157479329887, 0.19707589925971225, 0.18125497301550453, 0.546819752034278, 0.262845079277798, 0.21804021672435703, 0.25130729566914445, 0.27493692654919877, 0.434963732849142, 0.2447878314194475, 0.42366605495937093, 0.3624154900561821, 0.24515391233437878, 0.509189318315969, 0.4747784440328786, 0.599064204963796, 0.5016382629189381, 0.24924558264502628, 0.2227513753457947, 0.31844330218681693, 0.21661929612037334, 0.28215364427950806, 0.17937971738986958, 0.2724742302758967, 0.2821936074996094, 0.3865286833568986, 0.21798135083516523, 0.19487120011017522, 0.19048968797540078, 0.25131863869967397, 0.20654629535368207, 0.24670920302045063, 0.2528520195912729, 0.21373913271831624, 0.22366123873333443, 0.20027263161569753, 0.19435184486011836, 0.24575644051565237, 0.2428266430029996, 0.18869622458558788, 0.24029558511274218, 0.1990906972077413, 0.2069624178148992, 0.2069411061096833, 0.8585304391204805, 0.19903081440561488, 0.175557884161461, 0.8517614084943631, 0.19988195875585013, 0.1474023338286239, 0.8554186405141962, 0.16877962175740036, 0.15182863927668455, 0.8590430079642989, 0.2086836818451, 0.20932073847283683, 0.7646326738132165, 0.1667318044168622, 0.6323639279050162, 0.10473593983250706, 0.10433761070548897, 0.8115552857736175, 0.21676686528365485, 0.19180359724688223, 0.2089852131033031, 0.18852752645090898, 0.22268289320158285, 0.18989238866996794, 0.18067149034823038, 0.18664291255030296, 0.18544688449957825, 0.10580921034004931, 0.09949618103677327, 0.1401773364828448, 0.10077359638428318, 0.08066288948850231, 0.13700198412632214, 0.08353991829714391, 0.09584867712194778, 0.08804462908715271]}, "mutation_prompt": null}
{"id": "a9327684-c846-47f2-8a4f-75c7ad8b6de5", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                proximity_factor = np.linalg.norm(global_best - pop[i]) / np.sqrt(self.dim)\n                dynamic_mutation_factor = self.mutation_factor * (0.5 + 1.0 * (1 - proximity_factor))\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / (2 * self.budget))))  # Adjusts based on convergence\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance convergence by introducing adaptive mutation strategy based on proximity to global best.", "configspace": "", "generation": 51, "fitness": 0.3209961376678044, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "2dadcdad-01c1-403a-bff9-fed3c1495637", "metadata": {"aucs": [0.8282875809177036, 0.8298385637837775, 0.825289381455853, 0.8133162041386368, 0.8394282017242296, 0.824689658663277, 0.8130888170407902, 0.8286503886941635, 0.8395732209230542, 0.6613027717079845, 0.6474082597341142, 0.6561994847851853, 0.6237471950607888, 0.624992228198201, 0.6183070108269397, 0.6542561732793044, 0.6399490298592091, 0.6585331187991537, 0.11935876583806315, 0.15032479963210266, 0.17152083480158598, 0.11641660318022806, 0.15155992405238705, 0.14581428182080358, 0.11778840447100936, 0.11222243134091137, 0.11932226600646734, 0.1489369879096335, 0.10548236287051949, 0.130142433688603, 0.1156273415141903, 0.11971418627589625, 0.1231385575264552, 0.08783476349277464, 0.13453756418322993, 0.10604992432956029, 0.9696153422892239, 0.9780533864256583, 0.9755005274158624, 0.9693579823689019, 0.9743599943263874, 0.9683575463786417, 0.971491839466885, 0.9791881859856487, 0.9702884561882141, 0.7212590381736068, 0.7143024820646495, 0.7346088760973606, 0.69453198244714, 0.14975746732000494, 0.7147417583087579, 0.7301879761023118, 0.6994151395158097, 0.6390320591300789, 0.36349201238914497, 0.3644401811052973, 0.22602825768252666, 0.8291132017699989, 0.36661592255210285, 0.12158883448059987, 0.7716137593632664, 0.21552854919297593, 0.23206605215193643, 0.23026987687898448, 0.20161275583036442, 0.25205341768774203, 0.2139463216847114, 0.12841733462395077, 0.2120853740560782, 0.13037602609539267, 0.26629469483905777, 0.22688381134754665, 0.23614220459388602, 0.22565905091267813, 0.1271018462969583, 0.19234676422166108, 0.1888943376345097, 0.24863577893337607, 0.2774996911516525, 0.2318394267652153, 0.23567352565905242, 9.999999999998899e-05, 0.030107706820293623, 0.02813732825960069, 9.999999999998899e-05, 9.999999999998899e-05, 0.03532677141881757, 9.999999999998899e-05, 0.01205873529858914, 0.00045542006567944604, 0.2753377132454288, 0.025983960079692614, 0.12200227858524582, 0.07403037606225293, 0.02158570456715847, 0.054412646672156395, 0.07544528984200294, 0.09938218171140056, 0.0870743123689608, 0.1308920918280133, 0.031180157979875167, 0.05052015632641482, 0.14736712472217983, 0.31473087604952665, 0.14768420233589008, 0.09572493867017018, 0.31718459528884957, 0.0909736933981038, 0.15698467048127818, 0.2619995822028208, 0.1143685545489741, 0.040433499395989725, 0.086785306941502, 0.10996310789378827, 0.1686008069443513, 0.07936572620825932, 0.07940519470759244, 0.5119209686718744, 0.5081862454258199, 0.5355615066432686, 0.5317655464181713, 0.5842325082793212, 0.5308081492364622, 0.5374477000262419, 0.5374708803007061, 0.5591518724604312, 0.10956646516895818, 0.10898999883198779, 0.08769331971165883, 0.13573440502329137, 0.10832036870599182, 0.13559048779081373, 0.15554090089799377, 0.07539656300568387, 0.1760477611542527, 0.17528578428684982, 0.20322927893807818, 0.1711453161374027, 0.32898125120468946, 0.19365893452053462, 0.3108657029470352, 0.261355298363413, 0.21310508635816072, 0.18533218478616809, 0.3840457928838167, 0.2615004810604409, 0.29957153298271877, 0.5361541805644027, 0.22961705279931366, 0.44069810818359867, 0.2592969700527957, 0.49249962523782365, 0.30913874893217885, 0.26554277933437453, 0.21181478193591097, 0.16716565209668444, 0.31319675223433807, 0.24753704527412979, 0.3639002034536325, 0.2439908277391668, 0.31212246558669676, 0.3075627062257422, 0.22668191678718974, 0.22254267669809025, 0.2759659370329709, 0.2345407406607607, 0.2254359531464487, 0.19871294621663405, 0.21088513103506257, 0.2689630022018913, 0.2276102676855225, 0.6994522639352758, 0.1935708802219146, 0.20199749847651727, 0.22485081142738605, 0.2191220330755116, 0.19977007897480858, 0.719023807965807, 0.21207401247298152, 0.18612397197815334, 0.1615370038679188, 0.16711006002735607, 0.12507042997554418, 0.8891081497757042, 0.1855568204181146, 0.19736621964062784, 0.14196694768311213, 0.16892515100732985, 0.8528562909262335, 0.6942158000956233, 0.20930343141522234, 0.7542305706633822, 0.20724058457038508, 0.16812476271495436, 0.7604377566338111, 0.8346652865431271, 0.7482014027962534, 0.10445808725372352, 0.1936371338618611, 0.1937502075945805, 0.18789688787310888, 0.20297998828005737, 0.1909526420484765, 0.18935529850823118, 0.17950419835251774, 0.18520088519274436, 0.22228916121224462, 0.10387603556453529, 0.101986522629548, 0.14489379286421988, 0.09211551705832421, 0.10192323622747734, 0.09683951237800015, 0.09644958626191014, 0.09556971579292206, 0.08168305331714454]}, "mutation_prompt": null}
{"id": "766a31c3-310a-45e0-bf5d-903f76d7f1c4", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.3, 1.7)  # Changed\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / (2 * self.budget))))  # Adjusts based on convergence\n\n        return global_best", "name": "HybridDEPSO", "description": "Integrate a stochastic component to dynamically vary the mutation factor and enhance diversity in exploration.", "configspace": "", "generation": 52, "fitness": 0.3214605156452253, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "2dadcdad-01c1-403a-bff9-fed3c1495637", "metadata": {"aucs": [0.8146103545216125, 0.8239398512563249, 0.8079405932970403, 0.827425716334976, 0.8252070812668226, 0.82476578411873, 0.8060010197158639, 0.8370823359206929, 0.8129730823722401, 0.6597192080872004, 0.6001811948937509, 0.6505620697310784, 0.6551408210643254, 0.5964082320557593, 0.6466479770831888, 0.6657328964877749, 0.6401485299386847, 0.629818534262218, 0.1458100342340265, 0.11516301217853275, 0.16679449293888482, 0.17466862233688207, 0.13754554995853063, 0.12207334567678796, 0.1683512814237822, 0.6870322035132257, 0.1742413917813045, 0.10544914576821829, 0.13346322715821168, 0.1457336786003368, 0.11241815221279772, 0.1717337102145562, 0.10530333105035938, 0.11801704089191078, 0.08900669282346729, 0.10156213032753225, 0.9718483266182734, 0.9716585010058418, 0.9700697374979619, 0.9632951864578236, 0.9705804642868434, 0.9649034544950721, 0.9755338843908533, 0.9729692184050363, 0.9678631659096201, 0.7197531392366543, 0.7395919800687665, 0.7077497296977281, 0.7323618590690368, 0.7237582701152385, 0.7014408386507115, 0.6987856473687521, 0.7188555180480611, 0.7180259571501297, 0.2275710372955171, 0.8451635495175033, 0.3861235875259186, 0.36364208609498505, 0.275694410548738, 0.2705855796509451, 0.8224201329779702, 0.2331546983179501, 0.3796578996986626, 0.11862549334504568, 0.23674739021568114, 0.22284994486527798, 0.1911731937890504, 0.23003336959333376, 0.22238880565193575, 0.21728800221541011, 0.11825194746717194, 0.12976737535328797, 0.1718693673066557, 0.21992669006567922, 0.11292402736621932, 0.25842063516218794, 0.24506812021090796, 0.2633517644507227, 0.25719997244981874, 0.19828429503715161, 0.23493115873243164, 9.999999999998899e-05, 9.999999999998899e-05, 0.08892195262057268, 0.03427437792610877, 9.999999999998899e-05, 9.999999999998899e-05, 0.011564035661142058, 9.999999999998899e-05, 0.04836112679455673, 0.1379194757300536, 0.04975646281376955, 0.14355233331179296, 0.0563123771629791, 0.02530775473186042, 0.036759025138523804, 0.053633571239435684, 0.20348015731955116, 0.043386276197099116, 0.10614466591797378, 0.23350474648161612, 0.18702063985031125, 0.21814745673286573, 0.07034847413778877, 0.07069696940009329, 0.16149024534308987, 0.1563232000250977, 0.0695083520226002, 0.18380107670343948, 0.020416741406206307, 0.31166451305703635, 0.006450056090191336, 0.181389358934684, 0.10956855157337453, 0.1067616624896156, 0.08177234681642132, 0.0791979254713373, 0.5284415874723016, 0.5649123641367704, 0.5075263139212108, 0.5437397085129279, 0.523903231293305, 0.6116431264062352, 0.6390758736140534, 0.5650386730856749, 0.5481736325302125, 0.10523115107332082, 0.10045321816827002, 0.10040807904051052, 0.10399459588558735, 0.1251511666912558, 0.12843177991025567, 0.12616528312991682, 0.12366815646406393, 0.11859299390148648, 0.19478880300512869, 0.1947474839331892, 0.17288680534477374, 0.24928315344525598, 0.33891067952971066, 0.25476428880238156, 0.16975061978159922, 0.2705036735384009, 0.22426897182684435, 0.2889664060776004, 0.329813268396442, 0.3931644662382665, 0.3734441352405279, 0.3361373008399624, 0.4806003764317568, 0.6483633462198289, 0.7017542188568153, 0.502914519287938, 0.29306258369609217, 0.20601901094546393, 0.20662021017996468, 0.19803095687103855, 0.23905495777446295, 0.2820394748888594, 0.24231720469256035, 0.4412731133251595, 0.1967477201460741, 0.2233565891857333, 0.22088429446155422, 0.21490824286821075, 0.20837089446550394, 0.22190347738807192, 0.24254505549283878, 0.2216277944194277, 0.21319328293517092, 0.2821310067135969, 0.19663558358455313, 0.18365788130486804, 0.23967801680859935, 0.208047040452206, 0.2233086184738008, 0.23040658427547256, 0.20573542871129769, 0.21904985846410896, 0.2048330280253109, 0.18481379824787458, 0.1994113265654408, 0.19878258518644143, 0.8873254176751022, 0.1988786030199271, 0.19839216651242486, 0.8468991475717769, 0.16890199048907284, 0.15173433430023175, 0.8373714582604428, 0.2099485991409933, 0.2098630619221532, 0.2081544096205582, 0.16728413649295504, 0.6136075268683279, 0.10465978545856558, 0.10435330985742075, 0.7829656907450426, 0.18800620250908773, 0.19495181771696513, 0.20272770257321693, 0.1979647938561141, 0.18424800907342553, 0.2037659359985784, 0.18672356428203996, 0.20040992734595886, 0.18924627616655265, 0.08298697282745038, 0.08730081775752585, 0.1194556074008809, 0.09846057391707963, 0.09921494521678909, 0.1353978593697821, 0.12567946415394748, 0.09429918024503314, 0.08746537046231029]}, "mutation_prompt": null}
{"id": "c8856282-1e96-4676-91af-30a9f7dcac87", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.archive = []  # Added for diversity preservation\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 2.0)  # Adjusted scaling\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n                    else:\n                        self.archive.append(trial_vector)  # Archive for diversity\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / (2 * self.budget))))  # Adjusts based on convergence\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance convergence by introducing an archive-based diversity preservation mechanism and adaptive mutation scaling.", "configspace": "", "generation": 53, "fitness": 0.3151873550316687, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "2dadcdad-01c1-403a-bff9-fed3c1495637", "metadata": {"aucs": [0.8081919077807618, 0.817437390695738, 0.8276594193697584, 0.8498365606649546, 0.8092702477086618, 0.825170475819498, 0.8319210957474835, 0.8205578844534298, 0.8118978326828079, 0.6762919103204887, 0.5850445918208556, 0.6545252164666238, 0.6119471221012225, 0.676952671659903, 0.6777332553701383, 0.6717586306915325, 0.6394799230094146, 0.6653951741850452, 0.16060597137406984, 0.17686137210485753, 0.15942565734120184, 0.1127603806103773, 0.14636972095187362, 0.6056632991755011, 0.16725269314135782, 0.13180758539276272, 0.1491137597129213, 0.07596340165551396, 0.13369106210979587, 0.14134928589765838, 0.12258897090741627, 0.13186062043179558, 0.14296124882145578, 0.15008809039370008, 0.14209623702195384, 0.10782245720582162, 0.9773267582964947, 0.971871789552456, 0.9698437935729518, 0.9779598333848596, 0.9705402245526623, 0.965219920713973, 0.9755781090740726, 0.976529878554308, 0.9680818985141953, 0.7276804897908937, 0.7156635283285426, 0.6681436254362412, 0.7147254633889547, 0.7013018416678242, 0.6627990919489182, 0.7123645038553106, 0.6649534458328693, 0.6936546393017904, 0.33595037667293914, 0.21886991547308943, 0.22207381890042366, 0.2726364731945511, 0.31141435684417507, 0.2715221780303654, 0.22225387482508374, 0.22955923197012573, 0.37056350794327086, 0.24935811778322914, 0.1986564834756751, 0.21729871567100478, 0.12876661656263755, 0.23219408019932153, 0.1281869812842149, 0.22860433823730608, 0.1147477268269822, 0.23579276595602283, 0.2041247506602868, 0.18230278946787792, 0.14697425841459588, 0.26460794432950463, 0.24237786423931806, 0.2524043191848486, 0.12618690094691065, 0.12291638458698306, 0.2719328389437571, 9.999999999998899e-05, 0.08211986466855159, 0.05866552277681325, 0.055220586125150684, 9.999999999998899e-05, 0.0026415962081353106, 0.029393200272295528, 9.999999999998899e-05, 0.0640446643632756, 0.07013172655454891, 0.05758943101292402, 0.11485646556516949, 0.1069044618719247, 0.11966727866173255, 0.1585428797682623, 0.12144661750981245, 0.13733504779331085, 0.040902821833705416, 0.11686040233087536, 0.14189719674560108, 0.03339985272319901, 0.1332139641555835, 0.07269015673286794, 0.07281927960148149, 0.19074700192858607, 0.18696694262075986, 0.13506530933629834, 0.09406623285227511, 0.01066835996909088, 0.1735537176364913, 0.0638543141663176, 0.11618653941794999, 0.0961831987134657, 0.04668770233995534, 0.10511737947354016, 0.08198447266466025, 0.54825915948756, 0.5025024833159971, 0.5774187647668226, 0.5798666176774733, 0.5338934757592922, 0.5203377170005005, 0.6443902413053564, 0.514085341029862, 0.5530345936974512, 0.1277814514725485, 0.08631374662128688, 0.12399105556545442, 0.08802497202687642, 0.10779529317717007, 0.1328843297025435, 0.10285723984879691, 0.10452204783356522, 0.14475537193837995, 0.27697998965311343, 0.24334852432099197, 0.2014029634879545, 0.4109676547623432, 0.24712913281162008, 0.2567357704029646, 0.2683022970167096, 0.20893664739931506, 0.18631438441879045, 0.2728633085633049, 0.2801183848815205, 0.4553034244337597, 0.32676958988048044, 0.40671812192390644, 0.5018197778012848, 0.6540901998740456, 0.6888733819991499, 0.25901288247966825, 0.38579031716593104, 0.28045558528639514, 0.25741749281883775, 0.23542413213166635, 0.20932892070936093, 0.28057917176546465, 0.2530339585508554, 0.2374644248578791, 0.21365798904087463, 0.2423253984969823, 0.2611324284656251, 0.22735107322689352, 0.22591974947236648, 0.1958138791264541, 0.2370204836281803, 0.22746498412653815, 0.20585032328918162, 0.21745649526900124, 0.1975839964020053, 0.20116715252684725, 0.1885430412808804, 0.22491706503525288, 0.21829205011731578, 0.22223993889461569, 0.19796406756745133, 0.20167495256086, 0.21995056629605503, 0.8637399586173897, 0.1846715392351731, 0.20012153260412735, 0.17249631575665358, 0.1990595899374279, 0.8345478452125386, 0.8171086909844011, 0.13079029795347052, 0.16170438502538365, 0.8142615158634837, 0.2112144549799867, 0.12654327983544122, 0.20741857354089321, 0.1674723574128255, 0.5828383047528185, 0.10455192087028331, 0.10431806441409064, 0.8304265641066726, 0.22040097910798262, 0.18571585952492065, 0.22014007777801603, 0.1979983126947229, 0.19984178258678298, 0.20200718310709254, 0.19267428761263328, 0.1899965266544278, 0.18802544121022258, 0.09188290785361664, 0.09413154784643407, 0.09358688036912532, 0.09355349572788185, 0.08019214659301344, 0.11235823156525693, 0.085783529438888, 0.09332425455043702, 0.09375631548351415]}, "mutation_prompt": null}
{"id": "d3112d38-959b-4268-bb29-86e8659afd99", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                # Change 1: Introduce dynamic exploration factor\n                exploration_factor = 1 + 0.5 * np.sin(evals / self.budget * np.pi)\n                dynamic_mutation_factor = self.mutation_factor * exploration_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / (2 * self.budget))))  # Adjusts based on convergence\n\n        return global_best", "name": "HybridDEPSO", "description": "Integrate a dynamic exploration factor to enhance both local and global search capabilities.", "configspace": "", "generation": 54, "fitness": 0.31825466048813955, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "2dadcdad-01c1-403a-bff9-fed3c1495637", "metadata": {"aucs": [0.8437080032339478, 0.8174811044426902, 0.8186707984619375, 0.8125649233966467, 0.8251522491617407, 0.8262839287043693, 0.8286342054361978, 0.8252421553125314, 0.8291850205652456, 0.6384665971031107, 0.6669442460829182, 0.6551619861003914, 0.6275776902882021, 0.5679578520727253, 0.6822034890165514, 0.6381368672080726, 0.6561244782766681, 0.6296665510332187, 0.13983071111888146, 0.14719002799431002, 0.1725364452413889, 0.1256637849302228, 0.13344519047142822, 0.11506512877336084, 0.11087796424659735, 0.15760729150952268, 0.15256386055617766, 0.1393368807612767, 0.12959652738180194, 0.10184378760200508, 0.11302651171301825, 0.1339221777181694, 0.13051088691125567, 0.13537676004235966, 0.12284287639289126, 0.13007563974682756, 0.9716666467251011, 0.9705083520346378, 0.9700064001666765, 0.9638432197269572, 0.9705381170872297, 0.9629944321491871, 0.9755234618834072, 0.9731761559513448, 0.9677870390309187, 0.6650836437643264, 0.7200751592905701, 0.7090802609445428, 0.7258145086357874, 0.6781810278818821, 0.7207749033338595, 0.7206994213473714, 0.6888611499195525, 0.7171807150175661, 0.22814924878427234, 0.4900716802552, 0.8021014660781924, 0.3657408483949839, 0.20771826398704663, 0.2045987466220156, 0.2343732952535884, 0.8614359471561361, 0.24128716575014364, 0.39921017074905873, 0.21558619304803306, 0.20591660343493545, 0.12476937940107824, 0.2090107444519641, 0.22777339784935413, 0.21864469351674376, 0.20423963770349673, 0.2231386931264101, 0.23566559817783828, 0.13117908250445176, 0.14377670331531334, 0.25450004213682864, 0.1844029647055636, 0.2484180008090987, 0.18745302553617005, 0.24072400664282845, 0.2577655819274143, 9.999999999998899e-05, 0.02950704698519835, 9.999999999998899e-05, 0.03414149285319412, 9.999999999998899e-05, 0.02395502617393408, 0.008464935186191513, 9.999999999998899e-05, 0.00497034584493572, 0.11444191132843973, 0.030819674915931627, 0.07869893233197711, 0.08821417338115967, 0.05574049176583207, 0.033692892020966814, 0.06809081323955901, 0.10895379030190089, 0.06288731530233815, 0.12608792637110888, 0.11426401928199559, 0.17459025320279853, 0.14878405205450762, 0.09850335284572631, 0.06857419374596685, 0.14761098558784946, 0.0970688582346575, 0.06549231271727929, 0.16033139097962124, 0.011729459631044326, 0.047142466965747865, 0.030269581368977394, 0.0414507894944709, 0.2240023904338162, 0.05468632199930268, 0.09830351280399185, 0.08847597107121452, 0.5204620209192621, 0.5318584509977196, 0.5405868876032632, 0.581521823013612, 0.5524427884869078, 0.5104213333194108, 0.5679993658472782, 0.5702363498144636, 0.5768876358182762, 0.13553039479697893, 0.10739926498186048, 0.1088219944925588, 0.12742693024777796, 0.13425548765080453, 0.10777951105622319, 0.10970821905890293, 0.10478441930555293, 0.12412793643913467, 0.21937217164980782, 0.1960497294990431, 0.23100972358949834, 0.208955940908916, 0.3325113112785383, 0.2668906476789943, 0.27257092121585325, 0.3367295674363088, 0.2221437421230712, 0.30582564510179766, 0.37735191111133704, 0.40891327061475424, 0.34331742504964446, 0.39748348239131825, 0.5344408613567904, 0.5274707926512445, 0.49202901576834956, 0.587644417004735, 0.28221000557492637, 0.29850165466011247, 0.13608615163768423, 0.2283231365307643, 0.2939961931912006, 0.24645259467685998, 0.30403991180533985, 0.42397144701980305, 0.32051638263027016, 0.19226345631659714, 0.21144817843533503, 0.20777719863117716, 0.24499940397536968, 0.2248490895308911, 0.20735891273913754, 0.24989200165247094, 0.255407087867791, 0.2602408205988226, 0.19538333593704982, 0.18861397604378904, 0.20672461484461624, 0.19236614117361472, 0.1989698263177363, 0.2379493076095377, 0.2131567657183734, 0.2444978709401321, 0.21383699574669235, 0.18353970236742767, 0.19917603010262308, 0.1725084953782241, 0.8691232789466898, 0.19944051219478343, 0.14578832529654173, 0.8453606361042946, 0.16876447495478464, 0.15205471458727426, 0.8366865158198211, 0.20903877077816013, 0.2091120810530036, 0.8266900287994361, 0.1667179492068015, 0.35836282438850764, 0.10472517513715796, 0.10430458554673383, 0.8107847085966506, 0.18417251663845924, 0.18205464277676087, 0.18433118328289788, 0.20239989596784957, 0.18635062528093027, 0.24417094977093257, 0.202312210586436, 0.19468558546806736, 0.21186946627300918, 0.09420847048898473, 0.09399698947884139, 0.10117523144096707, 0.10156324445473253, 0.0878397756029552, 0.14329442131436076, 0.09620740129061667, 0.0953783067879147, 0.08175601154905177]}, "mutation_prompt": null}
{"id": "7fa00735-7d6d-434f-b7d3-e0adfd98a5d9", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / (2 * self.budget))))  # Adjusts based on convergence\n\n        return global_best", "name": "HybridDEPSO", "description": "Introduce adaptive crossover rate and enhance exploration by adaptively updating the population size based on convergence.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2dadcdad-01c1-403a-bff9-fed3c1495637", "metadata": {"aucs": [0.8359344413819497, 0.8340020473636771, 0.8177542711523587, 0.8282637876571906, 0.8272468883972396, 0.8296198977328977, 0.8453163689613803, 0.8298710928367996, 0.8086930057290679, 0.6300650824211467, 0.5243839758318625, 0.6480287619233989, 0.6293383597844323, 0.5661979305507592, 0.6327004966143543, 0.6609175176278232, 0.6673560545920878, 0.661990063393395, 0.15047509578713958, 0.12997097041522743, 0.12620484931474307, 0.13756588336602615, 0.14403952733366965, 0.13829661227842793, 0.12631748607174997, 0.14042619794064792, 0.679913523619764, 0.1348929289905143, 0.10025521190385789, 0.08915599729795376, 0.12174548146873587, 0.11203967860189701, 0.14694400466350943, 0.13602685798117276, 0.13293448702184618, 0.12842920639109634, 0.9716577286457261, 0.9704854374227017, 0.9700121311361274, 0.9638062100940954, 0.970532483939913, 0.9629986958369492, 0.9755187178690252, 0.9731786009342139, 0.9677615403300047, 0.7455288209443123, 0.7078318408839777, 0.741965831501826, 0.7247124619072475, 0.7001765537054596, 0.7173970378873546, 0.7250746051997472, 0.7147823537715927, 0.7147702163688576, 0.7753744346780321, 0.8275717282747095, 0.22423005123800555, 0.7713891017561286, 0.3498806077231317, 0.27154681615585263, 0.8244896619222833, 0.8656253127153338, 0.22184002709514916, 0.1888047299915805, 0.2068870084009269, 0.2181633004292346, 0.2171470204039957, 0.2298967387244627, 0.23327798867867033, 0.2251430100614974, 0.27247767217355034, 0.22943578865809489, 0.23894088856678464, 0.12813436811567003, 0.14322705647211265, 0.24789311992593532, 0.22223316206366184, 0.25644521533794795, 0.2634509502082456, 0.25485136381451967, 0.2580310884366892, 9.999999999998899e-05, 0.04905010372085161, 9.999999999998899e-05, 0.031124022545261143, 0.00010009251651721396, 0.0676408433591692, 0.004121327247791462, 9.999999999998899e-05, 0.004048934944478111, 0.07228794955288886, 0.025207162494297886, 0.11613800131198515, 0.08790078192921469, 0.02005366371679207, 0.03177561475707502, 0.05994418904005583, 0.08292395334092795, 0.039132227159612065, 0.14370720647068724, 0.2762296473981354, 0.08342813776121327, 0.30440753749415506, 0.08950069127576898, 0.07175084741362314, 0.15204631577118577, 0.09046531786762813, 0.07377413301538072, 0.07945697552627684, 0.012230241887086546, 0.05535991908341986, 0.052080239077988866, 0.10503265122564753, 0.051718218946512184, 0.05499692758606256, 0.09889989631300689, 0.08879616287047976, 0.5438819781871052, 0.5110996258505001, 0.5191495041697142, 0.6043964776592872, 0.5218077945518597, 0.5449463362848045, 0.5166776003563157, 0.5235545718584635, 0.5348459588109533, 0.12334462956345593, 0.11905734543592084, 0.11164586859489589, 0.14761233292301346, 0.15118319459240448, 0.12378084021430635, 0.11344946489117069, 0.10625827763004525, 0.15321125099271415, 0.4320761069241412, 0.18977157479329887, 0.19707589925971225, 0.18125497301550453, 0.546819752034278, 0.262845079277798, 0.21804021672435703, 0.25130729566914445, 0.27493692654919877, 0.434963732849142, 0.2447878314194475, 0.42366605495937093, 0.3624154900561821, 0.24515391233437878, 0.509189318315969, 0.4747784440328786, 0.599064204963796, 0.5016382629189381, 0.24924558264502628, 0.2227513753457947, 0.31844330218681693, 0.21661929612037334, 0.28215364427950806, 0.17937971738986958, 0.2724742302758967, 0.2821936074996094, 0.3865286833568986, 0.21798135083516523, 0.19487120011017522, 0.19048968797540078, 0.25131863869967397, 0.20654629535368207, 0.24670920302045063, 0.2528520195912729, 0.21373913271831624, 0.22366123873333443, 0.20027263161569753, 0.19435184486011836, 0.24575644051565237, 0.2428266430029996, 0.18869622458558788, 0.24029558511274218, 0.1990906972077413, 0.2069624178148992, 0.2069411061096833, 0.8585304391204805, 0.19903081440561488, 0.175557884161461, 0.8517614084943631, 0.19988195875585013, 0.1474023338286239, 0.8554186405141962, 0.16877962175740036, 0.15182863927668455, 0.8590430079642989, 0.2086836818451, 0.20932073847283683, 0.7646326738132165, 0.1667318044168622, 0.6323639279050162, 0.10473593983250706, 0.10433761070548897, 0.8115552857736175, 0.21676686528365485, 0.19180359724688223, 0.2089852131033031, 0.18852752645090898, 0.22268289320158285, 0.18989238866996794, 0.18067149034823038, 0.18664291255030296, 0.18544688449957825, 0.10580921034004931, 0.09949618103677327, 0.1401773364828448, 0.10077359638428318, 0.08066288948850231, 0.13700198412632214, 0.08353991829714391, 0.09584867712194778, 0.08804462908715271]}, "mutation_prompt": null}
{"id": "372d6221-4b4a-4fc8-9985-750f9439ec5d", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * (0.5 + evals / self.budget) * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n            \n            # Local search exploitation\n            for i in range(self.population_size):\n                local_vector = clip(personal_best[i] + np.random.normal(0, 0.1, self.dim))\n                local_score = func(local_vector)\n                evals += 1\n                \n                if local_score < personal_best_scores[i]:\n                    personal_best[i] = local_vector\n                    personal_best_scores[i] = local_score\n                    if local_score < global_best_score:\n                        global_best = local_vector\n                        global_best_score = local_score\n            \n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / (2 * self.budget))))  # Adjusts based on convergence\n\n        return global_best", "name": "HybridDEPSO", "description": "Refine HybridDEPSO by introducing adaptive mutation factor scaling and incorporating local search to enhance exploitation.", "configspace": "", "generation": 56, "fitness": 0.32457386304429375, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "2dadcdad-01c1-403a-bff9-fed3c1495637", "metadata": {"aucs": [0.7944255360976715, 0.7787609237544246, 0.7757177861010356, 0.7854189302070901, 0.7885788576004259, 0.7817666217792594, 0.7564374860063819, 0.7885262812644245, 0.7909888950390723, 0.5842086681781035, 0.5788027945235722, 0.5582175892095493, 0.5624331704201132, 0.5249166259974911, 0.5832103870504761, 0.5336145067136651, 0.5345821892210797, 0.5908664317380027, 0.1750564372031007, 0.1282982527391574, 0.13279644645518807, 0.1556715925214912, 0.15529006494409636, 0.13378884574664518, 0.1452737027985771, 0.1688254250490432, 0.36539598703837506, 0.1444221585016885, 0.11511108664161551, 0.13417828605924265, 0.11270414400510653, 0.16715210702050987, 0.10430184600057657, 0.1367669990913566, 0.12912631259131613, 0.15089434867840812, 0.9584740302509247, 0.9567390352072546, 0.9641477718692228, 0.9418075018073218, 0.9536448208377082, 0.9538299584029206, 0.9621473206158332, 0.9463208533436175, 0.9460914809649854, 0.6336177821282827, 0.6416500165509513, 0.6507366210413006, 0.6397558294040131, 0.6598311343359281, 0.6687061290841896, 0.6170108435042199, 0.573876915652409, 0.6515240248869196, 0.2250605834840168, 0.3511365336598149, 0.4352423282781468, 0.27143843642430054, 0.3607956354788482, 0.1888695495794267, 0.7482523838315644, 0.7539437158601043, 0.23184339502409324, 0.3627951344885756, 0.1231858597163017, 0.186526823477012, 0.12875036424934883, 0.12881976030998776, 0.18938029955239832, 0.1250062362434825, 0.18559997183045585, 0.18592960136544323, 0.2135823167890336, 0.12573853390778367, 0.14658523043804073, 0.21475735709404054, 0.21108288010622356, 0.21483193159952851, 0.21749371234460158, 0.2477536919510892, 0.23877563861205842, 0.02979448319040634, 0.035490066692625666, 0.09105671787410696, 0.023532897232743544, 0.0622079587708253, 0.03590429663145356, 9.999999999998899e-05, 9.999999999998899e-05, 0.040922402967834004, 0.11809239926449122, 0.07371711789449253, 0.16386164841265305, 0.08150291620270622, 0.06080955463351967, 0.056761689895333256, 0.09536490103453765, 0.17806619113460587, 0.08462197271157512, 0.13918959085408167, 0.10341959671952394, 0.1073825672737968, 0.17604833393520236, 0.26921160311918246, 0.08706879353408259, 0.09313558891892448, 0.13805417153773303, 0.1854590772666196, 0.19498857007824422, 0.09860964769355196, 0.15129389764374768, 0.06120669842568771, 0.11128461279402868, 0.08904954086640282, 0.09352405799920871, 0.23730433788320693, 0.13162339125304912, 0.5366358032444248, 0.5071555726993062, 0.48927031132451093, 0.4947291037449616, 0.5133007049778969, 0.5051404295484647, 0.5416915828459307, 0.5810678100873665, 0.5296998381688238, 0.13224032291094623, 0.14363154507712994, 0.12780273041451817, 0.1256797405829948, 0.0972998873991543, 0.23547170602833767, 0.10425281370605755, 0.13238086603010124, 0.10953986863805398, 0.20443324991241574, 0.23982821441933622, 0.2030241905916481, 0.2202282131609793, 0.2120365416086918, 0.3166061182330825, 0.3698914946528069, 0.20391928087240263, 0.18876746456914373, 0.4607882945947278, 0.37633434535274257, 0.3717638988051456, 0.3963943931487346, 0.36810281579004567, 0.44183202541078914, 0.47755970799632963, 0.5106738221347353, 0.4667378922403922, 0.2409788181996182, 0.26378607163046985, 0.2076795220847566, 0.3671369236813009, 0.31341921528863126, 0.26450406685476024, 0.33345835721432115, 0.3194287181031217, 0.32883633660227896, 0.2443971792178975, 0.21310987375309465, 0.23572264712111257, 0.2191540857925447, 0.21468456184255247, 0.2701535526204881, 0.23771826515918115, 0.2581447867551857, 0.21107297221497678, 0.48601915274728846, 0.20270555569573212, 0.42439546202220946, 0.7104368739453333, 0.21127409900276384, 0.6081954419719253, 0.22370979469147056, 0.2181877850016536, 0.21694150398038015, 0.18552751341567542, 0.18671895080998724, 0.18664228897986346, 0.8602438262740255, 0.1996173443830953, 0.19909914528453176, 0.7116093673822068, 0.8351896514733568, 0.15269831306641213, 0.7202889439827573, 0.21106485083790483, 0.2093582036774716, 0.20607369435275547, 0.6348812048192052, 0.5405343848559747, 0.6997707780692632, 0.1650593419322529, 0.6367292780425128, 0.20292139044971713, 0.19633210803447865, 0.1940288150090329, 0.19120025616201042, 0.19862155351314137, 0.18897507570597405, 0.21451824769021866, 0.1950365559066286, 0.19091181663833545, 0.09404867643251835, 0.09520283949156982, 0.1401912494065567, 0.0909787884653942, 0.0890736442703235, 0.13769413276671238, 0.09433509680216046, 0.10008598012663716, 0.09214789302736914]}, "mutation_prompt": null}
{"id": "992a21fb-4dd7-4eea-945b-cc4ef6ff1e68", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * (evals / self.budget)**2)  # Non-linear scaling\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - (evals / self.budget)**2)  # Non-linear scaling\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * (evals / self.budget)**2)  # Non-linear scaling\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * (evals / self.budget)**2)  # Non-linear scaling\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / (2 * self.budget))))  # Adjusts based on convergence\n\n        return global_best", "name": "HybridDEPSO", "description": "Introduce non-linear scaling for dynamic factors to further enhance exploration and convergence.", "configspace": "", "generation": 57, "fitness": 0.3074477968421095, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "2dadcdad-01c1-403a-bff9-fed3c1495637", "metadata": {"aucs": [0.7694955994486277, 0.7802236993706003, 0.7670835116261642, 0.7725122290469258, 0.7691917536475756, 0.7632253049552336, 0.7657594161383564, 0.7796505898142321, 0.770744485476885, 0.5732832447657095, 0.5652104637604625, 0.5036665467746646, 0.5596844662117174, 0.4865162661689385, 0.6124799415108892, 0.5628310342464264, 0.46470470556656485, 0.6076215918377842, 0.13416346151371816, 0.16439184987314925, 0.11125105027676163, 0.12196208200321557, 0.1452600885245382, 0.13836973817767861, 0.15427160847943, 0.1262150891659587, 0.12848734197772993, 0.11393208971788304, 0.12392648039741616, 0.16531023464730532, 0.09542579724035372, 0.10997640941797637, 0.12060737333975391, 0.10906192924545177, 0.10665142807689931, 0.0864991906511714, 0.9716027013352884, 0.9706789055808522, 0.9699232268009451, 0.9633260951193517, 0.9704939407026771, 0.9575195621838822, 0.9760187020308835, 0.9713791946486441, 0.9677561510709927, 0.6944053771771133, 0.6605186590629509, 0.6359027932805096, 0.6800110471785966, 0.526492917385723, 0.6667150136632538, 0.6434923123728848, 0.6740778598537002, 0.6505984192541843, 0.3756827966112045, 0.3820112322020882, 0.2097167412779407, 0.26820555680979286, 0.35921904926849424, 0.21393161267483152, 0.32831480557553827, 0.2313787555783572, 0.22859784190616061, 0.2826663238861059, 0.24498609516584324, 0.22949367807446774, 0.12691680307531716, 0.1305466285817669, 0.2114843483632468, 0.25086915917507735, 0.21274872008649937, 0.19492368363465373, 0.22743013274306823, 0.22865558267755082, 0.2929209936592414, 0.26384190933824747, 0.23172907212004823, 0.26118508365855697, 0.27331156298076953, 0.21945466325556318, 0.26236763315236744, 9.999999999998899e-05, 0.026695927986897683, 9.999999999998899e-05, 0.04149449474475164, 9.999999999998899e-05, 9.999999999998899e-05, 0.006505496093565544, 9.999999999998899e-05, 0.015678883339822813, 0.07613606818226692, 0.04562263942543798, 0.11912529830844687, 0.062364916124467706, 0.02583858645183923, 0.04121690667548206, 0.04763823723609606, 0.08112667196877921, 0.036102812546065954, 0.04407369751411094, 0.18359181790724766, 0.18727371412599392, 0.23753306090861537, 0.08930259975929788, 0.06484121197883885, 0.12662299217458517, 0.12282805246614714, 0.054210857577489, 0.18837445913685258, 0.01707486458013896, 0.1206210446267294, 0.005855637491059107, 0.22292436756579226, 0.10452120215517358, 0.05589396130901403, 0.11182924148320583, 0.0918772202667435, 0.5026125749506543, 0.5562524613916769, 0.5283233583037152, 0.5203609432821807, 0.5607304565130486, 0.5787873521745652, 0.5741388969274739, 0.4956862097042736, 0.557094360435819, 0.131265533207923, 0.10706901180146777, 0.11459787745092376, 0.1269656836908971, 0.1331272527430063, 0.10415045160671776, 0.07969380237084256, 0.13663922611484436, 0.1273930316873335, 0.26070928849236985, 0.16616492551884876, 0.22294891060747768, 0.17565629237176583, 0.28844262802377196, 0.25990398131494497, 0.1670817110705637, 0.2363902947072325, 0.266383773838999, 0.37843377971302794, 0.3882579099949238, 0.49835819582387575, 0.49120559198854696, 0.39066985662445874, 0.20276617052636503, 0.5879758364719305, 0.4222678806886002, 0.4559058958376935, 0.20624200505332613, 0.2513835556810553, 0.2889792194381554, 0.17101541513329288, 0.20337863304380233, 0.24029511101088363, 0.28112999922565973, 0.3022833592315254, 0.26363720597177676, 0.22175432445773724, 0.20956496555561321, 0.2015615840181324, 0.20941093862491422, 0.24084693103415045, 0.20330850731413053, 0.21699349270210533, 0.22908702769005795, 0.20383472554052884, 0.20780529033203177, 0.18612290334129578, 0.20497055498457173, 0.18841879312009235, 0.20541317050044317, 0.22380957642662114, 0.6566384408458958, 0.19555720061233095, 0.2004384786005189, 0.809305845813542, 0.19117092468007035, 0.17501128552938894, 0.8292134131713215, 0.19863445862236884, 0.14721493861892143, 0.8479202113233153, 0.16881017517822205, 0.15228779863496367, 0.7860938295965993, 0.20906771054273843, 0.208590610485495, 0.7655311340083923, 0.1637876080596985, 0.6703397215430402, 0.16741799808185265, 0.20375600901713942, 0.7693791573328046, 0.18041422912256877, 0.18554393580881712, 0.1923539885425709, 0.19241573300542203, 0.20153181191795655, 0.18601856305205489, 0.18666256218705735, 0.21321128841350778, 0.22267571282600007, 0.10047750466725525, 0.09853673272806096, 0.10879062387932359, 0.09752757248830768, 0.09145172192841089, 0.09207897131192189, 0.1020109392983517, 0.10516370555416177, 0.10158449402028003]}, "mutation_prompt": null}
{"id": "23cf9d6f-005a-4917-98cb-8492910f1678", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / (2 * self.budget))))  # Adjusts based on convergence\n\n        return global_best", "name": "HybridDEPSO", "description": "Introduce adaptive crossover rate and enhance exploration by adaptively updating the population size based on convergence.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2dadcdad-01c1-403a-bff9-fed3c1495637", "metadata": {"aucs": [0.8359344413819497, 0.8340020473636771, 0.8177542711523587, 0.8282637876571906, 0.8272468883972396, 0.8296198977328977, 0.8453163689613803, 0.8298710928367996, 0.8086930057290679, 0.6300650824211467, 0.5243839758318625, 0.6480287619233989, 0.6293383597844323, 0.5661979305507592, 0.6327004966143543, 0.6609175176278232, 0.6673560545920878, 0.661990063393395, 0.15047509578713958, 0.12997097041522743, 0.12620484931474307, 0.13756588336602615, 0.14403952733366965, 0.13829661227842793, 0.12631748607174997, 0.14042619794064792, 0.679913523619764, 0.1348929289905143, 0.10025521190385789, 0.08915599729795376, 0.12174548146873587, 0.11203967860189701, 0.14694400466350943, 0.13602685798117276, 0.13293448702184618, 0.12842920639109634, 0.9716577286457261, 0.9704854374227017, 0.9700121311361274, 0.9638062100940954, 0.970532483939913, 0.9629986958369492, 0.9755187178690252, 0.9731786009342139, 0.9677615403300047, 0.7455288209443123, 0.7078318408839777, 0.741965831501826, 0.7247124619072475, 0.7001765537054596, 0.7173970378873546, 0.7250746051997472, 0.7147823537715927, 0.7147702163688576, 0.7753744346780321, 0.8275717282747095, 0.22423005123800555, 0.7713891017561286, 0.3498806077231317, 0.27154681615585263, 0.8244896619222833, 0.8656253127153338, 0.22184002709514916, 0.1888047299915805, 0.2068870084009269, 0.2181633004292346, 0.2171470204039957, 0.2298967387244627, 0.23327798867867033, 0.2251430100614974, 0.27247767217355034, 0.22943578865809489, 0.23894088856678464, 0.12813436811567003, 0.14322705647211265, 0.24789311992593532, 0.22223316206366184, 0.25644521533794795, 0.2634509502082456, 0.25485136381451967, 0.2580310884366892, 9.999999999998899e-05, 0.04905010372085161, 9.999999999998899e-05, 0.031124022545261143, 0.00010009251651721396, 0.0676408433591692, 0.004121327247791462, 9.999999999998899e-05, 0.004048934944478111, 0.07228794955288886, 0.025207162494297886, 0.11613800131198515, 0.08790078192921469, 0.02005366371679207, 0.03177561475707502, 0.05994418904005583, 0.08292395334092795, 0.039132227159612065, 0.14370720647068724, 0.2762296473981354, 0.08342813776121327, 0.30440753749415506, 0.08950069127576898, 0.07175084741362314, 0.15204631577118577, 0.09046531786762813, 0.07377413301538072, 0.07945697552627684, 0.012230241887086546, 0.05535991908341986, 0.052080239077988866, 0.10503265122564753, 0.051718218946512184, 0.05499692758606256, 0.09889989631300689, 0.08879616287047976, 0.5438819781871052, 0.5110996258505001, 0.5191495041697142, 0.6043964776592872, 0.5218077945518597, 0.5449463362848045, 0.5166776003563157, 0.5235545718584635, 0.5348459588109533, 0.12334462956345593, 0.11905734543592084, 0.11164586859489589, 0.14761233292301346, 0.15118319459240448, 0.12378084021430635, 0.11344946489117069, 0.10625827763004525, 0.15321125099271415, 0.4320761069241412, 0.18977157479329887, 0.19707589925971225, 0.18125497301550453, 0.546819752034278, 0.262845079277798, 0.21804021672435703, 0.25130729566914445, 0.27493692654919877, 0.434963732849142, 0.2447878314194475, 0.42366605495937093, 0.3624154900561821, 0.24515391233437878, 0.509189318315969, 0.4747784440328786, 0.599064204963796, 0.5016382629189381, 0.24924558264502628, 0.2227513753457947, 0.31844330218681693, 0.21661929612037334, 0.28215364427950806, 0.17937971738986958, 0.2724742302758967, 0.2821936074996094, 0.3865286833568986, 0.21798135083516523, 0.19487120011017522, 0.19048968797540078, 0.25131863869967397, 0.20654629535368207, 0.24670920302045063, 0.2528520195912729, 0.21373913271831624, 0.22366123873333443, 0.20027263161569753, 0.19435184486011836, 0.24575644051565237, 0.2428266430029996, 0.18869622458558788, 0.24029558511274218, 0.1990906972077413, 0.2069624178148992, 0.2069411061096833, 0.8585304391204805, 0.19903081440561488, 0.175557884161461, 0.8517614084943631, 0.19988195875585013, 0.1474023338286239, 0.8554186405141962, 0.16877962175740036, 0.15182863927668455, 0.8590430079642989, 0.2086836818451, 0.20932073847283683, 0.7646326738132165, 0.1667318044168622, 0.6323639279050162, 0.10473593983250706, 0.10433761070548897, 0.8115552857736175, 0.21676686528365485, 0.19180359724688223, 0.2089852131033031, 0.18852752645090898, 0.22268289320158285, 0.18989238866996794, 0.18067149034823038, 0.18664291255030296, 0.18544688449957825, 0.10580921034004931, 0.09949618103677327, 0.1401773364828448, 0.10077359638428318, 0.08066288948850231, 0.13700198412632214, 0.08353991829714391, 0.09584867712194778, 0.08804462908715271]}, "mutation_prompt": null}
{"id": "8d8ca21a-9a24-4c66-a7f6-bd8423a4445c", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / (2 * self.budget))))  # Adjusts based on convergence\n\n        return global_best", "name": "HybridDEPSO", "description": "Introduce adaptive crossover rate and enhance exploration by adaptively updating the population size based on convergence.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2dadcdad-01c1-403a-bff9-fed3c1495637", "metadata": {"aucs": [0.8359344413819497, 0.8340020473636771, 0.8177542711523587, 0.8282637876571906, 0.8272468883972396, 0.8296198977328977, 0.8453163689613803, 0.8298710928367996, 0.8086930057290679, 0.6300650824211467, 0.5243839758318625, 0.6480287619233989, 0.6293383597844323, 0.5661979305507592, 0.6327004966143543, 0.6609175176278232, 0.6673560545920878, 0.661990063393395, 0.15047509578713958, 0.12997097041522743, 0.12620484931474307, 0.13756588336602615, 0.14403952733366965, 0.13829661227842793, 0.12631748607174997, 0.14042619794064792, 0.679913523619764, 0.1348929289905143, 0.10025521190385789, 0.08915599729795376, 0.12174548146873587, 0.11203967860189701, 0.14694400466350943, 0.13602685798117276, 0.13293448702184618, 0.12842920639109634, 0.9716577286457261, 0.9704854374227017, 0.9700121311361274, 0.9638062100940954, 0.970532483939913, 0.9629986958369492, 0.9755187178690252, 0.9731786009342139, 0.9677615403300047, 0.7455288209443123, 0.7078318408839777, 0.741965831501826, 0.7247124619072475, 0.7001765537054596, 0.7173970378873546, 0.7250746051997472, 0.7147823537715927, 0.7147702163688576, 0.7753744346780321, 0.8275717282747095, 0.22423005123800555, 0.7713891017561286, 0.3498806077231317, 0.27154681615585263, 0.8244896619222833, 0.8656253127153338, 0.22184002709514916, 0.1888047299915805, 0.2068870084009269, 0.2181633004292346, 0.2171470204039957, 0.2298967387244627, 0.23327798867867033, 0.2251430100614974, 0.27247767217355034, 0.22943578865809489, 0.23894088856678464, 0.12813436811567003, 0.14322705647211265, 0.24789311992593532, 0.22223316206366184, 0.25644521533794795, 0.2634509502082456, 0.25485136381451967, 0.2580310884366892, 9.999999999998899e-05, 0.04905010372085161, 9.999999999998899e-05, 0.031124022545261143, 0.00010009251651721396, 0.0676408433591692, 0.004121327247791462, 9.999999999998899e-05, 0.004048934944478111, 0.07228794955288886, 0.025207162494297886, 0.11613800131198515, 0.08790078192921469, 0.02005366371679207, 0.03177561475707502, 0.05994418904005583, 0.08292395334092795, 0.039132227159612065, 0.14370720647068724, 0.2762296473981354, 0.08342813776121327, 0.30440753749415506, 0.08950069127576898, 0.07175084741362314, 0.15204631577118577, 0.09046531786762813, 0.07377413301538072, 0.07945697552627684, 0.012230241887086546, 0.05535991908341986, 0.052080239077988866, 0.10503265122564753, 0.051718218946512184, 0.05499692758606256, 0.09889989631300689, 0.08879616287047976, 0.5438819781871052, 0.5110996258505001, 0.5191495041697142, 0.6043964776592872, 0.5218077945518597, 0.5449463362848045, 0.5166776003563157, 0.5235545718584635, 0.5348459588109533, 0.12334462956345593, 0.11905734543592084, 0.11164586859489589, 0.14761233292301346, 0.15118319459240448, 0.12378084021430635, 0.11344946489117069, 0.10625827763004525, 0.15321125099271415, 0.4320761069241412, 0.18977157479329887, 0.19707589925971225, 0.18125497301550453, 0.546819752034278, 0.262845079277798, 0.21804021672435703, 0.25130729566914445, 0.27493692654919877, 0.434963732849142, 0.2447878314194475, 0.42366605495937093, 0.3624154900561821, 0.24515391233437878, 0.509189318315969, 0.4747784440328786, 0.599064204963796, 0.5016382629189381, 0.24924558264502628, 0.2227513753457947, 0.31844330218681693, 0.21661929612037334, 0.28215364427950806, 0.17937971738986958, 0.2724742302758967, 0.2821936074996094, 0.3865286833568986, 0.21798135083516523, 0.19487120011017522, 0.19048968797540078, 0.25131863869967397, 0.20654629535368207, 0.24670920302045063, 0.2528520195912729, 0.21373913271831624, 0.22366123873333443, 0.20027263161569753, 0.19435184486011836, 0.24575644051565237, 0.2428266430029996, 0.18869622458558788, 0.24029558511274218, 0.1990906972077413, 0.2069624178148992, 0.2069411061096833, 0.8585304391204805, 0.19903081440561488, 0.175557884161461, 0.8517614084943631, 0.19988195875585013, 0.1474023338286239, 0.8554186405141962, 0.16877962175740036, 0.15182863927668455, 0.8590430079642989, 0.2086836818451, 0.20932073847283683, 0.7646326738132165, 0.1667318044168622, 0.6323639279050162, 0.10473593983250706, 0.10433761070548897, 0.8115552857736175, 0.21676686528365485, 0.19180359724688223, 0.2089852131033031, 0.18852752645090898, 0.22268289320158285, 0.18989238866996794, 0.18067149034823038, 0.18664291255030296, 0.18544688449957825, 0.10580921034004931, 0.09949618103677327, 0.1401773364828448, 0.10077359638428318, 0.08066288948850231, 0.13700198412632214, 0.08353991829714391, 0.09584867712194778, 0.08804462908715271]}, "mutation_prompt": null}
{"id": "f568077d-e8e3-4844-8799-6a8953622479", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.reset_probability = 0.1  # New line for reset probability\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                \n                if np.random.rand() < self.reset_probability:  # Implementing reset condition\n                    pop[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Position reset\n\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / (2 * self.budget))))  # Adjusts based on convergence\n\n        return global_best", "name": "HybridDEPSO", "description": "Introduce a diversity preservation mechanism by randomly resetting some particles to explore unvisited areas.", "configspace": "", "generation": 60, "fitness": 0.22957175356023976, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.21.", "error": "", "parent_id": "2dadcdad-01c1-403a-bff9-fed3c1495637", "metadata": {"aucs": [0.4858581836113064, 0.5879058457724906, 0.5801868440609812, 0.6115240108333888, 0.5017292212900875, 0.49897960975267275, 0.5579899937392678, 0.4314414825080507, 0.5823100474789544, 0.10293441832063033, 0.11768128393284294, 0.06698841827687552, 0.262878800458646, 0.0611031450899191, 0.26629744933320976, 0.22037369890670122, 0.22449397128468496, 0.05784270094720212, 0.1256454338852756, 0.11115689608482748, 0.11970149948313902, 0.2674614950053723, 0.1228847536221187, 0.11699739921976438, 0.1448019697877604, 0.11634309415794652, 0.12423174106265356, 0.11628056522826413, 0.08990244750857923, 0.09746549303995544, 0.11518913626330363, 0.09147265356841383, 0.09270168188835304, 0.08682730876878575, 0.09610432575302907, 0.08118290598686129, 0.9723308881177672, 0.9795538009121486, 0.9721402293681217, 0.9574845284948185, 0.965961609437552, 0.9622879310116609, 0.9707257946645913, 0.9644438799913033, 0.9703704094280713, 0.30284183030531153, 0.32427436545007027, 0.3691764207626135, 0.3839587447100301, 0.2900692293733881, 0.22360939057295526, 0.28608694149986413, 0.24756734217007093, 0.3357571444815455, 0.30095995636300055, 0.30863598808552695, 0.36987427283596963, 0.2621874543309187, 0.3337182258875897, 0.2743317436977365, 0.2277613423516215, 0.2921696776271846, 0.22522185117455595, 0.11700657133732162, 0.14266028528790742, 0.04310773899423237, 0.14086849931774637, 0.10860233366511052, 0.1512681312556502, 0.1333910109631341, 0.16357599665893507, 0.13542357240732394, 0.12310908149152588, 0.13105863814741192, 0.10123763074285685, 0.12126561547773929, 0.14751074601351355, 0.10772192984897067, 0.12929314809391856, 0.1274372442807291, 0.22666821060399578, 9.999999999998899e-05, 0.02865852756211773, 9.999999999998899e-05, 0.004786323508128576, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011331364105927388, 0.005900032121924248, 0.11710887640265577, 0.02337290686077509, 0.10042052040800176, 0.08690469037440451, 0.004606919255473629, 0.04623409942485068, 0.06596021111842487, 0.10467710706637723, 0.047776482495703765, 9.999999999998899e-05, 0.039619834565277956, 0.026800438481249356, 0.05624194277376593, 0.03349008840392087, 0.03927989661355846, 0.061764824391885464, 0.053545513095537345, 0.04016925568154461, 0.05743354259352251, 0.028898263274678704, 0.1590506303060738, 0.040956313899881414, 0.03555710592325545, 0.18536053678203046, 0.07524039311262298, 0.11871605881317793, 0.09460349747151053, 0.41532436440665155, 0.41465345214380345, 0.4190964545104173, 0.44041989765170275, 0.4104218167465109, 0.45073205405835715, 0.42439954504226307, 0.3805287173163995, 0.38455647767799594, 0.08290889156497028, 0.11296448469644149, 0.08129338297539312, 0.10250854441181179, 0.11147184562916324, 0.1004852934244631, 0.09987121508153196, 0.09958996911292817, 0.09630665844884256, 0.1758644320944024, 0.17836437044547915, 0.1629938472071084, 0.13858331177593974, 0.19760313509668226, 0.19683907675254264, 0.19789018746587606, 0.1546818151608622, 0.1594377210433986, 0.2474487694087426, 0.29538935901929575, 0.33441572069119807, 0.3476636006901672, 0.22308302404251357, 0.26017634791350275, 0.27297108815070426, 0.29001629361849324, 0.34925238697360594, 0.2253233525170777, 0.24416738423251805, 0.22677543696233304, 0.21271498612064765, 0.1877127456930402, 0.1924289587827307, 0.17677677335424646, 0.25348997903905635, 0.2072039181667864, 0.21423202945062492, 0.20295892161353724, 0.23608196078396093, 0.209381832394548, 0.19726214081203164, 0.2057165950059534, 0.20467159805362012, 0.18639987167526062, 0.21280130788406582, 0.18823906210703167, 0.19678211144532975, 0.20392520018729676, 0.1906688277683165, 0.19495118376594522, 0.19678384227987833, 0.19745084753969255, 0.1920062669999797, 0.19152176185440017, 0.6868685703516462, 0.5013839833788342, 0.18022403740712256, 0.6644501706798561, 0.19247416862674738, 0.1686392629325244, 0.17502900799631715, 0.1693055665097971, 0.1638362741733912, 0.4284900015443375, 0.20468392723650763, 0.4565335504898991, 0.4198582508100107, 0.16394412119265056, 0.17073057329843122, 0.5120310071824117, 0.4496273945364547, 0.4581717452187516, 0.18280275838180482, 0.20032506175429476, 0.1846472722022282, 0.1874207105975263, 0.20481812278147693, 0.1990451632324085, 0.19544443634671627, 0.1849847977789596, 0.1931012566385072, 0.09349079005157257, 0.07855745838028683, 0.08124162663967438, 0.08684643936864811, 0.06889933452920427, 0.10336774691628647, 0.07667431651613277, 0.09557532909149047, 0.090694584804216]}, "mutation_prompt": null}
{"id": "5fcc2708-277a-49ed-8fdb-0a8bf78c55a3", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5) * (1 - evals / self.budget)  # Adjust mutation factor\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / (2 * self.budget))))  # Adjusts based on convergence\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance exploration and exploitation balance by dynamically adjusting the mutation factor based on iteration progress.", "configspace": "", "generation": 61, "fitness": 0.3241089175778124, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.28.", "error": "", "parent_id": "2dadcdad-01c1-403a-bff9-fed3c1495637", "metadata": {"aucs": [0.8281591740925939, 0.8349253743857499, 0.8171754529436224, 0.8180584369560109, 0.8183868146547276, 0.8182383044958436, 0.8258768579236693, 0.8240722093599259, 0.820431124273798, 0.6939581116631182, 0.5353431090222488, 0.6845823662361041, 0.6297873314379561, 0.5549699210966956, 0.6895708802480308, 0.6585852574022477, 0.6878952079358412, 0.6577199364282682, 0.13383601790688737, 0.11566972740855841, 0.12543977290220498, 0.14862161831621068, 0.17188945008470413, 0.11323302636789245, 0.09463438282927361, 0.15234737601992743, 0.13477570288230256, 0.0832269679072215, 0.11654465676576165, 0.08845448837823333, 0.13605865328534306, 0.13092343187410804, 0.13517344505994133, 0.1383944809252453, 0.10961342018691866, 0.08920807160632593, 0.9716527485395167, 0.9704725855270466, 0.9700157680788793, 0.963787200447673, 0.970528477996048, 0.9629979435076007, 0.9755157222453866, 0.9715949569009769, 0.967748246891086, 0.7337200322682356, 0.7315002972373104, 0.7029085549109857, 0.7474045304373986, 0.7386582913965409, 0.7286025900829436, 0.7232310856421489, 0.6840961005666559, 0.693959413736622, 0.22620204320471848, 0.36708207830583783, 0.8103829840664227, 0.8168723407060862, 0.36892638272139167, 0.2716223375695165, 0.3913020273893386, 0.8106654714555601, 0.23301246042458257, 0.11943970642505097, 0.22030576082734588, 0.2214053937353807, 0.27206872221981093, 0.19092591562470007, 0.12678980829910014, 0.2356883212727655, 0.26281964881619335, 0.20640494486567929, 0.12815886977234658, 0.2256496470610757, 0.16336449602114822, 0.23980093186510887, 0.2559737262100855, 0.2369365428611362, 0.240556189920073, 0.24869471329632775, 0.23715137503823303, 9.999999999998899e-05, 0.054651730533852416, 9.999999999998899e-05, 0.04215483387246477, 9.999999999998899e-05, 0.048388803401642644, 0.0009458991976342146, 9.999999999998899e-05, 0.004900977818703689, 0.14442767173559146, 0.03593458388552595, 0.05971976681520641, 0.057542659508908245, 0.0027155781053410655, 0.04383007666375183, 0.05127317818312438, 0.09108305245202863, 0.03823923654184491, 0.044116390142709294, 0.44946543919767, 0.17628454105718505, 0.34127831179737134, 0.09150150913609068, 0.06939541506047553, 0.15402694386658444, 0.09206925869470506, 0.07340344721467607, 0.17483870347376418, 0.03787208420816801, 0.1047959336098444, 0.03292946998974133, 0.11049651141874661, 0.0499777720226009, 0.05504382225029636, 0.1364305469317484, 0.08740442731745024, 0.5757813743720803, 0.5498601201956396, 0.5320345749023907, 0.5231018609737675, 0.5237217595525822, 0.5037921419986413, 0.5596892544977106, 0.5483531945169523, 0.5356575721569954, 0.1409544791889641, 0.1059581789508991, 0.07454984617930682, 0.12160793253506796, 0.1543981861106315, 0.08296665222036192, 0.10404964595464483, 0.12795701922673797, 0.09373958986875752, 0.1824804008915416, 0.2754064947812108, 0.21211711928529398, 0.3372220254456024, 0.35196145205073803, 0.25926166435861053, 0.23171823873876207, 0.24110681372964493, 0.1809053047238689, 0.4456157790427412, 0.2539697368156856, 0.3437368861862785, 0.2729567051196725, 0.30103363256586424, 0.2028558962593836, 0.29806282734651335, 0.2858706928916239, 0.45844353114437686, 0.323177968256139, 0.38729058946173067, 0.3260450414825544, 0.19988981032741526, 0.3032533803431653, 0.3847338894431833, 0.27681941564136725, 0.3417118253811685, 0.23439921825840648, 0.1915045983566186, 0.18137705700229023, 0.20952326993261994, 0.23390058709965555, 0.2359661257311736, 0.22927847723665584, 0.24544369510953845, 0.21851908161219014, 0.2230654527303798, 0.20077457496116402, 0.2063763740599831, 0.221165504360185, 0.19432033974837815, 0.18428601898953922, 0.2221703633212776, 0.6983219603297208, 0.18130046610770423, 0.20820653422636537, 0.8785908442689498, 0.1981942873821828, 0.17515242435973655, 0.861539611177613, 0.19987632738228156, 0.14738017631820344, 0.8396627861996417, 0.16869392924832305, 0.15208727737272765, 0.8546346894789498, 0.20961368916273604, 0.2094140406634215, 0.8556779482101307, 0.166730047054782, 0.5376989478474437, 0.10475537935831292, 0.10433108836738247, 0.8331870131449047, 0.18988277997814662, 0.18832257038227163, 0.1967564295149392, 0.2122294002158307, 0.18795011254989702, 0.19239239423844823, 0.19440040247877355, 0.18180575133682442, 0.21188200093621734, 0.08988658378733527, 0.08661246170533754, 0.12994959653184468, 0.10667093738369693, 0.08926033031461089, 0.18496524315508245, 0.1001812302972116, 0.10280395718631175, 0.0987167797698214]}, "mutation_prompt": null}
{"id": "653116a0-c4aa-4d26-8a62-5d5b31dff811", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / (2 * self.budget))))  # Adjusts based on convergence\n\n        return global_best", "name": "HybridDEPSO", "description": "Introduce adaptive crossover rate and enhance exploration by adaptively updating the population size based on convergence.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2dadcdad-01c1-403a-bff9-fed3c1495637", "metadata": {"aucs": [0.8359344413819497, 0.8340020473636771, 0.8177542711523587, 0.8282637876571906, 0.8272468883972396, 0.8296198977328977, 0.8453163689613803, 0.8298710928367996, 0.8086930057290679, 0.6300650824211467, 0.5243839758318625, 0.6480287619233989, 0.6293383597844323, 0.5661979305507592, 0.6327004966143543, 0.6609175176278232, 0.6673560545920878, 0.661990063393395, 0.15047509578713958, 0.12997097041522743, 0.12620484931474307, 0.13756588336602615, 0.14403952733366965, 0.13829661227842793, 0.12631748607174997, 0.14042619794064792, 0.679913523619764, 0.1348929289905143, 0.10025521190385789, 0.08915599729795376, 0.12174548146873587, 0.11203967860189701, 0.14694400466350943, 0.13602685798117276, 0.13293448702184618, 0.12842920639109634, 0.9716577286457261, 0.9704854374227017, 0.9700121311361274, 0.9638062100940954, 0.970532483939913, 0.9629986958369492, 0.9755187178690252, 0.9731786009342139, 0.9677615403300047, 0.7455288209443123, 0.7078318408839777, 0.741965831501826, 0.7247124619072475, 0.7001765537054596, 0.7173970378873546, 0.7250746051997472, 0.7147823537715927, 0.7147702163688576, 0.7753744346780321, 0.8275717282747095, 0.22423005123800555, 0.7713891017561286, 0.3498806077231317, 0.27154681615585263, 0.8244896619222833, 0.8656253127153338, 0.22184002709514916, 0.1888047299915805, 0.2068870084009269, 0.2181633004292346, 0.2171470204039957, 0.2298967387244627, 0.23327798867867033, 0.2251430100614974, 0.27247767217355034, 0.22943578865809489, 0.23894088856678464, 0.12813436811567003, 0.14322705647211265, 0.24789311992593532, 0.22223316206366184, 0.25644521533794795, 0.2634509502082456, 0.25485136381451967, 0.2580310884366892, 9.999999999998899e-05, 0.04905010372085161, 9.999999999998899e-05, 0.031124022545261143, 0.00010009251651721396, 0.0676408433591692, 0.004121327247791462, 9.999999999998899e-05, 0.004048934944478111, 0.07228794955288886, 0.025207162494297886, 0.11613800131198515, 0.08790078192921469, 0.02005366371679207, 0.03177561475707502, 0.05994418904005583, 0.08292395334092795, 0.039132227159612065, 0.14370720647068724, 0.2762296473981354, 0.08342813776121327, 0.30440753749415506, 0.08950069127576898, 0.07175084741362314, 0.15204631577118577, 0.09046531786762813, 0.07377413301538072, 0.07945697552627684, 0.012230241887086546, 0.05535991908341986, 0.052080239077988866, 0.10503265122564753, 0.051718218946512184, 0.05499692758606256, 0.09889989631300689, 0.08879616287047976, 0.5438819781871052, 0.5110996258505001, 0.5191495041697142, 0.6043964776592872, 0.5218077945518597, 0.5449463362848045, 0.5166776003563157, 0.5235545718584635, 0.5348459588109533, 0.12334462956345593, 0.11905734543592084, 0.11164586859489589, 0.14761233292301346, 0.15118319459240448, 0.12378084021430635, 0.11344946489117069, 0.10625827763004525, 0.15321125099271415, 0.4320761069241412, 0.18977157479329887, 0.19707589925971225, 0.18125497301550453, 0.546819752034278, 0.262845079277798, 0.21804021672435703, 0.25130729566914445, 0.27493692654919877, 0.434963732849142, 0.2447878314194475, 0.42366605495937093, 0.3624154900561821, 0.24515391233437878, 0.509189318315969, 0.4747784440328786, 0.599064204963796, 0.5016382629189381, 0.24924558264502628, 0.2227513753457947, 0.31844330218681693, 0.21661929612037334, 0.28215364427950806, 0.17937971738986958, 0.2724742302758967, 0.2821936074996094, 0.3865286833568986, 0.21798135083516523, 0.19487120011017522, 0.19048968797540078, 0.25131863869967397, 0.20654629535368207, 0.24670920302045063, 0.2528520195912729, 0.21373913271831624, 0.22366123873333443, 0.20027263161569753, 0.19435184486011836, 0.24575644051565237, 0.2428266430029996, 0.18869622458558788, 0.24029558511274218, 0.1990906972077413, 0.2069624178148992, 0.2069411061096833, 0.8585304391204805, 0.19903081440561488, 0.175557884161461, 0.8517614084943631, 0.19988195875585013, 0.1474023338286239, 0.8554186405141962, 0.16877962175740036, 0.15182863927668455, 0.8590430079642989, 0.2086836818451, 0.20932073847283683, 0.7646326738132165, 0.1667318044168622, 0.6323639279050162, 0.10473593983250706, 0.10433761070548897, 0.8115552857736175, 0.21676686528365485, 0.19180359724688223, 0.2089852131033031, 0.18852752645090898, 0.22268289320158285, 0.18989238866996794, 0.18067149034823038, 0.18664291255030296, 0.18544688449957825, 0.10580921034004931, 0.09949618103677327, 0.1401773364828448, 0.10077359638428318, 0.08066288948850231, 0.13700198412632214, 0.08353991829714391, 0.09584867712194778, 0.08804462908715271]}, "mutation_prompt": null}
{"id": "8ce74789-0851-4fb5-8b7f-2eaadc9fb3cb", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            pop_std = np.std(pop, axis=0)\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                \n                dynamic_mutation_factor = np.random.uniform(0.6, 1.2) * np.mean(pop_std)  # Change 1\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                \n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = 0.5 + 0.4 * np.random.rand()  # Change 2\n                dynamic_cognitive_constant = 1.5 + 0.5 * np.random.rand()  # Change 3\n                dynamic_social_constant = 1.5 + 0.5 * np.random.rand()  # Change 4\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / (2 * self.budget))))  # Adjusts based on convergence\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance exploration by introducing an adaptive mutation factor based on diversity and replacing fixed parameters with random adaptive strategies.", "configspace": "", "generation": 63, "fitness": 0.1987612640393698, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.20.", "error": "", "parent_id": "2dadcdad-01c1-403a-bff9-fed3c1495637", "metadata": {"aucs": [0.4501914531099225, 0.4798415488456993, 0.5045813306446201, 0.47168963308996903, 0.18718063993926515, 0.49216272820637486, 0.49146395455572933, 0.1815881782206349, 0.49607298474188377, 0.15920281790878565, 0.08309344236751326, 0.0927273855430516, 0.1418217491071908, 0.17429986204007542, 0.16936994716204334, 0.16456500674132113, 0.08481144621137104, 0.04605826706481597, 0.094076210109165, 0.09986889922120157, 0.10067908958783678, 0.12101253418806224, 0.08984905601380433, 0.12000360637751928, 0.06925035037587968, 0.10001014793207363, 0.11532594320876377, 0.08528399448179114, 0.07650034623184365, 0.0863484380952767, 0.1459246938549269, 0.09014783245741742, 0.11543552638785604, 0.12061808857527101, 0.1146540571003214, 0.09169707528375437, 0.9827757987206756, 0.992512432511432, 0.9860172602912128, 0.9853435825431285, 0.9905328282652668, 0.9838316643321623, 0.9856750509855476, 0.9821598187003527, 0.9840890111993948, 0.2235279445084073, 0.2288157792703268, 0.059064622671213485, 0.2466114816350815, 0.14219250010400797, 0.1434360542455042, 0.23944766711932186, 0.2405635267218943, 0.20388994259536697, 0.1682845894157584, 0.2094650971824631, 0.20622479081179268, 0.18619336121097818, 0.22780450575443334, 0.15413744567133814, 0.2680795916244797, 0.3388917318995951, 0.18940094279390718, 0.15374970629255658, 0.12303832252196134, 0.0988748238961954, 0.07875815040342427, 0.11038714379428494, 0.10797000889930475, 0.13841191582234713, 0.12020119432979959, 0.16439070978135184, 0.13000875527191857, 0.10948044672420965, 0.125220472295965, 0.12475470121254462, 0.09225221617255996, 0.12194424966755957, 0.11588247898875892, 0.10934532124728735, 0.11469714403573072, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.022372026788924804, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0022621331946495182, 9.999999999998899e-05, 0.06649774851915213, 0.04385381219901807, 0.05276391851624562, 0.01151616267688882, 0.01103834542495663, 0.043630384803651556, 0.03761527993348024, 0.07050584092680312, 0.028625169638657688, 0.0016962787758544318, 0.005874233872758983, 0.06833794881486188, 0.025404685913211544, 0.033036914305981324, 0.011860709981382, 0.022050200542483078, 0.03442033965775804, 0.03262272846775882, 0.09213109988042545, 0.033666364707155116, 0.052555242536386326, 0.028532915491501498, 0.08419035475201997, 0.033761551287821545, 0.04659591988595002, 0.05148638496671443, 0.04482930690014442, 0.34764067624169437, 0.4191030476903863, 0.35785111949970816, 0.4040445144508441, 0.35696957286486264, 0.3844174760457185, 0.3676084754329655, 0.38873207971870893, 0.35645322927250267, 0.08849817706944674, 0.08713976655257993, 0.09410808197467524, 0.0878051790160842, 0.08231672610767704, 0.11137636862708389, 0.10283987290525853, 0.08695506343005976, 0.0894040902383274, 0.1712686303628731, 0.14704005249728613, 0.14155131746066696, 0.20957255563860044, 0.14431824562434792, 0.27260566742349635, 0.17653680244291936, 0.18990778437191713, 0.18811558880366674, 0.2034726236019333, 0.2608274455507732, 0.255656856920936, 0.2728388576498154, 0.19109046108248462, 0.28887745845382085, 0.28827055664235224, 0.30103307826572734, 0.2691398128764828, 0.20982445130359828, 0.18047435639469223, 0.21424371077587845, 0.175783885467385, 0.17387637500678754, 0.20323071230695744, 0.20709815936692044, 0.2072813547075576, 0.1836713803138753, 0.17162239218516062, 0.1567998018806649, 0.20301203736697337, 0.19885876154408266, 0.200144015570065, 0.17949794663990593, 0.18072341865962338, 0.19555875363952735, 0.20538660619525395, 0.17022102760176783, 0.19204492723069377, 0.1823180958402787, 0.2045688224086606, 0.17419854901826837, 0.18446569282633107, 0.19887861851502753, 0.1798835205284176, 0.18694786688412635, 0.2613159120116848, 0.16577776421128032, 0.17141770350795982, 0.5984383550177669, 0.19595531890707307, 0.11974112342756615, 0.57676910569826, 0.16373872782260024, 0.20307040473523985, 0.5124597414557617, 0.19437817707324034, 0.3243027401090325, 0.19635182759746483, 0.19511968243220135, 0.15665324552256332, 0.19534814006309265, 0.1451284544595579, 0.3008224111737279, 0.20301414570555776, 0.18768892654548786, 0.18030683596376496, 0.19079432315030875, 0.21610423515978316, 0.18701114438170452, 0.19916440153338788, 0.19484044255202304, 0.17645603999707293, 0.07163044382220563, 0.07677769375862731, 0.09147400679583895, 0.0848281927463489, 0.07968591178239637, 0.08045203139848855, 0.06899086990996062, 0.08705748682731007, 0.08318545977193703]}, "mutation_prompt": null}
{"id": "37f24280-8d2e-4aca-9967-fad5609eb4cb", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                k = np.random.randint(2, self.population_size // 2)  # Changed line for variable neighborhood\n                indices = np.random.choice(self.population_size, k, replace=False)\n                a, b, c = pop[indices[:3]]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - np.sqrt(evals / self.budget))  # Modified line\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / (2 * self.budget))))  # Adjusts based on convergence\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance global exploration by introducing variable neighborhood sizes and improve local exploitation by adjusting inertia weight dynamically.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('not enough values to unpack (expected 3, got 2)').", "error": "ValueError('not enough values to unpack (expected 3, got 2)')", "parent_id": "2dadcdad-01c1-403a-bff9-fed3c1495637", "metadata": {}, "mutation_prompt": null}
{"id": "9b862635-c191-4f50-b762-fa48736fcbf7", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.4, 1.6)  # Line 1: Changed range\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (0.5 + 0.5 * (1 - evals / self.budget))  # Line 2: Enhanced adaptation\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / (2 * self.budget))))  # Adjusts based on convergence\n\n        return global_best", "name": "HybridDEPSO", "description": "Improve convergence by increasing mutation factor variability and enhancing inertia weight adaptation.", "configspace": "", "generation": 65, "fitness": 0.31213540722660904, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "2dadcdad-01c1-403a-bff9-fed3c1495637", "metadata": {"aucs": [0.7982281815332279, 0.7755616542752923, 0.7971213208244927, 0.7898178724773133, 0.8085262381843692, 0.7822339229120147, 0.7773634307485767, 0.8021706889361067, 0.8136738136754151, 0.620597410816386, 0.5504068650052758, 0.5819968433073437, 0.517425007963078, 0.44136029393812326, 0.590170280332732, 0.5903288555440439, 0.5744203315819834, 0.5763692936460267, 0.12037525954952666, 0.10978358107559039, 0.1440649639231817, 0.1517795395653495, 0.13615930559922074, 0.12578150757733275, 0.09155504269007886, 0.1542657712322274, 0.15024096473217108, 0.1375728458069403, 0.14104040394222306, 0.11101518652092168, 0.14863116362589757, 0.1102596639997282, 0.10905014044803707, 0.1444637581898911, 0.10542422655090489, 0.16977020727585457, 0.9717336312788005, 0.9717411045762777, 0.9700696086983988, 0.9638164439340086, 0.9705802152158962, 0.9651276889965444, 0.9755325745183557, 0.972955540951887, 0.967823963361456, 0.6828795595817567, 0.665646557692269, 0.6661874558320727, 0.6489306461189115, 0.670691970558652, 0.6718411391813723, 0.6899924390221593, 0.6641077955295436, 0.6624992439479944, 0.31653239636746855, 0.36966317218270817, 0.22239463474446486, 0.8162163840494115, 0.3488750952136226, 0.1919971111319917, 0.20885371791333884, 0.3861122427956495, 0.23397234855484428, 0.3060331042864617, 0.24089450656285694, 0.24059457422313035, 0.22235757413392276, 0.12614732774492055, 0.23537447693461055, 0.2325978315953775, 0.21386002735564769, 0.24207319463417254, 0.20272660569678136, 0.1287959729370054, 0.1192602141056619, 0.24289311554216086, 0.251786089684388, 0.2741524129248819, 0.25431442117876246, 0.255780186432646, 0.12850606218382055, 0.040485992482806044, 0.0006821731684307775, 9.999999999998899e-05, 0.030570837850295685, 9.999999999998899e-05, 0.01988429614710263, 0.009430986211648396, 9.999999999998899e-05, 0.009333233942381725, 0.14941718471086862, 0.03078291063789551, 0.09391596902499821, 0.07192676910179796, 0.03493454773808313, 0.027560640928486424, 0.06443332796410794, 0.0800494661647414, 0.03950734359563446, 0.15478321608429213, 0.11206670937114271, 0.10626887469820012, 0.16375372751684614, 0.09524519946380627, 0.06614125955994388, 0.15816874360339261, 0.0864116785357193, 0.06728505151815278, 0.3130829906875149, 0.010685104875181595, 0.058609502425867155, 0.017488957274235273, 0.03863865369314157, 0.1157868328445133, 0.16921924993750204, 0.09386731193571796, 0.10116163591846528, 0.4953842506990257, 0.5253774486989806, 0.5321492981427383, 0.5209631347840371, 0.5486631214306756, 0.5503618854809385, 0.5474761082482096, 0.5739561415800583, 0.5160724329934088, 0.1266647424958568, 0.12728132243743695, 0.1167378287117079, 0.10671829417064049, 0.10153094632973148, 0.11935127321527617, 0.10549336793970232, 0.13382901177118967, 0.07369249773394981, 0.16331060563841604, 0.16200985411788738, 0.19497701966800196, 0.2199223886853977, 0.25039048779544504, 0.6914841009983841, 0.23931571923961736, 0.1600861225484863, 0.307494025412678, 0.3682301135167909, 0.4183593028080065, 0.47655090701058467, 0.31336669901355363, 0.3909289784943998, 0.364320012206636, 0.5047633573765178, 0.4549969873236399, 0.3044354607948683, 0.17955703318067295, 0.3784613459414623, 0.2260844417308695, 0.2509998894858916, 0.30042542476065415, 0.28215733107506746, 0.2524075107589263, 0.37468101258041975, 0.22218862091275693, 0.2309249575396749, 0.20912159122464968, 0.20482628672651282, 0.233810747268821, 0.22319268066600584, 0.2304786283224114, 0.23404323352905243, 0.20868934676007445, 0.21040160556529353, 0.21758648814240866, 0.18631247834210163, 0.21782093233937982, 0.19598301923215034, 0.1894503761430124, 0.20591240163512226, 0.20985322581017785, 0.7058962559581354, 0.6859318188194091, 0.18548049089329866, 0.1990339315156019, 0.19884101443889057, 0.85167394218352, 0.19939770780610133, 0.197605362743821, 0.79490409117822, 0.16865979061420566, 0.15140845477549159, 0.7904880071409034, 0.20925719386489583, 0.20994213818122953, 0.2073322324258846, 0.7040341653530068, 0.6572925649707032, 0.10471788996899067, 0.10435216541690695, 0.8087468065163078, 0.20408350475179382, 0.19382739314036668, 0.18756476263720656, 0.19020652338849453, 0.1847492394685315, 0.18662894329028545, 0.18068083206272145, 0.20671064680497309, 0.20784072189199465, 0.10064049601883163, 0.09150605416349011, 0.10876289911391357, 0.10076646386382504, 0.0920231226945396, 0.10314836475100819, 0.09700936936181881, 0.12309669141961399, 0.09918145044532178]}, "mutation_prompt": null}
{"id": "b79b8744-d94f-4a02-bdd7-e3861c43ca65", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            historical_best = np.copy(global_best)  # Keep track of the historical best\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   0.1 * dynamic_social_constant * r2 * (historical_best - pop[i]))  # Historical influence\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / (2 * self.budget))))  # Adjusts based on convergence\n\n        return global_best", "name": "HybridDEPSO", "description": "Introduce learning rates in PSO phase based on historical information to enhance convergence precision.", "configspace": "", "generation": 66, "fitness": 0.28954185820677797, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "2dadcdad-01c1-403a-bff9-fed3c1495637", "metadata": {"aucs": [0.7467298826300852, 0.7280834924400154, 0.749941233789486, 0.7476803645353146, 0.7310724145819156, 0.7298660418632164, 0.7418928521664618, 0.7341426712480799, 0.7403603924801885, 0.5141086900780606, 0.525818442943411, 0.5463282440611342, 0.5227811155625615, 0.5225132083600503, 0.5365227346829228, 0.522673873046392, 0.529409832604425, 0.5153477460150012, 0.11048005857001952, 0.12133087116415264, 0.12362844849411248, 0.12948431547325, 0.11398725872852356, 0.16234355253440103, 0.13191005304393488, 0.11150769314023923, 0.12848785562588272, 0.0887563521942939, 0.12359616977416299, 0.11757342414056315, 0.10187209725842916, 0.12107619864919139, 0.10486961532787842, 0.12419433903047261, 0.11725912836975916, 0.10509789822689763, 0.9463878210858169, 0.9314958561641934, 0.9044330407816097, 0.95734758438533, 0.9304588789454853, 0.9242187396606251, 0.9335831904303821, 0.9352746751774904, 0.9174939927173287, 0.42128479348956205, 0.4569954123497383, 0.3768161513586259, 0.4494648685515683, 0.4251571154703434, 0.4275287139231565, 0.33227445703551706, 0.3546928378784113, 0.3858500956784685, 0.484276029437815, 0.3630464453930654, 0.3762232416729512, 0.5410192641676412, 0.44025552124988654, 0.5433260903323744, 0.3144544199946807, 0.5050316109096996, 0.4059287513928208, 0.22911160396510954, 0.1569652415886259, 0.1683720257976049, 0.23003158923094302, 0.17137399506493545, 0.12098911942550217, 0.15006105942164139, 0.16965617887326334, 0.19784621921766177, 0.16328647742221458, 0.2236613220626853, 0.14408346929164617, 0.14052066492400084, 0.16654453558741333, 0.14281125692643704, 0.13162027965468537, 0.17121225235108417, 0.2266400259894975, 0.0711052072722772, 0.037169038168694324, 0.061807422010955126, 0.07659306182520431, 0.027181458325172936, 0.04430503694216892, 0.07291107370609062, 0.08475162242546408, 0.09180201710904745, 0.15221631031069627, 0.0978425554672474, 0.16624356505504678, 0.09202837518920881, 0.11615207217389378, 0.07096634082865438, 0.11258704279466347, 0.11116294823276263, 0.12374325399095198, 0.10633386704387904, 0.17293321263277195, 0.12738240656394428, 0.06941513039375435, 0.11213359285660551, 0.08770757085318814, 0.058577607536353216, 0.10906231048235948, 0.14443859283712723, 0.23605115218059403, 0.1713504940884948, 0.23460624518598872, 0.14243740282941253, 0.1597698281906833, 0.14467193550837854, 0.20186993437957856, 0.12729118910561243, 0.09355796514773917, 0.5459009184855038, 0.5068617678184417, 0.5522067948146453, 0.4889366200136611, 0.49390849066813347, 0.4873754823213361, 0.5355828649374758, 0.5345260971652751, 0.5383868910287464, 0.11263745615905885, 0.094405634421311, 0.09228178826349975, 0.1474204615020399, 0.10025571258228139, 0.10469470998567454, 0.09346049162767889, 0.09702206741595742, 0.0945708055709259, 0.18011030624860636, 0.16266966480493006, 0.1370839924096252, 0.19902672246145203, 0.16661817995507466, 0.1896133805286343, 0.1603675625493992, 0.15336487782057107, 0.15014744411050873, 0.29526272169071766, 0.28121829391090214, 0.24977231520242937, 0.28008553360206256, 0.28553859898501466, 0.29016136568648143, 0.30210747623864087, 0.3209945372251255, 0.29124487353783135, 0.2108145276689194, 0.2302497099253047, 0.20820409547119512, 0.21113387577241038, 0.20271454409903267, 0.2348492445235153, 0.18636711429205888, 0.23486821918931045, 0.21796897483402622, 0.21926587729830793, 0.2069245596576258, 0.20435492060601423, 0.2153812118481072, 0.2029637753158119, 0.189135773993089, 0.21502900526543844, 0.1986402973037339, 0.22345097550073256, 0.18762625661115473, 0.2659228177066443, 0.1947654065575417, 0.21294297591835465, 0.17868332846326251, 0.19151311135425408, 0.18841408963997164, 0.22757342676305992, 0.18053770221668453, 0.181423424152655, 0.7387083357540021, 0.31137949517108465, 0.7463298465198435, 0.2904954775891956, 0.6529850430862264, 0.16304986895800444, 0.28170512822025406, 0.4538597046682591, 0.691286899273218, 0.4713961562221177, 0.5492925289441575, 0.5109041401809193, 0.2005157122025868, 0.6219453261594411, 0.38297593479073344, 0.3605085926376589, 0.3948819172751027, 0.19797113347379314, 0.18123917334763173, 0.19563987908551606, 0.1858040105823422, 0.19683863352917186, 0.17696315671630347, 0.17536455819222663, 0.1914354084898171, 0.20804391052277282, 0.07869901236969978, 0.08547317834639012, 0.07855405030993756, 0.07398698799047088, 0.08858031285227697, 0.09207091918240717, 0.08108675619126893, 0.08703913422189058, 0.08449458700035084]}, "mutation_prompt": null}
{"id": "8eaf5ea4-d435-4352-90d5-420eda597f05", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n\n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                improvement_factor = np.mean(personal_best_scores) / personal_best_scores[i]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5) * improvement_factor\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget) * improvement_factor\n                dynamic_cognitive_constant = self.cognitive_constant * (0.5 + 0.5 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.5 + 0.5 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            self.population_size = max(20, int(40 * (1 - evals / (2 * self.budget))))  # Adjusts based on convergence\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance diversity and convergence by introducing a dynamic mutation factor and adaptive inertia weight based on fitness improvement.", "configspace": "", "generation": 67, "fitness": 0.26676791991163545, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.27.", "error": "", "parent_id": "2dadcdad-01c1-403a-bff9-fed3c1495637", "metadata": {"aucs": [0.835372032244051, 0.7837119473971775, 0.8353426073462045, 0.8330790932928613, 0.8295529587375017, 0.8163822612080104, 0.8185369030521217, 0.8211448934407672, 0.8232659877263523, 9.999999999998899e-05, 9.999999999998899e-05, 0.05395975431283695, 0.0034207299610403696, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0009849098017739033, 0.14457267672137952, 0.5940244247687875, 0.16434717518193998, 0.1462524480666627, 0.16336554813284387, 0.10894297997817737, 0.15369509027990935, 0.14581554374178596, 0.570303343868264, 0.11266489280526948, 0.1502565344283796, 0.07512140168478343, 0.0870326516923231, 0.10986229122604729, 0.10560891222505941, 0.12878316322342231, 0.1724330734960311, 0.1053213448371011, 0.9778250257445483, 0.9715830127735828, 0.9697806445689535, 0.9639057108982968, 0.9705021877615845, 0.9648183807167868, 0.9760216785802321, 0.9707314916574593, 0.9674227167177177, 0.06274794416174423, 0.08911492765585827, 0.6869441838719482, 0.06880041730593967, 0.26339675937503104, 0.03660746004245685, 0.6280276524421401, 0.09894036901341585, 0.19467977553893367, 0.209423518483978, 0.3664522256839483, 0.16690920760924144, 0.2702778338633428, 0.2347032251040032, 0.15826127283565716, 0.36860392511959694, 0.16740411824759993, 0.2920537566945999, 0.1421526705349626, 0.07882056254993441, 0.06478358026877018, 0.37118426508044067, 0.039444510162519486, 0.17605889209124015, 0.232555494410026, 9.999999999998899e-05, 9.999999999998899e-05, 0.2185230120876428, 0.165559209590188, 0.07228420059495166, 0.18480372887507046, 0.010130293304783433, 0.12612303262416302, 0.15727180961885368, 0.028685895576184173, 0.09276054742276552, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02534819650713782, 0.06875059147860685, 0.00150435461745968, 0.04435884175185478, 0.046281311026854066, 9.999999999998899e-05, 0.00914800203847721, 0.029125409464893726, 9.999999999998899e-05, 0.03762265745142179, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.23684964539574427, 0.011606221742095468, 0.06110917030412655, 0.08504953867769693, 0.22558764936395947, 0.07061145181666417, 0.2597674434267756, 0.05852755017568312, 0.18426909119273527, 0.5325807027737963, 0.5392302527268765, 0.5280117980205323, 0.5157994003440818, 0.5514708290589723, 0.5387635309558187, 0.5793362461501683, 0.5395524433652772, 0.5986516627062133, 0.10570702794352815, 0.10167151611834946, 0.11033740348138432, 0.11313897090091873, 0.14875360563471696, 0.09825776522999241, 0.10914627970992097, 0.08490862232923391, 0.13870105699593482, 0.24607645660228805, 0.3549800053235346, 0.23198372374673104, 0.267332743899536, 0.32431116473012755, 0.27351739527014274, 0.344847241685284, 0.20991240057255334, 0.25971684763713343, 0.4678928687668946, 0.3182233929075855, 0.43331517055243496, 0.5764313316995466, 0.4286447763090059, 0.42967977886076136, 0.5277916301465911, 0.5837501676664911, 0.553166642875609, 0.12588563049140888, 0.25691065355770437, 0.12925919712236578, 0.34857438995010226, 0.21737841424369897, 0.2128193485391049, 0.24516121570185556, 0.2969346475902819, 0.2071473430810512, 0.20205661661549945, 0.22697958073620061, 0.18381504623613365, 0.23485078478494292, 0.21746119218493265, 0.19854872704781856, 0.21048436591138964, 0.21342322079816045, 0.22130857098714551, 0.2107113086966207, 0.15167056087066266, 0.15669063564975116, 0.18262100894420763, 0.21052409276765294, 0.20573642475297627, 0.15901991463946819, 0.15262067993321193, 0.22056516286436412, 0.8740530588724624, 0.1988717925251352, 0.7958240055456296, 0.17489611710130537, 0.18208539222573394, 0.5656773312617358, 0.8298786788296137, 0.1687570029897617, 0.1530308074404847, 0.8183874737855539, 0.21004746456259726, 0.20875472831730868, 0.7662820651979003, 0.16731074759472486, 0.6338804100121062, 0.835769471582523, 0.6932875196646973, 0.8922009591251013, 0.19426345475733575, 0.18034159492634116, 0.190188057195392, 0.21273841863112952, 0.20152587088791896, 0.18410036837676025, 0.1923217565745502, 0.20303154399299306, 0.22414985089245, 0.1068435288684837, 0.13882034952865396, 0.0833905817831313, 0.10577760879659726, 0.0615863817538721, 0.12913648196163774, 0.08892672202081031, 0.08343504136859847, 0.09909064499339781]}, "mutation_prompt": null}
{"id": "6e2a7ff8-2437-4189-a24c-90bfbf3e5251", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n        \n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.7 + 0.3 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.3 + 0.7 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment and restart mechanism\n            if evals % 1000 == 0:  # Restart mechanism\n                pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                pop_velocity = np.zeros_like(pop)\n                personal_best = np.copy(pop)\n                personal_best_scores = np.array([func(ind) for ind in personal_best])\n                evals += self.population_size\n\n            self.population_size = max(20, int(40 * (1 - evals / (2 * self.budget))))  # Adjusts based on convergence\n\n        return global_best", "name": "HybridDEPSO", "description": "Improve convergence by dynamically adjusting cognitive and social constants and applying a restart mechanism.", "configspace": "", "generation": 68, "fitness": 0.33703321848013706, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.27.", "error": "", "parent_id": "2dadcdad-01c1-403a-bff9-fed3c1495637", "metadata": {"aucs": [0.8540053435700363, 0.8446239005009433, 0.8433137197462313, 0.8350982109361492, 0.8321282735121005, 0.849236144878778, 0.8345923313156289, 0.8475649551958029, 0.8398984266380145, 0.6908944447732139, 0.6748835414430687, 0.680518736349941, 0.6897767425189212, 0.6392589876559729, 0.6706836237364475, 0.685650158347709, 0.6837827379391365, 0.6856489491061533, 0.17452639944946569, 0.13651342619404117, 0.6102099223562799, 0.14593772020779472, 0.1742751795310371, 0.17033576450548138, 0.15568341339437497, 0.5194671041759595, 0.1348086415263704, 0.12134898662683369, 0.10307138029128582, 0.14492721456943003, 0.14296388169277985, 0.10261040177991432, 0.13341343739585354, 0.14524005522680294, 0.12665492635242903, 0.13141552793587086, 0.9633836239454582, 0.9704713861294545, 0.9623025443008554, 0.9636691383744607, 0.961582359892674, 0.9617458810469397, 0.9692103469348498, 0.9575932364551011, 0.9634821675761607, 0.7062894815226939, 0.7257079629663544, 0.7365722337048701, 0.7095609935756645, 0.6694645731079703, 0.7241524215388724, 0.70765980105798, 0.7342156257678243, 0.7118692813438237, 0.38730705742758975, 0.22253694890358056, 0.2253577081822491, 0.37085957564102723, 0.2765135280916413, 0.3624278247274526, 0.22732605631855218, 0.23254561975137167, 0.384421936115785, 0.21842093808429397, 0.206791840002145, 0.29223858763009514, 0.12182196030190429, 0.19285803866944684, 0.12965526915705994, 0.24476197461288096, 0.28256847611748726, 0.18754035996166862, 0.2210412767637987, 0.22179200402093557, 0.1982180050628638, 0.20989133817156158, 0.2093323442855538, 0.22725563450479125, 0.23958373547070622, 0.24058957935018943, 0.22551857161267708, 0.08477005784290648, 0.014494010183869421, 9.999999999998899e-05, 0.08984385999339506, 9.999999999998899e-05, 0.02472900155043356, 0.00788445290801465, 9.999999999998899e-05, 0.141824824571403, 0.14934093500953172, 0.06809679487732867, 0.16742357798663066, 0.08026950631928342, 0.07800294285392151, 0.043085510022119355, 0.15136925030245307, 0.0893600771916574, 0.07566788948406078, 0.18226985069938795, 0.15037386562328703, 0.1983192288706369, 0.0775491261454141, 0.12872239746696235, 0.09158046146059495, 0.19957772925512818, 0.13576035824603128, 0.09439685136035436, 0.11465892227374841, 0.06629342928011406, 0.14298679393801828, 0.04422367182408793, 0.12026868663592671, 0.07082511058337881, 0.1023818140327114, 0.20627388841517547, 0.08135602383382834, 0.6095215451153417, 0.5239010867711287, 0.5281336912296635, 0.5566727380058853, 0.6000278243743683, 0.5204247985956874, 0.6370610161648398, 0.5401352562301153, 0.5650313672428267, 0.13771241477647567, 0.5777014548819656, 0.08814308671874027, 0.13328006760332267, 0.1460677963079785, 0.16823810250218285, 0.14748131381111362, 0.11790247159913181, 0.13931041649201248, 0.3304067437117796, 0.17175167290050763, 0.1667504997464997, 0.2703972310320495, 0.22977252003138215, 0.2789654242942531, 0.21291564964739695, 0.22293968146651344, 0.21392604333619847, 0.2814646189524338, 0.43867644914740866, 0.2924712613825332, 0.42331001146177283, 0.3753505123820805, 0.28999691264756366, 0.6809046241001966, 0.5646785722235212, 0.4995545254912902, 0.2936526986874509, 0.25809663696208995, 0.20739096265565782, 0.3099359863203254, 0.30399427040706206, 0.3257826259935993, 0.22783206991526894, 0.3639649974895546, 0.23247189891613884, 0.21882213270107154, 0.21990413537306008, 0.2087416323445892, 0.21529223106038775, 0.2472130956536499, 0.23781510781713, 0.2393442302547899, 0.21283374666344756, 0.2627801097412127, 0.20135047829989394, 0.23687316929044422, 0.20839754031053526, 0.7476343343056103, 0.2114259834883142, 0.20945720190941552, 0.20858124984282045, 0.2449425944040956, 0.21687694108880073, 0.8889690399875826, 0.1856130721729613, 0.17313141123634546, 0.9001068190780968, 0.19973513845309376, 0.8766438351381951, 0.8298364646118694, 0.8123001475704195, 0.15247655770399848, 0.7645605884431432, 0.20887985573634182, 0.11173104282889834, 0.7007510596283757, 0.16610855461701213, 0.15531219012888464, 0.1044235161911995, 0.20739958772113054, 0.841758324773506, 0.1976594736326498, 0.20242653153582502, 0.17112098820264054, 0.20019641947623112, 0.22680987553157705, 0.1956056522725338, 0.1780018772542027, 0.21083464720164602, 0.1866443018931937, 0.08522368511852352, 0.09068547562243345, 0.08669960537714338, 0.09497740685756928, 0.08373196113994019, 0.09068219873196903, 0.09001935382820248, 0.10302510606419635, 0.08535320107412592]}, "mutation_prompt": null}
{"id": "9df13afa-f8fb-4cb6-99de-b2ef1b94f195", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n        \n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.7 + 0.3 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.3 + 0.7 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment and restart mechanism\n            if evals % 1000 == 0:  # Restart mechanism\n                pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                pop_velocity = np.zeros_like(pop)\n                personal_best = np.copy(pop)\n                personal_best_scores = np.array([func(ind) for ind in personal_best])\n                evals += self.population_size\n\n            self.population_size = max(20, int(40 * (1 - evals / (2 * self.budget))))  # Adjusts based on convergence\n\n        return global_best", "name": "HybridDEPSO", "description": "Improve convergence by dynamically adjusting cognitive and social constants and applying a restart mechanism.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6e2a7ff8-2437-4189-a24c-90bfbf3e5251", "metadata": {"aucs": [0.8540053435700363, 0.8446239005009433, 0.8433137197462313, 0.8350982109361492, 0.8321282735121005, 0.849236144878778, 0.8345923313156289, 0.8475649551958029, 0.8398984266380145, 0.6908944447732139, 0.6748835414430687, 0.680518736349941, 0.6897767425189212, 0.6392589876559729, 0.6706836237364475, 0.685650158347709, 0.6837827379391365, 0.6856489491061533, 0.17452639944946569, 0.13651342619404117, 0.6102099223562799, 0.14593772020779472, 0.1742751795310371, 0.17033576450548138, 0.15568341339437497, 0.5194671041759595, 0.1348086415263704, 0.12134898662683369, 0.10307138029128582, 0.14492721456943003, 0.14296388169277985, 0.10261040177991432, 0.13341343739585354, 0.14524005522680294, 0.12665492635242903, 0.13141552793587086, 0.9633836239454582, 0.9704713861294545, 0.9623025443008554, 0.9636691383744607, 0.961582359892674, 0.9617458810469397, 0.9692103469348498, 0.9575932364551011, 0.9634821675761607, 0.7062894815226939, 0.7257079629663544, 0.7365722337048701, 0.7095609935756645, 0.6694645731079703, 0.7241524215388724, 0.70765980105798, 0.7342156257678243, 0.7118692813438237, 0.38730705742758975, 0.22253694890358056, 0.2253577081822491, 0.37085957564102723, 0.2765135280916413, 0.3624278247274526, 0.22732605631855218, 0.23254561975137167, 0.384421936115785, 0.21842093808429397, 0.206791840002145, 0.29223858763009514, 0.12182196030190429, 0.19285803866944684, 0.12965526915705994, 0.24476197461288096, 0.28256847611748726, 0.18754035996166862, 0.2210412767637987, 0.22179200402093557, 0.1982180050628638, 0.20989133817156158, 0.2093323442855538, 0.22725563450479125, 0.23958373547070622, 0.24058957935018943, 0.22551857161267708, 0.08477005784290648, 0.014494010183869421, 9.999999999998899e-05, 0.08984385999339506, 9.999999999998899e-05, 0.02472900155043356, 0.00788445290801465, 9.999999999998899e-05, 0.141824824571403, 0.14934093500953172, 0.06809679487732867, 0.16742357798663066, 0.08026950631928342, 0.07800294285392151, 0.043085510022119355, 0.15136925030245307, 0.0893600771916574, 0.07566788948406078, 0.18226985069938795, 0.15037386562328703, 0.1983192288706369, 0.0775491261454141, 0.12872239746696235, 0.09158046146059495, 0.19957772925512818, 0.13576035824603128, 0.09439685136035436, 0.11465892227374841, 0.06629342928011406, 0.14298679393801828, 0.04422367182408793, 0.12026868663592671, 0.07082511058337881, 0.1023818140327114, 0.20627388841517547, 0.08135602383382834, 0.6095215451153417, 0.5239010867711287, 0.5281336912296635, 0.5566727380058853, 0.6000278243743683, 0.5204247985956874, 0.6370610161648398, 0.5401352562301153, 0.5650313672428267, 0.13771241477647567, 0.5777014548819656, 0.08814308671874027, 0.13328006760332267, 0.1460677963079785, 0.16823810250218285, 0.14748131381111362, 0.11790247159913181, 0.13931041649201248, 0.3304067437117796, 0.17175167290050763, 0.1667504997464997, 0.2703972310320495, 0.22977252003138215, 0.2789654242942531, 0.21291564964739695, 0.22293968146651344, 0.21392604333619847, 0.2814646189524338, 0.43867644914740866, 0.2924712613825332, 0.42331001146177283, 0.3753505123820805, 0.28999691264756366, 0.6809046241001966, 0.5646785722235212, 0.4995545254912902, 0.2936526986874509, 0.25809663696208995, 0.20739096265565782, 0.3099359863203254, 0.30399427040706206, 0.3257826259935993, 0.22783206991526894, 0.3639649974895546, 0.23247189891613884, 0.21882213270107154, 0.21990413537306008, 0.2087416323445892, 0.21529223106038775, 0.2472130956536499, 0.23781510781713, 0.2393442302547899, 0.21283374666344756, 0.2627801097412127, 0.20135047829989394, 0.23687316929044422, 0.20839754031053526, 0.7476343343056103, 0.2114259834883142, 0.20945720190941552, 0.20858124984282045, 0.2449425944040956, 0.21687694108880073, 0.8889690399875826, 0.1856130721729613, 0.17313141123634546, 0.9001068190780968, 0.19973513845309376, 0.8766438351381951, 0.8298364646118694, 0.8123001475704195, 0.15247655770399848, 0.7645605884431432, 0.20887985573634182, 0.11173104282889834, 0.7007510596283757, 0.16610855461701213, 0.15531219012888464, 0.1044235161911995, 0.20739958772113054, 0.841758324773506, 0.1976594736326498, 0.20242653153582502, 0.17112098820264054, 0.20019641947623112, 0.22680987553157705, 0.1956056522725338, 0.1780018772542027, 0.21083464720164602, 0.1866443018931937, 0.08522368511852352, 0.09068547562243345, 0.08669960537714338, 0.09497740685756928, 0.08373196113994019, 0.09068219873196903, 0.09001935382820248, 0.10302510606419635, 0.08535320107412592]}, "mutation_prompt": null}
{"id": "54adcfd4-9862-4295-94da-7bcbd3dc14fa", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n        \n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.7 + 0.3 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.3 + 0.7 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment and restart mechanism\n            if evals % 1000 == 0:  # Restart mechanism\n                pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                pop_velocity = np.zeros_like(pop)\n                personal_best = np.copy(pop)\n                personal_best_scores = np.array([func(ind) for ind in personal_best])\n                evals += self.population_size\n\n            self.population_size = max(20, int(40 * (1 - evals / (2 * self.budget))))  # Adjusts based on convergence\n\n        return global_best", "name": "HybridDEPSO", "description": "Improve convergence by dynamically adjusting cognitive and social constants and applying a restart mechanism.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6e2a7ff8-2437-4189-a24c-90bfbf3e5251", "metadata": {"aucs": [0.8540053435700363, 0.8446239005009433, 0.8433137197462313, 0.8350982109361492, 0.8321282735121005, 0.849236144878778, 0.8345923313156289, 0.8475649551958029, 0.8398984266380145, 0.6908944447732139, 0.6748835414430687, 0.680518736349941, 0.6897767425189212, 0.6392589876559729, 0.6706836237364475, 0.685650158347709, 0.6837827379391365, 0.6856489491061533, 0.17452639944946569, 0.13651342619404117, 0.6102099223562799, 0.14593772020779472, 0.1742751795310371, 0.17033576450548138, 0.15568341339437497, 0.5194671041759595, 0.1348086415263704, 0.12134898662683369, 0.10307138029128582, 0.14492721456943003, 0.14296388169277985, 0.10261040177991432, 0.13341343739585354, 0.14524005522680294, 0.12665492635242903, 0.13141552793587086, 0.9633836239454582, 0.9704713861294545, 0.9623025443008554, 0.9636691383744607, 0.961582359892674, 0.9617458810469397, 0.9692103469348498, 0.9575932364551011, 0.9634821675761607, 0.7062894815226939, 0.7257079629663544, 0.7365722337048701, 0.7095609935756645, 0.6694645731079703, 0.7241524215388724, 0.70765980105798, 0.7342156257678243, 0.7118692813438237, 0.38730705742758975, 0.22253694890358056, 0.2253577081822491, 0.37085957564102723, 0.2765135280916413, 0.3624278247274526, 0.22732605631855218, 0.23254561975137167, 0.384421936115785, 0.21842093808429397, 0.206791840002145, 0.29223858763009514, 0.12182196030190429, 0.19285803866944684, 0.12965526915705994, 0.24476197461288096, 0.28256847611748726, 0.18754035996166862, 0.2210412767637987, 0.22179200402093557, 0.1982180050628638, 0.20989133817156158, 0.2093323442855538, 0.22725563450479125, 0.23958373547070622, 0.24058957935018943, 0.22551857161267708, 0.08477005784290648, 0.014494010183869421, 9.999999999998899e-05, 0.08984385999339506, 9.999999999998899e-05, 0.02472900155043356, 0.00788445290801465, 9.999999999998899e-05, 0.141824824571403, 0.14934093500953172, 0.06809679487732867, 0.16742357798663066, 0.08026950631928342, 0.07800294285392151, 0.043085510022119355, 0.15136925030245307, 0.0893600771916574, 0.07566788948406078, 0.18226985069938795, 0.15037386562328703, 0.1983192288706369, 0.0775491261454141, 0.12872239746696235, 0.09158046146059495, 0.19957772925512818, 0.13576035824603128, 0.09439685136035436, 0.11465892227374841, 0.06629342928011406, 0.14298679393801828, 0.04422367182408793, 0.12026868663592671, 0.07082511058337881, 0.1023818140327114, 0.20627388841517547, 0.08135602383382834, 0.6095215451153417, 0.5239010867711287, 0.5281336912296635, 0.5566727380058853, 0.6000278243743683, 0.5204247985956874, 0.6370610161648398, 0.5401352562301153, 0.5650313672428267, 0.13771241477647567, 0.5777014548819656, 0.08814308671874027, 0.13328006760332267, 0.1460677963079785, 0.16823810250218285, 0.14748131381111362, 0.11790247159913181, 0.13931041649201248, 0.3304067437117796, 0.17175167290050763, 0.1667504997464997, 0.2703972310320495, 0.22977252003138215, 0.2789654242942531, 0.21291564964739695, 0.22293968146651344, 0.21392604333619847, 0.2814646189524338, 0.43867644914740866, 0.2924712613825332, 0.42331001146177283, 0.3753505123820805, 0.28999691264756366, 0.6809046241001966, 0.5646785722235212, 0.4995545254912902, 0.2936526986874509, 0.25809663696208995, 0.20739096265565782, 0.3099359863203254, 0.30399427040706206, 0.3257826259935993, 0.22783206991526894, 0.3639649974895546, 0.23247189891613884, 0.21882213270107154, 0.21990413537306008, 0.2087416323445892, 0.21529223106038775, 0.2472130956536499, 0.23781510781713, 0.2393442302547899, 0.21283374666344756, 0.2627801097412127, 0.20135047829989394, 0.23687316929044422, 0.20839754031053526, 0.7476343343056103, 0.2114259834883142, 0.20945720190941552, 0.20858124984282045, 0.2449425944040956, 0.21687694108880073, 0.8889690399875826, 0.1856130721729613, 0.17313141123634546, 0.9001068190780968, 0.19973513845309376, 0.8766438351381951, 0.8298364646118694, 0.8123001475704195, 0.15247655770399848, 0.7645605884431432, 0.20887985573634182, 0.11173104282889834, 0.7007510596283757, 0.16610855461701213, 0.15531219012888464, 0.1044235161911995, 0.20739958772113054, 0.841758324773506, 0.1976594736326498, 0.20242653153582502, 0.17112098820264054, 0.20019641947623112, 0.22680987553157705, 0.1956056522725338, 0.1780018772542027, 0.21083464720164602, 0.1866443018931937, 0.08522368511852352, 0.09068547562243345, 0.08669960537714338, 0.09497740685756928, 0.08373196113994019, 0.09068219873196903, 0.09001935382820248, 0.10302510606419635, 0.08535320107412592]}, "mutation_prompt": null}
{"id": "e9135e70-8801-4789-a878-4bf2917e1837", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n        \n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.7 + 0.3 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.3 + 0.7 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment and restart mechanism\n            if evals % 1000 == 0 or np.std(personal_best_scores) < 1e-5:  # Fitness diversity-based restart\n                pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                pop_velocity = np.zeros_like(pop)\n                personal_best = np.copy(pop)\n                personal_best_scores = np.array([func(ind) for ind in personal_best])\n                evals += self.population_size\n\n            self.population_size = max(20, int(40 * (1 - evals / (2 * self.budget))))  # Adjusts based on convergence\n\n        return global_best", "name": "HybridDEPSO", "description": "Integrate a fitness diversity-based restart mechanism to enhance exploration.", "configspace": "", "generation": 71, "fitness": 0.33703321848013706, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.27.", "error": "", "parent_id": "6e2a7ff8-2437-4189-a24c-90bfbf3e5251", "metadata": {"aucs": [0.8540053435700363, 0.8446239005009433, 0.8433137197462313, 0.8350982109361492, 0.8321282735121005, 0.849236144878778, 0.8345923313156289, 0.8475649551958029, 0.8398984266380145, 0.6908944447732139, 0.6748835414430687, 0.680518736349941, 0.6897767425189212, 0.6392589876559729, 0.6706836237364475, 0.685650158347709, 0.6837827379391365, 0.6856489491061533, 0.17452639944946569, 0.13651342619404117, 0.6102099223562799, 0.14593772020779472, 0.1742751795310371, 0.17033576450548138, 0.15568341339437497, 0.5194671041759595, 0.1348086415263704, 0.12134898662683369, 0.10307138029128582, 0.14492721456943003, 0.14296388169277985, 0.10261040177991432, 0.13341343739585354, 0.14524005522680294, 0.12665492635242903, 0.13141552793587086, 0.9633836239454582, 0.9704713861294545, 0.9623025443008554, 0.9636691383744607, 0.961582359892674, 0.9617458810469397, 0.9692103469348498, 0.9575932364551011, 0.9634821675761607, 0.7062894815226939, 0.7257079629663544, 0.7365722337048701, 0.7095609935756645, 0.6694645731079703, 0.7241524215388724, 0.70765980105798, 0.7342156257678243, 0.7118692813438237, 0.38730705742758975, 0.22253694890358056, 0.2253577081822491, 0.37085957564102723, 0.2765135280916413, 0.3624278247274526, 0.22732605631855218, 0.23254561975137167, 0.384421936115785, 0.21842093808429397, 0.206791840002145, 0.29223858763009514, 0.12182196030190429, 0.19285803866944684, 0.12965526915705994, 0.24476197461288096, 0.28256847611748726, 0.18754035996166862, 0.2210412767637987, 0.22179200402093557, 0.1982180050628638, 0.20989133817156158, 0.2093323442855538, 0.22725563450479125, 0.23958373547070622, 0.24058957935018943, 0.22551857161267708, 0.08477005784290648, 0.014494010183869421, 9.999999999998899e-05, 0.08984385999339506, 9.999999999998899e-05, 0.02472900155043356, 0.00788445290801465, 9.999999999998899e-05, 0.141824824571403, 0.14934093500953172, 0.06809679487732867, 0.16742357798663066, 0.08026950631928342, 0.07800294285392151, 0.043085510022119355, 0.15136925030245307, 0.0893600771916574, 0.07566788948406078, 0.18226985069938795, 0.15037386562328703, 0.1983192288706369, 0.0775491261454141, 0.12872239746696235, 0.09158046146059495, 0.19957772925512818, 0.13576035824603128, 0.09439685136035436, 0.11465892227374841, 0.06629342928011406, 0.14298679393801828, 0.04422367182408793, 0.12026868663592671, 0.07082511058337881, 0.1023818140327114, 0.20627388841517547, 0.08135602383382834, 0.6095215451153417, 0.5239010867711287, 0.5281336912296635, 0.5566727380058853, 0.6000278243743683, 0.5204247985956874, 0.6370610161648398, 0.5401352562301153, 0.5650313672428267, 0.13771241477647567, 0.5777014548819656, 0.08814308671874027, 0.13328006760332267, 0.1460677963079785, 0.16823810250218285, 0.14748131381111362, 0.11790247159913181, 0.13931041649201248, 0.3304067437117796, 0.17175167290050763, 0.1667504997464997, 0.2703972310320495, 0.22977252003138215, 0.2789654242942531, 0.21291564964739695, 0.22293968146651344, 0.21392604333619847, 0.2814646189524338, 0.43867644914740866, 0.2924712613825332, 0.42331001146177283, 0.3753505123820805, 0.28999691264756366, 0.6809046241001966, 0.5646785722235212, 0.4995545254912902, 0.2936526986874509, 0.25809663696208995, 0.20739096265565782, 0.3099359863203254, 0.30399427040706206, 0.3257826259935993, 0.22783206991526894, 0.3639649974895546, 0.23247189891613884, 0.21882213270107154, 0.21990413537306008, 0.2087416323445892, 0.21529223106038775, 0.2472130956536499, 0.23781510781713, 0.2393442302547899, 0.21283374666344756, 0.2627801097412127, 0.20135047829989394, 0.23687316929044422, 0.20839754031053526, 0.7476343343056103, 0.2114259834883142, 0.20945720190941552, 0.20858124984282045, 0.2449425944040956, 0.21687694108880073, 0.8889690399875826, 0.1856130721729613, 0.17313141123634546, 0.9001068190780968, 0.19973513845309376, 0.8766438351381951, 0.8298364646118694, 0.8123001475704195, 0.15247655770399848, 0.7645605884431432, 0.20887985573634182, 0.11173104282889834, 0.7007510596283757, 0.16610855461701213, 0.15531219012888464, 0.1044235161911995, 0.20739958772113054, 0.841758324773506, 0.1976594736326498, 0.20242653153582502, 0.17112098820264054, 0.20019641947623112, 0.22680987553157705, 0.1956056522725338, 0.1780018772542027, 0.21083464720164602, 0.1866443018931937, 0.08522368511852352, 0.09068547562243345, 0.08669960537714338, 0.09497740685756928, 0.08373196113994019, 0.09068219873196903, 0.09001935382820248, 0.10302510606419635, 0.08535320107412592]}, "mutation_prompt": null}
{"id": "db550278-7c77-4d93-9e98-d1874ab1456f", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n        \n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5) * (1 - global_best_score / self.budget)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.7 + 0.3 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.3 + 0.7 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment and restart mechanism\n            if evals % 1000 == 0:  # Restart mechanism\n                pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                pop_velocity = np.zeros_like(pop)\n                personal_best = np.copy(pop)\n                personal_best_scores = np.array([func(ind) for ind in personal_best])\n                evals += self.population_size\n\n            self.population_size = max(20, int(40 * (1 - evals / (2 * self.budget))))  # Adjusts based on convergence\n\n        return global_best", "name": "HybridDEPSO", "description": "Introduce a dynamic mutation factor influenced by both the budget and the best score to enhance exploration and exploitation balance.", "configspace": "", "generation": 72, "fitness": 0.33434717367694167, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.27.", "error": "", "parent_id": "6e2a7ff8-2437-4189-a24c-90bfbf3e5251", "metadata": {"aucs": [0.8459654395653834, 0.836697165181103, 0.8519784263727388, 0.8510227152689644, 0.8314971850247932, 0.8470931288877641, 0.8259686624556948, 0.8397005331315681, 0.8259121819995738, 0.6848465163925945, 0.6842142293821138, 0.6473754450392758, 0.683376721718558, 0.6526914292811667, 0.7124369468159732, 0.658893506856878, 0.659811168722277, 0.7152434748160565, 0.1608109600513955, 0.16718692463379226, 0.17852817525667997, 0.159528077436224, 0.5161531816686795, 0.14267322553076733, 0.16442882096708222, 0.4825986991440806, 0.6361204528409503, 0.17342914728964565, 0.13937575561406412, 0.13962551519872302, 0.14915055117901066, 0.10823033281146033, 0.12399149965489653, 0.1335548448934869, 0.13635442621416605, 0.14081922499693733, 0.9633816915055781, 0.9704684949219452, 0.9623059091054948, 0.9635321238603859, 0.9616077639609886, 0.9617478534059661, 0.9692481678661813, 0.9631356510529796, 0.9634813167865269, 0.7323884283562043, 0.700956287409926, 0.6951437499112305, 0.7489087294972042, 0.703250033160336, 0.7292739355233101, 0.7102060224048097, 0.67322965335324, 0.7015332976439945, 0.3670612186115553, 0.2252574765511386, 0.22279954972765204, 0.8676790557095957, 0.8387925063737887, 0.27237771278551104, 0.308792251992852, 0.23249165966687058, 0.8367581722476576, 0.1743407261694092, 0.19345039680716614, 0.19979286434857502, 0.1230155374081151, 0.1989175481453489, 0.17973323354779314, 0.19788035962800354, 0.18058887689238, 0.1880827378695541, 0.13132925518730898, 0.22356066601931468, 0.19385493013333965, 0.21169780054529663, 0.2168095983075946, 0.2023382324997246, 0.2516482577772997, 0.20129027073541805, 0.21975320389097242, 0.026471113802063573, 0.0026598742504096995, 9.999999999998899e-05, 0.05830238031668855, 9.999999999998899e-05, 9.999999999998899e-05, 0.0023685380675586565, 9.999999999998899e-05, 0.10629728626993584, 0.12865963316209184, 0.10875739577495058, 0.1382411031497831, 0.12714596206403717, 0.04423497981944924, 0.05694626249281243, 0.10688422166915112, 0.18466843621431372, 0.17564345672595538, 0.08724634624445882, 0.12526823001367282, 0.2052075431829875, 0.10296944829986443, 0.10433539095901123, 0.07097789054917902, 0.1887436901342785, 0.09625845576599223, 0.11387482408964766, 0.29031029862918734, 0.06269162307505394, 0.19852006503349418, 0.03092823668620881, 0.06217975175790069, 0.08726484153523184, 0.18964089392259886, 0.22219813058454607, 0.0812353100840375, 0.5343320089523094, 0.4944158177409754, 0.5287736489478424, 0.5784577318620849, 0.496788246979152, 0.5790077383432618, 0.5652313313586275, 0.569741483004595, 0.5473713563381898, 0.13156329599280925, 0.13874851982946823, 0.1309922740371705, 0.12444020802853428, 0.1669471216977768, 0.13456225204737216, 0.10087193857720034, 0.12727244524882753, 0.11837368451530705, 0.20669521699177307, 0.188820078317666, 0.1729315451672777, 0.22298239210232318, 0.3170045306618051, 0.3562198780663177, 0.21190620900638935, 0.16012644514245133, 0.1470370469013278, 0.2585273951359418, 0.3751029714712979, 0.43816954558345234, 0.4693592175982422, 0.34400102004944033, 0.3725589246570138, 0.3897388398581676, 0.39385337907031737, 0.6109021014763603, 0.2968169878185889, 0.24819352399928063, 0.2147303459350307, 0.290756502805786, 0.30019790493115606, 0.24090324197288715, 0.2284590533838916, 0.26465593730758363, 0.36620372772688536, 0.2341669906471483, 0.2131105405314222, 0.21630064905779234, 0.29850170538728593, 0.24022363708381556, 0.22590535620710095, 0.24712399732002177, 0.20862228600014276, 0.24676342202919532, 0.19307707200735547, 0.18730227344040906, 0.20737872723570805, 0.2095672532312738, 0.20636706020986006, 0.1898752963617747, 0.23367461307028092, 0.2379980061324718, 0.18085313680521353, 0.8845407455742518, 0.1856001056126685, 0.17314200938184, 0.898172146410383, 0.19968799611299293, 0.8816088059837702, 0.8690194246094106, 0.15176851269312008, 0.16040978829454489, 0.7226292845005158, 0.21135399879622685, 0.20692914463990386, 0.6233928658930616, 0.1662504545588528, 0.1493486646604042, 0.10438723611939915, 0.20727388526047885, 0.8385759598353231, 0.24008927863857255, 0.19411228887816823, 0.20572506044298378, 0.20019640492202784, 0.2030800332279763, 0.20344889503379848, 0.18826358238658691, 0.18110632944672778, 0.17853849421131185, 0.08864938438025949, 0.08498330026024725, 0.10283019112043346, 0.10039891273134749, 0.08500541743901047, 0.08842325161509523, 0.08852024109526213, 0.09928758905460033, 0.09197322507281391]}, "mutation_prompt": null}
{"id": "327bae6a-37bf-4b6f-bcbc-8dfddbbe88c7", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.6  # Adjusted from 0.8\n        self.inertia_weight = 0.9  # Adjusted from 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n        \n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (0.6 - 0.5 * evals / self.budget)  # Adjusted from (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.7 + 0.3 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.3 + 0.7 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment and restart mechanism\n            if evals % 1000 == 0:  # Restart mechanism\n                pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                pop_velocity = np.zeros_like(pop)\n                personal_best = np.copy(pop)\n                personal_best_scores = np.array([func(ind) for ind in personal_best])\n                evals += self.population_size\n\n            self.population_size = max(20, int(40 * (1 - evals / (2 * self.budget))))  # Adjusts based on convergence\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance exploration and exploitation balance by fine-tuning mutation factor and inertia weight scheduling.", "configspace": "", "generation": 73, "fitness": 0.33099522061936376, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "6e2a7ff8-2437-4189-a24c-90bfbf3e5251", "metadata": {"aucs": [0.8839785443171722, 0.8802542286715368, 0.881224663416363, 0.8798930774608681, 0.8772161223461139, 0.8745026658537929, 0.8751614519768136, 0.880696908249915, 0.8837341977001164, 0.7474502741467579, 0.7627984698960176, 0.7501273997869521, 0.7403356819464774, 0.6985413969421037, 0.7595322130010067, 0.7096914845900872, 0.7520363137634254, 0.7471258334761437, 0.17441649060638098, 0.11923408443586614, 0.17276652642588064, 0.14667213001561685, 0.10500577025120306, 0.11836605794274024, 0.13829122568529617, 0.12140778041348621, 0.18043465897784294, 0.1255655278804807, 0.08422130224949365, 0.12104750285417809, 0.12895885924631179, 0.1129149687800205, 0.11285284155851694, 0.08001541694401859, 0.17538452869000865, 0.10734286886642241, 0.9512037601622124, 0.958766062929721, 0.9546800436447742, 0.9378583525932435, 0.9566562709031465, 0.9316357105995463, 0.9683968118592661, 0.9624550814652573, 0.9616379504003881, 0.6768617226087088, 0.7370662643390957, 0.7609313335153751, 0.7550116380853376, 0.2939129715112586, 0.7754160010386821, 0.752022791759322, 0.746525496057193, 0.7346688878399494, 0.8366050718360245, 0.22391856487950612, 0.7707759053443135, 0.37462514365628463, 0.352249495225476, 0.19124511013024426, 0.17540322100452155, 0.234848698014827, 0.3509506172233874, 0.33426938836912834, 0.17334652421560204, 0.1802505184706915, 0.10400902315873883, 0.1323252283905867, 0.1702473920181643, 0.1690290082042193, 0.12749249945551167, 0.18068166496410065, 0.16430002881140426, 0.22929032769269153, 0.13002618930105803, 0.19300320424766282, 0.13524001502748362, 0.13237087020558935, 0.23292234290377556, 0.15942125640982652, 0.2237593856143144, 0.05209602870434593, 9.999999999998899e-05, 0.1073405294639369, 0.04979789766692233, 9.999999999998899e-05, 0.02658100917461448, 0.00817651977144307, 0.011273614719546465, 0.013212365134833481, 0.08622182770961573, 0.08165603070549898, 0.1594919275711285, 0.06633131271267434, 0.033547758720133936, 0.06013717660568185, 0.2935388985367109, 0.1711959611297289, 0.07768258231203307, 0.05938853729649418, 0.21287928033145564, 0.2233022660449272, 0.07640797715478598, 0.1921417914703919, 0.18992757507406033, 0.15115147384195937, 0.1448296899279201, 0.08811643430523486, 0.10100242041280982, 0.05058202749778762, 0.1842565136514207, 0.037038357764752616, 0.10073578561273477, 0.2989499295006093, 0.2995222674249902, 0.08348258169013756, 0.08654309601772547, 0.5689559289023474, 0.5717043202400199, 0.5246780241609965, 0.6494012956816437, 0.5178979812279635, 0.5689519014433089, 0.5851467294795494, 0.6118351672464877, 0.6090371456107746, 0.09107198758816559, 0.12915877975016177, 0.15197524585683808, 0.10857120284246158, 0.10811052914283503, 0.13456566590796426, 0.08668460453936677, 0.12025502166418156, 0.13931689918072476, 0.29144529265662145, 0.19636697508449374, 0.19632839919564715, 0.1914361381025419, 0.17535025857577324, 0.21253351198220327, 0.2491287011089487, 0.2805733443040477, 0.3088179404719502, 0.3443957524672945, 0.255526024112227, 0.3925097248607329, 0.2929591687838562, 0.3475961507640213, 0.4036163836468659, 0.5129965966139953, 0.44746735975921004, 0.47114498748399647, 0.21394029780598667, 0.22187781775152426, 0.3431750374028367, 0.2538644829589374, 0.28820473675445724, 0.32107527497328203, 0.3187953503479568, 0.22729853619456786, 0.2589207846126006, 0.23273204041439144, 0.24330516553563752, 0.23448247404600964, 0.2503186912066677, 0.2317791540729066, 0.2650122680531788, 0.22375631603334423, 0.27242457699101663, 0.23490266821859385, 0.20548151437477657, 0.8028788989958895, 0.1938234820925855, 0.19651689964236851, 0.20870379731043986, 0.20533391484972519, 0.1929450521880537, 0.21104822873193907, 0.2064888339742914, 0.18557593489228152, 0.18558397951255146, 0.18761231158727665, 0.9295966591491394, 0.19993953522240615, 0.19846832798488434, 0.1765974592238705, 0.6794182000729134, 0.16052112402269558, 0.5821620249928863, 0.63681670190246, 0.8793678619230288, 0.8908346984689847, 0.5974075672663071, 0.15081662863118617, 0.35951361224316525, 0.10401283658839389, 0.6070449389584376, 0.1973675693948599, 0.19728415301177182, 0.19262253472057078, 0.18697125201475429, 0.20148310512635037, 0.20613724402987832, 0.18436243508703787, 0.17957450722763046, 0.1979247845626717, 0.09832564175640013, 0.09090416579032246, 0.08826152807503862, 0.09865886792562828, 0.0930111021897535, 0.10115321225040097, 0.10066280090165858, 0.08801662924706288, 0.08810552074162425]}, "mutation_prompt": null}
{"id": "d01a5de0-640c-4a99-b752-b5f53eee6a0d", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n        \n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.7 + 0.3 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.3 + 0.7 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment and restart mechanism\n            if evals % 1000 == 0:  # Restart mechanism\n                pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                pop_velocity = np.zeros_like(pop)\n                personal_best = np.copy(pop)\n                personal_best_scores = np.array([func(ind) for ind in personal_best])\n                evals += self.population_size\n\n            self.population_size = max(20, int(40 * (1 - evals / (2 * self.budget))))  # Adjusts based on convergence\n\n        return global_best", "name": "HybridDEPSO", "description": "Improve convergence by dynamically adjusting cognitive and social constants and applying a restart mechanism.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6e2a7ff8-2437-4189-a24c-90bfbf3e5251", "metadata": {"aucs": [0.8540053435700363, 0.8446239005009433, 0.8433137197462313, 0.8350982109361492, 0.8321282735121005, 0.849236144878778, 0.8345923313156289, 0.8475649551958029, 0.8398984266380145, 0.6908944447732139, 0.6748835414430687, 0.680518736349941, 0.6897767425189212, 0.6392589876559729, 0.6706836237364475, 0.685650158347709, 0.6837827379391365, 0.6856489491061533, 0.17452639944946569, 0.13651342619404117, 0.6102099223562799, 0.14593772020779472, 0.1742751795310371, 0.17033576450548138, 0.15568341339437497, 0.5194671041759595, 0.1348086415263704, 0.12134898662683369, 0.10307138029128582, 0.14492721456943003, 0.14296388169277985, 0.10261040177991432, 0.13341343739585354, 0.14524005522680294, 0.12665492635242903, 0.13141552793587086, 0.9633836239454582, 0.9704713861294545, 0.9623025443008554, 0.9636691383744607, 0.961582359892674, 0.9617458810469397, 0.9692103469348498, 0.9575932364551011, 0.9634821675761607, 0.7062894815226939, 0.7257079629663544, 0.7365722337048701, 0.7095609935756645, 0.6694645731079703, 0.7241524215388724, 0.70765980105798, 0.7342156257678243, 0.7118692813438237, 0.38730705742758975, 0.22253694890358056, 0.2253577081822491, 0.37085957564102723, 0.2765135280916413, 0.3624278247274526, 0.22732605631855218, 0.23254561975137167, 0.384421936115785, 0.21842093808429397, 0.206791840002145, 0.29223858763009514, 0.12182196030190429, 0.19285803866944684, 0.12965526915705994, 0.24476197461288096, 0.28256847611748726, 0.18754035996166862, 0.2210412767637987, 0.22179200402093557, 0.1982180050628638, 0.20989133817156158, 0.2093323442855538, 0.22725563450479125, 0.23958373547070622, 0.24058957935018943, 0.22551857161267708, 0.08477005784290648, 0.014494010183869421, 9.999999999998899e-05, 0.08984385999339506, 9.999999999998899e-05, 0.02472900155043356, 0.00788445290801465, 9.999999999998899e-05, 0.141824824571403, 0.14934093500953172, 0.06809679487732867, 0.16742357798663066, 0.08026950631928342, 0.07800294285392151, 0.043085510022119355, 0.15136925030245307, 0.0893600771916574, 0.07566788948406078, 0.18226985069938795, 0.15037386562328703, 0.1983192288706369, 0.0775491261454141, 0.12872239746696235, 0.09158046146059495, 0.19957772925512818, 0.13576035824603128, 0.09439685136035436, 0.11465892227374841, 0.06629342928011406, 0.14298679393801828, 0.04422367182408793, 0.12026868663592671, 0.07082511058337881, 0.1023818140327114, 0.20627388841517547, 0.08135602383382834, 0.6095215451153417, 0.5239010867711287, 0.5281336912296635, 0.5566727380058853, 0.6000278243743683, 0.5204247985956874, 0.6370610161648398, 0.5401352562301153, 0.5650313672428267, 0.13771241477647567, 0.5777014548819656, 0.08814308671874027, 0.13328006760332267, 0.1460677963079785, 0.16823810250218285, 0.14748131381111362, 0.11790247159913181, 0.13931041649201248, 0.3304067437117796, 0.17175167290050763, 0.1667504997464997, 0.2703972310320495, 0.22977252003138215, 0.2789654242942531, 0.21291564964739695, 0.22293968146651344, 0.21392604333619847, 0.2814646189524338, 0.43867644914740866, 0.2924712613825332, 0.42331001146177283, 0.3753505123820805, 0.28999691264756366, 0.6809046241001966, 0.5646785722235212, 0.4995545254912902, 0.2936526986874509, 0.25809663696208995, 0.20739096265565782, 0.3099359863203254, 0.30399427040706206, 0.3257826259935993, 0.22783206991526894, 0.3639649974895546, 0.23247189891613884, 0.21882213270107154, 0.21990413537306008, 0.2087416323445892, 0.21529223106038775, 0.2472130956536499, 0.23781510781713, 0.2393442302547899, 0.21283374666344756, 0.2627801097412127, 0.20135047829989394, 0.23687316929044422, 0.20839754031053526, 0.7476343343056103, 0.2114259834883142, 0.20945720190941552, 0.20858124984282045, 0.2449425944040956, 0.21687694108880073, 0.8889690399875826, 0.1856130721729613, 0.17313141123634546, 0.9001068190780968, 0.19973513845309376, 0.8766438351381951, 0.8298364646118694, 0.8123001475704195, 0.15247655770399848, 0.7645605884431432, 0.20887985573634182, 0.11173104282889834, 0.7007510596283757, 0.16610855461701213, 0.15531219012888464, 0.1044235161911995, 0.20739958772113054, 0.841758324773506, 0.1976594736326498, 0.20242653153582502, 0.17112098820264054, 0.20019641947623112, 0.22680987553157705, 0.1956056522725338, 0.1780018772542027, 0.21083464720164602, 0.1866443018931937, 0.08522368511852352, 0.09068547562243345, 0.08669960537714338, 0.09497740685756928, 0.08373196113994019, 0.09068219873196903, 0.09001935382820248, 0.10302510606419635, 0.08535320107412592]}, "mutation_prompt": null}
{"id": "4833180b-5f7f-42cf-95fe-89a5dd3a08d9", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n        \n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * np.exp(-evals / self.budget)  # Changed scaling\n                dynamic_cognitive_constant = self.cognitive_constant * (0.7 + 0.3 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.3 + 0.7 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment and restart mechanism\n            if evals % int(1000 * (1 - global_best_score / 10)) == 0:  # Dynamic restart threshold\n                pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                pop_velocity = np.zeros_like(pop)\n                personal_best = np.copy(pop)\n                personal_best_scores = np.array([func(ind) for ind in personal_best])\n                evals += self.population_size\n\n            self.population_size = max(20, int(40 * (1 - evals / (2 * self.budget))))  # Adjusts based on convergence\n\n        return global_best", "name": "HybridDEPSO", "description": "Introduce a dynamic restart threshold and adjust inertia weight scaling for improved global exploration.", "configspace": "", "generation": 75, "fitness": 0.3359315903564346, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.27.", "error": "", "parent_id": "6e2a7ff8-2437-4189-a24c-90bfbf3e5251", "metadata": {"aucs": [0.8578220088070014, 0.8410624944287102, 0.841225166743313, 0.821149322738906, 0.8273588187093235, 0.8408673258603125, 0.8260611296005869, 0.8429243766435038, 0.8361396089525202, 0.6675786801881118, 0.6789281066544883, 0.6597072223821958, 0.6629777345258533, 0.5994043975782752, 0.6715514103972171, 0.6775728610119649, 0.6680280312922608, 0.691496472018829, 0.15237015006863652, 0.14625500285377513, 0.1637652707112056, 0.15733052505659728, 0.17399190538221787, 0.15392968097775395, 0.39631833068793676, 0.146664952509451, 0.16896369046796467, 0.15033373404972394, 0.10518269291874371, 0.14250266424686975, 0.14554654281025525, 0.10476270594814419, 0.1270621540848471, 0.14062491764311635, 0.13791194108492566, 0.13843016645122075, 0.9633844538933745, 0.9704717679149215, 0.962303309873157, 0.9636698614428127, 0.9615832214505637, 0.9617462312696115, 0.9692109907551575, 0.9576021125517858, 0.9634851189779579, 0.6764676739088469, 0.7064846699635046, 0.7071561621185805, 0.7226252941648572, 0.7069465524830231, 0.7000861962884465, 0.7032930371470774, 0.7104745195054751, 0.6986152714903627, 0.38595559955672876, 0.223177130689155, 0.7652599147076158, 0.8503833824849731, 0.27647221791233956, 0.26750645921609506, 0.17015571351435732, 0.23254561975137167, 0.3639430651484117, 0.23651244035993024, 0.2263509839302611, 0.2609748266493722, 0.12360782216053545, 0.21215199100119542, 0.13015067565694605, 0.26149411306241854, 0.2895748636584241, 0.23050233078959959, 0.2417232416619205, 0.23386054874963225, 0.22111817814415213, 0.2644515680844389, 0.24850368512470022, 0.24633493071676604, 0.2522627555924053, 0.24577223668818693, 0.23886576898337075, 0.04817291858233497, 0.007355562980142727, 9.999999999998899e-05, 0.04635363910893975, 9.999999999998899e-05, 0.013204492178411797, 0.008699660141022303, 9.999999999998899e-05, 0.1062561428096962, 0.12814883780608977, 0.05595113947330499, 0.18582660039061139, 0.0840329132644867, 0.07602078484298092, 0.0640705861002645, 0.15456918493636862, 0.1101258768053327, 0.08382194660554121, 0.19348330602800456, 0.15253652307767684, 0.20958801530884463, 0.0712817726704621, 0.1292708510725068, 0.08813672238467929, 0.1941626283209672, 0.12560914665369982, 0.09633386912823771, 0.1057830246839847, 0.07018686195460666, 0.06823686640545545, 0.026328866326349232, 0.06203313180095915, 0.08875121821653065, 0.1044391947927481, 0.22453221486543218, 0.08130667643949596, 0.5378934524056005, 0.539087457097764, 0.5172658433607898, 0.5435362628090901, 0.5520860389094511, 0.51101022437253, 0.5879180075294097, 0.574997559925053, 0.544340267460798, 0.12740812457619, 0.1646424981973319, 0.08835720260723834, 0.1699061517895174, 0.14729526037080343, 0.16824935278669817, 0.11552315114549894, 0.1321468350608881, 0.14335514155957185, 0.3429437636503705, 0.1942323967686188, 0.15654804928354404, 0.15390603350945153, 0.26654770028245256, 0.26964696555952616, 0.2128974885245758, 0.2417375876589507, 0.2415411068089881, 0.31477181421866307, 0.3930672440076399, 0.49563517275467994, 0.4048588097396646, 0.36380472986075385, 0.2972982120967048, 0.5472203565317976, 0.6566253955784118, 0.44218074406256846, 0.3482881556683297, 0.2776666987663077, 0.26991166430379177, 0.29776585704248926, 0.2976654813709785, 0.33721708549680385, 0.19130342598439787, 0.4479514708992357, 0.23807821523363593, 0.2213505468024375, 0.20663117013293053, 0.20920197410333774, 0.23565931120253902, 0.23382266275445351, 0.21611603166114257, 0.21436364315023815, 0.2291096740771612, 0.24874559535403318, 0.19405640810365343, 0.21754430492053967, 0.2187955750857784, 0.2470555548133745, 0.21210020398732754, 0.20906143078079953, 0.2178277304975601, 0.2430949851983275, 0.6570117231112017, 0.8834074822436903, 0.1856007421735839, 0.1721593773299479, 0.8988835856883701, 0.19971884584105615, 0.8738224465659431, 0.8146043494702804, 0.8119445268414887, 0.15247157990420224, 0.8414589378769332, 0.2088917055219074, 0.11173040256990574, 0.6866287103631786, 0.16610518745606317, 0.15531870580081408, 0.10442224420278923, 0.20734612886929893, 0.8581536569986125, 0.18854373565378368, 0.22201980924893316, 0.19371034182803082, 0.20019641947623112, 0.20195082178455215, 0.2052327203702169, 0.18842404608724939, 0.19879865604432012, 0.18083500248300677, 0.09322866136867325, 0.08420377324659845, 0.0848387614836047, 0.09031284497819547, 0.0926489365381592, 0.08266427256885522, 0.08759692265085328, 0.10756566961390057, 0.0939726406444934]}, "mutation_prompt": null}
{"id": "4a94ae68-add7-4973-b591-07d3be48ca09", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n        \n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.7 + 0.3 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.3 + 0.7 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment and restart mechanism\n            if evals % 1000 == 0:  # Restart mechanism\n                pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                pop_velocity = np.zeros_like(pop)\n                personal_best = np.copy(pop)\n                personal_best_scores = np.array([func(ind) for ind in personal_best])\n                evals += self.population_size\n\n            self.population_size = max(20, int(40 * (1 - evals / (2 * self.budget))))  # Adjusts based on convergence\n\n        return global_best", "name": "HybridDEPSO", "description": "Improve convergence by dynamically adjusting cognitive and social constants and applying a restart mechanism.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6e2a7ff8-2437-4189-a24c-90bfbf3e5251", "metadata": {"aucs": [0.8540053435700363, 0.8446239005009433, 0.8433137197462313, 0.8350982109361492, 0.8321282735121005, 0.849236144878778, 0.8345923313156289, 0.8475649551958029, 0.8398984266380145, 0.6908944447732139, 0.6748835414430687, 0.680518736349941, 0.6897767425189212, 0.6392589876559729, 0.6706836237364475, 0.685650158347709, 0.6837827379391365, 0.6856489491061533, 0.17452639944946569, 0.13651342619404117, 0.6102099223562799, 0.14593772020779472, 0.1742751795310371, 0.17033576450548138, 0.15568341339437497, 0.5194671041759595, 0.1348086415263704, 0.12134898662683369, 0.10307138029128582, 0.14492721456943003, 0.14296388169277985, 0.10261040177991432, 0.13341343739585354, 0.14524005522680294, 0.12665492635242903, 0.13141552793587086, 0.9633836239454582, 0.9704713861294545, 0.9623025443008554, 0.9636691383744607, 0.961582359892674, 0.9617458810469397, 0.9692103469348498, 0.9575932364551011, 0.9634821675761607, 0.7062894815226939, 0.7257079629663544, 0.7365722337048701, 0.7095609935756645, 0.6694645731079703, 0.7241524215388724, 0.70765980105798, 0.7342156257678243, 0.7118692813438237, 0.38730705742758975, 0.22253694890358056, 0.2253577081822491, 0.37085957564102723, 0.2765135280916413, 0.3624278247274526, 0.22732605631855218, 0.23254561975137167, 0.384421936115785, 0.21842093808429397, 0.206791840002145, 0.29223858763009514, 0.12182196030190429, 0.19285803866944684, 0.12965526915705994, 0.24476197461288096, 0.28256847611748726, 0.18754035996166862, 0.2210412767637987, 0.22179200402093557, 0.1982180050628638, 0.20989133817156158, 0.2093323442855538, 0.22725563450479125, 0.23958373547070622, 0.24058957935018943, 0.22551857161267708, 0.08477005784290648, 0.014494010183869421, 9.999999999998899e-05, 0.08984385999339506, 9.999999999998899e-05, 0.02472900155043356, 0.00788445290801465, 9.999999999998899e-05, 0.141824824571403, 0.14934093500953172, 0.06809679487732867, 0.16742357798663066, 0.08026950631928342, 0.07800294285392151, 0.043085510022119355, 0.15136925030245307, 0.0893600771916574, 0.07566788948406078, 0.18226985069938795, 0.15037386562328703, 0.1983192288706369, 0.0775491261454141, 0.12872239746696235, 0.09158046146059495, 0.19957772925512818, 0.13576035824603128, 0.09439685136035436, 0.11465892227374841, 0.06629342928011406, 0.14298679393801828, 0.04422367182408793, 0.12026868663592671, 0.07082511058337881, 0.1023818140327114, 0.20627388841517547, 0.08135602383382834, 0.6095215451153417, 0.5239010867711287, 0.5281336912296635, 0.5566727380058853, 0.6000278243743683, 0.5204247985956874, 0.6370610161648398, 0.5401352562301153, 0.5650313672428267, 0.13771241477647567, 0.5777014548819656, 0.08814308671874027, 0.13328006760332267, 0.1460677963079785, 0.16823810250218285, 0.14748131381111362, 0.11790247159913181, 0.13931041649201248, 0.3304067437117796, 0.17175167290050763, 0.1667504997464997, 0.2703972310320495, 0.22977252003138215, 0.2789654242942531, 0.21291564964739695, 0.22293968146651344, 0.21392604333619847, 0.2814646189524338, 0.43867644914740866, 0.2924712613825332, 0.42331001146177283, 0.3753505123820805, 0.28999691264756366, 0.6809046241001966, 0.5646785722235212, 0.4995545254912902, 0.2936526986874509, 0.25809663696208995, 0.20739096265565782, 0.3099359863203254, 0.30399427040706206, 0.3257826259935993, 0.22783206991526894, 0.3639649974895546, 0.23247189891613884, 0.21882213270107154, 0.21990413537306008, 0.2087416323445892, 0.21529223106038775, 0.2472130956536499, 0.23781510781713, 0.2393442302547899, 0.21283374666344756, 0.2627801097412127, 0.20135047829989394, 0.23687316929044422, 0.20839754031053526, 0.7476343343056103, 0.2114259834883142, 0.20945720190941552, 0.20858124984282045, 0.2449425944040956, 0.21687694108880073, 0.8889690399875826, 0.1856130721729613, 0.17313141123634546, 0.9001068190780968, 0.19973513845309376, 0.8766438351381951, 0.8298364646118694, 0.8123001475704195, 0.15247655770399848, 0.7645605884431432, 0.20887985573634182, 0.11173104282889834, 0.7007510596283757, 0.16610855461701213, 0.15531219012888464, 0.1044235161911995, 0.20739958772113054, 0.841758324773506, 0.1976594736326498, 0.20242653153582502, 0.17112098820264054, 0.20019641947623112, 0.22680987553157705, 0.1956056522725338, 0.1780018772542027, 0.21083464720164602, 0.1866443018931937, 0.08522368511852352, 0.09068547562243345, 0.08669960537714338, 0.09497740685756928, 0.08373196113994019, 0.09068219873196903, 0.09001935382820248, 0.10302510606419635, 0.08535320107412592]}, "mutation_prompt": null}
{"id": "b37275b0-37a9-4941-91a6-d884cc7e3236", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n        \n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.7 + 0.3 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.3 + 0.7 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment and restart mechanism\n            if evals % 1000 == 0:  # Restart mechanism\n                pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                pop_velocity = np.zeros_like(pop)\n                personal_best = np.copy(pop)\n                personal_best_scores = np.array([func(ind) for ind in personal_best])\n                evals += self.population_size\n\n            self.population_size = max(20, int(40 * (1 - evals / (2 * self.budget))))  # Adjusts based on convergence\n\n        return global_best", "name": "HybridDEPSO", "description": "Improve convergence by dynamically adjusting cognitive and social constants and applying a restart mechanism.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6e2a7ff8-2437-4189-a24c-90bfbf3e5251", "metadata": {"aucs": [0.8540053435700363, 0.8446239005009433, 0.8433137197462313, 0.8350982109361492, 0.8321282735121005, 0.849236144878778, 0.8345923313156289, 0.8475649551958029, 0.8398984266380145, 0.6908944447732139, 0.6748835414430687, 0.680518736349941, 0.6897767425189212, 0.6392589876559729, 0.6706836237364475, 0.685650158347709, 0.6837827379391365, 0.6856489491061533, 0.17452639944946569, 0.13651342619404117, 0.6102099223562799, 0.14593772020779472, 0.1742751795310371, 0.17033576450548138, 0.15568341339437497, 0.5194671041759595, 0.1348086415263704, 0.12134898662683369, 0.10307138029128582, 0.14492721456943003, 0.14296388169277985, 0.10261040177991432, 0.13341343739585354, 0.14524005522680294, 0.12665492635242903, 0.13141552793587086, 0.9633836239454582, 0.9704713861294545, 0.9623025443008554, 0.9636691383744607, 0.961582359892674, 0.9617458810469397, 0.9692103469348498, 0.9575932364551011, 0.9634821675761607, 0.7062894815226939, 0.7257079629663544, 0.7365722337048701, 0.7095609935756645, 0.6694645731079703, 0.7241524215388724, 0.70765980105798, 0.7342156257678243, 0.7118692813438237, 0.38730705742758975, 0.22253694890358056, 0.2253577081822491, 0.37085957564102723, 0.2765135280916413, 0.3624278247274526, 0.22732605631855218, 0.23254561975137167, 0.384421936115785, 0.21842093808429397, 0.206791840002145, 0.29223858763009514, 0.12182196030190429, 0.19285803866944684, 0.12965526915705994, 0.24476197461288096, 0.28256847611748726, 0.18754035996166862, 0.2210412767637987, 0.22179200402093557, 0.1982180050628638, 0.20989133817156158, 0.2093323442855538, 0.22725563450479125, 0.23958373547070622, 0.24058957935018943, 0.22551857161267708, 0.08477005784290648, 0.014494010183869421, 9.999999999998899e-05, 0.08984385999339506, 9.999999999998899e-05, 0.02472900155043356, 0.00788445290801465, 9.999999999998899e-05, 0.141824824571403, 0.14934093500953172, 0.06809679487732867, 0.16742357798663066, 0.08026950631928342, 0.07800294285392151, 0.043085510022119355, 0.15136925030245307, 0.0893600771916574, 0.07566788948406078, 0.18226985069938795, 0.15037386562328703, 0.1983192288706369, 0.0775491261454141, 0.12872239746696235, 0.09158046146059495, 0.19957772925512818, 0.13576035824603128, 0.09439685136035436, 0.11465892227374841, 0.06629342928011406, 0.14298679393801828, 0.04422367182408793, 0.12026868663592671, 0.07082511058337881, 0.1023818140327114, 0.20627388841517547, 0.08135602383382834, 0.6095215451153417, 0.5239010867711287, 0.5281336912296635, 0.5566727380058853, 0.6000278243743683, 0.5204247985956874, 0.6370610161648398, 0.5401352562301153, 0.5650313672428267, 0.13771241477647567, 0.5777014548819656, 0.08814308671874027, 0.13328006760332267, 0.1460677963079785, 0.16823810250218285, 0.14748131381111362, 0.11790247159913181, 0.13931041649201248, 0.3304067437117796, 0.17175167290050763, 0.1667504997464997, 0.2703972310320495, 0.22977252003138215, 0.2789654242942531, 0.21291564964739695, 0.22293968146651344, 0.21392604333619847, 0.2814646189524338, 0.43867644914740866, 0.2924712613825332, 0.42331001146177283, 0.3753505123820805, 0.28999691264756366, 0.6809046241001966, 0.5646785722235212, 0.4995545254912902, 0.2936526986874509, 0.25809663696208995, 0.20739096265565782, 0.3099359863203254, 0.30399427040706206, 0.3257826259935993, 0.22783206991526894, 0.3639649974895546, 0.23247189891613884, 0.21882213270107154, 0.21990413537306008, 0.2087416323445892, 0.21529223106038775, 0.2472130956536499, 0.23781510781713, 0.2393442302547899, 0.21283374666344756, 0.2627801097412127, 0.20135047829989394, 0.23687316929044422, 0.20839754031053526, 0.7476343343056103, 0.2114259834883142, 0.20945720190941552, 0.20858124984282045, 0.2449425944040956, 0.21687694108880073, 0.8889690399875826, 0.1856130721729613, 0.17313141123634546, 0.9001068190780968, 0.19973513845309376, 0.8766438351381951, 0.8298364646118694, 0.8123001475704195, 0.15247655770399848, 0.7645605884431432, 0.20887985573634182, 0.11173104282889834, 0.7007510596283757, 0.16610855461701213, 0.15531219012888464, 0.1044235161911995, 0.20739958772113054, 0.841758324773506, 0.1976594736326498, 0.20242653153582502, 0.17112098820264054, 0.20019641947623112, 0.22680987553157705, 0.1956056522725338, 0.1780018772542027, 0.21083464720164602, 0.1866443018931937, 0.08522368511852352, 0.09068547562243345, 0.08669960537714338, 0.09497740685756928, 0.08373196113994019, 0.09068219873196903, 0.09001935382820248, 0.10302510606419635, 0.08535320107412592]}, "mutation_prompt": null}
{"id": "dbe34bb9-e570-46c0-9544-87edcc0914f0", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n        \n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.7 + 0.3 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.3 + 0.7 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment and restart mechanism\n            if evals % 1000 == 0:  # Restart mechanism\n                pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                pop_velocity = np.zeros_like(pop)\n                personal_best = np.copy(pop)\n                personal_best_scores = np.array([func(ind) for ind in personal_best])\n                evals += self.population_size\n\n            self.population_size = max(20, int(40 * (1 - evals / (2 * self.budget))))  # Adjusts based on convergence\n\n        return global_best", "name": "HybridDEPSO", "description": "Improve convergence by dynamically adjusting cognitive and social constants and applying a restart mechanism.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6e2a7ff8-2437-4189-a24c-90bfbf3e5251", "metadata": {"aucs": [0.8540053435700363, 0.8446239005009433, 0.8433137197462313, 0.8350982109361492, 0.8321282735121005, 0.849236144878778, 0.8345923313156289, 0.8475649551958029, 0.8398984266380145, 0.6908944447732139, 0.6748835414430687, 0.680518736349941, 0.6897767425189212, 0.6392589876559729, 0.6706836237364475, 0.685650158347709, 0.6837827379391365, 0.6856489491061533, 0.17452639944946569, 0.13651342619404117, 0.6102099223562799, 0.14593772020779472, 0.1742751795310371, 0.17033576450548138, 0.15568341339437497, 0.5194671041759595, 0.1348086415263704, 0.12134898662683369, 0.10307138029128582, 0.14492721456943003, 0.14296388169277985, 0.10261040177991432, 0.13341343739585354, 0.14524005522680294, 0.12665492635242903, 0.13141552793587086, 0.9633836239454582, 0.9704713861294545, 0.9623025443008554, 0.9636691383744607, 0.961582359892674, 0.9617458810469397, 0.9692103469348498, 0.9575932364551011, 0.9634821675761607, 0.7062894815226939, 0.7257079629663544, 0.7365722337048701, 0.7095609935756645, 0.6694645731079703, 0.7241524215388724, 0.70765980105798, 0.7342156257678243, 0.7118692813438237, 0.38730705742758975, 0.22253694890358056, 0.2253577081822491, 0.37085957564102723, 0.2765135280916413, 0.3624278247274526, 0.22732605631855218, 0.23254561975137167, 0.384421936115785, 0.21842093808429397, 0.206791840002145, 0.29223858763009514, 0.12182196030190429, 0.19285803866944684, 0.12965526915705994, 0.24476197461288096, 0.28256847611748726, 0.18754035996166862, 0.2210412767637987, 0.22179200402093557, 0.1982180050628638, 0.20989133817156158, 0.2093323442855538, 0.22725563450479125, 0.23958373547070622, 0.24058957935018943, 0.22551857161267708, 0.08477005784290648, 0.014494010183869421, 9.999999999998899e-05, 0.08984385999339506, 9.999999999998899e-05, 0.02472900155043356, 0.00788445290801465, 9.999999999998899e-05, 0.141824824571403, 0.14934093500953172, 0.06809679487732867, 0.16742357798663066, 0.08026950631928342, 0.07800294285392151, 0.043085510022119355, 0.15136925030245307, 0.0893600771916574, 0.07566788948406078, 0.18226985069938795, 0.15037386562328703, 0.1983192288706369, 0.0775491261454141, 0.12872239746696235, 0.09158046146059495, 0.19957772925512818, 0.13576035824603128, 0.09439685136035436, 0.11465892227374841, 0.06629342928011406, 0.14298679393801828, 0.04422367182408793, 0.12026868663592671, 0.07082511058337881, 0.1023818140327114, 0.20627388841517547, 0.08135602383382834, 0.6095215451153417, 0.5239010867711287, 0.5281336912296635, 0.5566727380058853, 0.6000278243743683, 0.5204247985956874, 0.6370610161648398, 0.5401352562301153, 0.5650313672428267, 0.13771241477647567, 0.5777014548819656, 0.08814308671874027, 0.13328006760332267, 0.1460677963079785, 0.16823810250218285, 0.14748131381111362, 0.11790247159913181, 0.13931041649201248, 0.3304067437117796, 0.17175167290050763, 0.1667504997464997, 0.2703972310320495, 0.22977252003138215, 0.2789654242942531, 0.21291564964739695, 0.22293968146651344, 0.21392604333619847, 0.2814646189524338, 0.43867644914740866, 0.2924712613825332, 0.42331001146177283, 0.3753505123820805, 0.28999691264756366, 0.6809046241001966, 0.5646785722235212, 0.4995545254912902, 0.2936526986874509, 0.25809663696208995, 0.20739096265565782, 0.3099359863203254, 0.30399427040706206, 0.3257826259935993, 0.22783206991526894, 0.3639649974895546, 0.23247189891613884, 0.21882213270107154, 0.21990413537306008, 0.2087416323445892, 0.21529223106038775, 0.2472130956536499, 0.23781510781713, 0.2393442302547899, 0.21283374666344756, 0.2627801097412127, 0.20135047829989394, 0.23687316929044422, 0.20839754031053526, 0.7476343343056103, 0.2114259834883142, 0.20945720190941552, 0.20858124984282045, 0.2449425944040956, 0.21687694108880073, 0.8889690399875826, 0.1856130721729613, 0.17313141123634546, 0.9001068190780968, 0.19973513845309376, 0.8766438351381951, 0.8298364646118694, 0.8123001475704195, 0.15247655770399848, 0.7645605884431432, 0.20887985573634182, 0.11173104282889834, 0.7007510596283757, 0.16610855461701213, 0.15531219012888464, 0.1044235161911995, 0.20739958772113054, 0.841758324773506, 0.1976594736326498, 0.20242653153582502, 0.17112098820264054, 0.20019641947623112, 0.22680987553157705, 0.1956056522725338, 0.1780018772542027, 0.21083464720164602, 0.1866443018931937, 0.08522368511852352, 0.09068547562243345, 0.08669960537714338, 0.09497740685756928, 0.08373196113994019, 0.09068219873196903, 0.09001935382820248, 0.10302510606419635, 0.08535320107412592]}, "mutation_prompt": null}
{"id": "9b07dd56-6806-4f33-816a-4a5c4332078c", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n        \n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.7 + 0.3 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.3 + 0.7 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment and restart mechanism\n            if evals % 1000 == 0:  # Restart mechanism\n                pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                pop_velocity = np.zeros_like(pop)\n                personal_best = np.copy(pop)\n                personal_best_scores = np.array([func(ind) for ind in personal_best])\n                evals += self.population_size\n\n            self.population_size = max(20, int(40 * (1 - evals / (2 * self.budget))))  # Adjusts based on convergence\n\n        return global_best", "name": "HybridDEPSO", "description": "Improve convergence by dynamically adjusting cognitive and social constants and applying a restart mechanism.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6e2a7ff8-2437-4189-a24c-90bfbf3e5251", "metadata": {"aucs": [0.8540053435700363, 0.8446239005009433, 0.8433137197462313, 0.8350982109361492, 0.8321282735121005, 0.849236144878778, 0.8345923313156289, 0.8475649551958029, 0.8398984266380145, 0.6908944447732139, 0.6748835414430687, 0.680518736349941, 0.6897767425189212, 0.6392589876559729, 0.6706836237364475, 0.685650158347709, 0.6837827379391365, 0.6856489491061533, 0.17452639944946569, 0.13651342619404117, 0.6102099223562799, 0.14593772020779472, 0.1742751795310371, 0.17033576450548138, 0.15568341339437497, 0.5194671041759595, 0.1348086415263704, 0.12134898662683369, 0.10307138029128582, 0.14492721456943003, 0.14296388169277985, 0.10261040177991432, 0.13341343739585354, 0.14524005522680294, 0.12665492635242903, 0.13141552793587086, 0.9633836239454582, 0.9704713861294545, 0.9623025443008554, 0.9636691383744607, 0.961582359892674, 0.9617458810469397, 0.9692103469348498, 0.9575932364551011, 0.9634821675761607, 0.7062894815226939, 0.7257079629663544, 0.7365722337048701, 0.7095609935756645, 0.6694645731079703, 0.7241524215388724, 0.70765980105798, 0.7342156257678243, 0.7118692813438237, 0.38730705742758975, 0.22253694890358056, 0.2253577081822491, 0.37085957564102723, 0.2765135280916413, 0.3624278247274526, 0.22732605631855218, 0.23254561975137167, 0.384421936115785, 0.21842093808429397, 0.206791840002145, 0.29223858763009514, 0.12182196030190429, 0.19285803866944684, 0.12965526915705994, 0.24476197461288096, 0.28256847611748726, 0.18754035996166862, 0.2210412767637987, 0.22179200402093557, 0.1982180050628638, 0.20989133817156158, 0.2093323442855538, 0.22725563450479125, 0.23958373547070622, 0.24058957935018943, 0.22551857161267708, 0.08477005784290648, 0.014494010183869421, 9.999999999998899e-05, 0.08984385999339506, 9.999999999998899e-05, 0.02472900155043356, 0.00788445290801465, 9.999999999998899e-05, 0.141824824571403, 0.14934093500953172, 0.06809679487732867, 0.16742357798663066, 0.08026950631928342, 0.07800294285392151, 0.043085510022119355, 0.15136925030245307, 0.0893600771916574, 0.07566788948406078, 0.18226985069938795, 0.15037386562328703, 0.1983192288706369, 0.0775491261454141, 0.12872239746696235, 0.09158046146059495, 0.19957772925512818, 0.13576035824603128, 0.09439685136035436, 0.11465892227374841, 0.06629342928011406, 0.14298679393801828, 0.04422367182408793, 0.12026868663592671, 0.07082511058337881, 0.1023818140327114, 0.20627388841517547, 0.08135602383382834, 0.6095215451153417, 0.5239010867711287, 0.5281336912296635, 0.5566727380058853, 0.6000278243743683, 0.5204247985956874, 0.6370610161648398, 0.5401352562301153, 0.5650313672428267, 0.13771241477647567, 0.5777014548819656, 0.08814308671874027, 0.13328006760332267, 0.1460677963079785, 0.16823810250218285, 0.14748131381111362, 0.11790247159913181, 0.13931041649201248, 0.3304067437117796, 0.17175167290050763, 0.1667504997464997, 0.2703972310320495, 0.22977252003138215, 0.2789654242942531, 0.21291564964739695, 0.22293968146651344, 0.21392604333619847, 0.2814646189524338, 0.43867644914740866, 0.2924712613825332, 0.42331001146177283, 0.3753505123820805, 0.28999691264756366, 0.6809046241001966, 0.5646785722235212, 0.4995545254912902, 0.2936526986874509, 0.25809663696208995, 0.20739096265565782, 0.3099359863203254, 0.30399427040706206, 0.3257826259935993, 0.22783206991526894, 0.3639649974895546, 0.23247189891613884, 0.21882213270107154, 0.21990413537306008, 0.2087416323445892, 0.21529223106038775, 0.2472130956536499, 0.23781510781713, 0.2393442302547899, 0.21283374666344756, 0.2627801097412127, 0.20135047829989394, 0.23687316929044422, 0.20839754031053526, 0.7476343343056103, 0.2114259834883142, 0.20945720190941552, 0.20858124984282045, 0.2449425944040956, 0.21687694108880073, 0.8889690399875826, 0.1856130721729613, 0.17313141123634546, 0.9001068190780968, 0.19973513845309376, 0.8766438351381951, 0.8298364646118694, 0.8123001475704195, 0.15247655770399848, 0.7645605884431432, 0.20887985573634182, 0.11173104282889834, 0.7007510596283757, 0.16610855461701213, 0.15531219012888464, 0.1044235161911995, 0.20739958772113054, 0.841758324773506, 0.1976594736326498, 0.20242653153582502, 0.17112098820264054, 0.20019641947623112, 0.22680987553157705, 0.1956056522725338, 0.1780018772542027, 0.21083464720164602, 0.1866443018931937, 0.08522368511852352, 0.09068547562243345, 0.08669960537714338, 0.09497740685756928, 0.08373196113994019, 0.09068219873196903, 0.09001935382820248, 0.10302510606419635, 0.08535320107412592]}, "mutation_prompt": null}
{"id": "0450b9e5-266e-430b-a590-d349a8deb32e", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n        \n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.7 + 0.3 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.3 + 0.7 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment and restart mechanism\n            if evals % 500 == 0:  # More frequent local search for stuck situations\n                pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                pop_velocity = np.zeros_like(pop)\n                personal_best = np.copy(pop)\n                personal_best_scores = np.array([func(ind) for ind in personal_best])\n                evals += self.population_size\n\n            self.population_size = max(10, int(40 * (1 - evals / self.budget)))  # More aggressive shrinkage\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance convergence by varying the population size more adaptively and introducing a local search when stuck.", "configspace": "", "generation": 80, "fitness": 0.33795517907865924, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.27.", "error": "", "parent_id": "6e2a7ff8-2437-4189-a24c-90bfbf3e5251", "metadata": {"aucs": [0.8164195756494056, 0.8031872572484745, 0.7981962501001248, 0.8131225564221786, 0.7959314763104478, 0.8159998662454583, 0.8090775586870029, 0.8006111898269437, 0.8134346873442886, 0.6243917730717828, 0.6409613488746846, 0.6246065014104285, 0.6324330962371657, 0.6206267988292387, 0.6602978125663587, 0.6250778151442056, 0.6284297288630931, 0.6439013126697939, 0.16468275658009335, 0.1523742403417102, 0.14944011076747288, 0.14716212489162195, 0.14090427166772357, 0.12587880678527852, 0.13646435953101976, 0.1260808454423351, 0.1269074889641384, 0.12992090088605224, 0.13179453711442457, 0.11510077274071262, 0.14523343787680443, 0.1057840450887072, 0.12467044905865843, 0.13196596422219609, 0.15054869008726268, 0.13693992192926197, 0.9663096765456931, 0.9677332223840229, 0.9618773564657753, 0.9638852704863604, 0.9620637956010087, 0.9569925276456013, 0.9692532669982198, 0.9610165844843083, 0.9640342759298982, 0.6636107433678256, 0.689397734550597, 0.6682565674513377, 0.6916670030969504, 0.690871529705677, 0.5652380734053882, 0.6667720011864461, 0.6871262955424005, 0.6473159988560401, 0.22763517280017742, 0.2118816720146538, 0.7836262031264627, 0.84578012830147, 0.8203343143094035, 0.7744304099080812, 0.17460902341458462, 0.7953357547666624, 0.3757134550867367, 0.2107971195254189, 0.24651678371339114, 0.18269965187640447, 0.11814504410615212, 0.20027378772360638, 0.13075831823908413, 0.18405659724765, 0.1277671597237473, 0.17171183149166014, 0.14309816794389285, 0.2158639387776684, 0.1704826718779172, 0.23005345603411143, 0.20521122308868534, 0.1287205377626286, 0.38718778951761823, 0.16937928514143785, 0.20816433037503468, 0.03959176468957226, 9.999999999998899e-05, 0.00031421543773779703, 0.06403598872531935, 9.999999999998899e-05, 0.036110584892703135, 0.036694065018338606, 9.999999999998899e-05, 0.09482080258988312, 0.15810534866420334, 0.06485839267962179, 0.2017290099601835, 0.10096586964702814, 0.11422515328791394, 0.04802136278645486, 0.1293826885334014, 0.11759789281328425, 0.12608127874006236, 0.13380112040446168, 0.15891056752287636, 0.1514436027400523, 0.07031829799362277, 0.09650138311991263, 0.08318442293071604, 0.1912512508481211, 0.08295765018880286, 0.06502938132417624, 0.1499729323527983, 0.05542051459464292, 0.15327041455090762, 0.060783208333432204, 0.14882642972741777, 0.09160518239415383, 0.17220744833632617, 0.12354687710778145, 0.08002066681340947, 0.5298123484565177, 0.529285141836223, 0.45867080181005604, 0.6014561431684758, 0.5809646948813703, 0.535796068789504, 0.5565041868029215, 0.5686885175621472, 0.565138982294016, 0.1702038582845946, 0.11155316239271174, 0.12718560658188527, 0.13664661583402027, 0.14769810302095066, 0.09796032234223262, 0.10542028426953143, 0.13206163748123378, 0.16695854828833212, 0.26316510603854626, 0.18078049438937305, 0.17757744449420387, 0.36902492510643403, 0.3085390395537042, 0.2167927410806021, 0.20983864439674682, 0.18886006157122515, 0.224895107857373, 0.37181862721051095, 0.43398203125220447, 0.3840394953354527, 0.6457913645405944, 0.3218435105490979, 0.34741295279887063, 0.4716088830979944, 0.4821895714212573, 0.43218061949430386, 0.36060678281106084, 0.2663671896734999, 0.30649396587511746, 0.1979014575589807, 0.25267023352040685, 0.3400143003751097, 0.2443471266778784, 0.2829321350311348, 0.20498549838601265, 0.24500071852190564, 0.23030750191766336, 0.19860433573672553, 0.19753353415442265, 0.21220519246017333, 0.2441652194232553, 0.2068059052476896, 0.19171736585156307, 0.21698527097461062, 0.20832681704906386, 0.20666044854360677, 0.24248543275313206, 0.24048260646445752, 0.7136474683773988, 0.18904862232033293, 0.23574981141135742, 0.2388205240911917, 0.20674812472537218, 0.8554093136413741, 0.18618219756183085, 0.17509284781105072, 0.8880815933740098, 0.7370607668086624, 0.8676846685938672, 0.802427634092667, 0.20038380338638728, 0.15193343518505975, 0.736688440226879, 0.2097884435243943, 0.6450877980321346, 0.45733183821076595, 0.1659987174390537, 0.7743417556918712, 0.10446575563517091, 0.6634898619036615, 0.814670317470632, 0.19760660251995554, 0.20292063549860018, 0.19514375318972754, 0.20019641947623112, 0.1993269213963459, 0.17628382319001068, 0.19838985220839245, 0.19143968990205462, 0.23275128772514664, 0.0880041717212775, 0.0761057388855263, 0.10065148477971997, 0.09463972977891721, 0.09658997637279809, 0.10369392557241408, 0.10008295173801451, 0.08839558095476208, 0.0919158624489197]}, "mutation_prompt": null}
{"id": "8d3c71f2-6a15-4e7e-aacc-c99ffb413e90", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n        \n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.7 + 0.3 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.3 + 0.7 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment and restart mechanism\n            if evals % 500 == 0:  # More frequent local search for stuck situations\n                pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                pop_velocity = np.zeros_like(pop)\n                personal_best = np.copy(pop)\n                personal_best_scores = np.array([func(ind) for ind in personal_best])\n                evals += self.population_size\n\n            self.population_size = max(10, int(40 * (1 - evals / self.budget)))  # More aggressive shrinkage\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance convergence by varying the population size more adaptively and introducing a local search when stuck.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0450b9e5-266e-430b-a590-d349a8deb32e", "metadata": {"aucs": [0.8164195756494056, 0.8031872572484745, 0.7981962501001248, 0.8131225564221786, 0.7959314763104478, 0.8159998662454583, 0.8090775586870029, 0.8006111898269437, 0.8134346873442886, 0.6243917730717828, 0.6409613488746846, 0.6246065014104285, 0.6324330962371657, 0.6206267988292387, 0.6602978125663587, 0.6250778151442056, 0.6284297288630931, 0.6439013126697939, 0.16468275658009335, 0.1523742403417102, 0.14944011076747288, 0.14716212489162195, 0.14090427166772357, 0.12587880678527852, 0.13646435953101976, 0.1260808454423351, 0.1269074889641384, 0.12992090088605224, 0.13179453711442457, 0.11510077274071262, 0.14523343787680443, 0.1057840450887072, 0.12467044905865843, 0.13196596422219609, 0.15054869008726268, 0.13693992192926197, 0.9663096765456931, 0.9677332223840229, 0.9618773564657753, 0.9638852704863604, 0.9620637956010087, 0.9569925276456013, 0.9692532669982198, 0.9610165844843083, 0.9640342759298982, 0.6636107433678256, 0.689397734550597, 0.6682565674513377, 0.6916670030969504, 0.690871529705677, 0.5652380734053882, 0.6667720011864461, 0.6871262955424005, 0.6473159988560401, 0.22763517280017742, 0.2118816720146538, 0.7836262031264627, 0.84578012830147, 0.8203343143094035, 0.7744304099080812, 0.17460902341458462, 0.7953357547666624, 0.3757134550867367, 0.2107971195254189, 0.24651678371339114, 0.18269965187640447, 0.11814504410615212, 0.20027378772360638, 0.13075831823908413, 0.18405659724765, 0.1277671597237473, 0.17171183149166014, 0.14309816794389285, 0.2158639387776684, 0.1704826718779172, 0.23005345603411143, 0.20521122308868534, 0.1287205377626286, 0.38718778951761823, 0.16937928514143785, 0.20816433037503468, 0.03959176468957226, 9.999999999998899e-05, 0.00031421543773779703, 0.06403598872531935, 9.999999999998899e-05, 0.036110584892703135, 0.036694065018338606, 9.999999999998899e-05, 0.09482080258988312, 0.15810534866420334, 0.06485839267962179, 0.2017290099601835, 0.10096586964702814, 0.11422515328791394, 0.04802136278645486, 0.1293826885334014, 0.11759789281328425, 0.12608127874006236, 0.13380112040446168, 0.15891056752287636, 0.1514436027400523, 0.07031829799362277, 0.09650138311991263, 0.08318442293071604, 0.1912512508481211, 0.08295765018880286, 0.06502938132417624, 0.1499729323527983, 0.05542051459464292, 0.15327041455090762, 0.060783208333432204, 0.14882642972741777, 0.09160518239415383, 0.17220744833632617, 0.12354687710778145, 0.08002066681340947, 0.5298123484565177, 0.529285141836223, 0.45867080181005604, 0.6014561431684758, 0.5809646948813703, 0.535796068789504, 0.5565041868029215, 0.5686885175621472, 0.565138982294016, 0.1702038582845946, 0.11155316239271174, 0.12718560658188527, 0.13664661583402027, 0.14769810302095066, 0.09796032234223262, 0.10542028426953143, 0.13206163748123378, 0.16695854828833212, 0.26316510603854626, 0.18078049438937305, 0.17757744449420387, 0.36902492510643403, 0.3085390395537042, 0.2167927410806021, 0.20983864439674682, 0.18886006157122515, 0.224895107857373, 0.37181862721051095, 0.43398203125220447, 0.3840394953354527, 0.6457913645405944, 0.3218435105490979, 0.34741295279887063, 0.4716088830979944, 0.4821895714212573, 0.43218061949430386, 0.36060678281106084, 0.2663671896734999, 0.30649396587511746, 0.1979014575589807, 0.25267023352040685, 0.3400143003751097, 0.2443471266778784, 0.2829321350311348, 0.20498549838601265, 0.24500071852190564, 0.23030750191766336, 0.19860433573672553, 0.19753353415442265, 0.21220519246017333, 0.2441652194232553, 0.2068059052476896, 0.19171736585156307, 0.21698527097461062, 0.20832681704906386, 0.20666044854360677, 0.24248543275313206, 0.24048260646445752, 0.7136474683773988, 0.18904862232033293, 0.23574981141135742, 0.2388205240911917, 0.20674812472537218, 0.8554093136413741, 0.18618219756183085, 0.17509284781105072, 0.8880815933740098, 0.7370607668086624, 0.8676846685938672, 0.802427634092667, 0.20038380338638728, 0.15193343518505975, 0.736688440226879, 0.2097884435243943, 0.6450877980321346, 0.45733183821076595, 0.1659987174390537, 0.7743417556918712, 0.10446575563517091, 0.6634898619036615, 0.814670317470632, 0.19760660251995554, 0.20292063549860018, 0.19514375318972754, 0.20019641947623112, 0.1993269213963459, 0.17628382319001068, 0.19838985220839245, 0.19143968990205462, 0.23275128772514664, 0.0880041717212775, 0.0761057388855263, 0.10065148477971997, 0.09463972977891721, 0.09658997637279809, 0.10369392557241408, 0.10008295173801451, 0.08839558095476208, 0.0919158624489197]}, "mutation_prompt": null}
{"id": "6c4a138c-c427-4e60-ab21-0b943406116e", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n        \n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                random_perturbation = np.random.uniform(-0.1, 0.1, self.dim)  # Added line\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c) + random_perturbation)  # Modified line\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.7 + 0.3 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.3 + 0.7 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment and restart mechanism\n            if evals % 500 == 0:  # More frequent local search for stuck situations\n                pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                pop_velocity = np.zeros_like(pop)\n                personal_best = np.copy(pop)\n                personal_best_scores = np.array([func(ind) for ind in personal_best])\n                evals += self.population_size\n\n            self.population_size = max(10, int(40 * (1 - evals / self.budget)))  # More aggressive shrinkage\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance exploration by adding a random perturbation in the DE phase to avoid premature convergence.", "configspace": "", "generation": 82, "fitness": 0.3247905922559473, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "0450b9e5-266e-430b-a590-d349a8deb32e", "metadata": {"aucs": [0.8103280323151135, 0.8064948409121315, 0.8030373800459787, 0.797338389121924, 0.8032007614750066, 0.806144143835584, 0.8027751826420458, 0.8179033551128013, 0.8058942317643115, 0.6180080487415619, 0.43446510135414396, 0.6487251210945211, 0.6425259073351682, 0.1677185589436313, 0.6266511306360663, 0.6448972122343917, 0.6281056700505855, 0.6254719938882014, 0.26964061705172593, 0.13763235283420616, 0.12176139912785888, 0.16216323216364947, 0.1409791006493566, 0.11384750126818177, 0.12408931177431093, 0.5951350552036596, 0.16269744851966117, 0.1027529167962411, 0.13611785237673102, 0.12077485895662599, 0.12854090669321017, 0.11756728953358309, 0.1112779027060502, 0.10553692984214191, 0.13241291404057665, 0.14131458952940956, 0.9635455080925034, 0.963546228837687, 0.962392961742557, 0.9634362876276347, 0.9582171265906858, 0.9633859848044508, 0.9643533784001119, 0.9685939689205755, 0.956545737654424, 0.4480145795301894, 0.5034212608694604, 0.40173041612699745, 0.44691792271166075, 0.4870169383363582, 0.48717005858489815, 0.632221072253174, 0.45524166604066074, 0.4953580299999757, 0.7688958400398209, 0.7741041606221072, 0.22435001731758242, 0.8091893231711635, 0.2650543778561507, 0.26266015639507534, 0.22612677588094043, 0.2237421397596615, 0.7744002738823134, 0.19554037281159442, 0.17467122818883873, 0.16507961117521064, 0.16451241681346018, 0.16209548437581411, 0.1696511721675117, 0.18238109697601979, 0.12579099947007966, 0.17688161669830438, 0.193084750369111, 0.12074461248473711, 0.19710163112288337, 0.19637219046259535, 0.17047012209495382, 0.20159294637440084, 0.20500844992579603, 0.17651189280964585, 0.19458398296485524, 9.999999999998899e-05, 0.0038672110218880285, 0.0408205375674453, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10593691890709722, 9.999999999998899e-05, 9.999999999998899e-05, 0.12411099260442571, 0.0807038065171406, 0.18536771272205943, 0.0810816205089897, 0.10078408971731334, 0.08740940033291045, 0.12057183320294551, 0.07414755729771028, 0.12089231354635743, 0.04183501921990718, 0.09172002965049031, 0.3221279973307376, 0.06917854594224826, 0.11642620859136732, 0.06485056015716328, 0.14105619087434373, 0.09891592438855912, 0.1695342455515071, 0.22361965446268472, 0.10876539901114135, 0.11777089203530233, 0.04074768195873313, 0.10648930433499826, 0.12596282743232712, 0.08473451093588469, 0.21523784858415207, 0.08358900824280424, 0.4762777579417041, 0.5614101342665918, 0.5043031236703259, 0.4729313700857726, 0.4929809021618936, 0.5127983848237858, 0.5144161251713202, 0.5507154655570616, 0.5222993912142423, 0.11020518975425353, 0.10693161956928776, 0.11775907191235124, 0.15015468122510534, 0.14627548581091143, 0.13570485954494993, 0.09994552079806707, 0.1350648249502212, 0.16041511323031066, 0.19806441885146597, 0.2741695991207367, 0.16296653539288597, 0.2428469191649728, 0.28093267600515714, 0.17393900355044667, 0.3028248636070301, 0.3208619100274942, 0.39317822612297026, 0.4154357659001371, 0.26585414579287103, 0.2905494925000156, 0.4291664512896991, 0.32550370074003643, 0.3496534559155897, 0.278554240757413, 0.3617837110449953, 0.40744893359041334, 0.291246086998149, 0.2936073329848147, 0.30146694169883426, 0.2271234470435486, 0.24269106220360204, 0.3054904087848097, 0.23215386822960504, 0.36013164976075596, 0.22733134396435695, 0.2107941732453349, 0.20933196501918372, 0.26571686869346167, 0.22465264422012532, 0.2233013058833918, 0.23142986143057043, 0.215722850213649, 0.23142152032257102, 0.24987382467295616, 0.716915315707986, 0.20441438549015378, 0.23431237808146965, 0.24147772166277548, 0.21997721010772198, 0.19793915033685094, 0.1939235798768908, 0.24176758190002157, 0.20273683944776133, 0.16147190488024332, 0.8103411564646931, 0.18661538588851567, 0.7533040539884736, 0.8179086931916766, 0.8674168198821184, 0.8529304648659453, 0.8074631304682799, 0.830194775792877, 0.5874460065016637, 0.21304113830284488, 0.20974901685927128, 0.2076701480990507, 0.8146611101920287, 0.7362802026805304, 0.6441341297368047, 0.584712121266006, 0.1635476896631719, 0.1937040753236542, 0.19040706120989936, 0.18698913489209168, 0.1754851274890854, 0.2037337024867346, 0.18854395275147073, 0.18038158783163072, 0.18291538925498885, 0.18492970165881584, 0.09284931739540792, 0.10074267654376368, 0.08818067009328334, 0.12800369449693683, 0.08880800491541563, 0.1041499105419742, 0.09973280327123724, 0.0948076781322379, 0.09575124867234741]}, "mutation_prompt": null}
{"id": "4e4158c1-68cb-4e2f-b36d-ee635ab34278", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n        \n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.7 + 0.3 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.3 + 0.7 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment and restart mechanism\n            if evals % 500 == 0:  # More frequent local search for stuck situations\n                pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                pop_velocity = np.zeros_like(pop)\n                personal_best = np.copy(pop)\n                personal_best_scores = np.array([func(ind) for ind in personal_best])\n                evals += self.population_size\n\n            self.population_size = max(10, int(40 * (1 - evals / self.budget)))  # More aggressive shrinkage\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance convergence by varying the population size more adaptively and introducing a local search when stuck.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0450b9e5-266e-430b-a590-d349a8deb32e", "metadata": {"aucs": [0.8164195756494056, 0.8031872572484745, 0.7981962501001248, 0.8131225564221786, 0.7959314763104478, 0.8159998662454583, 0.8090775586870029, 0.8006111898269437, 0.8134346873442886, 0.6243917730717828, 0.6409613488746846, 0.6246065014104285, 0.6324330962371657, 0.6206267988292387, 0.6602978125663587, 0.6250778151442056, 0.6284297288630931, 0.6439013126697939, 0.16468275658009335, 0.1523742403417102, 0.14944011076747288, 0.14716212489162195, 0.14090427166772357, 0.12587880678527852, 0.13646435953101976, 0.1260808454423351, 0.1269074889641384, 0.12992090088605224, 0.13179453711442457, 0.11510077274071262, 0.14523343787680443, 0.1057840450887072, 0.12467044905865843, 0.13196596422219609, 0.15054869008726268, 0.13693992192926197, 0.9663096765456931, 0.9677332223840229, 0.9618773564657753, 0.9638852704863604, 0.9620637956010087, 0.9569925276456013, 0.9692532669982198, 0.9610165844843083, 0.9640342759298982, 0.6636107433678256, 0.689397734550597, 0.6682565674513377, 0.6916670030969504, 0.690871529705677, 0.5652380734053882, 0.6667720011864461, 0.6871262955424005, 0.6473159988560401, 0.22763517280017742, 0.2118816720146538, 0.7836262031264627, 0.84578012830147, 0.8203343143094035, 0.7744304099080812, 0.17460902341458462, 0.7953357547666624, 0.3757134550867367, 0.2107971195254189, 0.24651678371339114, 0.18269965187640447, 0.11814504410615212, 0.20027378772360638, 0.13075831823908413, 0.18405659724765, 0.1277671597237473, 0.17171183149166014, 0.14309816794389285, 0.2158639387776684, 0.1704826718779172, 0.23005345603411143, 0.20521122308868534, 0.1287205377626286, 0.38718778951761823, 0.16937928514143785, 0.20816433037503468, 0.03959176468957226, 9.999999999998899e-05, 0.00031421543773779703, 0.06403598872531935, 9.999999999998899e-05, 0.036110584892703135, 0.036694065018338606, 9.999999999998899e-05, 0.09482080258988312, 0.15810534866420334, 0.06485839267962179, 0.2017290099601835, 0.10096586964702814, 0.11422515328791394, 0.04802136278645486, 0.1293826885334014, 0.11759789281328425, 0.12608127874006236, 0.13380112040446168, 0.15891056752287636, 0.1514436027400523, 0.07031829799362277, 0.09650138311991263, 0.08318442293071604, 0.1912512508481211, 0.08295765018880286, 0.06502938132417624, 0.1499729323527983, 0.05542051459464292, 0.15327041455090762, 0.060783208333432204, 0.14882642972741777, 0.09160518239415383, 0.17220744833632617, 0.12354687710778145, 0.08002066681340947, 0.5298123484565177, 0.529285141836223, 0.45867080181005604, 0.6014561431684758, 0.5809646948813703, 0.535796068789504, 0.5565041868029215, 0.5686885175621472, 0.565138982294016, 0.1702038582845946, 0.11155316239271174, 0.12718560658188527, 0.13664661583402027, 0.14769810302095066, 0.09796032234223262, 0.10542028426953143, 0.13206163748123378, 0.16695854828833212, 0.26316510603854626, 0.18078049438937305, 0.17757744449420387, 0.36902492510643403, 0.3085390395537042, 0.2167927410806021, 0.20983864439674682, 0.18886006157122515, 0.224895107857373, 0.37181862721051095, 0.43398203125220447, 0.3840394953354527, 0.6457913645405944, 0.3218435105490979, 0.34741295279887063, 0.4716088830979944, 0.4821895714212573, 0.43218061949430386, 0.36060678281106084, 0.2663671896734999, 0.30649396587511746, 0.1979014575589807, 0.25267023352040685, 0.3400143003751097, 0.2443471266778784, 0.2829321350311348, 0.20498549838601265, 0.24500071852190564, 0.23030750191766336, 0.19860433573672553, 0.19753353415442265, 0.21220519246017333, 0.2441652194232553, 0.2068059052476896, 0.19171736585156307, 0.21698527097461062, 0.20832681704906386, 0.20666044854360677, 0.24248543275313206, 0.24048260646445752, 0.7136474683773988, 0.18904862232033293, 0.23574981141135742, 0.2388205240911917, 0.20674812472537218, 0.8554093136413741, 0.18618219756183085, 0.17509284781105072, 0.8880815933740098, 0.7370607668086624, 0.8676846685938672, 0.802427634092667, 0.20038380338638728, 0.15193343518505975, 0.736688440226879, 0.2097884435243943, 0.6450877980321346, 0.45733183821076595, 0.1659987174390537, 0.7743417556918712, 0.10446575563517091, 0.6634898619036615, 0.814670317470632, 0.19760660251995554, 0.20292063549860018, 0.19514375318972754, 0.20019641947623112, 0.1993269213963459, 0.17628382319001068, 0.19838985220839245, 0.19143968990205462, 0.23275128772514664, 0.0880041717212775, 0.0761057388855263, 0.10065148477971997, 0.09463972977891721, 0.09658997637279809, 0.10369392557241408, 0.10008295173801451, 0.08839558095476208, 0.0919158624489197]}, "mutation_prompt": null}
{"id": "fc0f3008-ce66-4734-aef3-d78752d53f25", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n        \n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.7 + 0.3 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.3 + 0.7 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment and restart mechanism\n            if evals % 500 == 0:  # More frequent local search for stuck situations\n                pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                pop_velocity = np.zeros_like(pop)\n                personal_best = np.copy(pop)\n                personal_best_scores = np.array([func(ind) for ind in personal_best])\n                evals += self.population_size\n\n            self.population_size = max(10, int(40 * (1 - evals / self.budget)))  # More aggressive shrinkage\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance convergence by varying the population size more adaptively and introducing a local search when stuck.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0450b9e5-266e-430b-a590-d349a8deb32e", "metadata": {"aucs": [0.8164195756494056, 0.8031872572484745, 0.7981962501001248, 0.8131225564221786, 0.7959314763104478, 0.8159998662454583, 0.8090775586870029, 0.8006111898269437, 0.8134346873442886, 0.6243917730717828, 0.6409613488746846, 0.6246065014104285, 0.6324330962371657, 0.6206267988292387, 0.6602978125663587, 0.6250778151442056, 0.6284297288630931, 0.6439013126697939, 0.16468275658009335, 0.1523742403417102, 0.14944011076747288, 0.14716212489162195, 0.14090427166772357, 0.12587880678527852, 0.13646435953101976, 0.1260808454423351, 0.1269074889641384, 0.12992090088605224, 0.13179453711442457, 0.11510077274071262, 0.14523343787680443, 0.1057840450887072, 0.12467044905865843, 0.13196596422219609, 0.15054869008726268, 0.13693992192926197, 0.9663096765456931, 0.9677332223840229, 0.9618773564657753, 0.9638852704863604, 0.9620637956010087, 0.9569925276456013, 0.9692532669982198, 0.9610165844843083, 0.9640342759298982, 0.6636107433678256, 0.689397734550597, 0.6682565674513377, 0.6916670030969504, 0.690871529705677, 0.5652380734053882, 0.6667720011864461, 0.6871262955424005, 0.6473159988560401, 0.22763517280017742, 0.2118816720146538, 0.7836262031264627, 0.84578012830147, 0.8203343143094035, 0.7744304099080812, 0.17460902341458462, 0.7953357547666624, 0.3757134550867367, 0.2107971195254189, 0.24651678371339114, 0.18269965187640447, 0.11814504410615212, 0.20027378772360638, 0.13075831823908413, 0.18405659724765, 0.1277671597237473, 0.17171183149166014, 0.14309816794389285, 0.2158639387776684, 0.1704826718779172, 0.23005345603411143, 0.20521122308868534, 0.1287205377626286, 0.38718778951761823, 0.16937928514143785, 0.20816433037503468, 0.03959176468957226, 9.999999999998899e-05, 0.00031421543773779703, 0.06403598872531935, 9.999999999998899e-05, 0.036110584892703135, 0.036694065018338606, 9.999999999998899e-05, 0.09482080258988312, 0.15810534866420334, 0.06485839267962179, 0.2017290099601835, 0.10096586964702814, 0.11422515328791394, 0.04802136278645486, 0.1293826885334014, 0.11759789281328425, 0.12608127874006236, 0.13380112040446168, 0.15891056752287636, 0.1514436027400523, 0.07031829799362277, 0.09650138311991263, 0.08318442293071604, 0.1912512508481211, 0.08295765018880286, 0.06502938132417624, 0.1499729323527983, 0.05542051459464292, 0.15327041455090762, 0.060783208333432204, 0.14882642972741777, 0.09160518239415383, 0.17220744833632617, 0.12354687710778145, 0.08002066681340947, 0.5298123484565177, 0.529285141836223, 0.45867080181005604, 0.6014561431684758, 0.5809646948813703, 0.535796068789504, 0.5565041868029215, 0.5686885175621472, 0.565138982294016, 0.1702038582845946, 0.11155316239271174, 0.12718560658188527, 0.13664661583402027, 0.14769810302095066, 0.09796032234223262, 0.10542028426953143, 0.13206163748123378, 0.16695854828833212, 0.26316510603854626, 0.18078049438937305, 0.17757744449420387, 0.36902492510643403, 0.3085390395537042, 0.2167927410806021, 0.20983864439674682, 0.18886006157122515, 0.224895107857373, 0.37181862721051095, 0.43398203125220447, 0.3840394953354527, 0.6457913645405944, 0.3218435105490979, 0.34741295279887063, 0.4716088830979944, 0.4821895714212573, 0.43218061949430386, 0.36060678281106084, 0.2663671896734999, 0.30649396587511746, 0.1979014575589807, 0.25267023352040685, 0.3400143003751097, 0.2443471266778784, 0.2829321350311348, 0.20498549838601265, 0.24500071852190564, 0.23030750191766336, 0.19860433573672553, 0.19753353415442265, 0.21220519246017333, 0.2441652194232553, 0.2068059052476896, 0.19171736585156307, 0.21698527097461062, 0.20832681704906386, 0.20666044854360677, 0.24248543275313206, 0.24048260646445752, 0.7136474683773988, 0.18904862232033293, 0.23574981141135742, 0.2388205240911917, 0.20674812472537218, 0.8554093136413741, 0.18618219756183085, 0.17509284781105072, 0.8880815933740098, 0.7370607668086624, 0.8676846685938672, 0.802427634092667, 0.20038380338638728, 0.15193343518505975, 0.736688440226879, 0.2097884435243943, 0.6450877980321346, 0.45733183821076595, 0.1659987174390537, 0.7743417556918712, 0.10446575563517091, 0.6634898619036615, 0.814670317470632, 0.19760660251995554, 0.20292063549860018, 0.19514375318972754, 0.20019641947623112, 0.1993269213963459, 0.17628382319001068, 0.19838985220839245, 0.19143968990205462, 0.23275128772514664, 0.0880041717212775, 0.0761057388855263, 0.10065148477971997, 0.09463972977891721, 0.09658997637279809, 0.10369392557241408, 0.10008295173801451, 0.08839558095476208, 0.0919158624489197]}, "mutation_prompt": null}
{"id": "2dd191e5-d767-455a-8c13-e1a7993dde4b", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n        \n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                # Calculate population diversity and adjust mutation factor\n                diversity = np.std(pop, axis=0).mean() / (self.upper_bound - self.lower_bound)\n                dynamic_mutation_factor *= (1 + diversity)  # Adaptive mutation factor\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.7 + 0.3 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.3 + 0.7 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment and restart mechanism\n            if evals % 500 == 0:  # More frequent local search for stuck situations\n                pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                pop_velocity = np.zeros_like(pop)\n                personal_best = np.copy(pop)\n                personal_best_scores = np.array([func(ind) for ind in personal_best])\n                evals += self.population_size\n\n            self.population_size = max(10, int(40 * (1 - evals / self.budget)))  # More aggressive shrinkage\n\n        return global_best", "name": "HybridDEPSO", "description": "Introduce adaptive mutation based on population diversity to enhance exploration capabilities.", "configspace": "", "generation": 85, "fitness": 0.31867648293120576, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "0450b9e5-266e-430b-a590-d349a8deb32e", "metadata": {"aucs": [0.8051616723655821, 0.8098624671205805, 0.8024199192453352, 0.8010998876540029, 0.8134709872964072, 0.8142007740418029, 0.8005452239771598, 0.8189920466218489, 0.8067253256816452, 0.6320486007666706, 0.6371336484658245, 0.6519899302960963, 0.6341540027348013, 0.6135708968254785, 0.6096279818090072, 0.624123297579266, 0.6589539403165681, 0.6347211849312153, 0.13322367106614352, 0.1491531588005186, 0.15715698207211826, 0.11427934582610433, 0.11122932268419372, 0.11067706859539872, 0.13150968564054766, 0.17936214704855213, 0.14784247085459523, 0.15843361183553517, 0.16176737134867525, 0.12847643367545403, 0.10764680147013472, 0.09953564722423014, 0.1312338099751985, 0.13656350807119466, 0.10736915708421291, 0.11881087915046196, 0.9675335059619025, 0.9652391763100991, 0.962831512387132, 0.9680735712280435, 0.9631823530548413, 0.9574784911614441, 0.9652568296222892, 0.9630465758214984, 0.963671773678244, 0.677556904345183, 0.6183786952317034, 0.6777920938167039, 0.6895532324559212, 0.6692183460675817, 0.40164624484739997, 0.6835622886926327, 0.6841985683416467, 0.6839592654732904, 0.8418537807089337, 0.35065357326643865, 0.2190968205405619, 0.2756215924701688, 0.36941396415169014, 0.20921329033357305, 0.35088841836814877, 0.23281858205011863, 0.7202964357524524, 0.2094951869642555, 0.20140714171583618, 0.2220057187012533, 0.16155885960119976, 0.1310967487455933, 0.17637915653579495, 0.17684332343449682, 0.12806980365460263, 0.1769504736711619, 0.20215121596194363, 0.19863465685963, 0.12264996410218465, 0.2226403103910044, 0.2059860458911591, 0.22112277340753694, 0.2609218953459802, 0.22353833339947504, 0.18720185258630562, 0.0038733854480466068, 9.999999999998899e-05, 9.999999999998899e-05, 0.03688133491301138, 9.999999999998899e-05, 9.999999999998899e-05, 0.0075068139178161575, 9.999999999998899e-05, 0.05345810386383598, 0.21192072097426728, 0.07703870087568898, 0.10883219044881298, 0.11427822575130975, 0.054728181684410404, 0.07431834054247288, 0.11383335367164782, 0.11898350609026087, 0.08507852734379195, 0.1282049241572326, 0.1334862497146181, 0.2005747888012721, 0.07682679358966382, 0.0665668190951334, 0.06929369071387359, 0.15651719185228508, 0.2931953926609209, 0.14689729241038219, 0.19360382341535465, 0.04821860361284602, 0.18660338612240845, 0.07814935661672717, 0.06891415572468018, 0.19943514031194898, 0.13141875718522478, 0.13435110676085082, 0.08036186060493422, 0.49512568751045705, 0.4865718266668255, 0.5083646325839544, 0.5219638240780962, 0.5099889497330947, 0.4986573023140556, 0.5646941761407975, 0.5471533316381334, 0.6320712695360895, 0.08380784133582986, 0.1311026112035355, 0.08759597568995359, 0.09210515408370668, 0.1276311225172111, 0.1117778699559272, 0.11194793002262138, 0.12738186359872528, 0.11384862511274207, 0.2125108354851063, 0.2530691748291083, 0.25939851637806766, 0.2969725189284975, 0.18140792909486247, 0.2134437191590567, 0.25084950415241525, 0.20014624892290844, 0.28049767564371153, 0.37957772760617137, 0.40315493539832337, 0.3606121399760406, 0.37802192949025915, 0.31455503123257045, 0.2889591854704294, 0.5245968563516364, 0.3705713825334246, 0.25750296619914315, 0.20949116746103724, 0.25171303143447976, 0.2793347104581392, 0.25462474209726793, 0.22880233652917736, 0.2304972992898654, 0.30778432951929313, 0.3525553492598269, 0.2645341048069998, 0.21221230785746104, 0.1843513075557366, 0.20498915590057853, 0.2305455322775366, 0.23689099067384456, 0.22962261860016975, 0.22469004915938284, 0.19313979069944565, 0.25836759008403076, 0.20084825054969746, 0.2037376373670503, 0.22267975956001151, 0.6775303804853854, 0.21834615567984383, 0.2165059904793698, 0.18993204206872882, 0.724558760831565, 0.2128341177556149, 0.8413931186613848, 0.1877216670595181, 0.19904968307553994, 0.8815260433339499, 0.19946784807111162, 0.8543414457506968, 0.14140105045552387, 0.1487430605550315, 0.7983765532739178, 0.7368567576483855, 0.21010917895389392, 0.12682701001154328, 0.6720225973537202, 0.1861729798705345, 0.15435931133677117, 0.10363821825960617, 0.6479968865869177, 0.543269411252012, 0.1841968577822185, 0.191449697584968, 0.18893341163271304, 0.20018175360929158, 0.18221773916888195, 0.18435884302474204, 0.19349356602677092, 0.19188792426212875, 0.18689395393620567, 0.09730358957520535, 0.10722522600497741, 0.09093595118011433, 0.09232798710085222, 0.0882177098232525, 0.09948427146660666, 0.08171509676171118, 0.08294268310282882, 0.0907105244345432]}, "mutation_prompt": null}
{"id": "09034beb-c12a-4c24-95a6-7e13627f2e1d", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n        \n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.7 + 0.3 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.3 + 0.7 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment and restart mechanism\n            if evals % 500 == 0:  # More frequent local search for stuck situations\n                pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                pop_velocity = np.zeros_like(pop)\n                personal_best = np.copy(pop)\n                personal_best_scores = np.array([func(ind) for ind in personal_best])\n                evals += self.population_size\n\n            self.population_size = max(10, int(40 * (1 - evals / self.budget)))  # More aggressive shrinkage\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance convergence by varying the population size more adaptively and introducing a local search when stuck.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0450b9e5-266e-430b-a590-d349a8deb32e", "metadata": {"aucs": [0.8164195756494056, 0.8031872572484745, 0.7981962501001248, 0.8131225564221786, 0.7959314763104478, 0.8159998662454583, 0.8090775586870029, 0.8006111898269437, 0.8134346873442886, 0.6243917730717828, 0.6409613488746846, 0.6246065014104285, 0.6324330962371657, 0.6206267988292387, 0.6602978125663587, 0.6250778151442056, 0.6284297288630931, 0.6439013126697939, 0.16468275658009335, 0.1523742403417102, 0.14944011076747288, 0.14716212489162195, 0.14090427166772357, 0.12587880678527852, 0.13646435953101976, 0.1260808454423351, 0.1269074889641384, 0.12992090088605224, 0.13179453711442457, 0.11510077274071262, 0.14523343787680443, 0.1057840450887072, 0.12467044905865843, 0.13196596422219609, 0.15054869008726268, 0.13693992192926197, 0.9663096765456931, 0.9677332223840229, 0.9618773564657753, 0.9638852704863604, 0.9620637956010087, 0.9569925276456013, 0.9692532669982198, 0.9610165844843083, 0.9640342759298982, 0.6636107433678256, 0.689397734550597, 0.6682565674513377, 0.6916670030969504, 0.690871529705677, 0.5652380734053882, 0.6667720011864461, 0.6871262955424005, 0.6473159988560401, 0.22763517280017742, 0.2118816720146538, 0.7836262031264627, 0.84578012830147, 0.8203343143094035, 0.7744304099080812, 0.17460902341458462, 0.7953357547666624, 0.3757134550867367, 0.2107971195254189, 0.24651678371339114, 0.18269965187640447, 0.11814504410615212, 0.20027378772360638, 0.13075831823908413, 0.18405659724765, 0.1277671597237473, 0.17171183149166014, 0.14309816794389285, 0.2158639387776684, 0.1704826718779172, 0.23005345603411143, 0.20521122308868534, 0.1287205377626286, 0.38718778951761823, 0.16937928514143785, 0.20816433037503468, 0.03959176468957226, 9.999999999998899e-05, 0.00031421543773779703, 0.06403598872531935, 9.999999999998899e-05, 0.036110584892703135, 0.036694065018338606, 9.999999999998899e-05, 0.09482080258988312, 0.15810534866420334, 0.06485839267962179, 0.2017290099601835, 0.10096586964702814, 0.11422515328791394, 0.04802136278645486, 0.1293826885334014, 0.11759789281328425, 0.12608127874006236, 0.13380112040446168, 0.15891056752287636, 0.1514436027400523, 0.07031829799362277, 0.09650138311991263, 0.08318442293071604, 0.1912512508481211, 0.08295765018880286, 0.06502938132417624, 0.1499729323527983, 0.05542051459464292, 0.15327041455090762, 0.060783208333432204, 0.14882642972741777, 0.09160518239415383, 0.17220744833632617, 0.12354687710778145, 0.08002066681340947, 0.5298123484565177, 0.529285141836223, 0.45867080181005604, 0.6014561431684758, 0.5809646948813703, 0.535796068789504, 0.5565041868029215, 0.5686885175621472, 0.565138982294016, 0.1702038582845946, 0.11155316239271174, 0.12718560658188527, 0.13664661583402027, 0.14769810302095066, 0.09796032234223262, 0.10542028426953143, 0.13206163748123378, 0.16695854828833212, 0.26316510603854626, 0.18078049438937305, 0.17757744449420387, 0.36902492510643403, 0.3085390395537042, 0.2167927410806021, 0.20983864439674682, 0.18886006157122515, 0.224895107857373, 0.37181862721051095, 0.43398203125220447, 0.3840394953354527, 0.6457913645405944, 0.3218435105490979, 0.34741295279887063, 0.4716088830979944, 0.4821895714212573, 0.43218061949430386, 0.36060678281106084, 0.2663671896734999, 0.30649396587511746, 0.1979014575589807, 0.25267023352040685, 0.3400143003751097, 0.2443471266778784, 0.2829321350311348, 0.20498549838601265, 0.24500071852190564, 0.23030750191766336, 0.19860433573672553, 0.19753353415442265, 0.21220519246017333, 0.2441652194232553, 0.2068059052476896, 0.19171736585156307, 0.21698527097461062, 0.20832681704906386, 0.20666044854360677, 0.24248543275313206, 0.24048260646445752, 0.7136474683773988, 0.18904862232033293, 0.23574981141135742, 0.2388205240911917, 0.20674812472537218, 0.8554093136413741, 0.18618219756183085, 0.17509284781105072, 0.8880815933740098, 0.7370607668086624, 0.8676846685938672, 0.802427634092667, 0.20038380338638728, 0.15193343518505975, 0.736688440226879, 0.2097884435243943, 0.6450877980321346, 0.45733183821076595, 0.1659987174390537, 0.7743417556918712, 0.10446575563517091, 0.6634898619036615, 0.814670317470632, 0.19760660251995554, 0.20292063549860018, 0.19514375318972754, 0.20019641947623112, 0.1993269213963459, 0.17628382319001068, 0.19838985220839245, 0.19143968990205462, 0.23275128772514664, 0.0880041717212775, 0.0761057388855263, 0.10065148477971997, 0.09463972977891721, 0.09658997637279809, 0.10369392557241408, 0.10008295173801451, 0.08839558095476208, 0.0919158624489197]}, "mutation_prompt": null}
{"id": "07bddeeb-bb22-484b-8c8d-da496cffe15b", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n        \n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.7 + 0.3 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.3 + 0.7 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment and restart mechanism\n            if evals % 500 == 0:  # More frequent local search for stuck situations\n                elite_size = max(1, self.population_size // 5) # Preserve top 20% as elite\n                elite_indices = personal_best_scores.argsort()[:elite_size]\n                elite = personal_best[elite_indices]  # Preserve elite\n                pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - elite_size, self.dim))\n                pop = np.vstack((elite, pop))  # Combine elite with new individuals\n                pop_velocity = np.zeros_like(pop)\n                personal_best = np.copy(pop)\n                personal_best_scores = np.array([func(ind) for ind in personal_best])\n                evals += self.population_size\n\n            self.population_size = max(10, int(40 * (1 - evals / self.budget)))  # More aggressive shrinkage\n\n        return global_best", "name": "HybridDEPSO", "description": "Incorporate elitism by preserving a fraction of the best solutions during population refresh for improved convergence stability.", "configspace": "", "generation": 87, "fitness": 0.3327909636742652, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.27.", "error": "", "parent_id": "0450b9e5-266e-430b-a590-d349a8deb32e", "metadata": {"aucs": [0.8366361639907932, 0.8128872462284642, 0.8155326722907212, 0.8429149068922548, 0.8088805217865747, 0.8180382167160647, 0.82513517450389, 0.812011052787103, 0.8382764593253598, 0.6854461240926769, 0.6401641771346749, 0.6630683461603212, 0.6431081574350772, 0.6583296734698123, 0.6796419368149252, 0.6796155925597321, 0.6368866329022058, 0.6659010364327631, 0.1750032023109761, 0.176772362168094, 0.17225036504459001, 0.1360904539559491, 0.144865789702604, 0.13770310570111233, 0.15950570360064653, 0.1362479354802657, 0.5336183205656464, 0.10807234661353504, 0.12344982959586415, 0.11694754619118264, 0.13319551643405536, 0.1027646526424425, 0.14891539856139646, 0.143461845062142, 0.15128936271582805, 0.1521785555185574, 0.9663096765456931, 0.9677332223840229, 0.9618773564657753, 0.9638852704863604, 0.9620637956010087, 0.9569925276456013, 0.9692532669982198, 0.9610165844843083, 0.9640342759298982, 0.6455131688674378, 0.6936786262604433, 0.6978459393960839, 0.6463824885229872, 0.6632081120189335, 0.6467649301608243, 0.6673885302637852, 0.6806968588373856, 0.6874769792325939, 0.2277091322552769, 0.20975150335668546, 0.21403663141532936, 0.8700948862485427, 0.8784733491196173, 0.36079297735669225, 0.17460902341458462, 0.37173526272709356, 0.7936730369720526, 0.1852490516966121, 0.2345577993276886, 0.17004855898885884, 0.19222337653362942, 0.19881035028942806, 0.1308693201688368, 0.18356242620568808, 0.1285764424560255, 0.18661391398361338, 0.1629737246226567, 0.2046551774807871, 0.17373369711265663, 0.2069100316664123, 0.18415835611641285, 0.12934261806179403, 0.29935259250863033, 0.1675492844924964, 0.2294682206143066, 0.04461768646113029, 9.999999999998899e-05, 0.04613533477116638, 0.06902703368430652, 9.999999999998899e-05, 0.03944588519238701, 0.041298565694523726, 9.999999999998899e-05, 0.14463596825265523, 0.13919544409922968, 0.06260398289726021, 0.22227128252363493, 0.14051935632229362, 0.08952824748802524, 0.03099451503572892, 0.11874134762297894, 0.10410530966394071, 0.11246153849373841, 0.14689435427929365, 0.16169934325801893, 0.16948669210964995, 0.07519793345789383, 0.10395302404628548, 0.08563126731133908, 0.2002972933864844, 0.0900648208349547, 0.06974954862437244, 0.15281906251832755, 0.030132938911688112, 0.1513235979794808, 0.10906783882688886, 0.130250173680157, 0.09792318630358954, 0.17664922709912134, 0.12543221081423672, 0.08042165784787625, 0.5540395002914574, 0.5888281199462336, 0.5166986227485093, 0.5173577284307748, 0.5213690964606221, 0.5447318381591101, 0.5336025304090575, 0.5452655726101878, 0.5394139716190269, 0.1668216280528415, 0.11227887281427884, 0.13692455707541518, 0.13685563127549683, 0.14732893724276852, 0.09798705619168724, 0.14614002243470037, 0.13359869364400578, 0.1360974942793619, 0.34794852297060164, 0.19875271529306981, 0.22400380073459925, 0.16631609432232253, 0.31735240361171824, 0.2894066652659907, 0.21197368387984894, 0.1718845728358983, 0.2644885698173206, 0.3637770982349898, 0.39726264355403496, 0.3465861348882142, 0.4272651879294219, 0.28931169006372626, 0.32827946564505783, 0.35606636486983556, 0.3676418238344762, 0.3787534639335731, 0.2810745979017767, 0.2371522331523619, 0.269106747638996, 0.20951696188150248, 0.24917165841544187, 0.291155974914442, 0.2541554782219042, 0.2745798891475707, 0.2047586239674436, 0.24441453214510034, 0.23282587647869346, 0.20938387167977202, 0.2226985882292034, 0.2162530784508343, 0.22717098536465086, 0.2062015600113526, 0.2208585812453936, 0.21659725966369747, 0.21725060442990496, 0.23032945565877982, 0.21995957312172854, 0.24284676305547115, 0.21243094256175832, 0.20406309655506283, 0.21408715627087305, 0.2182237358944944, 0.20607320759339387, 0.8756081385904086, 0.18622181498631885, 0.6717789417126678, 0.9029975120447965, 0.19927394824334888, 0.8881995460518514, 0.7992179131770125, 0.19959360468359333, 0.1519510804570935, 0.7519144768254941, 0.20983025453082293, 0.6565474042913171, 0.5051707269903684, 0.16600202143148834, 0.7623643721280704, 0.10446746346886815, 0.6361503237754211, 0.8136157849044644, 0.17520973906381332, 0.1932398800161782, 0.18841022282383935, 0.2027656084790963, 0.18003711156702173, 0.18427497424129424, 0.18612189685525415, 0.19790327530898488, 0.23318963146148697, 0.08926989519193085, 0.07927584842849889, 0.09632428113133551, 0.09644571857532336, 0.1029871850908074, 0.10597336065268903, 0.101493902794205, 0.09136195059508789, 0.0935721258744483]}, "mutation_prompt": null}
{"id": "0f4d257e-8e0d-45be-8043-ec3c110f93d0", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n        \n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.7 + 0.3 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.3 + 0.7 * evals / self.budget)\n                \n                average_pos = np.mean(pop, axis=0)\n                directional_velocity = average_pos - pop[i]  # Directional change based on diversity\n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]) +\n                                   0.1 * directional_velocity)  # Adjust velocity based on diversity\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment and restart mechanism\n            if evals % 500 == 0:  # More frequent local search for stuck situations\n                pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                pop_velocity = np.zeros_like(pop)\n                personal_best = np.copy(pop)\n                personal_best_scores = np.array([func(ind) for ind in personal_best])\n                evals += self.population_size\n\n            self.population_size = max(10, int(40 * (1 - evals / self.budget)))  # More aggressive shrinkage\n\n        return global_best", "name": "HybridDEPSO", "description": "Introduce directional velocity adjustment based on population diversity to enhance exploration and exploitation balance.", "configspace": "", "generation": 88, "fitness": 0.2465954703319577, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.22.", "error": "", "parent_id": "0450b9e5-266e-430b-a590-d349a8deb32e", "metadata": {"aucs": [0.5240562015999699, 0.5038256204821338, 0.5258550400709028, 0.508744538338509, 0.5072489086941383, 0.5425148335743883, 0.500599274605039, 0.5078479121077171, 0.48062339207825666, 0.040579551133989256, 0.12273770195898503, 0.15967914163752794, 0.12748997060059697, 0.061542467040231585, 0.04662891655991519, 0.0670707780792742, 0.14329185052242088, 0.0605038275759453, 0.13384732346043315, 0.14297441991699467, 0.14380864778005964, 0.16413794015012606, 0.11614309665348632, 0.11205747927658138, 0.145505462454378, 0.16239604461342627, 0.15156493858449993, 0.10460018076140243, 0.10100899645663719, 0.1188647344619631, 0.12020963268272322, 0.10243051024206473, 0.1093815144967819, 0.1288253700351233, 0.10414247743024663, 0.12913335007614768, 0.9688557557957053, 0.9651540351696677, 0.9696814761724719, 0.9634385343023033, 0.9692125605791636, 0.9584223595215253, 0.9592814352631998, 0.964218332505069, 0.9698201008336607, 0.31816989176355326, 0.32604443026085983, 0.2987733486012222, 0.3124814794485363, 0.20255339959651053, 0.3024234714495666, 0.3776160052518247, 0.35992875648059175, 0.29385344649907486, 0.6838028536972672, 0.22585732004283599, 0.22239564036897896, 0.2811163131047464, 0.27073990110029933, 0.8179790761386047, 0.1746455818827808, 0.2291844426263655, 0.23334231477573586, 0.1143767968783217, 0.1499994447294768, 0.18784673820606645, 0.1184577393723677, 0.13030488994194167, 0.1292024696795281, 0.1549905700646126, 0.18284056715902186, 0.18646674112363837, 0.16552373236618756, 0.14097272782098402, 0.19171808840778803, 0.12760637248067597, 0.18765336061778448, 0.18812898176959303, 0.18327525142906798, 0.21052200078885486, 0.16710365312406084, 0.004905469343641333, 9.999999999998899e-05, 0.0004753744720128461, 0.011525236354858137, 9.999999999998899e-05, 0.004615403256644224, 0.00165776808294682, 0.029319428224211186, 0.011239561605772552, 0.20268982436055727, 0.06665509662478086, 0.1284911300425421, 0.06323241534417756, 0.046078126970752975, 0.04149348983812218, 0.06976384854903772, 0.11477388498688235, 0.13266433098889807, 0.01620791120771703, 0.0083827072451651, 0.000387129737681291, 0.027981307816580037, 0.0628405683879153, 0.011298296385658824, 0.011500555241186206, 0.0016669585985331636, 0.023432191240375544, 0.1563781796868332, 0.054777353969851506, 0.14547845661510383, 0.06195282818996617, 0.08658582842005813, 0.07481227181277006, 0.12011217402973906, 0.10199273091020367, 0.12243257351385928, 0.4652750784922265, 0.42339999226795366, 0.4385100782432323, 0.45222042220925274, 0.3852998466530637, 0.4411045134437097, 0.5173816476926005, 0.4278436488241346, 0.4326632947641472, 0.1419377211773455, 0.15111043508005528, 0.10875187591096869, 0.16111080211567785, 0.12232800048415815, 0.14157254166785005, 0.10110520080583396, 0.11976207023562835, 0.09984422409253368, 0.2088592341851796, 0.26035611512811496, 0.15612689120421985, 0.1665387162658346, 0.25884250143157606, 0.16325793609837858, 0.14158664540592236, 0.15123907158699001, 0.23383352240259514, 0.3184409763344268, 0.3107973034108662, 0.3253097469278561, 0.2935072316633316, 0.2966339087137133, 0.3129708321967115, 0.3034270714402877, 0.2791160903420954, 0.23805825760450738, 0.2621453738398759, 0.2638775703302114, 0.27701787661452415, 0.24280599860333507, 0.2732035439572398, 0.21661086396450968, 0.2438035638717545, 0.24857441373472378, 0.27990939261006575, 0.22428408329204108, 0.2154503058673316, 0.21284156819937028, 0.21357816873104074, 0.21525709680151672, 0.21531164546439674, 0.20808558819334932, 0.19646242205541575, 0.30300011574239993, 0.19150759594631195, 0.33282811116211064, 0.21459397400579727, 0.17599779098991442, 0.19350200526816874, 0.18069329583958893, 0.17854399600326054, 0.20567259055861464, 0.18904845114327917, 0.5786905156931705, 0.18537542109256144, 0.1739139011730223, 0.8279963895741265, 0.19820917750417222, 0.1990817141540161, 0.8276533514303538, 0.5976822919804159, 0.7880041672154312, 0.642886900480814, 0.38618420865347314, 0.6686867587552574, 0.5260838191342875, 0.16436389972336707, 0.38165196325612183, 0.10470859292645096, 0.10429653935836991, 0.3902738165486843, 0.18798296134970038, 0.19460032240864356, 0.17798069485398937, 0.19653672002785083, 0.1831958260578872, 0.1858485872513148, 0.19687221407942357, 0.17839775393623292, 0.191031008885446, 0.093174323598748, 0.09823732013719544, 0.09327236383605486, 0.09466672789424102, 0.10128587263231714, 0.07859846637352241, 0.08568660424637597, 0.08896341971774147, 0.09196127902881068]}, "mutation_prompt": null}
{"id": "81f18bb4-d1b6-4573-bc76-f0f16ef4eac8", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n        \n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.7 + 0.3 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.3 + 0.7 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment and restart mechanism\n            if evals % 500 == 0:  # More frequent local search for stuck situations\n                pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                pop_velocity = np.zeros_like(pop)\n                personal_best = np.copy(pop)\n                personal_best_scores = np.array([func(ind) for ind in personal_best])\n                evals += self.population_size\n\n            self.population_size = max(10, int(40 * (1 - evals / self.budget)))  # More aggressive shrinkage\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance convergence by varying the population size more adaptively and introducing a local search when stuck.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0450b9e5-266e-430b-a590-d349a8deb32e", "metadata": {"aucs": [0.8164195756494056, 0.8031872572484745, 0.7981962501001248, 0.8131225564221786, 0.7959314763104478, 0.8159998662454583, 0.8090775586870029, 0.8006111898269437, 0.8134346873442886, 0.6243917730717828, 0.6409613488746846, 0.6246065014104285, 0.6324330962371657, 0.6206267988292387, 0.6602978125663587, 0.6250778151442056, 0.6284297288630931, 0.6439013126697939, 0.16468275658009335, 0.1523742403417102, 0.14944011076747288, 0.14716212489162195, 0.14090427166772357, 0.12587880678527852, 0.13646435953101976, 0.1260808454423351, 0.1269074889641384, 0.12992090088605224, 0.13179453711442457, 0.11510077274071262, 0.14523343787680443, 0.1057840450887072, 0.12467044905865843, 0.13196596422219609, 0.15054869008726268, 0.13693992192926197, 0.9663096765456931, 0.9677332223840229, 0.9618773564657753, 0.9638852704863604, 0.9620637956010087, 0.9569925276456013, 0.9692532669982198, 0.9610165844843083, 0.9640342759298982, 0.6636107433678256, 0.689397734550597, 0.6682565674513377, 0.6916670030969504, 0.690871529705677, 0.5652380734053882, 0.6667720011864461, 0.6871262955424005, 0.6473159988560401, 0.22763517280017742, 0.2118816720146538, 0.7836262031264627, 0.84578012830147, 0.8203343143094035, 0.7744304099080812, 0.17460902341458462, 0.7953357547666624, 0.3757134550867367, 0.2107971195254189, 0.24651678371339114, 0.18269965187640447, 0.11814504410615212, 0.20027378772360638, 0.13075831823908413, 0.18405659724765, 0.1277671597237473, 0.17171183149166014, 0.14309816794389285, 0.2158639387776684, 0.1704826718779172, 0.23005345603411143, 0.20521122308868534, 0.1287205377626286, 0.38718778951761823, 0.16937928514143785, 0.20816433037503468, 0.03959176468957226, 9.999999999998899e-05, 0.00031421543773779703, 0.06403598872531935, 9.999999999998899e-05, 0.036110584892703135, 0.036694065018338606, 9.999999999998899e-05, 0.09482080258988312, 0.15810534866420334, 0.06485839267962179, 0.2017290099601835, 0.10096586964702814, 0.11422515328791394, 0.04802136278645486, 0.1293826885334014, 0.11759789281328425, 0.12608127874006236, 0.13380112040446168, 0.15891056752287636, 0.1514436027400523, 0.07031829799362277, 0.09650138311991263, 0.08318442293071604, 0.1912512508481211, 0.08295765018880286, 0.06502938132417624, 0.1499729323527983, 0.05542051459464292, 0.15327041455090762, 0.060783208333432204, 0.14882642972741777, 0.09160518239415383, 0.17220744833632617, 0.12354687710778145, 0.08002066681340947, 0.5298123484565177, 0.529285141836223, 0.45867080181005604, 0.6014561431684758, 0.5809646948813703, 0.535796068789504, 0.5565041868029215, 0.5686885175621472, 0.565138982294016, 0.1702038582845946, 0.11155316239271174, 0.12718560658188527, 0.13664661583402027, 0.14769810302095066, 0.09796032234223262, 0.10542028426953143, 0.13206163748123378, 0.16695854828833212, 0.26316510603854626, 0.18078049438937305, 0.17757744449420387, 0.36902492510643403, 0.3085390395537042, 0.2167927410806021, 0.20983864439674682, 0.18886006157122515, 0.224895107857373, 0.37181862721051095, 0.43398203125220447, 0.3840394953354527, 0.6457913645405944, 0.3218435105490979, 0.34741295279887063, 0.4716088830979944, 0.4821895714212573, 0.43218061949430386, 0.36060678281106084, 0.2663671896734999, 0.30649396587511746, 0.1979014575589807, 0.25267023352040685, 0.3400143003751097, 0.2443471266778784, 0.2829321350311348, 0.20498549838601265, 0.24500071852190564, 0.23030750191766336, 0.19860433573672553, 0.19753353415442265, 0.21220519246017333, 0.2441652194232553, 0.2068059052476896, 0.19171736585156307, 0.21698527097461062, 0.20832681704906386, 0.20666044854360677, 0.24248543275313206, 0.24048260646445752, 0.7136474683773988, 0.18904862232033293, 0.23574981141135742, 0.2388205240911917, 0.20674812472537218, 0.8554093136413741, 0.18618219756183085, 0.17509284781105072, 0.8880815933740098, 0.7370607668086624, 0.8676846685938672, 0.802427634092667, 0.20038380338638728, 0.15193343518505975, 0.736688440226879, 0.2097884435243943, 0.6450877980321346, 0.45733183821076595, 0.1659987174390537, 0.7743417556918712, 0.10446575563517091, 0.6634898619036615, 0.814670317470632, 0.19760660251995554, 0.20292063549860018, 0.19514375318972754, 0.20019641947623112, 0.1993269213963459, 0.17628382319001068, 0.19838985220839245, 0.19143968990205462, 0.23275128772514664, 0.0880041717212775, 0.0761057388855263, 0.10065148477971997, 0.09463972977891721, 0.09658997637279809, 0.10369392557241408, 0.10008295173801451, 0.08839558095476208, 0.0919158624489197]}, "mutation_prompt": null}
{"id": "41f23897-772f-4aec-9add-96316572882e", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n        \n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.7 + 0.3 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.3 + 0.7 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment and restart mechanism\n            if evals % 500 == 0:  # More frequent local search for stuck situations\n                pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                pop_velocity = np.zeros_like(pop)\n                personal_best = np.copy(pop)\n                personal_best_scores = np.array([func(ind) for ind in personal_best])\n                evals += self.population_size\n\n            self.population_size = max(10, int(40 * (1 - evals / self.budget)))  # More aggressive shrinkage\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance convergence by varying the population size more adaptively and introducing a local search when stuck.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0450b9e5-266e-430b-a590-d349a8deb32e", "metadata": {"aucs": [0.8164195756494056, 0.8031872572484745, 0.7981962501001248, 0.8131225564221786, 0.7959314763104478, 0.8159998662454583, 0.8090775586870029, 0.8006111898269437, 0.8134346873442886, 0.6243917730717828, 0.6409613488746846, 0.6246065014104285, 0.6324330962371657, 0.6206267988292387, 0.6602978125663587, 0.6250778151442056, 0.6284297288630931, 0.6439013126697939, 0.16468275658009335, 0.1523742403417102, 0.14944011076747288, 0.14716212489162195, 0.14090427166772357, 0.12587880678527852, 0.13646435953101976, 0.1260808454423351, 0.1269074889641384, 0.12992090088605224, 0.13179453711442457, 0.11510077274071262, 0.14523343787680443, 0.1057840450887072, 0.12467044905865843, 0.13196596422219609, 0.15054869008726268, 0.13693992192926197, 0.9663096765456931, 0.9677332223840229, 0.9618773564657753, 0.9638852704863604, 0.9620637956010087, 0.9569925276456013, 0.9692532669982198, 0.9610165844843083, 0.9640342759298982, 0.6636107433678256, 0.689397734550597, 0.6682565674513377, 0.6916670030969504, 0.690871529705677, 0.5652380734053882, 0.6667720011864461, 0.6871262955424005, 0.6473159988560401, 0.22763517280017742, 0.2118816720146538, 0.7836262031264627, 0.84578012830147, 0.8203343143094035, 0.7744304099080812, 0.17460902341458462, 0.7953357547666624, 0.3757134550867367, 0.2107971195254189, 0.24651678371339114, 0.18269965187640447, 0.11814504410615212, 0.20027378772360638, 0.13075831823908413, 0.18405659724765, 0.1277671597237473, 0.17171183149166014, 0.14309816794389285, 0.2158639387776684, 0.1704826718779172, 0.23005345603411143, 0.20521122308868534, 0.1287205377626286, 0.38718778951761823, 0.16937928514143785, 0.20816433037503468, 0.03959176468957226, 9.999999999998899e-05, 0.00031421543773779703, 0.06403598872531935, 9.999999999998899e-05, 0.036110584892703135, 0.036694065018338606, 9.999999999998899e-05, 0.09482080258988312, 0.15810534866420334, 0.06485839267962179, 0.2017290099601835, 0.10096586964702814, 0.11422515328791394, 0.04802136278645486, 0.1293826885334014, 0.11759789281328425, 0.12608127874006236, 0.13380112040446168, 0.15891056752287636, 0.1514436027400523, 0.07031829799362277, 0.09650138311991263, 0.08318442293071604, 0.1912512508481211, 0.08295765018880286, 0.06502938132417624, 0.1499729323527983, 0.05542051459464292, 0.15327041455090762, 0.060783208333432204, 0.14882642972741777, 0.09160518239415383, 0.17220744833632617, 0.12354687710778145, 0.08002066681340947, 0.5298123484565177, 0.529285141836223, 0.45867080181005604, 0.6014561431684758, 0.5809646948813703, 0.535796068789504, 0.5565041868029215, 0.5686885175621472, 0.565138982294016, 0.1702038582845946, 0.11155316239271174, 0.12718560658188527, 0.13664661583402027, 0.14769810302095066, 0.09796032234223262, 0.10542028426953143, 0.13206163748123378, 0.16695854828833212, 0.26316510603854626, 0.18078049438937305, 0.17757744449420387, 0.36902492510643403, 0.3085390395537042, 0.2167927410806021, 0.20983864439674682, 0.18886006157122515, 0.224895107857373, 0.37181862721051095, 0.43398203125220447, 0.3840394953354527, 0.6457913645405944, 0.3218435105490979, 0.34741295279887063, 0.4716088830979944, 0.4821895714212573, 0.43218061949430386, 0.36060678281106084, 0.2663671896734999, 0.30649396587511746, 0.1979014575589807, 0.25267023352040685, 0.3400143003751097, 0.2443471266778784, 0.2829321350311348, 0.20498549838601265, 0.24500071852190564, 0.23030750191766336, 0.19860433573672553, 0.19753353415442265, 0.21220519246017333, 0.2441652194232553, 0.2068059052476896, 0.19171736585156307, 0.21698527097461062, 0.20832681704906386, 0.20666044854360677, 0.24248543275313206, 0.24048260646445752, 0.7136474683773988, 0.18904862232033293, 0.23574981141135742, 0.2388205240911917, 0.20674812472537218, 0.8554093136413741, 0.18618219756183085, 0.17509284781105072, 0.8880815933740098, 0.7370607668086624, 0.8676846685938672, 0.802427634092667, 0.20038380338638728, 0.15193343518505975, 0.736688440226879, 0.2097884435243943, 0.6450877980321346, 0.45733183821076595, 0.1659987174390537, 0.7743417556918712, 0.10446575563517091, 0.6634898619036615, 0.814670317470632, 0.19760660251995554, 0.20292063549860018, 0.19514375318972754, 0.20019641947623112, 0.1993269213963459, 0.17628382319001068, 0.19838985220839245, 0.19143968990205462, 0.23275128772514664, 0.0880041717212775, 0.0761057388855263, 0.10065148477971997, 0.09463972977891721, 0.09658997637279809, 0.10369392557241408, 0.10008295173801451, 0.08839558095476208, 0.0919158624489197]}, "mutation_prompt": null}
{"id": "986ca8d9-9252-4344-aad0-06cb6ffc0884", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n        \n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.7 + 0.3 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.3 + 0.7 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment and restart mechanism\n            if evals % 500 == 0:  # More frequent local search for stuck situations\n                pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                pop_velocity = np.zeros_like(pop)\n                personal_best = np.copy(pop)\n                personal_best_scores = np.array([func(ind) for ind in personal_best])\n                evals += self.population_size\n\n            self.population_size = max(10, int(40 * (1 - evals / self.budget)))  # More aggressive shrinkage\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance convergence by varying the population size more adaptively and introducing a local search when stuck.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0450b9e5-266e-430b-a590-d349a8deb32e", "metadata": {"aucs": [0.8164195756494056, 0.8031872572484745, 0.7981962501001248, 0.8131225564221786, 0.7959314763104478, 0.8159998662454583, 0.8090775586870029, 0.8006111898269437, 0.8134346873442886, 0.6243917730717828, 0.6409613488746846, 0.6246065014104285, 0.6324330962371657, 0.6206267988292387, 0.6602978125663587, 0.6250778151442056, 0.6284297288630931, 0.6439013126697939, 0.16468275658009335, 0.1523742403417102, 0.14944011076747288, 0.14716212489162195, 0.14090427166772357, 0.12587880678527852, 0.13646435953101976, 0.1260808454423351, 0.1269074889641384, 0.12992090088605224, 0.13179453711442457, 0.11510077274071262, 0.14523343787680443, 0.1057840450887072, 0.12467044905865843, 0.13196596422219609, 0.15054869008726268, 0.13693992192926197, 0.9663096765456931, 0.9677332223840229, 0.9618773564657753, 0.9638852704863604, 0.9620637956010087, 0.9569925276456013, 0.9692532669982198, 0.9610165844843083, 0.9640342759298982, 0.6636107433678256, 0.689397734550597, 0.6682565674513377, 0.6916670030969504, 0.690871529705677, 0.5652380734053882, 0.6667720011864461, 0.6871262955424005, 0.6473159988560401, 0.22763517280017742, 0.2118816720146538, 0.7836262031264627, 0.84578012830147, 0.8203343143094035, 0.7744304099080812, 0.17460902341458462, 0.7953357547666624, 0.3757134550867367, 0.2107971195254189, 0.24651678371339114, 0.18269965187640447, 0.11814504410615212, 0.20027378772360638, 0.13075831823908413, 0.18405659724765, 0.1277671597237473, 0.17171183149166014, 0.14309816794389285, 0.2158639387776684, 0.1704826718779172, 0.23005345603411143, 0.20521122308868534, 0.1287205377626286, 0.38718778951761823, 0.16937928514143785, 0.20816433037503468, 0.03959176468957226, 9.999999999998899e-05, 0.00031421543773779703, 0.06403598872531935, 9.999999999998899e-05, 0.036110584892703135, 0.036694065018338606, 9.999999999998899e-05, 0.09482080258988312, 0.15810534866420334, 0.06485839267962179, 0.2017290099601835, 0.10096586964702814, 0.11422515328791394, 0.04802136278645486, 0.1293826885334014, 0.11759789281328425, 0.12608127874006236, 0.13380112040446168, 0.15891056752287636, 0.1514436027400523, 0.07031829799362277, 0.09650138311991263, 0.08318442293071604, 0.1912512508481211, 0.08295765018880286, 0.06502938132417624, 0.1499729323527983, 0.05542051459464292, 0.15327041455090762, 0.060783208333432204, 0.14882642972741777, 0.09160518239415383, 0.17220744833632617, 0.12354687710778145, 0.08002066681340947, 0.5298123484565177, 0.529285141836223, 0.45867080181005604, 0.6014561431684758, 0.5809646948813703, 0.535796068789504, 0.5565041868029215, 0.5686885175621472, 0.565138982294016, 0.1702038582845946, 0.11155316239271174, 0.12718560658188527, 0.13664661583402027, 0.14769810302095066, 0.09796032234223262, 0.10542028426953143, 0.13206163748123378, 0.16695854828833212, 0.26316510603854626, 0.18078049438937305, 0.17757744449420387, 0.36902492510643403, 0.3085390395537042, 0.2167927410806021, 0.20983864439674682, 0.18886006157122515, 0.224895107857373, 0.37181862721051095, 0.43398203125220447, 0.3840394953354527, 0.6457913645405944, 0.3218435105490979, 0.34741295279887063, 0.4716088830979944, 0.4821895714212573, 0.43218061949430386, 0.36060678281106084, 0.2663671896734999, 0.30649396587511746, 0.1979014575589807, 0.25267023352040685, 0.3400143003751097, 0.2443471266778784, 0.2829321350311348, 0.20498549838601265, 0.24500071852190564, 0.23030750191766336, 0.19860433573672553, 0.19753353415442265, 0.21220519246017333, 0.2441652194232553, 0.2068059052476896, 0.19171736585156307, 0.21698527097461062, 0.20832681704906386, 0.20666044854360677, 0.24248543275313206, 0.24048260646445752, 0.7136474683773988, 0.18904862232033293, 0.23574981141135742, 0.2388205240911917, 0.20674812472537218, 0.8554093136413741, 0.18618219756183085, 0.17509284781105072, 0.8880815933740098, 0.7370607668086624, 0.8676846685938672, 0.802427634092667, 0.20038380338638728, 0.15193343518505975, 0.736688440226879, 0.2097884435243943, 0.6450877980321346, 0.45733183821076595, 0.1659987174390537, 0.7743417556918712, 0.10446575563517091, 0.6634898619036615, 0.814670317470632, 0.19760660251995554, 0.20292063549860018, 0.19514375318972754, 0.20019641947623112, 0.1993269213963459, 0.17628382319001068, 0.19838985220839245, 0.19143968990205462, 0.23275128772514664, 0.0880041717212775, 0.0761057388855263, 0.10065148477971997, 0.09463972977891721, 0.09658997637279809, 0.10369392557241408, 0.10008295173801451, 0.08839558095476208, 0.0919158624489197]}, "mutation_prompt": null}
{"id": "3dfc4ab4-02d3-4465-ad62-f7f0f0efe04f", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n        \n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.6, 1.4)  # Fine-tuned\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.7 + 0.3 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.4 + 0.6 * evals / self.budget)  # Fine-tuned\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Integrate local search with gradient information\n            if evals % 500 == 0:\n                gradient = np.gradient([func(ind) for ind in pop])\n                pop = clip(pop - 0.01 * gradient)  # Local search step\n                pop_velocity = np.zeros_like(pop)\n                personal_best = np.copy(pop)\n                personal_best_scores = np.array([func(ind) for ind in personal_best])\n                evals += self.population_size\n\n            self.population_size = max(10, int(40 * (1 - evals / self.budget)))  # More aggressive shrinkage\n\n        return global_best", "name": "HybridDEPSO", "description": "Improve convergence by integrating a local search with gradient information and fine-tuning the dynamic parameters.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (40,5) (40,) ').", "error": "ValueError('operands could not be broadcast together with shapes (40,5) (40,) ')", "parent_id": "0450b9e5-266e-430b-a590-d349a8deb32e", "metadata": {}, "mutation_prompt": null}
{"id": "093f3354-0f8c-4f39-8b6e-556f804cb241", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n        \n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.7 + 0.3 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.3 + 0.7 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment and restart mechanism\n            if evals % 500 == 0:  # More frequent local search for stuck situations\n                pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                pop_velocity = np.zeros_like(pop)\n                personal_best = np.copy(pop)\n                personal_best_scores = np.array([func(ind) for ind in personal_best])\n                evals += self.population_size\n\n            self.population_size = max(10, int(40 * (1 - evals / self.budget)))  # More aggressive shrinkage\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance convergence by varying the population size more adaptively and introducing a local search when stuck.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0450b9e5-266e-430b-a590-d349a8deb32e", "metadata": {"aucs": [0.8164195756494056, 0.8031872572484745, 0.7981962501001248, 0.8131225564221786, 0.7959314763104478, 0.8159998662454583, 0.8090775586870029, 0.8006111898269437, 0.8134346873442886, 0.6243917730717828, 0.6409613488746846, 0.6246065014104285, 0.6324330962371657, 0.6206267988292387, 0.6602978125663587, 0.6250778151442056, 0.6284297288630931, 0.6439013126697939, 0.16468275658009335, 0.1523742403417102, 0.14944011076747288, 0.14716212489162195, 0.14090427166772357, 0.12587880678527852, 0.13646435953101976, 0.1260808454423351, 0.1269074889641384, 0.12992090088605224, 0.13179453711442457, 0.11510077274071262, 0.14523343787680443, 0.1057840450887072, 0.12467044905865843, 0.13196596422219609, 0.15054869008726268, 0.13693992192926197, 0.9663096765456931, 0.9677332223840229, 0.9618773564657753, 0.9638852704863604, 0.9620637956010087, 0.9569925276456013, 0.9692532669982198, 0.9610165844843083, 0.9640342759298982, 0.6636107433678256, 0.689397734550597, 0.6682565674513377, 0.6916670030969504, 0.690871529705677, 0.5652380734053882, 0.6667720011864461, 0.6871262955424005, 0.6473159988560401, 0.22763517280017742, 0.2118816720146538, 0.7836262031264627, 0.84578012830147, 0.8203343143094035, 0.7744304099080812, 0.17460902341458462, 0.7953357547666624, 0.3757134550867367, 0.2107971195254189, 0.24651678371339114, 0.18269965187640447, 0.11814504410615212, 0.20027378772360638, 0.13075831823908413, 0.18405659724765, 0.1277671597237473, 0.17171183149166014, 0.14309816794389285, 0.2158639387776684, 0.1704826718779172, 0.23005345603411143, 0.20521122308868534, 0.1287205377626286, 0.38718778951761823, 0.16937928514143785, 0.20816433037503468, 0.03959176468957226, 9.999999999998899e-05, 0.00031421543773779703, 0.06403598872531935, 9.999999999998899e-05, 0.036110584892703135, 0.036694065018338606, 9.999999999998899e-05, 0.09482080258988312, 0.15810534866420334, 0.06485839267962179, 0.2017290099601835, 0.10096586964702814, 0.11422515328791394, 0.04802136278645486, 0.1293826885334014, 0.11759789281328425, 0.12608127874006236, 0.13380112040446168, 0.15891056752287636, 0.1514436027400523, 0.07031829799362277, 0.09650138311991263, 0.08318442293071604, 0.1912512508481211, 0.08295765018880286, 0.06502938132417624, 0.1499729323527983, 0.05542051459464292, 0.15327041455090762, 0.060783208333432204, 0.14882642972741777, 0.09160518239415383, 0.17220744833632617, 0.12354687710778145, 0.08002066681340947, 0.5298123484565177, 0.529285141836223, 0.45867080181005604, 0.6014561431684758, 0.5809646948813703, 0.535796068789504, 0.5565041868029215, 0.5686885175621472, 0.565138982294016, 0.1702038582845946, 0.11155316239271174, 0.12718560658188527, 0.13664661583402027, 0.14769810302095066, 0.09796032234223262, 0.10542028426953143, 0.13206163748123378, 0.16695854828833212, 0.26316510603854626, 0.18078049438937305, 0.17757744449420387, 0.36902492510643403, 0.3085390395537042, 0.2167927410806021, 0.20983864439674682, 0.18886006157122515, 0.224895107857373, 0.37181862721051095, 0.43398203125220447, 0.3840394953354527, 0.6457913645405944, 0.3218435105490979, 0.34741295279887063, 0.4716088830979944, 0.4821895714212573, 0.43218061949430386, 0.36060678281106084, 0.2663671896734999, 0.30649396587511746, 0.1979014575589807, 0.25267023352040685, 0.3400143003751097, 0.2443471266778784, 0.2829321350311348, 0.20498549838601265, 0.24500071852190564, 0.23030750191766336, 0.19860433573672553, 0.19753353415442265, 0.21220519246017333, 0.2441652194232553, 0.2068059052476896, 0.19171736585156307, 0.21698527097461062, 0.20832681704906386, 0.20666044854360677, 0.24248543275313206, 0.24048260646445752, 0.7136474683773988, 0.18904862232033293, 0.23574981141135742, 0.2388205240911917, 0.20674812472537218, 0.8554093136413741, 0.18618219756183085, 0.17509284781105072, 0.8880815933740098, 0.7370607668086624, 0.8676846685938672, 0.802427634092667, 0.20038380338638728, 0.15193343518505975, 0.736688440226879, 0.2097884435243943, 0.6450877980321346, 0.45733183821076595, 0.1659987174390537, 0.7743417556918712, 0.10446575563517091, 0.6634898619036615, 0.814670317470632, 0.19760660251995554, 0.20292063549860018, 0.19514375318972754, 0.20019641947623112, 0.1993269213963459, 0.17628382319001068, 0.19838985220839245, 0.19143968990205462, 0.23275128772514664, 0.0880041717212775, 0.0761057388855263, 0.10065148477971997, 0.09463972977891721, 0.09658997637279809, 0.10369392557241408, 0.10008295173801451, 0.08839558095476208, 0.0919158624489197]}, "mutation_prompt": null}
{"id": "69c06b64-cbde-44d7-9ac1-ee95bfd72c61", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n        \n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.7 + 0.3 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.3 + 0.7 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment and restart mechanism\n            if evals % 500 == 0:  # More frequent local search for stuck situations\n                pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                pop_velocity = np.zeros_like(pop)\n                personal_best = np.copy(pop)\n                personal_best_scores = np.array([func(ind) for ind in personal_best])\n                evals += self.population_size\n\n            self.population_size = max(10, int(40 * (1 - evals / self.budget)))  # More aggressive shrinkage\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance convergence by varying the population size more adaptively and introducing a local search when stuck.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0450b9e5-266e-430b-a590-d349a8deb32e", "metadata": {"aucs": [0.8164195756494056, 0.8031872572484745, 0.7981962501001248, 0.8131225564221786, 0.7959314763104478, 0.8159998662454583, 0.8090775586870029, 0.8006111898269437, 0.8134346873442886, 0.6243917730717828, 0.6409613488746846, 0.6246065014104285, 0.6324330962371657, 0.6206267988292387, 0.6602978125663587, 0.6250778151442056, 0.6284297288630931, 0.6439013126697939, 0.16468275658009335, 0.1523742403417102, 0.14944011076747288, 0.14716212489162195, 0.14090427166772357, 0.12587880678527852, 0.13646435953101976, 0.1260808454423351, 0.1269074889641384, 0.12992090088605224, 0.13179453711442457, 0.11510077274071262, 0.14523343787680443, 0.1057840450887072, 0.12467044905865843, 0.13196596422219609, 0.15054869008726268, 0.13693992192926197, 0.9663096765456931, 0.9677332223840229, 0.9618773564657753, 0.9638852704863604, 0.9620637956010087, 0.9569925276456013, 0.9692532669982198, 0.9610165844843083, 0.9640342759298982, 0.6636107433678256, 0.689397734550597, 0.6682565674513377, 0.6916670030969504, 0.690871529705677, 0.5652380734053882, 0.6667720011864461, 0.6871262955424005, 0.6473159988560401, 0.22763517280017742, 0.2118816720146538, 0.7836262031264627, 0.84578012830147, 0.8203343143094035, 0.7744304099080812, 0.17460902341458462, 0.7953357547666624, 0.3757134550867367, 0.2107971195254189, 0.24651678371339114, 0.18269965187640447, 0.11814504410615212, 0.20027378772360638, 0.13075831823908413, 0.18405659724765, 0.1277671597237473, 0.17171183149166014, 0.14309816794389285, 0.2158639387776684, 0.1704826718779172, 0.23005345603411143, 0.20521122308868534, 0.1287205377626286, 0.38718778951761823, 0.16937928514143785, 0.20816433037503468, 0.03959176468957226, 9.999999999998899e-05, 0.00031421543773779703, 0.06403598872531935, 9.999999999998899e-05, 0.036110584892703135, 0.036694065018338606, 9.999999999998899e-05, 0.09482080258988312, 0.15810534866420334, 0.06485839267962179, 0.2017290099601835, 0.10096586964702814, 0.11422515328791394, 0.04802136278645486, 0.1293826885334014, 0.11759789281328425, 0.12608127874006236, 0.13380112040446168, 0.15891056752287636, 0.1514436027400523, 0.07031829799362277, 0.09650138311991263, 0.08318442293071604, 0.1912512508481211, 0.08295765018880286, 0.06502938132417624, 0.1499729323527983, 0.05542051459464292, 0.15327041455090762, 0.060783208333432204, 0.14882642972741777, 0.09160518239415383, 0.17220744833632617, 0.12354687710778145, 0.08002066681340947, 0.5298123484565177, 0.529285141836223, 0.45867080181005604, 0.6014561431684758, 0.5809646948813703, 0.535796068789504, 0.5565041868029215, 0.5686885175621472, 0.565138982294016, 0.1702038582845946, 0.11155316239271174, 0.12718560658188527, 0.13664661583402027, 0.14769810302095066, 0.09796032234223262, 0.10542028426953143, 0.13206163748123378, 0.16695854828833212, 0.26316510603854626, 0.18078049438937305, 0.17757744449420387, 0.36902492510643403, 0.3085390395537042, 0.2167927410806021, 0.20983864439674682, 0.18886006157122515, 0.224895107857373, 0.37181862721051095, 0.43398203125220447, 0.3840394953354527, 0.6457913645405944, 0.3218435105490979, 0.34741295279887063, 0.4716088830979944, 0.4821895714212573, 0.43218061949430386, 0.36060678281106084, 0.2663671896734999, 0.30649396587511746, 0.1979014575589807, 0.25267023352040685, 0.3400143003751097, 0.2443471266778784, 0.2829321350311348, 0.20498549838601265, 0.24500071852190564, 0.23030750191766336, 0.19860433573672553, 0.19753353415442265, 0.21220519246017333, 0.2441652194232553, 0.2068059052476896, 0.19171736585156307, 0.21698527097461062, 0.20832681704906386, 0.20666044854360677, 0.24248543275313206, 0.24048260646445752, 0.7136474683773988, 0.18904862232033293, 0.23574981141135742, 0.2388205240911917, 0.20674812472537218, 0.8554093136413741, 0.18618219756183085, 0.17509284781105072, 0.8880815933740098, 0.7370607668086624, 0.8676846685938672, 0.802427634092667, 0.20038380338638728, 0.15193343518505975, 0.736688440226879, 0.2097884435243943, 0.6450877980321346, 0.45733183821076595, 0.1659987174390537, 0.7743417556918712, 0.10446575563517091, 0.6634898619036615, 0.814670317470632, 0.19760660251995554, 0.20292063549860018, 0.19514375318972754, 0.20019641947623112, 0.1993269213963459, 0.17628382319001068, 0.19838985220839245, 0.19143968990205462, 0.23275128772514664, 0.0880041717212775, 0.0761057388855263, 0.10065148477971997, 0.09463972977891721, 0.09658997637279809, 0.10369392557241408, 0.10008295173801451, 0.08839558095476208, 0.0919158624489197]}, "mutation_prompt": null}
{"id": "295a07cd-c9a6-49a0-b056-1ca6a7199946", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n        \n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * (1 - (evals/self.budget)**2)  # Nonlinear adaptation\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - (evals/self.budget)**3)  # Nonlinear adaptation\n                dynamic_cognitive_constant = self.cognitive_constant * (0.7 + 0.3 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.3 + 0.7 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment and restart mechanism\n            if evals % 500 == 0:  # More frequent local search for stuck situations\n                pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                pop_velocity = np.zeros_like(pop)\n                personal_best = np.copy(pop)\n                personal_best_scores = np.array([func(ind) for ind in personal_best])\n                evals += self.population_size\n\n            self.population_size = max(10, int(40 * (1 - evals / self.budget)))  # More aggressive shrinkage\n\n        return global_best", "name": "HybridDEPSO", "description": "Introduce adaptive control of mutation factor and inertia weight using nonlinear functions for better exploration-exploitation balance.", "configspace": "", "generation": 95, "fitness": 0.31779354306990765, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "0450b9e5-266e-430b-a590-d349a8deb32e", "metadata": {"aucs": [0.7699655889182905, 0.759961094612337, 0.7437740911414081, 0.7465714170788251, 0.7360461666513312, 0.7177364578338066, 0.7063801528664788, 0.7603388483980432, 0.7409788730754723, 0.4849629777073433, 0.5156683750255016, 0.5127582841716536, 0.5229768820443783, 0.519581488101157, 0.5234971961199572, 0.49240775365687406, 0.5309610514513127, 0.46344698563551256, 0.47920358795754636, 0.15178294506995293, 0.13438009140413665, 0.11039089299604932, 0.11763258001674892, 0.15568455150938953, 0.16534828331175266, 0.14595826273594725, 0.1345853274749501, 0.1161457241844771, 0.12853541353818387, 0.12306342159791406, 0.11708821757448984, 0.10510238570429864, 0.10539830633551595, 0.10128790862088322, 0.11419815635566755, 0.12932545750733915, 0.9638322834103269, 0.9706420247969142, 0.9710742736598589, 0.9646202409985103, 0.9614872093197548, 0.9635518559236003, 0.9634895263984574, 0.9618210571744628, 0.9648031489726, 0.6348189327193614, 0.5054064188640084, 0.6114423238401, 0.6116478800844869, 0.6003045328399119, 0.6277038177834267, 0.5691206807362104, 0.5936973685203581, 0.6186366496373239, 0.3480341756724732, 0.20697906385117415, 0.6900557973584405, 0.7184047474781522, 0.7094596579457921, 0.27151549106438644, 0.22185209202889278, 0.22785970202646866, 0.7662508135136923, 0.20908601149133033, 0.2066554711972437, 0.23035712263919417, 0.2126095033201767, 0.21190592429157162, 0.12730780866412605, 0.20265023589039632, 0.11464194601392597, 0.23140191700113488, 0.22397741702763474, 0.2033175768215827, 0.12698137674257848, 0.24810199548398426, 0.22612780284254608, 0.23263398230431398, 0.24534194088229455, 0.22893644254370193, 0.2463678000645143, 9.999999999998899e-05, 0.0860372819486438, 0.07649858212687033, 0.02937868230721341, 0.04590668192857883, 9.999999999998899e-05, 0.060873938396347915, 0.00716573221464023, 0.058277579416308845, 0.09395011080797466, 0.07401949431815624, 0.08011996285207001, 0.06040815127509647, 0.032963429228440866, 0.06039806466324937, 0.07368701720191262, 0.09802212275789457, 0.1667868398679606, 0.03827834426545773, 0.07585974234469117, 0.12933522422093757, 0.06433202310575925, 0.15933008243329205, 0.10390835685495747, 0.06320690860066103, 0.06964398612199552, 0.15929689783011758, 0.1757722746214576, 0.06267200040172916, 0.10406894238614472, 0.08743469990991248, 0.08790529555316828, 0.2980555557634722, 0.07784714700572204, 0.0541605491108339, 0.08419777099867065, 0.5068877797521125, 0.5310613688304976, 0.47972721519251305, 0.5072706515691503, 0.5253746777664952, 0.49159947839418705, 0.5141989519027634, 0.5095991867246474, 0.5170807647167753, 0.13723657691288993, 0.10824098919054326, 0.0922686838258654, 0.15413599481160178, 0.1109399825307662, 0.13437035693711274, 0.10416909698479881, 0.11734387216500186, 0.1316026201939423, 0.3034534315678076, 0.23881047211101558, 0.16734006011721736, 0.20792324658981565, 0.23682872112537345, 0.19993392675657173, 0.20695225620224877, 0.25742680755258984, 0.20091467267296093, 0.24852047020304313, 0.38979070651303627, 0.33117035332687605, 0.42104565413832407, 0.39448498199930804, 0.4556855732908248, 0.44884767067304276, 0.4281913128864012, 0.39769766196419853, 0.37007458890956246, 0.24448693215849093, 0.2833449092729976, 0.22623065621322802, 0.18058839979778563, 0.19776003869193892, 0.23305120556451153, 0.3062564616881871, 0.23837280984679088, 0.21570272432408788, 0.2003508667588746, 0.18833255456465636, 0.20432758314243094, 0.23486043593917372, 0.24273643766827513, 0.21794984157217046, 0.21918913055460632, 0.2222747552849209, 0.23122581200956394, 0.5656062746696049, 0.21049734018408928, 0.6191985524876169, 0.2114638481483666, 0.2132589252772401, 0.22791064958859664, 0.23485178096492487, 0.24322160015594796, 0.19567897090110942, 0.18568280697538364, 0.7742521238907263, 0.8122496520179073, 0.199468930096814, 0.79754357322332, 0.7920827953948264, 0.8006464912347946, 0.1973168299687027, 0.7569231826733801, 0.21123278253760613, 0.7625356392780074, 0.7298814648728364, 0.16853099775482328, 0.14901407338078554, 0.15129415345661235, 0.6619823393083766, 0.6945686179799905, 0.19295975433348644, 0.19143046535305686, 0.19379248125336024, 0.18710430961666558, 0.19279911296441854, 0.1832844592543471, 0.1831210486388315, 0.18949068114948509, 0.1956407041452206, 0.14132126790274546, 0.09536821883388547, 0.07862533007320793, 0.09238453015176273, 0.08568297693298244, 0.09054215995813375, 0.09707280772657101, 0.10041242366722547, 0.09019708960104222]}, "mutation_prompt": null}
{"id": "96040ec7-55a5-42cf-8d0f-1674b66e1a2e", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n        \n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                diversity_factor = np.std(pop, axis=0).mean() / (self.upper_bound - self.lower_bound)\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5) * (1 + 0.5 * diversity_factor)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.7 + 0.3 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.3 + 0.7 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment and restart mechanism\n            if evals % 500 == 0:  # More frequent local search for stuck situations\n                pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                pop_velocity = np.zeros_like(pop)\n                personal_best = np.copy(pop)\n                personal_best_scores = np.array([func(ind) for ind in personal_best])\n                evals += self.population_size\n\n            self.population_size = max(10, int(40 * (1 - evals / self.budget)))  # More aggressive shrinkage\n\n        return global_best", "name": "HybridDEPSO", "description": "Refine convergence by introducing a dynamic mutation factor adjustment based on diversity and adaptive crossover rates.", "configspace": "", "generation": 96, "fitness": 0.3292123358208102, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "0450b9e5-266e-430b-a590-d349a8deb32e", "metadata": {"aucs": [0.8036803100710568, 0.8009389060115633, 0.8086835661526548, 0.8200220615105295, 0.7855494374328871, 0.8080785807281785, 0.8079427509902143, 0.8124173306770475, 0.8109304688262604, 0.6526342157150402, 0.5549262817357338, 0.5977845212174229, 0.6312903623702562, 0.6445177308472954, 0.6427705563979558, 0.6234456462048865, 0.6522377830046011, 0.6263254441223549, 0.16874376486850018, 0.14608981918751962, 0.6362444833185226, 0.14711449008524125, 0.5809655776049782, 0.17011363977592409, 0.11525520883483353, 0.12951983650999388, 0.6567367250900541, 0.12349589156220298, 0.14042438686905656, 0.10775845304798826, 0.1355142958680624, 0.14155262881887432, 0.10618912601864217, 0.09956104899921325, 0.12355698411660887, 0.11695834449683573, 0.9646182757188353, 0.9653378352732901, 0.9618524653187415, 0.9677134346479258, 0.9621199429600154, 0.9597077621329926, 0.9689415685995593, 0.9631707865329011, 0.963929945605122, 0.6812999230197418, 0.6655767419846328, 0.6827089897875627, 0.6599953897373537, 0.6957520553491274, 0.659276040533272, 0.564516838661014, 0.673573604721256, 0.5762505316239679, 0.3690005295287707, 0.37513271077243426, 0.7652214862039648, 0.271791914056415, 0.32300321396697695, 0.25982943113384505, 0.22455667933610823, 0.20036181942350995, 0.3425558513042789, 0.18430996912828745, 0.1830209622167297, 0.1307577419309055, 0.11051319384822889, 0.16688293314380276, 0.1320032057338122, 0.18593454465004045, 0.308797842217822, 0.1952123264707083, 0.2015099926261078, 0.2070297284241015, 0.27877635286061786, 0.22599907727483004, 0.19833161750798511, 0.17152620309830313, 0.1267669175460966, 0.21888664658873136, 0.19391702481093476, 9.999999999998899e-05, 9.999999999998899e-05, 0.026725592772206652, 9.999999999998899e-05, 9.999999999998899e-05, 0.039620649492562054, 0.007902471781127463, 9.999999999998899e-05, 0.1024102319752761, 0.07753878841941719, 0.08103592817642602, 0.09477451105511703, 0.11513605195920285, 0.0233385412501409, 0.11121553101158066, 0.09241392828379902, 0.1493863582319982, 0.06001593041223985, 0.1543257827237643, 0.18142893226951662, 0.16203148079888308, 0.07167541602345773, 0.07125527161053546, 0.06606577660777968, 0.08401798269656535, 0.14133258873227916, 0.0915534088822324, 0.2876985631117259, 0.026378499443490577, 0.22802692869606667, 0.03269179047344095, 0.16906935314557447, 0.1427895034962603, 0.13535164905222974, 0.19851527588464146, 0.08330541368711586, 0.5047191581356397, 0.4938751606332309, 0.5698076711907194, 0.5219302398196501, 0.5202590123389631, 0.4837355686709903, 0.5402341658262297, 0.5667305688520756, 0.5487660697911025, 0.1449481216240487, 0.11539506404091171, 0.10936172289151125, 0.1155374209402189, 0.15762723261676548, 0.10966735605792732, 0.10393211252064116, 0.13672359371178644, 0.14412706186040303, 0.27560704731196906, 0.17888795850770023, 0.2728355837978673, 0.1754119225376073, 0.15428058768200792, 0.17860129570773786, 0.2138353702503416, 0.21979123667535427, 0.2552274381505947, 0.38974264910472145, 0.34077418402195847, 0.3710484446047073, 0.42771809036563724, 0.31587428926876604, 0.3471408404885066, 0.46339698492696557, 0.3244170643512325, 0.29224896347711915, 0.2797710794782515, 0.236958864218907, 0.17370181303683985, 0.27743595958360023, 0.22812237584640838, 0.28741797868450336, 0.34084702974824943, 0.3670530128484716, 0.26142790238062164, 0.24489011493120982, 0.20959148963443963, 0.25013210522616114, 0.22681876506779075, 0.23441055270265365, 0.2341195929382437, 0.27762756520944387, 0.2034566335945237, 0.21654927660280587, 0.20282508280496658, 0.2348617544324878, 0.24085948960772607, 0.20302447345113062, 0.21875666091851487, 0.2051767790197665, 0.6917001819722681, 0.21600604982163885, 0.20377038458005814, 0.8092391812424019, 0.18683663243129245, 0.1990820607481898, 0.8511754816157755, 0.7613360093022654, 0.8894732412357681, 0.4143507955091348, 0.7669374784493806, 0.1521764243376743, 0.5510190580955705, 0.512351698239708, 0.12641914877702543, 0.7505340141707114, 0.4372048014347315, 0.3979766629222955, 0.3121397726366587, 0.45271303601439183, 0.7279635290865398, 0.1998852674901439, 0.1907873777431881, 0.19783083092737974, 0.20018783534517592, 0.21477789996800223, 0.18223980709067267, 0.21082201589047977, 0.19503837475303365, 0.1834489518870217, 0.09551404294646804, 0.0964652310403028, 0.09152646976763368, 0.09858219449955519, 0.08378657610976203, 0.11768283289530279, 0.07783176544541548, 0.0983194693958801, 0.09720750749747364]}, "mutation_prompt": null}
{"id": "a6e041c0-32f4-44ac-b968-4758547ea6eb", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n        \n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            pop_center = np.mean(pop, axis=0)\n            diversity = np.mean(np.linalg.norm(pop - pop_center, axis=1)) / self.dim\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget) * (1 + diversity)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.7 + 0.3 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.3 + 0.7 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment and restart mechanism\n            if evals % 500 == 0:  # More frequent local search for stuck situations\n                pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                pop_velocity = np.zeros_like(pop)\n                personal_best = np.copy(pop)\n                personal_best_scores = np.array([func(ind) for ind in personal_best])\n                evals += self.population_size\n\n            self.population_size = max(10, int(40 * (1 - evals / self.budget)))  # More aggressive shrinkage\n\n        return global_best", "name": "HybridDEPSO", "description": "Introduce dynamic inertia weight tuning based on current population diversity to enhance exploration and exploitation balance.", "configspace": "", "generation": 97, "fitness": 0.21405382192709035, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.22.", "error": "", "parent_id": "0450b9e5-266e-430b-a590-d349a8deb32e", "metadata": {"aucs": [0.1817074723908504, 0.2807376286791974, 0.6424173751180098, 0.7149696739887247, 0.7033257071788346, 0.6843005191947491, 0.6383809677783403, 0.709397950394179, 0.5894254161752798, 0.3712801367133781, 0.5024742580599983, 0.40298499531397225, 0.3275846195018517, 0.3592917416655774, 9.999999999998899e-05, 0.3660315660170258, 0.2980904085606445, 0.02049669069995852, 0.08124633104666923, 0.07247386762450403, 0.11074621142154994, 0.04773117326172871, 0.1359955070981299, 0.14922854660183205, 0.09185166527392374, 0.08562091819164941, 0.4730937692270166, 0.07333096763624924, 0.08228488666696354, 0.031094676003507793, 0.051318048175866715, 0.04374547192282319, 0.02789723006380629, 0.09845642959942924, 0.06808519858512596, 0.083079313098393, 0.971489271108181, 0.9728574771895112, 0.9714880763762389, 0.9706895329614864, 0.9694848673697738, 0.9690201680580361, 0.9756108510692832, 0.9704239563568549, 0.9702058738009289, 0.5244342036148794, 0.4883599515325755, 0.4303938519415599, 0.12493620423678531, 0.07685907763026156, 0.5038971893568767, 0.492197775138972, 0.525659564534437, 0.12888441098226833, 0.30789855164629365, 0.17814629259722115, 0.11356967690629483, 0.23581105485982012, 0.1725057643684359, 0.3025194254448227, 0.1095084350106672, 0.09225075909948499, 0.26061588917220146, 0.10528211548124966, 9.999999999998899e-05, 0.130951565071888, 0.08223866404051827, 0.03309457479176492, 0.12468277276417261, 0.10307194769406924, 0.1282206504241754, 0.05433629673347873, 0.1417898100542856, 0.004219361383779541, 0.018714871587911297, 0.023213328531540345, 0.1273003309899854, 0.09899583246068122, 0.11288688336148167, 9.999999999998899e-05, 0.04268275633763352, 9.999999999998899e-05, 0.03183757922125352, 0.02008936821218399, 0.011698199499530548, 9.999999999998899e-05, 9.999999999998899e-05, 0.00606862159386079, 9.999999999998899e-05, 9.999999999998899e-05, 0.06938642298789433, 0.04473235990861357, 0.08402801246790947, 0.01176765333497809, 0.08162457239187226, 0.06568690208104055, 0.02405814545612539, 0.10322285872035553, 0.049184581649250325, 0.037990193336769895, 0.06109681172899528, 0.0518978648031454, 9.999999999998899e-05, 0.08528930231102017, 0.05237334560851925, 0.08893088213478406, 0.1030335997561942, 0.11260396216289248, 0.018022729052030284, 0.02446878529240981, 0.08646923768472137, 0.11460113284597229, 0.1271287662247863, 0.0400735832209379, 0.17345748215024137, 0.03856556733132399, 0.04551440657692096, 0.27113191489150346, 0.1980715693825399, 0.39295860342030087, 0.39904235003579436, 0.3922770877185383, 0.40888079241178443, 0.26901336595899206, 0.386290857218449, 0.3794294681917788, 0.1193008442881317, 0.08180935947409129, 0.11303872467031106, 0.07899385906949974, 0.09570239636095135, 0.06068158258101952, 0.10209038174588203, 0.08308219382172832, 0.04073645698245998, 0.18603110353957641, 0.13183096484913692, 0.14566453212002384, 0.2116706633716232, 0.19195868575163355, 0.199722910695593, 0.16355736007798516, 0.1542497693071455, 0.1535881833829078, 0.4003311792672338, 0.16428204822746717, 0.17012775096419375, 0.20752222439791024, 0.3860576393296401, 0.16642785167403473, 0.32830630775455716, 0.33239439627653544, 0.36161720721463886, 0.20768565625895508, 0.20299924555588378, 0.1830884403932862, 0.09831586681777948, 0.10701014078055993, 0.1708800578275963, 0.18021005573731197, 0.13307791804796054, 0.22347352380575747, 0.14848237340581327, 0.18528900547656668, 0.19983034569264857, 0.19030803075640468, 0.17103806761750362, 0.1887757525339684, 0.2044445110610934, 0.17807449399401942, 0.18589595605698328, 0.1643451638340122, 0.15236253358948304, 0.1614177364762801, 0.20432964128223208, 0.17490525772074328, 0.1727271297730778, 0.15177823385401756, 0.14927570136621526, 0.16269225152658295, 0.6066492149942712, 0.6358542813386034, 0.15359360446084647, 0.12157524499254269, 0.17704058576831394, 0.2594088217145192, 0.15456853437306706, 0.16142941444001357, 0.11159896962284965, 0.23294291549404655, 0.15669439982088207, 0.14826364823217375, 0.34454138488417985, 0.2953559370010965, 0.23738325328040033, 0.19152212871128182, 0.19134935721420276, 0.5175151213731459, 0.1956546397777733, 0.19034919929386984, 0.19203928746108623, 0.2004818054190779, 0.19042645948251358, 0.1835380132399036, 0.17303319540054163, 0.19667515563162197, 0.1930650663418737, 0.0713027324033787, 0.06729552945586825, 0.07027531961288003, 0.0740786229092324, 0.06601728846007904, 0.06594170228682328, 0.0694725393507597, 0.07568713213597311, 0.0750391694544491]}, "mutation_prompt": null}
{"id": "5e6ba440-1e19-488c-b170-a0586f1b2068", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n        \n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.7 + 0.3 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.3 + 0.7 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment and restart mechanism\n            if evals % 500 == 0:  # More frequent local search for stuck situations\n                pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                pop_velocity = np.zeros_like(pop)\n                personal_best = np.copy(pop)\n                personal_best_scores = np.array([func(ind) for ind in personal_best])\n                evals += self.population_size\n\n            self.population_size = max(10, int(40 * (1 - evals / self.budget)))  # More aggressive shrinkage\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance convergence by varying the population size more adaptively and introducing a local search when stuck.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0450b9e5-266e-430b-a590-d349a8deb32e", "metadata": {"aucs": [0.8164195756494056, 0.8031872572484745, 0.7981962501001248, 0.8131225564221786, 0.7959314763104478, 0.8159998662454583, 0.8090775586870029, 0.8006111898269437, 0.8134346873442886, 0.6243917730717828, 0.6409613488746846, 0.6246065014104285, 0.6324330962371657, 0.6206267988292387, 0.6602978125663587, 0.6250778151442056, 0.6284297288630931, 0.6439013126697939, 0.16468275658009335, 0.1523742403417102, 0.14944011076747288, 0.14716212489162195, 0.14090427166772357, 0.12587880678527852, 0.13646435953101976, 0.1260808454423351, 0.1269074889641384, 0.12992090088605224, 0.13179453711442457, 0.11510077274071262, 0.14523343787680443, 0.1057840450887072, 0.12467044905865843, 0.13196596422219609, 0.15054869008726268, 0.13693992192926197, 0.9663096765456931, 0.9677332223840229, 0.9618773564657753, 0.9638852704863604, 0.9620637956010087, 0.9569925276456013, 0.9692532669982198, 0.9610165844843083, 0.9640342759298982, 0.6636107433678256, 0.689397734550597, 0.6682565674513377, 0.6916670030969504, 0.690871529705677, 0.5652380734053882, 0.6667720011864461, 0.6871262955424005, 0.6473159988560401, 0.22763517280017742, 0.2118816720146538, 0.7836262031264627, 0.84578012830147, 0.8203343143094035, 0.7744304099080812, 0.17460902341458462, 0.7953357547666624, 0.3757134550867367, 0.2107971195254189, 0.24651678371339114, 0.18269965187640447, 0.11814504410615212, 0.20027378772360638, 0.13075831823908413, 0.18405659724765, 0.1277671597237473, 0.17171183149166014, 0.14309816794389285, 0.2158639387776684, 0.1704826718779172, 0.23005345603411143, 0.20521122308868534, 0.1287205377626286, 0.38718778951761823, 0.16937928514143785, 0.20816433037503468, 0.03959176468957226, 9.999999999998899e-05, 0.00031421543773779703, 0.06403598872531935, 9.999999999998899e-05, 0.036110584892703135, 0.036694065018338606, 9.999999999998899e-05, 0.09482080258988312, 0.15810534866420334, 0.06485839267962179, 0.2017290099601835, 0.10096586964702814, 0.11422515328791394, 0.04802136278645486, 0.1293826885334014, 0.11759789281328425, 0.12608127874006236, 0.13380112040446168, 0.15891056752287636, 0.1514436027400523, 0.07031829799362277, 0.09650138311991263, 0.08318442293071604, 0.1912512508481211, 0.08295765018880286, 0.06502938132417624, 0.1499729323527983, 0.05542051459464292, 0.15327041455090762, 0.060783208333432204, 0.14882642972741777, 0.09160518239415383, 0.17220744833632617, 0.12354687710778145, 0.08002066681340947, 0.5298123484565177, 0.529285141836223, 0.45867080181005604, 0.6014561431684758, 0.5809646948813703, 0.535796068789504, 0.5565041868029215, 0.5686885175621472, 0.565138982294016, 0.1702038582845946, 0.11155316239271174, 0.12718560658188527, 0.13664661583402027, 0.14769810302095066, 0.09796032234223262, 0.10542028426953143, 0.13206163748123378, 0.16695854828833212, 0.26316510603854626, 0.18078049438937305, 0.17757744449420387, 0.36902492510643403, 0.3085390395537042, 0.2167927410806021, 0.20983864439674682, 0.18886006157122515, 0.224895107857373, 0.37181862721051095, 0.43398203125220447, 0.3840394953354527, 0.6457913645405944, 0.3218435105490979, 0.34741295279887063, 0.4716088830979944, 0.4821895714212573, 0.43218061949430386, 0.36060678281106084, 0.2663671896734999, 0.30649396587511746, 0.1979014575589807, 0.25267023352040685, 0.3400143003751097, 0.2443471266778784, 0.2829321350311348, 0.20498549838601265, 0.24500071852190564, 0.23030750191766336, 0.19860433573672553, 0.19753353415442265, 0.21220519246017333, 0.2441652194232553, 0.2068059052476896, 0.19171736585156307, 0.21698527097461062, 0.20832681704906386, 0.20666044854360677, 0.24248543275313206, 0.24048260646445752, 0.7136474683773988, 0.18904862232033293, 0.23574981141135742, 0.2388205240911917, 0.20674812472537218, 0.8554093136413741, 0.18618219756183085, 0.17509284781105072, 0.8880815933740098, 0.7370607668086624, 0.8676846685938672, 0.802427634092667, 0.20038380338638728, 0.15193343518505975, 0.736688440226879, 0.2097884435243943, 0.6450877980321346, 0.45733183821076595, 0.1659987174390537, 0.7743417556918712, 0.10446575563517091, 0.6634898619036615, 0.814670317470632, 0.19760660251995554, 0.20292063549860018, 0.19514375318972754, 0.20019641947623112, 0.1993269213963459, 0.17628382319001068, 0.19838985220839245, 0.19143968990205462, 0.23275128772514664, 0.0880041717212775, 0.0761057388855263, 0.10065148477971997, 0.09463972977891721, 0.09658997637279809, 0.10369392557241408, 0.10008295173801451, 0.08839558095476208, 0.0919158624489197]}, "mutation_prompt": null}
{"id": "bbaa9a3f-71c7-4f51-964f-f88d927d2f44", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def __call__(self, func):\n        def clip(x):\n            return np.clip(x, self.lower_bound, self.upper_bound)\n        \n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        pop_velocity = np.zeros_like(pop)\n        personal_best = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n\n        evals = len(personal_best_scores)\n        \n        while evals < self.budget:\n            # Differential Evolution phase\n            for i in range(self.population_size):\n                a, b, c = pop[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = clip(a + dynamic_mutation_factor * (b - c))\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * evals / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, pop[i])\n                \n                trial_score = func(trial_vector)\n                evals += 1\n                \n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n\n            # Particle Swarm Optimization phase\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                adaptive_inertia_weight = self.inertia_weight * (1 - evals / self.budget)\n                dynamic_cognitive_constant = self.cognitive_constant * (0.7 + 0.3 * evals / self.budget)\n                dynamic_social_constant = self.social_constant * (0.3 + 0.7 * evals / self.budget)\n                \n                pop_velocity[i] = (adaptive_inertia_weight * pop_velocity[i] +\n                                   dynamic_cognitive_constant * r1 * (personal_best[i] - pop[i]) +\n                                   dynamic_social_constant * r2 * (global_best - pop[i]))\n                \n                pop[i] = clip(pop[i] + pop_velocity[i])\n                score = func(pop[i])\n                evals += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best[i] = pop[i]\n                    personal_best_scores[i] = score\n                    if score < global_best_score:\n                        global_best = pop[i]\n                        global_best_score = score\n\n                if evals >= self.budget:\n                    break\n\n            # Dynamic population size adjustment and restart mechanism\n            if evals % 500 == 0:  # More frequent local search for stuck situations\n                pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                pop_velocity = np.zeros_like(pop)\n                personal_best = np.copy(pop)\n                personal_best_scores = np.array([func(ind) for ind in personal_best])\n                evals += self.population_size\n\n            self.population_size = max(10, int(40 * (1 - evals / self.budget)))  # More aggressive shrinkage\n\n        return global_best", "name": "HybridDEPSO", "description": "Enhance convergence by varying the population size more adaptively and introducing a local search when stuck.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0450b9e5-266e-430b-a590-d349a8deb32e", "metadata": {"aucs": [0.8164195756494056, 0.8031872572484745, 0.7981962501001248, 0.8131225564221786, 0.7959314763104478, 0.8159998662454583, 0.8090775586870029, 0.8006111898269437, 0.8134346873442886, 0.6243917730717828, 0.6409613488746846, 0.6246065014104285, 0.6324330962371657, 0.6206267988292387, 0.6602978125663587, 0.6250778151442056, 0.6284297288630931, 0.6439013126697939, 0.16468275658009335, 0.1523742403417102, 0.14944011076747288, 0.14716212489162195, 0.14090427166772357, 0.12587880678527852, 0.13646435953101976, 0.1260808454423351, 0.1269074889641384, 0.12992090088605224, 0.13179453711442457, 0.11510077274071262, 0.14523343787680443, 0.1057840450887072, 0.12467044905865843, 0.13196596422219609, 0.15054869008726268, 0.13693992192926197, 0.9663096765456931, 0.9677332223840229, 0.9618773564657753, 0.9638852704863604, 0.9620637956010087, 0.9569925276456013, 0.9692532669982198, 0.9610165844843083, 0.9640342759298982, 0.6636107433678256, 0.689397734550597, 0.6682565674513377, 0.6916670030969504, 0.690871529705677, 0.5652380734053882, 0.6667720011864461, 0.6871262955424005, 0.6473159988560401, 0.22763517280017742, 0.2118816720146538, 0.7836262031264627, 0.84578012830147, 0.8203343143094035, 0.7744304099080812, 0.17460902341458462, 0.7953357547666624, 0.3757134550867367, 0.2107971195254189, 0.24651678371339114, 0.18269965187640447, 0.11814504410615212, 0.20027378772360638, 0.13075831823908413, 0.18405659724765, 0.1277671597237473, 0.17171183149166014, 0.14309816794389285, 0.2158639387776684, 0.1704826718779172, 0.23005345603411143, 0.20521122308868534, 0.1287205377626286, 0.38718778951761823, 0.16937928514143785, 0.20816433037503468, 0.03959176468957226, 9.999999999998899e-05, 0.00031421543773779703, 0.06403598872531935, 9.999999999998899e-05, 0.036110584892703135, 0.036694065018338606, 9.999999999998899e-05, 0.09482080258988312, 0.15810534866420334, 0.06485839267962179, 0.2017290099601835, 0.10096586964702814, 0.11422515328791394, 0.04802136278645486, 0.1293826885334014, 0.11759789281328425, 0.12608127874006236, 0.13380112040446168, 0.15891056752287636, 0.1514436027400523, 0.07031829799362277, 0.09650138311991263, 0.08318442293071604, 0.1912512508481211, 0.08295765018880286, 0.06502938132417624, 0.1499729323527983, 0.05542051459464292, 0.15327041455090762, 0.060783208333432204, 0.14882642972741777, 0.09160518239415383, 0.17220744833632617, 0.12354687710778145, 0.08002066681340947, 0.5298123484565177, 0.529285141836223, 0.45867080181005604, 0.6014561431684758, 0.5809646948813703, 0.535796068789504, 0.5565041868029215, 0.5686885175621472, 0.565138982294016, 0.1702038582845946, 0.11155316239271174, 0.12718560658188527, 0.13664661583402027, 0.14769810302095066, 0.09796032234223262, 0.10542028426953143, 0.13206163748123378, 0.16695854828833212, 0.26316510603854626, 0.18078049438937305, 0.17757744449420387, 0.36902492510643403, 0.3085390395537042, 0.2167927410806021, 0.20983864439674682, 0.18886006157122515, 0.224895107857373, 0.37181862721051095, 0.43398203125220447, 0.3840394953354527, 0.6457913645405944, 0.3218435105490979, 0.34741295279887063, 0.4716088830979944, 0.4821895714212573, 0.43218061949430386, 0.36060678281106084, 0.2663671896734999, 0.30649396587511746, 0.1979014575589807, 0.25267023352040685, 0.3400143003751097, 0.2443471266778784, 0.2829321350311348, 0.20498549838601265, 0.24500071852190564, 0.23030750191766336, 0.19860433573672553, 0.19753353415442265, 0.21220519246017333, 0.2441652194232553, 0.2068059052476896, 0.19171736585156307, 0.21698527097461062, 0.20832681704906386, 0.20666044854360677, 0.24248543275313206, 0.24048260646445752, 0.7136474683773988, 0.18904862232033293, 0.23574981141135742, 0.2388205240911917, 0.20674812472537218, 0.8554093136413741, 0.18618219756183085, 0.17509284781105072, 0.8880815933740098, 0.7370607668086624, 0.8676846685938672, 0.802427634092667, 0.20038380338638728, 0.15193343518505975, 0.736688440226879, 0.2097884435243943, 0.6450877980321346, 0.45733183821076595, 0.1659987174390537, 0.7743417556918712, 0.10446575563517091, 0.6634898619036615, 0.814670317470632, 0.19760660251995554, 0.20292063549860018, 0.19514375318972754, 0.20019641947623112, 0.1993269213963459, 0.17628382319001068, 0.19838985220839245, 0.19143968990205462, 0.23275128772514664, 0.0880041717212775, 0.0761057388855263, 0.10065148477971997, 0.09463972977891721, 0.09658997637279809, 0.10369392557241408, 0.10008295173801451, 0.08839558095476208, 0.0919158624489197]}, "mutation_prompt": null}
