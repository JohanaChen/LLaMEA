{"id": "7586f1e8-e7c7-407f-a0fa-018017367457", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = int(self.budget / (10 * dim))\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 5\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n    \n    def _local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        current_solution = solution.copy()\n        \n        for _ in range(max_iters):\n            perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n            candidate_solution = np.clip(current_solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n            current_solution = candidate_solution\n        \n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Perform local search for further improvement\n                    improved_solution = self._local_search(trial, func, self.max_local_search_iterations)\n                    improved_score = func(improved_solution)\n                    evaluations += 1\n\n                    if improved_score < trial_score:\n                        self.population[i] = improved_solution\n                        population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "A differential evolution inspired algorithm with adaptive mutation and crossover rates, combined with local search for improved convergence.", "configspace": "", "generation": 0, "fitness": 0.10896061170974435, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.11.", "error": "", "parent_id": null, "metadata": {"aucs": [0.18208971723941392, 0.19044780879133782, 0.1944814775334901, 0.2079492851021223, 0.17917702938182867, 0.18967037904178918, 0.1705593670701916, 0.16187828336494914, 0.2229383382744914, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05935309629858021, 0.06532307984645247, 0.04649794784932315, 0.04644727609107535, 0.04499614422266951, 0.05562425914138225, 0.06268642132980273, 0.05907506524178552, 0.051520470733913304, 0.03467715508611835, 0.039198276970781265, 0.03454692445408358, 0.03459242227591841, 0.0411699979020812, 0.03129806261096579, 0.04043725828306066, 0.0376676544382879, 0.0346527313655286, 0.2807083072142528, 0.6105652585182215, 0.4869993098795534, 0.6570532174193082, 0.7495595214779892, 0.18225506480804565, 0.3452305610503642, 0.3891996998383733, 0.5910615175357019, 0.07634106074691682, 0.06904185530542817, 0.10538330655683925, 0.056634779120387946, 0.08412700827381958, 0.06774196189449633, 0.08432233118062882, 0.05520870054639415, 0.09153253121924632, 0.16068429858483213, 0.14448942409905174, 0.11197569144547215, 0.12130700200801692, 0.1157960036735649, 0.13150055516072967, 0.11584788732203177, 0.14398017923763706, 0.14187158614695394, 0.018822866096605884, 0.013082569823170909, 0.008741010202640398, 0.019949284469964024, 0.009053998249488382, 0.015099744583559005, 0.0071160422301538295, 0.009587929108363813, 0.0040625196639287875, 0.03002332168218469, 0.0308806700652956, 0.01635697373773115, 0.014038696103638393, 0.046390361653912415, 0.004977628607565343, 0.03365745941779974, 0.004815081436852386, 0.0031546484293323296, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06257191446633548, 0.04084849842647875, 0.06429968213783577, 0.07460750634287383, 0.04350987415709062, 0.07561951913583576, 0.06748586559351666, 0.0669977920590592, 0.07077720439477819, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010069130457675435, 0.005182889110050604, 0.007266691232700406, 0.00026542501123116846, 9.999999999998899e-05, 0.0033039776258505515, 0.00582416086701909, 0.0009232232850019395, 0.005880627472806044, 0.18159142342508794, 0.1784182603524741, 0.21027959683688568, 0.19602876575080153, 0.18855566959319814, 0.18150246226507893, 0.2056992330285755, 0.19047702465567606, 0.21630082128783867, 0.06375175379764442, 0.05922833952412143, 0.05893536366442875, 0.057855915070246344, 0.052112369973042805, 0.06357445307543663, 0.052403289360661964, 0.07095807532490306, 0.0652934109765454, 0.15005275113475314, 0.1506488113561829, 0.13417445969636865, 0.16452382506282193, 0.16173904650734117, 0.15509580990905925, 0.1452056442007652, 0.15448904011915165, 0.1537004039335741, 0.16896311931518815, 0.1711738681225835, 0.17803400916391743, 0.1604533739574565, 0.1769089461567308, 0.1794819472751531, 0.17614433948462005, 0.18447720239281784, 0.17206625863011127, 0.1162385714543529, 0.10800535920449494, 0.11272230319758414, 0.1225182612109087, 0.12028326919881915, 0.12015226841561144, 0.12179759932679868, 0.12932182443506368, 0.13804785211361903, 0.1525452438198519, 0.17057176514162298, 0.17889757176386178, 0.1734111176045945, 0.16281352986264852, 0.16763327126785788, 0.16102281036444788, 0.16035634329731252, 0.16697212694978514, 0.10255467497354398, 0.15983189906193018, 0.12877498704479318, 0.1465212429338102, 0.15103015053769864, 0.15013170028449185, 0.12844638256072072, 0.11767448077744613, 0.1620817151192654, 0.14788903562912314, 0.16224511892771565, 0.14686842068453698, 0.1386331389342098, 0.14100264776682747, 0.15665671435881556, 0.13860939059310418, 0.1713930906101485, 0.168635120730959, 0.13305558808562945, 0.1372611213094308, 0.13280608135356053, 0.14590830332380333, 0.14649173513828206, 0.15707870712231597, 0.17575116913703714, 0.13116847903651674, 0.14185129625297155, 0.18514073131559927, 0.184707316747165, 0.1732121021520323, 0.19235348047481793, 0.19356384818508843, 0.1908569035908636, 0.19213233301101318, 0.18351788952122083, 0.18638774425831905, 0.06505919433614848, 0.05428789252651145, 0.056975676068955705, 0.055887317926775704, 0.061629029110693456, 0.05812423210672801, 0.06605009505597204, 0.0595226310380258, 0.054701809035672566]}, "mutation_prompt": null}
{"id": "8a499d28-315d-4475-9b9a-dfc142d03522", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = int(self.budget / (10 * dim))\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 5\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n    \n    def _local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        current_solution = solution.copy()\n        \n        for _ in range(max_iters):\n            perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n            candidate_solution = np.clip(current_solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n            current_solution = candidate_solution\n        \n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Perform local search for further improvement\n                    improved_solution = self._local_search(trial, func, self.max_local_search_iterations)\n                    improved_score = func(improved_solution)\n                    evaluations += 1\n\n                    if improved_score < trial_score:\n                        self.population[i] = improved_solution\n                        population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "A differential evolution inspired algorithm with adaptive mutation and crossover rates, combined with local search for improved convergence.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7586f1e8-e7c7-407f-a0fa-018017367457", "metadata": {"aucs": [0.18208971723941392, 0.19044780879133782, 0.1944814775334901, 0.2079492851021223, 0.17917702938182867, 0.18967037904178918, 0.1705593670701916, 0.16187828336494914, 0.2229383382744914, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05935309629858021, 0.06532307984645247, 0.04649794784932315, 0.04644727609107535, 0.04499614422266951, 0.05562425914138225, 0.06268642132980273, 0.05907506524178552, 0.051520470733913304, 0.03467715508611835, 0.039198276970781265, 0.03454692445408358, 0.03459242227591841, 0.0411699979020812, 0.03129806261096579, 0.04043725828306066, 0.0376676544382879, 0.0346527313655286, 0.2807083072142528, 0.6105652585182215, 0.4869993098795534, 0.6570532174193082, 0.7495595214779892, 0.18225506480804565, 0.3452305610503642, 0.3891996998383733, 0.5910615175357019, 0.07634106074691682, 0.06904185530542817, 0.10538330655683925, 0.056634779120387946, 0.08412700827381958, 0.06774196189449633, 0.08432233118062882, 0.05520870054639415, 0.09153253121924632, 0.16068429858483213, 0.14448942409905174, 0.11197569144547215, 0.12130700200801692, 0.1157960036735649, 0.13150055516072967, 0.11584788732203177, 0.14398017923763706, 0.14187158614695394, 0.018822866096605884, 0.013082569823170909, 0.008741010202640398, 0.019949284469964024, 0.009053998249488382, 0.015099744583559005, 0.0071160422301538295, 0.009587929108363813, 0.0040625196639287875, 0.03002332168218469, 0.0308806700652956, 0.01635697373773115, 0.014038696103638393, 0.046390361653912415, 0.004977628607565343, 0.03365745941779974, 0.004815081436852386, 0.0031546484293323296, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06257191446633548, 0.04084849842647875, 0.06429968213783577, 0.07460750634287383, 0.04350987415709062, 0.07561951913583576, 0.06748586559351666, 0.0669977920590592, 0.07077720439477819, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010069130457675435, 0.005182889110050604, 0.007266691232700406, 0.00026542501123116846, 9.999999999998899e-05, 0.0033039776258505515, 0.00582416086701909, 0.0009232232850019395, 0.005880627472806044, 0.18159142342508794, 0.1784182603524741, 0.21027959683688568, 0.19602876575080153, 0.18855566959319814, 0.18150246226507893, 0.2056992330285755, 0.19047702465567606, 0.21630082128783867, 0.06375175379764442, 0.05922833952412143, 0.05893536366442875, 0.057855915070246344, 0.052112369973042805, 0.06357445307543663, 0.052403289360661964, 0.07095807532490306, 0.0652934109765454, 0.15005275113475314, 0.1506488113561829, 0.13417445969636865, 0.16452382506282193, 0.16173904650734117, 0.15509580990905925, 0.1452056442007652, 0.15448904011915165, 0.1537004039335741, 0.16896311931518815, 0.1711738681225835, 0.17803400916391743, 0.1604533739574565, 0.1769089461567308, 0.1794819472751531, 0.17614433948462005, 0.18447720239281784, 0.17206625863011127, 0.1162385714543529, 0.10800535920449494, 0.11272230319758414, 0.1225182612109087, 0.12028326919881915, 0.12015226841561144, 0.12179759932679868, 0.12932182443506368, 0.13804785211361903, 0.1525452438198519, 0.17057176514162298, 0.17889757176386178, 0.1734111176045945, 0.16281352986264852, 0.16763327126785788, 0.16102281036444788, 0.16035634329731252, 0.16697212694978514, 0.10255467497354398, 0.15983189906193018, 0.12877498704479318, 0.1465212429338102, 0.15103015053769864, 0.15013170028449185, 0.12844638256072072, 0.11767448077744613, 0.1620817151192654, 0.14788903562912314, 0.16224511892771565, 0.14686842068453698, 0.1386331389342098, 0.14100264776682747, 0.15665671435881556, 0.13860939059310418, 0.1713930906101485, 0.168635120730959, 0.13305558808562945, 0.1372611213094308, 0.13280608135356053, 0.14590830332380333, 0.14649173513828206, 0.15707870712231597, 0.17575116913703714, 0.13116847903651674, 0.14185129625297155, 0.18514073131559927, 0.184707316747165, 0.1732121021520323, 0.19235348047481793, 0.19356384818508843, 0.1908569035908636, 0.19213233301101318, 0.18351788952122083, 0.18638774425831905, 0.06505919433614848, 0.05428789252651145, 0.056975676068955705, 0.055887317926775704, 0.061629029110693456, 0.05812423210672801, 0.06605009505597204, 0.0595226310380258, 0.054701809035672566]}, "mutation_prompt": null}
{"id": "b5dc9b74-18b1-46cf-9cbb-053e51cef51a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = int(self.budget / (10 * dim))\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 5\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n    \n    def _local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        current_solution = solution.copy()\n        \n        for _ in range(max_iters):\n            perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n            candidate_solution = np.clip(current_solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n            current_solution = candidate_solution\n        \n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Perform local search for further improvement\n                    improved_solution = self._local_search(trial, func, self.max_local_search_iterations)\n                    improved_score = func(improved_solution)\n                    evaluations += 1\n\n                    if improved_score < trial_score:\n                        self.population[i] = improved_solution\n                        population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "A differential evolution inspired algorithm with adaptive mutation and crossover rates, combined with local search for improved convergence.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7586f1e8-e7c7-407f-a0fa-018017367457", "metadata": {"aucs": [0.18208971723941392, 0.19044780879133782, 0.1944814775334901, 0.2079492851021223, 0.17917702938182867, 0.18967037904178918, 0.1705593670701916, 0.16187828336494914, 0.2229383382744914, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05935309629858021, 0.06532307984645247, 0.04649794784932315, 0.04644727609107535, 0.04499614422266951, 0.05562425914138225, 0.06268642132980273, 0.05907506524178552, 0.051520470733913304, 0.03467715508611835, 0.039198276970781265, 0.03454692445408358, 0.03459242227591841, 0.0411699979020812, 0.03129806261096579, 0.04043725828306066, 0.0376676544382879, 0.0346527313655286, 0.2807083072142528, 0.6105652585182215, 0.4869993098795534, 0.6570532174193082, 0.7495595214779892, 0.18225506480804565, 0.3452305610503642, 0.3891996998383733, 0.5910615175357019, 0.07634106074691682, 0.06904185530542817, 0.10538330655683925, 0.056634779120387946, 0.08412700827381958, 0.06774196189449633, 0.08432233118062882, 0.05520870054639415, 0.09153253121924632, 0.16068429858483213, 0.14448942409905174, 0.11197569144547215, 0.12130700200801692, 0.1157960036735649, 0.13150055516072967, 0.11584788732203177, 0.14398017923763706, 0.14187158614695394, 0.018822866096605884, 0.013082569823170909, 0.008741010202640398, 0.019949284469964024, 0.009053998249488382, 0.015099744583559005, 0.0071160422301538295, 0.009587929108363813, 0.0040625196639287875, 0.03002332168218469, 0.0308806700652956, 0.01635697373773115, 0.014038696103638393, 0.046390361653912415, 0.004977628607565343, 0.03365745941779974, 0.004815081436852386, 0.0031546484293323296, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06257191446633548, 0.04084849842647875, 0.06429968213783577, 0.07460750634287383, 0.04350987415709062, 0.07561951913583576, 0.06748586559351666, 0.0669977920590592, 0.07077720439477819, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010069130457675435, 0.005182889110050604, 0.007266691232700406, 0.00026542501123116846, 9.999999999998899e-05, 0.0033039776258505515, 0.00582416086701909, 0.0009232232850019395, 0.005880627472806044, 0.18159142342508794, 0.1784182603524741, 0.21027959683688568, 0.19602876575080153, 0.18855566959319814, 0.18150246226507893, 0.2056992330285755, 0.19047702465567606, 0.21630082128783867, 0.06375175379764442, 0.05922833952412143, 0.05893536366442875, 0.057855915070246344, 0.052112369973042805, 0.06357445307543663, 0.052403289360661964, 0.07095807532490306, 0.0652934109765454, 0.15005275113475314, 0.1506488113561829, 0.13417445969636865, 0.16452382506282193, 0.16173904650734117, 0.15509580990905925, 0.1452056442007652, 0.15448904011915165, 0.1537004039335741, 0.16896311931518815, 0.1711738681225835, 0.17803400916391743, 0.1604533739574565, 0.1769089461567308, 0.1794819472751531, 0.17614433948462005, 0.18447720239281784, 0.17206625863011127, 0.1162385714543529, 0.10800535920449494, 0.11272230319758414, 0.1225182612109087, 0.12028326919881915, 0.12015226841561144, 0.12179759932679868, 0.12932182443506368, 0.13804785211361903, 0.1525452438198519, 0.17057176514162298, 0.17889757176386178, 0.1734111176045945, 0.16281352986264852, 0.16763327126785788, 0.16102281036444788, 0.16035634329731252, 0.16697212694978514, 0.10255467497354398, 0.15983189906193018, 0.12877498704479318, 0.1465212429338102, 0.15103015053769864, 0.15013170028449185, 0.12844638256072072, 0.11767448077744613, 0.1620817151192654, 0.14788903562912314, 0.16224511892771565, 0.14686842068453698, 0.1386331389342098, 0.14100264776682747, 0.15665671435881556, 0.13860939059310418, 0.1713930906101485, 0.168635120730959, 0.13305558808562945, 0.1372611213094308, 0.13280608135356053, 0.14590830332380333, 0.14649173513828206, 0.15707870712231597, 0.17575116913703714, 0.13116847903651674, 0.14185129625297155, 0.18514073131559927, 0.184707316747165, 0.1732121021520323, 0.19235348047481793, 0.19356384818508843, 0.1908569035908636, 0.19213233301101318, 0.18351788952122083, 0.18638774425831905, 0.06505919433614848, 0.05428789252651145, 0.056975676068955705, 0.055887317926775704, 0.061629029110693456, 0.05812423210672801, 0.06605009505597204, 0.0595226310380258, 0.054701809035672566]}, "mutation_prompt": null}
{"id": "96d1464c-3d7b-4ad9-9b10-adad0116f5a1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = int(self.budget / (10 * dim))\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 5\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n    \n    def _local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        current_solution = solution.copy()\n        \n        for _ in range(max_iters):\n            perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n            candidate_solution = np.clip(current_solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n            current_solution = candidate_solution\n        \n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Perform local search for further improvement\n                    improved_solution = self._local_search(trial, func, self.max_local_search_iterations)\n                    improved_score = func(improved_solution)\n                    evaluations += 1\n\n                    if improved_score < trial_score:\n                        self.population[i] = improved_solution\n                        population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "A differential evolution inspired algorithm with adaptive mutation and crossover rates, combined with local search for improved convergence.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7586f1e8-e7c7-407f-a0fa-018017367457", "metadata": {"aucs": [0.18208971723941392, 0.19044780879133782, 0.1944814775334901, 0.2079492851021223, 0.17917702938182867, 0.18967037904178918, 0.1705593670701916, 0.16187828336494914, 0.2229383382744914, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05935309629858021, 0.06532307984645247, 0.04649794784932315, 0.04644727609107535, 0.04499614422266951, 0.05562425914138225, 0.06268642132980273, 0.05907506524178552, 0.051520470733913304, 0.03467715508611835, 0.039198276970781265, 0.03454692445408358, 0.03459242227591841, 0.0411699979020812, 0.03129806261096579, 0.04043725828306066, 0.0376676544382879, 0.0346527313655286, 0.2807083072142528, 0.6105652585182215, 0.4869993098795534, 0.6570532174193082, 0.7495595214779892, 0.18225506480804565, 0.3452305610503642, 0.3891996998383733, 0.5910615175357019, 0.07634106074691682, 0.06904185530542817, 0.10538330655683925, 0.056634779120387946, 0.08412700827381958, 0.06774196189449633, 0.08432233118062882, 0.05520870054639415, 0.09153253121924632, 0.16068429858483213, 0.14448942409905174, 0.11197569144547215, 0.12130700200801692, 0.1157960036735649, 0.13150055516072967, 0.11584788732203177, 0.14398017923763706, 0.14187158614695394, 0.018822866096605884, 0.013082569823170909, 0.008741010202640398, 0.019949284469964024, 0.009053998249488382, 0.015099744583559005, 0.0071160422301538295, 0.009587929108363813, 0.0040625196639287875, 0.03002332168218469, 0.0308806700652956, 0.01635697373773115, 0.014038696103638393, 0.046390361653912415, 0.004977628607565343, 0.03365745941779974, 0.004815081436852386, 0.0031546484293323296, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06257191446633548, 0.04084849842647875, 0.06429968213783577, 0.07460750634287383, 0.04350987415709062, 0.07561951913583576, 0.06748586559351666, 0.0669977920590592, 0.07077720439477819, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010069130457675435, 0.005182889110050604, 0.007266691232700406, 0.00026542501123116846, 9.999999999998899e-05, 0.0033039776258505515, 0.00582416086701909, 0.0009232232850019395, 0.005880627472806044, 0.18159142342508794, 0.1784182603524741, 0.21027959683688568, 0.19602876575080153, 0.18855566959319814, 0.18150246226507893, 0.2056992330285755, 0.19047702465567606, 0.21630082128783867, 0.06375175379764442, 0.05922833952412143, 0.05893536366442875, 0.057855915070246344, 0.052112369973042805, 0.06357445307543663, 0.052403289360661964, 0.07095807532490306, 0.0652934109765454, 0.15005275113475314, 0.1506488113561829, 0.13417445969636865, 0.16452382506282193, 0.16173904650734117, 0.15509580990905925, 0.1452056442007652, 0.15448904011915165, 0.1537004039335741, 0.16896311931518815, 0.1711738681225835, 0.17803400916391743, 0.1604533739574565, 0.1769089461567308, 0.1794819472751531, 0.17614433948462005, 0.18447720239281784, 0.17206625863011127, 0.1162385714543529, 0.10800535920449494, 0.11272230319758414, 0.1225182612109087, 0.12028326919881915, 0.12015226841561144, 0.12179759932679868, 0.12932182443506368, 0.13804785211361903, 0.1525452438198519, 0.17057176514162298, 0.17889757176386178, 0.1734111176045945, 0.16281352986264852, 0.16763327126785788, 0.16102281036444788, 0.16035634329731252, 0.16697212694978514, 0.10255467497354398, 0.15983189906193018, 0.12877498704479318, 0.1465212429338102, 0.15103015053769864, 0.15013170028449185, 0.12844638256072072, 0.11767448077744613, 0.1620817151192654, 0.14788903562912314, 0.16224511892771565, 0.14686842068453698, 0.1386331389342098, 0.14100264776682747, 0.15665671435881556, 0.13860939059310418, 0.1713930906101485, 0.168635120730959, 0.13305558808562945, 0.1372611213094308, 0.13280608135356053, 0.14590830332380333, 0.14649173513828206, 0.15707870712231597, 0.17575116913703714, 0.13116847903651674, 0.14185129625297155, 0.18514073131559927, 0.184707316747165, 0.1732121021520323, 0.19235348047481793, 0.19356384818508843, 0.1908569035908636, 0.19213233301101318, 0.18351788952122083, 0.18638774425831905, 0.06505919433614848, 0.05428789252651145, 0.056975676068955705, 0.055887317926775704, 0.061629029110693456, 0.05812423210672801, 0.06605009505597204, 0.0595226310380258, 0.054701809035672566]}, "mutation_prompt": null}
{"id": "6780dbd8-58f2-446e-a8c2-9f0f1876d555", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = int(self.budget / (10 * dim))\n        self.crossover_rate_initial = 0.9\n        self.mutation_factor_initial = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 5\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx, eval_progress):\n        adaptive_factor = 1 - eval_progress\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + adaptive_factor * self.mutation_factor_initial * (self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, eval_progress):\n        adaptive_rate = self.crossover_rate_initial * eval_progress\n        crossover_mask = np.random.rand(self.dim) < adaptive_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n    \n    def _local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        current_solution = solution.copy()\n        \n        for _ in range(max_iters):\n            perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n            candidate_solution = np.clip(current_solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n            current_solution = candidate_solution\n        \n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_progress = evaluations / self.budget\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i, eval_progress)\n                trial = self._crossover(target, mutant, eval_progress)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Perform local search for further improvement\n                    improved_solution = self._local_search(trial, func, self.max_local_search_iterations)\n                    improved_score = func(improved_solution)\n                    evaluations += 1\n\n                    if improved_score < trial_score:\n                        self.population[i] = improved_solution\n                        population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduced dynamic scaling for mutation and crossover rates based on convergence to improve exploration and exploitation balance.", "configspace": "", "generation": 4, "fitness": 0.09948412946410722, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.07.", "error": "", "parent_id": "7586f1e8-e7c7-407f-a0fa-018017367457", "metadata": {"aucs": [0.20367459596774184, 0.20758314774717723, 0.1756774013869794, 0.19133041921566551, 0.1816670838704375, 0.18359762602286434, 0.18690428263709769, 0.180343460638543, 0.18112096748291517, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.053427581929354706, 0.06086817362420005, 0.05508888399588485, 0.04983196357898634, 0.05703333382335496, 0.0571078244483626, 0.06171061605964845, 0.05741824477551438, 0.06685727371049721, 0.05653515823059296, 0.04086318914811926, 0.04805317091990924, 0.04780252428585008, 0.037363190841958716, 0.0456620244538577, 0.05541626357832852, 0.04514444974726306, 0.04858850119926761, 0.11876412348320697, 0.1472142871848502, 0.1294541648948363, 0.14630402447231494, 0.24890219674474023, 0.15621536614835752, 0.17608833519942946, 0.24723626218620043, 0.1592968302363944, 0.07096034748465752, 0.06376231896623652, 0.1017790844717481, 0.10158789578983252, 0.07073886065763468, 0.06350692520861789, 0.06408831928201475, 0.05544638674785296, 0.0917260086685705, 0.1176984694868759, 0.10744178847440833, 0.13158078238737703, 0.12313272012677912, 0.1294129379252752, 0.11707057108852237, 0.1538472763349762, 0.13613685171500622, 0.14374034194946494, 0.041112005269257734, 0.019838747958682013, 9.999999999998899e-05, 0.029790880167204326, 0.0058163453624873185, 0.027447826401199582, 0.005735929123435013, 0.013347973408116554, 0.017216356689086942, 0.012048767444971187, 0.020351942922767874, 0.021549524059230274, 0.010854769000134046, 0.0032369326292392975, 0.01432452512377691, 0.04861893289888253, 0.042317419355122676, 0.013798458929610069, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.055410276877765896, 0.06256185419870997, 0.08903078042454748, 0.04833844947128019, 0.07480730115410428, 0.04153404431367036, 0.055263551687982915, 0.05867458847536089, 0.08032625402654126, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0015241573145921006, 9.999999999998899e-05, 9.999999999998899e-05, 0.0001241965706955117, 0.0013547768119820391, 0.009898610244876926, 0.008173069483494277, 0.0029284740782675733, 0.008412874425357986, 0.1856172082576436, 0.18282221224103767, 0.2149237832495775, 0.16718238563452903, 0.19124739083897369, 0.16940991401623828, 0.19854237322340373, 0.18747134448487535, 0.20190174939783523, 0.045123173827166796, 0.05289504917365939, 0.042594212995536895, 0.05183935488969815, 0.049729125759875425, 0.05058170762164804, 0.05239230829028818, 0.05800687948563099, 0.05685776740712767, 0.1375656065703248, 0.13979653215096677, 0.16201761140534343, 0.18920076796618213, 0.1410751592513958, 0.15022697882210545, 0.15461089928181193, 0.15076693204950808, 0.1471318623248712, 0.17021002998067802, 0.15810990574228345, 0.1704743826181757, 0.16249376174573338, 0.18664405202290557, 0.19366029670154672, 0.17182661484040562, 0.1803130789849352, 0.1640165277771899, 0.10918712230926997, 0.10428912736810414, 0.1129753123657179, 0.11033288701091426, 0.12811244632677188, 0.12787372053631174, 0.13871512259357555, 0.1341293666929727, 0.119814210201581, 0.17070941286167385, 0.16401523237777405, 0.16842347982057038, 0.18386213995365386, 0.1674764254961808, 0.1685521913609518, 0.18340666591937616, 0.17372078941640123, 0.17296927318947186, 0.1420964343054224, 0.1362511171098204, 0.11950517920305137, 0.13309884501855518, 0.1472925305372199, 0.167083396143611, 0.11948272787302561, 0.1395762959392356, 0.1633807144020164, 0.16390541453046958, 0.159403895564596, 0.1633983928112659, 0.16698317313200206, 0.2779339032921304, 0.22247411996531385, 0.2252823591841876, 0.16714219826654353, 0.15322017622405015, 0.17479928841342152, 0.1552566970244792, 0.19299401031219554, 0.19326344923595828, 0.28758488405802596, 0.21412707732215108, 0.17754866980087225, 0.16626495605312508, 0.13373640764379147, 0.17706907082774015, 0.1840951386782479, 0.17886370721486933, 0.18567964763246914, 0.1797543119464251, 0.17536281403689102, 0.18154167207205318, 0.17038836082287345, 0.18691867305092436, 0.05291478481498302, 0.06692711277181318, 0.0633019554243005, 0.05602246652390552, 0.06037048038892412, 0.0554745121092135, 0.057370130633093486, 0.05638385165580406, 0.050627666504721724]}, "mutation_prompt": null}
{"id": "77071bd3-d374-483c-9bda-c8e1c86dab8e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = int(self.budget / (10 * dim))\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 5\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n    \n    def _local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        current_solution = solution.copy()\n        \n        for _ in range(max_iters):\n            perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n            candidate_solution = np.clip(current_solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n            current_solution = candidate_solution\n        \n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Perform local search for further improvement\n                    improved_solution = self._local_search(trial, func, self.max_local_search_iterations)\n                    improved_score = func(improved_solution)\n                    evaluations += 1\n\n                    if improved_score < trial_score:\n                        self.population[i] = improved_solution\n                        population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "A differential evolution inspired algorithm with adaptive mutation and crossover rates, combined with local search for improved convergence.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7586f1e8-e7c7-407f-a0fa-018017367457", "metadata": {"aucs": [0.18208971723941392, 0.19044780879133782, 0.1944814775334901, 0.2079492851021223, 0.17917702938182867, 0.18967037904178918, 0.1705593670701916, 0.16187828336494914, 0.2229383382744914, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05935309629858021, 0.06532307984645247, 0.04649794784932315, 0.04644727609107535, 0.04499614422266951, 0.05562425914138225, 0.06268642132980273, 0.05907506524178552, 0.051520470733913304, 0.03467715508611835, 0.039198276970781265, 0.03454692445408358, 0.03459242227591841, 0.0411699979020812, 0.03129806261096579, 0.04043725828306066, 0.0376676544382879, 0.0346527313655286, 0.2807083072142528, 0.6105652585182215, 0.4869993098795534, 0.6570532174193082, 0.7495595214779892, 0.18225506480804565, 0.3452305610503642, 0.3891996998383733, 0.5910615175357019, 0.07634106074691682, 0.06904185530542817, 0.10538330655683925, 0.056634779120387946, 0.08412700827381958, 0.06774196189449633, 0.08432233118062882, 0.05520870054639415, 0.09153253121924632, 0.16068429858483213, 0.14448942409905174, 0.11197569144547215, 0.12130700200801692, 0.1157960036735649, 0.13150055516072967, 0.11584788732203177, 0.14398017923763706, 0.14187158614695394, 0.018822866096605884, 0.013082569823170909, 0.008741010202640398, 0.019949284469964024, 0.009053998249488382, 0.015099744583559005, 0.0071160422301538295, 0.009587929108363813, 0.0040625196639287875, 0.03002332168218469, 0.0308806700652956, 0.01635697373773115, 0.014038696103638393, 0.046390361653912415, 0.004977628607565343, 0.03365745941779974, 0.004815081436852386, 0.0031546484293323296, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06257191446633548, 0.04084849842647875, 0.06429968213783577, 0.07460750634287383, 0.04350987415709062, 0.07561951913583576, 0.06748586559351666, 0.0669977920590592, 0.07077720439477819, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010069130457675435, 0.005182889110050604, 0.007266691232700406, 0.00026542501123116846, 9.999999999998899e-05, 0.0033039776258505515, 0.00582416086701909, 0.0009232232850019395, 0.005880627472806044, 0.18159142342508794, 0.1784182603524741, 0.21027959683688568, 0.19602876575080153, 0.18855566959319814, 0.18150246226507893, 0.2056992330285755, 0.19047702465567606, 0.21630082128783867, 0.06375175379764442, 0.05922833952412143, 0.05893536366442875, 0.057855915070246344, 0.052112369973042805, 0.06357445307543663, 0.052403289360661964, 0.07095807532490306, 0.0652934109765454, 0.15005275113475314, 0.1506488113561829, 0.13417445969636865, 0.16452382506282193, 0.16173904650734117, 0.15509580990905925, 0.1452056442007652, 0.15448904011915165, 0.1537004039335741, 0.16896311931518815, 0.1711738681225835, 0.17803400916391743, 0.1604533739574565, 0.1769089461567308, 0.1794819472751531, 0.17614433948462005, 0.18447720239281784, 0.17206625863011127, 0.1162385714543529, 0.10800535920449494, 0.11272230319758414, 0.1225182612109087, 0.12028326919881915, 0.12015226841561144, 0.12179759932679868, 0.12932182443506368, 0.13804785211361903, 0.1525452438198519, 0.17057176514162298, 0.17889757176386178, 0.1734111176045945, 0.16281352986264852, 0.16763327126785788, 0.16102281036444788, 0.16035634329731252, 0.16697212694978514, 0.10255467497354398, 0.15983189906193018, 0.12877498704479318, 0.1465212429338102, 0.15103015053769864, 0.15013170028449185, 0.12844638256072072, 0.11767448077744613, 0.1620817151192654, 0.14788903562912314, 0.16224511892771565, 0.14686842068453698, 0.1386331389342098, 0.14100264776682747, 0.15665671435881556, 0.13860939059310418, 0.1713930906101485, 0.168635120730959, 0.13305558808562945, 0.1372611213094308, 0.13280608135356053, 0.14590830332380333, 0.14649173513828206, 0.15707870712231597, 0.17575116913703714, 0.13116847903651674, 0.14185129625297155, 0.18514073131559927, 0.184707316747165, 0.1732121021520323, 0.19235348047481793, 0.19356384818508843, 0.1908569035908636, 0.19213233301101318, 0.18351788952122083, 0.18638774425831905, 0.06505919433614848, 0.05428789252651145, 0.056975676068955705, 0.055887317926775704, 0.061629029110693456, 0.05812423210672801, 0.06605009505597204, 0.0595226310380258, 0.054701809035672566]}, "mutation_prompt": null}
{"id": "2f60fd04-36ca-4e70-a50d-6eca36ac86f2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = int(self.budget / (10 * dim))\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 5\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n    \n    def _local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        current_solution = solution.copy()\n        \n        for _ in range(max_iters):\n            perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n            candidate_solution = np.clip(current_solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n            current_solution = candidate_solution\n        \n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Perform local search for further improvement\n                    improved_solution = self._local_search(trial, func, self.max_local_search_iterations)\n                    improved_score = func(improved_solution)\n                    evaluations += 1\n\n                    if improved_score < trial_score:\n                        self.population[i] = improved_solution\n                        population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "A differential evolution inspired algorithm with adaptive mutation and crossover rates, combined with local search for improved convergence.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7586f1e8-e7c7-407f-a0fa-018017367457", "metadata": {"aucs": [0.18208971723941392, 0.19044780879133782, 0.1944814775334901, 0.2079492851021223, 0.17917702938182867, 0.18967037904178918, 0.1705593670701916, 0.16187828336494914, 0.2229383382744914, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05935309629858021, 0.06532307984645247, 0.04649794784932315, 0.04644727609107535, 0.04499614422266951, 0.05562425914138225, 0.06268642132980273, 0.05907506524178552, 0.051520470733913304, 0.03467715508611835, 0.039198276970781265, 0.03454692445408358, 0.03459242227591841, 0.0411699979020812, 0.03129806261096579, 0.04043725828306066, 0.0376676544382879, 0.0346527313655286, 0.2807083072142528, 0.6105652585182215, 0.4869993098795534, 0.6570532174193082, 0.7495595214779892, 0.18225506480804565, 0.3452305610503642, 0.3891996998383733, 0.5910615175357019, 0.07634106074691682, 0.06904185530542817, 0.10538330655683925, 0.056634779120387946, 0.08412700827381958, 0.06774196189449633, 0.08432233118062882, 0.05520870054639415, 0.09153253121924632, 0.16068429858483213, 0.14448942409905174, 0.11197569144547215, 0.12130700200801692, 0.1157960036735649, 0.13150055516072967, 0.11584788732203177, 0.14398017923763706, 0.14187158614695394, 0.018822866096605884, 0.013082569823170909, 0.008741010202640398, 0.019949284469964024, 0.009053998249488382, 0.015099744583559005, 0.0071160422301538295, 0.009587929108363813, 0.0040625196639287875, 0.03002332168218469, 0.0308806700652956, 0.01635697373773115, 0.014038696103638393, 0.046390361653912415, 0.004977628607565343, 0.03365745941779974, 0.004815081436852386, 0.0031546484293323296, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06257191446633548, 0.04084849842647875, 0.06429968213783577, 0.07460750634287383, 0.04350987415709062, 0.07561951913583576, 0.06748586559351666, 0.0669977920590592, 0.07077720439477819, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010069130457675435, 0.005182889110050604, 0.007266691232700406, 0.00026542501123116846, 9.999999999998899e-05, 0.0033039776258505515, 0.00582416086701909, 0.0009232232850019395, 0.005880627472806044, 0.18159142342508794, 0.1784182603524741, 0.21027959683688568, 0.19602876575080153, 0.18855566959319814, 0.18150246226507893, 0.2056992330285755, 0.19047702465567606, 0.21630082128783867, 0.06375175379764442, 0.05922833952412143, 0.05893536366442875, 0.057855915070246344, 0.052112369973042805, 0.06357445307543663, 0.052403289360661964, 0.07095807532490306, 0.0652934109765454, 0.15005275113475314, 0.1506488113561829, 0.13417445969636865, 0.16452382506282193, 0.16173904650734117, 0.15509580990905925, 0.1452056442007652, 0.15448904011915165, 0.1537004039335741, 0.16896311931518815, 0.1711738681225835, 0.17803400916391743, 0.1604533739574565, 0.1769089461567308, 0.1794819472751531, 0.17614433948462005, 0.18447720239281784, 0.17206625863011127, 0.1162385714543529, 0.10800535920449494, 0.11272230319758414, 0.1225182612109087, 0.12028326919881915, 0.12015226841561144, 0.12179759932679868, 0.12932182443506368, 0.13804785211361903, 0.1525452438198519, 0.17057176514162298, 0.17889757176386178, 0.1734111176045945, 0.16281352986264852, 0.16763327126785788, 0.16102281036444788, 0.16035634329731252, 0.16697212694978514, 0.10255467497354398, 0.15983189906193018, 0.12877498704479318, 0.1465212429338102, 0.15103015053769864, 0.15013170028449185, 0.12844638256072072, 0.11767448077744613, 0.1620817151192654, 0.14788903562912314, 0.16224511892771565, 0.14686842068453698, 0.1386331389342098, 0.14100264776682747, 0.15665671435881556, 0.13860939059310418, 0.1713930906101485, 0.168635120730959, 0.13305558808562945, 0.1372611213094308, 0.13280608135356053, 0.14590830332380333, 0.14649173513828206, 0.15707870712231597, 0.17575116913703714, 0.13116847903651674, 0.14185129625297155, 0.18514073131559927, 0.184707316747165, 0.1732121021520323, 0.19235348047481793, 0.19356384818508843, 0.1908569035908636, 0.19213233301101318, 0.18351788952122083, 0.18638774425831905, 0.06505919433614848, 0.05428789252651145, 0.056975676068955705, 0.055887317926775704, 0.061629029110693456, 0.05812423210672801, 0.06605009505597204, 0.0595226310380258, 0.054701809035672566]}, "mutation_prompt": null}
{"id": "b37f5e73-c86d-4fc6-912e-89161256568a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = int(self.budget / (10 * dim))\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 5\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n    \n    def _local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        current_solution = solution.copy()\n        \n        for _ in range(max_iters):\n            perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n            candidate_solution = np.clip(current_solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n            current_solution = candidate_solution\n        \n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Perform local search for further improvement\n                    improved_solution = self._local_search(trial, func, self.max_local_search_iterations)\n                    improved_score = func(improved_solution)\n                    evaluations += 1\n\n                    if improved_score < trial_score:\n                        self.population[i] = improved_solution\n                        population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "A differential evolution inspired algorithm with adaptive mutation and crossover rates, combined with local search for improved convergence.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7586f1e8-e7c7-407f-a0fa-018017367457", "metadata": {"aucs": [0.18208971723941392, 0.19044780879133782, 0.1944814775334901, 0.2079492851021223, 0.17917702938182867, 0.18967037904178918, 0.1705593670701916, 0.16187828336494914, 0.2229383382744914, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05935309629858021, 0.06532307984645247, 0.04649794784932315, 0.04644727609107535, 0.04499614422266951, 0.05562425914138225, 0.06268642132980273, 0.05907506524178552, 0.051520470733913304, 0.03467715508611835, 0.039198276970781265, 0.03454692445408358, 0.03459242227591841, 0.0411699979020812, 0.03129806261096579, 0.04043725828306066, 0.0376676544382879, 0.0346527313655286, 0.2807083072142528, 0.6105652585182215, 0.4869993098795534, 0.6570532174193082, 0.7495595214779892, 0.18225506480804565, 0.3452305610503642, 0.3891996998383733, 0.5910615175357019, 0.07634106074691682, 0.06904185530542817, 0.10538330655683925, 0.056634779120387946, 0.08412700827381958, 0.06774196189449633, 0.08432233118062882, 0.05520870054639415, 0.09153253121924632, 0.16068429858483213, 0.14448942409905174, 0.11197569144547215, 0.12130700200801692, 0.1157960036735649, 0.13150055516072967, 0.11584788732203177, 0.14398017923763706, 0.14187158614695394, 0.018822866096605884, 0.013082569823170909, 0.008741010202640398, 0.019949284469964024, 0.009053998249488382, 0.015099744583559005, 0.0071160422301538295, 0.009587929108363813, 0.0040625196639287875, 0.03002332168218469, 0.0308806700652956, 0.01635697373773115, 0.014038696103638393, 0.046390361653912415, 0.004977628607565343, 0.03365745941779974, 0.004815081436852386, 0.0031546484293323296, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06257191446633548, 0.04084849842647875, 0.06429968213783577, 0.07460750634287383, 0.04350987415709062, 0.07561951913583576, 0.06748586559351666, 0.0669977920590592, 0.07077720439477819, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010069130457675435, 0.005182889110050604, 0.007266691232700406, 0.00026542501123116846, 9.999999999998899e-05, 0.0033039776258505515, 0.00582416086701909, 0.0009232232850019395, 0.005880627472806044, 0.18159142342508794, 0.1784182603524741, 0.21027959683688568, 0.19602876575080153, 0.18855566959319814, 0.18150246226507893, 0.2056992330285755, 0.19047702465567606, 0.21630082128783867, 0.06375175379764442, 0.05922833952412143, 0.05893536366442875, 0.057855915070246344, 0.052112369973042805, 0.06357445307543663, 0.052403289360661964, 0.07095807532490306, 0.0652934109765454, 0.15005275113475314, 0.1506488113561829, 0.13417445969636865, 0.16452382506282193, 0.16173904650734117, 0.15509580990905925, 0.1452056442007652, 0.15448904011915165, 0.1537004039335741, 0.16896311931518815, 0.1711738681225835, 0.17803400916391743, 0.1604533739574565, 0.1769089461567308, 0.1794819472751531, 0.17614433948462005, 0.18447720239281784, 0.17206625863011127, 0.1162385714543529, 0.10800535920449494, 0.11272230319758414, 0.1225182612109087, 0.12028326919881915, 0.12015226841561144, 0.12179759932679868, 0.12932182443506368, 0.13804785211361903, 0.1525452438198519, 0.17057176514162298, 0.17889757176386178, 0.1734111176045945, 0.16281352986264852, 0.16763327126785788, 0.16102281036444788, 0.16035634329731252, 0.16697212694978514, 0.10255467497354398, 0.15983189906193018, 0.12877498704479318, 0.1465212429338102, 0.15103015053769864, 0.15013170028449185, 0.12844638256072072, 0.11767448077744613, 0.1620817151192654, 0.14788903562912314, 0.16224511892771565, 0.14686842068453698, 0.1386331389342098, 0.14100264776682747, 0.15665671435881556, 0.13860939059310418, 0.1713930906101485, 0.168635120730959, 0.13305558808562945, 0.1372611213094308, 0.13280608135356053, 0.14590830332380333, 0.14649173513828206, 0.15707870712231597, 0.17575116913703714, 0.13116847903651674, 0.14185129625297155, 0.18514073131559927, 0.184707316747165, 0.1732121021520323, 0.19235348047481793, 0.19356384818508843, 0.1908569035908636, 0.19213233301101318, 0.18351788952122083, 0.18638774425831905, 0.06505919433614848, 0.05428789252651145, 0.056975676068955705, 0.055887317926775704, 0.061629029110693456, 0.05812423210672801, 0.06605009505597204, 0.0595226310380258, 0.054701809035672566]}, "mutation_prompt": null}
{"id": "f5d12d3f-5c4f-4da8-9f4a-85513e022d1d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = int(self.budget / (10 * dim))\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 5\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n    \n    def _local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        current_solution = solution.copy()\n        \n        for _ in range(max_iters):\n            perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n            candidate_solution = np.clip(current_solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n            current_solution = candidate_solution\n        \n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Perform local search for further improvement\n                    improved_solution = self._local_search(trial, func, self.max_local_search_iterations)\n                    improved_score = func(improved_solution)\n                    evaluations += 1\n\n                    if improved_score < trial_score:\n                        self.population[i] = improved_solution\n                        population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "A differential evolution inspired algorithm with adaptive mutation and crossover rates, combined with local search for improved convergence.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7586f1e8-e7c7-407f-a0fa-018017367457", "metadata": {"aucs": [0.18208971723941392, 0.19044780879133782, 0.1944814775334901, 0.2079492851021223, 0.17917702938182867, 0.18967037904178918, 0.1705593670701916, 0.16187828336494914, 0.2229383382744914, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05935309629858021, 0.06532307984645247, 0.04649794784932315, 0.04644727609107535, 0.04499614422266951, 0.05562425914138225, 0.06268642132980273, 0.05907506524178552, 0.051520470733913304, 0.03467715508611835, 0.039198276970781265, 0.03454692445408358, 0.03459242227591841, 0.0411699979020812, 0.03129806261096579, 0.04043725828306066, 0.0376676544382879, 0.0346527313655286, 0.2807083072142528, 0.6105652585182215, 0.4869993098795534, 0.6570532174193082, 0.7495595214779892, 0.18225506480804565, 0.3452305610503642, 0.3891996998383733, 0.5910615175357019, 0.07634106074691682, 0.06904185530542817, 0.10538330655683925, 0.056634779120387946, 0.08412700827381958, 0.06774196189449633, 0.08432233118062882, 0.05520870054639415, 0.09153253121924632, 0.16068429858483213, 0.14448942409905174, 0.11197569144547215, 0.12130700200801692, 0.1157960036735649, 0.13150055516072967, 0.11584788732203177, 0.14398017923763706, 0.14187158614695394, 0.018822866096605884, 0.013082569823170909, 0.008741010202640398, 0.019949284469964024, 0.009053998249488382, 0.015099744583559005, 0.0071160422301538295, 0.009587929108363813, 0.0040625196639287875, 0.03002332168218469, 0.0308806700652956, 0.01635697373773115, 0.014038696103638393, 0.046390361653912415, 0.004977628607565343, 0.03365745941779974, 0.004815081436852386, 0.0031546484293323296, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06257191446633548, 0.04084849842647875, 0.06429968213783577, 0.07460750634287383, 0.04350987415709062, 0.07561951913583576, 0.06748586559351666, 0.0669977920590592, 0.07077720439477819, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010069130457675435, 0.005182889110050604, 0.007266691232700406, 0.00026542501123116846, 9.999999999998899e-05, 0.0033039776258505515, 0.00582416086701909, 0.0009232232850019395, 0.005880627472806044, 0.18159142342508794, 0.1784182603524741, 0.21027959683688568, 0.19602876575080153, 0.18855566959319814, 0.18150246226507893, 0.2056992330285755, 0.19047702465567606, 0.21630082128783867, 0.06375175379764442, 0.05922833952412143, 0.05893536366442875, 0.057855915070246344, 0.052112369973042805, 0.06357445307543663, 0.052403289360661964, 0.07095807532490306, 0.0652934109765454, 0.15005275113475314, 0.1506488113561829, 0.13417445969636865, 0.16452382506282193, 0.16173904650734117, 0.15509580990905925, 0.1452056442007652, 0.15448904011915165, 0.1537004039335741, 0.16896311931518815, 0.1711738681225835, 0.17803400916391743, 0.1604533739574565, 0.1769089461567308, 0.1794819472751531, 0.17614433948462005, 0.18447720239281784, 0.17206625863011127, 0.1162385714543529, 0.10800535920449494, 0.11272230319758414, 0.1225182612109087, 0.12028326919881915, 0.12015226841561144, 0.12179759932679868, 0.12932182443506368, 0.13804785211361903, 0.1525452438198519, 0.17057176514162298, 0.17889757176386178, 0.1734111176045945, 0.16281352986264852, 0.16763327126785788, 0.16102281036444788, 0.16035634329731252, 0.16697212694978514, 0.10255467497354398, 0.15983189906193018, 0.12877498704479318, 0.1465212429338102, 0.15103015053769864, 0.15013170028449185, 0.12844638256072072, 0.11767448077744613, 0.1620817151192654, 0.14788903562912314, 0.16224511892771565, 0.14686842068453698, 0.1386331389342098, 0.14100264776682747, 0.15665671435881556, 0.13860939059310418, 0.1713930906101485, 0.168635120730959, 0.13305558808562945, 0.1372611213094308, 0.13280608135356053, 0.14590830332380333, 0.14649173513828206, 0.15707870712231597, 0.17575116913703714, 0.13116847903651674, 0.14185129625297155, 0.18514073131559927, 0.184707316747165, 0.1732121021520323, 0.19235348047481793, 0.19356384818508843, 0.1908569035908636, 0.19213233301101318, 0.18351788952122083, 0.18638774425831905, 0.06505919433614848, 0.05428789252651145, 0.056975676068955705, 0.055887317926775704, 0.061629029110693456, 0.05812423210672801, 0.06605009505597204, 0.0595226310380258, 0.054701809035672566]}, "mutation_prompt": null}
{"id": "a815b09b-4bb1-43be-a4ff-cf61bb3a5ff7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = int(self.budget / (10 * dim))\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 5\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n    \n    def _local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        current_solution = solution.copy()\n        \n        for _ in range(max_iters):\n            perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n            candidate_solution = np.clip(current_solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n            current_solution = candidate_solution\n        \n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Perform local search for further improvement\n                    improved_solution = self._local_search(trial, func, self.max_local_search_iterations)\n                    improved_score = func(improved_solution)\n                    evaluations += 1\n\n                    if improved_score < trial_score:\n                        self.population[i] = improved_solution\n                        population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "A differential evolution inspired algorithm with adaptive mutation and crossover rates, combined with local search for improved convergence.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7586f1e8-e7c7-407f-a0fa-018017367457", "metadata": {"aucs": [0.18208971723941392, 0.19044780879133782, 0.1944814775334901, 0.2079492851021223, 0.17917702938182867, 0.18967037904178918, 0.1705593670701916, 0.16187828336494914, 0.2229383382744914, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05935309629858021, 0.06532307984645247, 0.04649794784932315, 0.04644727609107535, 0.04499614422266951, 0.05562425914138225, 0.06268642132980273, 0.05907506524178552, 0.051520470733913304, 0.03467715508611835, 0.039198276970781265, 0.03454692445408358, 0.03459242227591841, 0.0411699979020812, 0.03129806261096579, 0.04043725828306066, 0.0376676544382879, 0.0346527313655286, 0.2807083072142528, 0.6105652585182215, 0.4869993098795534, 0.6570532174193082, 0.7495595214779892, 0.18225506480804565, 0.3452305610503642, 0.3891996998383733, 0.5910615175357019, 0.07634106074691682, 0.06904185530542817, 0.10538330655683925, 0.056634779120387946, 0.08412700827381958, 0.06774196189449633, 0.08432233118062882, 0.05520870054639415, 0.09153253121924632, 0.16068429858483213, 0.14448942409905174, 0.11197569144547215, 0.12130700200801692, 0.1157960036735649, 0.13150055516072967, 0.11584788732203177, 0.14398017923763706, 0.14187158614695394, 0.018822866096605884, 0.013082569823170909, 0.008741010202640398, 0.019949284469964024, 0.009053998249488382, 0.015099744583559005, 0.0071160422301538295, 0.009587929108363813, 0.0040625196639287875, 0.03002332168218469, 0.0308806700652956, 0.01635697373773115, 0.014038696103638393, 0.046390361653912415, 0.004977628607565343, 0.03365745941779974, 0.004815081436852386, 0.0031546484293323296, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06257191446633548, 0.04084849842647875, 0.06429968213783577, 0.07460750634287383, 0.04350987415709062, 0.07561951913583576, 0.06748586559351666, 0.0669977920590592, 0.07077720439477819, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010069130457675435, 0.005182889110050604, 0.007266691232700406, 0.00026542501123116846, 9.999999999998899e-05, 0.0033039776258505515, 0.00582416086701909, 0.0009232232850019395, 0.005880627472806044, 0.18159142342508794, 0.1784182603524741, 0.21027959683688568, 0.19602876575080153, 0.18855566959319814, 0.18150246226507893, 0.2056992330285755, 0.19047702465567606, 0.21630082128783867, 0.06375175379764442, 0.05922833952412143, 0.05893536366442875, 0.057855915070246344, 0.052112369973042805, 0.06357445307543663, 0.052403289360661964, 0.07095807532490306, 0.0652934109765454, 0.15005275113475314, 0.1506488113561829, 0.13417445969636865, 0.16452382506282193, 0.16173904650734117, 0.15509580990905925, 0.1452056442007652, 0.15448904011915165, 0.1537004039335741, 0.16896311931518815, 0.1711738681225835, 0.17803400916391743, 0.1604533739574565, 0.1769089461567308, 0.1794819472751531, 0.17614433948462005, 0.18447720239281784, 0.17206625863011127, 0.1162385714543529, 0.10800535920449494, 0.11272230319758414, 0.1225182612109087, 0.12028326919881915, 0.12015226841561144, 0.12179759932679868, 0.12932182443506368, 0.13804785211361903, 0.1525452438198519, 0.17057176514162298, 0.17889757176386178, 0.1734111176045945, 0.16281352986264852, 0.16763327126785788, 0.16102281036444788, 0.16035634329731252, 0.16697212694978514, 0.10255467497354398, 0.15983189906193018, 0.12877498704479318, 0.1465212429338102, 0.15103015053769864, 0.15013170028449185, 0.12844638256072072, 0.11767448077744613, 0.1620817151192654, 0.14788903562912314, 0.16224511892771565, 0.14686842068453698, 0.1386331389342098, 0.14100264776682747, 0.15665671435881556, 0.13860939059310418, 0.1713930906101485, 0.168635120730959, 0.13305558808562945, 0.1372611213094308, 0.13280608135356053, 0.14590830332380333, 0.14649173513828206, 0.15707870712231597, 0.17575116913703714, 0.13116847903651674, 0.14185129625297155, 0.18514073131559927, 0.184707316747165, 0.1732121021520323, 0.19235348047481793, 0.19356384818508843, 0.1908569035908636, 0.19213233301101318, 0.18351788952122083, 0.18638774425831905, 0.06505919433614848, 0.05428789252651145, 0.056975676068955705, 0.055887317926775704, 0.061629029110693456, 0.05812423210672801, 0.06605009505597204, 0.0595226310380258, 0.054701809035672566]}, "mutation_prompt": null}
{"id": "d724d241-d7ec-425e-9765-8302b93c5913", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = int(self.budget / (10 * dim))\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 5\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n    \n    def _local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        current_solution = solution.copy()\n        \n        for _ in range(max_iters):\n            perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n            candidate_solution = np.clip(current_solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n            current_solution = candidate_solution\n        \n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Perform local search for further improvement\n                    improved_solution = self._local_search(trial, func, self.max_local_search_iterations)\n                    improved_score = func(improved_solution)\n                    evaluations += 1\n\n                    if improved_score < trial_score:\n                        self.population[i] = improved_solution\n                        population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "A differential evolution inspired algorithm with adaptive mutation and crossover rates, combined with local search for improved convergence.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7586f1e8-e7c7-407f-a0fa-018017367457", "metadata": {"aucs": [0.18208971723941392, 0.19044780879133782, 0.1944814775334901, 0.2079492851021223, 0.17917702938182867, 0.18967037904178918, 0.1705593670701916, 0.16187828336494914, 0.2229383382744914, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05935309629858021, 0.06532307984645247, 0.04649794784932315, 0.04644727609107535, 0.04499614422266951, 0.05562425914138225, 0.06268642132980273, 0.05907506524178552, 0.051520470733913304, 0.03467715508611835, 0.039198276970781265, 0.03454692445408358, 0.03459242227591841, 0.0411699979020812, 0.03129806261096579, 0.04043725828306066, 0.0376676544382879, 0.0346527313655286, 0.2807083072142528, 0.6105652585182215, 0.4869993098795534, 0.6570532174193082, 0.7495595214779892, 0.18225506480804565, 0.3452305610503642, 0.3891996998383733, 0.5910615175357019, 0.07634106074691682, 0.06904185530542817, 0.10538330655683925, 0.056634779120387946, 0.08412700827381958, 0.06774196189449633, 0.08432233118062882, 0.05520870054639415, 0.09153253121924632, 0.16068429858483213, 0.14448942409905174, 0.11197569144547215, 0.12130700200801692, 0.1157960036735649, 0.13150055516072967, 0.11584788732203177, 0.14398017923763706, 0.14187158614695394, 0.018822866096605884, 0.013082569823170909, 0.008741010202640398, 0.019949284469964024, 0.009053998249488382, 0.015099744583559005, 0.0071160422301538295, 0.009587929108363813, 0.0040625196639287875, 0.03002332168218469, 0.0308806700652956, 0.01635697373773115, 0.014038696103638393, 0.046390361653912415, 0.004977628607565343, 0.03365745941779974, 0.004815081436852386, 0.0031546484293323296, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06257191446633548, 0.04084849842647875, 0.06429968213783577, 0.07460750634287383, 0.04350987415709062, 0.07561951913583576, 0.06748586559351666, 0.0669977920590592, 0.07077720439477819, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010069130457675435, 0.005182889110050604, 0.007266691232700406, 0.00026542501123116846, 9.999999999998899e-05, 0.0033039776258505515, 0.00582416086701909, 0.0009232232850019395, 0.005880627472806044, 0.18159142342508794, 0.1784182603524741, 0.21027959683688568, 0.19602876575080153, 0.18855566959319814, 0.18150246226507893, 0.2056992330285755, 0.19047702465567606, 0.21630082128783867, 0.06375175379764442, 0.05922833952412143, 0.05893536366442875, 0.057855915070246344, 0.052112369973042805, 0.06357445307543663, 0.052403289360661964, 0.07095807532490306, 0.0652934109765454, 0.15005275113475314, 0.1506488113561829, 0.13417445969636865, 0.16452382506282193, 0.16173904650734117, 0.15509580990905925, 0.1452056442007652, 0.15448904011915165, 0.1537004039335741, 0.16896311931518815, 0.1711738681225835, 0.17803400916391743, 0.1604533739574565, 0.1769089461567308, 0.1794819472751531, 0.17614433948462005, 0.18447720239281784, 0.17206625863011127, 0.1162385714543529, 0.10800535920449494, 0.11272230319758414, 0.1225182612109087, 0.12028326919881915, 0.12015226841561144, 0.12179759932679868, 0.12932182443506368, 0.13804785211361903, 0.1525452438198519, 0.17057176514162298, 0.17889757176386178, 0.1734111176045945, 0.16281352986264852, 0.16763327126785788, 0.16102281036444788, 0.16035634329731252, 0.16697212694978514, 0.10255467497354398, 0.15983189906193018, 0.12877498704479318, 0.1465212429338102, 0.15103015053769864, 0.15013170028449185, 0.12844638256072072, 0.11767448077744613, 0.1620817151192654, 0.14788903562912314, 0.16224511892771565, 0.14686842068453698, 0.1386331389342098, 0.14100264776682747, 0.15665671435881556, 0.13860939059310418, 0.1713930906101485, 0.168635120730959, 0.13305558808562945, 0.1372611213094308, 0.13280608135356053, 0.14590830332380333, 0.14649173513828206, 0.15707870712231597, 0.17575116913703714, 0.13116847903651674, 0.14185129625297155, 0.18514073131559927, 0.184707316747165, 0.1732121021520323, 0.19235348047481793, 0.19356384818508843, 0.1908569035908636, 0.19213233301101318, 0.18351788952122083, 0.18638774425831905, 0.06505919433614848, 0.05428789252651145, 0.056975676068955705, 0.055887317926775704, 0.061629029110693456, 0.05812423210672801, 0.06605009505597204, 0.0595226310380258, 0.054701809035672566]}, "mutation_prompt": null}
{"id": "f9e36e01-ee4d-4d66-a9d9-389ae3ddc9d8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = int(self.budget / (10 * dim))\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 5\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n    \n    def _local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        current_solution = solution.copy()\n        \n        for _ in range(max_iters):\n            perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n            candidate_solution = np.clip(current_solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n            current_solution = candidate_solution\n        \n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Perform local search for further improvement\n                    improved_solution = self._local_search(trial, func, self.max_local_search_iterations)\n                    improved_score = func(improved_solution)\n                    evaluations += 1\n\n                    if improved_score < trial_score:\n                        self.population[i] = improved_solution\n                        population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "A differential evolution inspired algorithm with adaptive mutation and crossover rates, combined with local search for improved convergence.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7586f1e8-e7c7-407f-a0fa-018017367457", "metadata": {"aucs": [0.18208971723941392, 0.19044780879133782, 0.1944814775334901, 0.2079492851021223, 0.17917702938182867, 0.18967037904178918, 0.1705593670701916, 0.16187828336494914, 0.2229383382744914, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05935309629858021, 0.06532307984645247, 0.04649794784932315, 0.04644727609107535, 0.04499614422266951, 0.05562425914138225, 0.06268642132980273, 0.05907506524178552, 0.051520470733913304, 0.03467715508611835, 0.039198276970781265, 0.03454692445408358, 0.03459242227591841, 0.0411699979020812, 0.03129806261096579, 0.04043725828306066, 0.0376676544382879, 0.0346527313655286, 0.2807083072142528, 0.6105652585182215, 0.4869993098795534, 0.6570532174193082, 0.7495595214779892, 0.18225506480804565, 0.3452305610503642, 0.3891996998383733, 0.5910615175357019, 0.07634106074691682, 0.06904185530542817, 0.10538330655683925, 0.056634779120387946, 0.08412700827381958, 0.06774196189449633, 0.08432233118062882, 0.05520870054639415, 0.09153253121924632, 0.16068429858483213, 0.14448942409905174, 0.11197569144547215, 0.12130700200801692, 0.1157960036735649, 0.13150055516072967, 0.11584788732203177, 0.14398017923763706, 0.14187158614695394, 0.018822866096605884, 0.013082569823170909, 0.008741010202640398, 0.019949284469964024, 0.009053998249488382, 0.015099744583559005, 0.0071160422301538295, 0.009587929108363813, 0.0040625196639287875, 0.03002332168218469, 0.0308806700652956, 0.01635697373773115, 0.014038696103638393, 0.046390361653912415, 0.004977628607565343, 0.03365745941779974, 0.004815081436852386, 0.0031546484293323296, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06257191446633548, 0.04084849842647875, 0.06429968213783577, 0.07460750634287383, 0.04350987415709062, 0.07561951913583576, 0.06748586559351666, 0.0669977920590592, 0.07077720439477819, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010069130457675435, 0.005182889110050604, 0.007266691232700406, 0.00026542501123116846, 9.999999999998899e-05, 0.0033039776258505515, 0.00582416086701909, 0.0009232232850019395, 0.005880627472806044, 0.18159142342508794, 0.1784182603524741, 0.21027959683688568, 0.19602876575080153, 0.18855566959319814, 0.18150246226507893, 0.2056992330285755, 0.19047702465567606, 0.21630082128783867, 0.06375175379764442, 0.05922833952412143, 0.05893536366442875, 0.057855915070246344, 0.052112369973042805, 0.06357445307543663, 0.052403289360661964, 0.07095807532490306, 0.0652934109765454, 0.15005275113475314, 0.1506488113561829, 0.13417445969636865, 0.16452382506282193, 0.16173904650734117, 0.15509580990905925, 0.1452056442007652, 0.15448904011915165, 0.1537004039335741, 0.16896311931518815, 0.1711738681225835, 0.17803400916391743, 0.1604533739574565, 0.1769089461567308, 0.1794819472751531, 0.17614433948462005, 0.18447720239281784, 0.17206625863011127, 0.1162385714543529, 0.10800535920449494, 0.11272230319758414, 0.1225182612109087, 0.12028326919881915, 0.12015226841561144, 0.12179759932679868, 0.12932182443506368, 0.13804785211361903, 0.1525452438198519, 0.17057176514162298, 0.17889757176386178, 0.1734111176045945, 0.16281352986264852, 0.16763327126785788, 0.16102281036444788, 0.16035634329731252, 0.16697212694978514, 0.10255467497354398, 0.15983189906193018, 0.12877498704479318, 0.1465212429338102, 0.15103015053769864, 0.15013170028449185, 0.12844638256072072, 0.11767448077744613, 0.1620817151192654, 0.14788903562912314, 0.16224511892771565, 0.14686842068453698, 0.1386331389342098, 0.14100264776682747, 0.15665671435881556, 0.13860939059310418, 0.1713930906101485, 0.168635120730959, 0.13305558808562945, 0.1372611213094308, 0.13280608135356053, 0.14590830332380333, 0.14649173513828206, 0.15707870712231597, 0.17575116913703714, 0.13116847903651674, 0.14185129625297155, 0.18514073131559927, 0.184707316747165, 0.1732121021520323, 0.19235348047481793, 0.19356384818508843, 0.1908569035908636, 0.19213233301101318, 0.18351788952122083, 0.18638774425831905, 0.06505919433614848, 0.05428789252651145, 0.056975676068955705, 0.055887317926775704, 0.061629029110693456, 0.05812423210672801, 0.06605009505597204, 0.0595226310380258, 0.054701809035672566]}, "mutation_prompt": null}
{"id": "c45e2055-2f78-41bd-81d5-a0b9f48f7928", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = int(self.budget / (10 * dim))\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 5\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n    \n    def _local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        current_solution = solution.copy()\n        \n        for _ in range(max_iters):\n            perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n            candidate_solution = np.clip(current_solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n            current_solution = candidate_solution\n        \n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Perform local search for further improvement\n                    improved_solution = self._local_search(trial, func, self.max_local_search_iterations)\n                    improved_score = func(improved_solution)\n                    evaluations += 1\n\n                    if improved_score < trial_score:\n                        self.population[i] = improved_solution\n                        population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "A differential evolution inspired algorithm with adaptive mutation and crossover rates, combined with local search for improved convergence.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7586f1e8-e7c7-407f-a0fa-018017367457", "metadata": {"aucs": [0.18208971723941392, 0.19044780879133782, 0.1944814775334901, 0.2079492851021223, 0.17917702938182867, 0.18967037904178918, 0.1705593670701916, 0.16187828336494914, 0.2229383382744914, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05935309629858021, 0.06532307984645247, 0.04649794784932315, 0.04644727609107535, 0.04499614422266951, 0.05562425914138225, 0.06268642132980273, 0.05907506524178552, 0.051520470733913304, 0.03467715508611835, 0.039198276970781265, 0.03454692445408358, 0.03459242227591841, 0.0411699979020812, 0.03129806261096579, 0.04043725828306066, 0.0376676544382879, 0.0346527313655286, 0.2807083072142528, 0.6105652585182215, 0.4869993098795534, 0.6570532174193082, 0.7495595214779892, 0.18225506480804565, 0.3452305610503642, 0.3891996998383733, 0.5910615175357019, 0.07634106074691682, 0.06904185530542817, 0.10538330655683925, 0.056634779120387946, 0.08412700827381958, 0.06774196189449633, 0.08432233118062882, 0.05520870054639415, 0.09153253121924632, 0.16068429858483213, 0.14448942409905174, 0.11197569144547215, 0.12130700200801692, 0.1157960036735649, 0.13150055516072967, 0.11584788732203177, 0.14398017923763706, 0.14187158614695394, 0.018822866096605884, 0.013082569823170909, 0.008741010202640398, 0.019949284469964024, 0.009053998249488382, 0.015099744583559005, 0.0071160422301538295, 0.009587929108363813, 0.0040625196639287875, 0.03002332168218469, 0.0308806700652956, 0.01635697373773115, 0.014038696103638393, 0.046390361653912415, 0.004977628607565343, 0.03365745941779974, 0.004815081436852386, 0.0031546484293323296, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06257191446633548, 0.04084849842647875, 0.06429968213783577, 0.07460750634287383, 0.04350987415709062, 0.07561951913583576, 0.06748586559351666, 0.0669977920590592, 0.07077720439477819, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010069130457675435, 0.005182889110050604, 0.007266691232700406, 0.00026542501123116846, 9.999999999998899e-05, 0.0033039776258505515, 0.00582416086701909, 0.0009232232850019395, 0.005880627472806044, 0.18159142342508794, 0.1784182603524741, 0.21027959683688568, 0.19602876575080153, 0.18855566959319814, 0.18150246226507893, 0.2056992330285755, 0.19047702465567606, 0.21630082128783867, 0.06375175379764442, 0.05922833952412143, 0.05893536366442875, 0.057855915070246344, 0.052112369973042805, 0.06357445307543663, 0.052403289360661964, 0.07095807532490306, 0.0652934109765454, 0.15005275113475314, 0.1506488113561829, 0.13417445969636865, 0.16452382506282193, 0.16173904650734117, 0.15509580990905925, 0.1452056442007652, 0.15448904011915165, 0.1537004039335741, 0.16896311931518815, 0.1711738681225835, 0.17803400916391743, 0.1604533739574565, 0.1769089461567308, 0.1794819472751531, 0.17614433948462005, 0.18447720239281784, 0.17206625863011127, 0.1162385714543529, 0.10800535920449494, 0.11272230319758414, 0.1225182612109087, 0.12028326919881915, 0.12015226841561144, 0.12179759932679868, 0.12932182443506368, 0.13804785211361903, 0.1525452438198519, 0.17057176514162298, 0.17889757176386178, 0.1734111176045945, 0.16281352986264852, 0.16763327126785788, 0.16102281036444788, 0.16035634329731252, 0.16697212694978514, 0.10255467497354398, 0.15983189906193018, 0.12877498704479318, 0.1465212429338102, 0.15103015053769864, 0.15013170028449185, 0.12844638256072072, 0.11767448077744613, 0.1620817151192654, 0.14788903562912314, 0.16224511892771565, 0.14686842068453698, 0.1386331389342098, 0.14100264776682747, 0.15665671435881556, 0.13860939059310418, 0.1713930906101485, 0.168635120730959, 0.13305558808562945, 0.1372611213094308, 0.13280608135356053, 0.14590830332380333, 0.14649173513828206, 0.15707870712231597, 0.17575116913703714, 0.13116847903651674, 0.14185129625297155, 0.18514073131559927, 0.184707316747165, 0.1732121021520323, 0.19235348047481793, 0.19356384818508843, 0.1908569035908636, 0.19213233301101318, 0.18351788952122083, 0.18638774425831905, 0.06505919433614848, 0.05428789252651145, 0.056975676068955705, 0.055887317926775704, 0.061629029110693456, 0.05812423210672801, 0.06605009505597204, 0.0595226310380258, 0.054701809035672566]}, "mutation_prompt": null}
{"id": "1e7ef7b1-2915-4f28-9319-36ffa7f04331", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = int(self.budget / (10 * dim))\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 5\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n    \n    def _local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        current_solution = solution.copy()\n        \n        for _ in range(max_iters):\n            perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n            candidate_solution = np.clip(current_solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n            current_solution = candidate_solution\n        \n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Perform local search for further improvement\n                    improved_solution = self._local_search(trial, func, self.max_local_search_iterations)\n                    improved_score = func(improved_solution)\n                    evaluations += 1\n\n                    if improved_score < trial_score:\n                        self.population[i] = improved_solution\n                        population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "A differential evolution inspired algorithm with adaptive mutation and crossover rates, combined with local search for improved convergence.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7586f1e8-e7c7-407f-a0fa-018017367457", "metadata": {"aucs": [0.18208971723941392, 0.19044780879133782, 0.1944814775334901, 0.2079492851021223, 0.17917702938182867, 0.18967037904178918, 0.1705593670701916, 0.16187828336494914, 0.2229383382744914, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05935309629858021, 0.06532307984645247, 0.04649794784932315, 0.04644727609107535, 0.04499614422266951, 0.05562425914138225, 0.06268642132980273, 0.05907506524178552, 0.051520470733913304, 0.03467715508611835, 0.039198276970781265, 0.03454692445408358, 0.03459242227591841, 0.0411699979020812, 0.03129806261096579, 0.04043725828306066, 0.0376676544382879, 0.0346527313655286, 0.2807083072142528, 0.6105652585182215, 0.4869993098795534, 0.6570532174193082, 0.7495595214779892, 0.18225506480804565, 0.3452305610503642, 0.3891996998383733, 0.5910615175357019, 0.07634106074691682, 0.06904185530542817, 0.10538330655683925, 0.056634779120387946, 0.08412700827381958, 0.06774196189449633, 0.08432233118062882, 0.05520870054639415, 0.09153253121924632, 0.16068429858483213, 0.14448942409905174, 0.11197569144547215, 0.12130700200801692, 0.1157960036735649, 0.13150055516072967, 0.11584788732203177, 0.14398017923763706, 0.14187158614695394, 0.018822866096605884, 0.013082569823170909, 0.008741010202640398, 0.019949284469964024, 0.009053998249488382, 0.015099744583559005, 0.0071160422301538295, 0.009587929108363813, 0.0040625196639287875, 0.03002332168218469, 0.0308806700652956, 0.01635697373773115, 0.014038696103638393, 0.046390361653912415, 0.004977628607565343, 0.03365745941779974, 0.004815081436852386, 0.0031546484293323296, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06257191446633548, 0.04084849842647875, 0.06429968213783577, 0.07460750634287383, 0.04350987415709062, 0.07561951913583576, 0.06748586559351666, 0.0669977920590592, 0.07077720439477819, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010069130457675435, 0.005182889110050604, 0.007266691232700406, 0.00026542501123116846, 9.999999999998899e-05, 0.0033039776258505515, 0.00582416086701909, 0.0009232232850019395, 0.005880627472806044, 0.18159142342508794, 0.1784182603524741, 0.21027959683688568, 0.19602876575080153, 0.18855566959319814, 0.18150246226507893, 0.2056992330285755, 0.19047702465567606, 0.21630082128783867, 0.06375175379764442, 0.05922833952412143, 0.05893536366442875, 0.057855915070246344, 0.052112369973042805, 0.06357445307543663, 0.052403289360661964, 0.07095807532490306, 0.0652934109765454, 0.15005275113475314, 0.1506488113561829, 0.13417445969636865, 0.16452382506282193, 0.16173904650734117, 0.15509580990905925, 0.1452056442007652, 0.15448904011915165, 0.1537004039335741, 0.16896311931518815, 0.1711738681225835, 0.17803400916391743, 0.1604533739574565, 0.1769089461567308, 0.1794819472751531, 0.17614433948462005, 0.18447720239281784, 0.17206625863011127, 0.1162385714543529, 0.10800535920449494, 0.11272230319758414, 0.1225182612109087, 0.12028326919881915, 0.12015226841561144, 0.12179759932679868, 0.12932182443506368, 0.13804785211361903, 0.1525452438198519, 0.17057176514162298, 0.17889757176386178, 0.1734111176045945, 0.16281352986264852, 0.16763327126785788, 0.16102281036444788, 0.16035634329731252, 0.16697212694978514, 0.10255467497354398, 0.15983189906193018, 0.12877498704479318, 0.1465212429338102, 0.15103015053769864, 0.15013170028449185, 0.12844638256072072, 0.11767448077744613, 0.1620817151192654, 0.14788903562912314, 0.16224511892771565, 0.14686842068453698, 0.1386331389342098, 0.14100264776682747, 0.15665671435881556, 0.13860939059310418, 0.1713930906101485, 0.168635120730959, 0.13305558808562945, 0.1372611213094308, 0.13280608135356053, 0.14590830332380333, 0.14649173513828206, 0.15707870712231597, 0.17575116913703714, 0.13116847903651674, 0.14185129625297155, 0.18514073131559927, 0.184707316747165, 0.1732121021520323, 0.19235348047481793, 0.19356384818508843, 0.1908569035908636, 0.19213233301101318, 0.18351788952122083, 0.18638774425831905, 0.06505919433614848, 0.05428789252651145, 0.056975676068955705, 0.055887317926775704, 0.061629029110693456, 0.05812423210672801, 0.06605009505597204, 0.0595226310380258, 0.054701809035672566]}, "mutation_prompt": null}
{"id": "fb61dc86-fc70-4721-866e-4a75c8feaf38", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.dynamic_population_scaling = 0.8  # Introduced dynamic scaling factor\n        self.population_size = int(self.budget / (8 * dim))  # Adjusted population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 3  # Reduced local search iterations for faster convergence\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.dynamic_population_scaling * self.mutation_factor * (\n            self.population[b] - self.population[c])  # Integrated dynamic scaling\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n    \n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)  # Changed to normal distribution\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Perform stochastic local search for further improvement\n                    improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                    improved_score = func(improved_solution)\n                    evaluations += 1\n\n                    if improved_score < trial_score:\n                        self.population[i] = improved_solution\n                        population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with stochastic local search and dynamic population scaling for improved convergence speed.", "configspace": "", "generation": 14, "fitness": 0.11630012950689045, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.11.", "error": "", "parent_id": "7586f1e8-e7c7-407f-a0fa-018017367457", "metadata": {"aucs": [0.20795871937614907, 0.24823041726229722, 0.19844407513474038, 0.19293545413335367, 0.2028049306957742, 0.19981482459290578, 0.1952652321871614, 0.20466608899983552, 0.20995194395512096, 9.999999999998899e-05, 0.001832990457867556, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007757251472736426, 0.0003327856415360486, 9.999999999998899e-05, 0.06466459009687786, 0.061132075663174135, 0.05825500773407144, 0.05650332798454383, 0.05174647045372949, 0.053537985497330354, 0.06068827446941871, 0.053425414910412306, 0.062159465021757954, 0.042834578020057634, 0.04671410078542326, 0.036044207233016046, 0.043097150741883694, 0.04255000265305575, 0.043686140940581764, 0.04113719267081173, 0.03899459627368884, 0.030146863760619258, 0.4279662569086572, 0.5267426058756992, 0.5360180404268334, 0.31397135708573287, 0.5312789919019374, 0.5389002922737662, 0.8205496628302421, 0.17495925230299003, 0.36661327037316294, 0.09362164844370635, 0.06933540122623705, 0.10171882691615464, 0.09883323358502716, 0.06941116920390811, 0.05496522313753682, 0.08977602631360038, 0.07179789321231111, 0.0925085819850654, 0.1620801448639242, 0.12971493286447056, 0.14265372916517705, 0.1762189929585113, 0.13844102688488324, 0.1618410696905006, 0.13396202614919106, 0.14929998551515422, 0.13883140484544876, 0.024026755283857115, 0.0439586300185667, 0.07091414417576947, 0.03241695722800142, 0.027920954917337815, 0.025260794836753142, 0.01952641276052347, 0.024449965540318086, 0.03400800900792733, 0.025000068682724863, 0.034841276782412, 0.03634555211879864, 0.010104851146647387, 0.06291369488757415, 0.020033324269577824, 0.03756660047486582, 0.011865972647892686, 0.030024539976032827, 9.999999999998899e-05, 0.002572167852644136, 9.999999999998899e-05, 0.0032517849805735466, 9.999999999998899e-05, 9.999999999998899e-05, 0.010402626974006624, 9.999999999998899e-05, 9.999999999998899e-05, 0.06802267602270273, 0.08766129246353471, 0.0729740650201759, 0.0859258854139413, 0.0517659405476687, 0.06876837976039352, 0.07725268592967405, 0.06205725238204396, 0.06103927102634987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02554811481345909, 0.00435419483886712, 0.011340853274690033, 0.016946847182702895, 0.008247746909672227, 0.006882771721418046, 0.014009789707040698, 0.0020321628023016736, 0.029011886554294652, 0.20092978713226162, 0.20393011128601224, 0.2551547552038431, 0.21110212300919684, 0.19671455676502714, 0.20534471821619482, 0.21728180494794047, 0.2087984076253071, 0.2149237542260396, 0.066058284127124, 0.056283153740468106, 0.056344917037018605, 0.06549290401652963, 0.05024124049474066, 0.06727351805583426, 0.050497942460407064, 0.06597414553501635, 0.06075252125956809, 0.14224843168324075, 0.1401298586193851, 0.15699817838371288, 0.1628114781758151, 0.15351353419887948, 0.15141880272458497, 0.14664217317937456, 0.16526058228595852, 0.14211451468671987, 0.1758555253547267, 0.17996752295904772, 0.18225572128915912, 0.18094959634689467, 0.18072329842912438, 0.181674660501279, 0.17671663684519023, 0.19767103231791916, 0.1700365264862861, 0.13384924498562378, 0.12258060711977925, 0.13706596474311394, 0.12706626069998694, 0.12482842150505291, 0.14174422883386906, 0.12532956796271844, 0.13050645428129426, 0.1192658152906304, 0.1938707017464113, 0.16084113928214516, 0.173015431339562, 0.17966609463315275, 0.17693589376718044, 0.17488781370891737, 0.17396994468754778, 0.16665020682319753, 0.1711050109322907, 0.16300569704958545, 0.15687749963244946, 0.1375346488518926, 0.13172034714270064, 0.15721224807405398, 0.16393027873945798, 0.13446210343606746, 0.13148895322043086, 0.16417468019440729, 0.15773370310368318, 0.18036246326973104, 0.16189079498590908, 0.1680792206817301, 0.1509583799793045, 0.16074956786419825, 0.1554904139705332, 0.16274123830945952, 0.1570876852941645, 0.13975995998245494, 0.19427582540709243, 0.15114982223282747, 0.19518512518796893, 0.1438322599544546, 0.17214263459560553, 0.24404477855546802, 0.17745711444216505, 0.17849174130035772, 0.17328694081711316, 0.18713509166605014, 0.17789169236489344, 0.18384897812251366, 0.17015179267943936, 0.17544778302536657, 0.1813476881130507, 0.17394865189523556, 0.17948287203880287, 0.06494392123889337, 0.05469685471989383, 0.05473932060922926, 0.061144598994306354, 0.0725498585692167, 0.05445558089367819, 0.05991047823980622, 0.05971263902766677, 0.06533994269868859]}, "mutation_prompt": null}
{"id": "4aa310e1-aadd-4713-a9a3-953af369a473", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.dynamic_population_scaling = 0.8  # Introduced dynamic scaling factor\n        self.population_size = int(self.budget / (8 * dim))  # Adjusted population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 3  # Reduced local search iterations for faster convergence\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.dynamic_population_scaling * self.mutation_factor * (\n            self.population[b] - self.population[c])  # Integrated dynamic scaling\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n    \n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)  # Changed to normal distribution\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Perform stochastic local search for further improvement\n                    improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                    improved_score = func(improved_solution)\n                    evaluations += 1\n\n                    if improved_score < trial_score:\n                        self.population[i] = improved_solution\n                        population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with stochastic local search and dynamic population scaling for improved convergence speed.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fb61dc86-fc70-4721-866e-4a75c8feaf38", "metadata": {"aucs": [0.20795871937614907, 0.24823041726229722, 0.19844407513474038, 0.19293545413335367, 0.2028049306957742, 0.19981482459290578, 0.1952652321871614, 0.20466608899983552, 0.20995194395512096, 9.999999999998899e-05, 0.001832990457867556, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007757251472736426, 0.0003327856415360486, 9.999999999998899e-05, 0.06466459009687786, 0.061132075663174135, 0.05825500773407144, 0.05650332798454383, 0.05174647045372949, 0.053537985497330354, 0.06068827446941871, 0.053425414910412306, 0.062159465021757954, 0.042834578020057634, 0.04671410078542326, 0.036044207233016046, 0.043097150741883694, 0.04255000265305575, 0.043686140940581764, 0.04113719267081173, 0.03899459627368884, 0.030146863760619258, 0.4279662569086572, 0.5267426058756992, 0.5360180404268334, 0.31397135708573287, 0.5312789919019374, 0.5389002922737662, 0.8205496628302421, 0.17495925230299003, 0.36661327037316294, 0.09362164844370635, 0.06933540122623705, 0.10171882691615464, 0.09883323358502716, 0.06941116920390811, 0.05496522313753682, 0.08977602631360038, 0.07179789321231111, 0.0925085819850654, 0.1620801448639242, 0.12971493286447056, 0.14265372916517705, 0.1762189929585113, 0.13844102688488324, 0.1618410696905006, 0.13396202614919106, 0.14929998551515422, 0.13883140484544876, 0.024026755283857115, 0.0439586300185667, 0.07091414417576947, 0.03241695722800142, 0.027920954917337815, 0.025260794836753142, 0.01952641276052347, 0.024449965540318086, 0.03400800900792733, 0.025000068682724863, 0.034841276782412, 0.03634555211879864, 0.010104851146647387, 0.06291369488757415, 0.020033324269577824, 0.03756660047486582, 0.011865972647892686, 0.030024539976032827, 9.999999999998899e-05, 0.002572167852644136, 9.999999999998899e-05, 0.0032517849805735466, 9.999999999998899e-05, 9.999999999998899e-05, 0.010402626974006624, 9.999999999998899e-05, 9.999999999998899e-05, 0.06802267602270273, 0.08766129246353471, 0.0729740650201759, 0.0859258854139413, 0.0517659405476687, 0.06876837976039352, 0.07725268592967405, 0.06205725238204396, 0.06103927102634987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02554811481345909, 0.00435419483886712, 0.011340853274690033, 0.016946847182702895, 0.008247746909672227, 0.006882771721418046, 0.014009789707040698, 0.0020321628023016736, 0.029011886554294652, 0.20092978713226162, 0.20393011128601224, 0.2551547552038431, 0.21110212300919684, 0.19671455676502714, 0.20534471821619482, 0.21728180494794047, 0.2087984076253071, 0.2149237542260396, 0.066058284127124, 0.056283153740468106, 0.056344917037018605, 0.06549290401652963, 0.05024124049474066, 0.06727351805583426, 0.050497942460407064, 0.06597414553501635, 0.06075252125956809, 0.14224843168324075, 0.1401298586193851, 0.15699817838371288, 0.1628114781758151, 0.15351353419887948, 0.15141880272458497, 0.14664217317937456, 0.16526058228595852, 0.14211451468671987, 0.1758555253547267, 0.17996752295904772, 0.18225572128915912, 0.18094959634689467, 0.18072329842912438, 0.181674660501279, 0.17671663684519023, 0.19767103231791916, 0.1700365264862861, 0.13384924498562378, 0.12258060711977925, 0.13706596474311394, 0.12706626069998694, 0.12482842150505291, 0.14174422883386906, 0.12532956796271844, 0.13050645428129426, 0.1192658152906304, 0.1938707017464113, 0.16084113928214516, 0.173015431339562, 0.17966609463315275, 0.17693589376718044, 0.17488781370891737, 0.17396994468754778, 0.16665020682319753, 0.1711050109322907, 0.16300569704958545, 0.15687749963244946, 0.1375346488518926, 0.13172034714270064, 0.15721224807405398, 0.16393027873945798, 0.13446210343606746, 0.13148895322043086, 0.16417468019440729, 0.15773370310368318, 0.18036246326973104, 0.16189079498590908, 0.1680792206817301, 0.1509583799793045, 0.16074956786419825, 0.1554904139705332, 0.16274123830945952, 0.1570876852941645, 0.13975995998245494, 0.19427582540709243, 0.15114982223282747, 0.19518512518796893, 0.1438322599544546, 0.17214263459560553, 0.24404477855546802, 0.17745711444216505, 0.17849174130035772, 0.17328694081711316, 0.18713509166605014, 0.17789169236489344, 0.18384897812251366, 0.17015179267943936, 0.17544778302536657, 0.1813476881130507, 0.17394865189523556, 0.17948287203880287, 0.06494392123889337, 0.05469685471989383, 0.05473932060922926, 0.061144598994306354, 0.0725498585692167, 0.05445558089367819, 0.05991047823980622, 0.05971263902766677, 0.06533994269868859]}, "mutation_prompt": null}
{"id": "1180c4e1-de51-4960-b90f-610980af5618", "solution": "import numpy as np\n\nclass ModifiedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.85  # Slightly adjusted\n        self.mutation_factor = 0.9  # Increased mutation factor for more diverse mutations\n        self.dynamic_population_scaling = 0.85  # Adjusted dynamic scaling factor\n        self.population_size = int(self.budget / (7 * dim))  # Slightly increased population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 4  # Increased local search iterations\n        self.local_search_intensity_factor = 0.5  # New parameter to adapt local search intensity\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c, d = np.random.choice(indices, 4, replace=False)\n        # Using four vectors for mutation to increase diversity\n        mutant_vector = self.population[a] + self.dynamic_population_scaling * self.mutation_factor * (\n            self.population[b] - self.population[c] + self.population[d] - self.population[a])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n    \n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(int(max_iters * self.local_search_intensity_factor)):  # Adaptive search intensity\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                    improved_score = func(improved_solution)\n                    evaluations += 1\n\n                    if improved_score < trial_score:\n                        self.population[i] = improved_solution\n                        population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "ModifiedAdaptiveDifferentialEvolution", "description": "Modified Adaptive Differential Evolution with increased mutation diversity and adaptive local search intensity for enhanced convergence.", "configspace": "", "generation": 16, "fitness": 0.11118047034426956, "feedback": "The algorithm ModifiedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.10.", "error": "", "parent_id": "fb61dc86-fc70-4721-866e-4a75c8feaf38", "metadata": {"aucs": [0.20856851986830482, 0.21266908622537817, 0.19653193666962065, 0.2168572027593455, 0.1936958937771378, 0.24854301350107189, 0.1941943848114649, 0.19576949990970605, 0.20820194500342726, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009898761558863378, 9.999999999998899e-05, 0.0001636666485806959, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06010308397884834, 0.05240742355465022, 0.06485024549099838, 0.05172560962060946, 0.0537447862559578, 0.055147773710664816, 0.0591408737713226, 0.05397445341934182, 0.06658339590884221, 0.03403612487250374, 0.038971462753214614, 0.04766972637907385, 0.04914244696870096, 0.047324903794411566, 0.03626545386107227, 0.04589000726769976, 0.036317745885074526, 0.047408421900218656, 0.16622351756668463, 0.5695912743273293, 0.20968348919781865, 0.3715846163664649, 0.2406130589118789, 0.15011956926610326, 0.8622784940795172, 0.593041831750342, 0.23593791204431114, 0.08152648289773279, 0.06570925550611373, 0.10235405972429346, 0.09281430338946595, 0.08044783472389538, 0.07073546221102156, 0.085895726679166, 0.07886203576617623, 0.0962509084520965, 0.16588340386287515, 0.1260352410274974, 0.14964739705506813, 0.1500348273236064, 0.13265996088924437, 0.15761035013305158, 0.13195563784754671, 0.1728184904431329, 0.1501421443671801, 0.011753226975448117, 0.023152501365526268, 0.01665149849586689, 0.029017319842882028, 0.03753438352405991, 0.030884957441819627, 0.014998688728517284, 0.022015328788200672, 0.023054286606711494, 0.024733097106465762, 0.030244817951963876, 0.030941767643057783, 0.02673534986977011, 0.04057554434429511, 0.04481033343927887, 0.028886537485012242, 0.03674112782379746, 0.05922538633314467, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.049324926506872924, 0.08231785221484356, 0.06548254729814684, 0.06628746862941748, 0.06100749349336532, 0.06123512748851445, 0.07637970761793533, 0.07429908319440004, 0.05993214088211918, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01352400025629541, 0.0071323990309809515, 0.014722160044993826, 0.004455499769542293, 0.007930018127903171, 0.003294806984737275, 0.002939126419876481, 0.0100558196806253, 0.008305855269519768, 0.21239198678062532, 0.2013191360305845, 0.2170984711050924, 0.20188219317054246, 0.20907848187204803, 0.20720954623155963, 0.22300668067282425, 0.22727323589953108, 0.20676661301238242, 0.06033277771204726, 0.05373623631830782, 0.05512695033970738, 0.06234816321605918, 0.056573062047459044, 0.06384374454815656, 0.054777228969992264, 0.0531263316923678, 0.06427761465789628, 0.1491243811495948, 0.1441428401075553, 0.12275624473787683, 0.15350909362026688, 0.13523667644779014, 0.13852861509666603, 0.14129371144522407, 0.15347004191847757, 0.15651666372908424, 0.18147481857409953, 0.16085481563584758, 0.18200004915043233, 0.1662247205397751, 0.18055809472460682, 0.18224455358553138, 0.17664843430907973, 0.19024973263710576, 0.17028398387561083, 0.12340815868242716, 0.12016406117913847, 0.1307842026264907, 0.10988228145993251, 0.11172552782007406, 0.11689554268696667, 0.1262857073081879, 0.13556323890958832, 0.12124180309642218, 0.16067635458005547, 0.17046366650302802, 0.17541748981519611, 0.2027331440973721, 0.16744500437828158, 0.16807199399265937, 0.177867720465809, 0.16174242473070777, 0.16307545782767996, 0.13881981359653506, 0.15880699065961001, 0.1548017123881762, 0.16123968969835534, 0.1603400927005012, 0.1601370250755514, 0.1354254784466442, 0.1447439070007316, 0.16577989943265825, 0.14885993889034677, 0.13685267114737854, 0.16493089864407162, 0.2564454827671948, 0.17906160507239932, 0.1576503748049778, 0.2039699311227795, 0.16685137040837184, 0.15692009224327252, 0.1419353976537946, 0.14830488830515964, 0.18598709328875895, 0.14421598114976242, 0.15988217822663098, 0.16041268994522395, 0.20331434554238526, 0.15203453081934282, 0.16239296319810204, 0.1725689193756469, 0.18414271945772032, 0.18296465681460328, 0.1794126046668253, 0.172445183893698, 0.18035416369578505, 0.18680022533082818, 0.18020679915345905, 0.1819975101109691, 0.05679694253980305, 0.053733476784821876, 0.06079905680383091, 0.05897308495054043, 0.06192149249095946, 0.06264569611010029, 0.05906817493507355, 0.07498663960713203, 0.056980177078258976]}, "mutation_prompt": null}
{"id": "cfeb00b0-432b-4333-840c-b30e828900e9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population_size = int(self.budget / (7 * dim))  # Adjusted population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 5  # Increased local search iterations for better exploration\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = np.random.uniform(0.5, 1.0)  # Dynamic mutation factor\n        mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        crossover_rate = np.random.uniform(0.8, 1.0)  # Adaptive crossover rate\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n    \n    def _stochastic_local_search(self, solution, func, threshold):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(self.max_local_search_iterations):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score and candidate_score < threshold:  # Threshold-based acceptance\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Perform stochastic local search for further improvement\n                    threshold = np.min(population_scores) + 0.1 * (np.max(population_scores) - np.min(population_scores))\n                    improved_solution = self._stochastic_local_search(trial, func, threshold)\n                    improved_score = func(improved_solution)\n                    evaluations += 1\n\n                    if improved_score < trial_score:\n                        self.population[i] = improved_solution\n                        population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with dynamic mutation, crossover strategies, and threshold-based local search for improved convergence speed.", "configspace": "", "generation": 17, "fitness": 0.10058721065021581, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.09.", "error": "", "parent_id": "fb61dc86-fc70-4721-866e-4a75c8feaf38", "metadata": {"aucs": [0.1810378926359676, 0.20226333792607165, 0.17347033878443252, 0.18254200534861298, 0.2103247164835721, 0.17824409261404195, 0.1707675898481501, 0.15996424677250654, 0.20123761939763618, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04749453219007305, 0.05611859935838037, 0.05467440666090584, 0.05897292705762647, 0.04071428041911562, 0.05473013168994134, 0.05155886481031269, 0.0588592555566978, 0.05422172062224506, 0.03302817305694461, 0.03571750112178795, 0.02913129416644622, 0.06274262313211076, 0.03746187185576433, 0.05134619285811426, 0.03807588648035509, 0.03507657343754467, 0.03705099651745036, 0.26571636889140016, 0.17028244239880985, 0.1887670740009787, 0.49579291957071825, 0.4657279570841192, 0.3082994322516406, 0.13330750829616578, 0.48006659170114474, 0.2892827821170657, 0.07543398699766568, 0.06722158784483723, 0.10171882691615464, 0.09419331430460243, 0.08311010356573989, 0.057492076905909184, 0.06190064236261661, 0.06700473296527998, 0.08919533621105913, 0.14718945187900523, 0.1140775158835835, 0.13407733849949655, 0.12987895197571964, 0.11117863312905318, 0.12899567563964776, 0.10674075056872645, 0.1254859208973247, 0.11129073371186682, 0.005095428461653895, 0.026295715188353497, 0.001871102496081245, 0.003271937792278745, 0.05729619839397149, 0.0006113220750597614, 0.005943998764790237, 0.0137482108593866, 0.00011116499634156174, 0.014011687262427408, 0.01333322550495708, 0.02108758049331305, 0.018721187916182713, 0.002128442144483378, 0.008550693873100479, 0.032563966935184374, 0.0047886307217049895, 0.00021193234096172908, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0593227409765692, 0.06918786297499468, 0.040577864927021645, 0.06403805079041935, 0.049116460269645, 0.0412927465360543, 0.07253814577129958, 0.0428250565608187, 0.062324310217734324, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0008505526073590008, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003788550682320202, 9.999999999998899e-05, 0.00260951177754265, 0.0002842184252808133, 0.1852269754749174, 0.18173697151744583, 0.19060997530927415, 0.1852811966334167, 0.19592288951793813, 0.19301897226864817, 0.2049214475050578, 0.21851469980591953, 0.17692227775562552, 0.0567129932607644, 0.049427930780261864, 0.05091779132867158, 0.05131029556973665, 0.04455048219166713, 0.05218302290687804, 0.03951083501235675, 0.05794095619018136, 0.05005579227272794, 0.15228700101992765, 0.16127289101888687, 0.13889721454415105, 0.18754744688571667, 0.16555888921474815, 0.15711939932513974, 0.1425771189796089, 0.17093576484947792, 0.13741789070855737, 0.1675366876944916, 0.1618982394337236, 0.16653590369028404, 0.17170002806546492, 0.1813501225557499, 0.17223476198477272, 0.17729092079422115, 0.1792251691142579, 0.16228657893938647, 0.10166157381324115, 0.1050250166375779, 0.10767308413710108, 0.11876332247240118, 0.12497771799563129, 0.1132622719716202, 0.1261237773155719, 0.1260443850348938, 0.11540359518161092, 0.16752434132277272, 0.17683484598160393, 0.16234455259732583, 0.1941514116195593, 0.1705616038209964, 0.17013822062426676, 0.16608447170212637, 0.15204196998840303, 0.16548329024359032, 0.15096944861024697, 0.16062892952022667, 0.12342400575418, 0.09108503403066825, 0.1406323812387289, 0.15499963086223012, 0.10030535762950621, 0.12768906106473388, 0.16283609238667762, 0.16652352451190833, 0.14070239637588033, 0.16286468398746423, 0.1860618588333397, 0.14798631605242774, 0.12928526035933374, 0.18595013731897303, 0.15067255093541476, 0.15692009224327252, 0.15138790792792567, 0.14255858530723364, 0.13678729431569536, 0.13861046638243535, 0.1562710718110064, 0.13312241555557813, 0.17390715065648432, 0.16788792441622447, 0.15285057131027602, 0.17671561962247484, 0.19435750605799884, 0.18211383669936532, 0.18389020616569407, 0.18555447860037788, 0.17837400166683526, 0.18044042628444767, 0.18638738746477812, 0.18262299769522738, 0.0584250225337275, 0.07955542625019663, 0.06425814630243554, 0.052129364392464184, 0.06173817117340352, 0.05623829816759063, 0.053361099799153044, 0.05955665478499561, 0.0538068946965945]}, "mutation_prompt": null}
{"id": "86ad9e88-d15f-4dbe-b734-2b0d80e2a410", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.dynamic_population_scaling = 0.8  # Introduced dynamic scaling factor\n        self.population_size = int(self.budget / (8 * dim))  # Adjusted population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 3  # Reduced local search iterations for faster convergence\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.dynamic_population_scaling * self.mutation_factor * (\n            self.population[b] - self.population[c])  # Integrated dynamic scaling\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n    \n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)  # Changed to normal distribution\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Perform stochastic local search for further improvement\n                    improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                    improved_score = func(improved_solution)\n                    evaluations += 1\n\n                    if improved_score < trial_score:\n                        self.population[i] = improved_solution\n                        population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with stochastic local search and dynamic population scaling for improved convergence speed.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fb61dc86-fc70-4721-866e-4a75c8feaf38", "metadata": {"aucs": [0.20795871937614907, 0.24823041726229722, 0.19844407513474038, 0.19293545413335367, 0.2028049306957742, 0.19981482459290578, 0.1952652321871614, 0.20466608899983552, 0.20995194395512096, 9.999999999998899e-05, 0.001832990457867556, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007757251472736426, 0.0003327856415360486, 9.999999999998899e-05, 0.06466459009687786, 0.061132075663174135, 0.05825500773407144, 0.05650332798454383, 0.05174647045372949, 0.053537985497330354, 0.06068827446941871, 0.053425414910412306, 0.062159465021757954, 0.042834578020057634, 0.04671410078542326, 0.036044207233016046, 0.043097150741883694, 0.04255000265305575, 0.043686140940581764, 0.04113719267081173, 0.03899459627368884, 0.030146863760619258, 0.4279662569086572, 0.5267426058756992, 0.5360180404268334, 0.31397135708573287, 0.5312789919019374, 0.5389002922737662, 0.8205496628302421, 0.17495925230299003, 0.36661327037316294, 0.09362164844370635, 0.06933540122623705, 0.10171882691615464, 0.09883323358502716, 0.06941116920390811, 0.05496522313753682, 0.08977602631360038, 0.07179789321231111, 0.0925085819850654, 0.1620801448639242, 0.12971493286447056, 0.14265372916517705, 0.1762189929585113, 0.13844102688488324, 0.1618410696905006, 0.13396202614919106, 0.14929998551515422, 0.13883140484544876, 0.024026755283857115, 0.0439586300185667, 0.07091414417576947, 0.03241695722800142, 0.027920954917337815, 0.025260794836753142, 0.01952641276052347, 0.024449965540318086, 0.03400800900792733, 0.025000068682724863, 0.034841276782412, 0.03634555211879864, 0.010104851146647387, 0.06291369488757415, 0.020033324269577824, 0.03756660047486582, 0.011865972647892686, 0.030024539976032827, 9.999999999998899e-05, 0.002572167852644136, 9.999999999998899e-05, 0.0032517849805735466, 9.999999999998899e-05, 9.999999999998899e-05, 0.010402626974006624, 9.999999999998899e-05, 9.999999999998899e-05, 0.06802267602270273, 0.08766129246353471, 0.0729740650201759, 0.0859258854139413, 0.0517659405476687, 0.06876837976039352, 0.07725268592967405, 0.06205725238204396, 0.06103927102634987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02554811481345909, 0.00435419483886712, 0.011340853274690033, 0.016946847182702895, 0.008247746909672227, 0.006882771721418046, 0.014009789707040698, 0.0020321628023016736, 0.029011886554294652, 0.20092978713226162, 0.20393011128601224, 0.2551547552038431, 0.21110212300919684, 0.19671455676502714, 0.20534471821619482, 0.21728180494794047, 0.2087984076253071, 0.2149237542260396, 0.066058284127124, 0.056283153740468106, 0.056344917037018605, 0.06549290401652963, 0.05024124049474066, 0.06727351805583426, 0.050497942460407064, 0.06597414553501635, 0.06075252125956809, 0.14224843168324075, 0.1401298586193851, 0.15699817838371288, 0.1628114781758151, 0.15351353419887948, 0.15141880272458497, 0.14664217317937456, 0.16526058228595852, 0.14211451468671987, 0.1758555253547267, 0.17996752295904772, 0.18225572128915912, 0.18094959634689467, 0.18072329842912438, 0.181674660501279, 0.17671663684519023, 0.19767103231791916, 0.1700365264862861, 0.13384924498562378, 0.12258060711977925, 0.13706596474311394, 0.12706626069998694, 0.12482842150505291, 0.14174422883386906, 0.12532956796271844, 0.13050645428129426, 0.1192658152906304, 0.1938707017464113, 0.16084113928214516, 0.173015431339562, 0.17966609463315275, 0.17693589376718044, 0.17488781370891737, 0.17396994468754778, 0.16665020682319753, 0.1711050109322907, 0.16300569704958545, 0.15687749963244946, 0.1375346488518926, 0.13172034714270064, 0.15721224807405398, 0.16393027873945798, 0.13446210343606746, 0.13148895322043086, 0.16417468019440729, 0.15773370310368318, 0.18036246326973104, 0.16189079498590908, 0.1680792206817301, 0.1509583799793045, 0.16074956786419825, 0.1554904139705332, 0.16274123830945952, 0.1570876852941645, 0.13975995998245494, 0.19427582540709243, 0.15114982223282747, 0.19518512518796893, 0.1438322599544546, 0.17214263459560553, 0.24404477855546802, 0.17745711444216505, 0.17849174130035772, 0.17328694081711316, 0.18713509166605014, 0.17789169236489344, 0.18384897812251366, 0.17015179267943936, 0.17544778302536657, 0.1813476881130507, 0.17394865189523556, 0.17948287203880287, 0.06494392123889337, 0.05469685471989383, 0.05473932060922926, 0.061144598994306354, 0.0725498585692167, 0.05445558089367819, 0.05991047823980622, 0.05971263902766677, 0.06533994269868859]}, "mutation_prompt": null}
{"id": "f405d32e-3553-4573-948b-71b909996848", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.dynamic_population_scaling = 0.8  # Introduced dynamic scaling factor\n        self.population_size = int(self.budget / (8 * dim))  # Adjusted population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 3  # Reduced local search iterations for faster convergence\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.dynamic_population_scaling * self.mutation_factor * (\n            self.population[b] - self.population[c])  # Integrated dynamic scaling\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n    \n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)  # Changed to normal distribution\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Perform stochastic local search for further improvement\n                    improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                    improved_score = func(improved_solution)\n                    evaluations += 1\n\n                    if improved_score < trial_score:\n                        self.population[i] = improved_solution\n                        population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with stochastic local search and dynamic population scaling for improved convergence speed.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fb61dc86-fc70-4721-866e-4a75c8feaf38", "metadata": {"aucs": [0.20795871937614907, 0.24823041726229722, 0.19844407513474038, 0.19293545413335367, 0.2028049306957742, 0.19981482459290578, 0.1952652321871614, 0.20466608899983552, 0.20995194395512096, 9.999999999998899e-05, 0.001832990457867556, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007757251472736426, 0.0003327856415360486, 9.999999999998899e-05, 0.06466459009687786, 0.061132075663174135, 0.05825500773407144, 0.05650332798454383, 0.05174647045372949, 0.053537985497330354, 0.06068827446941871, 0.053425414910412306, 0.062159465021757954, 0.042834578020057634, 0.04671410078542326, 0.036044207233016046, 0.043097150741883694, 0.04255000265305575, 0.043686140940581764, 0.04113719267081173, 0.03899459627368884, 0.030146863760619258, 0.4279662569086572, 0.5267426058756992, 0.5360180404268334, 0.31397135708573287, 0.5312789919019374, 0.5389002922737662, 0.8205496628302421, 0.17495925230299003, 0.36661327037316294, 0.09362164844370635, 0.06933540122623705, 0.10171882691615464, 0.09883323358502716, 0.06941116920390811, 0.05496522313753682, 0.08977602631360038, 0.07179789321231111, 0.0925085819850654, 0.1620801448639242, 0.12971493286447056, 0.14265372916517705, 0.1762189929585113, 0.13844102688488324, 0.1618410696905006, 0.13396202614919106, 0.14929998551515422, 0.13883140484544876, 0.024026755283857115, 0.0439586300185667, 0.07091414417576947, 0.03241695722800142, 0.027920954917337815, 0.025260794836753142, 0.01952641276052347, 0.024449965540318086, 0.03400800900792733, 0.025000068682724863, 0.034841276782412, 0.03634555211879864, 0.010104851146647387, 0.06291369488757415, 0.020033324269577824, 0.03756660047486582, 0.011865972647892686, 0.030024539976032827, 9.999999999998899e-05, 0.002572167852644136, 9.999999999998899e-05, 0.0032517849805735466, 9.999999999998899e-05, 9.999999999998899e-05, 0.010402626974006624, 9.999999999998899e-05, 9.999999999998899e-05, 0.06802267602270273, 0.08766129246353471, 0.0729740650201759, 0.0859258854139413, 0.0517659405476687, 0.06876837976039352, 0.07725268592967405, 0.06205725238204396, 0.06103927102634987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02554811481345909, 0.00435419483886712, 0.011340853274690033, 0.016946847182702895, 0.008247746909672227, 0.006882771721418046, 0.014009789707040698, 0.0020321628023016736, 0.029011886554294652, 0.20092978713226162, 0.20393011128601224, 0.2551547552038431, 0.21110212300919684, 0.19671455676502714, 0.20534471821619482, 0.21728180494794047, 0.2087984076253071, 0.2149237542260396, 0.066058284127124, 0.056283153740468106, 0.056344917037018605, 0.06549290401652963, 0.05024124049474066, 0.06727351805583426, 0.050497942460407064, 0.06597414553501635, 0.06075252125956809, 0.14224843168324075, 0.1401298586193851, 0.15699817838371288, 0.1628114781758151, 0.15351353419887948, 0.15141880272458497, 0.14664217317937456, 0.16526058228595852, 0.14211451468671987, 0.1758555253547267, 0.17996752295904772, 0.18225572128915912, 0.18094959634689467, 0.18072329842912438, 0.181674660501279, 0.17671663684519023, 0.19767103231791916, 0.1700365264862861, 0.13384924498562378, 0.12258060711977925, 0.13706596474311394, 0.12706626069998694, 0.12482842150505291, 0.14174422883386906, 0.12532956796271844, 0.13050645428129426, 0.1192658152906304, 0.1938707017464113, 0.16084113928214516, 0.173015431339562, 0.17966609463315275, 0.17693589376718044, 0.17488781370891737, 0.17396994468754778, 0.16665020682319753, 0.1711050109322907, 0.16300569704958545, 0.15687749963244946, 0.1375346488518926, 0.13172034714270064, 0.15721224807405398, 0.16393027873945798, 0.13446210343606746, 0.13148895322043086, 0.16417468019440729, 0.15773370310368318, 0.18036246326973104, 0.16189079498590908, 0.1680792206817301, 0.1509583799793045, 0.16074956786419825, 0.1554904139705332, 0.16274123830945952, 0.1570876852941645, 0.13975995998245494, 0.19427582540709243, 0.15114982223282747, 0.19518512518796893, 0.1438322599544546, 0.17214263459560553, 0.24404477855546802, 0.17745711444216505, 0.17849174130035772, 0.17328694081711316, 0.18713509166605014, 0.17789169236489344, 0.18384897812251366, 0.17015179267943936, 0.17544778302536657, 0.1813476881130507, 0.17394865189523556, 0.17948287203880287, 0.06494392123889337, 0.05469685471989383, 0.05473932060922926, 0.061144598994306354, 0.0725498585692167, 0.05445558089367819, 0.05991047823980622, 0.05971263902766677, 0.06533994269868859]}, "mutation_prompt": null}
{"id": "54ee7cc7-3657-455d-a44a-d487e1cf3fc0", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.dynamic_population_scaling = 0.8  # Introduced dynamic scaling factor\n        self.population_size = int(self.budget / (8 * dim))  # Adjusted population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 3  # Reduced local search iterations for faster convergence\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.dynamic_population_scaling * self.mutation_factor * (\n            self.population[b] - self.population[c])  # Integrated dynamic scaling\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n    \n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)  # Changed to normal distribution\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Perform stochastic local search for further improvement\n                    improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                    improved_score = func(improved_solution)\n                    evaluations += 1\n\n                    if improved_score < trial_score:\n                        self.population[i] = improved_solution\n                        population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with stochastic local search and dynamic population scaling for improved convergence speed.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fb61dc86-fc70-4721-866e-4a75c8feaf38", "metadata": {"aucs": [0.20795871937614907, 0.24823041726229722, 0.19844407513474038, 0.19293545413335367, 0.2028049306957742, 0.19981482459290578, 0.1952652321871614, 0.20466608899983552, 0.20995194395512096, 9.999999999998899e-05, 0.001832990457867556, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007757251472736426, 0.0003327856415360486, 9.999999999998899e-05, 0.06466459009687786, 0.061132075663174135, 0.05825500773407144, 0.05650332798454383, 0.05174647045372949, 0.053537985497330354, 0.06068827446941871, 0.053425414910412306, 0.062159465021757954, 0.042834578020057634, 0.04671410078542326, 0.036044207233016046, 0.043097150741883694, 0.04255000265305575, 0.043686140940581764, 0.04113719267081173, 0.03899459627368884, 0.030146863760619258, 0.4279662569086572, 0.5267426058756992, 0.5360180404268334, 0.31397135708573287, 0.5312789919019374, 0.5389002922737662, 0.8205496628302421, 0.17495925230299003, 0.36661327037316294, 0.09362164844370635, 0.06933540122623705, 0.10171882691615464, 0.09883323358502716, 0.06941116920390811, 0.05496522313753682, 0.08977602631360038, 0.07179789321231111, 0.0925085819850654, 0.1620801448639242, 0.12971493286447056, 0.14265372916517705, 0.1762189929585113, 0.13844102688488324, 0.1618410696905006, 0.13396202614919106, 0.14929998551515422, 0.13883140484544876, 0.024026755283857115, 0.0439586300185667, 0.07091414417576947, 0.03241695722800142, 0.027920954917337815, 0.025260794836753142, 0.01952641276052347, 0.024449965540318086, 0.03400800900792733, 0.025000068682724863, 0.034841276782412, 0.03634555211879864, 0.010104851146647387, 0.06291369488757415, 0.020033324269577824, 0.03756660047486582, 0.011865972647892686, 0.030024539976032827, 9.999999999998899e-05, 0.002572167852644136, 9.999999999998899e-05, 0.0032517849805735466, 9.999999999998899e-05, 9.999999999998899e-05, 0.010402626974006624, 9.999999999998899e-05, 9.999999999998899e-05, 0.06802267602270273, 0.08766129246353471, 0.0729740650201759, 0.0859258854139413, 0.0517659405476687, 0.06876837976039352, 0.07725268592967405, 0.06205725238204396, 0.06103927102634987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02554811481345909, 0.00435419483886712, 0.011340853274690033, 0.016946847182702895, 0.008247746909672227, 0.006882771721418046, 0.014009789707040698, 0.0020321628023016736, 0.029011886554294652, 0.20092978713226162, 0.20393011128601224, 0.2551547552038431, 0.21110212300919684, 0.19671455676502714, 0.20534471821619482, 0.21728180494794047, 0.2087984076253071, 0.2149237542260396, 0.066058284127124, 0.056283153740468106, 0.056344917037018605, 0.06549290401652963, 0.05024124049474066, 0.06727351805583426, 0.050497942460407064, 0.06597414553501635, 0.06075252125956809, 0.14224843168324075, 0.1401298586193851, 0.15699817838371288, 0.1628114781758151, 0.15351353419887948, 0.15141880272458497, 0.14664217317937456, 0.16526058228595852, 0.14211451468671987, 0.1758555253547267, 0.17996752295904772, 0.18225572128915912, 0.18094959634689467, 0.18072329842912438, 0.181674660501279, 0.17671663684519023, 0.19767103231791916, 0.1700365264862861, 0.13384924498562378, 0.12258060711977925, 0.13706596474311394, 0.12706626069998694, 0.12482842150505291, 0.14174422883386906, 0.12532956796271844, 0.13050645428129426, 0.1192658152906304, 0.1938707017464113, 0.16084113928214516, 0.173015431339562, 0.17966609463315275, 0.17693589376718044, 0.17488781370891737, 0.17396994468754778, 0.16665020682319753, 0.1711050109322907, 0.16300569704958545, 0.15687749963244946, 0.1375346488518926, 0.13172034714270064, 0.15721224807405398, 0.16393027873945798, 0.13446210343606746, 0.13148895322043086, 0.16417468019440729, 0.15773370310368318, 0.18036246326973104, 0.16189079498590908, 0.1680792206817301, 0.1509583799793045, 0.16074956786419825, 0.1554904139705332, 0.16274123830945952, 0.1570876852941645, 0.13975995998245494, 0.19427582540709243, 0.15114982223282747, 0.19518512518796893, 0.1438322599544546, 0.17214263459560553, 0.24404477855546802, 0.17745711444216505, 0.17849174130035772, 0.17328694081711316, 0.18713509166605014, 0.17789169236489344, 0.18384897812251366, 0.17015179267943936, 0.17544778302536657, 0.1813476881130507, 0.17394865189523556, 0.17948287203880287, 0.06494392123889337, 0.05469685471989383, 0.05473932060922926, 0.061144598994306354, 0.0725498585692167, 0.05445558089367819, 0.05991047823980622, 0.05971263902766677, 0.06533994269868859]}, "mutation_prompt": null}
{"id": "ddc0a887-a31f-4043-af48-af544f1812ee", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.dynamic_population_scaling = 0.9  # Increased dynamic scaling for exploration\n        self.population_size = int(self.budget / (7 * dim))  # Increased population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 2  # Reduced local search iterations to prioritize global search\n        self.local_search_probability = 0.5  # Added local search probability\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.dynamic_population_scaling * self.mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        adaptive_crossover_rate = self.crossover_rate * (1.0 - np.random.rand())  # Adaptive crossover rate\n        crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n    \n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.local_search_probability:  # Conditional local search\n                        improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Dynamic Differential Evolution with adaptive crossover and local search probability for accelerated convergence.", "configspace": "", "generation": 21, "fitness": 0.12154134269075484, "feedback": "The algorithm EnhancedDynamicDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.12.", "error": "", "parent_id": "fb61dc86-fc70-4721-866e-4a75c8feaf38", "metadata": {"aucs": [0.22632615881068063, 0.22620806649824254, 0.2299711867268709, 0.22490779018406803, 0.2056289400103577, 0.2082440140590901, 0.23119135795109214, 0.21206640320689552, 0.20227894613971165, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06920273910228336, 0.0681844588090127, 0.07318436271832907, 0.0725265307405325, 0.062102467616157675, 0.06068122814019283, 0.05665562450032269, 0.06940574062543348, 0.05796984700667929, 0.050987518205446225, 0.04943714417102529, 0.04473815139583426, 0.06095132388020974, 0.04750761402317816, 0.0584168563061247, 0.05491325051653362, 0.053970300085772194, 0.04169966652348811, 0.48013036084618, 0.5758250413563912, 0.579679705098571, 0.747092852751919, 0.5602371341377175, 0.650243306176054, 0.5913114174524933, 0.5683138904921403, 0.5584838928090761, 0.08372906097317556, 0.06972962600685462, 0.10975650667038372, 0.09048835504481467, 0.0759700254798632, 0.09375194432770317, 0.08121996136730392, 0.08713684503859409, 0.0943698424044096, 0.1508674026091389, 0.1594289081195318, 0.1443762887859562, 0.12949630005689594, 0.13577514418557257, 0.14292459312458627, 0.12392260002577293, 0.15530277154079197, 0.13981350755006738, 0.02555918736944207, 0.02764594865575709, 0.04760938478942067, 0.04883796551124997, 0.04277258867796552, 0.02930820402926093, 0.02453323514403205, 0.013219924813650086, 0.03855468068224088, 0.024729092818066012, 0.013427574356401406, 0.023108715872613317, 0.03099828335738619, 0.031174256032267644, 0.024596475694001696, 0.019586154410494383, 0.01686112004061091, 0.015221612006339647, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03999790904108069, 0.06628631353237158, 0.06769798371855629, 0.06449451549494856, 0.06147138720848655, 0.06055635419372174, 0.02911707579078593, 0.07641188905068097, 0.07921217573718298, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004303419775129602, 0.0027180792382196506, 0.0031172105885376444, 0.002357029655279841, 0.016266423306225963, 0.0010958015450307501, 0.006972721778327973, 0.003637484187210438, 0.025365174591294504, 0.21480801520043247, 0.2090117248780895, 0.21744254294074494, 0.20569496139445298, 0.2219948693158179, 0.21994332002604255, 0.2256352544845538, 0.22419941023666712, 0.2208818494916852, 0.046764602295961244, 0.054496654655007304, 0.06176260360088548, 0.08451684334020138, 0.05346405773101326, 0.0585064227480272, 0.054586632826866266, 0.05974006035951529, 0.05607601276793561, 0.17185892624465438, 0.15390447823951947, 0.14588119266185673, 0.14754754871649, 0.15262821328102671, 0.1295505085715195, 0.16495761152741528, 0.14632390391485983, 0.15332218604409642, 0.16981170033022497, 0.18503364195582017, 0.1739639316496443, 0.18616236854081913, 0.17855878434222672, 0.1775025142765979, 0.17580568316507617, 0.18709714913580988, 0.17601747318245398, 0.12045349178886755, 0.13551972399457224, 0.11458510884748063, 0.11787531501120863, 0.11565492363095653, 0.126472325387317, 0.1309647160728853, 0.12912877412676094, 0.11529396452200058, 0.17714769598359148, 0.15482511213015748, 0.15740534398000217, 0.18048885631447487, 0.1747726320866423, 0.17232446271888802, 0.16515038566992257, 0.1768202427002712, 0.1666345774266852, 0.15082422198675194, 0.15972953463624273, 0.12866485244277714, 0.14816036648122588, 0.15728505515927516, 0.15887520433990354, 0.1274357004901414, 0.12531511998238076, 0.1710188541949239, 0.15791901459273672, 0.16442719778093928, 0.16362290110481603, 0.1532914190235164, 0.18184525672756713, 0.15135817889915215, 0.19711782628626828, 0.17113336829481818, 0.1644025631155619, 0.16331991230729692, 0.18658290457508442, 0.22232485728360318, 0.21660020562450355, 0.1570806582907508, 0.15257810865640098, 0.17736195865511017, 0.16448511620968853, 0.15900075073557896, 0.18424307637046933, 0.18589955872335373, 0.18661249444407568, 0.1710319693237572, 0.19275953612250907, 0.17959278973521509, 0.1852672733963373, 0.18643125679720085, 0.18791749828325366, 0.06265669343959668, 0.05696028701484124, 0.06064817769846487, 0.0553770200121817, 0.06684471771730316, 0.05767544323581364, 0.05803130756841712, 0.07716788140391906, 0.058822300492829216]}, "mutation_prompt": null}
{"id": "fc70b20b-65b1-495f-93c8-6a8e058c3d28", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.85  # Tuned crossover rate\n        self.mutation_factor = 0.8\n        self.self_adaptive_mutation = 0.5  # Self-adaptive mutation factor\n        self.dynamic_population_scaling = 1.1  # Increased dynamic scaling for exploration\n        self.population_size = int(self.budget / (5 * dim))  # Adjusted population size for more initial exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 1  # Reduced local search iterations further\n        self.local_search_probability = 0.4  # Modified local search probability\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.dynamic_population_scaling * (\n            self.mutation_factor + np.random.rand() * self.self_adaptive_mutation) * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n    \n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                # Greedy selection strategy\n                if trial_score < population_scores[i] or np.random.rand() < self.local_search_probability:\n                    improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                    improved_score = func(improved_solution)\n                    evaluations += 1\n\n                    if improved_score < trial_score:\n                        self.population[i] = improved_solution\n                        population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Dynamic Differential Evolution with adaptive greedy selection and self-adaptive mutation factor for improved exploration and convergence.", "configspace": "", "generation": 22, "fitness": 0.10453476995137788, "feedback": "The algorithm EnhancedDynamicDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.15.", "error": "", "parent_id": "ddc0a887-a31f-4043-af48-af544f1812ee", "metadata": {"aucs": [0.16834045273823017, 0.16875996929289283, 0.1482586667575284, 0.15688353723687376, 0.14611979116424045, 0.15066796213067446, 0.13303755640818438, 0.13487118161493383, 0.14368718808954417, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.033421294097201515, 0.034292347218073505, 0.025906875120892847, 0.04256038597016998, 0.024621207090537833, 0.03662342001376073, 0.04010939827922444, 0.031045701818340987, 0.03717894638119634, 0.006244898081756545, 0.009320220325768958, 0.02616622588534756, 0.02098013938090393, 0.012664264664257296, 0.026537898914928193, 0.028598650100051026, 0.013113190517482165, 0.003899909133019408, 0.9124730771915357, 0.5722710583765226, 0.6718765452542841, 0.7134892392096668, 0.8276186375281731, 0.6496875533105713, 0.7348390776768254, 0.7441336764668377, 0.755145942203356, 0.08789578617916671, 0.032688093039965005, 0.10171882691615464, 0.03948492303434448, 0.062276416502640486, 0.027402818177791777, 0.055573730684816525, 0.048736100977349595, 0.1106593468881738, 0.11661272401821698, 0.19308637766117165, 0.09308426121880731, 0.11597389174592299, 0.08725967331655338, 0.09203739945813727, 0.11070216815843992, 0.10538735338755245, 0.11098937442246293, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005573400486922009, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006062927942487639, 0.004033634192843194, 0.0066828989844792686, 9.999999999998899e-05, 0.035362057023575866, 9.999999999998899e-05, 0.017993280776203546, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.023778370403007787, 0.06535045920481664, 0.04490689360873623, 0.06236963544458174, 0.021660397755754124, 0.005432627749066388, 0.10652459347764365, 0.023410435433450894, 0.032420382410983994, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.15295090712784054, 0.18462911766473922, 0.16308692172496542, 0.2055799784281095, 0.18130200804568508, 0.19226744717352073, 0.17726971074994213, 0.18114075080913095, 0.1532013052932909, 0.04806475863377413, 0.03826917587819356, 0.03232206226191792, 0.03266886175302153, 0.01827894705814248, 0.03103868566967416, 0.02162606765085351, 0.03601844466638582, 0.05645954464627667, 0.1372392836042996, 0.11164083219347465, 0.14835089657400968, 0.13766266535167793, 0.14172967435067496, 0.1333699863387312, 0.14963138758589234, 0.12001216886445365, 0.125953383171586, 0.1602710620254989, 0.15059180881326262, 0.1613932299901244, 0.1435242001077266, 0.14507912278510926, 0.161856142914947, 0.14569292081907914, 0.17377774300845283, 0.15192080156342758, 0.08696114089045126, 0.08741673565111119, 0.09426338487409935, 0.09374426197896468, 0.08339382945951368, 0.09793549997287943, 0.0850734229861797, 0.1237427242099084, 0.10058216101424622, 0.13920359879336852, 0.13329099949378853, 0.14031872906718923, 0.16440860638356625, 0.13790020956197535, 0.1592926511401882, 0.1605452527677247, 0.15873644631483674, 0.13980564630654213, 0.016952042055332295, 0.14205085413662677, 0.10293264078674924, 0.0160569351946942, 0.12836358984479923, 0.14183785494522416, 0.06450843071473267, 0.13042340421473364, 0.16207881422481074, 0.12203170589672896, 0.14688057719587655, 0.1593083731255257, 0.15176503580803635, 0.13065324090542507, 0.10920696521473638, 0.1123263718963261, 0.12639814869109778, 0.16454818275974537, 0.1508502679300836, 0.11957101406948278, 0.12206946191677615, 0.11321931362030901, 0.11042941706485088, 0.10913184713065671, 0.1609143438768892, 0.1607188668414654, 0.23324370495529134, 0.17229955664632723, 0.19088737855583793, 0.18626606062531437, 0.18714514777635627, 0.18397708293805304, 0.19098339285879962, 0.17832528638435108, 0.17553316996913382, 0.18659196259488942, 0.039428375373287805, 0.0476667368595004, 0.03547146096559228, 0.0496458412526628, 0.058815507864153016, 0.0388165651178235, 0.03700558446790492, 0.041440445548173166, 0.034874696192019994]}, "mutation_prompt": null}
{"id": "a23cd232-0934-487c-9295-60bcdf7fc968", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.dynamic_population_scaling = 0.9  # Increased dynamic scaling for exploration\n        self.population_size = int(self.budget / (7 * dim))  # Increased population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 2  # Reduced local search iterations to prioritize global search\n        self.local_search_probability = 0.5  # Added local search probability\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.dynamic_population_scaling * self.mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        adaptive_crossover_rate = self.crossover_rate * (1.0 - np.random.rand())  # Adaptive crossover rate\n        crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n    \n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.local_search_probability:  # Conditional local search\n                        improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Dynamic Differential Evolution with adaptive crossover and local search probability for accelerated convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ddc0a887-a31f-4043-af48-af544f1812ee", "metadata": {"aucs": [0.22632615881068063, 0.22620806649824254, 0.2299711867268709, 0.22490779018406803, 0.2056289400103577, 0.2082440140590901, 0.23119135795109214, 0.21206640320689552, 0.20227894613971165, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06920273910228336, 0.0681844588090127, 0.07318436271832907, 0.0725265307405325, 0.062102467616157675, 0.06068122814019283, 0.05665562450032269, 0.06940574062543348, 0.05796984700667929, 0.050987518205446225, 0.04943714417102529, 0.04473815139583426, 0.06095132388020974, 0.04750761402317816, 0.0584168563061247, 0.05491325051653362, 0.053970300085772194, 0.04169966652348811, 0.48013036084618, 0.5758250413563912, 0.579679705098571, 0.747092852751919, 0.5602371341377175, 0.650243306176054, 0.5913114174524933, 0.5683138904921403, 0.5584838928090761, 0.08372906097317556, 0.06972962600685462, 0.10975650667038372, 0.09048835504481467, 0.0759700254798632, 0.09375194432770317, 0.08121996136730392, 0.08713684503859409, 0.0943698424044096, 0.1508674026091389, 0.1594289081195318, 0.1443762887859562, 0.12949630005689594, 0.13577514418557257, 0.14292459312458627, 0.12392260002577293, 0.15530277154079197, 0.13981350755006738, 0.02555918736944207, 0.02764594865575709, 0.04760938478942067, 0.04883796551124997, 0.04277258867796552, 0.02930820402926093, 0.02453323514403205, 0.013219924813650086, 0.03855468068224088, 0.024729092818066012, 0.013427574356401406, 0.023108715872613317, 0.03099828335738619, 0.031174256032267644, 0.024596475694001696, 0.019586154410494383, 0.01686112004061091, 0.015221612006339647, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03999790904108069, 0.06628631353237158, 0.06769798371855629, 0.06449451549494856, 0.06147138720848655, 0.06055635419372174, 0.02911707579078593, 0.07641188905068097, 0.07921217573718298, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004303419775129602, 0.0027180792382196506, 0.0031172105885376444, 0.002357029655279841, 0.016266423306225963, 0.0010958015450307501, 0.006972721778327973, 0.003637484187210438, 0.025365174591294504, 0.21480801520043247, 0.2090117248780895, 0.21744254294074494, 0.20569496139445298, 0.2219948693158179, 0.21994332002604255, 0.2256352544845538, 0.22419941023666712, 0.2208818494916852, 0.046764602295961244, 0.054496654655007304, 0.06176260360088548, 0.08451684334020138, 0.05346405773101326, 0.0585064227480272, 0.054586632826866266, 0.05974006035951529, 0.05607601276793561, 0.17185892624465438, 0.15390447823951947, 0.14588119266185673, 0.14754754871649, 0.15262821328102671, 0.1295505085715195, 0.16495761152741528, 0.14632390391485983, 0.15332218604409642, 0.16981170033022497, 0.18503364195582017, 0.1739639316496443, 0.18616236854081913, 0.17855878434222672, 0.1775025142765979, 0.17580568316507617, 0.18709714913580988, 0.17601747318245398, 0.12045349178886755, 0.13551972399457224, 0.11458510884748063, 0.11787531501120863, 0.11565492363095653, 0.126472325387317, 0.1309647160728853, 0.12912877412676094, 0.11529396452200058, 0.17714769598359148, 0.15482511213015748, 0.15740534398000217, 0.18048885631447487, 0.1747726320866423, 0.17232446271888802, 0.16515038566992257, 0.1768202427002712, 0.1666345774266852, 0.15082422198675194, 0.15972953463624273, 0.12866485244277714, 0.14816036648122588, 0.15728505515927516, 0.15887520433990354, 0.1274357004901414, 0.12531511998238076, 0.1710188541949239, 0.15791901459273672, 0.16442719778093928, 0.16362290110481603, 0.1532914190235164, 0.18184525672756713, 0.15135817889915215, 0.19711782628626828, 0.17113336829481818, 0.1644025631155619, 0.16331991230729692, 0.18658290457508442, 0.22232485728360318, 0.21660020562450355, 0.1570806582907508, 0.15257810865640098, 0.17736195865511017, 0.16448511620968853, 0.15900075073557896, 0.18424307637046933, 0.18589955872335373, 0.18661249444407568, 0.1710319693237572, 0.19275953612250907, 0.17959278973521509, 0.1852672733963373, 0.18643125679720085, 0.18791749828325366, 0.06265669343959668, 0.05696028701484124, 0.06064817769846487, 0.0553770200121817, 0.06684471771730316, 0.05767544323581364, 0.05803130756841712, 0.07716788140391906, 0.058822300492829216]}, "mutation_prompt": null}
{"id": "e55d0525-a13f-45b2-b17a-40f7f569975d", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.dynamic_population_scaling = 0.9  # Increased dynamic scaling for exploration\n        self.population_size = int(self.budget / (7 * dim))  # Increased population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 2  # Reduced local search iterations to prioritize global search\n        self.local_search_probability = 0.5  # Added local search probability\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.dynamic_population_scaling * self.mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        adaptive_crossover_rate = self.crossover_rate * (1.0 - np.random.rand())  # Adaptive crossover rate\n        crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n    \n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.local_search_probability:  # Conditional local search\n                        improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Dynamic Differential Evolution with adaptive crossover and local search probability for accelerated convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ddc0a887-a31f-4043-af48-af544f1812ee", "metadata": {"aucs": [0.22632615881068063, 0.22620806649824254, 0.2299711867268709, 0.22490779018406803, 0.2056289400103577, 0.2082440140590901, 0.23119135795109214, 0.21206640320689552, 0.20227894613971165, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06920273910228336, 0.0681844588090127, 0.07318436271832907, 0.0725265307405325, 0.062102467616157675, 0.06068122814019283, 0.05665562450032269, 0.06940574062543348, 0.05796984700667929, 0.050987518205446225, 0.04943714417102529, 0.04473815139583426, 0.06095132388020974, 0.04750761402317816, 0.0584168563061247, 0.05491325051653362, 0.053970300085772194, 0.04169966652348811, 0.48013036084618, 0.5758250413563912, 0.579679705098571, 0.747092852751919, 0.5602371341377175, 0.650243306176054, 0.5913114174524933, 0.5683138904921403, 0.5584838928090761, 0.08372906097317556, 0.06972962600685462, 0.10975650667038372, 0.09048835504481467, 0.0759700254798632, 0.09375194432770317, 0.08121996136730392, 0.08713684503859409, 0.0943698424044096, 0.1508674026091389, 0.1594289081195318, 0.1443762887859562, 0.12949630005689594, 0.13577514418557257, 0.14292459312458627, 0.12392260002577293, 0.15530277154079197, 0.13981350755006738, 0.02555918736944207, 0.02764594865575709, 0.04760938478942067, 0.04883796551124997, 0.04277258867796552, 0.02930820402926093, 0.02453323514403205, 0.013219924813650086, 0.03855468068224088, 0.024729092818066012, 0.013427574356401406, 0.023108715872613317, 0.03099828335738619, 0.031174256032267644, 0.024596475694001696, 0.019586154410494383, 0.01686112004061091, 0.015221612006339647, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03999790904108069, 0.06628631353237158, 0.06769798371855629, 0.06449451549494856, 0.06147138720848655, 0.06055635419372174, 0.02911707579078593, 0.07641188905068097, 0.07921217573718298, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004303419775129602, 0.0027180792382196506, 0.0031172105885376444, 0.002357029655279841, 0.016266423306225963, 0.0010958015450307501, 0.006972721778327973, 0.003637484187210438, 0.025365174591294504, 0.21480801520043247, 0.2090117248780895, 0.21744254294074494, 0.20569496139445298, 0.2219948693158179, 0.21994332002604255, 0.2256352544845538, 0.22419941023666712, 0.2208818494916852, 0.046764602295961244, 0.054496654655007304, 0.06176260360088548, 0.08451684334020138, 0.05346405773101326, 0.0585064227480272, 0.054586632826866266, 0.05974006035951529, 0.05607601276793561, 0.17185892624465438, 0.15390447823951947, 0.14588119266185673, 0.14754754871649, 0.15262821328102671, 0.1295505085715195, 0.16495761152741528, 0.14632390391485983, 0.15332218604409642, 0.16981170033022497, 0.18503364195582017, 0.1739639316496443, 0.18616236854081913, 0.17855878434222672, 0.1775025142765979, 0.17580568316507617, 0.18709714913580988, 0.17601747318245398, 0.12045349178886755, 0.13551972399457224, 0.11458510884748063, 0.11787531501120863, 0.11565492363095653, 0.126472325387317, 0.1309647160728853, 0.12912877412676094, 0.11529396452200058, 0.17714769598359148, 0.15482511213015748, 0.15740534398000217, 0.18048885631447487, 0.1747726320866423, 0.17232446271888802, 0.16515038566992257, 0.1768202427002712, 0.1666345774266852, 0.15082422198675194, 0.15972953463624273, 0.12866485244277714, 0.14816036648122588, 0.15728505515927516, 0.15887520433990354, 0.1274357004901414, 0.12531511998238076, 0.1710188541949239, 0.15791901459273672, 0.16442719778093928, 0.16362290110481603, 0.1532914190235164, 0.18184525672756713, 0.15135817889915215, 0.19711782628626828, 0.17113336829481818, 0.1644025631155619, 0.16331991230729692, 0.18658290457508442, 0.22232485728360318, 0.21660020562450355, 0.1570806582907508, 0.15257810865640098, 0.17736195865511017, 0.16448511620968853, 0.15900075073557896, 0.18424307637046933, 0.18589955872335373, 0.18661249444407568, 0.1710319693237572, 0.19275953612250907, 0.17959278973521509, 0.1852672733963373, 0.18643125679720085, 0.18791749828325366, 0.06265669343959668, 0.05696028701484124, 0.06064817769846487, 0.0553770200121817, 0.06684471771730316, 0.05767544323581364, 0.05803130756841712, 0.07716788140391906, 0.058822300492829216]}, "mutation_prompt": null}
{"id": "f9ab1858-2dd4-488c-a181-d4562632d814", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.dynamic_population_scaling = 0.9  # Increased dynamic scaling for exploration\n        self.population_size = int(self.budget / (7 * dim))  # Increased population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 2  # Reduced local search iterations to prioritize global search\n        self.local_search_probability = 0.5  # Added local search probability\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.dynamic_population_scaling * self.mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        adaptive_crossover_rate = self.crossover_rate * (1.0 - np.random.rand())  # Adaptive crossover rate\n        crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n    \n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.local_search_probability:  # Conditional local search\n                        improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Dynamic Differential Evolution with adaptive crossover and local search probability for accelerated convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ddc0a887-a31f-4043-af48-af544f1812ee", "metadata": {"aucs": [0.22632615881068063, 0.22620806649824254, 0.2299711867268709, 0.22490779018406803, 0.2056289400103577, 0.2082440140590901, 0.23119135795109214, 0.21206640320689552, 0.20227894613971165, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06920273910228336, 0.0681844588090127, 0.07318436271832907, 0.0725265307405325, 0.062102467616157675, 0.06068122814019283, 0.05665562450032269, 0.06940574062543348, 0.05796984700667929, 0.050987518205446225, 0.04943714417102529, 0.04473815139583426, 0.06095132388020974, 0.04750761402317816, 0.0584168563061247, 0.05491325051653362, 0.053970300085772194, 0.04169966652348811, 0.48013036084618, 0.5758250413563912, 0.579679705098571, 0.747092852751919, 0.5602371341377175, 0.650243306176054, 0.5913114174524933, 0.5683138904921403, 0.5584838928090761, 0.08372906097317556, 0.06972962600685462, 0.10975650667038372, 0.09048835504481467, 0.0759700254798632, 0.09375194432770317, 0.08121996136730392, 0.08713684503859409, 0.0943698424044096, 0.1508674026091389, 0.1594289081195318, 0.1443762887859562, 0.12949630005689594, 0.13577514418557257, 0.14292459312458627, 0.12392260002577293, 0.15530277154079197, 0.13981350755006738, 0.02555918736944207, 0.02764594865575709, 0.04760938478942067, 0.04883796551124997, 0.04277258867796552, 0.02930820402926093, 0.02453323514403205, 0.013219924813650086, 0.03855468068224088, 0.024729092818066012, 0.013427574356401406, 0.023108715872613317, 0.03099828335738619, 0.031174256032267644, 0.024596475694001696, 0.019586154410494383, 0.01686112004061091, 0.015221612006339647, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03999790904108069, 0.06628631353237158, 0.06769798371855629, 0.06449451549494856, 0.06147138720848655, 0.06055635419372174, 0.02911707579078593, 0.07641188905068097, 0.07921217573718298, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004303419775129602, 0.0027180792382196506, 0.0031172105885376444, 0.002357029655279841, 0.016266423306225963, 0.0010958015450307501, 0.006972721778327973, 0.003637484187210438, 0.025365174591294504, 0.21480801520043247, 0.2090117248780895, 0.21744254294074494, 0.20569496139445298, 0.2219948693158179, 0.21994332002604255, 0.2256352544845538, 0.22419941023666712, 0.2208818494916852, 0.046764602295961244, 0.054496654655007304, 0.06176260360088548, 0.08451684334020138, 0.05346405773101326, 0.0585064227480272, 0.054586632826866266, 0.05974006035951529, 0.05607601276793561, 0.17185892624465438, 0.15390447823951947, 0.14588119266185673, 0.14754754871649, 0.15262821328102671, 0.1295505085715195, 0.16495761152741528, 0.14632390391485983, 0.15332218604409642, 0.16981170033022497, 0.18503364195582017, 0.1739639316496443, 0.18616236854081913, 0.17855878434222672, 0.1775025142765979, 0.17580568316507617, 0.18709714913580988, 0.17601747318245398, 0.12045349178886755, 0.13551972399457224, 0.11458510884748063, 0.11787531501120863, 0.11565492363095653, 0.126472325387317, 0.1309647160728853, 0.12912877412676094, 0.11529396452200058, 0.17714769598359148, 0.15482511213015748, 0.15740534398000217, 0.18048885631447487, 0.1747726320866423, 0.17232446271888802, 0.16515038566992257, 0.1768202427002712, 0.1666345774266852, 0.15082422198675194, 0.15972953463624273, 0.12866485244277714, 0.14816036648122588, 0.15728505515927516, 0.15887520433990354, 0.1274357004901414, 0.12531511998238076, 0.1710188541949239, 0.15791901459273672, 0.16442719778093928, 0.16362290110481603, 0.1532914190235164, 0.18184525672756713, 0.15135817889915215, 0.19711782628626828, 0.17113336829481818, 0.1644025631155619, 0.16331991230729692, 0.18658290457508442, 0.22232485728360318, 0.21660020562450355, 0.1570806582907508, 0.15257810865640098, 0.17736195865511017, 0.16448511620968853, 0.15900075073557896, 0.18424307637046933, 0.18589955872335373, 0.18661249444407568, 0.1710319693237572, 0.19275953612250907, 0.17959278973521509, 0.1852672733963373, 0.18643125679720085, 0.18791749828325366, 0.06265669343959668, 0.05696028701484124, 0.06064817769846487, 0.0553770200121817, 0.06684471771730316, 0.05767544323581364, 0.05803130756841712, 0.07716788140391906, 0.058822300492829216]}, "mutation_prompt": null}
{"id": "b05676cb-2d0b-4639-a037-55afa4dd4487", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.dynamic_population_scaling = 0.9  # Increased dynamic scaling for exploration\n        self.population_size = int(self.budget / (7 * dim))  # Increased population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 2  # Reduced local search iterations to prioritize global search\n        self.local_search_probability = 0.5  # Added local search probability\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.dynamic_population_scaling * self.mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        adaptive_crossover_rate = self.crossover_rate * (1.0 - np.random.rand())  # Adaptive crossover rate\n        crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n    \n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.local_search_probability:  # Conditional local search\n                        improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Dynamic Differential Evolution with adaptive crossover and local search probability for accelerated convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ddc0a887-a31f-4043-af48-af544f1812ee", "metadata": {"aucs": [0.22632615881068063, 0.22620806649824254, 0.2299711867268709, 0.22490779018406803, 0.2056289400103577, 0.2082440140590901, 0.23119135795109214, 0.21206640320689552, 0.20227894613971165, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06920273910228336, 0.0681844588090127, 0.07318436271832907, 0.0725265307405325, 0.062102467616157675, 0.06068122814019283, 0.05665562450032269, 0.06940574062543348, 0.05796984700667929, 0.050987518205446225, 0.04943714417102529, 0.04473815139583426, 0.06095132388020974, 0.04750761402317816, 0.0584168563061247, 0.05491325051653362, 0.053970300085772194, 0.04169966652348811, 0.48013036084618, 0.5758250413563912, 0.579679705098571, 0.747092852751919, 0.5602371341377175, 0.650243306176054, 0.5913114174524933, 0.5683138904921403, 0.5584838928090761, 0.08372906097317556, 0.06972962600685462, 0.10975650667038372, 0.09048835504481467, 0.0759700254798632, 0.09375194432770317, 0.08121996136730392, 0.08713684503859409, 0.0943698424044096, 0.1508674026091389, 0.1594289081195318, 0.1443762887859562, 0.12949630005689594, 0.13577514418557257, 0.14292459312458627, 0.12392260002577293, 0.15530277154079197, 0.13981350755006738, 0.02555918736944207, 0.02764594865575709, 0.04760938478942067, 0.04883796551124997, 0.04277258867796552, 0.02930820402926093, 0.02453323514403205, 0.013219924813650086, 0.03855468068224088, 0.024729092818066012, 0.013427574356401406, 0.023108715872613317, 0.03099828335738619, 0.031174256032267644, 0.024596475694001696, 0.019586154410494383, 0.01686112004061091, 0.015221612006339647, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03999790904108069, 0.06628631353237158, 0.06769798371855629, 0.06449451549494856, 0.06147138720848655, 0.06055635419372174, 0.02911707579078593, 0.07641188905068097, 0.07921217573718298, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004303419775129602, 0.0027180792382196506, 0.0031172105885376444, 0.002357029655279841, 0.016266423306225963, 0.0010958015450307501, 0.006972721778327973, 0.003637484187210438, 0.025365174591294504, 0.21480801520043247, 0.2090117248780895, 0.21744254294074494, 0.20569496139445298, 0.2219948693158179, 0.21994332002604255, 0.2256352544845538, 0.22419941023666712, 0.2208818494916852, 0.046764602295961244, 0.054496654655007304, 0.06176260360088548, 0.08451684334020138, 0.05346405773101326, 0.0585064227480272, 0.054586632826866266, 0.05974006035951529, 0.05607601276793561, 0.17185892624465438, 0.15390447823951947, 0.14588119266185673, 0.14754754871649, 0.15262821328102671, 0.1295505085715195, 0.16495761152741528, 0.14632390391485983, 0.15332218604409642, 0.16981170033022497, 0.18503364195582017, 0.1739639316496443, 0.18616236854081913, 0.17855878434222672, 0.1775025142765979, 0.17580568316507617, 0.18709714913580988, 0.17601747318245398, 0.12045349178886755, 0.13551972399457224, 0.11458510884748063, 0.11787531501120863, 0.11565492363095653, 0.126472325387317, 0.1309647160728853, 0.12912877412676094, 0.11529396452200058, 0.17714769598359148, 0.15482511213015748, 0.15740534398000217, 0.18048885631447487, 0.1747726320866423, 0.17232446271888802, 0.16515038566992257, 0.1768202427002712, 0.1666345774266852, 0.15082422198675194, 0.15972953463624273, 0.12866485244277714, 0.14816036648122588, 0.15728505515927516, 0.15887520433990354, 0.1274357004901414, 0.12531511998238076, 0.1710188541949239, 0.15791901459273672, 0.16442719778093928, 0.16362290110481603, 0.1532914190235164, 0.18184525672756713, 0.15135817889915215, 0.19711782628626828, 0.17113336829481818, 0.1644025631155619, 0.16331991230729692, 0.18658290457508442, 0.22232485728360318, 0.21660020562450355, 0.1570806582907508, 0.15257810865640098, 0.17736195865511017, 0.16448511620968853, 0.15900075073557896, 0.18424307637046933, 0.18589955872335373, 0.18661249444407568, 0.1710319693237572, 0.19275953612250907, 0.17959278973521509, 0.1852672733963373, 0.18643125679720085, 0.18791749828325366, 0.06265669343959668, 0.05696028701484124, 0.06064817769846487, 0.0553770200121817, 0.06684471771730316, 0.05767544323581364, 0.05803130756841712, 0.07716788140391906, 0.058822300492829216]}, "mutation_prompt": null}
{"id": "519a0b48-bb59-4962-8b48-6e1dad2c0bd1", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.8  # Adjusted crossover rate for better exploration\n        self.mutation_factor = 0.7  # Adjusted mutation factor\n        self.dynamic_population_scaling = 0.85  # Modified scaling for balanced exploration and exploitation\n        self.population_size = int(self.budget / (6 * dim))  # Slightly increased population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 3  # Increased local search iterations for further refinement\n        self.local_search_probability = 0.4  # Adjusted local search probability\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.dynamic_population_scaling * self.mutation_factor * (\n            self.population[b] - self.population[c] + np.random.uniform(-0.1, 0.1, self.dim))  # Adaptive mutation\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        adaptive_crossover_rate = self.crossover_rate * (1.0 - np.random.rand())\n        crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n    \n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            rank_probabilities = np.argsort(population_scores) / float(self.population_size)  # Rank-based selection\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[np.random.choice(self.population_size, p=rank_probabilities)]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.local_search_probability:\n                        improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Dynamic Differential Evolution with adaptive mutation and rank-based selection for improved convergence.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('probabilities do not sum to 1').", "error": "ValueError('probabilities do not sum to 1')", "parent_id": "ddc0a887-a31f-4043-af48-af544f1812ee", "metadata": {}, "mutation_prompt": null}
{"id": "fd8dafc6-79df-4325-8444-b78a51c80e2f", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.dynamic_population_scaling = 0.9  # Increased dynamic scaling for exploration\n        self.population_size = int(self.budget / (7 * dim))  # Increased population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 2  # Reduced local search iterations to prioritize global search\n        self.local_search_probability = 0.5  # Added local search probability\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.dynamic_population_scaling * self.mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        adaptive_crossover_rate = self.crossover_rate * (1.0 - np.random.rand())  # Adaptive crossover rate\n        crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n    \n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.local_search_probability:  # Conditional local search\n                        improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Dynamic Differential Evolution with adaptive crossover and local search probability for accelerated convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ddc0a887-a31f-4043-af48-af544f1812ee", "metadata": {"aucs": [0.22632615881068063, 0.22620806649824254, 0.2299711867268709, 0.22490779018406803, 0.2056289400103577, 0.2082440140590901, 0.23119135795109214, 0.21206640320689552, 0.20227894613971165, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06920273910228336, 0.0681844588090127, 0.07318436271832907, 0.0725265307405325, 0.062102467616157675, 0.06068122814019283, 0.05665562450032269, 0.06940574062543348, 0.05796984700667929, 0.050987518205446225, 0.04943714417102529, 0.04473815139583426, 0.06095132388020974, 0.04750761402317816, 0.0584168563061247, 0.05491325051653362, 0.053970300085772194, 0.04169966652348811, 0.48013036084618, 0.5758250413563912, 0.579679705098571, 0.747092852751919, 0.5602371341377175, 0.650243306176054, 0.5913114174524933, 0.5683138904921403, 0.5584838928090761, 0.08372906097317556, 0.06972962600685462, 0.10975650667038372, 0.09048835504481467, 0.0759700254798632, 0.09375194432770317, 0.08121996136730392, 0.08713684503859409, 0.0943698424044096, 0.1508674026091389, 0.1594289081195318, 0.1443762887859562, 0.12949630005689594, 0.13577514418557257, 0.14292459312458627, 0.12392260002577293, 0.15530277154079197, 0.13981350755006738, 0.02555918736944207, 0.02764594865575709, 0.04760938478942067, 0.04883796551124997, 0.04277258867796552, 0.02930820402926093, 0.02453323514403205, 0.013219924813650086, 0.03855468068224088, 0.024729092818066012, 0.013427574356401406, 0.023108715872613317, 0.03099828335738619, 0.031174256032267644, 0.024596475694001696, 0.019586154410494383, 0.01686112004061091, 0.015221612006339647, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03999790904108069, 0.06628631353237158, 0.06769798371855629, 0.06449451549494856, 0.06147138720848655, 0.06055635419372174, 0.02911707579078593, 0.07641188905068097, 0.07921217573718298, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004303419775129602, 0.0027180792382196506, 0.0031172105885376444, 0.002357029655279841, 0.016266423306225963, 0.0010958015450307501, 0.006972721778327973, 0.003637484187210438, 0.025365174591294504, 0.21480801520043247, 0.2090117248780895, 0.21744254294074494, 0.20569496139445298, 0.2219948693158179, 0.21994332002604255, 0.2256352544845538, 0.22419941023666712, 0.2208818494916852, 0.046764602295961244, 0.054496654655007304, 0.06176260360088548, 0.08451684334020138, 0.05346405773101326, 0.0585064227480272, 0.054586632826866266, 0.05974006035951529, 0.05607601276793561, 0.17185892624465438, 0.15390447823951947, 0.14588119266185673, 0.14754754871649, 0.15262821328102671, 0.1295505085715195, 0.16495761152741528, 0.14632390391485983, 0.15332218604409642, 0.16981170033022497, 0.18503364195582017, 0.1739639316496443, 0.18616236854081913, 0.17855878434222672, 0.1775025142765979, 0.17580568316507617, 0.18709714913580988, 0.17601747318245398, 0.12045349178886755, 0.13551972399457224, 0.11458510884748063, 0.11787531501120863, 0.11565492363095653, 0.126472325387317, 0.1309647160728853, 0.12912877412676094, 0.11529396452200058, 0.17714769598359148, 0.15482511213015748, 0.15740534398000217, 0.18048885631447487, 0.1747726320866423, 0.17232446271888802, 0.16515038566992257, 0.1768202427002712, 0.1666345774266852, 0.15082422198675194, 0.15972953463624273, 0.12866485244277714, 0.14816036648122588, 0.15728505515927516, 0.15887520433990354, 0.1274357004901414, 0.12531511998238076, 0.1710188541949239, 0.15791901459273672, 0.16442719778093928, 0.16362290110481603, 0.1532914190235164, 0.18184525672756713, 0.15135817889915215, 0.19711782628626828, 0.17113336829481818, 0.1644025631155619, 0.16331991230729692, 0.18658290457508442, 0.22232485728360318, 0.21660020562450355, 0.1570806582907508, 0.15257810865640098, 0.17736195865511017, 0.16448511620968853, 0.15900075073557896, 0.18424307637046933, 0.18589955872335373, 0.18661249444407568, 0.1710319693237572, 0.19275953612250907, 0.17959278973521509, 0.1852672733963373, 0.18643125679720085, 0.18791749828325366, 0.06265669343959668, 0.05696028701484124, 0.06064817769846487, 0.0553770200121817, 0.06684471771730316, 0.05767544323581364, 0.05803130756841712, 0.07716788140391906, 0.058822300492829216]}, "mutation_prompt": null}
{"id": "46f3c65e-41d7-4e82-a447-a6cc64e5addd", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.dynamic_population_scaling = 0.9  # Increased dynamic scaling for exploration\n        self.population_size = int(self.budget / (7 * dim))  # Increased population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 2  # Reduced local search iterations to prioritize global search\n        self.local_search_probability = 0.5  # Added local search probability\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.dynamic_population_scaling * self.mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        adaptive_crossover_rate = self.crossover_rate * (1.0 - np.random.rand())  # Adaptive crossover rate\n        crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n    \n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.local_search_probability:  # Conditional local search\n                        improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Dynamic Differential Evolution with adaptive crossover and local search probability for accelerated convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ddc0a887-a31f-4043-af48-af544f1812ee", "metadata": {"aucs": [0.22632615881068063, 0.22620806649824254, 0.2299711867268709, 0.22490779018406803, 0.2056289400103577, 0.2082440140590901, 0.23119135795109214, 0.21206640320689552, 0.20227894613971165, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06920273910228336, 0.0681844588090127, 0.07318436271832907, 0.0725265307405325, 0.062102467616157675, 0.06068122814019283, 0.05665562450032269, 0.06940574062543348, 0.05796984700667929, 0.050987518205446225, 0.04943714417102529, 0.04473815139583426, 0.06095132388020974, 0.04750761402317816, 0.0584168563061247, 0.05491325051653362, 0.053970300085772194, 0.04169966652348811, 0.48013036084618, 0.5758250413563912, 0.579679705098571, 0.747092852751919, 0.5602371341377175, 0.650243306176054, 0.5913114174524933, 0.5683138904921403, 0.5584838928090761, 0.08372906097317556, 0.06972962600685462, 0.10975650667038372, 0.09048835504481467, 0.0759700254798632, 0.09375194432770317, 0.08121996136730392, 0.08713684503859409, 0.0943698424044096, 0.1508674026091389, 0.1594289081195318, 0.1443762887859562, 0.12949630005689594, 0.13577514418557257, 0.14292459312458627, 0.12392260002577293, 0.15530277154079197, 0.13981350755006738, 0.02555918736944207, 0.02764594865575709, 0.04760938478942067, 0.04883796551124997, 0.04277258867796552, 0.02930820402926093, 0.02453323514403205, 0.013219924813650086, 0.03855468068224088, 0.024729092818066012, 0.013427574356401406, 0.023108715872613317, 0.03099828335738619, 0.031174256032267644, 0.024596475694001696, 0.019586154410494383, 0.01686112004061091, 0.015221612006339647, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03999790904108069, 0.06628631353237158, 0.06769798371855629, 0.06449451549494856, 0.06147138720848655, 0.06055635419372174, 0.02911707579078593, 0.07641188905068097, 0.07921217573718298, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004303419775129602, 0.0027180792382196506, 0.0031172105885376444, 0.002357029655279841, 0.016266423306225963, 0.0010958015450307501, 0.006972721778327973, 0.003637484187210438, 0.025365174591294504, 0.21480801520043247, 0.2090117248780895, 0.21744254294074494, 0.20569496139445298, 0.2219948693158179, 0.21994332002604255, 0.2256352544845538, 0.22419941023666712, 0.2208818494916852, 0.046764602295961244, 0.054496654655007304, 0.06176260360088548, 0.08451684334020138, 0.05346405773101326, 0.0585064227480272, 0.054586632826866266, 0.05974006035951529, 0.05607601276793561, 0.17185892624465438, 0.15390447823951947, 0.14588119266185673, 0.14754754871649, 0.15262821328102671, 0.1295505085715195, 0.16495761152741528, 0.14632390391485983, 0.15332218604409642, 0.16981170033022497, 0.18503364195582017, 0.1739639316496443, 0.18616236854081913, 0.17855878434222672, 0.1775025142765979, 0.17580568316507617, 0.18709714913580988, 0.17601747318245398, 0.12045349178886755, 0.13551972399457224, 0.11458510884748063, 0.11787531501120863, 0.11565492363095653, 0.126472325387317, 0.1309647160728853, 0.12912877412676094, 0.11529396452200058, 0.17714769598359148, 0.15482511213015748, 0.15740534398000217, 0.18048885631447487, 0.1747726320866423, 0.17232446271888802, 0.16515038566992257, 0.1768202427002712, 0.1666345774266852, 0.15082422198675194, 0.15972953463624273, 0.12866485244277714, 0.14816036648122588, 0.15728505515927516, 0.15887520433990354, 0.1274357004901414, 0.12531511998238076, 0.1710188541949239, 0.15791901459273672, 0.16442719778093928, 0.16362290110481603, 0.1532914190235164, 0.18184525672756713, 0.15135817889915215, 0.19711782628626828, 0.17113336829481818, 0.1644025631155619, 0.16331991230729692, 0.18658290457508442, 0.22232485728360318, 0.21660020562450355, 0.1570806582907508, 0.15257810865640098, 0.17736195865511017, 0.16448511620968853, 0.15900075073557896, 0.18424307637046933, 0.18589955872335373, 0.18661249444407568, 0.1710319693237572, 0.19275953612250907, 0.17959278973521509, 0.1852672733963373, 0.18643125679720085, 0.18791749828325366, 0.06265669343959668, 0.05696028701484124, 0.06064817769846487, 0.0553770200121817, 0.06684471771730316, 0.05767544323581364, 0.05803130756841712, 0.07716788140391906, 0.058822300492829216]}, "mutation_prompt": null}
{"id": "0f70ac0e-2d95-4533-94b4-4a92a69e3c09", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())  # Dynamic scaling for exploration and exploitation\n        self.population_size = int(self.budget / (6 * dim))  # Adjusted population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 3  # Increased local search iterations slightly\n        self.local_search_probability = 0.4  # Tweaked local search probability\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive mutation factor\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.local_search_probability:\n                        improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Dynamic Differential Evolution with Adaptive Mutation and Dynamic Scaling for Improved Convergence.", "configspace": "", "generation": 30, "fitness": 0.12278128340829525, "feedback": "The algorithm EnhancedDynamicDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.10.", "error": "", "parent_id": "ddc0a887-a31f-4043-af48-af544f1812ee", "metadata": {"aucs": [0.2309536128275821, 0.24140130041478225, 0.2551519925560234, 0.21692049877970365, 0.2365852378257277, 0.22072483679405674, 0.23163296595823746, 0.24818537155725384, 0.251514436395746, 0.0025318447600646277, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00014623977548910982, 0.0036062311293150184, 9.999999999998899e-05, 0.0013050311309606988, 9.999999999998899e-05, 0.06157117344709373, 0.061793459413875595, 0.06977999092553566, 0.07437661023839537, 0.06967406530150622, 0.0667395840139614, 0.06497095740251513, 0.061383469585015504, 0.06657997846270647, 0.05401386999124058, 0.053561416888603164, 0.04914281040151236, 0.048739645389581754, 0.05542028840159474, 0.0494448463775341, 0.056864396680539, 0.04899963504073368, 0.06098512097843467, 0.2887288389921647, 0.5159139953503428, 0.714147617104039, 0.5659460863367669, 0.32425029848465803, 0.3462443179115353, 0.400901506547625, 0.503052231355583, 0.33123211639264427, 0.08100634417503028, 0.09994826747292496, 0.07966676256776484, 0.09092631699651044, 0.09786048394280367, 0.08133202988047528, 0.10688171487141429, 0.12218133046958501, 0.08559903491634724, 0.15081670482955178, 0.169328153967913, 0.1534756606452109, 0.17585618130970582, 0.17207674407305262, 0.1505652432187209, 0.15765901900209434, 0.17489712670047664, 0.17290454360367025, 0.0285178102925423, 0.0460916226003123, 0.058770513738986896, 0.03728673973245766, 0.03956084969422913, 0.07175500359626563, 0.043118904177786854, 0.050111447290622, 0.031202302876102705, 0.03525278882796279, 0.058348053874654804, 0.03712753177729211, 0.05069262776034589, 0.0350749202006122, 0.04939903994337835, 0.033188640063688934, 0.039771157378691746, 0.04952452893927928, 9.999999999998899e-05, 9.999999999998899e-05, 0.005064193065404066, 9.999999999998899e-05, 9.999999999998899e-05, 0.00723431562553889, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09578466057659929, 0.09389215683010366, 0.09072591849986278, 0.09107725510005804, 0.09213147967140922, 0.06676900637518723, 0.09108547454809557, 0.11200502552218572, 0.0770775826087986, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016279986601719476, 0.013111746633201804, 0.015003522050638263, 0.014842301196113517, 0.021151511827529834, 0.013710102701378846, 0.014553996549061088, 0.013072740903712687, 0.026749187041233524, 0.22684754440578425, 0.24884916423598602, 0.23661921528808028, 0.2379270999971126, 0.24523966968441058, 0.2386217411684317, 0.22472072853125846, 0.2393052788286265, 0.22962695358601626, 0.05860071131391764, 0.06477729572536883, 0.062113149314511396, 0.05926733179223842, 0.06301105127876638, 0.06863040688550792, 0.07323121185161419, 0.07136666870946706, 0.06365016637221488, 0.16498654882463548, 0.11804347124549497, 0.16017384118495415, 0.15250793313857391, 0.1757237301179152, 0.13055010407175127, 0.13310763830725592, 0.13691134644300507, 0.14027376762499588, 0.18791647952246338, 0.19783310651764674, 0.19338429357547327, 0.17746765276632614, 0.1921417117352986, 0.18819197059132464, 0.1804893769278071, 0.18304382016018939, 0.18478486861579524, 0.1361435346116734, 0.14004499576586182, 0.13605150172791014, 0.12446924420814265, 0.1383811695464927, 0.12840969110461464, 0.13598476078556065, 0.13331210265074422, 0.12918733711687547, 0.1687051145230638, 0.18002370677189805, 0.16627613249363915, 0.17134968588342891, 0.17179531861919206, 0.1809786546664094, 0.18048903644267267, 0.16436100279374133, 0.19327006760624976, 0.15519185352224119, 0.15731474834174608, 0.1505616314174898, 0.1599380851043063, 0.1707517430808393, 0.15297353232999633, 0.15737525763253757, 0.16522050172616132, 0.15629573460429058, 0.15303321829598138, 0.20476823584647053, 0.1657909894261751, 0.14642857756131888, 0.18410201019149186, 0.1440876630332676, 0.20708969023666002, 0.16465451423372923, 0.13612482475776, 0.17731748479632192, 0.20796787277928108, 0.18371573069116198, 0.18195147745053375, 0.1505014169680966, 0.1516068170102315, 0.16386940011920992, 0.17317610513207327, 0.18298963499826437, 0.1868826218472417, 0.18786759010576526, 0.18105410649624942, 0.17963656736599587, 0.19111923851738855, 0.19324645848988042, 0.16722012691085442, 0.18488696101780988, 0.2018175623744456, 0.06277029590944805, 0.06842988300643227, 0.05811355271876695, 0.05859530831979631, 0.05978716167289766, 0.06043190466555659, 0.06328891721987895, 0.0644391684588943, 0.06088469549146669]}, "mutation_prompt": null}
{"id": "213cb932-885f-4fcf-aa90-1e054b04dad3", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())  # Dynamic scaling for exploration and exploitation\n        self.population_size = int(self.budget / (6 * dim))  # Adjusted population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 3  # Increased local search iterations slightly\n        self.local_search_probability = 0.4  # Tweaked local search probability\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive mutation factor\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.local_search_probability:\n                        improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Dynamic Differential Evolution with Adaptive Mutation and Dynamic Scaling for Improved Convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0f70ac0e-2d95-4533-94b4-4a92a69e3c09", "metadata": {"aucs": [0.2309536128275821, 0.24140130041478225, 0.2551519925560234, 0.21692049877970365, 0.2365852378257277, 0.22072483679405674, 0.23163296595823746, 0.24818537155725384, 0.251514436395746, 0.0025318447600646277, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00014623977548910982, 0.0036062311293150184, 9.999999999998899e-05, 0.0013050311309606988, 9.999999999998899e-05, 0.06157117344709373, 0.061793459413875595, 0.06977999092553566, 0.07437661023839537, 0.06967406530150622, 0.0667395840139614, 0.06497095740251513, 0.061383469585015504, 0.06657997846270647, 0.05401386999124058, 0.053561416888603164, 0.04914281040151236, 0.048739645389581754, 0.05542028840159474, 0.0494448463775341, 0.056864396680539, 0.04899963504073368, 0.06098512097843467, 0.2887288389921647, 0.5159139953503428, 0.714147617104039, 0.5659460863367669, 0.32425029848465803, 0.3462443179115353, 0.400901506547625, 0.503052231355583, 0.33123211639264427, 0.08100634417503028, 0.09994826747292496, 0.07966676256776484, 0.09092631699651044, 0.09786048394280367, 0.08133202988047528, 0.10688171487141429, 0.12218133046958501, 0.08559903491634724, 0.15081670482955178, 0.169328153967913, 0.1534756606452109, 0.17585618130970582, 0.17207674407305262, 0.1505652432187209, 0.15765901900209434, 0.17489712670047664, 0.17290454360367025, 0.0285178102925423, 0.0460916226003123, 0.058770513738986896, 0.03728673973245766, 0.03956084969422913, 0.07175500359626563, 0.043118904177786854, 0.050111447290622, 0.031202302876102705, 0.03525278882796279, 0.058348053874654804, 0.03712753177729211, 0.05069262776034589, 0.0350749202006122, 0.04939903994337835, 0.033188640063688934, 0.039771157378691746, 0.04952452893927928, 9.999999999998899e-05, 9.999999999998899e-05, 0.005064193065404066, 9.999999999998899e-05, 9.999999999998899e-05, 0.00723431562553889, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09578466057659929, 0.09389215683010366, 0.09072591849986278, 0.09107725510005804, 0.09213147967140922, 0.06676900637518723, 0.09108547454809557, 0.11200502552218572, 0.0770775826087986, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016279986601719476, 0.013111746633201804, 0.015003522050638263, 0.014842301196113517, 0.021151511827529834, 0.013710102701378846, 0.014553996549061088, 0.013072740903712687, 0.026749187041233524, 0.22684754440578425, 0.24884916423598602, 0.23661921528808028, 0.2379270999971126, 0.24523966968441058, 0.2386217411684317, 0.22472072853125846, 0.2393052788286265, 0.22962695358601626, 0.05860071131391764, 0.06477729572536883, 0.062113149314511396, 0.05926733179223842, 0.06301105127876638, 0.06863040688550792, 0.07323121185161419, 0.07136666870946706, 0.06365016637221488, 0.16498654882463548, 0.11804347124549497, 0.16017384118495415, 0.15250793313857391, 0.1757237301179152, 0.13055010407175127, 0.13310763830725592, 0.13691134644300507, 0.14027376762499588, 0.18791647952246338, 0.19783310651764674, 0.19338429357547327, 0.17746765276632614, 0.1921417117352986, 0.18819197059132464, 0.1804893769278071, 0.18304382016018939, 0.18478486861579524, 0.1361435346116734, 0.14004499576586182, 0.13605150172791014, 0.12446924420814265, 0.1383811695464927, 0.12840969110461464, 0.13598476078556065, 0.13331210265074422, 0.12918733711687547, 0.1687051145230638, 0.18002370677189805, 0.16627613249363915, 0.17134968588342891, 0.17179531861919206, 0.1809786546664094, 0.18048903644267267, 0.16436100279374133, 0.19327006760624976, 0.15519185352224119, 0.15731474834174608, 0.1505616314174898, 0.1599380851043063, 0.1707517430808393, 0.15297353232999633, 0.15737525763253757, 0.16522050172616132, 0.15629573460429058, 0.15303321829598138, 0.20476823584647053, 0.1657909894261751, 0.14642857756131888, 0.18410201019149186, 0.1440876630332676, 0.20708969023666002, 0.16465451423372923, 0.13612482475776, 0.17731748479632192, 0.20796787277928108, 0.18371573069116198, 0.18195147745053375, 0.1505014169680966, 0.1516068170102315, 0.16386940011920992, 0.17317610513207327, 0.18298963499826437, 0.1868826218472417, 0.18786759010576526, 0.18105410649624942, 0.17963656736599587, 0.19111923851738855, 0.19324645848988042, 0.16722012691085442, 0.18488696101780988, 0.2018175623744456, 0.06277029590944805, 0.06842988300643227, 0.05811355271876695, 0.05859530831979631, 0.05978716167289766, 0.06043190466555659, 0.06328891721987895, 0.0644391684588943, 0.06088469549146669]}, "mutation_prompt": null}
{"id": "34fe812f-39ab-4403-993b-466f99851302", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())  # Dynamic scaling for exploration and exploitation\n        self.population_size = int(self.budget / (6 * dim))  # Adjusted population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 3  # Increased local search iterations slightly\n        self.local_search_probability = 0.4  # Tweaked local search probability\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive mutation factor\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.local_search_probability:\n                        improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Dynamic Differential Evolution with Adaptive Mutation and Dynamic Scaling for Improved Convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0f70ac0e-2d95-4533-94b4-4a92a69e3c09", "metadata": {"aucs": [0.2309536128275821, 0.24140130041478225, 0.2551519925560234, 0.21692049877970365, 0.2365852378257277, 0.22072483679405674, 0.23163296595823746, 0.24818537155725384, 0.251514436395746, 0.0025318447600646277, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00014623977548910982, 0.0036062311293150184, 9.999999999998899e-05, 0.0013050311309606988, 9.999999999998899e-05, 0.06157117344709373, 0.061793459413875595, 0.06977999092553566, 0.07437661023839537, 0.06967406530150622, 0.0667395840139614, 0.06497095740251513, 0.061383469585015504, 0.06657997846270647, 0.05401386999124058, 0.053561416888603164, 0.04914281040151236, 0.048739645389581754, 0.05542028840159474, 0.0494448463775341, 0.056864396680539, 0.04899963504073368, 0.06098512097843467, 0.2887288389921647, 0.5159139953503428, 0.714147617104039, 0.5659460863367669, 0.32425029848465803, 0.3462443179115353, 0.400901506547625, 0.503052231355583, 0.33123211639264427, 0.08100634417503028, 0.09994826747292496, 0.07966676256776484, 0.09092631699651044, 0.09786048394280367, 0.08133202988047528, 0.10688171487141429, 0.12218133046958501, 0.08559903491634724, 0.15081670482955178, 0.169328153967913, 0.1534756606452109, 0.17585618130970582, 0.17207674407305262, 0.1505652432187209, 0.15765901900209434, 0.17489712670047664, 0.17290454360367025, 0.0285178102925423, 0.0460916226003123, 0.058770513738986896, 0.03728673973245766, 0.03956084969422913, 0.07175500359626563, 0.043118904177786854, 0.050111447290622, 0.031202302876102705, 0.03525278882796279, 0.058348053874654804, 0.03712753177729211, 0.05069262776034589, 0.0350749202006122, 0.04939903994337835, 0.033188640063688934, 0.039771157378691746, 0.04952452893927928, 9.999999999998899e-05, 9.999999999998899e-05, 0.005064193065404066, 9.999999999998899e-05, 9.999999999998899e-05, 0.00723431562553889, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09578466057659929, 0.09389215683010366, 0.09072591849986278, 0.09107725510005804, 0.09213147967140922, 0.06676900637518723, 0.09108547454809557, 0.11200502552218572, 0.0770775826087986, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016279986601719476, 0.013111746633201804, 0.015003522050638263, 0.014842301196113517, 0.021151511827529834, 0.013710102701378846, 0.014553996549061088, 0.013072740903712687, 0.026749187041233524, 0.22684754440578425, 0.24884916423598602, 0.23661921528808028, 0.2379270999971126, 0.24523966968441058, 0.2386217411684317, 0.22472072853125846, 0.2393052788286265, 0.22962695358601626, 0.05860071131391764, 0.06477729572536883, 0.062113149314511396, 0.05926733179223842, 0.06301105127876638, 0.06863040688550792, 0.07323121185161419, 0.07136666870946706, 0.06365016637221488, 0.16498654882463548, 0.11804347124549497, 0.16017384118495415, 0.15250793313857391, 0.1757237301179152, 0.13055010407175127, 0.13310763830725592, 0.13691134644300507, 0.14027376762499588, 0.18791647952246338, 0.19783310651764674, 0.19338429357547327, 0.17746765276632614, 0.1921417117352986, 0.18819197059132464, 0.1804893769278071, 0.18304382016018939, 0.18478486861579524, 0.1361435346116734, 0.14004499576586182, 0.13605150172791014, 0.12446924420814265, 0.1383811695464927, 0.12840969110461464, 0.13598476078556065, 0.13331210265074422, 0.12918733711687547, 0.1687051145230638, 0.18002370677189805, 0.16627613249363915, 0.17134968588342891, 0.17179531861919206, 0.1809786546664094, 0.18048903644267267, 0.16436100279374133, 0.19327006760624976, 0.15519185352224119, 0.15731474834174608, 0.1505616314174898, 0.1599380851043063, 0.1707517430808393, 0.15297353232999633, 0.15737525763253757, 0.16522050172616132, 0.15629573460429058, 0.15303321829598138, 0.20476823584647053, 0.1657909894261751, 0.14642857756131888, 0.18410201019149186, 0.1440876630332676, 0.20708969023666002, 0.16465451423372923, 0.13612482475776, 0.17731748479632192, 0.20796787277928108, 0.18371573069116198, 0.18195147745053375, 0.1505014169680966, 0.1516068170102315, 0.16386940011920992, 0.17317610513207327, 0.18298963499826437, 0.1868826218472417, 0.18786759010576526, 0.18105410649624942, 0.17963656736599587, 0.19111923851738855, 0.19324645848988042, 0.16722012691085442, 0.18488696101780988, 0.2018175623744456, 0.06277029590944805, 0.06842988300643227, 0.05811355271876695, 0.05859530831979631, 0.05978716167289766, 0.06043190466555659, 0.06328891721987895, 0.0644391684588943, 0.06088469549146669]}, "mutation_prompt": null}
{"id": "d7cd03d2-c71a-4733-8f7e-fe6a2d55eba1", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())  # Dynamic scaling for exploration and exploitation\n        self.population_size = int(self.budget / (6 * dim))  # Adjusted population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 3  # Increased local search iterations slightly\n        self.local_search_probability = 0.4  # Tweaked local search probability\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive mutation factor\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.local_search_probability:\n                        improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Dynamic Differential Evolution with Adaptive Mutation and Dynamic Scaling for Improved Convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0f70ac0e-2d95-4533-94b4-4a92a69e3c09", "metadata": {"aucs": [0.2309536128275821, 0.24140130041478225, 0.2551519925560234, 0.21692049877970365, 0.2365852378257277, 0.22072483679405674, 0.23163296595823746, 0.24818537155725384, 0.251514436395746, 0.0025318447600646277, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00014623977548910982, 0.0036062311293150184, 9.999999999998899e-05, 0.0013050311309606988, 9.999999999998899e-05, 0.06157117344709373, 0.061793459413875595, 0.06977999092553566, 0.07437661023839537, 0.06967406530150622, 0.0667395840139614, 0.06497095740251513, 0.061383469585015504, 0.06657997846270647, 0.05401386999124058, 0.053561416888603164, 0.04914281040151236, 0.048739645389581754, 0.05542028840159474, 0.0494448463775341, 0.056864396680539, 0.04899963504073368, 0.06098512097843467, 0.2887288389921647, 0.5159139953503428, 0.714147617104039, 0.5659460863367669, 0.32425029848465803, 0.3462443179115353, 0.400901506547625, 0.503052231355583, 0.33123211639264427, 0.08100634417503028, 0.09994826747292496, 0.07966676256776484, 0.09092631699651044, 0.09786048394280367, 0.08133202988047528, 0.10688171487141429, 0.12218133046958501, 0.08559903491634724, 0.15081670482955178, 0.169328153967913, 0.1534756606452109, 0.17585618130970582, 0.17207674407305262, 0.1505652432187209, 0.15765901900209434, 0.17489712670047664, 0.17290454360367025, 0.0285178102925423, 0.0460916226003123, 0.058770513738986896, 0.03728673973245766, 0.03956084969422913, 0.07175500359626563, 0.043118904177786854, 0.050111447290622, 0.031202302876102705, 0.03525278882796279, 0.058348053874654804, 0.03712753177729211, 0.05069262776034589, 0.0350749202006122, 0.04939903994337835, 0.033188640063688934, 0.039771157378691746, 0.04952452893927928, 9.999999999998899e-05, 9.999999999998899e-05, 0.005064193065404066, 9.999999999998899e-05, 9.999999999998899e-05, 0.00723431562553889, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09578466057659929, 0.09389215683010366, 0.09072591849986278, 0.09107725510005804, 0.09213147967140922, 0.06676900637518723, 0.09108547454809557, 0.11200502552218572, 0.0770775826087986, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016279986601719476, 0.013111746633201804, 0.015003522050638263, 0.014842301196113517, 0.021151511827529834, 0.013710102701378846, 0.014553996549061088, 0.013072740903712687, 0.026749187041233524, 0.22684754440578425, 0.24884916423598602, 0.23661921528808028, 0.2379270999971126, 0.24523966968441058, 0.2386217411684317, 0.22472072853125846, 0.2393052788286265, 0.22962695358601626, 0.05860071131391764, 0.06477729572536883, 0.062113149314511396, 0.05926733179223842, 0.06301105127876638, 0.06863040688550792, 0.07323121185161419, 0.07136666870946706, 0.06365016637221488, 0.16498654882463548, 0.11804347124549497, 0.16017384118495415, 0.15250793313857391, 0.1757237301179152, 0.13055010407175127, 0.13310763830725592, 0.13691134644300507, 0.14027376762499588, 0.18791647952246338, 0.19783310651764674, 0.19338429357547327, 0.17746765276632614, 0.1921417117352986, 0.18819197059132464, 0.1804893769278071, 0.18304382016018939, 0.18478486861579524, 0.1361435346116734, 0.14004499576586182, 0.13605150172791014, 0.12446924420814265, 0.1383811695464927, 0.12840969110461464, 0.13598476078556065, 0.13331210265074422, 0.12918733711687547, 0.1687051145230638, 0.18002370677189805, 0.16627613249363915, 0.17134968588342891, 0.17179531861919206, 0.1809786546664094, 0.18048903644267267, 0.16436100279374133, 0.19327006760624976, 0.15519185352224119, 0.15731474834174608, 0.1505616314174898, 0.1599380851043063, 0.1707517430808393, 0.15297353232999633, 0.15737525763253757, 0.16522050172616132, 0.15629573460429058, 0.15303321829598138, 0.20476823584647053, 0.1657909894261751, 0.14642857756131888, 0.18410201019149186, 0.1440876630332676, 0.20708969023666002, 0.16465451423372923, 0.13612482475776, 0.17731748479632192, 0.20796787277928108, 0.18371573069116198, 0.18195147745053375, 0.1505014169680966, 0.1516068170102315, 0.16386940011920992, 0.17317610513207327, 0.18298963499826437, 0.1868826218472417, 0.18786759010576526, 0.18105410649624942, 0.17963656736599587, 0.19111923851738855, 0.19324645848988042, 0.16722012691085442, 0.18488696101780988, 0.2018175623744456, 0.06277029590944805, 0.06842988300643227, 0.05811355271876695, 0.05859530831979631, 0.05978716167289766, 0.06043190466555659, 0.06328891721987895, 0.0644391684588943, 0.06088469549146669]}, "mutation_prompt": null}
{"id": "3aa485d4-c429-4dc9-b3ec-e3f3b5356794", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())  # Dynamic scaling for exploration and exploitation\n        self.population_size = int(self.budget / (6 * dim))  # Adjusted population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 3  # Increased local search iterations slightly\n        self.local_search_probability = 0.4  # Tweaked local search probability\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive mutation factor\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.local_search_probability:\n                        improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Dynamic Differential Evolution with Adaptive Mutation and Dynamic Scaling for Improved Convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0f70ac0e-2d95-4533-94b4-4a92a69e3c09", "metadata": {"aucs": [0.2309536128275821, 0.24140130041478225, 0.2551519925560234, 0.21692049877970365, 0.2365852378257277, 0.22072483679405674, 0.23163296595823746, 0.24818537155725384, 0.251514436395746, 0.0025318447600646277, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00014623977548910982, 0.0036062311293150184, 9.999999999998899e-05, 0.0013050311309606988, 9.999999999998899e-05, 0.06157117344709373, 0.061793459413875595, 0.06977999092553566, 0.07437661023839537, 0.06967406530150622, 0.0667395840139614, 0.06497095740251513, 0.061383469585015504, 0.06657997846270647, 0.05401386999124058, 0.053561416888603164, 0.04914281040151236, 0.048739645389581754, 0.05542028840159474, 0.0494448463775341, 0.056864396680539, 0.04899963504073368, 0.06098512097843467, 0.2887288389921647, 0.5159139953503428, 0.714147617104039, 0.5659460863367669, 0.32425029848465803, 0.3462443179115353, 0.400901506547625, 0.503052231355583, 0.33123211639264427, 0.08100634417503028, 0.09994826747292496, 0.07966676256776484, 0.09092631699651044, 0.09786048394280367, 0.08133202988047528, 0.10688171487141429, 0.12218133046958501, 0.08559903491634724, 0.15081670482955178, 0.169328153967913, 0.1534756606452109, 0.17585618130970582, 0.17207674407305262, 0.1505652432187209, 0.15765901900209434, 0.17489712670047664, 0.17290454360367025, 0.0285178102925423, 0.0460916226003123, 0.058770513738986896, 0.03728673973245766, 0.03956084969422913, 0.07175500359626563, 0.043118904177786854, 0.050111447290622, 0.031202302876102705, 0.03525278882796279, 0.058348053874654804, 0.03712753177729211, 0.05069262776034589, 0.0350749202006122, 0.04939903994337835, 0.033188640063688934, 0.039771157378691746, 0.04952452893927928, 9.999999999998899e-05, 9.999999999998899e-05, 0.005064193065404066, 9.999999999998899e-05, 9.999999999998899e-05, 0.00723431562553889, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09578466057659929, 0.09389215683010366, 0.09072591849986278, 0.09107725510005804, 0.09213147967140922, 0.06676900637518723, 0.09108547454809557, 0.11200502552218572, 0.0770775826087986, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016279986601719476, 0.013111746633201804, 0.015003522050638263, 0.014842301196113517, 0.021151511827529834, 0.013710102701378846, 0.014553996549061088, 0.013072740903712687, 0.026749187041233524, 0.22684754440578425, 0.24884916423598602, 0.23661921528808028, 0.2379270999971126, 0.24523966968441058, 0.2386217411684317, 0.22472072853125846, 0.2393052788286265, 0.22962695358601626, 0.05860071131391764, 0.06477729572536883, 0.062113149314511396, 0.05926733179223842, 0.06301105127876638, 0.06863040688550792, 0.07323121185161419, 0.07136666870946706, 0.06365016637221488, 0.16498654882463548, 0.11804347124549497, 0.16017384118495415, 0.15250793313857391, 0.1757237301179152, 0.13055010407175127, 0.13310763830725592, 0.13691134644300507, 0.14027376762499588, 0.18791647952246338, 0.19783310651764674, 0.19338429357547327, 0.17746765276632614, 0.1921417117352986, 0.18819197059132464, 0.1804893769278071, 0.18304382016018939, 0.18478486861579524, 0.1361435346116734, 0.14004499576586182, 0.13605150172791014, 0.12446924420814265, 0.1383811695464927, 0.12840969110461464, 0.13598476078556065, 0.13331210265074422, 0.12918733711687547, 0.1687051145230638, 0.18002370677189805, 0.16627613249363915, 0.17134968588342891, 0.17179531861919206, 0.1809786546664094, 0.18048903644267267, 0.16436100279374133, 0.19327006760624976, 0.15519185352224119, 0.15731474834174608, 0.1505616314174898, 0.1599380851043063, 0.1707517430808393, 0.15297353232999633, 0.15737525763253757, 0.16522050172616132, 0.15629573460429058, 0.15303321829598138, 0.20476823584647053, 0.1657909894261751, 0.14642857756131888, 0.18410201019149186, 0.1440876630332676, 0.20708969023666002, 0.16465451423372923, 0.13612482475776, 0.17731748479632192, 0.20796787277928108, 0.18371573069116198, 0.18195147745053375, 0.1505014169680966, 0.1516068170102315, 0.16386940011920992, 0.17317610513207327, 0.18298963499826437, 0.1868826218472417, 0.18786759010576526, 0.18105410649624942, 0.17963656736599587, 0.19111923851738855, 0.19324645848988042, 0.16722012691085442, 0.18488696101780988, 0.2018175623744456, 0.06277029590944805, 0.06842988300643227, 0.05811355271876695, 0.05859530831979631, 0.05978716167289766, 0.06043190466555659, 0.06328891721987895, 0.0644391684588943, 0.06088469549146669]}, "mutation_prompt": null}
{"id": "0c4e47cc-ec08-40a7-9756-1486df0be819", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.85  # Slightly reduced crossover rate\n        self.mutation_factor = 0.9  # Increased mutation factor for stronger exploration\n        self.population_scaling = 0.4 + (0.4 * np.random.rand())  # Wider range for dynamic scaling\n        self.population_size = int(self.budget / (7 * dim))  # Adjusted population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.greedy_step_probability = 0.3  # Added greedy step probability\n        self.max_local_search_iterations = 4  # Further increased local search iterations\n        self.local_search_probability = 0.5  # Increased local search probability\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.15, 0.15))  # More adaptive mutation\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _greedy_step(self, func, current_solution, current_score):\n        step_size = 0.1\n        greedy_solution = current_solution + step_size * np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        greedy_solution = np.clip(greedy_solution, self.lower_bound, self.upper_bound)\n        greedy_score = func(greedy_solution)\n        return (greedy_solution, greedy_score) if greedy_score < current_score else (current_solution, current_score)\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.local_search_probability:\n                        improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n                if np.random.rand() < self.greedy_step_probability:\n                    greedy_solution, greedy_score = self._greedy_step(func, self.population[i], population_scores[i])\n                    if greedy_score < population_scores[i]:\n                        self.population[i] = greedy_solution\n                        population_scores[i] = greedy_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Stochastic Greedy Step for Improved Convergence.", "configspace": "", "generation": 35, "fitness": 0.12038001013824219, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.10.", "error": "", "parent_id": "0f70ac0e-2d95-4533-94b4-4a92a69e3c09", "metadata": {"aucs": [0.222119157498346, 0.21712049717105752, 0.2749364844482244, 0.21851241456670356, 0.22247830307460004, 0.2134723909919103, 0.2053291527105927, 0.20886397649357047, 0.22668709612440885, 0.0013483951953007223, 0.00021882652515703427, 0.0009041434708262353, 9.999999999998899e-05, 0.0012950616686084881, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011788260177941767, 0.06639964903568962, 0.06092541820835262, 0.06549873687753738, 0.06951062243425332, 0.06919431051664837, 0.07149894967164927, 0.05513275396547557, 0.06735316224196208, 0.062211587374354727, 0.04861657361724503, 0.05161068600327512, 0.05244000229972556, 0.05137728499419736, 0.05153486951047559, 0.06727463033905712, 0.048238774344123714, 0.061652241142057806, 0.05559905740068172, 0.5297741189349486, 0.390286322936918, 0.4877171081607464, 0.48284849149397646, 0.5443195282874191, 0.29309679573971703, 0.49130193570585756, 0.24494764775188427, 0.2458706520121826, 0.06691458797033667, 0.11155877654511037, 0.08223613466568935, 0.07128192881912088, 0.07976413668023086, 0.07925583627880495, 0.11754292423582824, 0.13568592743815044, 0.08227801242612676, 0.16596992823596812, 0.16427555148873108, 0.1514756621160075, 0.1680285852895893, 0.1628168235733114, 0.15671402157731285, 0.14567865291082305, 0.1806844126000784, 0.152963256712061, 0.023391082566922128, 0.053128429643423125, 0.042986132691132495, 0.014725010452796061, 0.024686627173067577, 0.04363050625869802, 0.03084606534851919, 0.03790431430644381, 0.05144051831225971, 0.05022422472251453, 0.0813324808255449, 0.04934599432842557, 0.0520715096430906, 0.04563836488901907, 0.046567527194736114, 0.025449220324955113, 0.028530575644374, 0.05935172269565869, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06171588175406684, 0.06774549761028525, 0.10116901290684344, 0.06880285161181432, 0.05959370845208234, 0.05451763604882509, 0.05290789484999692, 0.062327288246312285, 0.07533849263501002, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.014799679150884315, 0.012280655755068759, 0.01799343141664833, 0.009800285772328388, 0.020771492571902472, 0.015819022923787673, 0.02246804783508416, 0.020611119714369464, 0.013837182008924143, 0.2371846193894247, 0.2217341841074969, 0.22753780104354915, 0.21337727864511047, 0.21948654834058, 0.22100727673884912, 0.23868846607819794, 0.23963549588939548, 0.22522745569043368, 0.06168383043366488, 0.05805002093192557, 0.05736381142216773, 0.05681932007180934, 0.06424343219512918, 0.07364733807390655, 0.06736842819929567, 0.0692582029437574, 0.06753540046846651, 0.1428746725836212, 0.14476458170633855, 0.15315420372488775, 0.1415100375915772, 0.1466619965590653, 0.1478467006620191, 0.1462272600116976, 0.15021007681320275, 0.13517484702074267, 0.18432820396755767, 0.17734853444769794, 0.20017785780406216, 0.17811718434434876, 0.18281557889059663, 0.19841705456168524, 0.1853172726772987, 0.19488597522565798, 0.20153271027845254, 0.1344776949008487, 0.14144166301035643, 0.12369752646144139, 0.1261336507853109, 0.12934428137798182, 0.12554716398413435, 0.15133447154908786, 0.12866966598907748, 0.1349711879669112, 0.17915029689033213, 0.17232333653717846, 0.20806897485414144, 0.1777784073500519, 0.16617735043635107, 0.18164447604945877, 0.16477630017007305, 0.19031797102442738, 0.17392823381788947, 0.15985447497092042, 0.15890152487194742, 0.16555201454818635, 0.15198520073288269, 0.160255357928487, 0.16056125345405947, 0.15592940187239457, 0.165304170174721, 0.15308053224154572, 0.1981319586842345, 0.1699114972098028, 0.15786251463824974, 0.15747391813328104, 0.17405933397180184, 0.22940418946713026, 0.1591953086456266, 0.18764613297452037, 0.17386437555810974, 0.18211399164407094, 0.19455966873706643, 0.1551680223515537, 0.21134510658915628, 0.21631666992575982, 0.17953850920701264, 0.16243981179113565, 0.17763959523680695, 0.1556135582863306, 0.18603258166895786, 0.17748559263029295, 0.19205515276697815, 0.2082593804464904, 0.19537423322687486, 0.18575442400315179, 0.17138824621296278, 0.21103953022954447, 0.18279536392975437, 0.06371954850523542, 0.06308430270200316, 0.06546954030760443, 0.06868354326859683, 0.0609838510767402, 0.06200603160538265, 0.06880522755908425, 0.0642112704336889, 0.06845867794484095]}, "mutation_prompt": null}
{"id": "ae69e253-ee5d-4b72-8b2e-4aea2ffda18c", "solution": "import numpy as np\n\nclass DynamicAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population_scaling = 0.5 + (0.4 * np.random.rand())  # Adjusted dynamic scaling\n        self.population_size = int(self.budget / (5.5 * dim))  # Adjusted population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 5  # Increased local search iterations\n        self.local_search_probability = 0.5  # Increased local search probability\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.2, 0.2))  # Enhanced mutation adaptability\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)  # Adjusted perturbation scale\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.local_search_probability:\n                        improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "DynamicAdaptiveDifferentialEvolution", "description": "Dynamic Adaptive Differential Evolution with Enhanced Local Search and Strategic Mutation for Accelerated Convergence.", "configspace": "", "generation": 36, "fitness": 0.109790971663075, "feedback": "The algorithm DynamicAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.09.", "error": "", "parent_id": "0f70ac0e-2d95-4533-94b4-4a92a69e3c09", "metadata": {"aucs": [0.20897743810013558, 0.21757787494901182, 0.22213980861157212, 0.19172002943629418, 0.21577758099132605, 0.1906961908111856, 0.1868105303023675, 0.17448408631293022, 0.21464642751635887, 9.999999999998899e-05, 9.999999999998899e-05, 0.002289822247126705, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0602324213820441, 0.05848120938631329, 0.05994342743118053, 0.05239335726099381, 0.0598085099760457, 0.06308921197434902, 0.05435974447735592, 0.05701907250882832, 0.06572682092051563, 0.04420344975099921, 0.04418123090918613, 0.04996328438318487, 0.044475924349916984, 0.03931274189170764, 0.04610592884823983, 0.03844431161734152, 0.0390069851451752, 0.05190289355948152, 0.5645020982328997, 0.45635932779189825, 0.14039188515117307, 0.24765730269310948, 0.1706336572882221, 0.29037208427172234, 0.4400651919593003, 0.16731327811421093, 0.12219394641490255, 0.06997004234384607, 0.1056301722962455, 0.08566439606062481, 0.10441454489333535, 0.09507833405141741, 0.07834032166401017, 0.0943564574956608, 0.11578924267917845, 0.0731383827105625, 0.16876207921098285, 0.14048389184568955, 0.15607279269127883, 0.14734351232616827, 0.1393062217299066, 0.13110176839376186, 0.12425220871621301, 0.15281448369655137, 0.16619643813261753, 0.04569569014003794, 0.03077513297075274, 0.01974746600292765, 0.03253831253617068, 0.039736918753202954, 0.027983931216945868, 0.03656581883830112, 0.0328567002061394, 0.0313954811623145, 0.030013723088119115, 0.04584537051554549, 0.01877485593563688, 0.032837882191917966, 0.031242742165892068, 0.03611726994425135, 0.02017242807007935, 0.027064323424529024, 0.025627111343262343, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07732960055111304, 0.06208436251663807, 0.08074746369222574, 0.0604321054685697, 0.07534298800414196, 0.11294735700706948, 0.06845642810248098, 0.06778113593493795, 0.09491665006843653, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005641190761938697, 0.0105896054691198, 0.002651999684946116, 0.002034542007300133, 0.006540865897467829, 0.0038173914996947333, 0.006048160820842141, 0.013872417463614894, 0.009767885596048798, 0.21538839621973926, 0.21130666256610564, 0.21690000433229306, 0.21936748908524684, 0.20844362685081386, 0.21700590191745484, 0.20774967923541143, 0.19940279334076494, 0.20315840904323557, 0.06242604479871228, 0.0733162739597999, 0.05544809554014807, 0.06872412408659145, 0.06282308786856972, 0.06794499675773857, 0.06041081080770838, 0.06331587936469552, 0.056663937071253945, 0.17432760754326615, 0.14807884604616905, 0.14108705283897838, 0.14569210099385332, 0.14514664877242578, 0.1516228945567224, 0.16825492271222287, 0.14244719586074484, 0.15827640755633343, 0.18340964687998695, 0.1833269320092752, 0.18754688247829288, 0.16943488663321937, 0.18434448935834935, 0.18215488393740276, 0.18190369327183575, 0.17470799072595167, 0.17622494229078478, 0.12444920187350639, 0.12496928599233192, 0.11819993454862765, 0.11877053459051135, 0.13224356186245512, 0.11877289115581569, 0.11577787569848574, 0.1195773703087134, 0.12245890844912588, 0.17174520701015006, 0.16506066337744685, 0.1666076472571567, 0.17486913525812764, 0.1814456451787877, 0.17339746475936768, 0.16887419914914192, 0.1592905831321021, 0.17951928748282864, 0.15770684621177078, 0.15581526790847033, 0.1524725493487349, 0.15812486202021936, 0.16156228404914597, 0.14978743092924074, 0.1656169734750933, 0.15586810340394863, 0.15085349422596195, 0.17944046262626467, 0.18045392350601108, 0.17718387941672042, 0.18110144057730515, 0.16732380835908878, 0.16767155674478218, 0.15180850098555532, 0.17715406521851307, 0.20517699770841302, 0.19847999836527574, 0.16218094011118334, 0.21620273236474796, 0.14298997164533744, 0.15729021014147015, 0.15618910661505436, 0.17132494112939134, 0.15644579918127344, 0.1891666809983732, 0.18292896660075342, 0.17606862528962497, 0.18176808995926508, 0.18860883089158897, 0.17778535796683315, 0.21528759255333296, 0.17665634943534603, 0.19102916731948294, 0.1722094804169878, 0.06480066626948389, 0.05714010235042255, 0.06781527697630241, 0.059706438387408745, 0.07645754446462538, 0.06148117760425664, 0.05799705159420987, 0.05975372371214349, 0.0675812888087346]}, "mutation_prompt": null}
{"id": "42b56552-ee61-4b80-bb4a-86a225d62911", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())  # Dynamic scaling for exploration and exploitation\n        self.population_size = int(self.budget / (6 * dim))  # Adjusted population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 3  # Increased local search iterations slightly\n        self.local_search_probability = 0.4  # Tweaked local search probability\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive mutation factor\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.local_search_probability:\n                        improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Dynamic Differential Evolution with Adaptive Mutation and Dynamic Scaling for Improved Convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0f70ac0e-2d95-4533-94b4-4a92a69e3c09", "metadata": {"aucs": [0.2309536128275821, 0.24140130041478225, 0.2551519925560234, 0.21692049877970365, 0.2365852378257277, 0.22072483679405674, 0.23163296595823746, 0.24818537155725384, 0.251514436395746, 0.0025318447600646277, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00014623977548910982, 0.0036062311293150184, 9.999999999998899e-05, 0.0013050311309606988, 9.999999999998899e-05, 0.06157117344709373, 0.061793459413875595, 0.06977999092553566, 0.07437661023839537, 0.06967406530150622, 0.0667395840139614, 0.06497095740251513, 0.061383469585015504, 0.06657997846270647, 0.05401386999124058, 0.053561416888603164, 0.04914281040151236, 0.048739645389581754, 0.05542028840159474, 0.0494448463775341, 0.056864396680539, 0.04899963504073368, 0.06098512097843467, 0.2887288389921647, 0.5159139953503428, 0.714147617104039, 0.5659460863367669, 0.32425029848465803, 0.3462443179115353, 0.400901506547625, 0.503052231355583, 0.33123211639264427, 0.08100634417503028, 0.09994826747292496, 0.07966676256776484, 0.09092631699651044, 0.09786048394280367, 0.08133202988047528, 0.10688171487141429, 0.12218133046958501, 0.08559903491634724, 0.15081670482955178, 0.169328153967913, 0.1534756606452109, 0.17585618130970582, 0.17207674407305262, 0.1505652432187209, 0.15765901900209434, 0.17489712670047664, 0.17290454360367025, 0.0285178102925423, 0.0460916226003123, 0.058770513738986896, 0.03728673973245766, 0.03956084969422913, 0.07175500359626563, 0.043118904177786854, 0.050111447290622, 0.031202302876102705, 0.03525278882796279, 0.058348053874654804, 0.03712753177729211, 0.05069262776034589, 0.0350749202006122, 0.04939903994337835, 0.033188640063688934, 0.039771157378691746, 0.04952452893927928, 9.999999999998899e-05, 9.999999999998899e-05, 0.005064193065404066, 9.999999999998899e-05, 9.999999999998899e-05, 0.00723431562553889, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09578466057659929, 0.09389215683010366, 0.09072591849986278, 0.09107725510005804, 0.09213147967140922, 0.06676900637518723, 0.09108547454809557, 0.11200502552218572, 0.0770775826087986, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016279986601719476, 0.013111746633201804, 0.015003522050638263, 0.014842301196113517, 0.021151511827529834, 0.013710102701378846, 0.014553996549061088, 0.013072740903712687, 0.026749187041233524, 0.22684754440578425, 0.24884916423598602, 0.23661921528808028, 0.2379270999971126, 0.24523966968441058, 0.2386217411684317, 0.22472072853125846, 0.2393052788286265, 0.22962695358601626, 0.05860071131391764, 0.06477729572536883, 0.062113149314511396, 0.05926733179223842, 0.06301105127876638, 0.06863040688550792, 0.07323121185161419, 0.07136666870946706, 0.06365016637221488, 0.16498654882463548, 0.11804347124549497, 0.16017384118495415, 0.15250793313857391, 0.1757237301179152, 0.13055010407175127, 0.13310763830725592, 0.13691134644300507, 0.14027376762499588, 0.18791647952246338, 0.19783310651764674, 0.19338429357547327, 0.17746765276632614, 0.1921417117352986, 0.18819197059132464, 0.1804893769278071, 0.18304382016018939, 0.18478486861579524, 0.1361435346116734, 0.14004499576586182, 0.13605150172791014, 0.12446924420814265, 0.1383811695464927, 0.12840969110461464, 0.13598476078556065, 0.13331210265074422, 0.12918733711687547, 0.1687051145230638, 0.18002370677189805, 0.16627613249363915, 0.17134968588342891, 0.17179531861919206, 0.1809786546664094, 0.18048903644267267, 0.16436100279374133, 0.19327006760624976, 0.15519185352224119, 0.15731474834174608, 0.1505616314174898, 0.1599380851043063, 0.1707517430808393, 0.15297353232999633, 0.15737525763253757, 0.16522050172616132, 0.15629573460429058, 0.15303321829598138, 0.20476823584647053, 0.1657909894261751, 0.14642857756131888, 0.18410201019149186, 0.1440876630332676, 0.20708969023666002, 0.16465451423372923, 0.13612482475776, 0.17731748479632192, 0.20796787277928108, 0.18371573069116198, 0.18195147745053375, 0.1505014169680966, 0.1516068170102315, 0.16386940011920992, 0.17317610513207327, 0.18298963499826437, 0.1868826218472417, 0.18786759010576526, 0.18105410649624942, 0.17963656736599587, 0.19111923851738855, 0.19324645848988042, 0.16722012691085442, 0.18488696101780988, 0.2018175623744456, 0.06277029590944805, 0.06842988300643227, 0.05811355271876695, 0.05859530831979631, 0.05978716167289766, 0.06043190466555659, 0.06328891721987895, 0.0644391684588943, 0.06088469549146669]}, "mutation_prompt": null}
{"id": "b85b14fb-cae8-42cc-b310-8ee792dfa7d9", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())  # Dynamic scaling for exploration and exploitation\n        self.population_size = int(self.budget / (6 * dim))  # Adjusted population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 3  # Increased local search iterations slightly\n        self.local_search_probability = 0.4  # Tweaked local search probability\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive mutation factor\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.local_search_probability:\n                        improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Dynamic Differential Evolution with Adaptive Mutation and Dynamic Scaling for Improved Convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0f70ac0e-2d95-4533-94b4-4a92a69e3c09", "metadata": {"aucs": [0.2309536128275821, 0.24140130041478225, 0.2551519925560234, 0.21692049877970365, 0.2365852378257277, 0.22072483679405674, 0.23163296595823746, 0.24818537155725384, 0.251514436395746, 0.0025318447600646277, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00014623977548910982, 0.0036062311293150184, 9.999999999998899e-05, 0.0013050311309606988, 9.999999999998899e-05, 0.06157117344709373, 0.061793459413875595, 0.06977999092553566, 0.07437661023839537, 0.06967406530150622, 0.0667395840139614, 0.06497095740251513, 0.061383469585015504, 0.06657997846270647, 0.05401386999124058, 0.053561416888603164, 0.04914281040151236, 0.048739645389581754, 0.05542028840159474, 0.0494448463775341, 0.056864396680539, 0.04899963504073368, 0.06098512097843467, 0.2887288389921647, 0.5159139953503428, 0.714147617104039, 0.5659460863367669, 0.32425029848465803, 0.3462443179115353, 0.400901506547625, 0.503052231355583, 0.33123211639264427, 0.08100634417503028, 0.09994826747292496, 0.07966676256776484, 0.09092631699651044, 0.09786048394280367, 0.08133202988047528, 0.10688171487141429, 0.12218133046958501, 0.08559903491634724, 0.15081670482955178, 0.169328153967913, 0.1534756606452109, 0.17585618130970582, 0.17207674407305262, 0.1505652432187209, 0.15765901900209434, 0.17489712670047664, 0.17290454360367025, 0.0285178102925423, 0.0460916226003123, 0.058770513738986896, 0.03728673973245766, 0.03956084969422913, 0.07175500359626563, 0.043118904177786854, 0.050111447290622, 0.031202302876102705, 0.03525278882796279, 0.058348053874654804, 0.03712753177729211, 0.05069262776034589, 0.0350749202006122, 0.04939903994337835, 0.033188640063688934, 0.039771157378691746, 0.04952452893927928, 9.999999999998899e-05, 9.999999999998899e-05, 0.005064193065404066, 9.999999999998899e-05, 9.999999999998899e-05, 0.00723431562553889, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09578466057659929, 0.09389215683010366, 0.09072591849986278, 0.09107725510005804, 0.09213147967140922, 0.06676900637518723, 0.09108547454809557, 0.11200502552218572, 0.0770775826087986, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016279986601719476, 0.013111746633201804, 0.015003522050638263, 0.014842301196113517, 0.021151511827529834, 0.013710102701378846, 0.014553996549061088, 0.013072740903712687, 0.026749187041233524, 0.22684754440578425, 0.24884916423598602, 0.23661921528808028, 0.2379270999971126, 0.24523966968441058, 0.2386217411684317, 0.22472072853125846, 0.2393052788286265, 0.22962695358601626, 0.05860071131391764, 0.06477729572536883, 0.062113149314511396, 0.05926733179223842, 0.06301105127876638, 0.06863040688550792, 0.07323121185161419, 0.07136666870946706, 0.06365016637221488, 0.16498654882463548, 0.11804347124549497, 0.16017384118495415, 0.15250793313857391, 0.1757237301179152, 0.13055010407175127, 0.13310763830725592, 0.13691134644300507, 0.14027376762499588, 0.18791647952246338, 0.19783310651764674, 0.19338429357547327, 0.17746765276632614, 0.1921417117352986, 0.18819197059132464, 0.1804893769278071, 0.18304382016018939, 0.18478486861579524, 0.1361435346116734, 0.14004499576586182, 0.13605150172791014, 0.12446924420814265, 0.1383811695464927, 0.12840969110461464, 0.13598476078556065, 0.13331210265074422, 0.12918733711687547, 0.1687051145230638, 0.18002370677189805, 0.16627613249363915, 0.17134968588342891, 0.17179531861919206, 0.1809786546664094, 0.18048903644267267, 0.16436100279374133, 0.19327006760624976, 0.15519185352224119, 0.15731474834174608, 0.1505616314174898, 0.1599380851043063, 0.1707517430808393, 0.15297353232999633, 0.15737525763253757, 0.16522050172616132, 0.15629573460429058, 0.15303321829598138, 0.20476823584647053, 0.1657909894261751, 0.14642857756131888, 0.18410201019149186, 0.1440876630332676, 0.20708969023666002, 0.16465451423372923, 0.13612482475776, 0.17731748479632192, 0.20796787277928108, 0.18371573069116198, 0.18195147745053375, 0.1505014169680966, 0.1516068170102315, 0.16386940011920992, 0.17317610513207327, 0.18298963499826437, 0.1868826218472417, 0.18786759010576526, 0.18105410649624942, 0.17963656736599587, 0.19111923851738855, 0.19324645848988042, 0.16722012691085442, 0.18488696101780988, 0.2018175623744456, 0.06277029590944805, 0.06842988300643227, 0.05811355271876695, 0.05859530831979631, 0.05978716167289766, 0.06043190466555659, 0.06328891721987895, 0.0644391684588943, 0.06088469549146669]}, "mutation_prompt": null}
{"id": "ae07e8ff-6582-49f1-9ac2-7972666aac35", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())  # Dynamic scaling for exploration and exploitation\n        self.population_size = int(self.budget / (6 * dim))  # Adjusted population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 3  # Increased local search iterations slightly\n        self.local_search_probability = 0.4  # Tweaked local search probability\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive mutation factor\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.local_search_probability:\n                        improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Dynamic Differential Evolution with Adaptive Mutation and Dynamic Scaling for Improved Convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0f70ac0e-2d95-4533-94b4-4a92a69e3c09", "metadata": {"aucs": [0.2309536128275821, 0.24140130041478225, 0.2551519925560234, 0.21692049877970365, 0.2365852378257277, 0.22072483679405674, 0.23163296595823746, 0.24818537155725384, 0.251514436395746, 0.0025318447600646277, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00014623977548910982, 0.0036062311293150184, 9.999999999998899e-05, 0.0013050311309606988, 9.999999999998899e-05, 0.06157117344709373, 0.061793459413875595, 0.06977999092553566, 0.07437661023839537, 0.06967406530150622, 0.0667395840139614, 0.06497095740251513, 0.061383469585015504, 0.06657997846270647, 0.05401386999124058, 0.053561416888603164, 0.04914281040151236, 0.048739645389581754, 0.05542028840159474, 0.0494448463775341, 0.056864396680539, 0.04899963504073368, 0.06098512097843467, 0.2887288389921647, 0.5159139953503428, 0.714147617104039, 0.5659460863367669, 0.32425029848465803, 0.3462443179115353, 0.400901506547625, 0.503052231355583, 0.33123211639264427, 0.08100634417503028, 0.09994826747292496, 0.07966676256776484, 0.09092631699651044, 0.09786048394280367, 0.08133202988047528, 0.10688171487141429, 0.12218133046958501, 0.08559903491634724, 0.15081670482955178, 0.169328153967913, 0.1534756606452109, 0.17585618130970582, 0.17207674407305262, 0.1505652432187209, 0.15765901900209434, 0.17489712670047664, 0.17290454360367025, 0.0285178102925423, 0.0460916226003123, 0.058770513738986896, 0.03728673973245766, 0.03956084969422913, 0.07175500359626563, 0.043118904177786854, 0.050111447290622, 0.031202302876102705, 0.03525278882796279, 0.058348053874654804, 0.03712753177729211, 0.05069262776034589, 0.0350749202006122, 0.04939903994337835, 0.033188640063688934, 0.039771157378691746, 0.04952452893927928, 9.999999999998899e-05, 9.999999999998899e-05, 0.005064193065404066, 9.999999999998899e-05, 9.999999999998899e-05, 0.00723431562553889, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09578466057659929, 0.09389215683010366, 0.09072591849986278, 0.09107725510005804, 0.09213147967140922, 0.06676900637518723, 0.09108547454809557, 0.11200502552218572, 0.0770775826087986, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016279986601719476, 0.013111746633201804, 0.015003522050638263, 0.014842301196113517, 0.021151511827529834, 0.013710102701378846, 0.014553996549061088, 0.013072740903712687, 0.026749187041233524, 0.22684754440578425, 0.24884916423598602, 0.23661921528808028, 0.2379270999971126, 0.24523966968441058, 0.2386217411684317, 0.22472072853125846, 0.2393052788286265, 0.22962695358601626, 0.05860071131391764, 0.06477729572536883, 0.062113149314511396, 0.05926733179223842, 0.06301105127876638, 0.06863040688550792, 0.07323121185161419, 0.07136666870946706, 0.06365016637221488, 0.16498654882463548, 0.11804347124549497, 0.16017384118495415, 0.15250793313857391, 0.1757237301179152, 0.13055010407175127, 0.13310763830725592, 0.13691134644300507, 0.14027376762499588, 0.18791647952246338, 0.19783310651764674, 0.19338429357547327, 0.17746765276632614, 0.1921417117352986, 0.18819197059132464, 0.1804893769278071, 0.18304382016018939, 0.18478486861579524, 0.1361435346116734, 0.14004499576586182, 0.13605150172791014, 0.12446924420814265, 0.1383811695464927, 0.12840969110461464, 0.13598476078556065, 0.13331210265074422, 0.12918733711687547, 0.1687051145230638, 0.18002370677189805, 0.16627613249363915, 0.17134968588342891, 0.17179531861919206, 0.1809786546664094, 0.18048903644267267, 0.16436100279374133, 0.19327006760624976, 0.15519185352224119, 0.15731474834174608, 0.1505616314174898, 0.1599380851043063, 0.1707517430808393, 0.15297353232999633, 0.15737525763253757, 0.16522050172616132, 0.15629573460429058, 0.15303321829598138, 0.20476823584647053, 0.1657909894261751, 0.14642857756131888, 0.18410201019149186, 0.1440876630332676, 0.20708969023666002, 0.16465451423372923, 0.13612482475776, 0.17731748479632192, 0.20796787277928108, 0.18371573069116198, 0.18195147745053375, 0.1505014169680966, 0.1516068170102315, 0.16386940011920992, 0.17317610513207327, 0.18298963499826437, 0.1868826218472417, 0.18786759010576526, 0.18105410649624942, 0.17963656736599587, 0.19111923851738855, 0.19324645848988042, 0.16722012691085442, 0.18488696101780988, 0.2018175623744456, 0.06277029590944805, 0.06842988300643227, 0.05811355271876695, 0.05859530831979631, 0.05978716167289766, 0.06043190466555659, 0.06328891721987895, 0.0644391684588943, 0.06088469549146669]}, "mutation_prompt": null}
{"id": "486bc72a-fc02-4fbe-b7d0-af912d7b73dd", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.85  # Slightly adjusted crossover rate\n        self.mutation_factor = 0.7  # Adjusted mutation factor for better exploration\n        self.population_scaling = 0.4 + (0.3 * np.random.rand())  # Refined dynamic scaling\n        self.dynamic_population_size = int(self.budget / (5 * dim))  # Dynamic population size for enhanced convergence\n        self.initial_population_size = self.dynamic_population_size // 2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.max_local_search_iterations = 4  # Increased local search iterations for deeper exploitation\n        self.local_search_probability = 0.5  # Increased local search probability\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(len(self.population)) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1))\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _expand_population(self, evaluations, func):\n        if len(self.population) < self.dynamic_population_size:\n            new_individuals_count = min(\n                self.dynamic_population_size - len(self.population),\n                self.budget - evaluations\n            )\n            new_individuals = np.random.uniform(\n                self.lower_bound, self.upper_bound, (new_individuals_count, self.dim)\n            )\n            self.population = np.vstack((self.population, new_individuals))\n            new_scores = self._evaluate_population(func)[-new_individuals_count:]\n            return new_scores, new_individuals_count\n        return np.array([]), 0\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = len(self.population)\n\n        while evaluations < self.budget:\n            for i in range(len(self.population)):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.local_search_probability:\n                        improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n            new_scores, new_evaluations = self._expand_population(evaluations, func)\n            evaluations += new_evaluations\n            population_scores = np.concatenate((population_scores, new_scores))\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Dynamic Differential Evolution with Dynamic Population and Hybrid Search Strategies for Accelerated Convergence.", "configspace": "", "generation": 40, "fitness": 0.10632640965868456, "feedback": "The algorithm EnhancedDynamicDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.07.", "error": "", "parent_id": "0f70ac0e-2d95-4533-94b4-4a92a69e3c09", "metadata": {"aucs": [0.22688173212891405, 0.19073460067179882, 0.22514946466182706, 0.19291465088777415, 0.19862357111067563, 0.1987679418710543, 0.20411290342838728, 0.20244050916093348, 0.20280496594626019, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01311811222749526, 0.0015985994414593474, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06123217100878098, 0.06801055854926596, 0.06555893655238287, 0.05817722860920371, 0.06967864757919562, 0.06525948048248609, 0.06226421749388633, 0.06941600925351321, 0.052479278550733754, 0.045576939700961105, 0.039676510280072796, 0.04266621774322443, 0.04558017733808195, 0.040391551176683915, 0.04894988335660677, 0.043737315124504295, 0.04655134576468867, 0.051829110267261225, 0.24082045615211134, 0.1486845516003561, 0.1590662963779832, 0.2444190601827554, 0.14614191602913984, 0.14310057219764527, 0.22342364522393232, 0.16897961125321637, 0.12306177172266819, 0.08232407848041878, 0.09698116601207785, 0.09165686080770752, 0.07176208678563656, 0.07867867981968135, 0.061280519029304426, 0.10239908498944006, 0.136799876776593, 0.07784041180228374, 0.12753130014982328, 0.13232390563828844, 0.15471971787673178, 0.13795485557504095, 0.17740403797436866, 0.16320196499114337, 0.14687417124142577, 0.15691504020840097, 0.1476327139440735, 0.027219320525376456, 0.050716832549802304, 0.028541479775171852, 0.02576714449107298, 0.045516169303363885, 0.03192331100531298, 0.03329602480553384, 0.035621628809777595, 0.02713019265823291, 0.029248903011071192, 0.02925201637154473, 0.05229673502942811, 0.04705293031315505, 0.03343668416670498, 0.030890158692431058, 0.029010903621879303, 0.03499577335550752, 0.030314569056119067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07431988033771142, 0.06336787539437194, 0.07866666012158419, 0.049229865062552225, 0.07259903650346278, 0.06618398395416547, 0.07907223826705378, 0.0861466077236055, 0.07362227919181807, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.025733691676748993, 0.006671210209745926, 0.018400068563572902, 0.008900291448808773, 0.004488530892639009, 0.009891391844653152, 0.004009362358647239, 0.003931082431415933, 0.01797684496008134, 0.23093748817934168, 0.21169160801056475, 0.24972870177051087, 0.21437312708563594, 0.22874410313412652, 0.2005659350814022, 0.21475022974446234, 0.21034069942543088, 0.2255481219815818, 0.05476412211068049, 0.05562938690344943, 0.06563958146360982, 0.06412081078138487, 0.061037066823392716, 0.04927731538230096, 0.06299506984548064, 0.06750013322524084, 0.06703987827056734, 0.14387481197296859, 0.14237274592577365, 0.14582440055109658, 0.15020941698032753, 0.1421314342669413, 0.14673589204505788, 0.14416546405235042, 0.1331315908477243, 0.17705317968301493, 0.1741766369968818, 0.17759274420953985, 0.18458285843788458, 0.17381673361212857, 0.18147916222446092, 0.1873818283216383, 0.17021107223339382, 0.17387402632928606, 0.17234677925466824, 0.12194821318767313, 0.13108768856680075, 0.1303496266169819, 0.1416094135697351, 0.14200911189763177, 0.12930266014649916, 0.1250262654189317, 0.13335844596954816, 0.12166869965019234, 0.1655405481061909, 0.1944194198908913, 0.17645489517222357, 0.17614599484349325, 0.1762388708764503, 0.1801107374338229, 0.17802627057823572, 0.1905924575878325, 0.18187309815603725, 0.1545053793590354, 0.15366056514281567, 0.16587888738323875, 0.1449054051202613, 0.17142480071481625, 0.1497475182438186, 0.1544582763502762, 0.15286106419983858, 0.1492986926256894, 0.1518588122228457, 0.17870604982834282, 0.23444453425106626, 0.18334752562769685, 0.1609976705192494, 0.17416011073187687, 0.1754205829499801, 0.19561616370482893, 0.16826815953728058, 0.19852297564556776, 0.17520964280974438, 0.17435196997041935, 0.17534926411690577, 0.16147737107226423, 0.16920146064596542, 0.1579351079205975, 0.17006270973246795, 0.14654519893598994, 0.20968670226831676, 0.18560935267187273, 0.18929396980623436, 0.1842829313965173, 0.1922047325543058, 0.18640587461547453, 0.1710205537309304, 0.1695148443041231, 0.17470171717620453, 0.06307298509187276, 0.06642317891058791, 0.0492679836153147, 0.06545668559276185, 0.06127936322390448, 0.062487452711049274, 0.0620695653267449, 0.053126067107549524, 0.07687539028126289]}, "mutation_prompt": null}
{"id": "94a4c84a-f939-45cb-b797-bc286a4cf418", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.85  # Slightly reduced for balanced exploration-exploitation\n        self.mutation_factor = 0.9  # Increased mutation factor for broader search\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (5 * dim))  # Adjusted to increase population diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 5  # Increased local search iterations for thorough exploration\n        self.local_search_probability = 0.45  # Enhanced probability for exploiting local search\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.15, 0.15))  # More variability in mutation\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _adaptive_selection(self, target_score, trial_score, idx, trial):\n        if trial_score < target_score:\n            self.population[idx] = trial\n            return trial_score\n        if np.random.rand() < 0.2:  # Add stochastic acceptance factor\n            self.population[idx] = trial\n            return trial_score\n        return target_score\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                population_scores[i] = self._adaptive_selection(population_scores[i], trial_score, i, trial)\n\n                if np.random.rand() < self.local_search_probability:\n                    improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                    improved_score = func(improved_solution)\n                    evaluations += 1\n\n                    if improved_score < population_scores[i]:\n                        self.population[i] = improved_solution\n                        population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Dynamic Differential Evolution with Hierarchical Mutation and Adaptive Selection Strategy for Faster Convergence.", "configspace": "", "generation": 41, "fitness": 0.08830327345076973, "feedback": "The algorithm EnhancedDynamicDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.07.", "error": "", "parent_id": "0f70ac0e-2d95-4533-94b4-4a92a69e3c09", "metadata": {"aucs": [0.15777736428728006, 0.18524970568990495, 0.17245169271302163, 0.18875171262536883, 0.18891527628981908, 0.1680332859165501, 0.1631670231831095, 0.14184755095108048, 0.1766603660193683, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.043440422106234666, 0.04363170709155728, 0.048843170692867366, 0.048591179160275555, 0.052587463787923894, 0.041036839256302526, 0.0459693049213471, 0.04438851793713716, 0.047095852190805254, 0.03081186026778382, 0.026389074051748507, 0.00902981917445922, 0.028743233755488706, 0.025907104012334092, 0.027995300974959947, 0.03533846965289067, 0.02980055035429685, 0.024539944955061177, 0.13035862936592935, 0.46132017063762154, 0.10554812471488972, 0.28217355919510256, 0.11723162047887348, 0.12392469533276196, 0.1272610969556236, 0.1374289227204767, 0.1184460763113877, 0.05542211853334411, 0.1034578335059636, 0.05098413360300269, 0.04625722994317416, 0.06193256894833632, 0.061168993600167365, 0.07528496270215201, 0.11578924267917845, 0.09252983907011769, 0.14973775565593894, 0.11974369926799977, 0.0970932786962665, 0.11851289865320125, 0.1339156738906584, 0.0958970305586403, 0.10079174861359008, 0.136780457463186, 0.1204836637197072, 0.0023483711719911593, 0.015924864286336327, 0.0028626231170119087, 0.012649629784784566, 9.999999999998899e-05, 0.021922952865721657, 0.012892424884172193, 9.999999999998899e-05, 9.999999999998899e-05, 0.018245932127113895, 0.006312250137746167, 9.999999999998899e-05, 0.026404180555176016, 0.020496209047083713, 0.0022856294155940704, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05388463355169637, 0.028692333909101086, 0.07452036533526885, 0.018898322817077817, 0.05623235646461855, 0.030629121303664797, 0.062196783996968374, 0.03246915623871793, 0.03222924560579499, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004349321139083262, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.17961801108875008, 0.1728103266173493, 0.19428481032130318, 0.17016889495414322, 0.19593875704758879, 0.19913163609311046, 0.18581053256662394, 0.16934959822003037, 0.16895532477624398, 0.04476085549931119, 0.04031762737000777, 0.04914546476065973, 0.05309320993231814, 0.055446221428424036, 0.04501324646049565, 0.05635063283898234, 0.03317407664266869, 0.05060167896538392, 0.14101351765872894, 0.12783488855768643, 0.13193224029579975, 0.13128298401630267, 0.14043338366683478, 0.14436663736079425, 0.12728844591162347, 0.13622358173471372, 0.15465224489200313, 0.1618269184889104, 0.16363962763583917, 0.17799389206608285, 0.16579807998590457, 0.17469077034667113, 0.15411228382457898, 0.16073307003525839, 0.16085071490155423, 0.1503994473857303, 0.10213524319152878, 0.09899734276378791, 0.11382153647343607, 0.09117336340751503, 0.10351387534962142, 0.09619705732543804, 0.10249354093101304, 0.1115064633779812, 0.09243206356152345, 0.15772742272172968, 0.1554134365694323, 0.15027890477244532, 0.15893999053785302, 0.15837731445739123, 0.1422590266158521, 0.16500320315303796, 0.15254829152896277, 0.16648734220993644, 0.14277722060430076, 0.13790154037385982, 0.14977812601393303, 0.14024385460328048, 0.11835214699877761, 0.10596215120108665, 0.1427986451043768, 0.14355621810935681, 0.14453992853345676, 0.1496512146200224, 0.14047838093879705, 0.12177744869802498, 0.18542925977667757, 0.1303591411169467, 0.14161509760350732, 0.12807291018242273, 0.13458818906128378, 0.11701491355089089, 0.18348160264291646, 0.15929575425720954, 0.15691767849413285, 0.13009407592301392, 0.1508430704854019, 0.16127625067997375, 0.11079369815067164, 0.12953047840194998, 0.1329810059526495, 0.1842396443849995, 0.17346294131174878, 0.17910204266535767, 0.18366102704664355, 0.18918163569041047, 0.17451326575146053, 0.17202944073253257, 0.181280993982478, 0.1877244495983308, 0.05342470102383523, 0.06586965011527424, 0.053585907601779614, 0.050776398473701745, 0.05272739900122636, 0.04947983618934737, 0.059808349049514264, 0.04798908483452802, 0.06298910697145688]}, "mutation_prompt": null}
{"id": "90b38e96-24cf-4e86-b68c-c9f93af6d360", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())  # Dynamic scaling for exploration and exploitation\n        self.population_size = int(self.budget / (6 * dim))  # Adjusted population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 3  # Increased local search iterations slightly\n        self.local_search_probability = 0.4  # Tweaked local search probability\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive mutation factor\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.local_search_probability:\n                        improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Dynamic Differential Evolution with Adaptive Mutation and Dynamic Scaling for Improved Convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0f70ac0e-2d95-4533-94b4-4a92a69e3c09", "metadata": {"aucs": [0.2309536128275821, 0.24140130041478225, 0.2551519925560234, 0.21692049877970365, 0.2365852378257277, 0.22072483679405674, 0.23163296595823746, 0.24818537155725384, 0.251514436395746, 0.0025318447600646277, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00014623977548910982, 0.0036062311293150184, 9.999999999998899e-05, 0.0013050311309606988, 9.999999999998899e-05, 0.06157117344709373, 0.061793459413875595, 0.06977999092553566, 0.07437661023839537, 0.06967406530150622, 0.0667395840139614, 0.06497095740251513, 0.061383469585015504, 0.06657997846270647, 0.05401386999124058, 0.053561416888603164, 0.04914281040151236, 0.048739645389581754, 0.05542028840159474, 0.0494448463775341, 0.056864396680539, 0.04899963504073368, 0.06098512097843467, 0.2887288389921647, 0.5159139953503428, 0.714147617104039, 0.5659460863367669, 0.32425029848465803, 0.3462443179115353, 0.400901506547625, 0.503052231355583, 0.33123211639264427, 0.08100634417503028, 0.09994826747292496, 0.07966676256776484, 0.09092631699651044, 0.09786048394280367, 0.08133202988047528, 0.10688171487141429, 0.12218133046958501, 0.08559903491634724, 0.15081670482955178, 0.169328153967913, 0.1534756606452109, 0.17585618130970582, 0.17207674407305262, 0.1505652432187209, 0.15765901900209434, 0.17489712670047664, 0.17290454360367025, 0.0285178102925423, 0.0460916226003123, 0.058770513738986896, 0.03728673973245766, 0.03956084969422913, 0.07175500359626563, 0.043118904177786854, 0.050111447290622, 0.031202302876102705, 0.03525278882796279, 0.058348053874654804, 0.03712753177729211, 0.05069262776034589, 0.0350749202006122, 0.04939903994337835, 0.033188640063688934, 0.039771157378691746, 0.04952452893927928, 9.999999999998899e-05, 9.999999999998899e-05, 0.005064193065404066, 9.999999999998899e-05, 9.999999999998899e-05, 0.00723431562553889, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09578466057659929, 0.09389215683010366, 0.09072591849986278, 0.09107725510005804, 0.09213147967140922, 0.06676900637518723, 0.09108547454809557, 0.11200502552218572, 0.0770775826087986, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016279986601719476, 0.013111746633201804, 0.015003522050638263, 0.014842301196113517, 0.021151511827529834, 0.013710102701378846, 0.014553996549061088, 0.013072740903712687, 0.026749187041233524, 0.22684754440578425, 0.24884916423598602, 0.23661921528808028, 0.2379270999971126, 0.24523966968441058, 0.2386217411684317, 0.22472072853125846, 0.2393052788286265, 0.22962695358601626, 0.05860071131391764, 0.06477729572536883, 0.062113149314511396, 0.05926733179223842, 0.06301105127876638, 0.06863040688550792, 0.07323121185161419, 0.07136666870946706, 0.06365016637221488, 0.16498654882463548, 0.11804347124549497, 0.16017384118495415, 0.15250793313857391, 0.1757237301179152, 0.13055010407175127, 0.13310763830725592, 0.13691134644300507, 0.14027376762499588, 0.18791647952246338, 0.19783310651764674, 0.19338429357547327, 0.17746765276632614, 0.1921417117352986, 0.18819197059132464, 0.1804893769278071, 0.18304382016018939, 0.18478486861579524, 0.1361435346116734, 0.14004499576586182, 0.13605150172791014, 0.12446924420814265, 0.1383811695464927, 0.12840969110461464, 0.13598476078556065, 0.13331210265074422, 0.12918733711687547, 0.1687051145230638, 0.18002370677189805, 0.16627613249363915, 0.17134968588342891, 0.17179531861919206, 0.1809786546664094, 0.18048903644267267, 0.16436100279374133, 0.19327006760624976, 0.15519185352224119, 0.15731474834174608, 0.1505616314174898, 0.1599380851043063, 0.1707517430808393, 0.15297353232999633, 0.15737525763253757, 0.16522050172616132, 0.15629573460429058, 0.15303321829598138, 0.20476823584647053, 0.1657909894261751, 0.14642857756131888, 0.18410201019149186, 0.1440876630332676, 0.20708969023666002, 0.16465451423372923, 0.13612482475776, 0.17731748479632192, 0.20796787277928108, 0.18371573069116198, 0.18195147745053375, 0.1505014169680966, 0.1516068170102315, 0.16386940011920992, 0.17317610513207327, 0.18298963499826437, 0.1868826218472417, 0.18786759010576526, 0.18105410649624942, 0.17963656736599587, 0.19111923851738855, 0.19324645848988042, 0.16722012691085442, 0.18488696101780988, 0.2018175623744456, 0.06277029590944805, 0.06842988300643227, 0.05811355271876695, 0.05859530831979631, 0.05978716167289766, 0.06043190466555659, 0.06328891721987895, 0.0644391684588943, 0.06088469549146669]}, "mutation_prompt": null}
{"id": "771339bc-8dba-4b6f-b43f-e97299dd8975", "solution": "import numpy as np\n\nclass EnhancedConvergenceDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (5 * dim))  # Adjusted for quicker adaption\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 5  # Increased local search iterations\n        self.local_search_probability = 0.5  # Increased local search probability\n        self.diversity_threshold = 1e-5  # New parameter for population diversity monitoring\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1))\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant):\n        adaptive_crossover_rate = self.crossover_rate * (1.0 - np.var(self.population) / (self.dim * self.diversity_threshold))\n        crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.local_search_probability:\n                        improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedConvergenceDifferentialEvolution", "description": "Enhanced Convergence with Dynamic Population Adaption and Adaptive Crossover for Improved Exploration and Exploitation.", "configspace": "", "generation": 43, "fitness": 0.09854387568686242, "feedback": "The algorithm EnhancedConvergenceDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.07.", "error": "", "parent_id": "0f70ac0e-2d95-4533-94b4-4a92a69e3c09", "metadata": {"aucs": [0.24349754596562911, 0.1873854705748127, 0.1793937273984486, 0.1925253283114372, 0.2018702974333716, 0.20620161757329147, 0.1757154540838365, 0.17766341432609645, 0.23929034053064346, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05136878049120419, 0.0587586571970935, 0.0647174630484958, 0.056405846251970204, 0.062308477708677645, 0.06363400690667131, 0.055057074432738995, 0.06263998348798505, 0.054530948147030744, 0.053083900411502016, 0.03296397010521612, 0.04741259303713086, 0.038382225064262476, 0.05676496610416448, 0.04342731517578757, 0.04843567415852812, 0.03988194163041536, 0.0480342316550626, 0.12491356422489275, 0.1149862101709681, 0.10692175714171959, 0.1086148123663021, 0.11066613929298219, 0.1169937865303966, 0.1304893141601, 0.1402247628209874, 0.3627597575379615, 0.05688096747797078, 0.11303512920679781, 0.07255545339978198, 0.07698629241219623, 0.09436117656773824, 0.055382670871504724, 0.08202197117175147, 0.12088272572716363, 0.051400323027245176, 0.12529550809865708, 0.11775193793313699, 0.12290321012890892, 0.13941151155534504, 0.12421468443482497, 0.13106246403366517, 0.14945776111058817, 0.1416615074500529, 0.13572112747248033, 0.027296191349422627, 0.031625490871594386, 0.002773009535581017, 0.010121533486519008, 0.04562481016553155, 0.022601419023603686, 0.009354561828942676, 0.007756347174756928, 0.008924020121018672, 0.021242979050193234, 0.005854650215651458, 0.021035330232354155, 0.03553121625372346, 0.015435969422782692, 0.026539974328919413, 0.0069248004537335595, 0.010452174221558974, 0.015490237726801914, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13002056815454743, 0.06122786143429659, 0.06932738517172288, 0.034636661958023285, 0.07805366099950739, 0.053931891261383536, 0.07033835554239176, 0.05692052620819543, 0.06829817692497331, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0003846402107934299, 9.999999999998899e-05, 0.0024287716402592308, 0.00275977499413238, 0.0036926680582840543, 0.0039410107316806275, 9.999999999998899e-05, 0.19921917582016835, 0.1894282761388566, 0.18288605827597726, 0.1773113774078503, 0.188145146815622, 0.25248211219698113, 0.19414720787957263, 0.20435600919925068, 0.19670467669607694, 0.0448321158371533, 0.04684187198599976, 0.04917930846527396, 0.04810768786329278, 0.04389321112656652, 0.06390969052222684, 0.05257403933335625, 0.044265740164775136, 0.05140579693596703, 0.1438079924350919, 0.14764735993782507, 0.20985926069361105, 0.15154432095536563, 0.17294048777557058, 0.16178003459014656, 0.15562352332852736, 0.14739985477153983, 0.18755341025479488, 0.1598913214606642, 0.1701063122014299, 0.18056069613894743, 0.16474230178566462, 0.1787236294960629, 0.17884122135756775, 0.16169142047865737, 0.16750719603755038, 0.16446853398286054, 0.10461561268645159, 0.12922449994796792, 0.11956217747519882, 0.11085492318124035, 0.12413636293558172, 0.1209932467710867, 0.10403567086338494, 0.1307408750560709, 0.1123864194603933, 0.1652112742965386, 0.17079661852065142, 0.1549274701921951, 0.16929523324046714, 0.15520831784685674, 0.1759270199547489, 0.16879041728749233, 0.17278047451929834, 0.16996485084931867, 0.14958405352641735, 0.14437450719267364, 0.1497614342256527, 0.14234411708826578, 0.15646687056477526, 0.14725533492137277, 0.16112080598334555, 0.15578003023316556, 0.15437174265261222, 0.1696207471897213, 0.1484419483686379, 0.15066076002804962, 0.20550004785585096, 0.20625774799016539, 0.17167981514951758, 0.16670928814244979, 0.18473845945883127, 0.1525839727472923, 0.19601806453069215, 0.16124076115144836, 0.15959598467269953, 0.13284169721836492, 0.12533358636830727, 0.1374802142933793, 0.14355060668846398, 0.1358564929772892, 0.22090646758355081, 0.17824391186273736, 0.18996716158332916, 0.18770769982431723, 0.19610992812662353, 0.20872872724780822, 0.1953669292136767, 0.16967275471719623, 0.1826011669982901, 0.18142837582285465, 0.05832181043799045, 0.057653057498672, 0.05292228107380437, 0.06123108361007812, 0.0507126015077638, 0.05810583706249195, 0.07231981763720907, 0.061896633381139377, 0.0660275202310171]}, "mutation_prompt": null}
{"id": "f0cea4bd-c275-460d-974b-fa2cac77a9d5", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.95  # Adjusted crossover rate for robustness\n        self.mutation_factor = 0.85  # Slightly increased mutation factor\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (5 * dim))  # Adjusted population size for quicker convergence\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 4  # Increased local search iterations\n        self.local_search_probability = 0.5  # Increased local search probability\n        self.levy_probability = 0.2  # Added Levy flight probability\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1))\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _levy_flight(self, solution):\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / abs(v) ** (1 / beta)\n        return np.clip(solution + step, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.local_search_probability:\n                        improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n                if np.random.rand() < self.levy_probability and evaluations < self.budget:\n                    levy_solution = self._levy_flight(self.population[i])\n                    levy_score = func(levy_solution)\n                    evaluations += 1\n\n                    if levy_score < population_scores[i]:\n                        self.population[i] = levy_solution\n                        population_scores[i] = levy_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Dynamic Differential Evolution with Adaptive Mutation, Dynamic Scaling, and Levy Flight for Improved Convergence and Diversity.", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "0f70ac0e-2d95-4533-94b4-4a92a69e3c09", "metadata": {}, "mutation_prompt": null}
{"id": "03aaa87b-cf86-4d03-b428-880d3132f117", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())  # Dynamic scaling for exploration and exploitation\n        self.population_size = int(self.budget / (6 * dim))  # Adjusted population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 3  \n        self.local_search_probability = 0.4  \n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1))  \n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _opposition_based_learning(self):\n        opposite_population = self.lower_bound + self.upper_bound - self.population\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.local_search_probability:\n                        improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Dynamic Differential Evolution with Opposition-Based Learning and Adaptive Crossover introduced for faster convergence.", "configspace": "", "generation": 45, "fitness": 0.12598687330913635, "feedback": "The algorithm EnhancedDynamicDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.11.", "error": "", "parent_id": "0f70ac0e-2d95-4533-94b4-4a92a69e3c09", "metadata": {"aucs": [0.22634800580454262, 0.24236618681980704, 0.2378504329072585, 0.22878960459200137, 0.24525244590417972, 0.22963161617278338, 0.21882381190605238, 0.23162355519808064, 0.23203859411942673, 0.0016135694211231177, 0.010002432972741393, 0.001974538391380176, 0.0027953574475108045, 9.999999999998899e-05, 0.0001879088157337172, 0.010002295965286234, 0.001406383294492608, 0.0002771922552837758, 0.07338267490805594, 0.07114034086470433, 0.06390780221304937, 0.06859450182169202, 0.07456938088632303, 0.06715922751736947, 0.07145176075777437, 0.06184890924560782, 0.07519994689773923, 0.05385356711124989, 0.05058915619676241, 0.05606131393969627, 0.05391729790225197, 0.05531281135899002, 0.05207376691084187, 0.05609324705517682, 0.053127249659466025, 0.08159681766610971, 0.4590750097494757, 0.49731541980314464, 0.3586189294474771, 0.3866718724920647, 0.4900579335044575, 0.8245237482027871, 0.5329165207071984, 0.5313374144606915, 0.537479077516154, 0.07389495326329398, 0.09732811949257503, 0.09498169881949092, 0.09428190033618544, 0.08052142859448963, 0.08913488726923646, 0.09988818156301404, 0.11952152253695936, 0.10077017468440408, 0.1369976342945478, 0.14869354588028705, 0.15152935520478272, 0.16286290560076377, 0.17175393448163467, 0.21211419453537916, 0.16347858950828797, 0.20264634198444986, 0.1640373095302179, 0.05960417935430162, 0.09041977101188114, 0.038714904617561885, 0.044205758340863044, 0.02817110927151456, 0.05136050637211387, 0.0563047133135548, 0.05045475937105581, 0.06459145902304098, 0.03421391812228558, 0.02416706651263134, 0.03546983026034667, 0.07628046260537524, 0.042634088677675375, 0.04090577394952488, 0.03649176472185167, 0.04473937904672132, 0.04204795460469135, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07201866014379121, 0.07312745368438611, 0.074795246536286, 0.05790574334749221, 0.07592478158596383, 0.07986418371437887, 0.0784723629167946, 0.09066324034296847, 0.05804535780347764, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010597832625994341, 0.008760712107993673, 0.013212424048312243, 0.009920499786042813, 0.018544704870406492, 0.019930907027141287, 0.023376192745402258, 0.016868831136677698, 0.021325416891869065, 0.22832147495370558, 0.247763947795403, 0.2347914909114711, 0.24044083890851953, 0.2304681251792594, 0.24158331696762392, 0.2504172422414628, 0.2403277446601264, 0.25115629904579695, 0.061012716680247325, 0.06233151120152669, 0.062025132340548406, 0.05562600417711416, 0.062084856627478646, 0.06355870396280139, 0.08386033924345171, 0.07751348014977832, 0.06056265409322803, 0.14600253531233398, 0.12650586518018048, 0.1380564137500191, 0.1510022252599993, 0.18069227791743792, 0.13258489873268953, 0.14010249492340954, 0.14448033777963487, 0.14657931435166616, 0.17601390054453692, 0.1793388161732189, 0.1866089456681681, 0.18387861347847223, 0.18707720028840868, 0.1896951409407881, 0.18746348486204611, 0.19459996691418724, 0.1924690200540996, 0.12647606324474603, 0.1302584965173963, 0.13605161745431382, 0.12571043351511058, 0.13216694201599744, 0.12922886211694606, 0.13468994634347076, 0.13880541766330445, 0.12490913790176406, 0.1747546539688647, 0.1764902524847174, 0.17217803881716498, 0.16469819340440628, 0.16698638123656817, 0.1696843837029739, 0.16405367658503256, 0.2156528032837901, 0.18439158140500345, 0.16261065391050833, 0.16256438771413162, 0.14978248009171835, 0.16142945917405394, 0.16118416596076002, 0.15577956380486924, 0.16358578934764179, 0.16103483683837494, 0.16112510573492178, 0.16972820794210586, 0.16494436907496524, 0.15016027789326747, 0.17595156299608683, 0.16287933729077664, 0.22331475459792882, 0.170484512544392, 0.15693519796015265, 0.18743654988007563, 0.1509555298939711, 0.16511228713436465, 0.2160548383727423, 0.15528746582199493, 0.1556772020147833, 0.1632540402570718, 0.1652386055250441, 0.17060717266784742, 0.16247898929300975, 0.18739054427982338, 0.19423802848578875, 0.18223895355185993, 0.1890141390367548, 0.1837732044949546, 0.2112773042611017, 0.1728867485092389, 0.197955144448831, 0.17789128196850035, 0.06906105805261542, 0.06730668349429192, 0.06260782493416339, 0.08174464431109629, 0.06008415591016514, 0.06014437749237744, 0.0634939701312005, 0.07018186709267371, 0.06276488879167808]}, "mutation_prompt": null}
{"id": "58efd296-af03-431e-89bd-7795f7295e66", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())  # Dynamic scaling for exploration and exploitation\n        self.population_size = int(self.budget / (6 * dim))  # Adjusted population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 3  \n        self.local_search_probability = 0.4  \n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1))  \n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _opposition_based_learning(self):\n        opposite_population = self.lower_bound + self.upper_bound - self.population\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.local_search_probability:\n                        improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Dynamic Differential Evolution with Opposition-Based Learning and Adaptive Crossover introduced for faster convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03aaa87b-cf86-4d03-b428-880d3132f117", "metadata": {"aucs": [0.22634800580454262, 0.24236618681980704, 0.2378504329072585, 0.22878960459200137, 0.24525244590417972, 0.22963161617278338, 0.21882381190605238, 0.23162355519808064, 0.23203859411942673, 0.0016135694211231177, 0.010002432972741393, 0.001974538391380176, 0.0027953574475108045, 9.999999999998899e-05, 0.0001879088157337172, 0.010002295965286234, 0.001406383294492608, 0.0002771922552837758, 0.07338267490805594, 0.07114034086470433, 0.06390780221304937, 0.06859450182169202, 0.07456938088632303, 0.06715922751736947, 0.07145176075777437, 0.06184890924560782, 0.07519994689773923, 0.05385356711124989, 0.05058915619676241, 0.05606131393969627, 0.05391729790225197, 0.05531281135899002, 0.05207376691084187, 0.05609324705517682, 0.053127249659466025, 0.08159681766610971, 0.4590750097494757, 0.49731541980314464, 0.3586189294474771, 0.3866718724920647, 0.4900579335044575, 0.8245237482027871, 0.5329165207071984, 0.5313374144606915, 0.537479077516154, 0.07389495326329398, 0.09732811949257503, 0.09498169881949092, 0.09428190033618544, 0.08052142859448963, 0.08913488726923646, 0.09988818156301404, 0.11952152253695936, 0.10077017468440408, 0.1369976342945478, 0.14869354588028705, 0.15152935520478272, 0.16286290560076377, 0.17175393448163467, 0.21211419453537916, 0.16347858950828797, 0.20264634198444986, 0.1640373095302179, 0.05960417935430162, 0.09041977101188114, 0.038714904617561885, 0.044205758340863044, 0.02817110927151456, 0.05136050637211387, 0.0563047133135548, 0.05045475937105581, 0.06459145902304098, 0.03421391812228558, 0.02416706651263134, 0.03546983026034667, 0.07628046260537524, 0.042634088677675375, 0.04090577394952488, 0.03649176472185167, 0.04473937904672132, 0.04204795460469135, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07201866014379121, 0.07312745368438611, 0.074795246536286, 0.05790574334749221, 0.07592478158596383, 0.07986418371437887, 0.0784723629167946, 0.09066324034296847, 0.05804535780347764, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010597832625994341, 0.008760712107993673, 0.013212424048312243, 0.009920499786042813, 0.018544704870406492, 0.019930907027141287, 0.023376192745402258, 0.016868831136677698, 0.021325416891869065, 0.22832147495370558, 0.247763947795403, 0.2347914909114711, 0.24044083890851953, 0.2304681251792594, 0.24158331696762392, 0.2504172422414628, 0.2403277446601264, 0.25115629904579695, 0.061012716680247325, 0.06233151120152669, 0.062025132340548406, 0.05562600417711416, 0.062084856627478646, 0.06355870396280139, 0.08386033924345171, 0.07751348014977832, 0.06056265409322803, 0.14600253531233398, 0.12650586518018048, 0.1380564137500191, 0.1510022252599993, 0.18069227791743792, 0.13258489873268953, 0.14010249492340954, 0.14448033777963487, 0.14657931435166616, 0.17601390054453692, 0.1793388161732189, 0.1866089456681681, 0.18387861347847223, 0.18707720028840868, 0.1896951409407881, 0.18746348486204611, 0.19459996691418724, 0.1924690200540996, 0.12647606324474603, 0.1302584965173963, 0.13605161745431382, 0.12571043351511058, 0.13216694201599744, 0.12922886211694606, 0.13468994634347076, 0.13880541766330445, 0.12490913790176406, 0.1747546539688647, 0.1764902524847174, 0.17217803881716498, 0.16469819340440628, 0.16698638123656817, 0.1696843837029739, 0.16405367658503256, 0.2156528032837901, 0.18439158140500345, 0.16261065391050833, 0.16256438771413162, 0.14978248009171835, 0.16142945917405394, 0.16118416596076002, 0.15577956380486924, 0.16358578934764179, 0.16103483683837494, 0.16112510573492178, 0.16972820794210586, 0.16494436907496524, 0.15016027789326747, 0.17595156299608683, 0.16287933729077664, 0.22331475459792882, 0.170484512544392, 0.15693519796015265, 0.18743654988007563, 0.1509555298939711, 0.16511228713436465, 0.2160548383727423, 0.15528746582199493, 0.1556772020147833, 0.1632540402570718, 0.1652386055250441, 0.17060717266784742, 0.16247898929300975, 0.18739054427982338, 0.19423802848578875, 0.18223895355185993, 0.1890141390367548, 0.1837732044949546, 0.2112773042611017, 0.1728867485092389, 0.197955144448831, 0.17789128196850035, 0.06906105805261542, 0.06730668349429192, 0.06260782493416339, 0.08174464431109629, 0.06008415591016514, 0.06014437749237744, 0.0634939701312005, 0.07018186709267371, 0.06276488879167808]}, "mutation_prompt": null}
{"id": "5bbb9d84-92f0-4faf-9ea0-cd24120890d0", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())  # Dynamic scaling for exploration and exploitation\n        self.population_size = int(self.budget / (6 * dim))  # Adjusted population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 3  \n        self.local_search_probability = 0.4  \n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1))  \n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _opposition_based_learning(self):\n        opposite_population = self.lower_bound + self.upper_bound - self.population\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.local_search_probability:\n                        improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Dynamic Differential Evolution with Opposition-Based Learning and Adaptive Crossover introduced for faster convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03aaa87b-cf86-4d03-b428-880d3132f117", "metadata": {"aucs": [0.22634800580454262, 0.24236618681980704, 0.2378504329072585, 0.22878960459200137, 0.24525244590417972, 0.22963161617278338, 0.21882381190605238, 0.23162355519808064, 0.23203859411942673, 0.0016135694211231177, 0.010002432972741393, 0.001974538391380176, 0.0027953574475108045, 9.999999999998899e-05, 0.0001879088157337172, 0.010002295965286234, 0.001406383294492608, 0.0002771922552837758, 0.07338267490805594, 0.07114034086470433, 0.06390780221304937, 0.06859450182169202, 0.07456938088632303, 0.06715922751736947, 0.07145176075777437, 0.06184890924560782, 0.07519994689773923, 0.05385356711124989, 0.05058915619676241, 0.05606131393969627, 0.05391729790225197, 0.05531281135899002, 0.05207376691084187, 0.05609324705517682, 0.053127249659466025, 0.08159681766610971, 0.4590750097494757, 0.49731541980314464, 0.3586189294474771, 0.3866718724920647, 0.4900579335044575, 0.8245237482027871, 0.5329165207071984, 0.5313374144606915, 0.537479077516154, 0.07389495326329398, 0.09732811949257503, 0.09498169881949092, 0.09428190033618544, 0.08052142859448963, 0.08913488726923646, 0.09988818156301404, 0.11952152253695936, 0.10077017468440408, 0.1369976342945478, 0.14869354588028705, 0.15152935520478272, 0.16286290560076377, 0.17175393448163467, 0.21211419453537916, 0.16347858950828797, 0.20264634198444986, 0.1640373095302179, 0.05960417935430162, 0.09041977101188114, 0.038714904617561885, 0.044205758340863044, 0.02817110927151456, 0.05136050637211387, 0.0563047133135548, 0.05045475937105581, 0.06459145902304098, 0.03421391812228558, 0.02416706651263134, 0.03546983026034667, 0.07628046260537524, 0.042634088677675375, 0.04090577394952488, 0.03649176472185167, 0.04473937904672132, 0.04204795460469135, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07201866014379121, 0.07312745368438611, 0.074795246536286, 0.05790574334749221, 0.07592478158596383, 0.07986418371437887, 0.0784723629167946, 0.09066324034296847, 0.05804535780347764, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010597832625994341, 0.008760712107993673, 0.013212424048312243, 0.009920499786042813, 0.018544704870406492, 0.019930907027141287, 0.023376192745402258, 0.016868831136677698, 0.021325416891869065, 0.22832147495370558, 0.247763947795403, 0.2347914909114711, 0.24044083890851953, 0.2304681251792594, 0.24158331696762392, 0.2504172422414628, 0.2403277446601264, 0.25115629904579695, 0.061012716680247325, 0.06233151120152669, 0.062025132340548406, 0.05562600417711416, 0.062084856627478646, 0.06355870396280139, 0.08386033924345171, 0.07751348014977832, 0.06056265409322803, 0.14600253531233398, 0.12650586518018048, 0.1380564137500191, 0.1510022252599993, 0.18069227791743792, 0.13258489873268953, 0.14010249492340954, 0.14448033777963487, 0.14657931435166616, 0.17601390054453692, 0.1793388161732189, 0.1866089456681681, 0.18387861347847223, 0.18707720028840868, 0.1896951409407881, 0.18746348486204611, 0.19459996691418724, 0.1924690200540996, 0.12647606324474603, 0.1302584965173963, 0.13605161745431382, 0.12571043351511058, 0.13216694201599744, 0.12922886211694606, 0.13468994634347076, 0.13880541766330445, 0.12490913790176406, 0.1747546539688647, 0.1764902524847174, 0.17217803881716498, 0.16469819340440628, 0.16698638123656817, 0.1696843837029739, 0.16405367658503256, 0.2156528032837901, 0.18439158140500345, 0.16261065391050833, 0.16256438771413162, 0.14978248009171835, 0.16142945917405394, 0.16118416596076002, 0.15577956380486924, 0.16358578934764179, 0.16103483683837494, 0.16112510573492178, 0.16972820794210586, 0.16494436907496524, 0.15016027789326747, 0.17595156299608683, 0.16287933729077664, 0.22331475459792882, 0.170484512544392, 0.15693519796015265, 0.18743654988007563, 0.1509555298939711, 0.16511228713436465, 0.2160548383727423, 0.15528746582199493, 0.1556772020147833, 0.1632540402570718, 0.1652386055250441, 0.17060717266784742, 0.16247898929300975, 0.18739054427982338, 0.19423802848578875, 0.18223895355185993, 0.1890141390367548, 0.1837732044949546, 0.2112773042611017, 0.1728867485092389, 0.197955144448831, 0.17789128196850035, 0.06906105805261542, 0.06730668349429192, 0.06260782493416339, 0.08174464431109629, 0.06008415591016514, 0.06014437749237744, 0.0634939701312005, 0.07018186709267371, 0.06276488879167808]}, "mutation_prompt": null}
{"id": "e6204cb6-833a-44c9-a32c-315d9ed334e2", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())  # Dynamic scaling for exploration and exploitation\n        self.population_size = int(self.budget / (6 * dim))  # Adjusted population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 3  \n        self.local_search_probability = 0.4  \n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1))  \n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _opposition_based_learning(self):\n        opposite_population = self.lower_bound + self.upper_bound - self.population\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.local_search_probability:\n                        improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Dynamic Differential Evolution with Opposition-Based Learning and Adaptive Crossover introduced for faster convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03aaa87b-cf86-4d03-b428-880d3132f117", "metadata": {"aucs": [0.22634800580454262, 0.24236618681980704, 0.2378504329072585, 0.22878960459200137, 0.24525244590417972, 0.22963161617278338, 0.21882381190605238, 0.23162355519808064, 0.23203859411942673, 0.0016135694211231177, 0.010002432972741393, 0.001974538391380176, 0.0027953574475108045, 9.999999999998899e-05, 0.0001879088157337172, 0.010002295965286234, 0.001406383294492608, 0.0002771922552837758, 0.07338267490805594, 0.07114034086470433, 0.06390780221304937, 0.06859450182169202, 0.07456938088632303, 0.06715922751736947, 0.07145176075777437, 0.06184890924560782, 0.07519994689773923, 0.05385356711124989, 0.05058915619676241, 0.05606131393969627, 0.05391729790225197, 0.05531281135899002, 0.05207376691084187, 0.05609324705517682, 0.053127249659466025, 0.08159681766610971, 0.4590750097494757, 0.49731541980314464, 0.3586189294474771, 0.3866718724920647, 0.4900579335044575, 0.8245237482027871, 0.5329165207071984, 0.5313374144606915, 0.537479077516154, 0.07389495326329398, 0.09732811949257503, 0.09498169881949092, 0.09428190033618544, 0.08052142859448963, 0.08913488726923646, 0.09988818156301404, 0.11952152253695936, 0.10077017468440408, 0.1369976342945478, 0.14869354588028705, 0.15152935520478272, 0.16286290560076377, 0.17175393448163467, 0.21211419453537916, 0.16347858950828797, 0.20264634198444986, 0.1640373095302179, 0.05960417935430162, 0.09041977101188114, 0.038714904617561885, 0.044205758340863044, 0.02817110927151456, 0.05136050637211387, 0.0563047133135548, 0.05045475937105581, 0.06459145902304098, 0.03421391812228558, 0.02416706651263134, 0.03546983026034667, 0.07628046260537524, 0.042634088677675375, 0.04090577394952488, 0.03649176472185167, 0.04473937904672132, 0.04204795460469135, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07201866014379121, 0.07312745368438611, 0.074795246536286, 0.05790574334749221, 0.07592478158596383, 0.07986418371437887, 0.0784723629167946, 0.09066324034296847, 0.05804535780347764, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010597832625994341, 0.008760712107993673, 0.013212424048312243, 0.009920499786042813, 0.018544704870406492, 0.019930907027141287, 0.023376192745402258, 0.016868831136677698, 0.021325416891869065, 0.22832147495370558, 0.247763947795403, 0.2347914909114711, 0.24044083890851953, 0.2304681251792594, 0.24158331696762392, 0.2504172422414628, 0.2403277446601264, 0.25115629904579695, 0.061012716680247325, 0.06233151120152669, 0.062025132340548406, 0.05562600417711416, 0.062084856627478646, 0.06355870396280139, 0.08386033924345171, 0.07751348014977832, 0.06056265409322803, 0.14600253531233398, 0.12650586518018048, 0.1380564137500191, 0.1510022252599993, 0.18069227791743792, 0.13258489873268953, 0.14010249492340954, 0.14448033777963487, 0.14657931435166616, 0.17601390054453692, 0.1793388161732189, 0.1866089456681681, 0.18387861347847223, 0.18707720028840868, 0.1896951409407881, 0.18746348486204611, 0.19459996691418724, 0.1924690200540996, 0.12647606324474603, 0.1302584965173963, 0.13605161745431382, 0.12571043351511058, 0.13216694201599744, 0.12922886211694606, 0.13468994634347076, 0.13880541766330445, 0.12490913790176406, 0.1747546539688647, 0.1764902524847174, 0.17217803881716498, 0.16469819340440628, 0.16698638123656817, 0.1696843837029739, 0.16405367658503256, 0.2156528032837901, 0.18439158140500345, 0.16261065391050833, 0.16256438771413162, 0.14978248009171835, 0.16142945917405394, 0.16118416596076002, 0.15577956380486924, 0.16358578934764179, 0.16103483683837494, 0.16112510573492178, 0.16972820794210586, 0.16494436907496524, 0.15016027789326747, 0.17595156299608683, 0.16287933729077664, 0.22331475459792882, 0.170484512544392, 0.15693519796015265, 0.18743654988007563, 0.1509555298939711, 0.16511228713436465, 0.2160548383727423, 0.15528746582199493, 0.1556772020147833, 0.1632540402570718, 0.1652386055250441, 0.17060717266784742, 0.16247898929300975, 0.18739054427982338, 0.19423802848578875, 0.18223895355185993, 0.1890141390367548, 0.1837732044949546, 0.2112773042611017, 0.1728867485092389, 0.197955144448831, 0.17789128196850035, 0.06906105805261542, 0.06730668349429192, 0.06260782493416339, 0.08174464431109629, 0.06008415591016514, 0.06014437749237744, 0.0634939701312005, 0.07018186709267371, 0.06276488879167808]}, "mutation_prompt": null}
{"id": "2348653c-9583-451b-afd8-7c9625d68dd4", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())  # Dynamic scaling for exploration and exploitation\n        self.population_size = int(self.budget / (6 * dim))  # Adjusted population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 3  \n        self.local_search_probability = 0.4  \n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1))  \n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _opposition_based_learning(self):\n        opposite_population = self.lower_bound + self.upper_bound - self.population\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.local_search_probability:\n                        improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Dynamic Differential Evolution with Opposition-Based Learning and Adaptive Crossover introduced for faster convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03aaa87b-cf86-4d03-b428-880d3132f117", "metadata": {"aucs": [0.22634800580454262, 0.24236618681980704, 0.2378504329072585, 0.22878960459200137, 0.24525244590417972, 0.22963161617278338, 0.21882381190605238, 0.23162355519808064, 0.23203859411942673, 0.0016135694211231177, 0.010002432972741393, 0.001974538391380176, 0.0027953574475108045, 9.999999999998899e-05, 0.0001879088157337172, 0.010002295965286234, 0.001406383294492608, 0.0002771922552837758, 0.07338267490805594, 0.07114034086470433, 0.06390780221304937, 0.06859450182169202, 0.07456938088632303, 0.06715922751736947, 0.07145176075777437, 0.06184890924560782, 0.07519994689773923, 0.05385356711124989, 0.05058915619676241, 0.05606131393969627, 0.05391729790225197, 0.05531281135899002, 0.05207376691084187, 0.05609324705517682, 0.053127249659466025, 0.08159681766610971, 0.4590750097494757, 0.49731541980314464, 0.3586189294474771, 0.3866718724920647, 0.4900579335044575, 0.8245237482027871, 0.5329165207071984, 0.5313374144606915, 0.537479077516154, 0.07389495326329398, 0.09732811949257503, 0.09498169881949092, 0.09428190033618544, 0.08052142859448963, 0.08913488726923646, 0.09988818156301404, 0.11952152253695936, 0.10077017468440408, 0.1369976342945478, 0.14869354588028705, 0.15152935520478272, 0.16286290560076377, 0.17175393448163467, 0.21211419453537916, 0.16347858950828797, 0.20264634198444986, 0.1640373095302179, 0.05960417935430162, 0.09041977101188114, 0.038714904617561885, 0.044205758340863044, 0.02817110927151456, 0.05136050637211387, 0.0563047133135548, 0.05045475937105581, 0.06459145902304098, 0.03421391812228558, 0.02416706651263134, 0.03546983026034667, 0.07628046260537524, 0.042634088677675375, 0.04090577394952488, 0.03649176472185167, 0.04473937904672132, 0.04204795460469135, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07201866014379121, 0.07312745368438611, 0.074795246536286, 0.05790574334749221, 0.07592478158596383, 0.07986418371437887, 0.0784723629167946, 0.09066324034296847, 0.05804535780347764, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010597832625994341, 0.008760712107993673, 0.013212424048312243, 0.009920499786042813, 0.018544704870406492, 0.019930907027141287, 0.023376192745402258, 0.016868831136677698, 0.021325416891869065, 0.22832147495370558, 0.247763947795403, 0.2347914909114711, 0.24044083890851953, 0.2304681251792594, 0.24158331696762392, 0.2504172422414628, 0.2403277446601264, 0.25115629904579695, 0.061012716680247325, 0.06233151120152669, 0.062025132340548406, 0.05562600417711416, 0.062084856627478646, 0.06355870396280139, 0.08386033924345171, 0.07751348014977832, 0.06056265409322803, 0.14600253531233398, 0.12650586518018048, 0.1380564137500191, 0.1510022252599993, 0.18069227791743792, 0.13258489873268953, 0.14010249492340954, 0.14448033777963487, 0.14657931435166616, 0.17601390054453692, 0.1793388161732189, 0.1866089456681681, 0.18387861347847223, 0.18707720028840868, 0.1896951409407881, 0.18746348486204611, 0.19459996691418724, 0.1924690200540996, 0.12647606324474603, 0.1302584965173963, 0.13605161745431382, 0.12571043351511058, 0.13216694201599744, 0.12922886211694606, 0.13468994634347076, 0.13880541766330445, 0.12490913790176406, 0.1747546539688647, 0.1764902524847174, 0.17217803881716498, 0.16469819340440628, 0.16698638123656817, 0.1696843837029739, 0.16405367658503256, 0.2156528032837901, 0.18439158140500345, 0.16261065391050833, 0.16256438771413162, 0.14978248009171835, 0.16142945917405394, 0.16118416596076002, 0.15577956380486924, 0.16358578934764179, 0.16103483683837494, 0.16112510573492178, 0.16972820794210586, 0.16494436907496524, 0.15016027789326747, 0.17595156299608683, 0.16287933729077664, 0.22331475459792882, 0.170484512544392, 0.15693519796015265, 0.18743654988007563, 0.1509555298939711, 0.16511228713436465, 0.2160548383727423, 0.15528746582199493, 0.1556772020147833, 0.1632540402570718, 0.1652386055250441, 0.17060717266784742, 0.16247898929300975, 0.18739054427982338, 0.19423802848578875, 0.18223895355185993, 0.1890141390367548, 0.1837732044949546, 0.2112773042611017, 0.1728867485092389, 0.197955144448831, 0.17789128196850035, 0.06906105805261542, 0.06730668349429192, 0.06260782493416339, 0.08174464431109629, 0.06008415591016514, 0.06014437749237744, 0.0634939701312005, 0.07018186709267371, 0.06276488879167808]}, "mutation_prompt": null}
{"id": "6fffb917-9248-4916-ac47-32b5b7c78f18", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())  # Dynamic scaling for exploration and exploitation\n        self.population_size = int(self.budget / (6 * dim))  # Adjusted population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 3  \n        self.local_search_probability = 0.4  \n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1))  \n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _opposition_based_learning(self):\n        opposite_population = self.lower_bound + self.upper_bound - self.population\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.local_search_probability:\n                        improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Dynamic Differential Evolution with Opposition-Based Learning and Adaptive Crossover introduced for faster convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03aaa87b-cf86-4d03-b428-880d3132f117", "metadata": {"aucs": [0.22634800580454262, 0.24236618681980704, 0.2378504329072585, 0.22878960459200137, 0.24525244590417972, 0.22963161617278338, 0.21882381190605238, 0.23162355519808064, 0.23203859411942673, 0.0016135694211231177, 0.010002432972741393, 0.001974538391380176, 0.0027953574475108045, 9.999999999998899e-05, 0.0001879088157337172, 0.010002295965286234, 0.001406383294492608, 0.0002771922552837758, 0.07338267490805594, 0.07114034086470433, 0.06390780221304937, 0.06859450182169202, 0.07456938088632303, 0.06715922751736947, 0.07145176075777437, 0.06184890924560782, 0.07519994689773923, 0.05385356711124989, 0.05058915619676241, 0.05606131393969627, 0.05391729790225197, 0.05531281135899002, 0.05207376691084187, 0.05609324705517682, 0.053127249659466025, 0.08159681766610971, 0.4590750097494757, 0.49731541980314464, 0.3586189294474771, 0.3866718724920647, 0.4900579335044575, 0.8245237482027871, 0.5329165207071984, 0.5313374144606915, 0.537479077516154, 0.07389495326329398, 0.09732811949257503, 0.09498169881949092, 0.09428190033618544, 0.08052142859448963, 0.08913488726923646, 0.09988818156301404, 0.11952152253695936, 0.10077017468440408, 0.1369976342945478, 0.14869354588028705, 0.15152935520478272, 0.16286290560076377, 0.17175393448163467, 0.21211419453537916, 0.16347858950828797, 0.20264634198444986, 0.1640373095302179, 0.05960417935430162, 0.09041977101188114, 0.038714904617561885, 0.044205758340863044, 0.02817110927151456, 0.05136050637211387, 0.0563047133135548, 0.05045475937105581, 0.06459145902304098, 0.03421391812228558, 0.02416706651263134, 0.03546983026034667, 0.07628046260537524, 0.042634088677675375, 0.04090577394952488, 0.03649176472185167, 0.04473937904672132, 0.04204795460469135, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07201866014379121, 0.07312745368438611, 0.074795246536286, 0.05790574334749221, 0.07592478158596383, 0.07986418371437887, 0.0784723629167946, 0.09066324034296847, 0.05804535780347764, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010597832625994341, 0.008760712107993673, 0.013212424048312243, 0.009920499786042813, 0.018544704870406492, 0.019930907027141287, 0.023376192745402258, 0.016868831136677698, 0.021325416891869065, 0.22832147495370558, 0.247763947795403, 0.2347914909114711, 0.24044083890851953, 0.2304681251792594, 0.24158331696762392, 0.2504172422414628, 0.2403277446601264, 0.25115629904579695, 0.061012716680247325, 0.06233151120152669, 0.062025132340548406, 0.05562600417711416, 0.062084856627478646, 0.06355870396280139, 0.08386033924345171, 0.07751348014977832, 0.06056265409322803, 0.14600253531233398, 0.12650586518018048, 0.1380564137500191, 0.1510022252599993, 0.18069227791743792, 0.13258489873268953, 0.14010249492340954, 0.14448033777963487, 0.14657931435166616, 0.17601390054453692, 0.1793388161732189, 0.1866089456681681, 0.18387861347847223, 0.18707720028840868, 0.1896951409407881, 0.18746348486204611, 0.19459996691418724, 0.1924690200540996, 0.12647606324474603, 0.1302584965173963, 0.13605161745431382, 0.12571043351511058, 0.13216694201599744, 0.12922886211694606, 0.13468994634347076, 0.13880541766330445, 0.12490913790176406, 0.1747546539688647, 0.1764902524847174, 0.17217803881716498, 0.16469819340440628, 0.16698638123656817, 0.1696843837029739, 0.16405367658503256, 0.2156528032837901, 0.18439158140500345, 0.16261065391050833, 0.16256438771413162, 0.14978248009171835, 0.16142945917405394, 0.16118416596076002, 0.15577956380486924, 0.16358578934764179, 0.16103483683837494, 0.16112510573492178, 0.16972820794210586, 0.16494436907496524, 0.15016027789326747, 0.17595156299608683, 0.16287933729077664, 0.22331475459792882, 0.170484512544392, 0.15693519796015265, 0.18743654988007563, 0.1509555298939711, 0.16511228713436465, 0.2160548383727423, 0.15528746582199493, 0.1556772020147833, 0.1632540402570718, 0.1652386055250441, 0.17060717266784742, 0.16247898929300975, 0.18739054427982338, 0.19423802848578875, 0.18223895355185993, 0.1890141390367548, 0.1837732044949546, 0.2112773042611017, 0.1728867485092389, 0.197955144448831, 0.17789128196850035, 0.06906105805261542, 0.06730668349429192, 0.06260782493416339, 0.08174464431109629, 0.06008415591016514, 0.06014437749237744, 0.0634939701312005, 0.07018186709267371, 0.06276488879167808]}, "mutation_prompt": null}
{"id": "77cdaa52-ea1f-4f56-b2e4-0152f0920865", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())  # Dynamic scaling for exploration and exploitation\n        self.population_size = int(self.budget / (6 * dim))  # Adjusted population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 3  \n        self.local_search_probability = 0.4  \n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1))  \n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _opposition_based_learning(self):\n        opposite_population = self.lower_bound + self.upper_bound - self.population\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.local_search_probability:\n                        improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Dynamic Differential Evolution with Opposition-Based Learning and Adaptive Crossover introduced for faster convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03aaa87b-cf86-4d03-b428-880d3132f117", "metadata": {"aucs": [0.22634800580454262, 0.24236618681980704, 0.2378504329072585, 0.22878960459200137, 0.24525244590417972, 0.22963161617278338, 0.21882381190605238, 0.23162355519808064, 0.23203859411942673, 0.0016135694211231177, 0.010002432972741393, 0.001974538391380176, 0.0027953574475108045, 9.999999999998899e-05, 0.0001879088157337172, 0.010002295965286234, 0.001406383294492608, 0.0002771922552837758, 0.07338267490805594, 0.07114034086470433, 0.06390780221304937, 0.06859450182169202, 0.07456938088632303, 0.06715922751736947, 0.07145176075777437, 0.06184890924560782, 0.07519994689773923, 0.05385356711124989, 0.05058915619676241, 0.05606131393969627, 0.05391729790225197, 0.05531281135899002, 0.05207376691084187, 0.05609324705517682, 0.053127249659466025, 0.08159681766610971, 0.4590750097494757, 0.49731541980314464, 0.3586189294474771, 0.3866718724920647, 0.4900579335044575, 0.8245237482027871, 0.5329165207071984, 0.5313374144606915, 0.537479077516154, 0.07389495326329398, 0.09732811949257503, 0.09498169881949092, 0.09428190033618544, 0.08052142859448963, 0.08913488726923646, 0.09988818156301404, 0.11952152253695936, 0.10077017468440408, 0.1369976342945478, 0.14869354588028705, 0.15152935520478272, 0.16286290560076377, 0.17175393448163467, 0.21211419453537916, 0.16347858950828797, 0.20264634198444986, 0.1640373095302179, 0.05960417935430162, 0.09041977101188114, 0.038714904617561885, 0.044205758340863044, 0.02817110927151456, 0.05136050637211387, 0.0563047133135548, 0.05045475937105581, 0.06459145902304098, 0.03421391812228558, 0.02416706651263134, 0.03546983026034667, 0.07628046260537524, 0.042634088677675375, 0.04090577394952488, 0.03649176472185167, 0.04473937904672132, 0.04204795460469135, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07201866014379121, 0.07312745368438611, 0.074795246536286, 0.05790574334749221, 0.07592478158596383, 0.07986418371437887, 0.0784723629167946, 0.09066324034296847, 0.05804535780347764, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010597832625994341, 0.008760712107993673, 0.013212424048312243, 0.009920499786042813, 0.018544704870406492, 0.019930907027141287, 0.023376192745402258, 0.016868831136677698, 0.021325416891869065, 0.22832147495370558, 0.247763947795403, 0.2347914909114711, 0.24044083890851953, 0.2304681251792594, 0.24158331696762392, 0.2504172422414628, 0.2403277446601264, 0.25115629904579695, 0.061012716680247325, 0.06233151120152669, 0.062025132340548406, 0.05562600417711416, 0.062084856627478646, 0.06355870396280139, 0.08386033924345171, 0.07751348014977832, 0.06056265409322803, 0.14600253531233398, 0.12650586518018048, 0.1380564137500191, 0.1510022252599993, 0.18069227791743792, 0.13258489873268953, 0.14010249492340954, 0.14448033777963487, 0.14657931435166616, 0.17601390054453692, 0.1793388161732189, 0.1866089456681681, 0.18387861347847223, 0.18707720028840868, 0.1896951409407881, 0.18746348486204611, 0.19459996691418724, 0.1924690200540996, 0.12647606324474603, 0.1302584965173963, 0.13605161745431382, 0.12571043351511058, 0.13216694201599744, 0.12922886211694606, 0.13468994634347076, 0.13880541766330445, 0.12490913790176406, 0.1747546539688647, 0.1764902524847174, 0.17217803881716498, 0.16469819340440628, 0.16698638123656817, 0.1696843837029739, 0.16405367658503256, 0.2156528032837901, 0.18439158140500345, 0.16261065391050833, 0.16256438771413162, 0.14978248009171835, 0.16142945917405394, 0.16118416596076002, 0.15577956380486924, 0.16358578934764179, 0.16103483683837494, 0.16112510573492178, 0.16972820794210586, 0.16494436907496524, 0.15016027789326747, 0.17595156299608683, 0.16287933729077664, 0.22331475459792882, 0.170484512544392, 0.15693519796015265, 0.18743654988007563, 0.1509555298939711, 0.16511228713436465, 0.2160548383727423, 0.15528746582199493, 0.1556772020147833, 0.1632540402570718, 0.1652386055250441, 0.17060717266784742, 0.16247898929300975, 0.18739054427982338, 0.19423802848578875, 0.18223895355185993, 0.1890141390367548, 0.1837732044949546, 0.2112773042611017, 0.1728867485092389, 0.197955144448831, 0.17789128196850035, 0.06906105805261542, 0.06730668349429192, 0.06260782493416339, 0.08174464431109629, 0.06008415591016514, 0.06014437749237744, 0.0634939701312005, 0.07018186709267371, 0.06276488879167808]}, "mutation_prompt": null}
{"id": "240628d6-f5ff-4984-94fe-dbb3638f6b17", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())  # Dynamic scaling for exploration and exploitation\n        self.population_size = int(self.budget / (6 * dim))  # Adjusted population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 3  \n        self.local_search_probability = 0.4  \n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1))  \n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _opposition_based_learning(self):\n        opposite_population = self.lower_bound + self.upper_bound - self.population\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.local_search_probability:\n                        improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Dynamic Differential Evolution with Opposition-Based Learning and Adaptive Crossover introduced for faster convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03aaa87b-cf86-4d03-b428-880d3132f117", "metadata": {"aucs": [0.22634800580454262, 0.24236618681980704, 0.2378504329072585, 0.22878960459200137, 0.24525244590417972, 0.22963161617278338, 0.21882381190605238, 0.23162355519808064, 0.23203859411942673, 0.0016135694211231177, 0.010002432972741393, 0.001974538391380176, 0.0027953574475108045, 9.999999999998899e-05, 0.0001879088157337172, 0.010002295965286234, 0.001406383294492608, 0.0002771922552837758, 0.07338267490805594, 0.07114034086470433, 0.06390780221304937, 0.06859450182169202, 0.07456938088632303, 0.06715922751736947, 0.07145176075777437, 0.06184890924560782, 0.07519994689773923, 0.05385356711124989, 0.05058915619676241, 0.05606131393969627, 0.05391729790225197, 0.05531281135899002, 0.05207376691084187, 0.05609324705517682, 0.053127249659466025, 0.08159681766610971, 0.4590750097494757, 0.49731541980314464, 0.3586189294474771, 0.3866718724920647, 0.4900579335044575, 0.8245237482027871, 0.5329165207071984, 0.5313374144606915, 0.537479077516154, 0.07389495326329398, 0.09732811949257503, 0.09498169881949092, 0.09428190033618544, 0.08052142859448963, 0.08913488726923646, 0.09988818156301404, 0.11952152253695936, 0.10077017468440408, 0.1369976342945478, 0.14869354588028705, 0.15152935520478272, 0.16286290560076377, 0.17175393448163467, 0.21211419453537916, 0.16347858950828797, 0.20264634198444986, 0.1640373095302179, 0.05960417935430162, 0.09041977101188114, 0.038714904617561885, 0.044205758340863044, 0.02817110927151456, 0.05136050637211387, 0.0563047133135548, 0.05045475937105581, 0.06459145902304098, 0.03421391812228558, 0.02416706651263134, 0.03546983026034667, 0.07628046260537524, 0.042634088677675375, 0.04090577394952488, 0.03649176472185167, 0.04473937904672132, 0.04204795460469135, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07201866014379121, 0.07312745368438611, 0.074795246536286, 0.05790574334749221, 0.07592478158596383, 0.07986418371437887, 0.0784723629167946, 0.09066324034296847, 0.05804535780347764, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010597832625994341, 0.008760712107993673, 0.013212424048312243, 0.009920499786042813, 0.018544704870406492, 0.019930907027141287, 0.023376192745402258, 0.016868831136677698, 0.021325416891869065, 0.22832147495370558, 0.247763947795403, 0.2347914909114711, 0.24044083890851953, 0.2304681251792594, 0.24158331696762392, 0.2504172422414628, 0.2403277446601264, 0.25115629904579695, 0.061012716680247325, 0.06233151120152669, 0.062025132340548406, 0.05562600417711416, 0.062084856627478646, 0.06355870396280139, 0.08386033924345171, 0.07751348014977832, 0.06056265409322803, 0.14600253531233398, 0.12650586518018048, 0.1380564137500191, 0.1510022252599993, 0.18069227791743792, 0.13258489873268953, 0.14010249492340954, 0.14448033777963487, 0.14657931435166616, 0.17601390054453692, 0.1793388161732189, 0.1866089456681681, 0.18387861347847223, 0.18707720028840868, 0.1896951409407881, 0.18746348486204611, 0.19459996691418724, 0.1924690200540996, 0.12647606324474603, 0.1302584965173963, 0.13605161745431382, 0.12571043351511058, 0.13216694201599744, 0.12922886211694606, 0.13468994634347076, 0.13880541766330445, 0.12490913790176406, 0.1747546539688647, 0.1764902524847174, 0.17217803881716498, 0.16469819340440628, 0.16698638123656817, 0.1696843837029739, 0.16405367658503256, 0.2156528032837901, 0.18439158140500345, 0.16261065391050833, 0.16256438771413162, 0.14978248009171835, 0.16142945917405394, 0.16118416596076002, 0.15577956380486924, 0.16358578934764179, 0.16103483683837494, 0.16112510573492178, 0.16972820794210586, 0.16494436907496524, 0.15016027789326747, 0.17595156299608683, 0.16287933729077664, 0.22331475459792882, 0.170484512544392, 0.15693519796015265, 0.18743654988007563, 0.1509555298939711, 0.16511228713436465, 0.2160548383727423, 0.15528746582199493, 0.1556772020147833, 0.1632540402570718, 0.1652386055250441, 0.17060717266784742, 0.16247898929300975, 0.18739054427982338, 0.19423802848578875, 0.18223895355185993, 0.1890141390367548, 0.1837732044949546, 0.2112773042611017, 0.1728867485092389, 0.197955144448831, 0.17789128196850035, 0.06906105805261542, 0.06730668349429192, 0.06260782493416339, 0.08174464431109629, 0.06008415591016514, 0.06014437749237744, 0.0634939701312005, 0.07018186709267371, 0.06276488879167808]}, "mutation_prompt": null}
{"id": "2ad3c4f4-bcbb-43fc-95e9-7677e9ca92eb", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())  # Dynamic scaling for exploration and exploitation\n        self.population_size = int(self.budget / (6 * dim))  # Adjusted population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 3  \n        self.local_search_probability = 0.4  \n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1))  \n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _opposition_based_learning(self):\n        opposite_population = self.lower_bound + self.upper_bound - self.population\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.local_search_probability:\n                        improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Dynamic Differential Evolution with Opposition-Based Learning and Adaptive Crossover introduced for faster convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03aaa87b-cf86-4d03-b428-880d3132f117", "metadata": {"aucs": [0.22634800580454262, 0.24236618681980704, 0.2378504329072585, 0.22878960459200137, 0.24525244590417972, 0.22963161617278338, 0.21882381190605238, 0.23162355519808064, 0.23203859411942673, 0.0016135694211231177, 0.010002432972741393, 0.001974538391380176, 0.0027953574475108045, 9.999999999998899e-05, 0.0001879088157337172, 0.010002295965286234, 0.001406383294492608, 0.0002771922552837758, 0.07338267490805594, 0.07114034086470433, 0.06390780221304937, 0.06859450182169202, 0.07456938088632303, 0.06715922751736947, 0.07145176075777437, 0.06184890924560782, 0.07519994689773923, 0.05385356711124989, 0.05058915619676241, 0.05606131393969627, 0.05391729790225197, 0.05531281135899002, 0.05207376691084187, 0.05609324705517682, 0.053127249659466025, 0.08159681766610971, 0.4590750097494757, 0.49731541980314464, 0.3586189294474771, 0.3866718724920647, 0.4900579335044575, 0.8245237482027871, 0.5329165207071984, 0.5313374144606915, 0.537479077516154, 0.07389495326329398, 0.09732811949257503, 0.09498169881949092, 0.09428190033618544, 0.08052142859448963, 0.08913488726923646, 0.09988818156301404, 0.11952152253695936, 0.10077017468440408, 0.1369976342945478, 0.14869354588028705, 0.15152935520478272, 0.16286290560076377, 0.17175393448163467, 0.21211419453537916, 0.16347858950828797, 0.20264634198444986, 0.1640373095302179, 0.05960417935430162, 0.09041977101188114, 0.038714904617561885, 0.044205758340863044, 0.02817110927151456, 0.05136050637211387, 0.0563047133135548, 0.05045475937105581, 0.06459145902304098, 0.03421391812228558, 0.02416706651263134, 0.03546983026034667, 0.07628046260537524, 0.042634088677675375, 0.04090577394952488, 0.03649176472185167, 0.04473937904672132, 0.04204795460469135, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07201866014379121, 0.07312745368438611, 0.074795246536286, 0.05790574334749221, 0.07592478158596383, 0.07986418371437887, 0.0784723629167946, 0.09066324034296847, 0.05804535780347764, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010597832625994341, 0.008760712107993673, 0.013212424048312243, 0.009920499786042813, 0.018544704870406492, 0.019930907027141287, 0.023376192745402258, 0.016868831136677698, 0.021325416891869065, 0.22832147495370558, 0.247763947795403, 0.2347914909114711, 0.24044083890851953, 0.2304681251792594, 0.24158331696762392, 0.2504172422414628, 0.2403277446601264, 0.25115629904579695, 0.061012716680247325, 0.06233151120152669, 0.062025132340548406, 0.05562600417711416, 0.062084856627478646, 0.06355870396280139, 0.08386033924345171, 0.07751348014977832, 0.06056265409322803, 0.14600253531233398, 0.12650586518018048, 0.1380564137500191, 0.1510022252599993, 0.18069227791743792, 0.13258489873268953, 0.14010249492340954, 0.14448033777963487, 0.14657931435166616, 0.17601390054453692, 0.1793388161732189, 0.1866089456681681, 0.18387861347847223, 0.18707720028840868, 0.1896951409407881, 0.18746348486204611, 0.19459996691418724, 0.1924690200540996, 0.12647606324474603, 0.1302584965173963, 0.13605161745431382, 0.12571043351511058, 0.13216694201599744, 0.12922886211694606, 0.13468994634347076, 0.13880541766330445, 0.12490913790176406, 0.1747546539688647, 0.1764902524847174, 0.17217803881716498, 0.16469819340440628, 0.16698638123656817, 0.1696843837029739, 0.16405367658503256, 0.2156528032837901, 0.18439158140500345, 0.16261065391050833, 0.16256438771413162, 0.14978248009171835, 0.16142945917405394, 0.16118416596076002, 0.15577956380486924, 0.16358578934764179, 0.16103483683837494, 0.16112510573492178, 0.16972820794210586, 0.16494436907496524, 0.15016027789326747, 0.17595156299608683, 0.16287933729077664, 0.22331475459792882, 0.170484512544392, 0.15693519796015265, 0.18743654988007563, 0.1509555298939711, 0.16511228713436465, 0.2160548383727423, 0.15528746582199493, 0.1556772020147833, 0.1632540402570718, 0.1652386055250441, 0.17060717266784742, 0.16247898929300975, 0.18739054427982338, 0.19423802848578875, 0.18223895355185993, 0.1890141390367548, 0.1837732044949546, 0.2112773042611017, 0.1728867485092389, 0.197955144448831, 0.17789128196850035, 0.06906105805261542, 0.06730668349429192, 0.06260782493416339, 0.08174464431109629, 0.06008415591016514, 0.06014437749237744, 0.0634939701312005, 0.07018186709267371, 0.06276488879167808]}, "mutation_prompt": null}
{"id": "2d8498a5-e566-451a-a580-46902178939b", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())  # Dynamic scaling for exploration and exploitation\n        self.population_size = int(self.budget / (6 * dim))  # Adjusted population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 3  \n        self.local_search_probability = 0.4  \n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1))  \n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _opposition_based_learning(self):\n        opposite_population = self.lower_bound + self.upper_bound - self.population\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.local_search_probability:\n                        improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Dynamic Differential Evolution with Opposition-Based Learning and Adaptive Crossover introduced for faster convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03aaa87b-cf86-4d03-b428-880d3132f117", "metadata": {"aucs": [0.22634800580454262, 0.24236618681980704, 0.2378504329072585, 0.22878960459200137, 0.24525244590417972, 0.22963161617278338, 0.21882381190605238, 0.23162355519808064, 0.23203859411942673, 0.0016135694211231177, 0.010002432972741393, 0.001974538391380176, 0.0027953574475108045, 9.999999999998899e-05, 0.0001879088157337172, 0.010002295965286234, 0.001406383294492608, 0.0002771922552837758, 0.07338267490805594, 0.07114034086470433, 0.06390780221304937, 0.06859450182169202, 0.07456938088632303, 0.06715922751736947, 0.07145176075777437, 0.06184890924560782, 0.07519994689773923, 0.05385356711124989, 0.05058915619676241, 0.05606131393969627, 0.05391729790225197, 0.05531281135899002, 0.05207376691084187, 0.05609324705517682, 0.053127249659466025, 0.08159681766610971, 0.4590750097494757, 0.49731541980314464, 0.3586189294474771, 0.3866718724920647, 0.4900579335044575, 0.8245237482027871, 0.5329165207071984, 0.5313374144606915, 0.537479077516154, 0.07389495326329398, 0.09732811949257503, 0.09498169881949092, 0.09428190033618544, 0.08052142859448963, 0.08913488726923646, 0.09988818156301404, 0.11952152253695936, 0.10077017468440408, 0.1369976342945478, 0.14869354588028705, 0.15152935520478272, 0.16286290560076377, 0.17175393448163467, 0.21211419453537916, 0.16347858950828797, 0.20264634198444986, 0.1640373095302179, 0.05960417935430162, 0.09041977101188114, 0.038714904617561885, 0.044205758340863044, 0.02817110927151456, 0.05136050637211387, 0.0563047133135548, 0.05045475937105581, 0.06459145902304098, 0.03421391812228558, 0.02416706651263134, 0.03546983026034667, 0.07628046260537524, 0.042634088677675375, 0.04090577394952488, 0.03649176472185167, 0.04473937904672132, 0.04204795460469135, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07201866014379121, 0.07312745368438611, 0.074795246536286, 0.05790574334749221, 0.07592478158596383, 0.07986418371437887, 0.0784723629167946, 0.09066324034296847, 0.05804535780347764, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010597832625994341, 0.008760712107993673, 0.013212424048312243, 0.009920499786042813, 0.018544704870406492, 0.019930907027141287, 0.023376192745402258, 0.016868831136677698, 0.021325416891869065, 0.22832147495370558, 0.247763947795403, 0.2347914909114711, 0.24044083890851953, 0.2304681251792594, 0.24158331696762392, 0.2504172422414628, 0.2403277446601264, 0.25115629904579695, 0.061012716680247325, 0.06233151120152669, 0.062025132340548406, 0.05562600417711416, 0.062084856627478646, 0.06355870396280139, 0.08386033924345171, 0.07751348014977832, 0.06056265409322803, 0.14600253531233398, 0.12650586518018048, 0.1380564137500191, 0.1510022252599993, 0.18069227791743792, 0.13258489873268953, 0.14010249492340954, 0.14448033777963487, 0.14657931435166616, 0.17601390054453692, 0.1793388161732189, 0.1866089456681681, 0.18387861347847223, 0.18707720028840868, 0.1896951409407881, 0.18746348486204611, 0.19459996691418724, 0.1924690200540996, 0.12647606324474603, 0.1302584965173963, 0.13605161745431382, 0.12571043351511058, 0.13216694201599744, 0.12922886211694606, 0.13468994634347076, 0.13880541766330445, 0.12490913790176406, 0.1747546539688647, 0.1764902524847174, 0.17217803881716498, 0.16469819340440628, 0.16698638123656817, 0.1696843837029739, 0.16405367658503256, 0.2156528032837901, 0.18439158140500345, 0.16261065391050833, 0.16256438771413162, 0.14978248009171835, 0.16142945917405394, 0.16118416596076002, 0.15577956380486924, 0.16358578934764179, 0.16103483683837494, 0.16112510573492178, 0.16972820794210586, 0.16494436907496524, 0.15016027789326747, 0.17595156299608683, 0.16287933729077664, 0.22331475459792882, 0.170484512544392, 0.15693519796015265, 0.18743654988007563, 0.1509555298939711, 0.16511228713436465, 0.2160548383727423, 0.15528746582199493, 0.1556772020147833, 0.1632540402570718, 0.1652386055250441, 0.17060717266784742, 0.16247898929300975, 0.18739054427982338, 0.19423802848578875, 0.18223895355185993, 0.1890141390367548, 0.1837732044949546, 0.2112773042611017, 0.1728867485092389, 0.197955144448831, 0.17789128196850035, 0.06906105805261542, 0.06730668349429192, 0.06260782493416339, 0.08174464431109629, 0.06008415591016514, 0.06014437749237744, 0.0634939701312005, 0.07018186709267371, 0.06276488879167808]}, "mutation_prompt": null}
{"id": "bbe4e27a-12a1-465b-bd29-493671e493b5", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())  # Dynamic scaling for exploration and exploitation\n        self.population_size = int(self.budget / (6 * dim))  # Adjusted population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 3  \n        self.local_search_probability = 0.4  \n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1))  \n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _opposition_based_learning(self):\n        opposite_population = self.lower_bound + self.upper_bound - self.population\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.local_search_probability:\n                        improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Dynamic Differential Evolution with Opposition-Based Learning and Adaptive Crossover introduced for faster convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03aaa87b-cf86-4d03-b428-880d3132f117", "metadata": {"aucs": [0.22634800580454262, 0.24236618681980704, 0.2378504329072585, 0.22878960459200137, 0.24525244590417972, 0.22963161617278338, 0.21882381190605238, 0.23162355519808064, 0.23203859411942673, 0.0016135694211231177, 0.010002432972741393, 0.001974538391380176, 0.0027953574475108045, 9.999999999998899e-05, 0.0001879088157337172, 0.010002295965286234, 0.001406383294492608, 0.0002771922552837758, 0.07338267490805594, 0.07114034086470433, 0.06390780221304937, 0.06859450182169202, 0.07456938088632303, 0.06715922751736947, 0.07145176075777437, 0.06184890924560782, 0.07519994689773923, 0.05385356711124989, 0.05058915619676241, 0.05606131393969627, 0.05391729790225197, 0.05531281135899002, 0.05207376691084187, 0.05609324705517682, 0.053127249659466025, 0.08159681766610971, 0.4590750097494757, 0.49731541980314464, 0.3586189294474771, 0.3866718724920647, 0.4900579335044575, 0.8245237482027871, 0.5329165207071984, 0.5313374144606915, 0.537479077516154, 0.07389495326329398, 0.09732811949257503, 0.09498169881949092, 0.09428190033618544, 0.08052142859448963, 0.08913488726923646, 0.09988818156301404, 0.11952152253695936, 0.10077017468440408, 0.1369976342945478, 0.14869354588028705, 0.15152935520478272, 0.16286290560076377, 0.17175393448163467, 0.21211419453537916, 0.16347858950828797, 0.20264634198444986, 0.1640373095302179, 0.05960417935430162, 0.09041977101188114, 0.038714904617561885, 0.044205758340863044, 0.02817110927151456, 0.05136050637211387, 0.0563047133135548, 0.05045475937105581, 0.06459145902304098, 0.03421391812228558, 0.02416706651263134, 0.03546983026034667, 0.07628046260537524, 0.042634088677675375, 0.04090577394952488, 0.03649176472185167, 0.04473937904672132, 0.04204795460469135, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07201866014379121, 0.07312745368438611, 0.074795246536286, 0.05790574334749221, 0.07592478158596383, 0.07986418371437887, 0.0784723629167946, 0.09066324034296847, 0.05804535780347764, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010597832625994341, 0.008760712107993673, 0.013212424048312243, 0.009920499786042813, 0.018544704870406492, 0.019930907027141287, 0.023376192745402258, 0.016868831136677698, 0.021325416891869065, 0.22832147495370558, 0.247763947795403, 0.2347914909114711, 0.24044083890851953, 0.2304681251792594, 0.24158331696762392, 0.2504172422414628, 0.2403277446601264, 0.25115629904579695, 0.061012716680247325, 0.06233151120152669, 0.062025132340548406, 0.05562600417711416, 0.062084856627478646, 0.06355870396280139, 0.08386033924345171, 0.07751348014977832, 0.06056265409322803, 0.14600253531233398, 0.12650586518018048, 0.1380564137500191, 0.1510022252599993, 0.18069227791743792, 0.13258489873268953, 0.14010249492340954, 0.14448033777963487, 0.14657931435166616, 0.17601390054453692, 0.1793388161732189, 0.1866089456681681, 0.18387861347847223, 0.18707720028840868, 0.1896951409407881, 0.18746348486204611, 0.19459996691418724, 0.1924690200540996, 0.12647606324474603, 0.1302584965173963, 0.13605161745431382, 0.12571043351511058, 0.13216694201599744, 0.12922886211694606, 0.13468994634347076, 0.13880541766330445, 0.12490913790176406, 0.1747546539688647, 0.1764902524847174, 0.17217803881716498, 0.16469819340440628, 0.16698638123656817, 0.1696843837029739, 0.16405367658503256, 0.2156528032837901, 0.18439158140500345, 0.16261065391050833, 0.16256438771413162, 0.14978248009171835, 0.16142945917405394, 0.16118416596076002, 0.15577956380486924, 0.16358578934764179, 0.16103483683837494, 0.16112510573492178, 0.16972820794210586, 0.16494436907496524, 0.15016027789326747, 0.17595156299608683, 0.16287933729077664, 0.22331475459792882, 0.170484512544392, 0.15693519796015265, 0.18743654988007563, 0.1509555298939711, 0.16511228713436465, 0.2160548383727423, 0.15528746582199493, 0.1556772020147833, 0.1632540402570718, 0.1652386055250441, 0.17060717266784742, 0.16247898929300975, 0.18739054427982338, 0.19423802848578875, 0.18223895355185993, 0.1890141390367548, 0.1837732044949546, 0.2112773042611017, 0.1728867485092389, 0.197955144448831, 0.17789128196850035, 0.06906105805261542, 0.06730668349429192, 0.06260782493416339, 0.08174464431109629, 0.06008415591016514, 0.06014437749237744, 0.0634939701312005, 0.07018186709267371, 0.06276488879167808]}, "mutation_prompt": null}
{"id": "302fe93c-2960-4785-950d-d530c333ad5f", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())  # Dynamic scaling for exploration and exploitation\n        self.population_size = int(self.budget / (6 * dim))  # Adjusted population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.max_local_search_iterations = 3  \n        self.local_search_probability = 0.4  \n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1))  \n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _opposition_based_learning(self):\n        opposite_population = self.lower_bound + self.upper_bound - self.population\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.local_search_probability:\n                        improved_solution = self._stochastic_local_search(trial, func, self.max_local_search_iterations)\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Dynamic Differential Evolution with Opposition-Based Learning and Adaptive Crossover introduced for faster convergence.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03aaa87b-cf86-4d03-b428-880d3132f117", "metadata": {"aucs": [0.22634800580454262, 0.24236618681980704, 0.2378504329072585, 0.22878960459200137, 0.24525244590417972, 0.22963161617278338, 0.21882381190605238, 0.23162355519808064, 0.23203859411942673, 0.0016135694211231177, 0.010002432972741393, 0.001974538391380176, 0.0027953574475108045, 9.999999999998899e-05, 0.0001879088157337172, 0.010002295965286234, 0.001406383294492608, 0.0002771922552837758, 0.07338267490805594, 0.07114034086470433, 0.06390780221304937, 0.06859450182169202, 0.07456938088632303, 0.06715922751736947, 0.07145176075777437, 0.06184890924560782, 0.07519994689773923, 0.05385356711124989, 0.05058915619676241, 0.05606131393969627, 0.05391729790225197, 0.05531281135899002, 0.05207376691084187, 0.05609324705517682, 0.053127249659466025, 0.08159681766610971, 0.4590750097494757, 0.49731541980314464, 0.3586189294474771, 0.3866718724920647, 0.4900579335044575, 0.8245237482027871, 0.5329165207071984, 0.5313374144606915, 0.537479077516154, 0.07389495326329398, 0.09732811949257503, 0.09498169881949092, 0.09428190033618544, 0.08052142859448963, 0.08913488726923646, 0.09988818156301404, 0.11952152253695936, 0.10077017468440408, 0.1369976342945478, 0.14869354588028705, 0.15152935520478272, 0.16286290560076377, 0.17175393448163467, 0.21211419453537916, 0.16347858950828797, 0.20264634198444986, 0.1640373095302179, 0.05960417935430162, 0.09041977101188114, 0.038714904617561885, 0.044205758340863044, 0.02817110927151456, 0.05136050637211387, 0.0563047133135548, 0.05045475937105581, 0.06459145902304098, 0.03421391812228558, 0.02416706651263134, 0.03546983026034667, 0.07628046260537524, 0.042634088677675375, 0.04090577394952488, 0.03649176472185167, 0.04473937904672132, 0.04204795460469135, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07201866014379121, 0.07312745368438611, 0.074795246536286, 0.05790574334749221, 0.07592478158596383, 0.07986418371437887, 0.0784723629167946, 0.09066324034296847, 0.05804535780347764, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010597832625994341, 0.008760712107993673, 0.013212424048312243, 0.009920499786042813, 0.018544704870406492, 0.019930907027141287, 0.023376192745402258, 0.016868831136677698, 0.021325416891869065, 0.22832147495370558, 0.247763947795403, 0.2347914909114711, 0.24044083890851953, 0.2304681251792594, 0.24158331696762392, 0.2504172422414628, 0.2403277446601264, 0.25115629904579695, 0.061012716680247325, 0.06233151120152669, 0.062025132340548406, 0.05562600417711416, 0.062084856627478646, 0.06355870396280139, 0.08386033924345171, 0.07751348014977832, 0.06056265409322803, 0.14600253531233398, 0.12650586518018048, 0.1380564137500191, 0.1510022252599993, 0.18069227791743792, 0.13258489873268953, 0.14010249492340954, 0.14448033777963487, 0.14657931435166616, 0.17601390054453692, 0.1793388161732189, 0.1866089456681681, 0.18387861347847223, 0.18707720028840868, 0.1896951409407881, 0.18746348486204611, 0.19459996691418724, 0.1924690200540996, 0.12647606324474603, 0.1302584965173963, 0.13605161745431382, 0.12571043351511058, 0.13216694201599744, 0.12922886211694606, 0.13468994634347076, 0.13880541766330445, 0.12490913790176406, 0.1747546539688647, 0.1764902524847174, 0.17217803881716498, 0.16469819340440628, 0.16698638123656817, 0.1696843837029739, 0.16405367658503256, 0.2156528032837901, 0.18439158140500345, 0.16261065391050833, 0.16256438771413162, 0.14978248009171835, 0.16142945917405394, 0.16118416596076002, 0.15577956380486924, 0.16358578934764179, 0.16103483683837494, 0.16112510573492178, 0.16972820794210586, 0.16494436907496524, 0.15016027789326747, 0.17595156299608683, 0.16287933729077664, 0.22331475459792882, 0.170484512544392, 0.15693519796015265, 0.18743654988007563, 0.1509555298939711, 0.16511228713436465, 0.2160548383727423, 0.15528746582199493, 0.1556772020147833, 0.1632540402570718, 0.1652386055250441, 0.17060717266784742, 0.16247898929300975, 0.18739054427982338, 0.19423802848578875, 0.18223895355185993, 0.1890141390367548, 0.1837732044949546, 0.2112773042611017, 0.1728867485092389, 0.197955144448831, 0.17789128196850035, 0.06906105805261542, 0.06730668349429192, 0.06260782493416339, 0.08174464431109629, 0.06008415591016514, 0.06014437749237744, 0.0634939701312005, 0.07018186709267371, 0.06276488879167808]}, "mutation_prompt": null}
{"id": "520ef615-ed8c-479a-b24c-54270ff2f0c3", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(2, 5, self.population_size)\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _opposition_based_learning(self):\n        opposite_population = self.lower_bound + self.upper_bound - self.population\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.dynamic_mutation_factor[i]:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing a dynamic learning rate for mutation and localized exploration for better convergence speed.", "configspace": "", "generation": 57, "fitness": 0.14250342941462316, "feedback": "The algorithm EnhancedDynamicDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.09.", "error": "", "parent_id": "03aaa87b-cf86-4d03-b428-880d3132f117", "metadata": {"aucs": [0.2751169268572792, 0.27103077747949345, 0.29824105550787194, 0.28554659414408723, 0.3098631007475774, 0.28118300348646585, 0.30171614719440754, 0.30672458794148416, 0.30618394019412976, 0.026623864795076613, 0.05900027897464022, 0.030165426391061345, 0.03219288795675024, 0.02140554389542193, 0.008261824130967765, 0.04204926184679769, 0.03518130925795704, 0.018251289050715824, 0.11130400584706279, 0.09754971852867766, 0.09327900552274082, 0.09741592858514048, 0.10336883424357912, 0.09639475470840375, 0.10140255083128491, 0.11300883429586117, 0.11247067955346834, 0.08155369563008918, 0.08347240661616939, 0.08299986336536791, 0.08752601083589584, 0.0798444736242866, 0.07802450295474905, 0.08058635818869297, 0.09966261244712282, 0.08583115573967537, 0.41095875307213015, 0.23127215736205486, 0.3195321466817449, 0.3608047905873982, 0.29270335378412493, 0.39322975127985127, 0.40055851115394026, 0.24606315633901155, 0.43594368147888485, 0.11048238791257814, 0.1260058391872484, 0.10279338262052329, 0.09958112836617916, 0.10429168777634679, 0.10862916812851742, 0.11354618250653581, 0.13502749607690312, 0.10236020005603408, 0.16617509205460046, 0.17475136222252752, 0.17502032762784114, 0.21605083968026562, 0.2081647364112198, 0.20062762571885517, 0.21738095043512917, 0.2257722029531114, 0.2113634444378193, 0.0730908984332247, 0.10751444800226795, 0.0686359853088574, 0.06501245161940128, 0.07671772024971502, 0.06753589300928453, 0.08055569499518678, 0.09038729043751104, 0.07026227810680508, 0.07136035977563404, 0.07426093018747781, 0.07697549538694415, 0.08269087685739163, 0.07844359000272139, 0.09014735296682941, 0.06890160933902156, 0.07996495954102067, 0.08124509416757864, 9.999999999998899e-05, 0.0003716637754201946, 9.999999999998899e-05, 9.999999999998899e-05, 0.0018817491042857348, 0.0008841024985893897, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07991582453859336, 0.09295212501000039, 0.08050838680171524, 0.10584549317683833, 0.095645630237436, 0.09823933994479195, 0.11620834742229325, 0.09795355505720404, 0.09656731008982955, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0421040529424066, 0.034621398013112814, 0.034142539663067906, 0.03498691488629613, 0.037810677711639595, 0.0323036397137374, 0.041939500809653696, 0.03717549303107148, 0.04327961369624078, 0.29368344940874436, 0.3064495173337951, 0.2846593529181677, 0.2606707313909459, 0.26459302373961324, 0.30280424162141895, 0.26200952999397575, 0.2829078533089818, 0.2954574499959134, 0.07614223207705306, 0.08352081502582132, 0.07495588052580804, 0.07925896508626085, 0.0801374776470386, 0.06481280203142648, 0.07655131723431119, 0.0872568487760833, 0.07804387694488468, 0.17847395495272522, 0.15821989793386126, 0.16551102446499355, 0.15788591033327815, 0.1356696814760302, 0.15697880772924222, 0.1380266800237463, 0.17419181554778718, 0.14940890855287603, 0.2170578371476558, 0.2030221555846461, 0.21727828065611188, 0.21004849104534495, 0.2063375000571126, 0.20602528405125975, 0.21383369759461135, 0.21369981228052837, 0.2134181546392111, 0.15755537267387987, 0.15258999352507885, 0.17738636803452468, 0.1692057311795352, 0.14592935631215753, 0.15196800261252352, 0.16147104842220394, 0.15674350511121649, 0.15721454370165178, 0.17758182387266408, 0.1860889590430248, 0.18481427357775482, 0.19268340344604018, 0.1939576436876358, 0.2004145959202347, 0.1834872658792568, 0.1899234718397914, 0.24067516507431297, 0.19748178273013883, 0.18470453384574526, 0.16942753452945103, 0.17403734738380894, 0.18957111173393038, 0.1698111784763945, 0.19089110422647182, 0.1826351402117602, 0.16855254942977882, 0.16572477579017997, 0.2775416858381762, 0.23984161868431508, 0.24683335957000996, 0.2381222864869863, 0.2671014227539359, 0.2419978525974762, 0.22505334309757374, 0.24642870632258607, 0.28362611365536305, 0.20569216521427458, 0.18142133070374467, 0.17479673081493474, 0.18124592359678482, 0.17949166722277443, 0.17949625044930018, 0.22985879399910347, 0.24584106638370162, 0.19458989557478934, 0.1898769620923202, 0.17251026870910013, 0.19021738760468554, 0.18074432575341548, 0.17199143479675527, 0.18948448510292637, 0.18728033965289492, 0.1822301047220698, 0.07692289575707034, 0.07040152742972261, 0.070858376054454, 0.06580042607649228, 0.07677984115219638, 0.07082927056672816, 0.07022040600135537, 0.07051215005423161, 0.06950564387101477]}, "mutation_prompt": null}
{"id": "0ffcb938-1abb-47fc-821a-84b5d8a62667", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(2, 5, self.population_size)\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _opposition_based_learning(self):\n        opposite_population = self.lower_bound + self.upper_bound - self.population\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.dynamic_mutation_factor[i]:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing a dynamic learning rate for mutation and localized exploration for better convergence speed.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "520ef615-ed8c-479a-b24c-54270ff2f0c3", "metadata": {"aucs": [0.2751169268572792, 0.27103077747949345, 0.29824105550787194, 0.28554659414408723, 0.3098631007475774, 0.28118300348646585, 0.30171614719440754, 0.30672458794148416, 0.30618394019412976, 0.026623864795076613, 0.05900027897464022, 0.030165426391061345, 0.03219288795675024, 0.02140554389542193, 0.008261824130967765, 0.04204926184679769, 0.03518130925795704, 0.018251289050715824, 0.11130400584706279, 0.09754971852867766, 0.09327900552274082, 0.09741592858514048, 0.10336883424357912, 0.09639475470840375, 0.10140255083128491, 0.11300883429586117, 0.11247067955346834, 0.08155369563008918, 0.08347240661616939, 0.08299986336536791, 0.08752601083589584, 0.0798444736242866, 0.07802450295474905, 0.08058635818869297, 0.09966261244712282, 0.08583115573967537, 0.41095875307213015, 0.23127215736205486, 0.3195321466817449, 0.3608047905873982, 0.29270335378412493, 0.39322975127985127, 0.40055851115394026, 0.24606315633901155, 0.43594368147888485, 0.11048238791257814, 0.1260058391872484, 0.10279338262052329, 0.09958112836617916, 0.10429168777634679, 0.10862916812851742, 0.11354618250653581, 0.13502749607690312, 0.10236020005603408, 0.16617509205460046, 0.17475136222252752, 0.17502032762784114, 0.21605083968026562, 0.2081647364112198, 0.20062762571885517, 0.21738095043512917, 0.2257722029531114, 0.2113634444378193, 0.0730908984332247, 0.10751444800226795, 0.0686359853088574, 0.06501245161940128, 0.07671772024971502, 0.06753589300928453, 0.08055569499518678, 0.09038729043751104, 0.07026227810680508, 0.07136035977563404, 0.07426093018747781, 0.07697549538694415, 0.08269087685739163, 0.07844359000272139, 0.09014735296682941, 0.06890160933902156, 0.07996495954102067, 0.08124509416757864, 9.999999999998899e-05, 0.0003716637754201946, 9.999999999998899e-05, 9.999999999998899e-05, 0.0018817491042857348, 0.0008841024985893897, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07991582453859336, 0.09295212501000039, 0.08050838680171524, 0.10584549317683833, 0.095645630237436, 0.09823933994479195, 0.11620834742229325, 0.09795355505720404, 0.09656731008982955, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0421040529424066, 0.034621398013112814, 0.034142539663067906, 0.03498691488629613, 0.037810677711639595, 0.0323036397137374, 0.041939500809653696, 0.03717549303107148, 0.04327961369624078, 0.29368344940874436, 0.3064495173337951, 0.2846593529181677, 0.2606707313909459, 0.26459302373961324, 0.30280424162141895, 0.26200952999397575, 0.2829078533089818, 0.2954574499959134, 0.07614223207705306, 0.08352081502582132, 0.07495588052580804, 0.07925896508626085, 0.0801374776470386, 0.06481280203142648, 0.07655131723431119, 0.0872568487760833, 0.07804387694488468, 0.17847395495272522, 0.15821989793386126, 0.16551102446499355, 0.15788591033327815, 0.1356696814760302, 0.15697880772924222, 0.1380266800237463, 0.17419181554778718, 0.14940890855287603, 0.2170578371476558, 0.2030221555846461, 0.21727828065611188, 0.21004849104534495, 0.2063375000571126, 0.20602528405125975, 0.21383369759461135, 0.21369981228052837, 0.2134181546392111, 0.15755537267387987, 0.15258999352507885, 0.17738636803452468, 0.1692057311795352, 0.14592935631215753, 0.15196800261252352, 0.16147104842220394, 0.15674350511121649, 0.15721454370165178, 0.17758182387266408, 0.1860889590430248, 0.18481427357775482, 0.19268340344604018, 0.1939576436876358, 0.2004145959202347, 0.1834872658792568, 0.1899234718397914, 0.24067516507431297, 0.19748178273013883, 0.18470453384574526, 0.16942753452945103, 0.17403734738380894, 0.18957111173393038, 0.1698111784763945, 0.19089110422647182, 0.1826351402117602, 0.16855254942977882, 0.16572477579017997, 0.2775416858381762, 0.23984161868431508, 0.24683335957000996, 0.2381222864869863, 0.2671014227539359, 0.2419978525974762, 0.22505334309757374, 0.24642870632258607, 0.28362611365536305, 0.20569216521427458, 0.18142133070374467, 0.17479673081493474, 0.18124592359678482, 0.17949166722277443, 0.17949625044930018, 0.22985879399910347, 0.24584106638370162, 0.19458989557478934, 0.1898769620923202, 0.17251026870910013, 0.19021738760468554, 0.18074432575341548, 0.17199143479675527, 0.18948448510292637, 0.18728033965289492, 0.1822301047220698, 0.07692289575707034, 0.07040152742972261, 0.070858376054454, 0.06580042607649228, 0.07677984115219638, 0.07082927056672816, 0.07022040600135537, 0.07051215005423161, 0.06950564387101477]}, "mutation_prompt": null}
{"id": "9c67b447-41ca-4b25-85b2-d67aa931e772", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_crossover_rate = 0.9\n        self.mutation_factor = 0.8\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(2, 5, self.population_size)\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _opposition_based_learning(self):\n        opposite_population = self.lower_bound + self.upper_bound - self.population\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.dynamic_mutation_factor[i]:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing a dynamic learning rate for mutation and localized exploration for better convergence speed.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "520ef615-ed8c-479a-b24c-54270ff2f0c3", "metadata": {"aucs": [0.2751169268572792, 0.27103077747949345, 0.29824105550787194, 0.28554659414408723, 0.3098631007475774, 0.28118300348646585, 0.30171614719440754, 0.30672458794148416, 0.30618394019412976, 0.026623864795076613, 0.05900027897464022, 0.030165426391061345, 0.03219288795675024, 0.02140554389542193, 0.008261824130967765, 0.04204926184679769, 0.03518130925795704, 0.018251289050715824, 0.11130400584706279, 0.09754971852867766, 0.09327900552274082, 0.09741592858514048, 0.10336883424357912, 0.09639475470840375, 0.10140255083128491, 0.11300883429586117, 0.11247067955346834, 0.08155369563008918, 0.08347240661616939, 0.08299986336536791, 0.08752601083589584, 0.0798444736242866, 0.07802450295474905, 0.08058635818869297, 0.09966261244712282, 0.08583115573967537, 0.41095875307213015, 0.23127215736205486, 0.3195321466817449, 0.3608047905873982, 0.29270335378412493, 0.39322975127985127, 0.40055851115394026, 0.24606315633901155, 0.43594368147888485, 0.11048238791257814, 0.1260058391872484, 0.10279338262052329, 0.09958112836617916, 0.10429168777634679, 0.10862916812851742, 0.11354618250653581, 0.13502749607690312, 0.10236020005603408, 0.16617509205460046, 0.17475136222252752, 0.17502032762784114, 0.21605083968026562, 0.2081647364112198, 0.20062762571885517, 0.21738095043512917, 0.2257722029531114, 0.2113634444378193, 0.0730908984332247, 0.10751444800226795, 0.0686359853088574, 0.06501245161940128, 0.07671772024971502, 0.06753589300928453, 0.08055569499518678, 0.09038729043751104, 0.07026227810680508, 0.07136035977563404, 0.07426093018747781, 0.07697549538694415, 0.08269087685739163, 0.07844359000272139, 0.09014735296682941, 0.06890160933902156, 0.07996495954102067, 0.08124509416757864, 9.999999999998899e-05, 0.0003716637754201946, 9.999999999998899e-05, 9.999999999998899e-05, 0.0018817491042857348, 0.0008841024985893897, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07991582453859336, 0.09295212501000039, 0.08050838680171524, 0.10584549317683833, 0.095645630237436, 0.09823933994479195, 0.11620834742229325, 0.09795355505720404, 0.09656731008982955, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0421040529424066, 0.034621398013112814, 0.034142539663067906, 0.03498691488629613, 0.037810677711639595, 0.0323036397137374, 0.041939500809653696, 0.03717549303107148, 0.04327961369624078, 0.29368344940874436, 0.3064495173337951, 0.2846593529181677, 0.2606707313909459, 0.26459302373961324, 0.30280424162141895, 0.26200952999397575, 0.2829078533089818, 0.2954574499959134, 0.07614223207705306, 0.08352081502582132, 0.07495588052580804, 0.07925896508626085, 0.0801374776470386, 0.06481280203142648, 0.07655131723431119, 0.0872568487760833, 0.07804387694488468, 0.17847395495272522, 0.15821989793386126, 0.16551102446499355, 0.15788591033327815, 0.1356696814760302, 0.15697880772924222, 0.1380266800237463, 0.17419181554778718, 0.14940890855287603, 0.2170578371476558, 0.2030221555846461, 0.21727828065611188, 0.21004849104534495, 0.2063375000571126, 0.20602528405125975, 0.21383369759461135, 0.21369981228052837, 0.2134181546392111, 0.15755537267387987, 0.15258999352507885, 0.17738636803452468, 0.1692057311795352, 0.14592935631215753, 0.15196800261252352, 0.16147104842220394, 0.15674350511121649, 0.15721454370165178, 0.17758182387266408, 0.1860889590430248, 0.18481427357775482, 0.19268340344604018, 0.1939576436876358, 0.2004145959202347, 0.1834872658792568, 0.1899234718397914, 0.24067516507431297, 0.19748178273013883, 0.18470453384574526, 0.16942753452945103, 0.17403734738380894, 0.18957111173393038, 0.1698111784763945, 0.19089110422647182, 0.1826351402117602, 0.16855254942977882, 0.16572477579017997, 0.2775416858381762, 0.23984161868431508, 0.24683335957000996, 0.2381222864869863, 0.2671014227539359, 0.2419978525974762, 0.22505334309757374, 0.24642870632258607, 0.28362611365536305, 0.20569216521427458, 0.18142133070374467, 0.17479673081493474, 0.18124592359678482, 0.17949166722277443, 0.17949625044930018, 0.22985879399910347, 0.24584106638370162, 0.19458989557478934, 0.1898769620923202, 0.17251026870910013, 0.19021738760468554, 0.18074432575341548, 0.17199143479675527, 0.18948448510292637, 0.18728033965289492, 0.1822301047220698, 0.07692289575707034, 0.07040152742972261, 0.070858376054454, 0.06580042607649228, 0.07677984115219638, 0.07082927056672816, 0.07022040600135537, 0.07051215005423161, 0.06950564387101477]}, "mutation_prompt": null}
{"id": "66f4ede6-8747-4002-9726-0824cec21f0a", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85  # Adjusted mutation factor for enhanced exploration\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(3, 6, self.population_size)  # Increased search iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)  # Adjusted perturbation for better local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)  # Adaptive opposition around mid-point\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Hybrid local search with adaptive probability\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.7:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing adaptive opposition and hybrid local search to accelerate convergence while maintaining diverse exploration.", "configspace": "", "generation": 60, "fitness": 0.14860256274550132, "feedback": "The algorithm EnhancedDynamicDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.10.", "error": "", "parent_id": "520ef615-ed8c-479a-b24c-54270ff2f0c3", "metadata": {"aucs": [0.3077463200079953, 0.29800629202985396, 0.3025613883450171, 0.27060000676808615, 0.2964253163481396, 0.3139775566443388, 0.299689533340175, 0.2852803589865135, 0.30264009599547803, 0.030390373530886805, 0.022619902017002813, 0.05744768800337574, 0.022665187643416407, 0.022195674666327103, 0.028513928293954605, 0.03297552711165297, 0.038512374160619256, 0.06165542715695049, 0.09993005534542465, 0.10180310815625893, 0.09629099170821553, 0.09783416807060108, 0.1014471088962462, 0.10014467809949079, 0.09870180632984105, 0.10354004722757604, 0.09522959285025367, 0.08578432566353245, 0.0821955220488586, 0.08637978449951478, 0.09013304913308917, 0.08886658916793388, 0.09256766363142943, 0.08043763193193831, 0.08672009378035928, 0.08977870534806842, 0.4050114492967012, 0.5314024385859337, 0.35027454961845905, 0.41686022138508116, 0.4068927940498418, 0.3527118209195953, 0.33919465196930765, 0.4867638639301072, 0.3303767350560993, 0.0946337317676238, 0.11180378767878296, 0.1598312733474344, 0.12577925697277115, 0.09633577681971728, 0.08883473787463247, 0.13726660946641245, 0.1369245428341006, 0.12273296266741873, 0.20837197932348084, 0.16196334566232673, 0.1992613664863272, 0.20176968108776527, 0.20186820675468342, 0.20893907649120258, 0.1964563993712889, 0.2037196255505812, 0.17598002485325592, 0.06522698301884633, 0.08333539742339524, 0.07243358087909746, 0.06673057992411191, 0.07578717946068259, 0.08555571306861642, 0.0794883534914479, 0.09907256018648203, 0.07156790191190043, 0.06582649210988512, 0.07864057763779952, 0.09098668837343138, 0.1013120979331954, 0.06985443579283745, 0.0807632634149602, 0.0728990038062941, 0.09120043545518419, 0.08874793448271534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027381380250671605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10012850013535224, 0.09086467990256863, 0.09213120563736488, 0.09742740207871081, 0.11455789961260687, 0.0998825777597998, 0.10013619022648113, 0.09394430557175859, 0.10335848410808435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031006519457458692, 0.030840448987022318, 0.030815805181557687, 0.03115803173038456, 0.046711575916170256, 0.04460894322514941, 0.04729506665409977, 0.04104288171792503, 0.03413840419664316, 0.30921616727181367, 0.29057422648783693, 0.2967621429180982, 0.27764376008512703, 0.2955378620300333, 0.3026453617400586, 0.27741225865684305, 0.2953119171367573, 0.2919241388058428, 0.08355213951380558, 0.08860699937929317, 0.08386075129742787, 0.07246946252798425, 0.07122896366031672, 0.07219538361084687, 0.08327390753850505, 0.0805966186859689, 0.07551735838433249, 0.13385634043853167, 0.17180187713093076, 0.1675994334343346, 0.1660679929147666, 0.1645826807386389, 0.12833606853334678, 0.15136022848006436, 0.18518924731787145, 0.13610717811508966, 0.2150719156401838, 0.20821311466788328, 0.22742757466683539, 0.2082193784363049, 0.21475913033697014, 0.21323552027730808, 0.21895917694478773, 0.21878899369832427, 0.21800979920714636, 0.1549837311664285, 0.16251272264638916, 0.17382382111676176, 0.16419635381714837, 0.14525793019407252, 0.15822292884302647, 0.1666620410567624, 0.1586980835221662, 0.16194124409100985, 0.19761595001740784, 0.18784520300325735, 0.1945071097213259, 0.18189411975302106, 0.18440474108236105, 0.18494816835119565, 0.19182880353981513, 0.19222758520319982, 0.19867803134245687, 0.17676384629735387, 0.180977649483118, 0.1792723387390568, 0.17809003768452536, 0.17642268148475726, 0.18140421015843022, 0.1859001440838287, 0.17444197053441535, 0.17347647357064488, 0.21797498081645594, 0.24451143440678902, 0.22742593471067962, 0.27709451263785645, 0.27649594957169754, 0.211517461702451, 0.3366826057574279, 0.24208246360741825, 0.31364088870736306, 0.2698035055340351, 0.18516368463537758, 0.21181516901327546, 0.20913535070615308, 0.2320678061122775, 0.21361565728347398, 0.20805365355098415, 0.2964427551899559, 0.30697736954134114, 0.18476314099780045, 0.17618479847423774, 0.1972850149789469, 0.1922727813088566, 0.17937445702687005, 0.19182502251350564, 0.1905150686941921, 0.18328399343970125, 0.18405711750676534, 0.06799479994301294, 0.08268703975560254, 0.07421167810988716, 0.06818256862748018, 0.07168382116484084, 0.07242419562746505, 0.07494816592008369, 0.06990488309518439, 0.07093256766464906]}, "mutation_prompt": null}
{"id": "b30ffd21-3c35-4927-a808-a114003e38d1", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85  # Adjusted mutation factor for enhanced exploration\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(3, 6, self.population_size)  # Increased search iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)  # Adjusted perturbation for better local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)  # Adaptive opposition around mid-point\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Hybrid local search with adaptive probability\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.7:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing adaptive opposition and hybrid local search to accelerate convergence while maintaining diverse exploration.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.3077463200079953, 0.29800629202985396, 0.3025613883450171, 0.27060000676808615, 0.2964253163481396, 0.3139775566443388, 0.299689533340175, 0.2852803589865135, 0.30264009599547803, 0.030390373530886805, 0.022619902017002813, 0.05744768800337574, 0.022665187643416407, 0.022195674666327103, 0.028513928293954605, 0.03297552711165297, 0.038512374160619256, 0.06165542715695049, 0.09993005534542465, 0.10180310815625893, 0.09629099170821553, 0.09783416807060108, 0.1014471088962462, 0.10014467809949079, 0.09870180632984105, 0.10354004722757604, 0.09522959285025367, 0.08578432566353245, 0.0821955220488586, 0.08637978449951478, 0.09013304913308917, 0.08886658916793388, 0.09256766363142943, 0.08043763193193831, 0.08672009378035928, 0.08977870534806842, 0.4050114492967012, 0.5314024385859337, 0.35027454961845905, 0.41686022138508116, 0.4068927940498418, 0.3527118209195953, 0.33919465196930765, 0.4867638639301072, 0.3303767350560993, 0.0946337317676238, 0.11180378767878296, 0.1598312733474344, 0.12577925697277115, 0.09633577681971728, 0.08883473787463247, 0.13726660946641245, 0.1369245428341006, 0.12273296266741873, 0.20837197932348084, 0.16196334566232673, 0.1992613664863272, 0.20176968108776527, 0.20186820675468342, 0.20893907649120258, 0.1964563993712889, 0.2037196255505812, 0.17598002485325592, 0.06522698301884633, 0.08333539742339524, 0.07243358087909746, 0.06673057992411191, 0.07578717946068259, 0.08555571306861642, 0.0794883534914479, 0.09907256018648203, 0.07156790191190043, 0.06582649210988512, 0.07864057763779952, 0.09098668837343138, 0.1013120979331954, 0.06985443579283745, 0.0807632634149602, 0.0728990038062941, 0.09120043545518419, 0.08874793448271534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027381380250671605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10012850013535224, 0.09086467990256863, 0.09213120563736488, 0.09742740207871081, 0.11455789961260687, 0.0998825777597998, 0.10013619022648113, 0.09394430557175859, 0.10335848410808435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031006519457458692, 0.030840448987022318, 0.030815805181557687, 0.03115803173038456, 0.046711575916170256, 0.04460894322514941, 0.04729506665409977, 0.04104288171792503, 0.03413840419664316, 0.30921616727181367, 0.29057422648783693, 0.2967621429180982, 0.27764376008512703, 0.2955378620300333, 0.3026453617400586, 0.27741225865684305, 0.2953119171367573, 0.2919241388058428, 0.08355213951380558, 0.08860699937929317, 0.08386075129742787, 0.07246946252798425, 0.07122896366031672, 0.07219538361084687, 0.08327390753850505, 0.0805966186859689, 0.07551735838433249, 0.13385634043853167, 0.17180187713093076, 0.1675994334343346, 0.1660679929147666, 0.1645826807386389, 0.12833606853334678, 0.15136022848006436, 0.18518924731787145, 0.13610717811508966, 0.2150719156401838, 0.20821311466788328, 0.22742757466683539, 0.2082193784363049, 0.21475913033697014, 0.21323552027730808, 0.21895917694478773, 0.21878899369832427, 0.21800979920714636, 0.1549837311664285, 0.16251272264638916, 0.17382382111676176, 0.16419635381714837, 0.14525793019407252, 0.15822292884302647, 0.1666620410567624, 0.1586980835221662, 0.16194124409100985, 0.19761595001740784, 0.18784520300325735, 0.1945071097213259, 0.18189411975302106, 0.18440474108236105, 0.18494816835119565, 0.19182880353981513, 0.19222758520319982, 0.19867803134245687, 0.17676384629735387, 0.180977649483118, 0.1792723387390568, 0.17809003768452536, 0.17642268148475726, 0.18140421015843022, 0.1859001440838287, 0.17444197053441535, 0.17347647357064488, 0.21797498081645594, 0.24451143440678902, 0.22742593471067962, 0.27709451263785645, 0.27649594957169754, 0.211517461702451, 0.3366826057574279, 0.24208246360741825, 0.31364088870736306, 0.2698035055340351, 0.18516368463537758, 0.21181516901327546, 0.20913535070615308, 0.2320678061122775, 0.21361565728347398, 0.20805365355098415, 0.2964427551899559, 0.30697736954134114, 0.18476314099780045, 0.17618479847423774, 0.1972850149789469, 0.1922727813088566, 0.17937445702687005, 0.19182502251350564, 0.1905150686941921, 0.18328399343970125, 0.18405711750676534, 0.06799479994301294, 0.08268703975560254, 0.07421167810988716, 0.06818256862748018, 0.07168382116484084, 0.07242419562746505, 0.07494816592008369, 0.06990488309518439, 0.07093256766464906]}, "mutation_prompt": null}
{"id": "4df0175a-48ed-4e14-9400-a663fea21bb0", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85  # Adjusted mutation factor for enhanced exploration\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(3, 6, self.population_size)  # Increased search iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)  # Adjusted perturbation for better local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)  # Adaptive opposition around mid-point\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Hybrid local search with adaptive probability\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.7:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing adaptive opposition and hybrid local search to accelerate convergence while maintaining diverse exploration.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.3077463200079953, 0.29800629202985396, 0.3025613883450171, 0.27060000676808615, 0.2964253163481396, 0.3139775566443388, 0.299689533340175, 0.2852803589865135, 0.30264009599547803, 0.030390373530886805, 0.022619902017002813, 0.05744768800337574, 0.022665187643416407, 0.022195674666327103, 0.028513928293954605, 0.03297552711165297, 0.038512374160619256, 0.06165542715695049, 0.09993005534542465, 0.10180310815625893, 0.09629099170821553, 0.09783416807060108, 0.1014471088962462, 0.10014467809949079, 0.09870180632984105, 0.10354004722757604, 0.09522959285025367, 0.08578432566353245, 0.0821955220488586, 0.08637978449951478, 0.09013304913308917, 0.08886658916793388, 0.09256766363142943, 0.08043763193193831, 0.08672009378035928, 0.08977870534806842, 0.4050114492967012, 0.5314024385859337, 0.35027454961845905, 0.41686022138508116, 0.4068927940498418, 0.3527118209195953, 0.33919465196930765, 0.4867638639301072, 0.3303767350560993, 0.0946337317676238, 0.11180378767878296, 0.1598312733474344, 0.12577925697277115, 0.09633577681971728, 0.08883473787463247, 0.13726660946641245, 0.1369245428341006, 0.12273296266741873, 0.20837197932348084, 0.16196334566232673, 0.1992613664863272, 0.20176968108776527, 0.20186820675468342, 0.20893907649120258, 0.1964563993712889, 0.2037196255505812, 0.17598002485325592, 0.06522698301884633, 0.08333539742339524, 0.07243358087909746, 0.06673057992411191, 0.07578717946068259, 0.08555571306861642, 0.0794883534914479, 0.09907256018648203, 0.07156790191190043, 0.06582649210988512, 0.07864057763779952, 0.09098668837343138, 0.1013120979331954, 0.06985443579283745, 0.0807632634149602, 0.0728990038062941, 0.09120043545518419, 0.08874793448271534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027381380250671605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10012850013535224, 0.09086467990256863, 0.09213120563736488, 0.09742740207871081, 0.11455789961260687, 0.0998825777597998, 0.10013619022648113, 0.09394430557175859, 0.10335848410808435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031006519457458692, 0.030840448987022318, 0.030815805181557687, 0.03115803173038456, 0.046711575916170256, 0.04460894322514941, 0.04729506665409977, 0.04104288171792503, 0.03413840419664316, 0.30921616727181367, 0.29057422648783693, 0.2967621429180982, 0.27764376008512703, 0.2955378620300333, 0.3026453617400586, 0.27741225865684305, 0.2953119171367573, 0.2919241388058428, 0.08355213951380558, 0.08860699937929317, 0.08386075129742787, 0.07246946252798425, 0.07122896366031672, 0.07219538361084687, 0.08327390753850505, 0.0805966186859689, 0.07551735838433249, 0.13385634043853167, 0.17180187713093076, 0.1675994334343346, 0.1660679929147666, 0.1645826807386389, 0.12833606853334678, 0.15136022848006436, 0.18518924731787145, 0.13610717811508966, 0.2150719156401838, 0.20821311466788328, 0.22742757466683539, 0.2082193784363049, 0.21475913033697014, 0.21323552027730808, 0.21895917694478773, 0.21878899369832427, 0.21800979920714636, 0.1549837311664285, 0.16251272264638916, 0.17382382111676176, 0.16419635381714837, 0.14525793019407252, 0.15822292884302647, 0.1666620410567624, 0.1586980835221662, 0.16194124409100985, 0.19761595001740784, 0.18784520300325735, 0.1945071097213259, 0.18189411975302106, 0.18440474108236105, 0.18494816835119565, 0.19182880353981513, 0.19222758520319982, 0.19867803134245687, 0.17676384629735387, 0.180977649483118, 0.1792723387390568, 0.17809003768452536, 0.17642268148475726, 0.18140421015843022, 0.1859001440838287, 0.17444197053441535, 0.17347647357064488, 0.21797498081645594, 0.24451143440678902, 0.22742593471067962, 0.27709451263785645, 0.27649594957169754, 0.211517461702451, 0.3366826057574279, 0.24208246360741825, 0.31364088870736306, 0.2698035055340351, 0.18516368463537758, 0.21181516901327546, 0.20913535070615308, 0.2320678061122775, 0.21361565728347398, 0.20805365355098415, 0.2964427551899559, 0.30697736954134114, 0.18476314099780045, 0.17618479847423774, 0.1972850149789469, 0.1922727813088566, 0.17937445702687005, 0.19182502251350564, 0.1905150686941921, 0.18328399343970125, 0.18405711750676534, 0.06799479994301294, 0.08268703975560254, 0.07421167810988716, 0.06818256862748018, 0.07168382116484084, 0.07242419562746505, 0.07494816592008369, 0.06990488309518439, 0.07093256766464906]}, "mutation_prompt": null}
{"id": "922aed77-b997-4981-910f-17f2b6d73ec4", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85  # Adjusted mutation factor for enhanced exploration\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(3, 6, self.population_size)  # Increased search iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)  # Adjusted perturbation for better local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)  # Adaptive opposition around mid-point\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Hybrid local search with adaptive probability\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.7:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing adaptive opposition and hybrid local search to accelerate convergence while maintaining diverse exploration.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.3077463200079953, 0.29800629202985396, 0.3025613883450171, 0.27060000676808615, 0.2964253163481396, 0.3139775566443388, 0.299689533340175, 0.2852803589865135, 0.30264009599547803, 0.030390373530886805, 0.022619902017002813, 0.05744768800337574, 0.022665187643416407, 0.022195674666327103, 0.028513928293954605, 0.03297552711165297, 0.038512374160619256, 0.06165542715695049, 0.09993005534542465, 0.10180310815625893, 0.09629099170821553, 0.09783416807060108, 0.1014471088962462, 0.10014467809949079, 0.09870180632984105, 0.10354004722757604, 0.09522959285025367, 0.08578432566353245, 0.0821955220488586, 0.08637978449951478, 0.09013304913308917, 0.08886658916793388, 0.09256766363142943, 0.08043763193193831, 0.08672009378035928, 0.08977870534806842, 0.4050114492967012, 0.5314024385859337, 0.35027454961845905, 0.41686022138508116, 0.4068927940498418, 0.3527118209195953, 0.33919465196930765, 0.4867638639301072, 0.3303767350560993, 0.0946337317676238, 0.11180378767878296, 0.1598312733474344, 0.12577925697277115, 0.09633577681971728, 0.08883473787463247, 0.13726660946641245, 0.1369245428341006, 0.12273296266741873, 0.20837197932348084, 0.16196334566232673, 0.1992613664863272, 0.20176968108776527, 0.20186820675468342, 0.20893907649120258, 0.1964563993712889, 0.2037196255505812, 0.17598002485325592, 0.06522698301884633, 0.08333539742339524, 0.07243358087909746, 0.06673057992411191, 0.07578717946068259, 0.08555571306861642, 0.0794883534914479, 0.09907256018648203, 0.07156790191190043, 0.06582649210988512, 0.07864057763779952, 0.09098668837343138, 0.1013120979331954, 0.06985443579283745, 0.0807632634149602, 0.0728990038062941, 0.09120043545518419, 0.08874793448271534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027381380250671605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10012850013535224, 0.09086467990256863, 0.09213120563736488, 0.09742740207871081, 0.11455789961260687, 0.0998825777597998, 0.10013619022648113, 0.09394430557175859, 0.10335848410808435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031006519457458692, 0.030840448987022318, 0.030815805181557687, 0.03115803173038456, 0.046711575916170256, 0.04460894322514941, 0.04729506665409977, 0.04104288171792503, 0.03413840419664316, 0.30921616727181367, 0.29057422648783693, 0.2967621429180982, 0.27764376008512703, 0.2955378620300333, 0.3026453617400586, 0.27741225865684305, 0.2953119171367573, 0.2919241388058428, 0.08355213951380558, 0.08860699937929317, 0.08386075129742787, 0.07246946252798425, 0.07122896366031672, 0.07219538361084687, 0.08327390753850505, 0.0805966186859689, 0.07551735838433249, 0.13385634043853167, 0.17180187713093076, 0.1675994334343346, 0.1660679929147666, 0.1645826807386389, 0.12833606853334678, 0.15136022848006436, 0.18518924731787145, 0.13610717811508966, 0.2150719156401838, 0.20821311466788328, 0.22742757466683539, 0.2082193784363049, 0.21475913033697014, 0.21323552027730808, 0.21895917694478773, 0.21878899369832427, 0.21800979920714636, 0.1549837311664285, 0.16251272264638916, 0.17382382111676176, 0.16419635381714837, 0.14525793019407252, 0.15822292884302647, 0.1666620410567624, 0.1586980835221662, 0.16194124409100985, 0.19761595001740784, 0.18784520300325735, 0.1945071097213259, 0.18189411975302106, 0.18440474108236105, 0.18494816835119565, 0.19182880353981513, 0.19222758520319982, 0.19867803134245687, 0.17676384629735387, 0.180977649483118, 0.1792723387390568, 0.17809003768452536, 0.17642268148475726, 0.18140421015843022, 0.1859001440838287, 0.17444197053441535, 0.17347647357064488, 0.21797498081645594, 0.24451143440678902, 0.22742593471067962, 0.27709451263785645, 0.27649594957169754, 0.211517461702451, 0.3366826057574279, 0.24208246360741825, 0.31364088870736306, 0.2698035055340351, 0.18516368463537758, 0.21181516901327546, 0.20913535070615308, 0.2320678061122775, 0.21361565728347398, 0.20805365355098415, 0.2964427551899559, 0.30697736954134114, 0.18476314099780045, 0.17618479847423774, 0.1972850149789469, 0.1922727813088566, 0.17937445702687005, 0.19182502251350564, 0.1905150686941921, 0.18328399343970125, 0.18405711750676534, 0.06799479994301294, 0.08268703975560254, 0.07421167810988716, 0.06818256862748018, 0.07168382116484084, 0.07242419562746505, 0.07494816592008369, 0.06990488309518439, 0.07093256766464906]}, "mutation_prompt": null}
{"id": "d5d6fe90-a56d-4a24-a203-92f6b0b7a31b", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85  # Adjusted mutation factor for enhanced exploration\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(3, 6, self.population_size)  # Increased search iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)  # Adjusted perturbation for better local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)  # Adaptive opposition around mid-point\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Hybrid local search with adaptive probability\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.7:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing adaptive opposition and hybrid local search to accelerate convergence while maintaining diverse exploration.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.3077463200079953, 0.29800629202985396, 0.3025613883450171, 0.27060000676808615, 0.2964253163481396, 0.3139775566443388, 0.299689533340175, 0.2852803589865135, 0.30264009599547803, 0.030390373530886805, 0.022619902017002813, 0.05744768800337574, 0.022665187643416407, 0.022195674666327103, 0.028513928293954605, 0.03297552711165297, 0.038512374160619256, 0.06165542715695049, 0.09993005534542465, 0.10180310815625893, 0.09629099170821553, 0.09783416807060108, 0.1014471088962462, 0.10014467809949079, 0.09870180632984105, 0.10354004722757604, 0.09522959285025367, 0.08578432566353245, 0.0821955220488586, 0.08637978449951478, 0.09013304913308917, 0.08886658916793388, 0.09256766363142943, 0.08043763193193831, 0.08672009378035928, 0.08977870534806842, 0.4050114492967012, 0.5314024385859337, 0.35027454961845905, 0.41686022138508116, 0.4068927940498418, 0.3527118209195953, 0.33919465196930765, 0.4867638639301072, 0.3303767350560993, 0.0946337317676238, 0.11180378767878296, 0.1598312733474344, 0.12577925697277115, 0.09633577681971728, 0.08883473787463247, 0.13726660946641245, 0.1369245428341006, 0.12273296266741873, 0.20837197932348084, 0.16196334566232673, 0.1992613664863272, 0.20176968108776527, 0.20186820675468342, 0.20893907649120258, 0.1964563993712889, 0.2037196255505812, 0.17598002485325592, 0.06522698301884633, 0.08333539742339524, 0.07243358087909746, 0.06673057992411191, 0.07578717946068259, 0.08555571306861642, 0.0794883534914479, 0.09907256018648203, 0.07156790191190043, 0.06582649210988512, 0.07864057763779952, 0.09098668837343138, 0.1013120979331954, 0.06985443579283745, 0.0807632634149602, 0.0728990038062941, 0.09120043545518419, 0.08874793448271534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027381380250671605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10012850013535224, 0.09086467990256863, 0.09213120563736488, 0.09742740207871081, 0.11455789961260687, 0.0998825777597998, 0.10013619022648113, 0.09394430557175859, 0.10335848410808435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031006519457458692, 0.030840448987022318, 0.030815805181557687, 0.03115803173038456, 0.046711575916170256, 0.04460894322514941, 0.04729506665409977, 0.04104288171792503, 0.03413840419664316, 0.30921616727181367, 0.29057422648783693, 0.2967621429180982, 0.27764376008512703, 0.2955378620300333, 0.3026453617400586, 0.27741225865684305, 0.2953119171367573, 0.2919241388058428, 0.08355213951380558, 0.08860699937929317, 0.08386075129742787, 0.07246946252798425, 0.07122896366031672, 0.07219538361084687, 0.08327390753850505, 0.0805966186859689, 0.07551735838433249, 0.13385634043853167, 0.17180187713093076, 0.1675994334343346, 0.1660679929147666, 0.1645826807386389, 0.12833606853334678, 0.15136022848006436, 0.18518924731787145, 0.13610717811508966, 0.2150719156401838, 0.20821311466788328, 0.22742757466683539, 0.2082193784363049, 0.21475913033697014, 0.21323552027730808, 0.21895917694478773, 0.21878899369832427, 0.21800979920714636, 0.1549837311664285, 0.16251272264638916, 0.17382382111676176, 0.16419635381714837, 0.14525793019407252, 0.15822292884302647, 0.1666620410567624, 0.1586980835221662, 0.16194124409100985, 0.19761595001740784, 0.18784520300325735, 0.1945071097213259, 0.18189411975302106, 0.18440474108236105, 0.18494816835119565, 0.19182880353981513, 0.19222758520319982, 0.19867803134245687, 0.17676384629735387, 0.180977649483118, 0.1792723387390568, 0.17809003768452536, 0.17642268148475726, 0.18140421015843022, 0.1859001440838287, 0.17444197053441535, 0.17347647357064488, 0.21797498081645594, 0.24451143440678902, 0.22742593471067962, 0.27709451263785645, 0.27649594957169754, 0.211517461702451, 0.3366826057574279, 0.24208246360741825, 0.31364088870736306, 0.2698035055340351, 0.18516368463537758, 0.21181516901327546, 0.20913535070615308, 0.2320678061122775, 0.21361565728347398, 0.20805365355098415, 0.2964427551899559, 0.30697736954134114, 0.18476314099780045, 0.17618479847423774, 0.1972850149789469, 0.1922727813088566, 0.17937445702687005, 0.19182502251350564, 0.1905150686941921, 0.18328399343970125, 0.18405711750676534, 0.06799479994301294, 0.08268703975560254, 0.07421167810988716, 0.06818256862748018, 0.07168382116484084, 0.07242419562746505, 0.07494816592008369, 0.06990488309518439, 0.07093256766464906]}, "mutation_prompt": null}
{"id": "73d8e60f-e573-422f-af7a-a09bd5a36320", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85  # Adjusted mutation factor for enhanced exploration\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(3, 6, self.population_size)  # Increased search iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)  # Adjusted perturbation for better local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)  # Adaptive opposition around mid-point\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Hybrid local search with adaptive probability\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.7:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing adaptive opposition and hybrid local search to accelerate convergence while maintaining diverse exploration.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.3077463200079953, 0.29800629202985396, 0.3025613883450171, 0.27060000676808615, 0.2964253163481396, 0.3139775566443388, 0.299689533340175, 0.2852803589865135, 0.30264009599547803, 0.030390373530886805, 0.022619902017002813, 0.05744768800337574, 0.022665187643416407, 0.022195674666327103, 0.028513928293954605, 0.03297552711165297, 0.038512374160619256, 0.06165542715695049, 0.09993005534542465, 0.10180310815625893, 0.09629099170821553, 0.09783416807060108, 0.1014471088962462, 0.10014467809949079, 0.09870180632984105, 0.10354004722757604, 0.09522959285025367, 0.08578432566353245, 0.0821955220488586, 0.08637978449951478, 0.09013304913308917, 0.08886658916793388, 0.09256766363142943, 0.08043763193193831, 0.08672009378035928, 0.08977870534806842, 0.4050114492967012, 0.5314024385859337, 0.35027454961845905, 0.41686022138508116, 0.4068927940498418, 0.3527118209195953, 0.33919465196930765, 0.4867638639301072, 0.3303767350560993, 0.0946337317676238, 0.11180378767878296, 0.1598312733474344, 0.12577925697277115, 0.09633577681971728, 0.08883473787463247, 0.13726660946641245, 0.1369245428341006, 0.12273296266741873, 0.20837197932348084, 0.16196334566232673, 0.1992613664863272, 0.20176968108776527, 0.20186820675468342, 0.20893907649120258, 0.1964563993712889, 0.2037196255505812, 0.17598002485325592, 0.06522698301884633, 0.08333539742339524, 0.07243358087909746, 0.06673057992411191, 0.07578717946068259, 0.08555571306861642, 0.0794883534914479, 0.09907256018648203, 0.07156790191190043, 0.06582649210988512, 0.07864057763779952, 0.09098668837343138, 0.1013120979331954, 0.06985443579283745, 0.0807632634149602, 0.0728990038062941, 0.09120043545518419, 0.08874793448271534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027381380250671605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10012850013535224, 0.09086467990256863, 0.09213120563736488, 0.09742740207871081, 0.11455789961260687, 0.0998825777597998, 0.10013619022648113, 0.09394430557175859, 0.10335848410808435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031006519457458692, 0.030840448987022318, 0.030815805181557687, 0.03115803173038456, 0.046711575916170256, 0.04460894322514941, 0.04729506665409977, 0.04104288171792503, 0.03413840419664316, 0.30921616727181367, 0.29057422648783693, 0.2967621429180982, 0.27764376008512703, 0.2955378620300333, 0.3026453617400586, 0.27741225865684305, 0.2953119171367573, 0.2919241388058428, 0.08355213951380558, 0.08860699937929317, 0.08386075129742787, 0.07246946252798425, 0.07122896366031672, 0.07219538361084687, 0.08327390753850505, 0.0805966186859689, 0.07551735838433249, 0.13385634043853167, 0.17180187713093076, 0.1675994334343346, 0.1660679929147666, 0.1645826807386389, 0.12833606853334678, 0.15136022848006436, 0.18518924731787145, 0.13610717811508966, 0.2150719156401838, 0.20821311466788328, 0.22742757466683539, 0.2082193784363049, 0.21475913033697014, 0.21323552027730808, 0.21895917694478773, 0.21878899369832427, 0.21800979920714636, 0.1549837311664285, 0.16251272264638916, 0.17382382111676176, 0.16419635381714837, 0.14525793019407252, 0.15822292884302647, 0.1666620410567624, 0.1586980835221662, 0.16194124409100985, 0.19761595001740784, 0.18784520300325735, 0.1945071097213259, 0.18189411975302106, 0.18440474108236105, 0.18494816835119565, 0.19182880353981513, 0.19222758520319982, 0.19867803134245687, 0.17676384629735387, 0.180977649483118, 0.1792723387390568, 0.17809003768452536, 0.17642268148475726, 0.18140421015843022, 0.1859001440838287, 0.17444197053441535, 0.17347647357064488, 0.21797498081645594, 0.24451143440678902, 0.22742593471067962, 0.27709451263785645, 0.27649594957169754, 0.211517461702451, 0.3366826057574279, 0.24208246360741825, 0.31364088870736306, 0.2698035055340351, 0.18516368463537758, 0.21181516901327546, 0.20913535070615308, 0.2320678061122775, 0.21361565728347398, 0.20805365355098415, 0.2964427551899559, 0.30697736954134114, 0.18476314099780045, 0.17618479847423774, 0.1972850149789469, 0.1922727813088566, 0.17937445702687005, 0.19182502251350564, 0.1905150686941921, 0.18328399343970125, 0.18405711750676534, 0.06799479994301294, 0.08268703975560254, 0.07421167810988716, 0.06818256862748018, 0.07168382116484084, 0.07242419562746505, 0.07494816592008369, 0.06990488309518439, 0.07093256766464906]}, "mutation_prompt": null}
{"id": "2192d53d-184c-4c2d-8df3-88ca4d96b032", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85  # Adjusted mutation factor for enhanced exploration\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(3, 6, self.population_size)  # Increased search iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)  # Adjusted perturbation for better local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)  # Adaptive opposition around mid-point\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Hybrid local search with adaptive probability\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.7:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing adaptive opposition and hybrid local search to accelerate convergence while maintaining diverse exploration.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.3077463200079953, 0.29800629202985396, 0.3025613883450171, 0.27060000676808615, 0.2964253163481396, 0.3139775566443388, 0.299689533340175, 0.2852803589865135, 0.30264009599547803, 0.030390373530886805, 0.022619902017002813, 0.05744768800337574, 0.022665187643416407, 0.022195674666327103, 0.028513928293954605, 0.03297552711165297, 0.038512374160619256, 0.06165542715695049, 0.09993005534542465, 0.10180310815625893, 0.09629099170821553, 0.09783416807060108, 0.1014471088962462, 0.10014467809949079, 0.09870180632984105, 0.10354004722757604, 0.09522959285025367, 0.08578432566353245, 0.0821955220488586, 0.08637978449951478, 0.09013304913308917, 0.08886658916793388, 0.09256766363142943, 0.08043763193193831, 0.08672009378035928, 0.08977870534806842, 0.4050114492967012, 0.5314024385859337, 0.35027454961845905, 0.41686022138508116, 0.4068927940498418, 0.3527118209195953, 0.33919465196930765, 0.4867638639301072, 0.3303767350560993, 0.0946337317676238, 0.11180378767878296, 0.1598312733474344, 0.12577925697277115, 0.09633577681971728, 0.08883473787463247, 0.13726660946641245, 0.1369245428341006, 0.12273296266741873, 0.20837197932348084, 0.16196334566232673, 0.1992613664863272, 0.20176968108776527, 0.20186820675468342, 0.20893907649120258, 0.1964563993712889, 0.2037196255505812, 0.17598002485325592, 0.06522698301884633, 0.08333539742339524, 0.07243358087909746, 0.06673057992411191, 0.07578717946068259, 0.08555571306861642, 0.0794883534914479, 0.09907256018648203, 0.07156790191190043, 0.06582649210988512, 0.07864057763779952, 0.09098668837343138, 0.1013120979331954, 0.06985443579283745, 0.0807632634149602, 0.0728990038062941, 0.09120043545518419, 0.08874793448271534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027381380250671605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10012850013535224, 0.09086467990256863, 0.09213120563736488, 0.09742740207871081, 0.11455789961260687, 0.0998825777597998, 0.10013619022648113, 0.09394430557175859, 0.10335848410808435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031006519457458692, 0.030840448987022318, 0.030815805181557687, 0.03115803173038456, 0.046711575916170256, 0.04460894322514941, 0.04729506665409977, 0.04104288171792503, 0.03413840419664316, 0.30921616727181367, 0.29057422648783693, 0.2967621429180982, 0.27764376008512703, 0.2955378620300333, 0.3026453617400586, 0.27741225865684305, 0.2953119171367573, 0.2919241388058428, 0.08355213951380558, 0.08860699937929317, 0.08386075129742787, 0.07246946252798425, 0.07122896366031672, 0.07219538361084687, 0.08327390753850505, 0.0805966186859689, 0.07551735838433249, 0.13385634043853167, 0.17180187713093076, 0.1675994334343346, 0.1660679929147666, 0.1645826807386389, 0.12833606853334678, 0.15136022848006436, 0.18518924731787145, 0.13610717811508966, 0.2150719156401838, 0.20821311466788328, 0.22742757466683539, 0.2082193784363049, 0.21475913033697014, 0.21323552027730808, 0.21895917694478773, 0.21878899369832427, 0.21800979920714636, 0.1549837311664285, 0.16251272264638916, 0.17382382111676176, 0.16419635381714837, 0.14525793019407252, 0.15822292884302647, 0.1666620410567624, 0.1586980835221662, 0.16194124409100985, 0.19761595001740784, 0.18784520300325735, 0.1945071097213259, 0.18189411975302106, 0.18440474108236105, 0.18494816835119565, 0.19182880353981513, 0.19222758520319982, 0.19867803134245687, 0.17676384629735387, 0.180977649483118, 0.1792723387390568, 0.17809003768452536, 0.17642268148475726, 0.18140421015843022, 0.1859001440838287, 0.17444197053441535, 0.17347647357064488, 0.21797498081645594, 0.24451143440678902, 0.22742593471067962, 0.27709451263785645, 0.27649594957169754, 0.211517461702451, 0.3366826057574279, 0.24208246360741825, 0.31364088870736306, 0.2698035055340351, 0.18516368463537758, 0.21181516901327546, 0.20913535070615308, 0.2320678061122775, 0.21361565728347398, 0.20805365355098415, 0.2964427551899559, 0.30697736954134114, 0.18476314099780045, 0.17618479847423774, 0.1972850149789469, 0.1922727813088566, 0.17937445702687005, 0.19182502251350564, 0.1905150686941921, 0.18328399343970125, 0.18405711750676534, 0.06799479994301294, 0.08268703975560254, 0.07421167810988716, 0.06818256862748018, 0.07168382116484084, 0.07242419562746505, 0.07494816592008369, 0.06990488309518439, 0.07093256766464906]}, "mutation_prompt": null}
{"id": "029221ce-133c-4d19-a8fc-efef9def100b", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85  # Adjusted mutation factor for enhanced exploration\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(3, 6, self.population_size)  # Increased search iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)  # Adjusted perturbation for better local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)  # Adaptive opposition around mid-point\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Hybrid local search with adaptive probability\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.7:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing adaptive opposition and hybrid local search to accelerate convergence while maintaining diverse exploration.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.3077463200079953, 0.29800629202985396, 0.3025613883450171, 0.27060000676808615, 0.2964253163481396, 0.3139775566443388, 0.299689533340175, 0.2852803589865135, 0.30264009599547803, 0.030390373530886805, 0.022619902017002813, 0.05744768800337574, 0.022665187643416407, 0.022195674666327103, 0.028513928293954605, 0.03297552711165297, 0.038512374160619256, 0.06165542715695049, 0.09993005534542465, 0.10180310815625893, 0.09629099170821553, 0.09783416807060108, 0.1014471088962462, 0.10014467809949079, 0.09870180632984105, 0.10354004722757604, 0.09522959285025367, 0.08578432566353245, 0.0821955220488586, 0.08637978449951478, 0.09013304913308917, 0.08886658916793388, 0.09256766363142943, 0.08043763193193831, 0.08672009378035928, 0.08977870534806842, 0.4050114492967012, 0.5314024385859337, 0.35027454961845905, 0.41686022138508116, 0.4068927940498418, 0.3527118209195953, 0.33919465196930765, 0.4867638639301072, 0.3303767350560993, 0.0946337317676238, 0.11180378767878296, 0.1598312733474344, 0.12577925697277115, 0.09633577681971728, 0.08883473787463247, 0.13726660946641245, 0.1369245428341006, 0.12273296266741873, 0.20837197932348084, 0.16196334566232673, 0.1992613664863272, 0.20176968108776527, 0.20186820675468342, 0.20893907649120258, 0.1964563993712889, 0.2037196255505812, 0.17598002485325592, 0.06522698301884633, 0.08333539742339524, 0.07243358087909746, 0.06673057992411191, 0.07578717946068259, 0.08555571306861642, 0.0794883534914479, 0.09907256018648203, 0.07156790191190043, 0.06582649210988512, 0.07864057763779952, 0.09098668837343138, 0.1013120979331954, 0.06985443579283745, 0.0807632634149602, 0.0728990038062941, 0.09120043545518419, 0.08874793448271534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027381380250671605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10012850013535224, 0.09086467990256863, 0.09213120563736488, 0.09742740207871081, 0.11455789961260687, 0.0998825777597998, 0.10013619022648113, 0.09394430557175859, 0.10335848410808435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031006519457458692, 0.030840448987022318, 0.030815805181557687, 0.03115803173038456, 0.046711575916170256, 0.04460894322514941, 0.04729506665409977, 0.04104288171792503, 0.03413840419664316, 0.30921616727181367, 0.29057422648783693, 0.2967621429180982, 0.27764376008512703, 0.2955378620300333, 0.3026453617400586, 0.27741225865684305, 0.2953119171367573, 0.2919241388058428, 0.08355213951380558, 0.08860699937929317, 0.08386075129742787, 0.07246946252798425, 0.07122896366031672, 0.07219538361084687, 0.08327390753850505, 0.0805966186859689, 0.07551735838433249, 0.13385634043853167, 0.17180187713093076, 0.1675994334343346, 0.1660679929147666, 0.1645826807386389, 0.12833606853334678, 0.15136022848006436, 0.18518924731787145, 0.13610717811508966, 0.2150719156401838, 0.20821311466788328, 0.22742757466683539, 0.2082193784363049, 0.21475913033697014, 0.21323552027730808, 0.21895917694478773, 0.21878899369832427, 0.21800979920714636, 0.1549837311664285, 0.16251272264638916, 0.17382382111676176, 0.16419635381714837, 0.14525793019407252, 0.15822292884302647, 0.1666620410567624, 0.1586980835221662, 0.16194124409100985, 0.19761595001740784, 0.18784520300325735, 0.1945071097213259, 0.18189411975302106, 0.18440474108236105, 0.18494816835119565, 0.19182880353981513, 0.19222758520319982, 0.19867803134245687, 0.17676384629735387, 0.180977649483118, 0.1792723387390568, 0.17809003768452536, 0.17642268148475726, 0.18140421015843022, 0.1859001440838287, 0.17444197053441535, 0.17347647357064488, 0.21797498081645594, 0.24451143440678902, 0.22742593471067962, 0.27709451263785645, 0.27649594957169754, 0.211517461702451, 0.3366826057574279, 0.24208246360741825, 0.31364088870736306, 0.2698035055340351, 0.18516368463537758, 0.21181516901327546, 0.20913535070615308, 0.2320678061122775, 0.21361565728347398, 0.20805365355098415, 0.2964427551899559, 0.30697736954134114, 0.18476314099780045, 0.17618479847423774, 0.1972850149789469, 0.1922727813088566, 0.17937445702687005, 0.19182502251350564, 0.1905150686941921, 0.18328399343970125, 0.18405711750676534, 0.06799479994301294, 0.08268703975560254, 0.07421167810988716, 0.06818256862748018, 0.07168382116484084, 0.07242419562746505, 0.07494816592008369, 0.06990488309518439, 0.07093256766464906]}, "mutation_prompt": null}
{"id": "d678d7d4-2eaa-4969-82c5-c44d65325b39", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85  # Adjusted mutation factor for enhanced exploration\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(3, 6, self.population_size)  # Increased search iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)  # Adjusted perturbation for better local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)  # Adaptive opposition around mid-point\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Hybrid local search with adaptive probability\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.7:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing adaptive opposition and hybrid local search to accelerate convergence while maintaining diverse exploration.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.3077463200079953, 0.29800629202985396, 0.3025613883450171, 0.27060000676808615, 0.2964253163481396, 0.3139775566443388, 0.299689533340175, 0.2852803589865135, 0.30264009599547803, 0.030390373530886805, 0.022619902017002813, 0.05744768800337574, 0.022665187643416407, 0.022195674666327103, 0.028513928293954605, 0.03297552711165297, 0.038512374160619256, 0.06165542715695049, 0.09993005534542465, 0.10180310815625893, 0.09629099170821553, 0.09783416807060108, 0.1014471088962462, 0.10014467809949079, 0.09870180632984105, 0.10354004722757604, 0.09522959285025367, 0.08578432566353245, 0.0821955220488586, 0.08637978449951478, 0.09013304913308917, 0.08886658916793388, 0.09256766363142943, 0.08043763193193831, 0.08672009378035928, 0.08977870534806842, 0.4050114492967012, 0.5314024385859337, 0.35027454961845905, 0.41686022138508116, 0.4068927940498418, 0.3527118209195953, 0.33919465196930765, 0.4867638639301072, 0.3303767350560993, 0.0946337317676238, 0.11180378767878296, 0.1598312733474344, 0.12577925697277115, 0.09633577681971728, 0.08883473787463247, 0.13726660946641245, 0.1369245428341006, 0.12273296266741873, 0.20837197932348084, 0.16196334566232673, 0.1992613664863272, 0.20176968108776527, 0.20186820675468342, 0.20893907649120258, 0.1964563993712889, 0.2037196255505812, 0.17598002485325592, 0.06522698301884633, 0.08333539742339524, 0.07243358087909746, 0.06673057992411191, 0.07578717946068259, 0.08555571306861642, 0.0794883534914479, 0.09907256018648203, 0.07156790191190043, 0.06582649210988512, 0.07864057763779952, 0.09098668837343138, 0.1013120979331954, 0.06985443579283745, 0.0807632634149602, 0.0728990038062941, 0.09120043545518419, 0.08874793448271534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027381380250671605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10012850013535224, 0.09086467990256863, 0.09213120563736488, 0.09742740207871081, 0.11455789961260687, 0.0998825777597998, 0.10013619022648113, 0.09394430557175859, 0.10335848410808435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031006519457458692, 0.030840448987022318, 0.030815805181557687, 0.03115803173038456, 0.046711575916170256, 0.04460894322514941, 0.04729506665409977, 0.04104288171792503, 0.03413840419664316, 0.30921616727181367, 0.29057422648783693, 0.2967621429180982, 0.27764376008512703, 0.2955378620300333, 0.3026453617400586, 0.27741225865684305, 0.2953119171367573, 0.2919241388058428, 0.08355213951380558, 0.08860699937929317, 0.08386075129742787, 0.07246946252798425, 0.07122896366031672, 0.07219538361084687, 0.08327390753850505, 0.0805966186859689, 0.07551735838433249, 0.13385634043853167, 0.17180187713093076, 0.1675994334343346, 0.1660679929147666, 0.1645826807386389, 0.12833606853334678, 0.15136022848006436, 0.18518924731787145, 0.13610717811508966, 0.2150719156401838, 0.20821311466788328, 0.22742757466683539, 0.2082193784363049, 0.21475913033697014, 0.21323552027730808, 0.21895917694478773, 0.21878899369832427, 0.21800979920714636, 0.1549837311664285, 0.16251272264638916, 0.17382382111676176, 0.16419635381714837, 0.14525793019407252, 0.15822292884302647, 0.1666620410567624, 0.1586980835221662, 0.16194124409100985, 0.19761595001740784, 0.18784520300325735, 0.1945071097213259, 0.18189411975302106, 0.18440474108236105, 0.18494816835119565, 0.19182880353981513, 0.19222758520319982, 0.19867803134245687, 0.17676384629735387, 0.180977649483118, 0.1792723387390568, 0.17809003768452536, 0.17642268148475726, 0.18140421015843022, 0.1859001440838287, 0.17444197053441535, 0.17347647357064488, 0.21797498081645594, 0.24451143440678902, 0.22742593471067962, 0.27709451263785645, 0.27649594957169754, 0.211517461702451, 0.3366826057574279, 0.24208246360741825, 0.31364088870736306, 0.2698035055340351, 0.18516368463537758, 0.21181516901327546, 0.20913535070615308, 0.2320678061122775, 0.21361565728347398, 0.20805365355098415, 0.2964427551899559, 0.30697736954134114, 0.18476314099780045, 0.17618479847423774, 0.1972850149789469, 0.1922727813088566, 0.17937445702687005, 0.19182502251350564, 0.1905150686941921, 0.18328399343970125, 0.18405711750676534, 0.06799479994301294, 0.08268703975560254, 0.07421167810988716, 0.06818256862748018, 0.07168382116484084, 0.07242419562746505, 0.07494816592008369, 0.06990488309518439, 0.07093256766464906]}, "mutation_prompt": null}
{"id": "c7afa2fd-b761-4a5d-ab0a-9bb1234a1630", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.9  # Slightly increased for enhanced exploration\n        self.dynamic_scaling_factor = np.exp(np.linspace(-2, 0, self.population_size))  # New dynamic scaling\n        self.population_size = max(4, int(self.budget / (5 * dim)))  # Adjusted population size for better convergence\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.55, 0.95, self.population_size)  # Wider range for crossover\n        self.dynamic_mutation_factor = np.linspace(0.1, 0.5, self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(2, 7, self.population_size)  # Broadened search iterations\n        self.neighborhood_radius = 0.2  # Introduced parameter for neighborhood search\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_mutation_factor = self.mutation_factor * self.dynamic_mutation_factor[target_idx]\n        mutant_vector = self.population[a] + adaptive_mutation_factor * (\n            self.population[b] - self.population[c]) * self.dynamic_scaling_factor[target_idx]  # Dynamic scaling\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, self.neighborhood_radius, self.dim)  # Adaptive neighborhood search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)  # Adaptive opposition around mid-point\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Hybrid local search with adaptive probability\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.6:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introduced dynamic scaling factor and adaptive neighborhood search to enhance convergence speed while maintaining exploration.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'EnhancedDynamicDifferentialEvolution' object has no attribute 'population_size'\").", "error": "AttributeError(\"'EnhancedDynamicDifferentialEvolution' object has no attribute 'population_size'\")", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {}, "mutation_prompt": null}
{"id": "5c6eaf6a-16a7-48a6-b1f6-c2a680777d61", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85  # Adjusted mutation factor for enhanced exploration\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(3, 6, self.population_size)  # Increased search iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)  # Adjusted perturbation for better local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)  # Adaptive opposition around mid-point\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Hybrid local search with adaptive probability\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.7:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing adaptive opposition and hybrid local search to accelerate convergence while maintaining diverse exploration.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.3077463200079953, 0.29800629202985396, 0.3025613883450171, 0.27060000676808615, 0.2964253163481396, 0.3139775566443388, 0.299689533340175, 0.2852803589865135, 0.30264009599547803, 0.030390373530886805, 0.022619902017002813, 0.05744768800337574, 0.022665187643416407, 0.022195674666327103, 0.028513928293954605, 0.03297552711165297, 0.038512374160619256, 0.06165542715695049, 0.09993005534542465, 0.10180310815625893, 0.09629099170821553, 0.09783416807060108, 0.1014471088962462, 0.10014467809949079, 0.09870180632984105, 0.10354004722757604, 0.09522959285025367, 0.08578432566353245, 0.0821955220488586, 0.08637978449951478, 0.09013304913308917, 0.08886658916793388, 0.09256766363142943, 0.08043763193193831, 0.08672009378035928, 0.08977870534806842, 0.4050114492967012, 0.5314024385859337, 0.35027454961845905, 0.41686022138508116, 0.4068927940498418, 0.3527118209195953, 0.33919465196930765, 0.4867638639301072, 0.3303767350560993, 0.0946337317676238, 0.11180378767878296, 0.1598312733474344, 0.12577925697277115, 0.09633577681971728, 0.08883473787463247, 0.13726660946641245, 0.1369245428341006, 0.12273296266741873, 0.20837197932348084, 0.16196334566232673, 0.1992613664863272, 0.20176968108776527, 0.20186820675468342, 0.20893907649120258, 0.1964563993712889, 0.2037196255505812, 0.17598002485325592, 0.06522698301884633, 0.08333539742339524, 0.07243358087909746, 0.06673057992411191, 0.07578717946068259, 0.08555571306861642, 0.0794883534914479, 0.09907256018648203, 0.07156790191190043, 0.06582649210988512, 0.07864057763779952, 0.09098668837343138, 0.1013120979331954, 0.06985443579283745, 0.0807632634149602, 0.0728990038062941, 0.09120043545518419, 0.08874793448271534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027381380250671605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10012850013535224, 0.09086467990256863, 0.09213120563736488, 0.09742740207871081, 0.11455789961260687, 0.0998825777597998, 0.10013619022648113, 0.09394430557175859, 0.10335848410808435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031006519457458692, 0.030840448987022318, 0.030815805181557687, 0.03115803173038456, 0.046711575916170256, 0.04460894322514941, 0.04729506665409977, 0.04104288171792503, 0.03413840419664316, 0.30921616727181367, 0.29057422648783693, 0.2967621429180982, 0.27764376008512703, 0.2955378620300333, 0.3026453617400586, 0.27741225865684305, 0.2953119171367573, 0.2919241388058428, 0.08355213951380558, 0.08860699937929317, 0.08386075129742787, 0.07246946252798425, 0.07122896366031672, 0.07219538361084687, 0.08327390753850505, 0.0805966186859689, 0.07551735838433249, 0.13385634043853167, 0.17180187713093076, 0.1675994334343346, 0.1660679929147666, 0.1645826807386389, 0.12833606853334678, 0.15136022848006436, 0.18518924731787145, 0.13610717811508966, 0.2150719156401838, 0.20821311466788328, 0.22742757466683539, 0.2082193784363049, 0.21475913033697014, 0.21323552027730808, 0.21895917694478773, 0.21878899369832427, 0.21800979920714636, 0.1549837311664285, 0.16251272264638916, 0.17382382111676176, 0.16419635381714837, 0.14525793019407252, 0.15822292884302647, 0.1666620410567624, 0.1586980835221662, 0.16194124409100985, 0.19761595001740784, 0.18784520300325735, 0.1945071097213259, 0.18189411975302106, 0.18440474108236105, 0.18494816835119565, 0.19182880353981513, 0.19222758520319982, 0.19867803134245687, 0.17676384629735387, 0.180977649483118, 0.1792723387390568, 0.17809003768452536, 0.17642268148475726, 0.18140421015843022, 0.1859001440838287, 0.17444197053441535, 0.17347647357064488, 0.21797498081645594, 0.24451143440678902, 0.22742593471067962, 0.27709451263785645, 0.27649594957169754, 0.211517461702451, 0.3366826057574279, 0.24208246360741825, 0.31364088870736306, 0.2698035055340351, 0.18516368463537758, 0.21181516901327546, 0.20913535070615308, 0.2320678061122775, 0.21361565728347398, 0.20805365355098415, 0.2964427551899559, 0.30697736954134114, 0.18476314099780045, 0.17618479847423774, 0.1972850149789469, 0.1922727813088566, 0.17937445702687005, 0.19182502251350564, 0.1905150686941921, 0.18328399343970125, 0.18405711750676534, 0.06799479994301294, 0.08268703975560254, 0.07421167810988716, 0.06818256862748018, 0.07168382116484084, 0.07242419562746505, 0.07494816592008369, 0.06990488309518439, 0.07093256766464906]}, "mutation_prompt": null}
{"id": "6844c163-464d-4717-ab1b-61e97c27f04e", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85  # Adjusted mutation factor for enhanced exploration\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(3, 6, self.population_size)  # Increased search iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)  # Adjusted perturbation for better local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)  # Adaptive opposition around mid-point\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Hybrid local search with adaptive probability\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.7:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing adaptive opposition and hybrid local search to accelerate convergence while maintaining diverse exploration.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.3077463200079953, 0.29800629202985396, 0.3025613883450171, 0.27060000676808615, 0.2964253163481396, 0.3139775566443388, 0.299689533340175, 0.2852803589865135, 0.30264009599547803, 0.030390373530886805, 0.022619902017002813, 0.05744768800337574, 0.022665187643416407, 0.022195674666327103, 0.028513928293954605, 0.03297552711165297, 0.038512374160619256, 0.06165542715695049, 0.09993005534542465, 0.10180310815625893, 0.09629099170821553, 0.09783416807060108, 0.1014471088962462, 0.10014467809949079, 0.09870180632984105, 0.10354004722757604, 0.09522959285025367, 0.08578432566353245, 0.0821955220488586, 0.08637978449951478, 0.09013304913308917, 0.08886658916793388, 0.09256766363142943, 0.08043763193193831, 0.08672009378035928, 0.08977870534806842, 0.4050114492967012, 0.5314024385859337, 0.35027454961845905, 0.41686022138508116, 0.4068927940498418, 0.3527118209195953, 0.33919465196930765, 0.4867638639301072, 0.3303767350560993, 0.0946337317676238, 0.11180378767878296, 0.1598312733474344, 0.12577925697277115, 0.09633577681971728, 0.08883473787463247, 0.13726660946641245, 0.1369245428341006, 0.12273296266741873, 0.20837197932348084, 0.16196334566232673, 0.1992613664863272, 0.20176968108776527, 0.20186820675468342, 0.20893907649120258, 0.1964563993712889, 0.2037196255505812, 0.17598002485325592, 0.06522698301884633, 0.08333539742339524, 0.07243358087909746, 0.06673057992411191, 0.07578717946068259, 0.08555571306861642, 0.0794883534914479, 0.09907256018648203, 0.07156790191190043, 0.06582649210988512, 0.07864057763779952, 0.09098668837343138, 0.1013120979331954, 0.06985443579283745, 0.0807632634149602, 0.0728990038062941, 0.09120043545518419, 0.08874793448271534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027381380250671605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10012850013535224, 0.09086467990256863, 0.09213120563736488, 0.09742740207871081, 0.11455789961260687, 0.0998825777597998, 0.10013619022648113, 0.09394430557175859, 0.10335848410808435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031006519457458692, 0.030840448987022318, 0.030815805181557687, 0.03115803173038456, 0.046711575916170256, 0.04460894322514941, 0.04729506665409977, 0.04104288171792503, 0.03413840419664316, 0.30921616727181367, 0.29057422648783693, 0.2967621429180982, 0.27764376008512703, 0.2955378620300333, 0.3026453617400586, 0.27741225865684305, 0.2953119171367573, 0.2919241388058428, 0.08355213951380558, 0.08860699937929317, 0.08386075129742787, 0.07246946252798425, 0.07122896366031672, 0.07219538361084687, 0.08327390753850505, 0.0805966186859689, 0.07551735838433249, 0.13385634043853167, 0.17180187713093076, 0.1675994334343346, 0.1660679929147666, 0.1645826807386389, 0.12833606853334678, 0.15136022848006436, 0.18518924731787145, 0.13610717811508966, 0.2150719156401838, 0.20821311466788328, 0.22742757466683539, 0.2082193784363049, 0.21475913033697014, 0.21323552027730808, 0.21895917694478773, 0.21878899369832427, 0.21800979920714636, 0.1549837311664285, 0.16251272264638916, 0.17382382111676176, 0.16419635381714837, 0.14525793019407252, 0.15822292884302647, 0.1666620410567624, 0.1586980835221662, 0.16194124409100985, 0.19761595001740784, 0.18784520300325735, 0.1945071097213259, 0.18189411975302106, 0.18440474108236105, 0.18494816835119565, 0.19182880353981513, 0.19222758520319982, 0.19867803134245687, 0.17676384629735387, 0.180977649483118, 0.1792723387390568, 0.17809003768452536, 0.17642268148475726, 0.18140421015843022, 0.1859001440838287, 0.17444197053441535, 0.17347647357064488, 0.21797498081645594, 0.24451143440678902, 0.22742593471067962, 0.27709451263785645, 0.27649594957169754, 0.211517461702451, 0.3366826057574279, 0.24208246360741825, 0.31364088870736306, 0.2698035055340351, 0.18516368463537758, 0.21181516901327546, 0.20913535070615308, 0.2320678061122775, 0.21361565728347398, 0.20805365355098415, 0.2964427551899559, 0.30697736954134114, 0.18476314099780045, 0.17618479847423774, 0.1972850149789469, 0.1922727813088566, 0.17937445702687005, 0.19182502251350564, 0.1905150686941921, 0.18328399343970125, 0.18405711750676534, 0.06799479994301294, 0.08268703975560254, 0.07421167810988716, 0.06818256862748018, 0.07168382116484084, 0.07242419562746505, 0.07494816592008369, 0.06990488309518439, 0.07093256766464906]}, "mutation_prompt": null}
{"id": "55012397-c5ce-4c98-927f-ca65fcb95b8a", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85  # Adjusted mutation factor for enhanced exploration\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(3, 6, self.population_size)  # Increased search iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)  # Adjusted perturbation for better local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)  # Adaptive opposition around mid-point\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Hybrid local search with adaptive probability\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.7:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing adaptive opposition and hybrid local search to accelerate convergence while maintaining diverse exploration.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.3077463200079953, 0.29800629202985396, 0.3025613883450171, 0.27060000676808615, 0.2964253163481396, 0.3139775566443388, 0.299689533340175, 0.2852803589865135, 0.30264009599547803, 0.030390373530886805, 0.022619902017002813, 0.05744768800337574, 0.022665187643416407, 0.022195674666327103, 0.028513928293954605, 0.03297552711165297, 0.038512374160619256, 0.06165542715695049, 0.09993005534542465, 0.10180310815625893, 0.09629099170821553, 0.09783416807060108, 0.1014471088962462, 0.10014467809949079, 0.09870180632984105, 0.10354004722757604, 0.09522959285025367, 0.08578432566353245, 0.0821955220488586, 0.08637978449951478, 0.09013304913308917, 0.08886658916793388, 0.09256766363142943, 0.08043763193193831, 0.08672009378035928, 0.08977870534806842, 0.4050114492967012, 0.5314024385859337, 0.35027454961845905, 0.41686022138508116, 0.4068927940498418, 0.3527118209195953, 0.33919465196930765, 0.4867638639301072, 0.3303767350560993, 0.0946337317676238, 0.11180378767878296, 0.1598312733474344, 0.12577925697277115, 0.09633577681971728, 0.08883473787463247, 0.13726660946641245, 0.1369245428341006, 0.12273296266741873, 0.20837197932348084, 0.16196334566232673, 0.1992613664863272, 0.20176968108776527, 0.20186820675468342, 0.20893907649120258, 0.1964563993712889, 0.2037196255505812, 0.17598002485325592, 0.06522698301884633, 0.08333539742339524, 0.07243358087909746, 0.06673057992411191, 0.07578717946068259, 0.08555571306861642, 0.0794883534914479, 0.09907256018648203, 0.07156790191190043, 0.06582649210988512, 0.07864057763779952, 0.09098668837343138, 0.1013120979331954, 0.06985443579283745, 0.0807632634149602, 0.0728990038062941, 0.09120043545518419, 0.08874793448271534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027381380250671605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10012850013535224, 0.09086467990256863, 0.09213120563736488, 0.09742740207871081, 0.11455789961260687, 0.0998825777597998, 0.10013619022648113, 0.09394430557175859, 0.10335848410808435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031006519457458692, 0.030840448987022318, 0.030815805181557687, 0.03115803173038456, 0.046711575916170256, 0.04460894322514941, 0.04729506665409977, 0.04104288171792503, 0.03413840419664316, 0.30921616727181367, 0.29057422648783693, 0.2967621429180982, 0.27764376008512703, 0.2955378620300333, 0.3026453617400586, 0.27741225865684305, 0.2953119171367573, 0.2919241388058428, 0.08355213951380558, 0.08860699937929317, 0.08386075129742787, 0.07246946252798425, 0.07122896366031672, 0.07219538361084687, 0.08327390753850505, 0.0805966186859689, 0.07551735838433249, 0.13385634043853167, 0.17180187713093076, 0.1675994334343346, 0.1660679929147666, 0.1645826807386389, 0.12833606853334678, 0.15136022848006436, 0.18518924731787145, 0.13610717811508966, 0.2150719156401838, 0.20821311466788328, 0.22742757466683539, 0.2082193784363049, 0.21475913033697014, 0.21323552027730808, 0.21895917694478773, 0.21878899369832427, 0.21800979920714636, 0.1549837311664285, 0.16251272264638916, 0.17382382111676176, 0.16419635381714837, 0.14525793019407252, 0.15822292884302647, 0.1666620410567624, 0.1586980835221662, 0.16194124409100985, 0.19761595001740784, 0.18784520300325735, 0.1945071097213259, 0.18189411975302106, 0.18440474108236105, 0.18494816835119565, 0.19182880353981513, 0.19222758520319982, 0.19867803134245687, 0.17676384629735387, 0.180977649483118, 0.1792723387390568, 0.17809003768452536, 0.17642268148475726, 0.18140421015843022, 0.1859001440838287, 0.17444197053441535, 0.17347647357064488, 0.21797498081645594, 0.24451143440678902, 0.22742593471067962, 0.27709451263785645, 0.27649594957169754, 0.211517461702451, 0.3366826057574279, 0.24208246360741825, 0.31364088870736306, 0.2698035055340351, 0.18516368463537758, 0.21181516901327546, 0.20913535070615308, 0.2320678061122775, 0.21361565728347398, 0.20805365355098415, 0.2964427551899559, 0.30697736954134114, 0.18476314099780045, 0.17618479847423774, 0.1972850149789469, 0.1922727813088566, 0.17937445702687005, 0.19182502251350564, 0.1905150686941921, 0.18328399343970125, 0.18405711750676534, 0.06799479994301294, 0.08268703975560254, 0.07421167810988716, 0.06818256862748018, 0.07168382116484084, 0.07242419562746505, 0.07494816592008369, 0.06990488309518439, 0.07093256766464906]}, "mutation_prompt": null}
{"id": "f4909291-4b13-4e32-bb35-c068ce222e25", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85  # Adjusted mutation factor for enhanced exploration\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(3, 6, self.population_size)  # Increased search iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)  # Adjusted perturbation for better local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)  # Adaptive opposition around mid-point\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Hybrid local search with adaptive probability\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.7:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing adaptive opposition and hybrid local search to accelerate convergence while maintaining diverse exploration.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.3077463200079953, 0.29800629202985396, 0.3025613883450171, 0.27060000676808615, 0.2964253163481396, 0.3139775566443388, 0.299689533340175, 0.2852803589865135, 0.30264009599547803, 0.030390373530886805, 0.022619902017002813, 0.05744768800337574, 0.022665187643416407, 0.022195674666327103, 0.028513928293954605, 0.03297552711165297, 0.038512374160619256, 0.06165542715695049, 0.09993005534542465, 0.10180310815625893, 0.09629099170821553, 0.09783416807060108, 0.1014471088962462, 0.10014467809949079, 0.09870180632984105, 0.10354004722757604, 0.09522959285025367, 0.08578432566353245, 0.0821955220488586, 0.08637978449951478, 0.09013304913308917, 0.08886658916793388, 0.09256766363142943, 0.08043763193193831, 0.08672009378035928, 0.08977870534806842, 0.4050114492967012, 0.5314024385859337, 0.35027454961845905, 0.41686022138508116, 0.4068927940498418, 0.3527118209195953, 0.33919465196930765, 0.4867638639301072, 0.3303767350560993, 0.0946337317676238, 0.11180378767878296, 0.1598312733474344, 0.12577925697277115, 0.09633577681971728, 0.08883473787463247, 0.13726660946641245, 0.1369245428341006, 0.12273296266741873, 0.20837197932348084, 0.16196334566232673, 0.1992613664863272, 0.20176968108776527, 0.20186820675468342, 0.20893907649120258, 0.1964563993712889, 0.2037196255505812, 0.17598002485325592, 0.06522698301884633, 0.08333539742339524, 0.07243358087909746, 0.06673057992411191, 0.07578717946068259, 0.08555571306861642, 0.0794883534914479, 0.09907256018648203, 0.07156790191190043, 0.06582649210988512, 0.07864057763779952, 0.09098668837343138, 0.1013120979331954, 0.06985443579283745, 0.0807632634149602, 0.0728990038062941, 0.09120043545518419, 0.08874793448271534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027381380250671605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10012850013535224, 0.09086467990256863, 0.09213120563736488, 0.09742740207871081, 0.11455789961260687, 0.0998825777597998, 0.10013619022648113, 0.09394430557175859, 0.10335848410808435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031006519457458692, 0.030840448987022318, 0.030815805181557687, 0.03115803173038456, 0.046711575916170256, 0.04460894322514941, 0.04729506665409977, 0.04104288171792503, 0.03413840419664316, 0.30921616727181367, 0.29057422648783693, 0.2967621429180982, 0.27764376008512703, 0.2955378620300333, 0.3026453617400586, 0.27741225865684305, 0.2953119171367573, 0.2919241388058428, 0.08355213951380558, 0.08860699937929317, 0.08386075129742787, 0.07246946252798425, 0.07122896366031672, 0.07219538361084687, 0.08327390753850505, 0.0805966186859689, 0.07551735838433249, 0.13385634043853167, 0.17180187713093076, 0.1675994334343346, 0.1660679929147666, 0.1645826807386389, 0.12833606853334678, 0.15136022848006436, 0.18518924731787145, 0.13610717811508966, 0.2150719156401838, 0.20821311466788328, 0.22742757466683539, 0.2082193784363049, 0.21475913033697014, 0.21323552027730808, 0.21895917694478773, 0.21878899369832427, 0.21800979920714636, 0.1549837311664285, 0.16251272264638916, 0.17382382111676176, 0.16419635381714837, 0.14525793019407252, 0.15822292884302647, 0.1666620410567624, 0.1586980835221662, 0.16194124409100985, 0.19761595001740784, 0.18784520300325735, 0.1945071097213259, 0.18189411975302106, 0.18440474108236105, 0.18494816835119565, 0.19182880353981513, 0.19222758520319982, 0.19867803134245687, 0.17676384629735387, 0.180977649483118, 0.1792723387390568, 0.17809003768452536, 0.17642268148475726, 0.18140421015843022, 0.1859001440838287, 0.17444197053441535, 0.17347647357064488, 0.21797498081645594, 0.24451143440678902, 0.22742593471067962, 0.27709451263785645, 0.27649594957169754, 0.211517461702451, 0.3366826057574279, 0.24208246360741825, 0.31364088870736306, 0.2698035055340351, 0.18516368463537758, 0.21181516901327546, 0.20913535070615308, 0.2320678061122775, 0.21361565728347398, 0.20805365355098415, 0.2964427551899559, 0.30697736954134114, 0.18476314099780045, 0.17618479847423774, 0.1972850149789469, 0.1922727813088566, 0.17937445702687005, 0.19182502251350564, 0.1905150686941921, 0.18328399343970125, 0.18405711750676534, 0.06799479994301294, 0.08268703975560254, 0.07421167810988716, 0.06818256862748018, 0.07168382116484084, 0.07242419562746505, 0.07494816592008369, 0.06990488309518439, 0.07093256766464906]}, "mutation_prompt": null}
{"id": "91c8a2da-e06e-4ad0-846c-1afd493fdfe6", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85  # Adjusted mutation factor for enhanced exploration\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(3, 6, self.population_size)  # Increased search iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)  # Adjusted perturbation for better local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)  # Adaptive opposition around mid-point\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Hybrid local search with adaptive probability\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.7:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing adaptive opposition and hybrid local search to accelerate convergence while maintaining diverse exploration.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.3077463200079953, 0.29800629202985396, 0.3025613883450171, 0.27060000676808615, 0.2964253163481396, 0.3139775566443388, 0.299689533340175, 0.2852803589865135, 0.30264009599547803, 0.030390373530886805, 0.022619902017002813, 0.05744768800337574, 0.022665187643416407, 0.022195674666327103, 0.028513928293954605, 0.03297552711165297, 0.038512374160619256, 0.06165542715695049, 0.09993005534542465, 0.10180310815625893, 0.09629099170821553, 0.09783416807060108, 0.1014471088962462, 0.10014467809949079, 0.09870180632984105, 0.10354004722757604, 0.09522959285025367, 0.08578432566353245, 0.0821955220488586, 0.08637978449951478, 0.09013304913308917, 0.08886658916793388, 0.09256766363142943, 0.08043763193193831, 0.08672009378035928, 0.08977870534806842, 0.4050114492967012, 0.5314024385859337, 0.35027454961845905, 0.41686022138508116, 0.4068927940498418, 0.3527118209195953, 0.33919465196930765, 0.4867638639301072, 0.3303767350560993, 0.0946337317676238, 0.11180378767878296, 0.1598312733474344, 0.12577925697277115, 0.09633577681971728, 0.08883473787463247, 0.13726660946641245, 0.1369245428341006, 0.12273296266741873, 0.20837197932348084, 0.16196334566232673, 0.1992613664863272, 0.20176968108776527, 0.20186820675468342, 0.20893907649120258, 0.1964563993712889, 0.2037196255505812, 0.17598002485325592, 0.06522698301884633, 0.08333539742339524, 0.07243358087909746, 0.06673057992411191, 0.07578717946068259, 0.08555571306861642, 0.0794883534914479, 0.09907256018648203, 0.07156790191190043, 0.06582649210988512, 0.07864057763779952, 0.09098668837343138, 0.1013120979331954, 0.06985443579283745, 0.0807632634149602, 0.0728990038062941, 0.09120043545518419, 0.08874793448271534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027381380250671605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10012850013535224, 0.09086467990256863, 0.09213120563736488, 0.09742740207871081, 0.11455789961260687, 0.0998825777597998, 0.10013619022648113, 0.09394430557175859, 0.10335848410808435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031006519457458692, 0.030840448987022318, 0.030815805181557687, 0.03115803173038456, 0.046711575916170256, 0.04460894322514941, 0.04729506665409977, 0.04104288171792503, 0.03413840419664316, 0.30921616727181367, 0.29057422648783693, 0.2967621429180982, 0.27764376008512703, 0.2955378620300333, 0.3026453617400586, 0.27741225865684305, 0.2953119171367573, 0.2919241388058428, 0.08355213951380558, 0.08860699937929317, 0.08386075129742787, 0.07246946252798425, 0.07122896366031672, 0.07219538361084687, 0.08327390753850505, 0.0805966186859689, 0.07551735838433249, 0.13385634043853167, 0.17180187713093076, 0.1675994334343346, 0.1660679929147666, 0.1645826807386389, 0.12833606853334678, 0.15136022848006436, 0.18518924731787145, 0.13610717811508966, 0.2150719156401838, 0.20821311466788328, 0.22742757466683539, 0.2082193784363049, 0.21475913033697014, 0.21323552027730808, 0.21895917694478773, 0.21878899369832427, 0.21800979920714636, 0.1549837311664285, 0.16251272264638916, 0.17382382111676176, 0.16419635381714837, 0.14525793019407252, 0.15822292884302647, 0.1666620410567624, 0.1586980835221662, 0.16194124409100985, 0.19761595001740784, 0.18784520300325735, 0.1945071097213259, 0.18189411975302106, 0.18440474108236105, 0.18494816835119565, 0.19182880353981513, 0.19222758520319982, 0.19867803134245687, 0.17676384629735387, 0.180977649483118, 0.1792723387390568, 0.17809003768452536, 0.17642268148475726, 0.18140421015843022, 0.1859001440838287, 0.17444197053441535, 0.17347647357064488, 0.21797498081645594, 0.24451143440678902, 0.22742593471067962, 0.27709451263785645, 0.27649594957169754, 0.211517461702451, 0.3366826057574279, 0.24208246360741825, 0.31364088870736306, 0.2698035055340351, 0.18516368463537758, 0.21181516901327546, 0.20913535070615308, 0.2320678061122775, 0.21361565728347398, 0.20805365355098415, 0.2964427551899559, 0.30697736954134114, 0.18476314099780045, 0.17618479847423774, 0.1972850149789469, 0.1922727813088566, 0.17937445702687005, 0.19182502251350564, 0.1905150686941921, 0.18328399343970125, 0.18405711750676534, 0.06799479994301294, 0.08268703975560254, 0.07421167810988716, 0.06818256862748018, 0.07168382116484084, 0.07242419562746505, 0.07494816592008369, 0.06990488309518439, 0.07093256766464906]}, "mutation_prompt": null}
{"id": "bca57b0f-96c0-4574-bd1c-eccf2b668d6d", "solution": "import numpy as np\n\nclass EnhancedChaoticCoEvolutionaryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8  # Slightly adjusted mutation factor\n        self.population_scaling = 0.5 + (0.4 * np.random.rand())  # Adjusted for more diversity\n        self.population_size = int(self.budget / (5 * dim))  # Adjusted size for faster convergence\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.5, 0.9, self.population_size)  # Broadened range for exploration\n        self.dynamic_mutation_factor = self._init_chaotic_map(self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(2, 5, self.population_size)  # Adjusted iterations\n        self.subgroup_cooperation_factor = 0.3  # Cooperation factor for co-evolution\n\n    def _init_chaotic_map(self, size):\n        return np.sin(np.linspace(0, np.pi, size))  # Chaotic map initialization for better exploration\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def _cooperative_co_evolution(self, func):\n        subgroup_size = max(1, self.population_size // 3)\n        for i in range(0, self.population_size, subgroup_size):\n            subgroup = self.population[i:i + subgroup_size]\n            subgroup_scores = [func(ind) for ind in subgroup]\n            best_in_subgroup = subgroup[np.argmin(subgroup_scores)]\n            self.population[i:i + subgroup_size] = subgroup * (1 - self.subgroup_cooperation_factor) + best_in_subgroup * self.subgroup_cooperation_factor\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            self._cooperative_co_evolution(func)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.65:  # Adjusted for more exploration\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedChaoticCoEvolutionaryDifferentialEvolution", "description": "Augment exploration and convergence by integrating chaotic maps for dynamic parameter adaptation and incorporating cooperative co-evolution strategies.", "configspace": "", "generation": 75, "fitness": 0.12783131594510075, "feedback": "The algorithm EnhancedChaoticCoEvolutionaryDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.08.", "error": "", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.258730247250745, 0.25030209998923647, 0.2552402463355926, 0.2512532971919883, 0.2521304929935748, 0.23688779472201227, 0.2610911129220672, 0.25423733134288007, 0.261080144880643, 0.014342070865571488, 9.999999999998899e-05, 0.003102549556197265, 9.999999999998899e-05, 0.00027715302116615437, 0.0020384212385855527, 9.999999999998899e-05, 0.0026839546198247355, 9.999999999998899e-05, 0.08894154121242648, 0.07130345607177946, 0.07629288620153274, 0.08107955871382544, 0.08489830684416522, 0.0770300534519438, 0.08025053900381995, 0.09105257667283129, 0.07989045208192636, 0.0648527438921026, 0.06170567108231373, 0.05498230042691088, 0.05527886844203089, 0.05904846448183321, 0.06611889892082545, 0.06571074838498392, 0.06115683889090251, 0.06556164975671108, 0.10089416996977052, 0.1269714122511426, 0.11754023769812172, 0.12695154507874518, 0.09843626021673213, 0.11466304917723158, 0.10260908227681242, 0.13027596997547775, 0.11015874976878481, 0.12031116231693684, 0.1270540970917371, 0.12209938503609552, 0.11329439673336039, 0.1063275426411201, 0.11274731283091899, 0.12675799640569607, 0.1653692417787812, 0.11008681930027342, 0.16729499463483866, 0.19881105399500032, 0.1909795095136263, 0.2085917895165802, 0.21018758086788036, 0.1883310871796725, 0.19906080183171948, 0.20856526913467865, 0.22069782933277915, 0.07147008038680747, 0.06234829847559109, 0.05865035182698142, 0.06015908132892578, 0.07868247415574658, 0.06500252997692169, 0.07441038577422698, 0.07279616479829598, 0.08095830235561352, 0.05747077194384165, 0.053731819142317394, 0.08802417062619694, 0.06984422062973694, 0.0666831694930754, 0.07879178094551786, 0.06579732673380001, 0.06818972804070722, 0.07700542467245486, 9.999999999998899e-05, 0.0010365771201057417, 9.999999999998899e-05, 0.0034661845014990478, 0.003987309830354335, 0.0009355979569681816, 0.0033063056005414593, 0.0022320697108876297, 0.027268633289940003, 0.08411254488207742, 0.123376438651981, 0.11163845989722632, 0.09583296166113198, 0.09626194361833496, 0.06342957533341176, 0.09782956613765015, 0.12908988098096974, 0.11619287324686889, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03879946606319573, 0.020095657878824058, 0.025588629913439354, 0.0335549144769971, 0.029131228303314827, 0.029665165513507286, 0.027373489063186263, 0.03268888947142645, 0.022665744297745705, 0.2712085462615793, 0.2705056432073185, 0.27309782606201394, 0.2542735485326879, 0.2480525374348418, 0.26694036341809746, 0.27019462693152074, 0.26049880745221865, 0.2732573759453534, 0.06915946988511901, 0.07271418241291705, 0.07784905494036298, 0.08163741933523272, 0.07926800048905969, 0.07927115108985294, 0.09061290979987391, 0.07917469590816617, 0.08271501914944879, 0.1782442085951892, 0.13961857281778212, 0.1554929352121418, 0.13834382231903675, 0.15063454710023982, 0.14060187243259248, 0.14695911659691152, 0.14750910685316376, 0.14667581757217119, 0.20115580267416655, 0.20713828945904467, 0.21297485580119413, 0.20948829569797667, 0.20681746465765205, 0.21870134105132155, 0.2189730041078466, 0.217269889614079, 0.20182652394800193, 0.15183119513928378, 0.1535700102317722, 0.1599047424292085, 0.14661523755240835, 0.16230858202650922, 0.16781070676409093, 0.15464453432988357, 0.13494550212094114, 0.13570871953235364, 0.18462216359220296, 0.19161819544553327, 0.18414685151752397, 0.18747518255298612, 0.18873510772882796, 0.19499207546107777, 0.18521735155155716, 0.18367461848148858, 0.1961273545002007, 0.17973802575051612, 0.16322712534145944, 0.16154221387962409, 0.16679551181734464, 0.1727600650276372, 0.16076252625430298, 0.1667206012268987, 0.1611906934152597, 0.16644070866025684, 0.3078116989023548, 0.1695520973616036, 0.1804390467079232, 0.24888541980880285, 0.3213388000071635, 0.2432642233518667, 0.2878496909531343, 0.3235143377414733, 0.33406783607512347, 0.3306566737369141, 0.23953134967766687, 0.17562531692196592, 0.2357359410025237, 0.15872543522598626, 0.22101083838581304, 0.22532920124430067, 0.2612698771412898, 0.1468604794632925, 0.20889223124583922, 0.18186489259666072, 0.1662831598700799, 0.18770997337751905, 0.17911147805918115, 0.17424704860031293, 0.17517246604197412, 0.18342557230115442, 0.18908030699172573, 0.07261298108975667, 0.07856868458502575, 0.08333851404302861, 0.07144782745887046, 0.07051067006599954, 0.07502375572587205, 0.06979027956601203, 0.06863406062536537, 0.07770282436505382]}, "mutation_prompt": null}
{"id": "3bd51032-5fa6-45f6-b5c4-78b7e14f39bc", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85  # Adjusted mutation factor for enhanced exploration\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(3, 6, self.population_size)  # Increased search iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)  # Adjusted perturbation for better local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)  # Adaptive opposition around mid-point\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Hybrid local search with adaptive probability\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.7:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing adaptive opposition and hybrid local search to accelerate convergence while maintaining diverse exploration.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.3077463200079953, 0.29800629202985396, 0.3025613883450171, 0.27060000676808615, 0.2964253163481396, 0.3139775566443388, 0.299689533340175, 0.2852803589865135, 0.30264009599547803, 0.030390373530886805, 0.022619902017002813, 0.05744768800337574, 0.022665187643416407, 0.022195674666327103, 0.028513928293954605, 0.03297552711165297, 0.038512374160619256, 0.06165542715695049, 0.09993005534542465, 0.10180310815625893, 0.09629099170821553, 0.09783416807060108, 0.1014471088962462, 0.10014467809949079, 0.09870180632984105, 0.10354004722757604, 0.09522959285025367, 0.08578432566353245, 0.0821955220488586, 0.08637978449951478, 0.09013304913308917, 0.08886658916793388, 0.09256766363142943, 0.08043763193193831, 0.08672009378035928, 0.08977870534806842, 0.4050114492967012, 0.5314024385859337, 0.35027454961845905, 0.41686022138508116, 0.4068927940498418, 0.3527118209195953, 0.33919465196930765, 0.4867638639301072, 0.3303767350560993, 0.0946337317676238, 0.11180378767878296, 0.1598312733474344, 0.12577925697277115, 0.09633577681971728, 0.08883473787463247, 0.13726660946641245, 0.1369245428341006, 0.12273296266741873, 0.20837197932348084, 0.16196334566232673, 0.1992613664863272, 0.20176968108776527, 0.20186820675468342, 0.20893907649120258, 0.1964563993712889, 0.2037196255505812, 0.17598002485325592, 0.06522698301884633, 0.08333539742339524, 0.07243358087909746, 0.06673057992411191, 0.07578717946068259, 0.08555571306861642, 0.0794883534914479, 0.09907256018648203, 0.07156790191190043, 0.06582649210988512, 0.07864057763779952, 0.09098668837343138, 0.1013120979331954, 0.06985443579283745, 0.0807632634149602, 0.0728990038062941, 0.09120043545518419, 0.08874793448271534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027381380250671605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10012850013535224, 0.09086467990256863, 0.09213120563736488, 0.09742740207871081, 0.11455789961260687, 0.0998825777597998, 0.10013619022648113, 0.09394430557175859, 0.10335848410808435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031006519457458692, 0.030840448987022318, 0.030815805181557687, 0.03115803173038456, 0.046711575916170256, 0.04460894322514941, 0.04729506665409977, 0.04104288171792503, 0.03413840419664316, 0.30921616727181367, 0.29057422648783693, 0.2967621429180982, 0.27764376008512703, 0.2955378620300333, 0.3026453617400586, 0.27741225865684305, 0.2953119171367573, 0.2919241388058428, 0.08355213951380558, 0.08860699937929317, 0.08386075129742787, 0.07246946252798425, 0.07122896366031672, 0.07219538361084687, 0.08327390753850505, 0.0805966186859689, 0.07551735838433249, 0.13385634043853167, 0.17180187713093076, 0.1675994334343346, 0.1660679929147666, 0.1645826807386389, 0.12833606853334678, 0.15136022848006436, 0.18518924731787145, 0.13610717811508966, 0.2150719156401838, 0.20821311466788328, 0.22742757466683539, 0.2082193784363049, 0.21475913033697014, 0.21323552027730808, 0.21895917694478773, 0.21878899369832427, 0.21800979920714636, 0.1549837311664285, 0.16251272264638916, 0.17382382111676176, 0.16419635381714837, 0.14525793019407252, 0.15822292884302647, 0.1666620410567624, 0.1586980835221662, 0.16194124409100985, 0.19761595001740784, 0.18784520300325735, 0.1945071097213259, 0.18189411975302106, 0.18440474108236105, 0.18494816835119565, 0.19182880353981513, 0.19222758520319982, 0.19867803134245687, 0.17676384629735387, 0.180977649483118, 0.1792723387390568, 0.17809003768452536, 0.17642268148475726, 0.18140421015843022, 0.1859001440838287, 0.17444197053441535, 0.17347647357064488, 0.21797498081645594, 0.24451143440678902, 0.22742593471067962, 0.27709451263785645, 0.27649594957169754, 0.211517461702451, 0.3366826057574279, 0.24208246360741825, 0.31364088870736306, 0.2698035055340351, 0.18516368463537758, 0.21181516901327546, 0.20913535070615308, 0.2320678061122775, 0.21361565728347398, 0.20805365355098415, 0.2964427551899559, 0.30697736954134114, 0.18476314099780045, 0.17618479847423774, 0.1972850149789469, 0.1922727813088566, 0.17937445702687005, 0.19182502251350564, 0.1905150686941921, 0.18328399343970125, 0.18405711750676534, 0.06799479994301294, 0.08268703975560254, 0.07421167810988716, 0.06818256862748018, 0.07168382116484084, 0.07242419562746505, 0.07494816592008369, 0.06990488309518439, 0.07093256766464906]}, "mutation_prompt": null}
{"id": "4b56beef-c62b-48a4-8bef-e7a3bf014ac3", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85  # Adjusted mutation factor for enhanced exploration\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(3, 6, self.population_size)  # Increased search iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)  # Adjusted perturbation for better local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)  # Adaptive opposition around mid-point\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Hybrid local search with adaptive probability\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.7:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing adaptive opposition and hybrid local search to accelerate convergence while maintaining diverse exploration.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.3077463200079953, 0.29800629202985396, 0.3025613883450171, 0.27060000676808615, 0.2964253163481396, 0.3139775566443388, 0.299689533340175, 0.2852803589865135, 0.30264009599547803, 0.030390373530886805, 0.022619902017002813, 0.05744768800337574, 0.022665187643416407, 0.022195674666327103, 0.028513928293954605, 0.03297552711165297, 0.038512374160619256, 0.06165542715695049, 0.09993005534542465, 0.10180310815625893, 0.09629099170821553, 0.09783416807060108, 0.1014471088962462, 0.10014467809949079, 0.09870180632984105, 0.10354004722757604, 0.09522959285025367, 0.08578432566353245, 0.0821955220488586, 0.08637978449951478, 0.09013304913308917, 0.08886658916793388, 0.09256766363142943, 0.08043763193193831, 0.08672009378035928, 0.08977870534806842, 0.4050114492967012, 0.5314024385859337, 0.35027454961845905, 0.41686022138508116, 0.4068927940498418, 0.3527118209195953, 0.33919465196930765, 0.4867638639301072, 0.3303767350560993, 0.0946337317676238, 0.11180378767878296, 0.1598312733474344, 0.12577925697277115, 0.09633577681971728, 0.08883473787463247, 0.13726660946641245, 0.1369245428341006, 0.12273296266741873, 0.20837197932348084, 0.16196334566232673, 0.1992613664863272, 0.20176968108776527, 0.20186820675468342, 0.20893907649120258, 0.1964563993712889, 0.2037196255505812, 0.17598002485325592, 0.06522698301884633, 0.08333539742339524, 0.07243358087909746, 0.06673057992411191, 0.07578717946068259, 0.08555571306861642, 0.0794883534914479, 0.09907256018648203, 0.07156790191190043, 0.06582649210988512, 0.07864057763779952, 0.09098668837343138, 0.1013120979331954, 0.06985443579283745, 0.0807632634149602, 0.0728990038062941, 0.09120043545518419, 0.08874793448271534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027381380250671605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10012850013535224, 0.09086467990256863, 0.09213120563736488, 0.09742740207871081, 0.11455789961260687, 0.0998825777597998, 0.10013619022648113, 0.09394430557175859, 0.10335848410808435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031006519457458692, 0.030840448987022318, 0.030815805181557687, 0.03115803173038456, 0.046711575916170256, 0.04460894322514941, 0.04729506665409977, 0.04104288171792503, 0.03413840419664316, 0.30921616727181367, 0.29057422648783693, 0.2967621429180982, 0.27764376008512703, 0.2955378620300333, 0.3026453617400586, 0.27741225865684305, 0.2953119171367573, 0.2919241388058428, 0.08355213951380558, 0.08860699937929317, 0.08386075129742787, 0.07246946252798425, 0.07122896366031672, 0.07219538361084687, 0.08327390753850505, 0.0805966186859689, 0.07551735838433249, 0.13385634043853167, 0.17180187713093076, 0.1675994334343346, 0.1660679929147666, 0.1645826807386389, 0.12833606853334678, 0.15136022848006436, 0.18518924731787145, 0.13610717811508966, 0.2150719156401838, 0.20821311466788328, 0.22742757466683539, 0.2082193784363049, 0.21475913033697014, 0.21323552027730808, 0.21895917694478773, 0.21878899369832427, 0.21800979920714636, 0.1549837311664285, 0.16251272264638916, 0.17382382111676176, 0.16419635381714837, 0.14525793019407252, 0.15822292884302647, 0.1666620410567624, 0.1586980835221662, 0.16194124409100985, 0.19761595001740784, 0.18784520300325735, 0.1945071097213259, 0.18189411975302106, 0.18440474108236105, 0.18494816835119565, 0.19182880353981513, 0.19222758520319982, 0.19867803134245687, 0.17676384629735387, 0.180977649483118, 0.1792723387390568, 0.17809003768452536, 0.17642268148475726, 0.18140421015843022, 0.1859001440838287, 0.17444197053441535, 0.17347647357064488, 0.21797498081645594, 0.24451143440678902, 0.22742593471067962, 0.27709451263785645, 0.27649594957169754, 0.211517461702451, 0.3366826057574279, 0.24208246360741825, 0.31364088870736306, 0.2698035055340351, 0.18516368463537758, 0.21181516901327546, 0.20913535070615308, 0.2320678061122775, 0.21361565728347398, 0.20805365355098415, 0.2964427551899559, 0.30697736954134114, 0.18476314099780045, 0.17618479847423774, 0.1972850149789469, 0.1922727813088566, 0.17937445702687005, 0.19182502251350564, 0.1905150686941921, 0.18328399343970125, 0.18405711750676534, 0.06799479994301294, 0.08268703975560254, 0.07421167810988716, 0.06818256862748018, 0.07168382116484084, 0.07242419562746505, 0.07494816592008369, 0.06990488309518439, 0.07093256766464906]}, "mutation_prompt": null}
{"id": "d12a5323-d03b-4d88-8cc6-84e6cae92453", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85  # Adjusted mutation factor for enhanced exploration\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(3, 6, self.population_size)  # Increased search iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)  # Adjusted perturbation for better local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)  # Adaptive opposition around mid-point\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Hybrid local search with adaptive probability\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.7:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing adaptive opposition and hybrid local search to accelerate convergence while maintaining diverse exploration.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.3077463200079953, 0.29800629202985396, 0.3025613883450171, 0.27060000676808615, 0.2964253163481396, 0.3139775566443388, 0.299689533340175, 0.2852803589865135, 0.30264009599547803, 0.030390373530886805, 0.022619902017002813, 0.05744768800337574, 0.022665187643416407, 0.022195674666327103, 0.028513928293954605, 0.03297552711165297, 0.038512374160619256, 0.06165542715695049, 0.09993005534542465, 0.10180310815625893, 0.09629099170821553, 0.09783416807060108, 0.1014471088962462, 0.10014467809949079, 0.09870180632984105, 0.10354004722757604, 0.09522959285025367, 0.08578432566353245, 0.0821955220488586, 0.08637978449951478, 0.09013304913308917, 0.08886658916793388, 0.09256766363142943, 0.08043763193193831, 0.08672009378035928, 0.08977870534806842, 0.4050114492967012, 0.5314024385859337, 0.35027454961845905, 0.41686022138508116, 0.4068927940498418, 0.3527118209195953, 0.33919465196930765, 0.4867638639301072, 0.3303767350560993, 0.0946337317676238, 0.11180378767878296, 0.1598312733474344, 0.12577925697277115, 0.09633577681971728, 0.08883473787463247, 0.13726660946641245, 0.1369245428341006, 0.12273296266741873, 0.20837197932348084, 0.16196334566232673, 0.1992613664863272, 0.20176968108776527, 0.20186820675468342, 0.20893907649120258, 0.1964563993712889, 0.2037196255505812, 0.17598002485325592, 0.06522698301884633, 0.08333539742339524, 0.07243358087909746, 0.06673057992411191, 0.07578717946068259, 0.08555571306861642, 0.0794883534914479, 0.09907256018648203, 0.07156790191190043, 0.06582649210988512, 0.07864057763779952, 0.09098668837343138, 0.1013120979331954, 0.06985443579283745, 0.0807632634149602, 0.0728990038062941, 0.09120043545518419, 0.08874793448271534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027381380250671605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10012850013535224, 0.09086467990256863, 0.09213120563736488, 0.09742740207871081, 0.11455789961260687, 0.0998825777597998, 0.10013619022648113, 0.09394430557175859, 0.10335848410808435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031006519457458692, 0.030840448987022318, 0.030815805181557687, 0.03115803173038456, 0.046711575916170256, 0.04460894322514941, 0.04729506665409977, 0.04104288171792503, 0.03413840419664316, 0.30921616727181367, 0.29057422648783693, 0.2967621429180982, 0.27764376008512703, 0.2955378620300333, 0.3026453617400586, 0.27741225865684305, 0.2953119171367573, 0.2919241388058428, 0.08355213951380558, 0.08860699937929317, 0.08386075129742787, 0.07246946252798425, 0.07122896366031672, 0.07219538361084687, 0.08327390753850505, 0.0805966186859689, 0.07551735838433249, 0.13385634043853167, 0.17180187713093076, 0.1675994334343346, 0.1660679929147666, 0.1645826807386389, 0.12833606853334678, 0.15136022848006436, 0.18518924731787145, 0.13610717811508966, 0.2150719156401838, 0.20821311466788328, 0.22742757466683539, 0.2082193784363049, 0.21475913033697014, 0.21323552027730808, 0.21895917694478773, 0.21878899369832427, 0.21800979920714636, 0.1549837311664285, 0.16251272264638916, 0.17382382111676176, 0.16419635381714837, 0.14525793019407252, 0.15822292884302647, 0.1666620410567624, 0.1586980835221662, 0.16194124409100985, 0.19761595001740784, 0.18784520300325735, 0.1945071097213259, 0.18189411975302106, 0.18440474108236105, 0.18494816835119565, 0.19182880353981513, 0.19222758520319982, 0.19867803134245687, 0.17676384629735387, 0.180977649483118, 0.1792723387390568, 0.17809003768452536, 0.17642268148475726, 0.18140421015843022, 0.1859001440838287, 0.17444197053441535, 0.17347647357064488, 0.21797498081645594, 0.24451143440678902, 0.22742593471067962, 0.27709451263785645, 0.27649594957169754, 0.211517461702451, 0.3366826057574279, 0.24208246360741825, 0.31364088870736306, 0.2698035055340351, 0.18516368463537758, 0.21181516901327546, 0.20913535070615308, 0.2320678061122775, 0.21361565728347398, 0.20805365355098415, 0.2964427551899559, 0.30697736954134114, 0.18476314099780045, 0.17618479847423774, 0.1972850149789469, 0.1922727813088566, 0.17937445702687005, 0.19182502251350564, 0.1905150686941921, 0.18328399343970125, 0.18405711750676534, 0.06799479994301294, 0.08268703975560254, 0.07421167810988716, 0.06818256862748018, 0.07168382116484084, 0.07242419562746505, 0.07494816592008369, 0.06990488309518439, 0.07093256766464906]}, "mutation_prompt": null}
{"id": "964f4375-4e47-4ecb-8f38-50d2daa046fe", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85  # Adjusted mutation factor for enhanced exploration\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(3, 6, self.population_size)  # Increased search iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)  # Adjusted perturbation for better local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)  # Adaptive opposition around mid-point\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Hybrid local search with adaptive probability\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.7:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing adaptive opposition and hybrid local search to accelerate convergence while maintaining diverse exploration.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.3077463200079953, 0.29800629202985396, 0.3025613883450171, 0.27060000676808615, 0.2964253163481396, 0.3139775566443388, 0.299689533340175, 0.2852803589865135, 0.30264009599547803, 0.030390373530886805, 0.022619902017002813, 0.05744768800337574, 0.022665187643416407, 0.022195674666327103, 0.028513928293954605, 0.03297552711165297, 0.038512374160619256, 0.06165542715695049, 0.09993005534542465, 0.10180310815625893, 0.09629099170821553, 0.09783416807060108, 0.1014471088962462, 0.10014467809949079, 0.09870180632984105, 0.10354004722757604, 0.09522959285025367, 0.08578432566353245, 0.0821955220488586, 0.08637978449951478, 0.09013304913308917, 0.08886658916793388, 0.09256766363142943, 0.08043763193193831, 0.08672009378035928, 0.08977870534806842, 0.4050114492967012, 0.5314024385859337, 0.35027454961845905, 0.41686022138508116, 0.4068927940498418, 0.3527118209195953, 0.33919465196930765, 0.4867638639301072, 0.3303767350560993, 0.0946337317676238, 0.11180378767878296, 0.1598312733474344, 0.12577925697277115, 0.09633577681971728, 0.08883473787463247, 0.13726660946641245, 0.1369245428341006, 0.12273296266741873, 0.20837197932348084, 0.16196334566232673, 0.1992613664863272, 0.20176968108776527, 0.20186820675468342, 0.20893907649120258, 0.1964563993712889, 0.2037196255505812, 0.17598002485325592, 0.06522698301884633, 0.08333539742339524, 0.07243358087909746, 0.06673057992411191, 0.07578717946068259, 0.08555571306861642, 0.0794883534914479, 0.09907256018648203, 0.07156790191190043, 0.06582649210988512, 0.07864057763779952, 0.09098668837343138, 0.1013120979331954, 0.06985443579283745, 0.0807632634149602, 0.0728990038062941, 0.09120043545518419, 0.08874793448271534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027381380250671605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10012850013535224, 0.09086467990256863, 0.09213120563736488, 0.09742740207871081, 0.11455789961260687, 0.0998825777597998, 0.10013619022648113, 0.09394430557175859, 0.10335848410808435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031006519457458692, 0.030840448987022318, 0.030815805181557687, 0.03115803173038456, 0.046711575916170256, 0.04460894322514941, 0.04729506665409977, 0.04104288171792503, 0.03413840419664316, 0.30921616727181367, 0.29057422648783693, 0.2967621429180982, 0.27764376008512703, 0.2955378620300333, 0.3026453617400586, 0.27741225865684305, 0.2953119171367573, 0.2919241388058428, 0.08355213951380558, 0.08860699937929317, 0.08386075129742787, 0.07246946252798425, 0.07122896366031672, 0.07219538361084687, 0.08327390753850505, 0.0805966186859689, 0.07551735838433249, 0.13385634043853167, 0.17180187713093076, 0.1675994334343346, 0.1660679929147666, 0.1645826807386389, 0.12833606853334678, 0.15136022848006436, 0.18518924731787145, 0.13610717811508966, 0.2150719156401838, 0.20821311466788328, 0.22742757466683539, 0.2082193784363049, 0.21475913033697014, 0.21323552027730808, 0.21895917694478773, 0.21878899369832427, 0.21800979920714636, 0.1549837311664285, 0.16251272264638916, 0.17382382111676176, 0.16419635381714837, 0.14525793019407252, 0.15822292884302647, 0.1666620410567624, 0.1586980835221662, 0.16194124409100985, 0.19761595001740784, 0.18784520300325735, 0.1945071097213259, 0.18189411975302106, 0.18440474108236105, 0.18494816835119565, 0.19182880353981513, 0.19222758520319982, 0.19867803134245687, 0.17676384629735387, 0.180977649483118, 0.1792723387390568, 0.17809003768452536, 0.17642268148475726, 0.18140421015843022, 0.1859001440838287, 0.17444197053441535, 0.17347647357064488, 0.21797498081645594, 0.24451143440678902, 0.22742593471067962, 0.27709451263785645, 0.27649594957169754, 0.211517461702451, 0.3366826057574279, 0.24208246360741825, 0.31364088870736306, 0.2698035055340351, 0.18516368463537758, 0.21181516901327546, 0.20913535070615308, 0.2320678061122775, 0.21361565728347398, 0.20805365355098415, 0.2964427551899559, 0.30697736954134114, 0.18476314099780045, 0.17618479847423774, 0.1972850149789469, 0.1922727813088566, 0.17937445702687005, 0.19182502251350564, 0.1905150686941921, 0.18328399343970125, 0.18405711750676534, 0.06799479994301294, 0.08268703975560254, 0.07421167810988716, 0.06818256862748018, 0.07168382116484084, 0.07242419562746505, 0.07494816592008369, 0.06990488309518439, 0.07093256766464906]}, "mutation_prompt": null}
{"id": "f2b9b321-72de-410c-857f-3015df1cdde4", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85  # Adjusted mutation factor for enhanced exploration\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(3, 6, self.population_size)  # Increased search iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)  # Adjusted perturbation for better local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)  # Adaptive opposition around mid-point\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Hybrid local search with adaptive probability\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.7:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing adaptive opposition and hybrid local search to accelerate convergence while maintaining diverse exploration.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.3077463200079953, 0.29800629202985396, 0.3025613883450171, 0.27060000676808615, 0.2964253163481396, 0.3139775566443388, 0.299689533340175, 0.2852803589865135, 0.30264009599547803, 0.030390373530886805, 0.022619902017002813, 0.05744768800337574, 0.022665187643416407, 0.022195674666327103, 0.028513928293954605, 0.03297552711165297, 0.038512374160619256, 0.06165542715695049, 0.09993005534542465, 0.10180310815625893, 0.09629099170821553, 0.09783416807060108, 0.1014471088962462, 0.10014467809949079, 0.09870180632984105, 0.10354004722757604, 0.09522959285025367, 0.08578432566353245, 0.0821955220488586, 0.08637978449951478, 0.09013304913308917, 0.08886658916793388, 0.09256766363142943, 0.08043763193193831, 0.08672009378035928, 0.08977870534806842, 0.4050114492967012, 0.5314024385859337, 0.35027454961845905, 0.41686022138508116, 0.4068927940498418, 0.3527118209195953, 0.33919465196930765, 0.4867638639301072, 0.3303767350560993, 0.0946337317676238, 0.11180378767878296, 0.1598312733474344, 0.12577925697277115, 0.09633577681971728, 0.08883473787463247, 0.13726660946641245, 0.1369245428341006, 0.12273296266741873, 0.20837197932348084, 0.16196334566232673, 0.1992613664863272, 0.20176968108776527, 0.20186820675468342, 0.20893907649120258, 0.1964563993712889, 0.2037196255505812, 0.17598002485325592, 0.06522698301884633, 0.08333539742339524, 0.07243358087909746, 0.06673057992411191, 0.07578717946068259, 0.08555571306861642, 0.0794883534914479, 0.09907256018648203, 0.07156790191190043, 0.06582649210988512, 0.07864057763779952, 0.09098668837343138, 0.1013120979331954, 0.06985443579283745, 0.0807632634149602, 0.0728990038062941, 0.09120043545518419, 0.08874793448271534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027381380250671605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10012850013535224, 0.09086467990256863, 0.09213120563736488, 0.09742740207871081, 0.11455789961260687, 0.0998825777597998, 0.10013619022648113, 0.09394430557175859, 0.10335848410808435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031006519457458692, 0.030840448987022318, 0.030815805181557687, 0.03115803173038456, 0.046711575916170256, 0.04460894322514941, 0.04729506665409977, 0.04104288171792503, 0.03413840419664316, 0.30921616727181367, 0.29057422648783693, 0.2967621429180982, 0.27764376008512703, 0.2955378620300333, 0.3026453617400586, 0.27741225865684305, 0.2953119171367573, 0.2919241388058428, 0.08355213951380558, 0.08860699937929317, 0.08386075129742787, 0.07246946252798425, 0.07122896366031672, 0.07219538361084687, 0.08327390753850505, 0.0805966186859689, 0.07551735838433249, 0.13385634043853167, 0.17180187713093076, 0.1675994334343346, 0.1660679929147666, 0.1645826807386389, 0.12833606853334678, 0.15136022848006436, 0.18518924731787145, 0.13610717811508966, 0.2150719156401838, 0.20821311466788328, 0.22742757466683539, 0.2082193784363049, 0.21475913033697014, 0.21323552027730808, 0.21895917694478773, 0.21878899369832427, 0.21800979920714636, 0.1549837311664285, 0.16251272264638916, 0.17382382111676176, 0.16419635381714837, 0.14525793019407252, 0.15822292884302647, 0.1666620410567624, 0.1586980835221662, 0.16194124409100985, 0.19761595001740784, 0.18784520300325735, 0.1945071097213259, 0.18189411975302106, 0.18440474108236105, 0.18494816835119565, 0.19182880353981513, 0.19222758520319982, 0.19867803134245687, 0.17676384629735387, 0.180977649483118, 0.1792723387390568, 0.17809003768452536, 0.17642268148475726, 0.18140421015843022, 0.1859001440838287, 0.17444197053441535, 0.17347647357064488, 0.21797498081645594, 0.24451143440678902, 0.22742593471067962, 0.27709451263785645, 0.27649594957169754, 0.211517461702451, 0.3366826057574279, 0.24208246360741825, 0.31364088870736306, 0.2698035055340351, 0.18516368463537758, 0.21181516901327546, 0.20913535070615308, 0.2320678061122775, 0.21361565728347398, 0.20805365355098415, 0.2964427551899559, 0.30697736954134114, 0.18476314099780045, 0.17618479847423774, 0.1972850149789469, 0.1922727813088566, 0.17937445702687005, 0.19182502251350564, 0.1905150686941921, 0.18328399343970125, 0.18405711750676534, 0.06799479994301294, 0.08268703975560254, 0.07421167810988716, 0.06818256862748018, 0.07168382116484084, 0.07242419562746505, 0.07494816592008369, 0.06990488309518439, 0.07093256766464906]}, "mutation_prompt": null}
{"id": "c6bfdc5d-6f3c-44b0-a77a-3a87539327bb", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85  # Adjusted mutation factor for enhanced exploration\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(3, 6, self.population_size)  # Increased search iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)  # Adjusted perturbation for better local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)  # Adaptive opposition around mid-point\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Hybrid local search with adaptive probability\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.7:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing adaptive opposition and hybrid local search to accelerate convergence while maintaining diverse exploration.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.3077463200079953, 0.29800629202985396, 0.3025613883450171, 0.27060000676808615, 0.2964253163481396, 0.3139775566443388, 0.299689533340175, 0.2852803589865135, 0.30264009599547803, 0.030390373530886805, 0.022619902017002813, 0.05744768800337574, 0.022665187643416407, 0.022195674666327103, 0.028513928293954605, 0.03297552711165297, 0.038512374160619256, 0.06165542715695049, 0.09993005534542465, 0.10180310815625893, 0.09629099170821553, 0.09783416807060108, 0.1014471088962462, 0.10014467809949079, 0.09870180632984105, 0.10354004722757604, 0.09522959285025367, 0.08578432566353245, 0.0821955220488586, 0.08637978449951478, 0.09013304913308917, 0.08886658916793388, 0.09256766363142943, 0.08043763193193831, 0.08672009378035928, 0.08977870534806842, 0.4050114492967012, 0.5314024385859337, 0.35027454961845905, 0.41686022138508116, 0.4068927940498418, 0.3527118209195953, 0.33919465196930765, 0.4867638639301072, 0.3303767350560993, 0.0946337317676238, 0.11180378767878296, 0.1598312733474344, 0.12577925697277115, 0.09633577681971728, 0.08883473787463247, 0.13726660946641245, 0.1369245428341006, 0.12273296266741873, 0.20837197932348084, 0.16196334566232673, 0.1992613664863272, 0.20176968108776527, 0.20186820675468342, 0.20893907649120258, 0.1964563993712889, 0.2037196255505812, 0.17598002485325592, 0.06522698301884633, 0.08333539742339524, 0.07243358087909746, 0.06673057992411191, 0.07578717946068259, 0.08555571306861642, 0.0794883534914479, 0.09907256018648203, 0.07156790191190043, 0.06582649210988512, 0.07864057763779952, 0.09098668837343138, 0.1013120979331954, 0.06985443579283745, 0.0807632634149602, 0.0728990038062941, 0.09120043545518419, 0.08874793448271534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027381380250671605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10012850013535224, 0.09086467990256863, 0.09213120563736488, 0.09742740207871081, 0.11455789961260687, 0.0998825777597998, 0.10013619022648113, 0.09394430557175859, 0.10335848410808435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031006519457458692, 0.030840448987022318, 0.030815805181557687, 0.03115803173038456, 0.046711575916170256, 0.04460894322514941, 0.04729506665409977, 0.04104288171792503, 0.03413840419664316, 0.30921616727181367, 0.29057422648783693, 0.2967621429180982, 0.27764376008512703, 0.2955378620300333, 0.3026453617400586, 0.27741225865684305, 0.2953119171367573, 0.2919241388058428, 0.08355213951380558, 0.08860699937929317, 0.08386075129742787, 0.07246946252798425, 0.07122896366031672, 0.07219538361084687, 0.08327390753850505, 0.0805966186859689, 0.07551735838433249, 0.13385634043853167, 0.17180187713093076, 0.1675994334343346, 0.1660679929147666, 0.1645826807386389, 0.12833606853334678, 0.15136022848006436, 0.18518924731787145, 0.13610717811508966, 0.2150719156401838, 0.20821311466788328, 0.22742757466683539, 0.2082193784363049, 0.21475913033697014, 0.21323552027730808, 0.21895917694478773, 0.21878899369832427, 0.21800979920714636, 0.1549837311664285, 0.16251272264638916, 0.17382382111676176, 0.16419635381714837, 0.14525793019407252, 0.15822292884302647, 0.1666620410567624, 0.1586980835221662, 0.16194124409100985, 0.19761595001740784, 0.18784520300325735, 0.1945071097213259, 0.18189411975302106, 0.18440474108236105, 0.18494816835119565, 0.19182880353981513, 0.19222758520319982, 0.19867803134245687, 0.17676384629735387, 0.180977649483118, 0.1792723387390568, 0.17809003768452536, 0.17642268148475726, 0.18140421015843022, 0.1859001440838287, 0.17444197053441535, 0.17347647357064488, 0.21797498081645594, 0.24451143440678902, 0.22742593471067962, 0.27709451263785645, 0.27649594957169754, 0.211517461702451, 0.3366826057574279, 0.24208246360741825, 0.31364088870736306, 0.2698035055340351, 0.18516368463537758, 0.21181516901327546, 0.20913535070615308, 0.2320678061122775, 0.21361565728347398, 0.20805365355098415, 0.2964427551899559, 0.30697736954134114, 0.18476314099780045, 0.17618479847423774, 0.1972850149789469, 0.1922727813088566, 0.17937445702687005, 0.19182502251350564, 0.1905150686941921, 0.18328399343970125, 0.18405711750676534, 0.06799479994301294, 0.08268703975560254, 0.07421167810988716, 0.06818256862748018, 0.07168382116484084, 0.07242419562746505, 0.07494816592008369, 0.06990488309518439, 0.07093256766464906]}, "mutation_prompt": null}
{"id": "3a0dc461-e06e-4ed7-b865-d994229f3031", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85  # Adjusted mutation factor for enhanced exploration\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(3, 6, self.population_size)  # Increased search iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)  # Adjusted perturbation for better local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)  # Adaptive opposition around mid-point\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Hybrid local search with adaptive probability\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.7:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing adaptive opposition and hybrid local search to accelerate convergence while maintaining diverse exploration.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.3077463200079953, 0.29800629202985396, 0.3025613883450171, 0.27060000676808615, 0.2964253163481396, 0.3139775566443388, 0.299689533340175, 0.2852803589865135, 0.30264009599547803, 0.030390373530886805, 0.022619902017002813, 0.05744768800337574, 0.022665187643416407, 0.022195674666327103, 0.028513928293954605, 0.03297552711165297, 0.038512374160619256, 0.06165542715695049, 0.09993005534542465, 0.10180310815625893, 0.09629099170821553, 0.09783416807060108, 0.1014471088962462, 0.10014467809949079, 0.09870180632984105, 0.10354004722757604, 0.09522959285025367, 0.08578432566353245, 0.0821955220488586, 0.08637978449951478, 0.09013304913308917, 0.08886658916793388, 0.09256766363142943, 0.08043763193193831, 0.08672009378035928, 0.08977870534806842, 0.4050114492967012, 0.5314024385859337, 0.35027454961845905, 0.41686022138508116, 0.4068927940498418, 0.3527118209195953, 0.33919465196930765, 0.4867638639301072, 0.3303767350560993, 0.0946337317676238, 0.11180378767878296, 0.1598312733474344, 0.12577925697277115, 0.09633577681971728, 0.08883473787463247, 0.13726660946641245, 0.1369245428341006, 0.12273296266741873, 0.20837197932348084, 0.16196334566232673, 0.1992613664863272, 0.20176968108776527, 0.20186820675468342, 0.20893907649120258, 0.1964563993712889, 0.2037196255505812, 0.17598002485325592, 0.06522698301884633, 0.08333539742339524, 0.07243358087909746, 0.06673057992411191, 0.07578717946068259, 0.08555571306861642, 0.0794883534914479, 0.09907256018648203, 0.07156790191190043, 0.06582649210988512, 0.07864057763779952, 0.09098668837343138, 0.1013120979331954, 0.06985443579283745, 0.0807632634149602, 0.0728990038062941, 0.09120043545518419, 0.08874793448271534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027381380250671605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10012850013535224, 0.09086467990256863, 0.09213120563736488, 0.09742740207871081, 0.11455789961260687, 0.0998825777597998, 0.10013619022648113, 0.09394430557175859, 0.10335848410808435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031006519457458692, 0.030840448987022318, 0.030815805181557687, 0.03115803173038456, 0.046711575916170256, 0.04460894322514941, 0.04729506665409977, 0.04104288171792503, 0.03413840419664316, 0.30921616727181367, 0.29057422648783693, 0.2967621429180982, 0.27764376008512703, 0.2955378620300333, 0.3026453617400586, 0.27741225865684305, 0.2953119171367573, 0.2919241388058428, 0.08355213951380558, 0.08860699937929317, 0.08386075129742787, 0.07246946252798425, 0.07122896366031672, 0.07219538361084687, 0.08327390753850505, 0.0805966186859689, 0.07551735838433249, 0.13385634043853167, 0.17180187713093076, 0.1675994334343346, 0.1660679929147666, 0.1645826807386389, 0.12833606853334678, 0.15136022848006436, 0.18518924731787145, 0.13610717811508966, 0.2150719156401838, 0.20821311466788328, 0.22742757466683539, 0.2082193784363049, 0.21475913033697014, 0.21323552027730808, 0.21895917694478773, 0.21878899369832427, 0.21800979920714636, 0.1549837311664285, 0.16251272264638916, 0.17382382111676176, 0.16419635381714837, 0.14525793019407252, 0.15822292884302647, 0.1666620410567624, 0.1586980835221662, 0.16194124409100985, 0.19761595001740784, 0.18784520300325735, 0.1945071097213259, 0.18189411975302106, 0.18440474108236105, 0.18494816835119565, 0.19182880353981513, 0.19222758520319982, 0.19867803134245687, 0.17676384629735387, 0.180977649483118, 0.1792723387390568, 0.17809003768452536, 0.17642268148475726, 0.18140421015843022, 0.1859001440838287, 0.17444197053441535, 0.17347647357064488, 0.21797498081645594, 0.24451143440678902, 0.22742593471067962, 0.27709451263785645, 0.27649594957169754, 0.211517461702451, 0.3366826057574279, 0.24208246360741825, 0.31364088870736306, 0.2698035055340351, 0.18516368463537758, 0.21181516901327546, 0.20913535070615308, 0.2320678061122775, 0.21361565728347398, 0.20805365355098415, 0.2964427551899559, 0.30697736954134114, 0.18476314099780045, 0.17618479847423774, 0.1972850149789469, 0.1922727813088566, 0.17937445702687005, 0.19182502251350564, 0.1905150686941921, 0.18328399343970125, 0.18405711750676534, 0.06799479994301294, 0.08268703975560254, 0.07421167810988716, 0.06818256862748018, 0.07168382116484084, 0.07242419562746505, 0.07494816592008369, 0.06990488309518439, 0.07093256766464906]}, "mutation_prompt": null}
{"id": "788ef430-826f-4e39-a127-d142acf740ac", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.9  # Increased mutation factor for better exploration\n        self.population_scaling = 0.4 + (0.4 * np.random.rand())  # Adjusted scaling\n        self.population_size = int(self.budget / (5 * dim))  # Increased population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.5, 0.95, self.population_size)  # Broaden crossover rate range\n        self.dynamic_mutation_factor = np.logspace(-1, 0, num=self.population_size)  # Adjusted for quicker adaptation\n        self.dynamic_local_search_iters = np.random.randint(2, 5, self.population_size)  # Reduced search iterations\n        self.elite_fraction = 0.2  # Fraction of population considered as elites\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1))\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)  # Adjusted perturbation for focused local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def _select_elites(self, scores):\n        elite_count = int(self.population_size * self.elite_fraction)\n        elite_indices = np.argsort(scores)[:elite_count]\n        return self.population[elite_indices], scores[elite_indices]\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            elite_population, elite_scores = self._select_elites(population_scores)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.6:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n                # Dynamic parameter adjustment based on elite performance\n                if elite_scores.min() < population_scores[i]:\n                    self.mutation_factor *= 0.99  # Adaptive mutation factor reduction\n                    self.adaptive_crossover_rate[i] = min(0.95, self.adaptive_crossover_rate[i] + 0.01)\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing elite selection and dynamic parameter adjustment to enhance convergence speed by focusing on promising regions.", "configspace": "", "generation": 83, "fitness": 0.1235576445490848, "feedback": "The algorithm EnhancedDynamicDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.08.", "error": "", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.25014817395115585, 0.2533779168858268, 0.24419090754981443, 0.22973466612070803, 0.2476460522530739, 0.23938362941549385, 0.24876715975080566, 0.248965759211482, 0.2645362177328622, 0.0029456901422563186, 0.006213012345218205, 0.016452384149240773, 0.0035923738573792052, 0.0026931216507045663, 0.014488294933095669, 0.01022436089982004, 0.008836952672767295, 0.009396865948402722, 0.11805337398218285, 0.09067095764645694, 0.09820834591394212, 0.10458132531108166, 0.0960127966329879, 0.0826472887338301, 0.09781127663202549, 0.09779071770984193, 0.09941657474579935, 0.08247974933701463, 0.08610537470122248, 0.0778756517175172, 0.08251751677086983, 0.09402001630479184, 0.07691398916875025, 0.0774755444327273, 0.0774126687338863, 0.08969939184503473, 0.1675023490767117, 0.1711241534292134, 0.1618847080265896, 0.24364266814962388, 0.12402794649106019, 0.2697312883597206, 0.15362141986095834, 0.14474481924786686, 0.23426727743283182, 0.10972021481265815, 0.10232385261849264, 0.09996390405786038, 0.10814156334529412, 0.07126652079390827, 0.08182720504326202, 0.09842986053473068, 0.12474845672122392, 0.10587077575386461, 0.1540919876272333, 0.16096425513401302, 0.15810667882977936, 0.16607271603803442, 0.17001598972874, 0.15060340561306895, 0.16958968491320303, 0.17537646429049414, 0.18543004364828053, 0.051094595926369, 0.06627531224411864, 0.05985686847318361, 0.04482733485737134, 0.048466719697031424, 0.0601337463959668, 0.05881757630864881, 0.06072131214692944, 0.045712747515457286, 0.06517955865163061, 0.058139287826234565, 0.05940768741231839, 0.08120612271842131, 0.07211690765492618, 0.044361798100527094, 0.0702771006248335, 0.045024377111202885, 0.053564382405472344, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0010045584373626903, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07973355109395219, 0.06492179986437896, 0.06986297493239513, 0.11336781671582707, 0.09190528353360639, 0.09905993821020453, 0.0874635691505462, 0.07557078627648572, 0.07366268594416292, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01574115986541269, 0.014829638472096507, 0.009362847110557793, 0.016650952149202203, 0.03180283192152944, 0.0348596513242283, 0.020909396897052512, 0.047812588381021315, 0.0160615586232421, 0.25865531021820976, 0.2612696300629509, 0.2703767170624345, 0.2402610466073275, 0.23963258686854272, 0.255995896424588, 0.26032836963324, 0.2607083445838444, 0.26675648066560176, 0.06921918332450894, 0.07611766446738033, 0.07344400557859188, 0.07069960089370719, 0.06655581741681249, 0.07840041638878448, 0.08084081046953162, 0.07626870887246517, 0.0686923009087923, 0.15674166751107532, 0.14467626205591655, 0.18867410737663948, 0.1576252717908868, 0.16159984160099372, 0.1387960032951181, 0.15896418616594687, 0.18942170097630529, 0.16344447089280367, 0.1860255981114377, 0.2112968457140103, 0.19068552463029176, 0.18617721230468876, 0.19779065213757407, 0.18687214000706698, 0.20008552639693766, 0.19401239987227759, 0.19126867413043402, 0.12997121929890787, 0.15252121249930117, 0.13411032965631597, 0.14228383666873634, 0.14435624664542135, 0.1502178108075819, 0.14876606424559846, 0.14660134956875026, 0.14278096396893802, 0.1713200914254407, 0.17120915063627284, 0.19498640757374197, 0.17981754657197668, 0.18214060145367117, 0.1685905781166923, 0.17048205557766982, 0.18125536134936793, 0.17871316824896055, 0.18275471536188237, 0.1739524805257735, 0.17531353690118578, 0.1666729778401559, 0.19259990862548337, 0.1631322743087814, 0.16933806001449736, 0.16960535615929495, 0.1614974809494395, 0.249178986046942, 0.169586634373874, 0.19779597178123176, 0.19956418323485292, 0.19722356970385035, 0.17681809360552325, 0.15378544550772244, 0.21437433142558537, 0.2605499887458993, 0.2931964596480423, 0.20169811300690998, 0.22287565408461274, 0.16861186912428294, 0.15104536720587725, 0.23783802275718757, 0.22576804049798138, 0.30295848493026933, 0.18127272976440467, 0.17814926270381093, 0.17891308283043306, 0.17504422193174562, 0.18622781912576303, 0.18747112379807895, 0.16882303767653395, 0.19080790403077552, 0.19388206772168437, 0.18214207086652157, 0.061618795263388204, 0.07508489261279205, 0.06300467636124374, 0.06965230492780705, 0.06784720960607682, 0.06948226398485624, 0.06769124118712666, 0.07353312747000729, 0.0657190802983656]}, "mutation_prompt": null}
{"id": "bd9c1f18-2931-4bf5-a338-6bb50248b8fc", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85  # Adjusted mutation factor for enhanced exploration\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(3, 6, self.population_size)  # Increased search iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)  # Adjusted perturbation for better local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)  # Adaptive opposition around mid-point\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Hybrid local search with adaptive probability\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.7:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing adaptive opposition and hybrid local search to accelerate convergence while maintaining diverse exploration.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.3077463200079953, 0.29800629202985396, 0.3025613883450171, 0.27060000676808615, 0.2964253163481396, 0.3139775566443388, 0.299689533340175, 0.2852803589865135, 0.30264009599547803, 0.030390373530886805, 0.022619902017002813, 0.05744768800337574, 0.022665187643416407, 0.022195674666327103, 0.028513928293954605, 0.03297552711165297, 0.038512374160619256, 0.06165542715695049, 0.09993005534542465, 0.10180310815625893, 0.09629099170821553, 0.09783416807060108, 0.1014471088962462, 0.10014467809949079, 0.09870180632984105, 0.10354004722757604, 0.09522959285025367, 0.08578432566353245, 0.0821955220488586, 0.08637978449951478, 0.09013304913308917, 0.08886658916793388, 0.09256766363142943, 0.08043763193193831, 0.08672009378035928, 0.08977870534806842, 0.4050114492967012, 0.5314024385859337, 0.35027454961845905, 0.41686022138508116, 0.4068927940498418, 0.3527118209195953, 0.33919465196930765, 0.4867638639301072, 0.3303767350560993, 0.0946337317676238, 0.11180378767878296, 0.1598312733474344, 0.12577925697277115, 0.09633577681971728, 0.08883473787463247, 0.13726660946641245, 0.1369245428341006, 0.12273296266741873, 0.20837197932348084, 0.16196334566232673, 0.1992613664863272, 0.20176968108776527, 0.20186820675468342, 0.20893907649120258, 0.1964563993712889, 0.2037196255505812, 0.17598002485325592, 0.06522698301884633, 0.08333539742339524, 0.07243358087909746, 0.06673057992411191, 0.07578717946068259, 0.08555571306861642, 0.0794883534914479, 0.09907256018648203, 0.07156790191190043, 0.06582649210988512, 0.07864057763779952, 0.09098668837343138, 0.1013120979331954, 0.06985443579283745, 0.0807632634149602, 0.0728990038062941, 0.09120043545518419, 0.08874793448271534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027381380250671605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10012850013535224, 0.09086467990256863, 0.09213120563736488, 0.09742740207871081, 0.11455789961260687, 0.0998825777597998, 0.10013619022648113, 0.09394430557175859, 0.10335848410808435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031006519457458692, 0.030840448987022318, 0.030815805181557687, 0.03115803173038456, 0.046711575916170256, 0.04460894322514941, 0.04729506665409977, 0.04104288171792503, 0.03413840419664316, 0.30921616727181367, 0.29057422648783693, 0.2967621429180982, 0.27764376008512703, 0.2955378620300333, 0.3026453617400586, 0.27741225865684305, 0.2953119171367573, 0.2919241388058428, 0.08355213951380558, 0.08860699937929317, 0.08386075129742787, 0.07246946252798425, 0.07122896366031672, 0.07219538361084687, 0.08327390753850505, 0.0805966186859689, 0.07551735838433249, 0.13385634043853167, 0.17180187713093076, 0.1675994334343346, 0.1660679929147666, 0.1645826807386389, 0.12833606853334678, 0.15136022848006436, 0.18518924731787145, 0.13610717811508966, 0.2150719156401838, 0.20821311466788328, 0.22742757466683539, 0.2082193784363049, 0.21475913033697014, 0.21323552027730808, 0.21895917694478773, 0.21878899369832427, 0.21800979920714636, 0.1549837311664285, 0.16251272264638916, 0.17382382111676176, 0.16419635381714837, 0.14525793019407252, 0.15822292884302647, 0.1666620410567624, 0.1586980835221662, 0.16194124409100985, 0.19761595001740784, 0.18784520300325735, 0.1945071097213259, 0.18189411975302106, 0.18440474108236105, 0.18494816835119565, 0.19182880353981513, 0.19222758520319982, 0.19867803134245687, 0.17676384629735387, 0.180977649483118, 0.1792723387390568, 0.17809003768452536, 0.17642268148475726, 0.18140421015843022, 0.1859001440838287, 0.17444197053441535, 0.17347647357064488, 0.21797498081645594, 0.24451143440678902, 0.22742593471067962, 0.27709451263785645, 0.27649594957169754, 0.211517461702451, 0.3366826057574279, 0.24208246360741825, 0.31364088870736306, 0.2698035055340351, 0.18516368463537758, 0.21181516901327546, 0.20913535070615308, 0.2320678061122775, 0.21361565728347398, 0.20805365355098415, 0.2964427551899559, 0.30697736954134114, 0.18476314099780045, 0.17618479847423774, 0.1972850149789469, 0.1922727813088566, 0.17937445702687005, 0.19182502251350564, 0.1905150686941921, 0.18328399343970125, 0.18405711750676534, 0.06799479994301294, 0.08268703975560254, 0.07421167810988716, 0.06818256862748018, 0.07168382116484084, 0.07242419562746505, 0.07494816592008369, 0.06990488309518439, 0.07093256766464906]}, "mutation_prompt": null}
{"id": "6444705f-8af9-4690-8d5c-dd1c4264cbad", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85  # Adjusted mutation factor for enhanced exploration\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(3, 6, self.population_size)  # Increased search iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)  # Adjusted perturbation for better local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)  # Adaptive opposition around mid-point\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Hybrid local search with adaptive probability\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.7:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing adaptive opposition and hybrid local search to accelerate convergence while maintaining diverse exploration.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.3077463200079953, 0.29800629202985396, 0.3025613883450171, 0.27060000676808615, 0.2964253163481396, 0.3139775566443388, 0.299689533340175, 0.2852803589865135, 0.30264009599547803, 0.030390373530886805, 0.022619902017002813, 0.05744768800337574, 0.022665187643416407, 0.022195674666327103, 0.028513928293954605, 0.03297552711165297, 0.038512374160619256, 0.06165542715695049, 0.09993005534542465, 0.10180310815625893, 0.09629099170821553, 0.09783416807060108, 0.1014471088962462, 0.10014467809949079, 0.09870180632984105, 0.10354004722757604, 0.09522959285025367, 0.08578432566353245, 0.0821955220488586, 0.08637978449951478, 0.09013304913308917, 0.08886658916793388, 0.09256766363142943, 0.08043763193193831, 0.08672009378035928, 0.08977870534806842, 0.4050114492967012, 0.5314024385859337, 0.35027454961845905, 0.41686022138508116, 0.4068927940498418, 0.3527118209195953, 0.33919465196930765, 0.4867638639301072, 0.3303767350560993, 0.0946337317676238, 0.11180378767878296, 0.1598312733474344, 0.12577925697277115, 0.09633577681971728, 0.08883473787463247, 0.13726660946641245, 0.1369245428341006, 0.12273296266741873, 0.20837197932348084, 0.16196334566232673, 0.1992613664863272, 0.20176968108776527, 0.20186820675468342, 0.20893907649120258, 0.1964563993712889, 0.2037196255505812, 0.17598002485325592, 0.06522698301884633, 0.08333539742339524, 0.07243358087909746, 0.06673057992411191, 0.07578717946068259, 0.08555571306861642, 0.0794883534914479, 0.09907256018648203, 0.07156790191190043, 0.06582649210988512, 0.07864057763779952, 0.09098668837343138, 0.1013120979331954, 0.06985443579283745, 0.0807632634149602, 0.0728990038062941, 0.09120043545518419, 0.08874793448271534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027381380250671605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10012850013535224, 0.09086467990256863, 0.09213120563736488, 0.09742740207871081, 0.11455789961260687, 0.0998825777597998, 0.10013619022648113, 0.09394430557175859, 0.10335848410808435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031006519457458692, 0.030840448987022318, 0.030815805181557687, 0.03115803173038456, 0.046711575916170256, 0.04460894322514941, 0.04729506665409977, 0.04104288171792503, 0.03413840419664316, 0.30921616727181367, 0.29057422648783693, 0.2967621429180982, 0.27764376008512703, 0.2955378620300333, 0.3026453617400586, 0.27741225865684305, 0.2953119171367573, 0.2919241388058428, 0.08355213951380558, 0.08860699937929317, 0.08386075129742787, 0.07246946252798425, 0.07122896366031672, 0.07219538361084687, 0.08327390753850505, 0.0805966186859689, 0.07551735838433249, 0.13385634043853167, 0.17180187713093076, 0.1675994334343346, 0.1660679929147666, 0.1645826807386389, 0.12833606853334678, 0.15136022848006436, 0.18518924731787145, 0.13610717811508966, 0.2150719156401838, 0.20821311466788328, 0.22742757466683539, 0.2082193784363049, 0.21475913033697014, 0.21323552027730808, 0.21895917694478773, 0.21878899369832427, 0.21800979920714636, 0.1549837311664285, 0.16251272264638916, 0.17382382111676176, 0.16419635381714837, 0.14525793019407252, 0.15822292884302647, 0.1666620410567624, 0.1586980835221662, 0.16194124409100985, 0.19761595001740784, 0.18784520300325735, 0.1945071097213259, 0.18189411975302106, 0.18440474108236105, 0.18494816835119565, 0.19182880353981513, 0.19222758520319982, 0.19867803134245687, 0.17676384629735387, 0.180977649483118, 0.1792723387390568, 0.17809003768452536, 0.17642268148475726, 0.18140421015843022, 0.1859001440838287, 0.17444197053441535, 0.17347647357064488, 0.21797498081645594, 0.24451143440678902, 0.22742593471067962, 0.27709451263785645, 0.27649594957169754, 0.211517461702451, 0.3366826057574279, 0.24208246360741825, 0.31364088870736306, 0.2698035055340351, 0.18516368463537758, 0.21181516901327546, 0.20913535070615308, 0.2320678061122775, 0.21361565728347398, 0.20805365355098415, 0.2964427551899559, 0.30697736954134114, 0.18476314099780045, 0.17618479847423774, 0.1972850149789469, 0.1922727813088566, 0.17937445702687005, 0.19182502251350564, 0.1905150686941921, 0.18328399343970125, 0.18405711750676534, 0.06799479994301294, 0.08268703975560254, 0.07421167810988716, 0.06818256862748018, 0.07168382116484084, 0.07242419562746505, 0.07494816592008369, 0.06990488309518439, 0.07093256766464906]}, "mutation_prompt": null}
{"id": "e045705c-5541-4d22-9298-3d33931e3126", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85  # Adjusted mutation factor for enhanced exploration\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(3, 6, self.population_size)  # Increased search iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)  # Adjusted perturbation for better local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)  # Adaptive opposition around mid-point\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Hybrid local search with adaptive probability\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.7:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing adaptive opposition and hybrid local search to accelerate convergence while maintaining diverse exploration.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.3077463200079953, 0.29800629202985396, 0.3025613883450171, 0.27060000676808615, 0.2964253163481396, 0.3139775566443388, 0.299689533340175, 0.2852803589865135, 0.30264009599547803, 0.030390373530886805, 0.022619902017002813, 0.05744768800337574, 0.022665187643416407, 0.022195674666327103, 0.028513928293954605, 0.03297552711165297, 0.038512374160619256, 0.06165542715695049, 0.09993005534542465, 0.10180310815625893, 0.09629099170821553, 0.09783416807060108, 0.1014471088962462, 0.10014467809949079, 0.09870180632984105, 0.10354004722757604, 0.09522959285025367, 0.08578432566353245, 0.0821955220488586, 0.08637978449951478, 0.09013304913308917, 0.08886658916793388, 0.09256766363142943, 0.08043763193193831, 0.08672009378035928, 0.08977870534806842, 0.4050114492967012, 0.5314024385859337, 0.35027454961845905, 0.41686022138508116, 0.4068927940498418, 0.3527118209195953, 0.33919465196930765, 0.4867638639301072, 0.3303767350560993, 0.0946337317676238, 0.11180378767878296, 0.1598312733474344, 0.12577925697277115, 0.09633577681971728, 0.08883473787463247, 0.13726660946641245, 0.1369245428341006, 0.12273296266741873, 0.20837197932348084, 0.16196334566232673, 0.1992613664863272, 0.20176968108776527, 0.20186820675468342, 0.20893907649120258, 0.1964563993712889, 0.2037196255505812, 0.17598002485325592, 0.06522698301884633, 0.08333539742339524, 0.07243358087909746, 0.06673057992411191, 0.07578717946068259, 0.08555571306861642, 0.0794883534914479, 0.09907256018648203, 0.07156790191190043, 0.06582649210988512, 0.07864057763779952, 0.09098668837343138, 0.1013120979331954, 0.06985443579283745, 0.0807632634149602, 0.0728990038062941, 0.09120043545518419, 0.08874793448271534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027381380250671605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10012850013535224, 0.09086467990256863, 0.09213120563736488, 0.09742740207871081, 0.11455789961260687, 0.0998825777597998, 0.10013619022648113, 0.09394430557175859, 0.10335848410808435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031006519457458692, 0.030840448987022318, 0.030815805181557687, 0.03115803173038456, 0.046711575916170256, 0.04460894322514941, 0.04729506665409977, 0.04104288171792503, 0.03413840419664316, 0.30921616727181367, 0.29057422648783693, 0.2967621429180982, 0.27764376008512703, 0.2955378620300333, 0.3026453617400586, 0.27741225865684305, 0.2953119171367573, 0.2919241388058428, 0.08355213951380558, 0.08860699937929317, 0.08386075129742787, 0.07246946252798425, 0.07122896366031672, 0.07219538361084687, 0.08327390753850505, 0.0805966186859689, 0.07551735838433249, 0.13385634043853167, 0.17180187713093076, 0.1675994334343346, 0.1660679929147666, 0.1645826807386389, 0.12833606853334678, 0.15136022848006436, 0.18518924731787145, 0.13610717811508966, 0.2150719156401838, 0.20821311466788328, 0.22742757466683539, 0.2082193784363049, 0.21475913033697014, 0.21323552027730808, 0.21895917694478773, 0.21878899369832427, 0.21800979920714636, 0.1549837311664285, 0.16251272264638916, 0.17382382111676176, 0.16419635381714837, 0.14525793019407252, 0.15822292884302647, 0.1666620410567624, 0.1586980835221662, 0.16194124409100985, 0.19761595001740784, 0.18784520300325735, 0.1945071097213259, 0.18189411975302106, 0.18440474108236105, 0.18494816835119565, 0.19182880353981513, 0.19222758520319982, 0.19867803134245687, 0.17676384629735387, 0.180977649483118, 0.1792723387390568, 0.17809003768452536, 0.17642268148475726, 0.18140421015843022, 0.1859001440838287, 0.17444197053441535, 0.17347647357064488, 0.21797498081645594, 0.24451143440678902, 0.22742593471067962, 0.27709451263785645, 0.27649594957169754, 0.211517461702451, 0.3366826057574279, 0.24208246360741825, 0.31364088870736306, 0.2698035055340351, 0.18516368463537758, 0.21181516901327546, 0.20913535070615308, 0.2320678061122775, 0.21361565728347398, 0.20805365355098415, 0.2964427551899559, 0.30697736954134114, 0.18476314099780045, 0.17618479847423774, 0.1972850149789469, 0.1922727813088566, 0.17937445702687005, 0.19182502251350564, 0.1905150686941921, 0.18328399343970125, 0.18405711750676534, 0.06799479994301294, 0.08268703975560254, 0.07421167810988716, 0.06818256862748018, 0.07168382116484084, 0.07242419562746505, 0.07494816592008369, 0.06990488309518439, 0.07093256766464906]}, "mutation_prompt": null}
{"id": "2d878490-3804-4da8-b36c-5c4eb32679c9", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85  # Adjusted mutation factor for enhanced exploration\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(3, 6, self.population_size)  # Increased search iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)  # Adjusted perturbation for better local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)  # Adaptive opposition around mid-point\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Hybrid local search with adaptive probability\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.7:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing adaptive opposition and hybrid local search to accelerate convergence while maintaining diverse exploration.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.3077463200079953, 0.29800629202985396, 0.3025613883450171, 0.27060000676808615, 0.2964253163481396, 0.3139775566443388, 0.299689533340175, 0.2852803589865135, 0.30264009599547803, 0.030390373530886805, 0.022619902017002813, 0.05744768800337574, 0.022665187643416407, 0.022195674666327103, 0.028513928293954605, 0.03297552711165297, 0.038512374160619256, 0.06165542715695049, 0.09993005534542465, 0.10180310815625893, 0.09629099170821553, 0.09783416807060108, 0.1014471088962462, 0.10014467809949079, 0.09870180632984105, 0.10354004722757604, 0.09522959285025367, 0.08578432566353245, 0.0821955220488586, 0.08637978449951478, 0.09013304913308917, 0.08886658916793388, 0.09256766363142943, 0.08043763193193831, 0.08672009378035928, 0.08977870534806842, 0.4050114492967012, 0.5314024385859337, 0.35027454961845905, 0.41686022138508116, 0.4068927940498418, 0.3527118209195953, 0.33919465196930765, 0.4867638639301072, 0.3303767350560993, 0.0946337317676238, 0.11180378767878296, 0.1598312733474344, 0.12577925697277115, 0.09633577681971728, 0.08883473787463247, 0.13726660946641245, 0.1369245428341006, 0.12273296266741873, 0.20837197932348084, 0.16196334566232673, 0.1992613664863272, 0.20176968108776527, 0.20186820675468342, 0.20893907649120258, 0.1964563993712889, 0.2037196255505812, 0.17598002485325592, 0.06522698301884633, 0.08333539742339524, 0.07243358087909746, 0.06673057992411191, 0.07578717946068259, 0.08555571306861642, 0.0794883534914479, 0.09907256018648203, 0.07156790191190043, 0.06582649210988512, 0.07864057763779952, 0.09098668837343138, 0.1013120979331954, 0.06985443579283745, 0.0807632634149602, 0.0728990038062941, 0.09120043545518419, 0.08874793448271534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027381380250671605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10012850013535224, 0.09086467990256863, 0.09213120563736488, 0.09742740207871081, 0.11455789961260687, 0.0998825777597998, 0.10013619022648113, 0.09394430557175859, 0.10335848410808435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031006519457458692, 0.030840448987022318, 0.030815805181557687, 0.03115803173038456, 0.046711575916170256, 0.04460894322514941, 0.04729506665409977, 0.04104288171792503, 0.03413840419664316, 0.30921616727181367, 0.29057422648783693, 0.2967621429180982, 0.27764376008512703, 0.2955378620300333, 0.3026453617400586, 0.27741225865684305, 0.2953119171367573, 0.2919241388058428, 0.08355213951380558, 0.08860699937929317, 0.08386075129742787, 0.07246946252798425, 0.07122896366031672, 0.07219538361084687, 0.08327390753850505, 0.0805966186859689, 0.07551735838433249, 0.13385634043853167, 0.17180187713093076, 0.1675994334343346, 0.1660679929147666, 0.1645826807386389, 0.12833606853334678, 0.15136022848006436, 0.18518924731787145, 0.13610717811508966, 0.2150719156401838, 0.20821311466788328, 0.22742757466683539, 0.2082193784363049, 0.21475913033697014, 0.21323552027730808, 0.21895917694478773, 0.21878899369832427, 0.21800979920714636, 0.1549837311664285, 0.16251272264638916, 0.17382382111676176, 0.16419635381714837, 0.14525793019407252, 0.15822292884302647, 0.1666620410567624, 0.1586980835221662, 0.16194124409100985, 0.19761595001740784, 0.18784520300325735, 0.1945071097213259, 0.18189411975302106, 0.18440474108236105, 0.18494816835119565, 0.19182880353981513, 0.19222758520319982, 0.19867803134245687, 0.17676384629735387, 0.180977649483118, 0.1792723387390568, 0.17809003768452536, 0.17642268148475726, 0.18140421015843022, 0.1859001440838287, 0.17444197053441535, 0.17347647357064488, 0.21797498081645594, 0.24451143440678902, 0.22742593471067962, 0.27709451263785645, 0.27649594957169754, 0.211517461702451, 0.3366826057574279, 0.24208246360741825, 0.31364088870736306, 0.2698035055340351, 0.18516368463537758, 0.21181516901327546, 0.20913535070615308, 0.2320678061122775, 0.21361565728347398, 0.20805365355098415, 0.2964427551899559, 0.30697736954134114, 0.18476314099780045, 0.17618479847423774, 0.1972850149789469, 0.1922727813088566, 0.17937445702687005, 0.19182502251350564, 0.1905150686941921, 0.18328399343970125, 0.18405711750676534, 0.06799479994301294, 0.08268703975560254, 0.07421167810988716, 0.06818256862748018, 0.07168382116484084, 0.07242419562746505, 0.07494816592008369, 0.06990488309518439, 0.07093256766464906]}, "mutation_prompt": null}
{"id": "bd254d79-fb00-450a-9d85-53bdf5e04c7c", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolutionV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.base_mutation_factor = 0.85\n        self.mutation_scaling = np.linspace(0.5, 1.0, num=int(budget / (6 * dim)))  # Dynamic scaling factor\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.95, self.population_size)  # Increased upper bound\n        self.dynamic_local_search_iters = np.random.randint(4, 8, self.population_size)  # Modified iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.mutation_scaling[target_idx]  # Dynamic scaling applied\n        adaptive_mutation_factor = self.base_mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + adaptive_mutation_factor * (self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim)  # Adjusted perturbation\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < 0.5:  # Simplified hybridization probability\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolutionV2", "description": "Introducing dynamic scaling of mutation strategies and multi-phase local search for improved convergence in diverse landscapes.", "configspace": "", "generation": 88, "fitness": 0.10890853013233058, "feedback": "The algorithm EnhancedDynamicDifferentialEvolutionV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.09.", "error": "", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.24551146071523877, 0.18900504280187413, 0.18166598913264942, 0.1915480584449577, 0.19363123648129454, 0.18171923634608778, 0.17150094666767324, 0.18633827848186846, 0.18726521968586007, 9.999999999998899e-05, 0.0005118573576852192, 9.999999999998899e-05, 0.0008953465034825525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.053790375470054275, 0.061471890616369596, 0.060579683497668735, 0.058467196400732835, 0.05106277431584805, 0.07481639806528528, 0.05393631618247163, 0.051138562626248274, 0.05793471462563049, 0.056662650724632835, 0.0449362562343677, 0.05511649745412783, 0.05925439364295948, 0.03394459861370158, 0.045493662109780564, 0.046812493032160285, 0.0485287907328833, 0.051777657756657214, 0.2843619482313505, 0.640614605878191, 0.4208783921251599, 0.2668627361874192, 0.4149635955269827, 0.40445448194568345, 0.19286487986536882, 0.3301923066582436, 0.24879351062154842, 0.07258104313063118, 0.08902551524252245, 0.10312479573600453, 0.08898500159153422, 0.06952498725962819, 0.06655557323164563, 0.06956850154852623, 0.0806879736013687, 0.09829556560512032, 0.14188265366358632, 0.19308637766117165, 0.12039350470596932, 0.1506133453325077, 0.1425639927745599, 0.13609762065581477, 0.136071846885772, 0.12883562501008383, 0.14385309935266954, 0.020082927699236808, 0.04172600193970266, 0.02237407286132076, 0.009503004149320815, 0.030136125252015145, 0.026028637268209254, 0.014645471298372459, 0.010830361371579111, 0.010058132972332157, 0.010920048207446409, 0.03156239361371649, 0.029184567687489782, 0.08709453680466306, 0.02284746848951158, 0.03286085290888874, 0.022149923854986042, 0.02860023901787967, 0.007549064887176993, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06861245469083466, 0.08149278274357552, 0.0628232493761991, 0.0773872538239675, 0.05143192141199304, 0.04927584154446285, 0.058615942418623446, 0.05769046646837672, 0.062404370341051285, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004885324653996936, 0.004455881610746615, 9.999999999998899e-05, 0.008900105420870053, 0.00041451233699629775, 0.002640200528211456, 0.008078473294930832, 0.002769677247121183, 0.002464557461618999, 0.20695657833199488, 0.2070854851560795, 0.21290726416483963, 0.22443518665760043, 0.22666000974678535, 0.20838090415743205, 0.20022045913652253, 0.19247714515293324, 0.19550419926120643, 0.07001479235545172, 0.05536410766908262, 0.051062156773232004, 0.05496004473150262, 0.05557566572438555, 0.07874463351028171, 0.057488027942171005, 0.05554479740472029, 0.062266138107999414, 0.19553928497901107, 0.13447645611132797, 0.1277130896847135, 0.15242597389548973, 0.145465795516608, 0.14962939821571908, 0.1553747937360207, 0.1324278813665023, 0.15004313136964942, 0.17527114152766876, 0.16594172850925737, 0.1820970019919208, 0.17127254980900708, 0.18551882300055156, 0.16685573766067807, 0.18722651972562865, 0.19055353239918404, 0.17913652997209606, 0.11135893287716059, 0.10553187752272264, 0.12110711464622548, 0.11672269002858116, 0.1184177888926462, 0.12961836697671003, 0.12742029545929823, 0.131382242321336, 0.11567629853469319, 0.17155166699292823, 0.15578821088801265, 0.16778249552170343, 0.17444384483820918, 0.1758988662846961, 0.17367267975104517, 0.18414837012274043, 0.17171649582094473, 0.1758864765032644, 0.14913855574526347, 0.15237745947807713, 0.14878461408652255, 0.14634977631144608, 0.15591948299809633, 0.15493468517227504, 0.13004064900958945, 0.14854376311545237, 0.1652877170267486, 0.13971984592579922, 0.173777409012413, 0.27251755357730634, 0.16985580862044658, 0.14767219989381608, 0.157301733961006, 0.16989691119494021, 0.15945920034680616, 0.15718710188031748, 0.15117108620383102, 0.14369080344780272, 0.1555420882581231, 0.1734932481889384, 0.15674474797983307, 0.14262076386285594, 0.17881188419507976, 0.16101357746015144, 0.14896437019377284, 0.18213314466114017, 0.18641272700065414, 0.18171558846469593, 0.18641312051197956, 0.17144177594180277, 0.18025894765629513, 0.21725755493613075, 0.19971685830924601, 0.18151895147303954, 0.05668324795473656, 0.06214608836512503, 0.05508828609208938, 0.05723801062982525, 0.06551536153607995, 0.05660318702804257, 0.05804017901731384, 0.06372711534207498, 0.06462573667150695]}, "mutation_prompt": null}
{"id": "0cfc2324-4124-431f-828c-4f2f5afb157d", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85  # Adjusted mutation factor for enhanced exploration\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(3, 6, self.population_size)  # Increased search iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)  # Adjusted perturbation for better local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)  # Adaptive opposition around mid-point\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Hybrid local search with adaptive probability\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.7:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing adaptive opposition and hybrid local search to accelerate convergence while maintaining diverse exploration.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.3077463200079953, 0.29800629202985396, 0.3025613883450171, 0.27060000676808615, 0.2964253163481396, 0.3139775566443388, 0.299689533340175, 0.2852803589865135, 0.30264009599547803, 0.030390373530886805, 0.022619902017002813, 0.05744768800337574, 0.022665187643416407, 0.022195674666327103, 0.028513928293954605, 0.03297552711165297, 0.038512374160619256, 0.06165542715695049, 0.09993005534542465, 0.10180310815625893, 0.09629099170821553, 0.09783416807060108, 0.1014471088962462, 0.10014467809949079, 0.09870180632984105, 0.10354004722757604, 0.09522959285025367, 0.08578432566353245, 0.0821955220488586, 0.08637978449951478, 0.09013304913308917, 0.08886658916793388, 0.09256766363142943, 0.08043763193193831, 0.08672009378035928, 0.08977870534806842, 0.4050114492967012, 0.5314024385859337, 0.35027454961845905, 0.41686022138508116, 0.4068927940498418, 0.3527118209195953, 0.33919465196930765, 0.4867638639301072, 0.3303767350560993, 0.0946337317676238, 0.11180378767878296, 0.1598312733474344, 0.12577925697277115, 0.09633577681971728, 0.08883473787463247, 0.13726660946641245, 0.1369245428341006, 0.12273296266741873, 0.20837197932348084, 0.16196334566232673, 0.1992613664863272, 0.20176968108776527, 0.20186820675468342, 0.20893907649120258, 0.1964563993712889, 0.2037196255505812, 0.17598002485325592, 0.06522698301884633, 0.08333539742339524, 0.07243358087909746, 0.06673057992411191, 0.07578717946068259, 0.08555571306861642, 0.0794883534914479, 0.09907256018648203, 0.07156790191190043, 0.06582649210988512, 0.07864057763779952, 0.09098668837343138, 0.1013120979331954, 0.06985443579283745, 0.0807632634149602, 0.0728990038062941, 0.09120043545518419, 0.08874793448271534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027381380250671605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10012850013535224, 0.09086467990256863, 0.09213120563736488, 0.09742740207871081, 0.11455789961260687, 0.0998825777597998, 0.10013619022648113, 0.09394430557175859, 0.10335848410808435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031006519457458692, 0.030840448987022318, 0.030815805181557687, 0.03115803173038456, 0.046711575916170256, 0.04460894322514941, 0.04729506665409977, 0.04104288171792503, 0.03413840419664316, 0.30921616727181367, 0.29057422648783693, 0.2967621429180982, 0.27764376008512703, 0.2955378620300333, 0.3026453617400586, 0.27741225865684305, 0.2953119171367573, 0.2919241388058428, 0.08355213951380558, 0.08860699937929317, 0.08386075129742787, 0.07246946252798425, 0.07122896366031672, 0.07219538361084687, 0.08327390753850505, 0.0805966186859689, 0.07551735838433249, 0.13385634043853167, 0.17180187713093076, 0.1675994334343346, 0.1660679929147666, 0.1645826807386389, 0.12833606853334678, 0.15136022848006436, 0.18518924731787145, 0.13610717811508966, 0.2150719156401838, 0.20821311466788328, 0.22742757466683539, 0.2082193784363049, 0.21475913033697014, 0.21323552027730808, 0.21895917694478773, 0.21878899369832427, 0.21800979920714636, 0.1549837311664285, 0.16251272264638916, 0.17382382111676176, 0.16419635381714837, 0.14525793019407252, 0.15822292884302647, 0.1666620410567624, 0.1586980835221662, 0.16194124409100985, 0.19761595001740784, 0.18784520300325735, 0.1945071097213259, 0.18189411975302106, 0.18440474108236105, 0.18494816835119565, 0.19182880353981513, 0.19222758520319982, 0.19867803134245687, 0.17676384629735387, 0.180977649483118, 0.1792723387390568, 0.17809003768452536, 0.17642268148475726, 0.18140421015843022, 0.1859001440838287, 0.17444197053441535, 0.17347647357064488, 0.21797498081645594, 0.24451143440678902, 0.22742593471067962, 0.27709451263785645, 0.27649594957169754, 0.211517461702451, 0.3366826057574279, 0.24208246360741825, 0.31364088870736306, 0.2698035055340351, 0.18516368463537758, 0.21181516901327546, 0.20913535070615308, 0.2320678061122775, 0.21361565728347398, 0.20805365355098415, 0.2964427551899559, 0.30697736954134114, 0.18476314099780045, 0.17618479847423774, 0.1972850149789469, 0.1922727813088566, 0.17937445702687005, 0.19182502251350564, 0.1905150686941921, 0.18328399343970125, 0.18405711750676534, 0.06799479994301294, 0.08268703975560254, 0.07421167810988716, 0.06818256862748018, 0.07168382116484084, 0.07242419562746505, 0.07494816592008369, 0.06990488309518439, 0.07093256766464906]}, "mutation_prompt": null}
{"id": "147d70ae-fbcf-4d6e-83c3-5ebc3f480e14", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85  # Adjusted mutation factor for enhanced exploration\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(3, 6, self.population_size)  # Increased search iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)  # Adjusted perturbation for better local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)  # Adaptive opposition around mid-point\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Hybrid local search with adaptive probability\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.7:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing adaptive opposition and hybrid local search to accelerate convergence while maintaining diverse exploration.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.3077463200079953, 0.29800629202985396, 0.3025613883450171, 0.27060000676808615, 0.2964253163481396, 0.3139775566443388, 0.299689533340175, 0.2852803589865135, 0.30264009599547803, 0.030390373530886805, 0.022619902017002813, 0.05744768800337574, 0.022665187643416407, 0.022195674666327103, 0.028513928293954605, 0.03297552711165297, 0.038512374160619256, 0.06165542715695049, 0.09993005534542465, 0.10180310815625893, 0.09629099170821553, 0.09783416807060108, 0.1014471088962462, 0.10014467809949079, 0.09870180632984105, 0.10354004722757604, 0.09522959285025367, 0.08578432566353245, 0.0821955220488586, 0.08637978449951478, 0.09013304913308917, 0.08886658916793388, 0.09256766363142943, 0.08043763193193831, 0.08672009378035928, 0.08977870534806842, 0.4050114492967012, 0.5314024385859337, 0.35027454961845905, 0.41686022138508116, 0.4068927940498418, 0.3527118209195953, 0.33919465196930765, 0.4867638639301072, 0.3303767350560993, 0.0946337317676238, 0.11180378767878296, 0.1598312733474344, 0.12577925697277115, 0.09633577681971728, 0.08883473787463247, 0.13726660946641245, 0.1369245428341006, 0.12273296266741873, 0.20837197932348084, 0.16196334566232673, 0.1992613664863272, 0.20176968108776527, 0.20186820675468342, 0.20893907649120258, 0.1964563993712889, 0.2037196255505812, 0.17598002485325592, 0.06522698301884633, 0.08333539742339524, 0.07243358087909746, 0.06673057992411191, 0.07578717946068259, 0.08555571306861642, 0.0794883534914479, 0.09907256018648203, 0.07156790191190043, 0.06582649210988512, 0.07864057763779952, 0.09098668837343138, 0.1013120979331954, 0.06985443579283745, 0.0807632634149602, 0.0728990038062941, 0.09120043545518419, 0.08874793448271534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027381380250671605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10012850013535224, 0.09086467990256863, 0.09213120563736488, 0.09742740207871081, 0.11455789961260687, 0.0998825777597998, 0.10013619022648113, 0.09394430557175859, 0.10335848410808435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031006519457458692, 0.030840448987022318, 0.030815805181557687, 0.03115803173038456, 0.046711575916170256, 0.04460894322514941, 0.04729506665409977, 0.04104288171792503, 0.03413840419664316, 0.30921616727181367, 0.29057422648783693, 0.2967621429180982, 0.27764376008512703, 0.2955378620300333, 0.3026453617400586, 0.27741225865684305, 0.2953119171367573, 0.2919241388058428, 0.08355213951380558, 0.08860699937929317, 0.08386075129742787, 0.07246946252798425, 0.07122896366031672, 0.07219538361084687, 0.08327390753850505, 0.0805966186859689, 0.07551735838433249, 0.13385634043853167, 0.17180187713093076, 0.1675994334343346, 0.1660679929147666, 0.1645826807386389, 0.12833606853334678, 0.15136022848006436, 0.18518924731787145, 0.13610717811508966, 0.2150719156401838, 0.20821311466788328, 0.22742757466683539, 0.2082193784363049, 0.21475913033697014, 0.21323552027730808, 0.21895917694478773, 0.21878899369832427, 0.21800979920714636, 0.1549837311664285, 0.16251272264638916, 0.17382382111676176, 0.16419635381714837, 0.14525793019407252, 0.15822292884302647, 0.1666620410567624, 0.1586980835221662, 0.16194124409100985, 0.19761595001740784, 0.18784520300325735, 0.1945071097213259, 0.18189411975302106, 0.18440474108236105, 0.18494816835119565, 0.19182880353981513, 0.19222758520319982, 0.19867803134245687, 0.17676384629735387, 0.180977649483118, 0.1792723387390568, 0.17809003768452536, 0.17642268148475726, 0.18140421015843022, 0.1859001440838287, 0.17444197053441535, 0.17347647357064488, 0.21797498081645594, 0.24451143440678902, 0.22742593471067962, 0.27709451263785645, 0.27649594957169754, 0.211517461702451, 0.3366826057574279, 0.24208246360741825, 0.31364088870736306, 0.2698035055340351, 0.18516368463537758, 0.21181516901327546, 0.20913535070615308, 0.2320678061122775, 0.21361565728347398, 0.20805365355098415, 0.2964427551899559, 0.30697736954134114, 0.18476314099780045, 0.17618479847423774, 0.1972850149789469, 0.1922727813088566, 0.17937445702687005, 0.19182502251350564, 0.1905150686941921, 0.18328399343970125, 0.18405711750676534, 0.06799479994301294, 0.08268703975560254, 0.07421167810988716, 0.06818256862748018, 0.07168382116484084, 0.07242419562746505, 0.07494816592008369, 0.06990488309518439, 0.07093256766464906]}, "mutation_prompt": null}
{"id": "0c1601ad-e69d-40ce-b030-0f95f702ee4f", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85  # Adjusted mutation factor for enhanced exploration\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(3, 6, self.population_size)  # Increased search iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)  # Adjusted perturbation for better local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)  # Adaptive opposition around mid-point\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Hybrid local search with adaptive probability\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.7:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing adaptive opposition and hybrid local search to accelerate convergence while maintaining diverse exploration.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.3077463200079953, 0.29800629202985396, 0.3025613883450171, 0.27060000676808615, 0.2964253163481396, 0.3139775566443388, 0.299689533340175, 0.2852803589865135, 0.30264009599547803, 0.030390373530886805, 0.022619902017002813, 0.05744768800337574, 0.022665187643416407, 0.022195674666327103, 0.028513928293954605, 0.03297552711165297, 0.038512374160619256, 0.06165542715695049, 0.09993005534542465, 0.10180310815625893, 0.09629099170821553, 0.09783416807060108, 0.1014471088962462, 0.10014467809949079, 0.09870180632984105, 0.10354004722757604, 0.09522959285025367, 0.08578432566353245, 0.0821955220488586, 0.08637978449951478, 0.09013304913308917, 0.08886658916793388, 0.09256766363142943, 0.08043763193193831, 0.08672009378035928, 0.08977870534806842, 0.4050114492967012, 0.5314024385859337, 0.35027454961845905, 0.41686022138508116, 0.4068927940498418, 0.3527118209195953, 0.33919465196930765, 0.4867638639301072, 0.3303767350560993, 0.0946337317676238, 0.11180378767878296, 0.1598312733474344, 0.12577925697277115, 0.09633577681971728, 0.08883473787463247, 0.13726660946641245, 0.1369245428341006, 0.12273296266741873, 0.20837197932348084, 0.16196334566232673, 0.1992613664863272, 0.20176968108776527, 0.20186820675468342, 0.20893907649120258, 0.1964563993712889, 0.2037196255505812, 0.17598002485325592, 0.06522698301884633, 0.08333539742339524, 0.07243358087909746, 0.06673057992411191, 0.07578717946068259, 0.08555571306861642, 0.0794883534914479, 0.09907256018648203, 0.07156790191190043, 0.06582649210988512, 0.07864057763779952, 0.09098668837343138, 0.1013120979331954, 0.06985443579283745, 0.0807632634149602, 0.0728990038062941, 0.09120043545518419, 0.08874793448271534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027381380250671605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10012850013535224, 0.09086467990256863, 0.09213120563736488, 0.09742740207871081, 0.11455789961260687, 0.0998825777597998, 0.10013619022648113, 0.09394430557175859, 0.10335848410808435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031006519457458692, 0.030840448987022318, 0.030815805181557687, 0.03115803173038456, 0.046711575916170256, 0.04460894322514941, 0.04729506665409977, 0.04104288171792503, 0.03413840419664316, 0.30921616727181367, 0.29057422648783693, 0.2967621429180982, 0.27764376008512703, 0.2955378620300333, 0.3026453617400586, 0.27741225865684305, 0.2953119171367573, 0.2919241388058428, 0.08355213951380558, 0.08860699937929317, 0.08386075129742787, 0.07246946252798425, 0.07122896366031672, 0.07219538361084687, 0.08327390753850505, 0.0805966186859689, 0.07551735838433249, 0.13385634043853167, 0.17180187713093076, 0.1675994334343346, 0.1660679929147666, 0.1645826807386389, 0.12833606853334678, 0.15136022848006436, 0.18518924731787145, 0.13610717811508966, 0.2150719156401838, 0.20821311466788328, 0.22742757466683539, 0.2082193784363049, 0.21475913033697014, 0.21323552027730808, 0.21895917694478773, 0.21878899369832427, 0.21800979920714636, 0.1549837311664285, 0.16251272264638916, 0.17382382111676176, 0.16419635381714837, 0.14525793019407252, 0.15822292884302647, 0.1666620410567624, 0.1586980835221662, 0.16194124409100985, 0.19761595001740784, 0.18784520300325735, 0.1945071097213259, 0.18189411975302106, 0.18440474108236105, 0.18494816835119565, 0.19182880353981513, 0.19222758520319982, 0.19867803134245687, 0.17676384629735387, 0.180977649483118, 0.1792723387390568, 0.17809003768452536, 0.17642268148475726, 0.18140421015843022, 0.1859001440838287, 0.17444197053441535, 0.17347647357064488, 0.21797498081645594, 0.24451143440678902, 0.22742593471067962, 0.27709451263785645, 0.27649594957169754, 0.211517461702451, 0.3366826057574279, 0.24208246360741825, 0.31364088870736306, 0.2698035055340351, 0.18516368463537758, 0.21181516901327546, 0.20913535070615308, 0.2320678061122775, 0.21361565728347398, 0.20805365355098415, 0.2964427551899559, 0.30697736954134114, 0.18476314099780045, 0.17618479847423774, 0.1972850149789469, 0.1922727813088566, 0.17937445702687005, 0.19182502251350564, 0.1905150686941921, 0.18328399343970125, 0.18405711750676534, 0.06799479994301294, 0.08268703975560254, 0.07421167810988716, 0.06818256862748018, 0.07168382116484084, 0.07242419562746505, 0.07494816592008369, 0.06990488309518439, 0.07093256766464906]}, "mutation_prompt": null}
{"id": "695bc87b-3457-4b54-a70b-2aff61206d0f", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85  # Adjusted mutation factor for enhanced exploration\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(3, 6, self.population_size)  # Increased search iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)  # Adjusted perturbation for better local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)  # Adaptive opposition around mid-point\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Hybrid local search with adaptive probability\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.7:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing adaptive opposition and hybrid local search to accelerate convergence while maintaining diverse exploration.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.3077463200079953, 0.29800629202985396, 0.3025613883450171, 0.27060000676808615, 0.2964253163481396, 0.3139775566443388, 0.299689533340175, 0.2852803589865135, 0.30264009599547803, 0.030390373530886805, 0.022619902017002813, 0.05744768800337574, 0.022665187643416407, 0.022195674666327103, 0.028513928293954605, 0.03297552711165297, 0.038512374160619256, 0.06165542715695049, 0.09993005534542465, 0.10180310815625893, 0.09629099170821553, 0.09783416807060108, 0.1014471088962462, 0.10014467809949079, 0.09870180632984105, 0.10354004722757604, 0.09522959285025367, 0.08578432566353245, 0.0821955220488586, 0.08637978449951478, 0.09013304913308917, 0.08886658916793388, 0.09256766363142943, 0.08043763193193831, 0.08672009378035928, 0.08977870534806842, 0.4050114492967012, 0.5314024385859337, 0.35027454961845905, 0.41686022138508116, 0.4068927940498418, 0.3527118209195953, 0.33919465196930765, 0.4867638639301072, 0.3303767350560993, 0.0946337317676238, 0.11180378767878296, 0.1598312733474344, 0.12577925697277115, 0.09633577681971728, 0.08883473787463247, 0.13726660946641245, 0.1369245428341006, 0.12273296266741873, 0.20837197932348084, 0.16196334566232673, 0.1992613664863272, 0.20176968108776527, 0.20186820675468342, 0.20893907649120258, 0.1964563993712889, 0.2037196255505812, 0.17598002485325592, 0.06522698301884633, 0.08333539742339524, 0.07243358087909746, 0.06673057992411191, 0.07578717946068259, 0.08555571306861642, 0.0794883534914479, 0.09907256018648203, 0.07156790191190043, 0.06582649210988512, 0.07864057763779952, 0.09098668837343138, 0.1013120979331954, 0.06985443579283745, 0.0807632634149602, 0.0728990038062941, 0.09120043545518419, 0.08874793448271534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027381380250671605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10012850013535224, 0.09086467990256863, 0.09213120563736488, 0.09742740207871081, 0.11455789961260687, 0.0998825777597998, 0.10013619022648113, 0.09394430557175859, 0.10335848410808435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031006519457458692, 0.030840448987022318, 0.030815805181557687, 0.03115803173038456, 0.046711575916170256, 0.04460894322514941, 0.04729506665409977, 0.04104288171792503, 0.03413840419664316, 0.30921616727181367, 0.29057422648783693, 0.2967621429180982, 0.27764376008512703, 0.2955378620300333, 0.3026453617400586, 0.27741225865684305, 0.2953119171367573, 0.2919241388058428, 0.08355213951380558, 0.08860699937929317, 0.08386075129742787, 0.07246946252798425, 0.07122896366031672, 0.07219538361084687, 0.08327390753850505, 0.0805966186859689, 0.07551735838433249, 0.13385634043853167, 0.17180187713093076, 0.1675994334343346, 0.1660679929147666, 0.1645826807386389, 0.12833606853334678, 0.15136022848006436, 0.18518924731787145, 0.13610717811508966, 0.2150719156401838, 0.20821311466788328, 0.22742757466683539, 0.2082193784363049, 0.21475913033697014, 0.21323552027730808, 0.21895917694478773, 0.21878899369832427, 0.21800979920714636, 0.1549837311664285, 0.16251272264638916, 0.17382382111676176, 0.16419635381714837, 0.14525793019407252, 0.15822292884302647, 0.1666620410567624, 0.1586980835221662, 0.16194124409100985, 0.19761595001740784, 0.18784520300325735, 0.1945071097213259, 0.18189411975302106, 0.18440474108236105, 0.18494816835119565, 0.19182880353981513, 0.19222758520319982, 0.19867803134245687, 0.17676384629735387, 0.180977649483118, 0.1792723387390568, 0.17809003768452536, 0.17642268148475726, 0.18140421015843022, 0.1859001440838287, 0.17444197053441535, 0.17347647357064488, 0.21797498081645594, 0.24451143440678902, 0.22742593471067962, 0.27709451263785645, 0.27649594957169754, 0.211517461702451, 0.3366826057574279, 0.24208246360741825, 0.31364088870736306, 0.2698035055340351, 0.18516368463537758, 0.21181516901327546, 0.20913535070615308, 0.2320678061122775, 0.21361565728347398, 0.20805365355098415, 0.2964427551899559, 0.30697736954134114, 0.18476314099780045, 0.17618479847423774, 0.1972850149789469, 0.1922727813088566, 0.17937445702687005, 0.19182502251350564, 0.1905150686941921, 0.18328399343970125, 0.18405711750676534, 0.06799479994301294, 0.08268703975560254, 0.07421167810988716, 0.06818256862748018, 0.07168382116484084, 0.07242419562746505, 0.07494816592008369, 0.06990488309518439, 0.07093256766464906]}, "mutation_prompt": null}
{"id": "681ca588-b036-4f0f-9146-395b82a4f03b", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(3, 8, self.population_size)  # Adjusted range\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.15)) * learning_rate  # Slightly increased range\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _trend_aware_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        trend_factor = 0.8  # Integrating trend factor\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.1, self.dim) * trend_factor\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _multi_trajectory_reinforcement(self):\n        path_choices = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        return path_choices\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        multi_trajectory_population = self._multi_trajectory_reinforcement()\n        evaluations += self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.dynamic_mutation_factor[i]:\n                        improved_solution = self._trend_aware_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Integrating multi-trajectorial search path reinforcement with trend-aware local search to boost convergence.", "configspace": "", "generation": 93, "fitness": 0.13542053868180856, "feedback": "The algorithm EnhancedDynamicDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.09.", "error": "", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.26753796630453563, 0.2910307750917346, 0.27683851055337483, 0.2606634297465076, 0.25735983224410197, 0.26115753004491293, 0.269812417291344, 0.25905574451480085, 0.27485821471617267, 0.029727046831528936, 0.019279943522834242, 0.0237302570600052, 0.013742066130814079, 0.00937911127671287, 0.02895175456747434, 0.015114187003943513, 0.0336682296755193, 0.022225236340173593, 0.09993163721264231, 0.0885970696389502, 0.10003855275830298, 0.09021079590840986, 0.09809713953482257, 0.09017931504262067, 0.09135123277963464, 0.0954238390417107, 0.09126832749848712, 0.07922986632192697, 0.07518318033804916, 0.07654410021780822, 0.0797107343841773, 0.08208977486189928, 0.06962684488616522, 0.07948849399575397, 0.07665935240092492, 0.08497083325328914, 0.24939769824253977, 0.4468820475673235, 0.3806292310440055, 0.4850065138030445, 0.21278849278247303, 0.21182477915318698, 0.3399460997831587, 0.18826202101546752, 0.18968214147405849, 0.09474872968280013, 0.101896739485, 0.11342213683298719, 0.10166467196223872, 0.07839496159385184, 0.09756176070176403, 0.10735363692655953, 0.14092900152386445, 0.10406618764958331, 0.16683138849777446, 0.1815432358420992, 0.15751046845109706, 0.200011179645471, 0.18435167725946022, 0.20311719688079422, 0.1729592285252729, 0.20145830971559653, 0.200996222851463, 0.10186276267379801, 0.09411369593278573, 0.08846652374499409, 0.05223620660514405, 0.06769526961262073, 0.06492655008368642, 0.07768210310740908, 0.060241164006127446, 0.06837725179313969, 0.07380757870370147, 0.0833136778827166, 0.0815552925752876, 0.09317973112442601, 0.07741171786180367, 0.07649922909040474, 0.06804484063169569, 0.06340629003883547, 0.09407537170447577, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0027890060583518617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0844169797798755, 0.08273773159608011, 0.10387258785741449, 0.11694334652014826, 0.07324614033007837, 0.09262484345516586, 0.08888816313969472, 0.07679498196964285, 0.08811686381977868, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031064618716348025, 0.03651611358623941, 0.04055446925920547, 0.01818709172938182, 0.03015036938064708, 0.0380109286696626, 0.018617916041033133, 0.034891623826759366, 0.03315804692973656, 0.28035271986884724, 0.26196318001427044, 0.27660164819318434, 0.2577386748225342, 0.27959225235265905, 0.2729132753610134, 0.25199747079030466, 0.25247152407589435, 0.257912340051369, 0.07092126609853089, 0.06986688575180344, 0.07282934079495684, 0.07133052529044526, 0.08618325166902263, 0.08633110204406946, 0.07045987257614339, 0.06724519048810673, 0.06807035245305737, 0.1687339713604994, 0.14251064020514181, 0.173703149605694, 0.1549608356515726, 0.1482684054810961, 0.1345348483814991, 0.1437243834237394, 0.1996318973312312, 0.15528305138734633, 0.2062218046294768, 0.2119223305265725, 0.20920521421452754, 0.19553785523331257, 0.22588343887426177, 0.20577827337247245, 0.20338507519115678, 0.1998035479673741, 0.21253379585694743, 0.13549866166572688, 0.14428589342087694, 0.14276653790300153, 0.14557595604776852, 0.14718247706355303, 0.1431149728921307, 0.1586000881774613, 0.16902141009987082, 0.15988335911102147, 0.18611056911256008, 0.19190838372538743, 0.19796081682310562, 0.17619486183446165, 0.1779232623637368, 0.1686403329838726, 0.19037689460330198, 0.18240117855589622, 0.18963883762666, 0.16856917482952227, 0.16847459086324867, 0.17133284279298167, 0.16677340614565905, 0.17214419942980452, 0.18250320246639906, 0.16844483056460924, 0.1878621280288758, 0.16516789763651318, 0.27405502052420483, 0.19894137844157, 0.2558161587723632, 0.28813877504072083, 0.22745797314119043, 0.24421872475954254, 0.24745595931787578, 0.23531143998375192, 0.22190193297196592, 0.21399812010187658, 0.2044057456904662, 0.2117736873493702, 0.21849640032039475, 0.22654944480457417, 0.16361687078480813, 0.19422771103769787, 0.2378787610853299, 0.17855410136345562, 0.1814736308307855, 0.18330313428262235, 0.17050823282889382, 0.18405460482536506, 0.189249440332372, 0.19223328155307207, 0.18705856321117997, 0.20396792812511966, 0.19415092491923358, 0.07529022423497322, 0.0707395008122712, 0.06475401848413098, 0.09196367506177083, 0.0688551791221711, 0.07185490434753394, 0.07331098386555257, 0.0712990996961238, 0.07306448336487592]}, "mutation_prompt": null}
{"id": "3608ef79-1bdb-46f6-b28c-914783bc77f6", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85  # Adjusted mutation factor for enhanced exploration\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(3, 6, self.population_size)  # Increased search iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)  # Adjusted perturbation for better local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)  # Adaptive opposition around mid-point\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Hybrid local search with adaptive probability\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.7:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing adaptive opposition and hybrid local search to accelerate convergence while maintaining diverse exploration.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.3077463200079953, 0.29800629202985396, 0.3025613883450171, 0.27060000676808615, 0.2964253163481396, 0.3139775566443388, 0.299689533340175, 0.2852803589865135, 0.30264009599547803, 0.030390373530886805, 0.022619902017002813, 0.05744768800337574, 0.022665187643416407, 0.022195674666327103, 0.028513928293954605, 0.03297552711165297, 0.038512374160619256, 0.06165542715695049, 0.09993005534542465, 0.10180310815625893, 0.09629099170821553, 0.09783416807060108, 0.1014471088962462, 0.10014467809949079, 0.09870180632984105, 0.10354004722757604, 0.09522959285025367, 0.08578432566353245, 0.0821955220488586, 0.08637978449951478, 0.09013304913308917, 0.08886658916793388, 0.09256766363142943, 0.08043763193193831, 0.08672009378035928, 0.08977870534806842, 0.4050114492967012, 0.5314024385859337, 0.35027454961845905, 0.41686022138508116, 0.4068927940498418, 0.3527118209195953, 0.33919465196930765, 0.4867638639301072, 0.3303767350560993, 0.0946337317676238, 0.11180378767878296, 0.1598312733474344, 0.12577925697277115, 0.09633577681971728, 0.08883473787463247, 0.13726660946641245, 0.1369245428341006, 0.12273296266741873, 0.20837197932348084, 0.16196334566232673, 0.1992613664863272, 0.20176968108776527, 0.20186820675468342, 0.20893907649120258, 0.1964563993712889, 0.2037196255505812, 0.17598002485325592, 0.06522698301884633, 0.08333539742339524, 0.07243358087909746, 0.06673057992411191, 0.07578717946068259, 0.08555571306861642, 0.0794883534914479, 0.09907256018648203, 0.07156790191190043, 0.06582649210988512, 0.07864057763779952, 0.09098668837343138, 0.1013120979331954, 0.06985443579283745, 0.0807632634149602, 0.0728990038062941, 0.09120043545518419, 0.08874793448271534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027381380250671605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10012850013535224, 0.09086467990256863, 0.09213120563736488, 0.09742740207871081, 0.11455789961260687, 0.0998825777597998, 0.10013619022648113, 0.09394430557175859, 0.10335848410808435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031006519457458692, 0.030840448987022318, 0.030815805181557687, 0.03115803173038456, 0.046711575916170256, 0.04460894322514941, 0.04729506665409977, 0.04104288171792503, 0.03413840419664316, 0.30921616727181367, 0.29057422648783693, 0.2967621429180982, 0.27764376008512703, 0.2955378620300333, 0.3026453617400586, 0.27741225865684305, 0.2953119171367573, 0.2919241388058428, 0.08355213951380558, 0.08860699937929317, 0.08386075129742787, 0.07246946252798425, 0.07122896366031672, 0.07219538361084687, 0.08327390753850505, 0.0805966186859689, 0.07551735838433249, 0.13385634043853167, 0.17180187713093076, 0.1675994334343346, 0.1660679929147666, 0.1645826807386389, 0.12833606853334678, 0.15136022848006436, 0.18518924731787145, 0.13610717811508966, 0.2150719156401838, 0.20821311466788328, 0.22742757466683539, 0.2082193784363049, 0.21475913033697014, 0.21323552027730808, 0.21895917694478773, 0.21878899369832427, 0.21800979920714636, 0.1549837311664285, 0.16251272264638916, 0.17382382111676176, 0.16419635381714837, 0.14525793019407252, 0.15822292884302647, 0.1666620410567624, 0.1586980835221662, 0.16194124409100985, 0.19761595001740784, 0.18784520300325735, 0.1945071097213259, 0.18189411975302106, 0.18440474108236105, 0.18494816835119565, 0.19182880353981513, 0.19222758520319982, 0.19867803134245687, 0.17676384629735387, 0.180977649483118, 0.1792723387390568, 0.17809003768452536, 0.17642268148475726, 0.18140421015843022, 0.1859001440838287, 0.17444197053441535, 0.17347647357064488, 0.21797498081645594, 0.24451143440678902, 0.22742593471067962, 0.27709451263785645, 0.27649594957169754, 0.211517461702451, 0.3366826057574279, 0.24208246360741825, 0.31364088870736306, 0.2698035055340351, 0.18516368463537758, 0.21181516901327546, 0.20913535070615308, 0.2320678061122775, 0.21361565728347398, 0.20805365355098415, 0.2964427551899559, 0.30697736954134114, 0.18476314099780045, 0.17618479847423774, 0.1972850149789469, 0.1922727813088566, 0.17937445702687005, 0.19182502251350564, 0.1905150686941921, 0.18328399343970125, 0.18405711750676534, 0.06799479994301294, 0.08268703975560254, 0.07421167810988716, 0.06818256862748018, 0.07168382116484084, 0.07242419562746505, 0.07494816592008369, 0.06990488309518439, 0.07093256766464906]}, "mutation_prompt": null}
{"id": "a6887c56-b019-4601-b5ef-e51131e03560", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.9  # Slightly increased mutation factor for better exploration\n        self.population_scaling = 0.4 + (0.4 * np.random.rand())\n        self.population_size = int(self.budget / (5.5 * dim))  # Adjusted population size for faster convergence\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.7, 0.95, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-1.5, 0.5, num=self.population_size)  # Modified learning rates\n        self.dynamic_local_search_iters = np.random.randint(2, 8, self.population_size)  # Diversified search iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.2, 0.2)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.2, self.dim)  # Increased perturbation for broader local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population) * 0.8  # Adjusted factor for opposition\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.8:  # Adjusted local search probability\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing adaptive learning rates and diversified local search mechanisms to enhance convergence speed while maintaining exploration.", "configspace": "", "generation": 95, "fitness": 0.13022086986402745, "feedback": "The algorithm EnhancedDynamicDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.10.", "error": "", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.22555265274841652, 0.23497964140602035, 0.26634930327155015, 0.2285725056761878, 0.23102907529646743, 0.23751982370800662, 0.23795210658106425, 0.2510801923893903, 0.23669517228260206, 0.004717078415389597, 9.999999999998899e-05, 0.001672869107163577, 9.999999999998899e-05, 0.0011769872293880823, 0.0013699386709253858, 9.999999999998899e-05, 0.0033211417263988574, 0.0034306232321541508, 0.08773546710243241, 0.07356316827290377, 0.08021916813905883, 0.07017919439798226, 0.0853538433775729, 0.08194094773077798, 0.07854777719877803, 0.07509700907237771, 0.07696773837693016, 0.0636911369987363, 0.06879267389538546, 0.0717528952527573, 0.06010843044588732, 0.07153395624732894, 0.06680037229629765, 0.0779827048368612, 0.05944160431737222, 0.07212663069367575, 0.29951858244261886, 0.6286094382987457, 0.39563074423621303, 0.38802403375478867, 0.22638127904215, 0.4542473255099281, 0.3581008465578188, 0.29253694506490424, 0.3412370194741411, 0.09371500732757543, 0.11492531504975445, 0.09587396475383625, 0.10060870137613909, 0.09171220103645028, 0.11486126199840818, 0.10612470942034724, 0.12894535754763115, 0.11554780332052983, 0.17453033431960208, 0.173271224386643, 0.16483058795523098, 0.17741103394196056, 0.17267890208797199, 0.16756432485292194, 0.15926798316995738, 0.17628725750274565, 0.19795973358043673, 0.047781151791557175, 0.04812953231307571, 0.06434706146711755, 0.048724479239388385, 0.04965427154531066, 0.045427816150075184, 0.06754835179078034, 0.07309617813039371, 0.050043356785886006, 0.06619022369009686, 0.0577768471097152, 0.0799371593866881, 0.06388756654532213, 0.06434592716465104, 0.06653093515384156, 0.06332937134842709, 0.05023871808971403, 0.044746793128407125, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09125015128969172, 0.08588566439882162, 0.09480664325329513, 0.0537509517968785, 0.08294735186215363, 0.08303495301119423, 0.07655907855211952, 0.10257801237635944, 0.12844735465114587, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024770843089290118, 0.009830389900759795, 0.026729764948089763, 0.01319351178273842, 0.021362747780872104, 0.01653389016823259, 0.020248144829621895, 0.017816626891601794, 0.013269971770186961, 0.24997850417345102, 0.23782755439237102, 0.258005737545253, 0.25834929775351234, 0.2369187063565209, 0.2537798675284183, 0.2606743181174809, 0.2427337214057479, 0.2545466793967971, 0.0628067774600044, 0.06428279062704167, 0.07483968189936274, 0.0697810260764854, 0.07776548685598406, 0.06175334243234232, 0.06351054072236162, 0.06631326268754223, 0.06958316198233183, 0.15102749940546056, 0.13938815741724375, 0.16470813652276028, 0.14659290856481477, 0.1337665854729181, 0.1582319952401594, 0.14568772603586344, 0.1589291501995027, 0.14464347891111307, 0.1906458550109391, 0.19364471117020854, 0.20300824136815443, 0.20107803492765153, 0.2029298704097946, 0.21050404660593625, 0.18472570844705571, 0.1985332397650016, 0.19101700722075643, 0.15449547655263363, 0.15794566769509422, 0.1534511505290348, 0.13543212234438984, 0.1426025700062986, 0.1442285722545832, 0.14525302937175166, 0.13875863355387918, 0.1303379854997393, 0.16899135877239768, 0.17672670471437746, 0.19136643836787548, 0.18377750054960929, 0.19255965946782272, 0.18044770444662828, 0.2046161862022453, 0.19996950248419676, 0.18605819900402754, 0.16951474487356977, 0.1665136437024456, 0.15878284977631862, 0.16624830993394113, 0.16328028741863543, 0.17290882260512408, 0.17585129817353085, 0.16802042158262154, 0.18020623072722342, 0.19407402884288594, 0.18799860689196735, 0.19355051687507807, 0.28126571614644347, 0.22785343478835052, 0.20416060606931463, 0.1429653021893077, 0.2350518534935636, 0.32509033084601, 0.2857125860895431, 0.176268212630036, 0.21546293180243503, 0.21174590246110203, 0.2287288493401044, 0.16312261673355788, 0.23924946966726646, 0.20335664090090144, 0.15889856172756733, 0.19541087005431823, 0.19204596166696375, 0.18423635904642022, 0.18949062488673418, 0.1917856156342549, 0.18868474375153865, 0.19068517614995184, 0.19737357158778623, 0.18852332267116478, 0.07887421165090436, 0.07134536105158618, 0.06446439952219862, 0.06656916790950873, 0.06471062016437557, 0.07361111441393953, 0.07545330261820093, 0.06816562700989526, 0.0663562510392236]}, "mutation_prompt": null}
{"id": "a0bfc860-38c4-40db-bd6b-d65486671828", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85  # Adjusted mutation factor for enhanced exploration\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(3, 6, self.population_size)  # Increased search iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)  # Adjusted perturbation for better local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)  # Adaptive opposition around mid-point\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Hybrid local search with adaptive probability\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.7:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing adaptive opposition and hybrid local search to accelerate convergence while maintaining diverse exploration.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.3077463200079953, 0.29800629202985396, 0.3025613883450171, 0.27060000676808615, 0.2964253163481396, 0.3139775566443388, 0.299689533340175, 0.2852803589865135, 0.30264009599547803, 0.030390373530886805, 0.022619902017002813, 0.05744768800337574, 0.022665187643416407, 0.022195674666327103, 0.028513928293954605, 0.03297552711165297, 0.038512374160619256, 0.06165542715695049, 0.09993005534542465, 0.10180310815625893, 0.09629099170821553, 0.09783416807060108, 0.1014471088962462, 0.10014467809949079, 0.09870180632984105, 0.10354004722757604, 0.09522959285025367, 0.08578432566353245, 0.0821955220488586, 0.08637978449951478, 0.09013304913308917, 0.08886658916793388, 0.09256766363142943, 0.08043763193193831, 0.08672009378035928, 0.08977870534806842, 0.4050114492967012, 0.5314024385859337, 0.35027454961845905, 0.41686022138508116, 0.4068927940498418, 0.3527118209195953, 0.33919465196930765, 0.4867638639301072, 0.3303767350560993, 0.0946337317676238, 0.11180378767878296, 0.1598312733474344, 0.12577925697277115, 0.09633577681971728, 0.08883473787463247, 0.13726660946641245, 0.1369245428341006, 0.12273296266741873, 0.20837197932348084, 0.16196334566232673, 0.1992613664863272, 0.20176968108776527, 0.20186820675468342, 0.20893907649120258, 0.1964563993712889, 0.2037196255505812, 0.17598002485325592, 0.06522698301884633, 0.08333539742339524, 0.07243358087909746, 0.06673057992411191, 0.07578717946068259, 0.08555571306861642, 0.0794883534914479, 0.09907256018648203, 0.07156790191190043, 0.06582649210988512, 0.07864057763779952, 0.09098668837343138, 0.1013120979331954, 0.06985443579283745, 0.0807632634149602, 0.0728990038062941, 0.09120043545518419, 0.08874793448271534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027381380250671605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10012850013535224, 0.09086467990256863, 0.09213120563736488, 0.09742740207871081, 0.11455789961260687, 0.0998825777597998, 0.10013619022648113, 0.09394430557175859, 0.10335848410808435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031006519457458692, 0.030840448987022318, 0.030815805181557687, 0.03115803173038456, 0.046711575916170256, 0.04460894322514941, 0.04729506665409977, 0.04104288171792503, 0.03413840419664316, 0.30921616727181367, 0.29057422648783693, 0.2967621429180982, 0.27764376008512703, 0.2955378620300333, 0.3026453617400586, 0.27741225865684305, 0.2953119171367573, 0.2919241388058428, 0.08355213951380558, 0.08860699937929317, 0.08386075129742787, 0.07246946252798425, 0.07122896366031672, 0.07219538361084687, 0.08327390753850505, 0.0805966186859689, 0.07551735838433249, 0.13385634043853167, 0.17180187713093076, 0.1675994334343346, 0.1660679929147666, 0.1645826807386389, 0.12833606853334678, 0.15136022848006436, 0.18518924731787145, 0.13610717811508966, 0.2150719156401838, 0.20821311466788328, 0.22742757466683539, 0.2082193784363049, 0.21475913033697014, 0.21323552027730808, 0.21895917694478773, 0.21878899369832427, 0.21800979920714636, 0.1549837311664285, 0.16251272264638916, 0.17382382111676176, 0.16419635381714837, 0.14525793019407252, 0.15822292884302647, 0.1666620410567624, 0.1586980835221662, 0.16194124409100985, 0.19761595001740784, 0.18784520300325735, 0.1945071097213259, 0.18189411975302106, 0.18440474108236105, 0.18494816835119565, 0.19182880353981513, 0.19222758520319982, 0.19867803134245687, 0.17676384629735387, 0.180977649483118, 0.1792723387390568, 0.17809003768452536, 0.17642268148475726, 0.18140421015843022, 0.1859001440838287, 0.17444197053441535, 0.17347647357064488, 0.21797498081645594, 0.24451143440678902, 0.22742593471067962, 0.27709451263785645, 0.27649594957169754, 0.211517461702451, 0.3366826057574279, 0.24208246360741825, 0.31364088870736306, 0.2698035055340351, 0.18516368463537758, 0.21181516901327546, 0.20913535070615308, 0.2320678061122775, 0.21361565728347398, 0.20805365355098415, 0.2964427551899559, 0.30697736954134114, 0.18476314099780045, 0.17618479847423774, 0.1972850149789469, 0.1922727813088566, 0.17937445702687005, 0.19182502251350564, 0.1905150686941921, 0.18328399343970125, 0.18405711750676534, 0.06799479994301294, 0.08268703975560254, 0.07421167810988716, 0.06818256862748018, 0.07168382116484084, 0.07242419562746505, 0.07494816592008369, 0.06990488309518439, 0.07093256766464906]}, "mutation_prompt": null}
{"id": "71524f6c-b5ca-4908-bdb0-9fbc91429144", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85  # Adjusted mutation factor for enhanced exploration\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(3, 6, self.population_size)  # Increased search iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)  # Adjusted perturbation for better local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)  # Adaptive opposition around mid-point\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Hybrid local search with adaptive probability\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.7:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing adaptive opposition and hybrid local search to accelerate convergence while maintaining diverse exploration.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.3077463200079953, 0.29800629202985396, 0.3025613883450171, 0.27060000676808615, 0.2964253163481396, 0.3139775566443388, 0.299689533340175, 0.2852803589865135, 0.30264009599547803, 0.030390373530886805, 0.022619902017002813, 0.05744768800337574, 0.022665187643416407, 0.022195674666327103, 0.028513928293954605, 0.03297552711165297, 0.038512374160619256, 0.06165542715695049, 0.09993005534542465, 0.10180310815625893, 0.09629099170821553, 0.09783416807060108, 0.1014471088962462, 0.10014467809949079, 0.09870180632984105, 0.10354004722757604, 0.09522959285025367, 0.08578432566353245, 0.0821955220488586, 0.08637978449951478, 0.09013304913308917, 0.08886658916793388, 0.09256766363142943, 0.08043763193193831, 0.08672009378035928, 0.08977870534806842, 0.4050114492967012, 0.5314024385859337, 0.35027454961845905, 0.41686022138508116, 0.4068927940498418, 0.3527118209195953, 0.33919465196930765, 0.4867638639301072, 0.3303767350560993, 0.0946337317676238, 0.11180378767878296, 0.1598312733474344, 0.12577925697277115, 0.09633577681971728, 0.08883473787463247, 0.13726660946641245, 0.1369245428341006, 0.12273296266741873, 0.20837197932348084, 0.16196334566232673, 0.1992613664863272, 0.20176968108776527, 0.20186820675468342, 0.20893907649120258, 0.1964563993712889, 0.2037196255505812, 0.17598002485325592, 0.06522698301884633, 0.08333539742339524, 0.07243358087909746, 0.06673057992411191, 0.07578717946068259, 0.08555571306861642, 0.0794883534914479, 0.09907256018648203, 0.07156790191190043, 0.06582649210988512, 0.07864057763779952, 0.09098668837343138, 0.1013120979331954, 0.06985443579283745, 0.0807632634149602, 0.0728990038062941, 0.09120043545518419, 0.08874793448271534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027381380250671605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10012850013535224, 0.09086467990256863, 0.09213120563736488, 0.09742740207871081, 0.11455789961260687, 0.0998825777597998, 0.10013619022648113, 0.09394430557175859, 0.10335848410808435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031006519457458692, 0.030840448987022318, 0.030815805181557687, 0.03115803173038456, 0.046711575916170256, 0.04460894322514941, 0.04729506665409977, 0.04104288171792503, 0.03413840419664316, 0.30921616727181367, 0.29057422648783693, 0.2967621429180982, 0.27764376008512703, 0.2955378620300333, 0.3026453617400586, 0.27741225865684305, 0.2953119171367573, 0.2919241388058428, 0.08355213951380558, 0.08860699937929317, 0.08386075129742787, 0.07246946252798425, 0.07122896366031672, 0.07219538361084687, 0.08327390753850505, 0.0805966186859689, 0.07551735838433249, 0.13385634043853167, 0.17180187713093076, 0.1675994334343346, 0.1660679929147666, 0.1645826807386389, 0.12833606853334678, 0.15136022848006436, 0.18518924731787145, 0.13610717811508966, 0.2150719156401838, 0.20821311466788328, 0.22742757466683539, 0.2082193784363049, 0.21475913033697014, 0.21323552027730808, 0.21895917694478773, 0.21878899369832427, 0.21800979920714636, 0.1549837311664285, 0.16251272264638916, 0.17382382111676176, 0.16419635381714837, 0.14525793019407252, 0.15822292884302647, 0.1666620410567624, 0.1586980835221662, 0.16194124409100985, 0.19761595001740784, 0.18784520300325735, 0.1945071097213259, 0.18189411975302106, 0.18440474108236105, 0.18494816835119565, 0.19182880353981513, 0.19222758520319982, 0.19867803134245687, 0.17676384629735387, 0.180977649483118, 0.1792723387390568, 0.17809003768452536, 0.17642268148475726, 0.18140421015843022, 0.1859001440838287, 0.17444197053441535, 0.17347647357064488, 0.21797498081645594, 0.24451143440678902, 0.22742593471067962, 0.27709451263785645, 0.27649594957169754, 0.211517461702451, 0.3366826057574279, 0.24208246360741825, 0.31364088870736306, 0.2698035055340351, 0.18516368463537758, 0.21181516901327546, 0.20913535070615308, 0.2320678061122775, 0.21361565728347398, 0.20805365355098415, 0.2964427551899559, 0.30697736954134114, 0.18476314099780045, 0.17618479847423774, 0.1972850149789469, 0.1922727813088566, 0.17937445702687005, 0.19182502251350564, 0.1905150686941921, 0.18328399343970125, 0.18405711750676534, 0.06799479994301294, 0.08268703975560254, 0.07421167810988716, 0.06818256862748018, 0.07168382116484084, 0.07242419562746505, 0.07494816592008369, 0.06990488309518439, 0.07093256766464906]}, "mutation_prompt": null}
{"id": "bd5798ae-4248-4090-9599-7d0496bed5f2", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85  # Adjusted mutation factor for enhanced exploration\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(3, 6, self.population_size)  # Increased search iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)  # Adjusted perturbation for better local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)  # Adaptive opposition around mid-point\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Hybrid local search with adaptive probability\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.7:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing adaptive opposition and hybrid local search to accelerate convergence while maintaining diverse exploration.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.3077463200079953, 0.29800629202985396, 0.3025613883450171, 0.27060000676808615, 0.2964253163481396, 0.3139775566443388, 0.299689533340175, 0.2852803589865135, 0.30264009599547803, 0.030390373530886805, 0.022619902017002813, 0.05744768800337574, 0.022665187643416407, 0.022195674666327103, 0.028513928293954605, 0.03297552711165297, 0.038512374160619256, 0.06165542715695049, 0.09993005534542465, 0.10180310815625893, 0.09629099170821553, 0.09783416807060108, 0.1014471088962462, 0.10014467809949079, 0.09870180632984105, 0.10354004722757604, 0.09522959285025367, 0.08578432566353245, 0.0821955220488586, 0.08637978449951478, 0.09013304913308917, 0.08886658916793388, 0.09256766363142943, 0.08043763193193831, 0.08672009378035928, 0.08977870534806842, 0.4050114492967012, 0.5314024385859337, 0.35027454961845905, 0.41686022138508116, 0.4068927940498418, 0.3527118209195953, 0.33919465196930765, 0.4867638639301072, 0.3303767350560993, 0.0946337317676238, 0.11180378767878296, 0.1598312733474344, 0.12577925697277115, 0.09633577681971728, 0.08883473787463247, 0.13726660946641245, 0.1369245428341006, 0.12273296266741873, 0.20837197932348084, 0.16196334566232673, 0.1992613664863272, 0.20176968108776527, 0.20186820675468342, 0.20893907649120258, 0.1964563993712889, 0.2037196255505812, 0.17598002485325592, 0.06522698301884633, 0.08333539742339524, 0.07243358087909746, 0.06673057992411191, 0.07578717946068259, 0.08555571306861642, 0.0794883534914479, 0.09907256018648203, 0.07156790191190043, 0.06582649210988512, 0.07864057763779952, 0.09098668837343138, 0.1013120979331954, 0.06985443579283745, 0.0807632634149602, 0.0728990038062941, 0.09120043545518419, 0.08874793448271534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027381380250671605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10012850013535224, 0.09086467990256863, 0.09213120563736488, 0.09742740207871081, 0.11455789961260687, 0.0998825777597998, 0.10013619022648113, 0.09394430557175859, 0.10335848410808435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031006519457458692, 0.030840448987022318, 0.030815805181557687, 0.03115803173038456, 0.046711575916170256, 0.04460894322514941, 0.04729506665409977, 0.04104288171792503, 0.03413840419664316, 0.30921616727181367, 0.29057422648783693, 0.2967621429180982, 0.27764376008512703, 0.2955378620300333, 0.3026453617400586, 0.27741225865684305, 0.2953119171367573, 0.2919241388058428, 0.08355213951380558, 0.08860699937929317, 0.08386075129742787, 0.07246946252798425, 0.07122896366031672, 0.07219538361084687, 0.08327390753850505, 0.0805966186859689, 0.07551735838433249, 0.13385634043853167, 0.17180187713093076, 0.1675994334343346, 0.1660679929147666, 0.1645826807386389, 0.12833606853334678, 0.15136022848006436, 0.18518924731787145, 0.13610717811508966, 0.2150719156401838, 0.20821311466788328, 0.22742757466683539, 0.2082193784363049, 0.21475913033697014, 0.21323552027730808, 0.21895917694478773, 0.21878899369832427, 0.21800979920714636, 0.1549837311664285, 0.16251272264638916, 0.17382382111676176, 0.16419635381714837, 0.14525793019407252, 0.15822292884302647, 0.1666620410567624, 0.1586980835221662, 0.16194124409100985, 0.19761595001740784, 0.18784520300325735, 0.1945071097213259, 0.18189411975302106, 0.18440474108236105, 0.18494816835119565, 0.19182880353981513, 0.19222758520319982, 0.19867803134245687, 0.17676384629735387, 0.180977649483118, 0.1792723387390568, 0.17809003768452536, 0.17642268148475726, 0.18140421015843022, 0.1859001440838287, 0.17444197053441535, 0.17347647357064488, 0.21797498081645594, 0.24451143440678902, 0.22742593471067962, 0.27709451263785645, 0.27649594957169754, 0.211517461702451, 0.3366826057574279, 0.24208246360741825, 0.31364088870736306, 0.2698035055340351, 0.18516368463537758, 0.21181516901327546, 0.20913535070615308, 0.2320678061122775, 0.21361565728347398, 0.20805365355098415, 0.2964427551899559, 0.30697736954134114, 0.18476314099780045, 0.17618479847423774, 0.1972850149789469, 0.1922727813088566, 0.17937445702687005, 0.19182502251350564, 0.1905150686941921, 0.18328399343970125, 0.18405711750676534, 0.06799479994301294, 0.08268703975560254, 0.07421167810988716, 0.06818256862748018, 0.07168382116484084, 0.07242419562746505, 0.07494816592008369, 0.06990488309518439, 0.07093256766464906]}, "mutation_prompt": null}
{"id": "33c0c0ab-4dc3-49a3-9465-ce8ba5af47c7", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85  # Adjusted mutation factor for enhanced exploration\n        self.population_scaling = 0.5 + (0.3 * np.random.rand())\n        self.population_size = int(self.budget / (6 * dim))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.adaptive_crossover_rate = np.linspace(0.6, 0.9, self.population_size)\n        self.dynamic_mutation_factor = np.logspace(-2, 0, num=self.population_size)\n        self.dynamic_local_search_iters = np.random.randint(3, 6, self.population_size)  # Increased search iterations\n\n    def _evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.population])\n\n    def _mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        learning_rate = self.dynamic_mutation_factor[target_idx]\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1)) * learning_rate\n        mutant_vector = self.population[a] + self.population_scaling * adaptive_mutation_factor * (\n            self.population[b] - self.population[c])\n        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n        return mutant_vector\n    \n    def _crossover(self, target, mutant, idx):\n        crossover_rate = self.adaptive_crossover_rate[idx]\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def _stochastic_local_search(self, solution, func, max_iters):\n        best_solution = solution.copy()\n        best_score = func(best_solution)\n        for _ in range(max_iters):\n            perturbation = np.random.normal(0.0, 0.15, self.dim)  # Adjusted perturbation for better local search\n            candidate_solution = np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate_solution)\n            if candidate_score < best_score:\n                best_solution = candidate_solution\n                best_score = candidate_score\n        return best_solution\n\n    def _adaptive_opposition_based_learning(self):\n        mid_point = (self.lower_bound + self.upper_bound) / 2\n        opposite_population = mid_point + (mid_point - self.population)  # Adaptive opposition around mid-point\n        opposite_population = np.clip(opposite_population, self.lower_bound, self.upper_bound)\n        return opposite_population\n\n    def __call__(self, func):\n        population_scores = self._evaluate_population(func)\n        evaluations = self.population_size\n\n        opposition_population = self._adaptive_opposition_based_learning()\n        opposition_scores = np.array([func(ind) for ind in opposition_population])\n        evaluations += self.population_size\n\n        for i in range(self.population_size):\n            if opposition_scores[i] < population_scores[i]:\n                self.population[i] = opposition_population[i]\n                population_scores[i] = opposition_scores[i]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant, i)\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < population_scores[i]:\n                    self.population[i] = trial\n                    population_scores[i] = trial_score\n\n                    # Hybrid local search with adaptive probability\n                    if np.random.rand() < self.dynamic_mutation_factor[i] * 0.7:\n                        improved_solution = self._stochastic_local_search(trial, func, self.dynamic_local_search_iters[i])\n                        improved_score = func(improved_solution)\n                        evaluations += 1\n\n                        if improved_score < trial_score:\n                            self.population[i] = improved_solution\n                            population_scores[i] = improved_score\n\n        best_index = np.argmin(population_scores)\n        return self.population[best_index]", "name": "EnhancedDynamicDifferentialEvolution", "description": "Introducing adaptive opposition and hybrid local search to accelerate convergence while maintaining diverse exploration.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66f4ede6-8747-4002-9726-0824cec21f0a", "metadata": {"aucs": [0.3077463200079953, 0.29800629202985396, 0.3025613883450171, 0.27060000676808615, 0.2964253163481396, 0.3139775566443388, 0.299689533340175, 0.2852803589865135, 0.30264009599547803, 0.030390373530886805, 0.022619902017002813, 0.05744768800337574, 0.022665187643416407, 0.022195674666327103, 0.028513928293954605, 0.03297552711165297, 0.038512374160619256, 0.06165542715695049, 0.09993005534542465, 0.10180310815625893, 0.09629099170821553, 0.09783416807060108, 0.1014471088962462, 0.10014467809949079, 0.09870180632984105, 0.10354004722757604, 0.09522959285025367, 0.08578432566353245, 0.0821955220488586, 0.08637978449951478, 0.09013304913308917, 0.08886658916793388, 0.09256766363142943, 0.08043763193193831, 0.08672009378035928, 0.08977870534806842, 0.4050114492967012, 0.5314024385859337, 0.35027454961845905, 0.41686022138508116, 0.4068927940498418, 0.3527118209195953, 0.33919465196930765, 0.4867638639301072, 0.3303767350560993, 0.0946337317676238, 0.11180378767878296, 0.1598312733474344, 0.12577925697277115, 0.09633577681971728, 0.08883473787463247, 0.13726660946641245, 0.1369245428341006, 0.12273296266741873, 0.20837197932348084, 0.16196334566232673, 0.1992613664863272, 0.20176968108776527, 0.20186820675468342, 0.20893907649120258, 0.1964563993712889, 0.2037196255505812, 0.17598002485325592, 0.06522698301884633, 0.08333539742339524, 0.07243358087909746, 0.06673057992411191, 0.07578717946068259, 0.08555571306861642, 0.0794883534914479, 0.09907256018648203, 0.07156790191190043, 0.06582649210988512, 0.07864057763779952, 0.09098668837343138, 0.1013120979331954, 0.06985443579283745, 0.0807632634149602, 0.0728990038062941, 0.09120043545518419, 0.08874793448271534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027381380250671605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10012850013535224, 0.09086467990256863, 0.09213120563736488, 0.09742740207871081, 0.11455789961260687, 0.0998825777597998, 0.10013619022648113, 0.09394430557175859, 0.10335848410808435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031006519457458692, 0.030840448987022318, 0.030815805181557687, 0.03115803173038456, 0.046711575916170256, 0.04460894322514941, 0.04729506665409977, 0.04104288171792503, 0.03413840419664316, 0.30921616727181367, 0.29057422648783693, 0.2967621429180982, 0.27764376008512703, 0.2955378620300333, 0.3026453617400586, 0.27741225865684305, 0.2953119171367573, 0.2919241388058428, 0.08355213951380558, 0.08860699937929317, 0.08386075129742787, 0.07246946252798425, 0.07122896366031672, 0.07219538361084687, 0.08327390753850505, 0.0805966186859689, 0.07551735838433249, 0.13385634043853167, 0.17180187713093076, 0.1675994334343346, 0.1660679929147666, 0.1645826807386389, 0.12833606853334678, 0.15136022848006436, 0.18518924731787145, 0.13610717811508966, 0.2150719156401838, 0.20821311466788328, 0.22742757466683539, 0.2082193784363049, 0.21475913033697014, 0.21323552027730808, 0.21895917694478773, 0.21878899369832427, 0.21800979920714636, 0.1549837311664285, 0.16251272264638916, 0.17382382111676176, 0.16419635381714837, 0.14525793019407252, 0.15822292884302647, 0.1666620410567624, 0.1586980835221662, 0.16194124409100985, 0.19761595001740784, 0.18784520300325735, 0.1945071097213259, 0.18189411975302106, 0.18440474108236105, 0.18494816835119565, 0.19182880353981513, 0.19222758520319982, 0.19867803134245687, 0.17676384629735387, 0.180977649483118, 0.1792723387390568, 0.17809003768452536, 0.17642268148475726, 0.18140421015843022, 0.1859001440838287, 0.17444197053441535, 0.17347647357064488, 0.21797498081645594, 0.24451143440678902, 0.22742593471067962, 0.27709451263785645, 0.27649594957169754, 0.211517461702451, 0.3366826057574279, 0.24208246360741825, 0.31364088870736306, 0.2698035055340351, 0.18516368463537758, 0.21181516901327546, 0.20913535070615308, 0.2320678061122775, 0.21361565728347398, 0.20805365355098415, 0.2964427551899559, 0.30697736954134114, 0.18476314099780045, 0.17618479847423774, 0.1972850149789469, 0.1922727813088566, 0.17937445702687005, 0.19182502251350564, 0.1905150686941921, 0.18328399343970125, 0.18405711750676534, 0.06799479994301294, 0.08268703975560254, 0.07421167810988716, 0.06818256862748018, 0.07168382116484084, 0.07242419562746505, 0.07494816592008369, 0.06990488309518439, 0.07093256766464906]}, "mutation_prompt": null}
