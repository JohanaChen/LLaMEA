{"id": "2ba6d4f4-5139-4688-b645-8e59dfe7046c", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                mutant = self.mutate(a, b, c)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c):\n        mutation = a + self.F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A hybrid Differential Evolution with Adaptive Local Search (DEALS) for efficient exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 0, "fitness": 0.26756665862497814, "feedback": "The algorithm DEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": null, "metadata": {"aucs": [0.613270331469187, 0.6258958226501584, 0.5870749066099039, 0.6365712786861815, 0.6459401369382454, 0.6475354752106718, 0.6238965184089815, 0.6110144538563027, 0.6199987607899016, 0.3144918918200881, 0.3475802846399608, 0.3539967448321202, 0.3370465967401849, 0.37259822264709275, 0.35422171909838973, 0.3517112335157937, 0.36916956523357636, 0.35925935472050585, 0.09438211284932929, 0.09399424449843741, 0.08896936541248757, 0.10005149858902496, 0.09312269122619687, 0.08994390577919098, 0.11178702376325855, 0.1105361553443035, 0.09135551924142693, 0.09060728081183655, 0.08827080696727752, 0.08560083002159558, 0.10348673525084451, 0.08119266870308661, 0.09484814875658609, 0.09049086489585623, 0.09653841187300205, 0.08612734512616571, 0.9422375745133456, 0.9279611758746413, 0.970334753101139, 0.9331971894679348, 0.9180662947740443, 0.9591292392977449, 0.9510012245298195, 0.9730245240164237, 0.9389110086497934, 0.27522314395040215, 0.28459492694989597, 0.25921353020992466, 0.28965971311046557, 0.2718314257369333, 0.28989184903511467, 0.3352022915443257, 0.2819439545620793, 0.2784295190208501, 0.5407235660722138, 0.4012219810974118, 0.4279159159541672, 0.6247898314209537, 0.5395470057881797, 0.4973957049304115, 0.5287400566054581, 0.46324762437727973, 0.5524185607052914, 0.1662286054021671, 0.19114887210275733, 0.18509202571349814, 0.19393955612749436, 0.20506677150303299, 0.17807964029842094, 0.204646382805855, 0.1978390349789504, 0.1797026067114451, 0.22854221388923912, 0.20556843137806835, 0.23856445260927617, 0.1817475627934697, 0.18603047072929169, 0.1976390057530507, 0.19267739773915282, 0.18681613029250554, 0.2030933556834884, 0.09058782462294479, 0.14882842778054328, 0.1266782511073823, 0.14519317447083413, 0.12079477580706877, 0.07929331469540724, 0.11966524430128844, 0.13385841280792588, 0.10178956841696596, 0.26532518113491244, 0.24420394190622108, 0.23379230945762153, 0.19473809339058967, 0.23149130733820467, 0.22865843897122795, 0.24131430004459453, 0.23329950655801646, 0.27588751293463476, 0.021943419940596343, 0.013025071013518352, 0.04240732935656655, 0.027444732723628462, 0.02369063187090703, 0.019405870563226957, 0.018499647161437816, 0.014593467545289007, 0.01684496907285704, 0.15032863466481705, 0.14289751598885536, 0.1591384546327499, 0.15617872935474864, 0.1477645815072075, 0.16816068062038358, 0.1537163000318036, 0.14379657879213226, 0.137992580619822, 0.47633411457797603, 0.4806910994889465, 0.4940904415191718, 0.4881407653722122, 0.47158099758803207, 0.46628251865085013, 0.48452184113057417, 0.46625690122542696, 0.468195521112307, 0.10351625396526032, 0.09229254700307354, 0.10005369822766019, 0.08597881462048318, 0.09932138976188232, 0.0827154761655371, 0.09007055024076838, 0.09437514463047414, 0.09883735457352416, 0.19231855340155124, 0.1527233734046618, 0.16157228925907785, 0.17885503730419838, 0.18252668339842326, 0.17896300625231254, 0.14971090215781702, 0.20793221250898242, 0.14937192281394274, 0.2824004302940176, 0.2708157998650538, 0.27367624085198794, 0.27057584059923123, 0.2531827596416064, 0.2295900989896169, 0.2841189072756357, 0.28784692850742155, 0.30356298024618356, 0.2154360543366013, 0.19302197617019512, 0.21714290032560468, 0.21402008727452493, 0.2142484112383043, 0.1874091527109485, 0.19320551112488527, 0.21769061433338344, 0.21894314026801287, 0.2015704074317578, 0.16750608756991237, 0.18482259167911974, 0.19330195794489358, 0.18750637745133136, 0.1848776168116235, 0.1808028318689474, 0.2022265959108519, 0.199240168046675, 0.17840221218980046, 0.17302829688326982, 0.18261107600995474, 0.19479239131730153, 0.1839794162540136, 0.1792537954123069, 0.1850177747270112, 0.17612530666172155, 0.18034447838667234, 0.7293020260840269, 0.19209212244774476, 0.6613245977712534, 0.1755857176996758, 0.2933445058714311, 0.40804344633567236, 0.3481197350686259, 0.4746703223147458, 0.18546563356475643, 0.5407298932442539, 0.20897381189090025, 0.48651069193400787, 0.3480935816649926, 0.20822189969797067, 0.29057819191671763, 0.21030484021729245, 0.6442148839304698, 0.20881562702534584, 0.1961573655838107, 0.1904054375634361, 0.183425785809897, 0.18524374579342961, 0.18520400724795993, 0.20036385251953015, 0.17876746065598437, 0.18021791517979868, 0.2108821614977623, 0.07116383752390665, 0.0750786900658097, 0.08331860303222582, 0.08807683407891187, 0.07764485545478805, 0.06924827140792222, 0.08383190134748397, 0.07016644616564827, 0.07719914643009329]}, "mutation_prompt": null}
{"id": "4fbbeabd-adc1-425a-b44b-a11926b88559", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                mutant = self.mutate(a, b, c)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c):\n        mutation = a + self.F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A hybrid Differential Evolution with Adaptive Local Search (DEALS) for efficient exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2ba6d4f4-5139-4688-b645-8e59dfe7046c", "metadata": {"aucs": [0.613270331469187, 0.6258958226501584, 0.5870749066099039, 0.6365712786861815, 0.6459401369382454, 0.6475354752106718, 0.6238965184089815, 0.6110144538563027, 0.6199987607899016, 0.3144918918200881, 0.3475802846399608, 0.3539967448321202, 0.3370465967401849, 0.37259822264709275, 0.35422171909838973, 0.3517112335157937, 0.36916956523357636, 0.35925935472050585, 0.09438211284932929, 0.09399424449843741, 0.08896936541248757, 0.10005149858902496, 0.09312269122619687, 0.08994390577919098, 0.11178702376325855, 0.1105361553443035, 0.09135551924142693, 0.09060728081183655, 0.08827080696727752, 0.08560083002159558, 0.10348673525084451, 0.08119266870308661, 0.09484814875658609, 0.09049086489585623, 0.09653841187300205, 0.08612734512616571, 0.9422375745133456, 0.9279611758746413, 0.970334753101139, 0.9331971894679348, 0.9180662947740443, 0.9591292392977449, 0.9510012245298195, 0.9730245240164237, 0.9389110086497934, 0.27522314395040215, 0.28459492694989597, 0.25921353020992466, 0.28965971311046557, 0.2718314257369333, 0.28989184903511467, 0.3352022915443257, 0.2819439545620793, 0.2784295190208501, 0.5407235660722138, 0.4012219810974118, 0.4279159159541672, 0.6247898314209537, 0.5395470057881797, 0.4973957049304115, 0.5287400566054581, 0.46324762437727973, 0.5524185607052914, 0.1662286054021671, 0.19114887210275733, 0.18509202571349814, 0.19393955612749436, 0.20506677150303299, 0.17807964029842094, 0.204646382805855, 0.1978390349789504, 0.1797026067114451, 0.22854221388923912, 0.20556843137806835, 0.23856445260927617, 0.1817475627934697, 0.18603047072929169, 0.1976390057530507, 0.19267739773915282, 0.18681613029250554, 0.2030933556834884, 0.09058782462294479, 0.14882842778054328, 0.1266782511073823, 0.14519317447083413, 0.12079477580706877, 0.07929331469540724, 0.11966524430128844, 0.13385841280792588, 0.10178956841696596, 0.26532518113491244, 0.24420394190622108, 0.23379230945762153, 0.19473809339058967, 0.23149130733820467, 0.22865843897122795, 0.24131430004459453, 0.23329950655801646, 0.27588751293463476, 0.021943419940596343, 0.013025071013518352, 0.04240732935656655, 0.027444732723628462, 0.02369063187090703, 0.019405870563226957, 0.018499647161437816, 0.014593467545289007, 0.01684496907285704, 0.15032863466481705, 0.14289751598885536, 0.1591384546327499, 0.15617872935474864, 0.1477645815072075, 0.16816068062038358, 0.1537163000318036, 0.14379657879213226, 0.137992580619822, 0.47633411457797603, 0.4806910994889465, 0.4940904415191718, 0.4881407653722122, 0.47158099758803207, 0.46628251865085013, 0.48452184113057417, 0.46625690122542696, 0.468195521112307, 0.10351625396526032, 0.09229254700307354, 0.10005369822766019, 0.08597881462048318, 0.09932138976188232, 0.0827154761655371, 0.09007055024076838, 0.09437514463047414, 0.09883735457352416, 0.19231855340155124, 0.1527233734046618, 0.16157228925907785, 0.17885503730419838, 0.18252668339842326, 0.17896300625231254, 0.14971090215781702, 0.20793221250898242, 0.14937192281394274, 0.2824004302940176, 0.2708157998650538, 0.27367624085198794, 0.27057584059923123, 0.2531827596416064, 0.2295900989896169, 0.2841189072756357, 0.28784692850742155, 0.30356298024618356, 0.2154360543366013, 0.19302197617019512, 0.21714290032560468, 0.21402008727452493, 0.2142484112383043, 0.1874091527109485, 0.19320551112488527, 0.21769061433338344, 0.21894314026801287, 0.2015704074317578, 0.16750608756991237, 0.18482259167911974, 0.19330195794489358, 0.18750637745133136, 0.1848776168116235, 0.1808028318689474, 0.2022265959108519, 0.199240168046675, 0.17840221218980046, 0.17302829688326982, 0.18261107600995474, 0.19479239131730153, 0.1839794162540136, 0.1792537954123069, 0.1850177747270112, 0.17612530666172155, 0.18034447838667234, 0.7293020260840269, 0.19209212244774476, 0.6613245977712534, 0.1755857176996758, 0.2933445058714311, 0.40804344633567236, 0.3481197350686259, 0.4746703223147458, 0.18546563356475643, 0.5407298932442539, 0.20897381189090025, 0.48651069193400787, 0.3480935816649926, 0.20822189969797067, 0.29057819191671763, 0.21030484021729245, 0.6442148839304698, 0.20881562702534584, 0.1961573655838107, 0.1904054375634361, 0.183425785809897, 0.18524374579342961, 0.18520400724795993, 0.20036385251953015, 0.17876746065598437, 0.18021791517979868, 0.2108821614977623, 0.07116383752390665, 0.0750786900658097, 0.08331860303222582, 0.08807683407891187, 0.07764485545478805, 0.06924827140792222, 0.08383190134748397, 0.07016644616564827, 0.07719914643009329]}, "mutation_prompt": null}
{"id": "fa5cefbc-d6c7-4def-ae04-64f4888d5835", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                mutant = self.mutate(a, b, c)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c):\n        mutation = a + self.F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A hybrid Differential Evolution with Adaptive Local Search (DEALS) for efficient exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2ba6d4f4-5139-4688-b645-8e59dfe7046c", "metadata": {"aucs": [0.613270331469187, 0.6258958226501584, 0.5870749066099039, 0.6365712786861815, 0.6459401369382454, 0.6475354752106718, 0.6238965184089815, 0.6110144538563027, 0.6199987607899016, 0.3144918918200881, 0.3475802846399608, 0.3539967448321202, 0.3370465967401849, 0.37259822264709275, 0.35422171909838973, 0.3517112335157937, 0.36916956523357636, 0.35925935472050585, 0.09438211284932929, 0.09399424449843741, 0.08896936541248757, 0.10005149858902496, 0.09312269122619687, 0.08994390577919098, 0.11178702376325855, 0.1105361553443035, 0.09135551924142693, 0.09060728081183655, 0.08827080696727752, 0.08560083002159558, 0.10348673525084451, 0.08119266870308661, 0.09484814875658609, 0.09049086489585623, 0.09653841187300205, 0.08612734512616571, 0.9422375745133456, 0.9279611758746413, 0.970334753101139, 0.9331971894679348, 0.9180662947740443, 0.9591292392977449, 0.9510012245298195, 0.9730245240164237, 0.9389110086497934, 0.27522314395040215, 0.28459492694989597, 0.25921353020992466, 0.28965971311046557, 0.2718314257369333, 0.28989184903511467, 0.3352022915443257, 0.2819439545620793, 0.2784295190208501, 0.5407235660722138, 0.4012219810974118, 0.4279159159541672, 0.6247898314209537, 0.5395470057881797, 0.4973957049304115, 0.5287400566054581, 0.46324762437727973, 0.5524185607052914, 0.1662286054021671, 0.19114887210275733, 0.18509202571349814, 0.19393955612749436, 0.20506677150303299, 0.17807964029842094, 0.204646382805855, 0.1978390349789504, 0.1797026067114451, 0.22854221388923912, 0.20556843137806835, 0.23856445260927617, 0.1817475627934697, 0.18603047072929169, 0.1976390057530507, 0.19267739773915282, 0.18681613029250554, 0.2030933556834884, 0.09058782462294479, 0.14882842778054328, 0.1266782511073823, 0.14519317447083413, 0.12079477580706877, 0.07929331469540724, 0.11966524430128844, 0.13385841280792588, 0.10178956841696596, 0.26532518113491244, 0.24420394190622108, 0.23379230945762153, 0.19473809339058967, 0.23149130733820467, 0.22865843897122795, 0.24131430004459453, 0.23329950655801646, 0.27588751293463476, 0.021943419940596343, 0.013025071013518352, 0.04240732935656655, 0.027444732723628462, 0.02369063187090703, 0.019405870563226957, 0.018499647161437816, 0.014593467545289007, 0.01684496907285704, 0.15032863466481705, 0.14289751598885536, 0.1591384546327499, 0.15617872935474864, 0.1477645815072075, 0.16816068062038358, 0.1537163000318036, 0.14379657879213226, 0.137992580619822, 0.47633411457797603, 0.4806910994889465, 0.4940904415191718, 0.4881407653722122, 0.47158099758803207, 0.46628251865085013, 0.48452184113057417, 0.46625690122542696, 0.468195521112307, 0.10351625396526032, 0.09229254700307354, 0.10005369822766019, 0.08597881462048318, 0.09932138976188232, 0.0827154761655371, 0.09007055024076838, 0.09437514463047414, 0.09883735457352416, 0.19231855340155124, 0.1527233734046618, 0.16157228925907785, 0.17885503730419838, 0.18252668339842326, 0.17896300625231254, 0.14971090215781702, 0.20793221250898242, 0.14937192281394274, 0.2824004302940176, 0.2708157998650538, 0.27367624085198794, 0.27057584059923123, 0.2531827596416064, 0.2295900989896169, 0.2841189072756357, 0.28784692850742155, 0.30356298024618356, 0.2154360543366013, 0.19302197617019512, 0.21714290032560468, 0.21402008727452493, 0.2142484112383043, 0.1874091527109485, 0.19320551112488527, 0.21769061433338344, 0.21894314026801287, 0.2015704074317578, 0.16750608756991237, 0.18482259167911974, 0.19330195794489358, 0.18750637745133136, 0.1848776168116235, 0.1808028318689474, 0.2022265959108519, 0.199240168046675, 0.17840221218980046, 0.17302829688326982, 0.18261107600995474, 0.19479239131730153, 0.1839794162540136, 0.1792537954123069, 0.1850177747270112, 0.17612530666172155, 0.18034447838667234, 0.7293020260840269, 0.19209212244774476, 0.6613245977712534, 0.1755857176996758, 0.2933445058714311, 0.40804344633567236, 0.3481197350686259, 0.4746703223147458, 0.18546563356475643, 0.5407298932442539, 0.20897381189090025, 0.48651069193400787, 0.3480935816649926, 0.20822189969797067, 0.29057819191671763, 0.21030484021729245, 0.6442148839304698, 0.20881562702534584, 0.1961573655838107, 0.1904054375634361, 0.183425785809897, 0.18524374579342961, 0.18520400724795993, 0.20036385251953015, 0.17876746065598437, 0.18021791517979868, 0.2108821614977623, 0.07116383752390665, 0.0750786900658097, 0.08331860303222582, 0.08807683407891187, 0.07764485545478805, 0.06924827140792222, 0.08383190134748397, 0.07016644616564827, 0.07719914643009329]}, "mutation_prompt": null}
{"id": "4d504ada-b47f-4091-9468-06baf2b3ec08", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.85  # Adjusted mutation factor for improved exploration\n        self.CR = 0.95  # Increased crossover probability for better recombination\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                mutant = self.mutate(a, b, c)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c):\n        mutation = a + self.F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover_mask, mutant, target)\n        if np.random.rand() < 0.1:  # Occasionally allow full replacement to escape local optima\n            trial = mutant\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.04  # Slightly reduced step size for finer local adjustments\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "An enhanced hybrid Differential Evolution with a refined crossover strategy and adaptive step size for local search to improve convergence speed.", "configspace": "", "generation": 3, "fitness": 0.2593320875330335, "feedback": "The algorithm DEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "2ba6d4f4-5139-4688-b645-8e59dfe7046c", "metadata": {"aucs": [0.5495692383939014, 0.5548731873299575, 0.5508224018572383, 0.6033911547584865, 0.5928723710614221, 0.5316112840841024, 0.5921381998771691, 0.5491873360866992, 0.5562475094001044, 0.2860458265870398, 0.25553470218256047, 0.31219719163357207, 0.3038207259545065, 0.3040605265107349, 0.27706134223134227, 0.2993369351363593, 0.3177973234909186, 0.26326436249685725, 0.09276656290235819, 0.10655825223386306, 0.10550913865443456, 0.0854625388707263, 0.083706671416381, 0.0888955576096514, 0.09912360446095914, 0.08129822353829508, 0.07788198590462003, 0.07657081945575117, 0.0871601045871756, 0.09008772402321719, 0.07618657981060128, 0.08503946436244403, 0.07798786921012957, 0.08175388519391602, 0.08892674889849173, 0.07972459223126793, 0.8871680365053124, 0.9420473571546193, 0.9031869145812919, 0.9691291137805337, 0.9150352602603145, 0.966270373567647, 0.9487598541986944, 0.9730258842003205, 0.9418289768676744, 0.2812927076006636, 0.2667251980340548, 0.27323252240887463, 0.2651312683415036, 0.2700586659224862, 0.2672791228841863, 0.28262295054395004, 0.2501790605986466, 0.29838939667659004, 0.5158302627038603, 0.4968752737356318, 0.4993954277679351, 0.5278109624369288, 0.5040807859413003, 0.49319520182755616, 0.2972568241047102, 0.5663437354444023, 0.4913824989166402, 0.1776432280338921, 0.14304331653975189, 0.18013746054794466, 0.1641433052028568, 0.16157122810803737, 0.17158091538789377, 0.18547988400617976, 0.18520172829467274, 0.17889020716390736, 0.12146711776128871, 0.2667951174235139, 0.2382646188015486, 0.18166454841936708, 0.1938060869528293, 0.19010026344619513, 0.18393930446187134, 0.1634026951440377, 0.15926916245486866, 0.16252936682854557, 0.1406933967116718, 0.13197697527564745, 0.18368703710630052, 0.1383700409443056, 0.15097823430683366, 0.12420790004807736, 0.161621531634764, 0.1814144733121661, 0.2979769998441818, 0.2519045145264621, 0.26351764983401815, 0.2533661422184429, 0.26024940350424286, 0.2708772015830274, 0.30637413870642827, 0.3013323852847226, 0.30731538252055657, 0.01774285907095219, 0.025183414336890197, 0.02105014751644252, 0.036808579137295405, 0.05356821055880756, 0.008291690264633833, 0.04143880934785338, 0.027123784419541552, 0.018045801240086257, 0.16514404161896767, 0.14092288154226718, 0.15700103543920885, 0.1336977752120322, 0.1535987967351954, 0.17969150505097153, 0.15299213910900922, 0.16925657700345365, 0.1536096575274618, 0.4623660237511311, 0.48106698300671, 0.46639187369265234, 0.4605144589287935, 0.4969663563197907, 0.4812492473060146, 0.48176603403890306, 0.46648654784585153, 0.4737347882891563, 0.10100002966330524, 0.0878444842677556, 0.09545477823565451, 0.08884234058886908, 0.08666843563687654, 0.08182370347907386, 0.10323722109290034, 0.07973239072821636, 0.10258896119882344, 0.13772089799957377, 0.16831215804598154, 0.1691814505773287, 0.2056305951708688, 0.19309097570168354, 0.23992042872233943, 0.26385769191149844, 0.17321983953125442, 0.2193053297326103, 0.26519304384108655, 0.2810015721719339, 0.25310472311641374, 0.28571270857731745, 0.24474975766346596, 0.2657933094757553, 0.279796797718349, 0.28597705350124125, 0.25396718643565286, 0.1924914199634803, 0.19452699908717253, 0.2041763006923184, 0.18467626954942518, 0.1930187865491909, 0.19753270492277886, 0.2150588450901133, 0.2137948205297051, 0.2132378235819674, 0.17650726025198749, 0.18831823823484917, 0.2027877042439128, 0.202292529030614, 0.18558216245497183, 0.17868907969671854, 0.19932607098518706, 0.18264156855042157, 0.18483269030960559, 0.1888146504140571, 0.17869563487196305, 0.1790906335516631, 0.18032148108074364, 0.17068047728195157, 0.1887530238385675, 0.1838994549204651, 0.17832022222495691, 0.1733150256362853, 0.18593732916102246, 0.2051919120335628, 0.6862760011951623, 0.4751711994095146, 0.19808968513740943, 0.3387640379697635, 0.37811623788356397, 0.17595514536920587, 0.19314942541489521, 0.6301305698423099, 0.20956179900016703, 0.20832876061899774, 0.3597432818046701, 0.4442979843572509, 0.20217488804116523, 0.5723286321965722, 0.21047359034801172, 0.20797965672011587, 0.1984590445843012, 0.18407586161020761, 0.18427572178706508, 0.19055850541261798, 0.19311443696147024, 0.1911211309823334, 0.16899350174796146, 0.18716566682980884, 0.20348196654813955, 0.07340072398927955, 0.08581006011352643, 0.06613464744115705, 0.07685345246324582, 0.08224731953538922, 0.06564687541158287, 0.07612012771698662, 0.07220776294641784, 0.07177566212477104]}, "mutation_prompt": null}
{"id": "c22b77b7-1b79-4806-b4c2-eab01c6bdcff", "solution": "import numpy as np\n\nclass EnhancedDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Adjusted population size for better exploration\n        self.F = 0.9  # Increased mutation factor for diverse exploration\n        self.CR = 0.85  # Slightly reduced crossover probability for more stable solutions\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n        \n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                mutant = self.mutate(a, b, c)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c):\n        mutation = a + self.F * (b - c + np.random.uniform(-0.5, 0.5, self.dim))  # Added random factor\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "EnhancedDEALS", "description": "An enhanced DEALS algorithm with modified mutation strategy and adaptive population size to improve convergence speed.", "configspace": "", "generation": 4, "fitness": 0.1839459408226988, "feedback": "The algorithm EnhancedDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": "2ba6d4f4-5139-4688-b645-8e59dfe7046c", "metadata": {"aucs": [0.36451668368116363, 0.34205731365310343, 0.36291185442264173, 0.35685329632673124, 0.36729047321385433, 0.3398688444213074, 0.3590527925995599, 0.3833783264744042, 0.35975011782570177, 0.010669294663371742, 0.006314807395351951, 0.03677397670655702, 0.0080983058102998, 0.0008925124071184065, 0.0005791963635362052, 0.015125809689193193, 0.014861772242906968, 0.010520126946920727, 0.08514734957785108, 0.08970809102360344, 0.09005922342306838, 0.08309057726782865, 0.08568551278272174, 0.08673378910079332, 0.08217462415286336, 0.0884448468105804, 0.08342456568657308, 0.07042050107199138, 0.08002516520535552, 0.08296683733227617, 0.07961557923723683, 0.08163988071868811, 0.07919093471324923, 0.07871378822639852, 0.0750300853992012, 0.08139232018880904, 0.9402464458425869, 0.9433205152328044, 0.9453907501899409, 0.948846238882987, 0.9583296820932026, 0.9414263447523542, 0.9234731338663532, 0.987804501726365, 0.9621966050168237, 0.21417241423462552, 0.20251559422083643, 0.18553010936656777, 0.20153129401161718, 0.20866041792162282, 0.18850007673940639, 0.19637364944790947, 0.20803238663759394, 0.1893083227957172, 0.24768599274097314, 0.26367290606024196, 0.2168063015818722, 0.2196201379183187, 0.24795503207396985, 0.2311849563796895, 0.22591075921107484, 0.26047082822321843, 0.23153098081077272, 0.12205222912694624, 0.11624091214357501, 0.09617180080790277, 0.1334944718414226, 0.10645521856550655, 0.10499817801169431, 0.12066056429242511, 0.10150558086801942, 0.12655490671758052, 0.10479827812172626, 0.12293411270652888, 0.08393513568523792, 0.12109281394327864, 0.10964916728185348, 0.10859127672592261, 0.11527088428973875, 0.10957446374123214, 0.1093364688883548, 9.999999999998899e-05, 9.999999999998899e-05, 0.025862309691345953, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0665874524882103, 0.03885062910293913, 0.07197789836734336, 0.07044993729275761, 0.06289785069593457, 0.05229427738550019, 0.06443556747732782, 0.06605758724451882, 0.06665838403301028, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06679072712365686, 0.06056138750741469, 0.05615064472244924, 0.049396131695438994, 0.06239182660345466, 0.06128687398504995, 0.07633131950369165, 0.06091237338213107, 0.04957765857162688, 0.32289207630577244, 0.3472414796783264, 0.3333969460629894, 0.35194765652309723, 0.33668291562880126, 0.3298323808611293, 0.335112824655282, 0.32209406047671085, 0.36785692303831663, 0.09284398481230438, 0.0829269858908227, 0.07927239725083068, 0.07625454673053977, 0.07977750900505276, 0.09316725818092819, 0.10569857757814916, 0.07326257938469827, 0.0789366578346502, 0.1392062293991594, 0.18328325166302095, 0.20227999870515956, 0.21784517406555093, 0.16324788148042457, 0.16714666249260302, 0.1867678470364682, 0.14715083303973664, 0.1532154047148948, 0.24527986477705055, 0.22410857942492668, 0.21884728246274576, 0.23602724603698821, 0.23545187117463573, 0.222192899558865, 0.24870037031910375, 0.24678920571120422, 0.22693629547859828, 0.18861729959353013, 0.15513634638520868, 0.18341757247188528, 0.15535266885593124, 0.17273495498679226, 0.17080170880558765, 0.18051158294261205, 0.182404494472321, 0.15936873453122502, 0.17645548542126266, 0.18728147010346952, 0.1985282681208902, 0.19361680577926843, 0.1831362979060276, 0.18551407815432153, 0.1962473577817494, 0.1826356503816109, 0.1922912760217963, 0.17005865107594675, 0.17915115124926473, 0.18737037509905918, 0.17265083044691476, 0.17784577575214666, 0.17123694682975454, 0.1697221631604593, 0.17528952215633453, 0.16767188272344924, 0.4362814744473379, 0.41553885764279863, 0.18989777858945622, 0.22378671729251387, 0.19033571031276875, 0.2549080077804018, 0.37201881220141453, 0.16522495521640246, 0.26619194806530244, 0.3252609202686746, 0.20579254346593823, 0.19750549286332808, 0.17913274671918789, 0.2504181681377642, 0.24869613210421038, 0.3238710156510731, 0.2091215030934961, 0.20559533637118632, 0.18895154652628476, 0.19125350001444408, 0.1785583137163902, 0.17168101373758904, 0.17932705814697625, 0.194844989939139, 0.18419670692559642, 0.18763260082987843, 0.19351582988804816, 0.07729548947495024, 0.0792974804974168, 0.0704125924917085, 0.08041365202712791, 0.07390482345725213, 0.06821333404690344, 0.06321240940678163, 0.07656261366466466, 0.06678427866517755]}, "mutation_prompt": null}
{"id": "ebede7f6-24cb-4495-a858-5e38d76db61c", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                mutant = self.mutate(a, b, c)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c):\n        mutation = a + self.F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A hybrid Differential Evolution with Adaptive Local Search (DEALS) for efficient exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2ba6d4f4-5139-4688-b645-8e59dfe7046c", "metadata": {"aucs": [0.613270331469187, 0.6258958226501584, 0.5870749066099039, 0.6365712786861815, 0.6459401369382454, 0.6475354752106718, 0.6238965184089815, 0.6110144538563027, 0.6199987607899016, 0.3144918918200881, 0.3475802846399608, 0.3539967448321202, 0.3370465967401849, 0.37259822264709275, 0.35422171909838973, 0.3517112335157937, 0.36916956523357636, 0.35925935472050585, 0.09438211284932929, 0.09399424449843741, 0.08896936541248757, 0.10005149858902496, 0.09312269122619687, 0.08994390577919098, 0.11178702376325855, 0.1105361553443035, 0.09135551924142693, 0.09060728081183655, 0.08827080696727752, 0.08560083002159558, 0.10348673525084451, 0.08119266870308661, 0.09484814875658609, 0.09049086489585623, 0.09653841187300205, 0.08612734512616571, 0.9422375745133456, 0.9279611758746413, 0.970334753101139, 0.9331971894679348, 0.9180662947740443, 0.9591292392977449, 0.9510012245298195, 0.9730245240164237, 0.9389110086497934, 0.27522314395040215, 0.28459492694989597, 0.25921353020992466, 0.28965971311046557, 0.2718314257369333, 0.28989184903511467, 0.3352022915443257, 0.2819439545620793, 0.2784295190208501, 0.5407235660722138, 0.4012219810974118, 0.4279159159541672, 0.6247898314209537, 0.5395470057881797, 0.4973957049304115, 0.5287400566054581, 0.46324762437727973, 0.5524185607052914, 0.1662286054021671, 0.19114887210275733, 0.18509202571349814, 0.19393955612749436, 0.20506677150303299, 0.17807964029842094, 0.204646382805855, 0.1978390349789504, 0.1797026067114451, 0.22854221388923912, 0.20556843137806835, 0.23856445260927617, 0.1817475627934697, 0.18603047072929169, 0.1976390057530507, 0.19267739773915282, 0.18681613029250554, 0.2030933556834884, 0.09058782462294479, 0.14882842778054328, 0.1266782511073823, 0.14519317447083413, 0.12079477580706877, 0.07929331469540724, 0.11966524430128844, 0.13385841280792588, 0.10178956841696596, 0.26532518113491244, 0.24420394190622108, 0.23379230945762153, 0.19473809339058967, 0.23149130733820467, 0.22865843897122795, 0.24131430004459453, 0.23329950655801646, 0.27588751293463476, 0.021943419940596343, 0.013025071013518352, 0.04240732935656655, 0.027444732723628462, 0.02369063187090703, 0.019405870563226957, 0.018499647161437816, 0.014593467545289007, 0.01684496907285704, 0.15032863466481705, 0.14289751598885536, 0.1591384546327499, 0.15617872935474864, 0.1477645815072075, 0.16816068062038358, 0.1537163000318036, 0.14379657879213226, 0.137992580619822, 0.47633411457797603, 0.4806910994889465, 0.4940904415191718, 0.4881407653722122, 0.47158099758803207, 0.46628251865085013, 0.48452184113057417, 0.46625690122542696, 0.468195521112307, 0.10351625396526032, 0.09229254700307354, 0.10005369822766019, 0.08597881462048318, 0.09932138976188232, 0.0827154761655371, 0.09007055024076838, 0.09437514463047414, 0.09883735457352416, 0.19231855340155124, 0.1527233734046618, 0.16157228925907785, 0.17885503730419838, 0.18252668339842326, 0.17896300625231254, 0.14971090215781702, 0.20793221250898242, 0.14937192281394274, 0.2824004302940176, 0.2708157998650538, 0.27367624085198794, 0.27057584059923123, 0.2531827596416064, 0.2295900989896169, 0.2841189072756357, 0.28784692850742155, 0.30356298024618356, 0.2154360543366013, 0.19302197617019512, 0.21714290032560468, 0.21402008727452493, 0.2142484112383043, 0.1874091527109485, 0.19320551112488527, 0.21769061433338344, 0.21894314026801287, 0.2015704074317578, 0.16750608756991237, 0.18482259167911974, 0.19330195794489358, 0.18750637745133136, 0.1848776168116235, 0.1808028318689474, 0.2022265959108519, 0.199240168046675, 0.17840221218980046, 0.17302829688326982, 0.18261107600995474, 0.19479239131730153, 0.1839794162540136, 0.1792537954123069, 0.1850177747270112, 0.17612530666172155, 0.18034447838667234, 0.7293020260840269, 0.19209212244774476, 0.6613245977712534, 0.1755857176996758, 0.2933445058714311, 0.40804344633567236, 0.3481197350686259, 0.4746703223147458, 0.18546563356475643, 0.5407298932442539, 0.20897381189090025, 0.48651069193400787, 0.3480935816649926, 0.20822189969797067, 0.29057819191671763, 0.21030484021729245, 0.6442148839304698, 0.20881562702534584, 0.1961573655838107, 0.1904054375634361, 0.183425785809897, 0.18524374579342961, 0.18520400724795993, 0.20036385251953015, 0.17876746065598437, 0.18021791517979868, 0.2108821614977623, 0.07116383752390665, 0.0750786900658097, 0.08331860303222582, 0.08807683407891187, 0.07764485545478805, 0.06924827140792222, 0.08383190134748397, 0.07016644616564827, 0.07719914643009329]}, "mutation_prompt": null}
{"id": "37521200-a5f5-4916-b475-87d6d58bf218", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                mutant = self.mutate(a, b, c)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c):\n        mutation = a + self.F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A hybrid Differential Evolution with Adaptive Local Search (DEALS) for efficient exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2ba6d4f4-5139-4688-b645-8e59dfe7046c", "metadata": {"aucs": [0.613270331469187, 0.6258958226501584, 0.5870749066099039, 0.6365712786861815, 0.6459401369382454, 0.6475354752106718, 0.6238965184089815, 0.6110144538563027, 0.6199987607899016, 0.3144918918200881, 0.3475802846399608, 0.3539967448321202, 0.3370465967401849, 0.37259822264709275, 0.35422171909838973, 0.3517112335157937, 0.36916956523357636, 0.35925935472050585, 0.09438211284932929, 0.09399424449843741, 0.08896936541248757, 0.10005149858902496, 0.09312269122619687, 0.08994390577919098, 0.11178702376325855, 0.1105361553443035, 0.09135551924142693, 0.09060728081183655, 0.08827080696727752, 0.08560083002159558, 0.10348673525084451, 0.08119266870308661, 0.09484814875658609, 0.09049086489585623, 0.09653841187300205, 0.08612734512616571, 0.9422375745133456, 0.9279611758746413, 0.970334753101139, 0.9331971894679348, 0.9180662947740443, 0.9591292392977449, 0.9510012245298195, 0.9730245240164237, 0.9389110086497934, 0.27522314395040215, 0.28459492694989597, 0.25921353020992466, 0.28965971311046557, 0.2718314257369333, 0.28989184903511467, 0.3352022915443257, 0.2819439545620793, 0.2784295190208501, 0.5407235660722138, 0.4012219810974118, 0.4279159159541672, 0.6247898314209537, 0.5395470057881797, 0.4973957049304115, 0.5287400566054581, 0.46324762437727973, 0.5524185607052914, 0.1662286054021671, 0.19114887210275733, 0.18509202571349814, 0.19393955612749436, 0.20506677150303299, 0.17807964029842094, 0.204646382805855, 0.1978390349789504, 0.1797026067114451, 0.22854221388923912, 0.20556843137806835, 0.23856445260927617, 0.1817475627934697, 0.18603047072929169, 0.1976390057530507, 0.19267739773915282, 0.18681613029250554, 0.2030933556834884, 0.09058782462294479, 0.14882842778054328, 0.1266782511073823, 0.14519317447083413, 0.12079477580706877, 0.07929331469540724, 0.11966524430128844, 0.13385841280792588, 0.10178956841696596, 0.26532518113491244, 0.24420394190622108, 0.23379230945762153, 0.19473809339058967, 0.23149130733820467, 0.22865843897122795, 0.24131430004459453, 0.23329950655801646, 0.27588751293463476, 0.021943419940596343, 0.013025071013518352, 0.04240732935656655, 0.027444732723628462, 0.02369063187090703, 0.019405870563226957, 0.018499647161437816, 0.014593467545289007, 0.01684496907285704, 0.15032863466481705, 0.14289751598885536, 0.1591384546327499, 0.15617872935474864, 0.1477645815072075, 0.16816068062038358, 0.1537163000318036, 0.14379657879213226, 0.137992580619822, 0.47633411457797603, 0.4806910994889465, 0.4940904415191718, 0.4881407653722122, 0.47158099758803207, 0.46628251865085013, 0.48452184113057417, 0.46625690122542696, 0.468195521112307, 0.10351625396526032, 0.09229254700307354, 0.10005369822766019, 0.08597881462048318, 0.09932138976188232, 0.0827154761655371, 0.09007055024076838, 0.09437514463047414, 0.09883735457352416, 0.19231855340155124, 0.1527233734046618, 0.16157228925907785, 0.17885503730419838, 0.18252668339842326, 0.17896300625231254, 0.14971090215781702, 0.20793221250898242, 0.14937192281394274, 0.2824004302940176, 0.2708157998650538, 0.27367624085198794, 0.27057584059923123, 0.2531827596416064, 0.2295900989896169, 0.2841189072756357, 0.28784692850742155, 0.30356298024618356, 0.2154360543366013, 0.19302197617019512, 0.21714290032560468, 0.21402008727452493, 0.2142484112383043, 0.1874091527109485, 0.19320551112488527, 0.21769061433338344, 0.21894314026801287, 0.2015704074317578, 0.16750608756991237, 0.18482259167911974, 0.19330195794489358, 0.18750637745133136, 0.1848776168116235, 0.1808028318689474, 0.2022265959108519, 0.199240168046675, 0.17840221218980046, 0.17302829688326982, 0.18261107600995474, 0.19479239131730153, 0.1839794162540136, 0.1792537954123069, 0.1850177747270112, 0.17612530666172155, 0.18034447838667234, 0.7293020260840269, 0.19209212244774476, 0.6613245977712534, 0.1755857176996758, 0.2933445058714311, 0.40804344633567236, 0.3481197350686259, 0.4746703223147458, 0.18546563356475643, 0.5407298932442539, 0.20897381189090025, 0.48651069193400787, 0.3480935816649926, 0.20822189969797067, 0.29057819191671763, 0.21030484021729245, 0.6442148839304698, 0.20881562702534584, 0.1961573655838107, 0.1904054375634361, 0.183425785809897, 0.18524374579342961, 0.18520400724795993, 0.20036385251953015, 0.17876746065598437, 0.18021791517979868, 0.2108821614977623, 0.07116383752390665, 0.0750786900658097, 0.08331860303222582, 0.08807683407891187, 0.07764485545478805, 0.06924827140792222, 0.08383190134748397, 0.07016644616564827, 0.07719914643009329]}, "mutation_prompt": null}
{"id": "bd462277-3409-4f02-960b-4d81b9f74f83", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                mutant = self.mutate(a, b, c)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c):\n        mutation = a + self.F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A hybrid Differential Evolution with Adaptive Local Search (DEALS) for efficient exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2ba6d4f4-5139-4688-b645-8e59dfe7046c", "metadata": {"aucs": [0.613270331469187, 0.6258958226501584, 0.5870749066099039, 0.6365712786861815, 0.6459401369382454, 0.6475354752106718, 0.6238965184089815, 0.6110144538563027, 0.6199987607899016, 0.3144918918200881, 0.3475802846399608, 0.3539967448321202, 0.3370465967401849, 0.37259822264709275, 0.35422171909838973, 0.3517112335157937, 0.36916956523357636, 0.35925935472050585, 0.09438211284932929, 0.09399424449843741, 0.08896936541248757, 0.10005149858902496, 0.09312269122619687, 0.08994390577919098, 0.11178702376325855, 0.1105361553443035, 0.09135551924142693, 0.09060728081183655, 0.08827080696727752, 0.08560083002159558, 0.10348673525084451, 0.08119266870308661, 0.09484814875658609, 0.09049086489585623, 0.09653841187300205, 0.08612734512616571, 0.9422375745133456, 0.9279611758746413, 0.970334753101139, 0.9331971894679348, 0.9180662947740443, 0.9591292392977449, 0.9510012245298195, 0.9730245240164237, 0.9389110086497934, 0.27522314395040215, 0.28459492694989597, 0.25921353020992466, 0.28965971311046557, 0.2718314257369333, 0.28989184903511467, 0.3352022915443257, 0.2819439545620793, 0.2784295190208501, 0.5407235660722138, 0.4012219810974118, 0.4279159159541672, 0.6247898314209537, 0.5395470057881797, 0.4973957049304115, 0.5287400566054581, 0.46324762437727973, 0.5524185607052914, 0.1662286054021671, 0.19114887210275733, 0.18509202571349814, 0.19393955612749436, 0.20506677150303299, 0.17807964029842094, 0.204646382805855, 0.1978390349789504, 0.1797026067114451, 0.22854221388923912, 0.20556843137806835, 0.23856445260927617, 0.1817475627934697, 0.18603047072929169, 0.1976390057530507, 0.19267739773915282, 0.18681613029250554, 0.2030933556834884, 0.09058782462294479, 0.14882842778054328, 0.1266782511073823, 0.14519317447083413, 0.12079477580706877, 0.07929331469540724, 0.11966524430128844, 0.13385841280792588, 0.10178956841696596, 0.26532518113491244, 0.24420394190622108, 0.23379230945762153, 0.19473809339058967, 0.23149130733820467, 0.22865843897122795, 0.24131430004459453, 0.23329950655801646, 0.27588751293463476, 0.021943419940596343, 0.013025071013518352, 0.04240732935656655, 0.027444732723628462, 0.02369063187090703, 0.019405870563226957, 0.018499647161437816, 0.014593467545289007, 0.01684496907285704, 0.15032863466481705, 0.14289751598885536, 0.1591384546327499, 0.15617872935474864, 0.1477645815072075, 0.16816068062038358, 0.1537163000318036, 0.14379657879213226, 0.137992580619822, 0.47633411457797603, 0.4806910994889465, 0.4940904415191718, 0.4881407653722122, 0.47158099758803207, 0.46628251865085013, 0.48452184113057417, 0.46625690122542696, 0.468195521112307, 0.10351625396526032, 0.09229254700307354, 0.10005369822766019, 0.08597881462048318, 0.09932138976188232, 0.0827154761655371, 0.09007055024076838, 0.09437514463047414, 0.09883735457352416, 0.19231855340155124, 0.1527233734046618, 0.16157228925907785, 0.17885503730419838, 0.18252668339842326, 0.17896300625231254, 0.14971090215781702, 0.20793221250898242, 0.14937192281394274, 0.2824004302940176, 0.2708157998650538, 0.27367624085198794, 0.27057584059923123, 0.2531827596416064, 0.2295900989896169, 0.2841189072756357, 0.28784692850742155, 0.30356298024618356, 0.2154360543366013, 0.19302197617019512, 0.21714290032560468, 0.21402008727452493, 0.2142484112383043, 0.1874091527109485, 0.19320551112488527, 0.21769061433338344, 0.21894314026801287, 0.2015704074317578, 0.16750608756991237, 0.18482259167911974, 0.19330195794489358, 0.18750637745133136, 0.1848776168116235, 0.1808028318689474, 0.2022265959108519, 0.199240168046675, 0.17840221218980046, 0.17302829688326982, 0.18261107600995474, 0.19479239131730153, 0.1839794162540136, 0.1792537954123069, 0.1850177747270112, 0.17612530666172155, 0.18034447838667234, 0.7293020260840269, 0.19209212244774476, 0.6613245977712534, 0.1755857176996758, 0.2933445058714311, 0.40804344633567236, 0.3481197350686259, 0.4746703223147458, 0.18546563356475643, 0.5407298932442539, 0.20897381189090025, 0.48651069193400787, 0.3480935816649926, 0.20822189969797067, 0.29057819191671763, 0.21030484021729245, 0.6442148839304698, 0.20881562702534584, 0.1961573655838107, 0.1904054375634361, 0.183425785809897, 0.18524374579342961, 0.18520400724795993, 0.20036385251953015, 0.17876746065598437, 0.18021791517979868, 0.2108821614977623, 0.07116383752390665, 0.0750786900658097, 0.08331860303222582, 0.08807683407891187, 0.07764485545478805, 0.06924827140792222, 0.08383190134748397, 0.07016644616564827, 0.07719914643009329]}, "mutation_prompt": null}
{"id": "cddf78f3-565d-4cfc-a07c-acf348146d8a", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                mutant = self.mutate(a, b, c)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c):\n        mutation = a + self.F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A hybrid Differential Evolution with Adaptive Local Search (DEALS) for efficient exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2ba6d4f4-5139-4688-b645-8e59dfe7046c", "metadata": {"aucs": [0.613270331469187, 0.6258958226501584, 0.5870749066099039, 0.6365712786861815, 0.6459401369382454, 0.6475354752106718, 0.6238965184089815, 0.6110144538563027, 0.6199987607899016, 0.3144918918200881, 0.3475802846399608, 0.3539967448321202, 0.3370465967401849, 0.37259822264709275, 0.35422171909838973, 0.3517112335157937, 0.36916956523357636, 0.35925935472050585, 0.09438211284932929, 0.09399424449843741, 0.08896936541248757, 0.10005149858902496, 0.09312269122619687, 0.08994390577919098, 0.11178702376325855, 0.1105361553443035, 0.09135551924142693, 0.09060728081183655, 0.08827080696727752, 0.08560083002159558, 0.10348673525084451, 0.08119266870308661, 0.09484814875658609, 0.09049086489585623, 0.09653841187300205, 0.08612734512616571, 0.9422375745133456, 0.9279611758746413, 0.970334753101139, 0.9331971894679348, 0.9180662947740443, 0.9591292392977449, 0.9510012245298195, 0.9730245240164237, 0.9389110086497934, 0.27522314395040215, 0.28459492694989597, 0.25921353020992466, 0.28965971311046557, 0.2718314257369333, 0.28989184903511467, 0.3352022915443257, 0.2819439545620793, 0.2784295190208501, 0.5407235660722138, 0.4012219810974118, 0.4279159159541672, 0.6247898314209537, 0.5395470057881797, 0.4973957049304115, 0.5287400566054581, 0.46324762437727973, 0.5524185607052914, 0.1662286054021671, 0.19114887210275733, 0.18509202571349814, 0.19393955612749436, 0.20506677150303299, 0.17807964029842094, 0.204646382805855, 0.1978390349789504, 0.1797026067114451, 0.22854221388923912, 0.20556843137806835, 0.23856445260927617, 0.1817475627934697, 0.18603047072929169, 0.1976390057530507, 0.19267739773915282, 0.18681613029250554, 0.2030933556834884, 0.09058782462294479, 0.14882842778054328, 0.1266782511073823, 0.14519317447083413, 0.12079477580706877, 0.07929331469540724, 0.11966524430128844, 0.13385841280792588, 0.10178956841696596, 0.26532518113491244, 0.24420394190622108, 0.23379230945762153, 0.19473809339058967, 0.23149130733820467, 0.22865843897122795, 0.24131430004459453, 0.23329950655801646, 0.27588751293463476, 0.021943419940596343, 0.013025071013518352, 0.04240732935656655, 0.027444732723628462, 0.02369063187090703, 0.019405870563226957, 0.018499647161437816, 0.014593467545289007, 0.01684496907285704, 0.15032863466481705, 0.14289751598885536, 0.1591384546327499, 0.15617872935474864, 0.1477645815072075, 0.16816068062038358, 0.1537163000318036, 0.14379657879213226, 0.137992580619822, 0.47633411457797603, 0.4806910994889465, 0.4940904415191718, 0.4881407653722122, 0.47158099758803207, 0.46628251865085013, 0.48452184113057417, 0.46625690122542696, 0.468195521112307, 0.10351625396526032, 0.09229254700307354, 0.10005369822766019, 0.08597881462048318, 0.09932138976188232, 0.0827154761655371, 0.09007055024076838, 0.09437514463047414, 0.09883735457352416, 0.19231855340155124, 0.1527233734046618, 0.16157228925907785, 0.17885503730419838, 0.18252668339842326, 0.17896300625231254, 0.14971090215781702, 0.20793221250898242, 0.14937192281394274, 0.2824004302940176, 0.2708157998650538, 0.27367624085198794, 0.27057584059923123, 0.2531827596416064, 0.2295900989896169, 0.2841189072756357, 0.28784692850742155, 0.30356298024618356, 0.2154360543366013, 0.19302197617019512, 0.21714290032560468, 0.21402008727452493, 0.2142484112383043, 0.1874091527109485, 0.19320551112488527, 0.21769061433338344, 0.21894314026801287, 0.2015704074317578, 0.16750608756991237, 0.18482259167911974, 0.19330195794489358, 0.18750637745133136, 0.1848776168116235, 0.1808028318689474, 0.2022265959108519, 0.199240168046675, 0.17840221218980046, 0.17302829688326982, 0.18261107600995474, 0.19479239131730153, 0.1839794162540136, 0.1792537954123069, 0.1850177747270112, 0.17612530666172155, 0.18034447838667234, 0.7293020260840269, 0.19209212244774476, 0.6613245977712534, 0.1755857176996758, 0.2933445058714311, 0.40804344633567236, 0.3481197350686259, 0.4746703223147458, 0.18546563356475643, 0.5407298932442539, 0.20897381189090025, 0.48651069193400787, 0.3480935816649926, 0.20822189969797067, 0.29057819191671763, 0.21030484021729245, 0.6442148839304698, 0.20881562702534584, 0.1961573655838107, 0.1904054375634361, 0.183425785809897, 0.18524374579342961, 0.18520400724795993, 0.20036385251953015, 0.17876746065598437, 0.18021791517979868, 0.2108821614977623, 0.07116383752390665, 0.0750786900658097, 0.08331860303222582, 0.08807683407891187, 0.07764485545478805, 0.06924827140792222, 0.08383190134748397, 0.07016644616564827, 0.07719914643009329]}, "mutation_prompt": null}
{"id": "6c813b65-adfa-4a0b-b895-fb3fb2b14fa2", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                mutant = self.mutate(a, b, c)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c):\n        mutation = a + self.F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A hybrid Differential Evolution with Adaptive Local Search (DEALS) for efficient exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2ba6d4f4-5139-4688-b645-8e59dfe7046c", "metadata": {"aucs": [0.613270331469187, 0.6258958226501584, 0.5870749066099039, 0.6365712786861815, 0.6459401369382454, 0.6475354752106718, 0.6238965184089815, 0.6110144538563027, 0.6199987607899016, 0.3144918918200881, 0.3475802846399608, 0.3539967448321202, 0.3370465967401849, 0.37259822264709275, 0.35422171909838973, 0.3517112335157937, 0.36916956523357636, 0.35925935472050585, 0.09438211284932929, 0.09399424449843741, 0.08896936541248757, 0.10005149858902496, 0.09312269122619687, 0.08994390577919098, 0.11178702376325855, 0.1105361553443035, 0.09135551924142693, 0.09060728081183655, 0.08827080696727752, 0.08560083002159558, 0.10348673525084451, 0.08119266870308661, 0.09484814875658609, 0.09049086489585623, 0.09653841187300205, 0.08612734512616571, 0.9422375745133456, 0.9279611758746413, 0.970334753101139, 0.9331971894679348, 0.9180662947740443, 0.9591292392977449, 0.9510012245298195, 0.9730245240164237, 0.9389110086497934, 0.27522314395040215, 0.28459492694989597, 0.25921353020992466, 0.28965971311046557, 0.2718314257369333, 0.28989184903511467, 0.3352022915443257, 0.2819439545620793, 0.2784295190208501, 0.5407235660722138, 0.4012219810974118, 0.4279159159541672, 0.6247898314209537, 0.5395470057881797, 0.4973957049304115, 0.5287400566054581, 0.46324762437727973, 0.5524185607052914, 0.1662286054021671, 0.19114887210275733, 0.18509202571349814, 0.19393955612749436, 0.20506677150303299, 0.17807964029842094, 0.204646382805855, 0.1978390349789504, 0.1797026067114451, 0.22854221388923912, 0.20556843137806835, 0.23856445260927617, 0.1817475627934697, 0.18603047072929169, 0.1976390057530507, 0.19267739773915282, 0.18681613029250554, 0.2030933556834884, 0.09058782462294479, 0.14882842778054328, 0.1266782511073823, 0.14519317447083413, 0.12079477580706877, 0.07929331469540724, 0.11966524430128844, 0.13385841280792588, 0.10178956841696596, 0.26532518113491244, 0.24420394190622108, 0.23379230945762153, 0.19473809339058967, 0.23149130733820467, 0.22865843897122795, 0.24131430004459453, 0.23329950655801646, 0.27588751293463476, 0.021943419940596343, 0.013025071013518352, 0.04240732935656655, 0.027444732723628462, 0.02369063187090703, 0.019405870563226957, 0.018499647161437816, 0.014593467545289007, 0.01684496907285704, 0.15032863466481705, 0.14289751598885536, 0.1591384546327499, 0.15617872935474864, 0.1477645815072075, 0.16816068062038358, 0.1537163000318036, 0.14379657879213226, 0.137992580619822, 0.47633411457797603, 0.4806910994889465, 0.4940904415191718, 0.4881407653722122, 0.47158099758803207, 0.46628251865085013, 0.48452184113057417, 0.46625690122542696, 0.468195521112307, 0.10351625396526032, 0.09229254700307354, 0.10005369822766019, 0.08597881462048318, 0.09932138976188232, 0.0827154761655371, 0.09007055024076838, 0.09437514463047414, 0.09883735457352416, 0.19231855340155124, 0.1527233734046618, 0.16157228925907785, 0.17885503730419838, 0.18252668339842326, 0.17896300625231254, 0.14971090215781702, 0.20793221250898242, 0.14937192281394274, 0.2824004302940176, 0.2708157998650538, 0.27367624085198794, 0.27057584059923123, 0.2531827596416064, 0.2295900989896169, 0.2841189072756357, 0.28784692850742155, 0.30356298024618356, 0.2154360543366013, 0.19302197617019512, 0.21714290032560468, 0.21402008727452493, 0.2142484112383043, 0.1874091527109485, 0.19320551112488527, 0.21769061433338344, 0.21894314026801287, 0.2015704074317578, 0.16750608756991237, 0.18482259167911974, 0.19330195794489358, 0.18750637745133136, 0.1848776168116235, 0.1808028318689474, 0.2022265959108519, 0.199240168046675, 0.17840221218980046, 0.17302829688326982, 0.18261107600995474, 0.19479239131730153, 0.1839794162540136, 0.1792537954123069, 0.1850177747270112, 0.17612530666172155, 0.18034447838667234, 0.7293020260840269, 0.19209212244774476, 0.6613245977712534, 0.1755857176996758, 0.2933445058714311, 0.40804344633567236, 0.3481197350686259, 0.4746703223147458, 0.18546563356475643, 0.5407298932442539, 0.20897381189090025, 0.48651069193400787, 0.3480935816649926, 0.20822189969797067, 0.29057819191671763, 0.21030484021729245, 0.6442148839304698, 0.20881562702534584, 0.1961573655838107, 0.1904054375634361, 0.183425785809897, 0.18524374579342961, 0.18520400724795993, 0.20036385251953015, 0.17876746065598437, 0.18021791517979868, 0.2108821614977623, 0.07116383752390665, 0.0750786900658097, 0.08331860303222582, 0.08807683407891187, 0.07764485545478805, 0.06924827140792222, 0.08383190134748397, 0.07016644616564827, 0.07719914643009329]}, "mutation_prompt": null}
{"id": "f51d62fd-9f9e-4b2b-923f-67c66d68182d", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                mutant = self.mutate(a, b, c)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c):\n        mutation = a + self.F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A hybrid Differential Evolution with Adaptive Local Search (DEALS) for efficient exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2ba6d4f4-5139-4688-b645-8e59dfe7046c", "metadata": {"aucs": [0.613270331469187, 0.6258958226501584, 0.5870749066099039, 0.6365712786861815, 0.6459401369382454, 0.6475354752106718, 0.6238965184089815, 0.6110144538563027, 0.6199987607899016, 0.3144918918200881, 0.3475802846399608, 0.3539967448321202, 0.3370465967401849, 0.37259822264709275, 0.35422171909838973, 0.3517112335157937, 0.36916956523357636, 0.35925935472050585, 0.09438211284932929, 0.09399424449843741, 0.08896936541248757, 0.10005149858902496, 0.09312269122619687, 0.08994390577919098, 0.11178702376325855, 0.1105361553443035, 0.09135551924142693, 0.09060728081183655, 0.08827080696727752, 0.08560083002159558, 0.10348673525084451, 0.08119266870308661, 0.09484814875658609, 0.09049086489585623, 0.09653841187300205, 0.08612734512616571, 0.9422375745133456, 0.9279611758746413, 0.970334753101139, 0.9331971894679348, 0.9180662947740443, 0.9591292392977449, 0.9510012245298195, 0.9730245240164237, 0.9389110086497934, 0.27522314395040215, 0.28459492694989597, 0.25921353020992466, 0.28965971311046557, 0.2718314257369333, 0.28989184903511467, 0.3352022915443257, 0.2819439545620793, 0.2784295190208501, 0.5407235660722138, 0.4012219810974118, 0.4279159159541672, 0.6247898314209537, 0.5395470057881797, 0.4973957049304115, 0.5287400566054581, 0.46324762437727973, 0.5524185607052914, 0.1662286054021671, 0.19114887210275733, 0.18509202571349814, 0.19393955612749436, 0.20506677150303299, 0.17807964029842094, 0.204646382805855, 0.1978390349789504, 0.1797026067114451, 0.22854221388923912, 0.20556843137806835, 0.23856445260927617, 0.1817475627934697, 0.18603047072929169, 0.1976390057530507, 0.19267739773915282, 0.18681613029250554, 0.2030933556834884, 0.09058782462294479, 0.14882842778054328, 0.1266782511073823, 0.14519317447083413, 0.12079477580706877, 0.07929331469540724, 0.11966524430128844, 0.13385841280792588, 0.10178956841696596, 0.26532518113491244, 0.24420394190622108, 0.23379230945762153, 0.19473809339058967, 0.23149130733820467, 0.22865843897122795, 0.24131430004459453, 0.23329950655801646, 0.27588751293463476, 0.021943419940596343, 0.013025071013518352, 0.04240732935656655, 0.027444732723628462, 0.02369063187090703, 0.019405870563226957, 0.018499647161437816, 0.014593467545289007, 0.01684496907285704, 0.15032863466481705, 0.14289751598885536, 0.1591384546327499, 0.15617872935474864, 0.1477645815072075, 0.16816068062038358, 0.1537163000318036, 0.14379657879213226, 0.137992580619822, 0.47633411457797603, 0.4806910994889465, 0.4940904415191718, 0.4881407653722122, 0.47158099758803207, 0.46628251865085013, 0.48452184113057417, 0.46625690122542696, 0.468195521112307, 0.10351625396526032, 0.09229254700307354, 0.10005369822766019, 0.08597881462048318, 0.09932138976188232, 0.0827154761655371, 0.09007055024076838, 0.09437514463047414, 0.09883735457352416, 0.19231855340155124, 0.1527233734046618, 0.16157228925907785, 0.17885503730419838, 0.18252668339842326, 0.17896300625231254, 0.14971090215781702, 0.20793221250898242, 0.14937192281394274, 0.2824004302940176, 0.2708157998650538, 0.27367624085198794, 0.27057584059923123, 0.2531827596416064, 0.2295900989896169, 0.2841189072756357, 0.28784692850742155, 0.30356298024618356, 0.2154360543366013, 0.19302197617019512, 0.21714290032560468, 0.21402008727452493, 0.2142484112383043, 0.1874091527109485, 0.19320551112488527, 0.21769061433338344, 0.21894314026801287, 0.2015704074317578, 0.16750608756991237, 0.18482259167911974, 0.19330195794489358, 0.18750637745133136, 0.1848776168116235, 0.1808028318689474, 0.2022265959108519, 0.199240168046675, 0.17840221218980046, 0.17302829688326982, 0.18261107600995474, 0.19479239131730153, 0.1839794162540136, 0.1792537954123069, 0.1850177747270112, 0.17612530666172155, 0.18034447838667234, 0.7293020260840269, 0.19209212244774476, 0.6613245977712534, 0.1755857176996758, 0.2933445058714311, 0.40804344633567236, 0.3481197350686259, 0.4746703223147458, 0.18546563356475643, 0.5407298932442539, 0.20897381189090025, 0.48651069193400787, 0.3480935816649926, 0.20822189969797067, 0.29057819191671763, 0.21030484021729245, 0.6442148839304698, 0.20881562702534584, 0.1961573655838107, 0.1904054375634361, 0.183425785809897, 0.18524374579342961, 0.18520400724795993, 0.20036385251953015, 0.17876746065598437, 0.18021791517979868, 0.2108821614977623, 0.07116383752390665, 0.0750786900658097, 0.08331860303222582, 0.08807683407891187, 0.07764485545478805, 0.06924827140792222, 0.08383190134748397, 0.07016644616564827, 0.07719914643009329]}, "mutation_prompt": null}
{"id": "c3fa3a55-c18a-4244-91af-ba9644144451", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.85  # Reduced crossover probability for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                mutant = self.mutate(a, b, c)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c):\n        mutation = a + self.F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.07  # Increased step size for more aggressive search\n        for _ in range(6):  # Slightly more local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "An enhanced hybrid Differential Evolution algorithm with optimized adaptive local search and modified crossover strategy for accelerated convergence.", "configspace": "", "generation": 11, "fitness": 0.25044420532076495, "feedback": "The algorithm DEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "2ba6d4f4-5139-4688-b645-8e59dfe7046c", "metadata": {"aucs": [0.6389170042314085, 0.5951707855974209, 0.5770027788179604, 0.6310688280532801, 0.6433339581566817, 0.6420403329460442, 0.6159298504510091, 0.598670923343577, 0.6597404704082377, 0.3450920876321969, 0.3714981979486254, 0.3215816250661506, 0.34657091469926304, 0.3565559653219904, 0.3098844217345528, 0.31758202961820414, 0.34867209399686305, 0.35607399335895096, 0.10812914058892542, 0.09647978474086727, 0.10187875435169647, 0.10234632972588187, 0.09151092993723509, 0.09642110837381368, 0.09490695985602438, 0.09440100920302097, 0.09841399734458178, 0.09714185304511103, 0.09213484087135926, 0.1085774379813802, 0.08356533594477678, 0.09937437783146308, 0.09298301366271788, 0.10089871583459575, 0.08868975269818968, 0.09281224895134477, 0.9416542784823321, 0.9539155736627203, 0.9653876110965461, 0.9472120096307639, 0.957727679255144, 0.9602370067787155, 0.9427308183947576, 0.9526976052379876, 0.9434549365030772, 0.2563571036252098, 0.25277810918700006, 0.256969037911687, 0.2606707675762131, 0.2761574984040597, 0.2903783835009016, 0.27610727842677896, 0.2728162578212988, 0.26964988735926154, 0.4064739452137034, 0.40398235891943124, 0.4735057945055666, 0.4806334285332249, 0.3561741315225796, 0.5140043103708374, 0.3905198514933237, 0.43238781579491303, 0.3744121788689001, 0.1584936685112287, 0.14402405462329249, 0.15342860792072988, 0.17757349014999402, 0.16832381746084357, 0.15561715154499767, 0.18581244990654966, 0.18340991015932573, 0.1739761581231738, 0.1785199315023559, 0.2373939242179829, 0.20998455828439755, 0.20107407789749365, 0.16020689864399096, 0.20692721568904093, 0.15357473258728893, 0.15481798393683022, 0.17443009503852103, 0.05524301155149369, 0.045199762774944086, 0.08977449998052267, 0.08596021716882318, 0.06879087527097383, 0.05245561709500235, 0.062440490347489885, 0.06174764586661108, 0.07038814680467276, 0.17625770678998176, 0.1787923412888731, 0.17185395676849546, 0.16975265668085904, 0.14494733878912303, 0.19078441603994645, 0.18937684716371572, 0.22622269015477836, 0.20445665861800533, 0.014304234562490414, 0.0017998272517983915, 0.003026966323345537, 0.021772386189121806, 0.00864770223196698, 0.016648833932903617, 0.017691188256325208, 0.0009961774331251894, 0.0279116449614345, 0.13068486800874723, 0.13356265760372243, 0.11216991425794554, 0.13548015782910994, 0.12330370985885242, 0.13692504640389402, 0.12497024206219043, 0.13010530799546793, 0.1193502938597345, 0.44441474532065317, 0.4638823086632442, 0.4468053974199955, 0.4683794466172171, 0.4544361510143695, 0.46523398461012133, 0.45041974909828664, 0.45816672689818383, 0.4679890992781153, 0.09474299414832965, 0.09418364097939425, 0.08000575295164469, 0.08369437866589957, 0.08982447294986928, 0.0841421614911867, 0.08844555871098347, 0.09017551632690812, 0.07923554130402011, 0.18484075600399297, 0.14962844846456025, 0.18403584524543837, 0.15538044246079286, 0.18775871591433657, 0.1497563260774124, 0.1723749624976303, 0.17781360182025696, 0.17503397838465085, 0.2628423917253897, 0.2688334432971228, 0.27634261882900957, 0.2432275078054439, 0.2719619067224929, 0.26107512578260994, 0.26125712042850424, 0.2740602595821323, 0.26983523766628736, 0.20434613358439324, 0.1897575395057184, 0.20562552251002775, 0.1768583654739514, 0.1903199584442018, 0.18527750752215955, 0.19800998551299065, 0.23760824644261103, 0.20304398300987037, 0.19490528283963526, 0.17179624739750976, 0.19114599734726445, 0.17447369451341999, 0.18860009109453757, 0.1674806044031506, 0.2069548002872349, 0.17852699525690363, 0.19534343700216006, 0.1840191033786498, 0.1750288993203174, 0.1930923432161844, 0.1855692438397213, 0.1831119607942353, 0.18496146540009206, 0.1767204654127823, 0.18635818933928094, 0.18099019925584603, 0.6782101964933263, 0.19559346162354774, 0.5770857806298362, 0.18076288422392095, 0.4472059094538545, 0.2793986095219855, 0.23017097158090116, 0.19440822654171053, 0.422924250764357, 0.44028375167946965, 0.20788764222944467, 0.4689290476772846, 0.3078262039162061, 0.20294842883046704, 0.3825673998843775, 0.20946341159286685, 0.20934396310652426, 0.20987626874754284, 0.17980412936721035, 0.196199328529155, 0.19830677088555348, 0.176287280820141, 0.21125932974557382, 0.18153317685456116, 0.17857362375474062, 0.20221355959329412, 0.19437079808783042, 0.08304349543553158, 0.07868709372199323, 0.07183326544971347, 0.08329466231601179, 0.07573166008260523, 0.07548687324686565, 0.06843485131611815, 0.06930184002749407, 0.08010534951500836]}, "mutation_prompt": null}
{"id": "6534cd23-8b39-4e1b-8f01-eef10a92837b", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                mutant = self.mutate(a, b, c)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c):\n        mutation = a + self.F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A hybrid Differential Evolution with Adaptive Local Search (DEALS) for efficient exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2ba6d4f4-5139-4688-b645-8e59dfe7046c", "metadata": {"aucs": [0.613270331469187, 0.6258958226501584, 0.5870749066099039, 0.6365712786861815, 0.6459401369382454, 0.6475354752106718, 0.6238965184089815, 0.6110144538563027, 0.6199987607899016, 0.3144918918200881, 0.3475802846399608, 0.3539967448321202, 0.3370465967401849, 0.37259822264709275, 0.35422171909838973, 0.3517112335157937, 0.36916956523357636, 0.35925935472050585, 0.09438211284932929, 0.09399424449843741, 0.08896936541248757, 0.10005149858902496, 0.09312269122619687, 0.08994390577919098, 0.11178702376325855, 0.1105361553443035, 0.09135551924142693, 0.09060728081183655, 0.08827080696727752, 0.08560083002159558, 0.10348673525084451, 0.08119266870308661, 0.09484814875658609, 0.09049086489585623, 0.09653841187300205, 0.08612734512616571, 0.9422375745133456, 0.9279611758746413, 0.970334753101139, 0.9331971894679348, 0.9180662947740443, 0.9591292392977449, 0.9510012245298195, 0.9730245240164237, 0.9389110086497934, 0.27522314395040215, 0.28459492694989597, 0.25921353020992466, 0.28965971311046557, 0.2718314257369333, 0.28989184903511467, 0.3352022915443257, 0.2819439545620793, 0.2784295190208501, 0.5407235660722138, 0.4012219810974118, 0.4279159159541672, 0.6247898314209537, 0.5395470057881797, 0.4973957049304115, 0.5287400566054581, 0.46324762437727973, 0.5524185607052914, 0.1662286054021671, 0.19114887210275733, 0.18509202571349814, 0.19393955612749436, 0.20506677150303299, 0.17807964029842094, 0.204646382805855, 0.1978390349789504, 0.1797026067114451, 0.22854221388923912, 0.20556843137806835, 0.23856445260927617, 0.1817475627934697, 0.18603047072929169, 0.1976390057530507, 0.19267739773915282, 0.18681613029250554, 0.2030933556834884, 0.09058782462294479, 0.14882842778054328, 0.1266782511073823, 0.14519317447083413, 0.12079477580706877, 0.07929331469540724, 0.11966524430128844, 0.13385841280792588, 0.10178956841696596, 0.26532518113491244, 0.24420394190622108, 0.23379230945762153, 0.19473809339058967, 0.23149130733820467, 0.22865843897122795, 0.24131430004459453, 0.23329950655801646, 0.27588751293463476, 0.021943419940596343, 0.013025071013518352, 0.04240732935656655, 0.027444732723628462, 0.02369063187090703, 0.019405870563226957, 0.018499647161437816, 0.014593467545289007, 0.01684496907285704, 0.15032863466481705, 0.14289751598885536, 0.1591384546327499, 0.15617872935474864, 0.1477645815072075, 0.16816068062038358, 0.1537163000318036, 0.14379657879213226, 0.137992580619822, 0.47633411457797603, 0.4806910994889465, 0.4940904415191718, 0.4881407653722122, 0.47158099758803207, 0.46628251865085013, 0.48452184113057417, 0.46625690122542696, 0.468195521112307, 0.10351625396526032, 0.09229254700307354, 0.10005369822766019, 0.08597881462048318, 0.09932138976188232, 0.0827154761655371, 0.09007055024076838, 0.09437514463047414, 0.09883735457352416, 0.19231855340155124, 0.1527233734046618, 0.16157228925907785, 0.17885503730419838, 0.18252668339842326, 0.17896300625231254, 0.14971090215781702, 0.20793221250898242, 0.14937192281394274, 0.2824004302940176, 0.2708157998650538, 0.27367624085198794, 0.27057584059923123, 0.2531827596416064, 0.2295900989896169, 0.2841189072756357, 0.28784692850742155, 0.30356298024618356, 0.2154360543366013, 0.19302197617019512, 0.21714290032560468, 0.21402008727452493, 0.2142484112383043, 0.1874091527109485, 0.19320551112488527, 0.21769061433338344, 0.21894314026801287, 0.2015704074317578, 0.16750608756991237, 0.18482259167911974, 0.19330195794489358, 0.18750637745133136, 0.1848776168116235, 0.1808028318689474, 0.2022265959108519, 0.199240168046675, 0.17840221218980046, 0.17302829688326982, 0.18261107600995474, 0.19479239131730153, 0.1839794162540136, 0.1792537954123069, 0.1850177747270112, 0.17612530666172155, 0.18034447838667234, 0.7293020260840269, 0.19209212244774476, 0.6613245977712534, 0.1755857176996758, 0.2933445058714311, 0.40804344633567236, 0.3481197350686259, 0.4746703223147458, 0.18546563356475643, 0.5407298932442539, 0.20897381189090025, 0.48651069193400787, 0.3480935816649926, 0.20822189969797067, 0.29057819191671763, 0.21030484021729245, 0.6442148839304698, 0.20881562702534584, 0.1961573655838107, 0.1904054375634361, 0.183425785809897, 0.18524374579342961, 0.18520400724795993, 0.20036385251953015, 0.17876746065598437, 0.18021791517979868, 0.2108821614977623, 0.07116383752390665, 0.0750786900658097, 0.08331860303222582, 0.08807683407891187, 0.07764485545478805, 0.06924827140792222, 0.08383190134748397, 0.07016644616564827, 0.07719914643009329]}, "mutation_prompt": null}
{"id": "6adcfea5-faa3-4404-a89e-20727d95f319", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                mutant = self.mutate(a, b, c)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c):\n        mutation = a + self.F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A hybrid Differential Evolution with Adaptive Local Search (DEALS) for efficient exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2ba6d4f4-5139-4688-b645-8e59dfe7046c", "metadata": {"aucs": [0.613270331469187, 0.6258958226501584, 0.5870749066099039, 0.6365712786861815, 0.6459401369382454, 0.6475354752106718, 0.6238965184089815, 0.6110144538563027, 0.6199987607899016, 0.3144918918200881, 0.3475802846399608, 0.3539967448321202, 0.3370465967401849, 0.37259822264709275, 0.35422171909838973, 0.3517112335157937, 0.36916956523357636, 0.35925935472050585, 0.09438211284932929, 0.09399424449843741, 0.08896936541248757, 0.10005149858902496, 0.09312269122619687, 0.08994390577919098, 0.11178702376325855, 0.1105361553443035, 0.09135551924142693, 0.09060728081183655, 0.08827080696727752, 0.08560083002159558, 0.10348673525084451, 0.08119266870308661, 0.09484814875658609, 0.09049086489585623, 0.09653841187300205, 0.08612734512616571, 0.9422375745133456, 0.9279611758746413, 0.970334753101139, 0.9331971894679348, 0.9180662947740443, 0.9591292392977449, 0.9510012245298195, 0.9730245240164237, 0.9389110086497934, 0.27522314395040215, 0.28459492694989597, 0.25921353020992466, 0.28965971311046557, 0.2718314257369333, 0.28989184903511467, 0.3352022915443257, 0.2819439545620793, 0.2784295190208501, 0.5407235660722138, 0.4012219810974118, 0.4279159159541672, 0.6247898314209537, 0.5395470057881797, 0.4973957049304115, 0.5287400566054581, 0.46324762437727973, 0.5524185607052914, 0.1662286054021671, 0.19114887210275733, 0.18509202571349814, 0.19393955612749436, 0.20506677150303299, 0.17807964029842094, 0.204646382805855, 0.1978390349789504, 0.1797026067114451, 0.22854221388923912, 0.20556843137806835, 0.23856445260927617, 0.1817475627934697, 0.18603047072929169, 0.1976390057530507, 0.19267739773915282, 0.18681613029250554, 0.2030933556834884, 0.09058782462294479, 0.14882842778054328, 0.1266782511073823, 0.14519317447083413, 0.12079477580706877, 0.07929331469540724, 0.11966524430128844, 0.13385841280792588, 0.10178956841696596, 0.26532518113491244, 0.24420394190622108, 0.23379230945762153, 0.19473809339058967, 0.23149130733820467, 0.22865843897122795, 0.24131430004459453, 0.23329950655801646, 0.27588751293463476, 0.021943419940596343, 0.013025071013518352, 0.04240732935656655, 0.027444732723628462, 0.02369063187090703, 0.019405870563226957, 0.018499647161437816, 0.014593467545289007, 0.01684496907285704, 0.15032863466481705, 0.14289751598885536, 0.1591384546327499, 0.15617872935474864, 0.1477645815072075, 0.16816068062038358, 0.1537163000318036, 0.14379657879213226, 0.137992580619822, 0.47633411457797603, 0.4806910994889465, 0.4940904415191718, 0.4881407653722122, 0.47158099758803207, 0.46628251865085013, 0.48452184113057417, 0.46625690122542696, 0.468195521112307, 0.10351625396526032, 0.09229254700307354, 0.10005369822766019, 0.08597881462048318, 0.09932138976188232, 0.0827154761655371, 0.09007055024076838, 0.09437514463047414, 0.09883735457352416, 0.19231855340155124, 0.1527233734046618, 0.16157228925907785, 0.17885503730419838, 0.18252668339842326, 0.17896300625231254, 0.14971090215781702, 0.20793221250898242, 0.14937192281394274, 0.2824004302940176, 0.2708157998650538, 0.27367624085198794, 0.27057584059923123, 0.2531827596416064, 0.2295900989896169, 0.2841189072756357, 0.28784692850742155, 0.30356298024618356, 0.2154360543366013, 0.19302197617019512, 0.21714290032560468, 0.21402008727452493, 0.2142484112383043, 0.1874091527109485, 0.19320551112488527, 0.21769061433338344, 0.21894314026801287, 0.2015704074317578, 0.16750608756991237, 0.18482259167911974, 0.19330195794489358, 0.18750637745133136, 0.1848776168116235, 0.1808028318689474, 0.2022265959108519, 0.199240168046675, 0.17840221218980046, 0.17302829688326982, 0.18261107600995474, 0.19479239131730153, 0.1839794162540136, 0.1792537954123069, 0.1850177747270112, 0.17612530666172155, 0.18034447838667234, 0.7293020260840269, 0.19209212244774476, 0.6613245977712534, 0.1755857176996758, 0.2933445058714311, 0.40804344633567236, 0.3481197350686259, 0.4746703223147458, 0.18546563356475643, 0.5407298932442539, 0.20897381189090025, 0.48651069193400787, 0.3480935816649926, 0.20822189969797067, 0.29057819191671763, 0.21030484021729245, 0.6442148839304698, 0.20881562702534584, 0.1961573655838107, 0.1904054375634361, 0.183425785809897, 0.18524374579342961, 0.18520400724795993, 0.20036385251953015, 0.17876746065598437, 0.18021791517979868, 0.2108821614977623, 0.07116383752390665, 0.0750786900658097, 0.08331860303222582, 0.08807683407891187, 0.07764485545478805, 0.06924827140792222, 0.08383190134748397, 0.07016644616564827, 0.07719914643009329]}, "mutation_prompt": null}
{"id": "af7eab9d-f575-45bf-bf94-599e43ef45aa", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                mutant = self.mutate(a, b, c)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c):\n        mutation = a + self.F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A hybrid Differential Evolution with Adaptive Local Search (DEALS) for efficient exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2ba6d4f4-5139-4688-b645-8e59dfe7046c", "metadata": {"aucs": [0.613270331469187, 0.6258958226501584, 0.5870749066099039, 0.6365712786861815, 0.6459401369382454, 0.6475354752106718, 0.6238965184089815, 0.6110144538563027, 0.6199987607899016, 0.3144918918200881, 0.3475802846399608, 0.3539967448321202, 0.3370465967401849, 0.37259822264709275, 0.35422171909838973, 0.3517112335157937, 0.36916956523357636, 0.35925935472050585, 0.09438211284932929, 0.09399424449843741, 0.08896936541248757, 0.10005149858902496, 0.09312269122619687, 0.08994390577919098, 0.11178702376325855, 0.1105361553443035, 0.09135551924142693, 0.09060728081183655, 0.08827080696727752, 0.08560083002159558, 0.10348673525084451, 0.08119266870308661, 0.09484814875658609, 0.09049086489585623, 0.09653841187300205, 0.08612734512616571, 0.9422375745133456, 0.9279611758746413, 0.970334753101139, 0.9331971894679348, 0.9180662947740443, 0.9591292392977449, 0.9510012245298195, 0.9730245240164237, 0.9389110086497934, 0.27522314395040215, 0.28459492694989597, 0.25921353020992466, 0.28965971311046557, 0.2718314257369333, 0.28989184903511467, 0.3352022915443257, 0.2819439545620793, 0.2784295190208501, 0.5407235660722138, 0.4012219810974118, 0.4279159159541672, 0.6247898314209537, 0.5395470057881797, 0.4973957049304115, 0.5287400566054581, 0.46324762437727973, 0.5524185607052914, 0.1662286054021671, 0.19114887210275733, 0.18509202571349814, 0.19393955612749436, 0.20506677150303299, 0.17807964029842094, 0.204646382805855, 0.1978390349789504, 0.1797026067114451, 0.22854221388923912, 0.20556843137806835, 0.23856445260927617, 0.1817475627934697, 0.18603047072929169, 0.1976390057530507, 0.19267739773915282, 0.18681613029250554, 0.2030933556834884, 0.09058782462294479, 0.14882842778054328, 0.1266782511073823, 0.14519317447083413, 0.12079477580706877, 0.07929331469540724, 0.11966524430128844, 0.13385841280792588, 0.10178956841696596, 0.26532518113491244, 0.24420394190622108, 0.23379230945762153, 0.19473809339058967, 0.23149130733820467, 0.22865843897122795, 0.24131430004459453, 0.23329950655801646, 0.27588751293463476, 0.021943419940596343, 0.013025071013518352, 0.04240732935656655, 0.027444732723628462, 0.02369063187090703, 0.019405870563226957, 0.018499647161437816, 0.014593467545289007, 0.01684496907285704, 0.15032863466481705, 0.14289751598885536, 0.1591384546327499, 0.15617872935474864, 0.1477645815072075, 0.16816068062038358, 0.1537163000318036, 0.14379657879213226, 0.137992580619822, 0.47633411457797603, 0.4806910994889465, 0.4940904415191718, 0.4881407653722122, 0.47158099758803207, 0.46628251865085013, 0.48452184113057417, 0.46625690122542696, 0.468195521112307, 0.10351625396526032, 0.09229254700307354, 0.10005369822766019, 0.08597881462048318, 0.09932138976188232, 0.0827154761655371, 0.09007055024076838, 0.09437514463047414, 0.09883735457352416, 0.19231855340155124, 0.1527233734046618, 0.16157228925907785, 0.17885503730419838, 0.18252668339842326, 0.17896300625231254, 0.14971090215781702, 0.20793221250898242, 0.14937192281394274, 0.2824004302940176, 0.2708157998650538, 0.27367624085198794, 0.27057584059923123, 0.2531827596416064, 0.2295900989896169, 0.2841189072756357, 0.28784692850742155, 0.30356298024618356, 0.2154360543366013, 0.19302197617019512, 0.21714290032560468, 0.21402008727452493, 0.2142484112383043, 0.1874091527109485, 0.19320551112488527, 0.21769061433338344, 0.21894314026801287, 0.2015704074317578, 0.16750608756991237, 0.18482259167911974, 0.19330195794489358, 0.18750637745133136, 0.1848776168116235, 0.1808028318689474, 0.2022265959108519, 0.199240168046675, 0.17840221218980046, 0.17302829688326982, 0.18261107600995474, 0.19479239131730153, 0.1839794162540136, 0.1792537954123069, 0.1850177747270112, 0.17612530666172155, 0.18034447838667234, 0.7293020260840269, 0.19209212244774476, 0.6613245977712534, 0.1755857176996758, 0.2933445058714311, 0.40804344633567236, 0.3481197350686259, 0.4746703223147458, 0.18546563356475643, 0.5407298932442539, 0.20897381189090025, 0.48651069193400787, 0.3480935816649926, 0.20822189969797067, 0.29057819191671763, 0.21030484021729245, 0.6442148839304698, 0.20881562702534584, 0.1961573655838107, 0.1904054375634361, 0.183425785809897, 0.18524374579342961, 0.18520400724795993, 0.20036385251953015, 0.17876746065598437, 0.18021791517979868, 0.2108821614977623, 0.07116383752390665, 0.0750786900658097, 0.08331860303222582, 0.08807683407891187, 0.07764485545478805, 0.06924827140792222, 0.08383190134748397, 0.07016644616564827, 0.07719914643009329]}, "mutation_prompt": null}
{"id": "c459969f-50d7-4e3e-ac01-563d3a467525", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) using an enhanced dynamic mutation factor for improved convergence speed.", "configspace": "", "generation": 15, "fitness": 0.3274958018397176, "feedback": "The algorithm DEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.23.", "error": "", "parent_id": "2ba6d4f4-5139-4688-b645-8e59dfe7046c", "metadata": {"aucs": [0.6938020557061727, 0.6981896661863495, 0.6832572940694606, 0.7118201728758551, 0.7129978187803072, 0.7173963547599209, 0.6864217748144283, 0.702758150094549, 0.7044217309543193, 0.5128095982732479, 0.5171731757544356, 0.4890688084835998, 0.4863608326326545, 0.4873512782714371, 0.48929177690773273, 0.5062501959066199, 0.49714217269784733, 0.506742858219779, 0.08992500281273785, 0.1061396298697369, 0.09711102230545965, 0.10870244394188178, 0.11253883223376959, 0.10271409065771875, 0.1100942190128078, 0.10589116692490408, 0.1032699262483957, 0.08963959219748063, 0.08975651710680344, 0.10108499527013659, 0.09196430606281569, 0.087017555003718, 0.09515561255218419, 0.08950201785486245, 0.09004189900107795, 0.08425322283908077, 0.9422406949352691, 0.9433086573391383, 0.9703321306715395, 0.9331827232489784, 0.9195484499935498, 0.9591235018926786, 0.9509986193324821, 0.9730242893377619, 0.9389140432492129, 0.3528831042783015, 0.36731293026926437, 0.3696874537347312, 0.37771034549502625, 0.3366397107284792, 0.3580732123738961, 0.3815627016238107, 0.3574597068540636, 0.3572630315728009, 0.6438127089797783, 0.6394258191332831, 0.5602401632456759, 0.6193822687953531, 0.6436672334608058, 0.6525122543660753, 0.6347016861344785, 0.6147008185234284, 0.6749795357566231, 0.17506923632689408, 0.1936526803929698, 0.16508234706868785, 0.19110298977276108, 0.19403720792156942, 0.208140473620975, 0.32434122880445815, 0.1985030891121613, 0.20586772211259885, 0.4167476604148713, 0.2020680257282471, 0.2891622316534951, 0.16623280539585739, 0.1852319821431916, 0.19043127981739327, 0.2056927281801203, 0.1810810543834105, 0.19946847238749976, 0.2477673825225304, 0.26418822020828125, 0.28268416098091065, 0.285827225974043, 0.2773613057032118, 0.188773959728881, 0.27981425517015457, 0.30265163075710144, 0.24810912730055534, 0.4066560079555027, 0.3499015692329147, 0.3650236849998547, 0.3979698736491353, 0.33797371123289377, 0.37439555511423783, 0.40052815887111914, 0.43079029490133947, 0.3737425207672007, 0.09701464740184274, 0.0894324774946581, 0.09983427158218694, 0.13472239029603572, 0.11642803065301288, 0.12966639440225192, 0.087758135565705, 0.10473685963941937, 0.10379002174616381, 0.22437111858363712, 0.24553293597322068, 0.2144652259866502, 0.26552190901665884, 0.25537105190918685, 0.24840110870161358, 0.24535058270163368, 0.21384298862942808, 0.22907387397129308, 0.5884618146606102, 0.5867976141560072, 0.6066141450750275, 0.5716074026778855, 0.6019445645761137, 0.5924653240725618, 0.5978889438907456, 0.5555938238341418, 0.597262810740798, 0.09009334896015553, 0.08861525457028441, 0.09164868700359219, 0.11163222938480599, 0.0934407244375911, 0.09356074410747606, 0.10939628036665294, 0.07961687934678852, 0.08254215061390457, 0.16762049476224672, 0.16036355398778868, 0.16143480860624493, 0.17887322863222976, 0.18252668339842326, 0.1990710867165847, 0.17751008518028666, 0.17665327058597413, 0.1805291896326231, 0.35792073248886314, 0.359882777675385, 0.35946586638892053, 0.33129099109316384, 0.36748811786171254, 0.3536487202734797, 0.3881048011042082, 0.3757826235749724, 0.37124349130847345, 0.26184998217733435, 0.2779939151655274, 0.289484162015998, 0.2666061674353709, 0.25516634468174504, 0.27087548699762487, 0.2713926361687682, 0.27883912262846533, 0.29313907603873035, 0.18879765714740238, 0.18021154114001858, 0.17299995695223047, 0.20190749341392822, 0.19373337008636105, 0.1944086463788257, 0.20485669752197178, 0.19377016201383623, 0.20456540036620208, 0.20900102494516182, 0.19805746184984585, 0.19096154567347734, 0.18460546893788143, 0.1969971707242144, 0.18435695792586582, 0.2004587245841042, 0.1807199401086378, 0.1897370361032712, 0.7729256214372398, 0.1660480540086583, 0.741581655383842, 0.6508397162037352, 0.468030139366688, 0.5593108175693271, 0.6059660170216032, 0.5612402270838825, 0.6313077798179025, 0.6373432126912961, 0.21057684436025736, 0.555084825263708, 0.58965711453779, 0.20892621194061467, 0.5987323016595096, 0.21041146656458332, 0.20974796311522448, 0.20912280833717034, 0.19485223308098742, 0.19120036704835464, 0.1876457421544644, 0.17179599986957128, 0.19202530144522956, 0.17554171264851992, 0.19125976217298912, 0.18617855925794513, 0.19471502538714358, 0.07908637111615457, 0.07368576916892267, 0.08700480035958169, 0.0833944918566254, 0.07803286149322008, 0.07076553503613592, 0.07791515250978842, 0.06956739599265638, 0.08135547831575585]}, "mutation_prompt": null}
{"id": "7ad196fd-d65c-46fd-a2e0-8aa2ad580744", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) using an enhanced dynamic mutation factor for improved convergence speed.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c459969f-50d7-4e3e-ac01-563d3a467525", "metadata": {"aucs": [0.6938020557061727, 0.6981896661863495, 0.6832572940694606, 0.7118201728758551, 0.7129978187803072, 0.7173963547599209, 0.6864217748144283, 0.702758150094549, 0.7044217309543193, 0.5128095982732479, 0.5171731757544356, 0.4890688084835998, 0.4863608326326545, 0.4873512782714371, 0.48929177690773273, 0.5062501959066199, 0.49714217269784733, 0.506742858219779, 0.08992500281273785, 0.1061396298697369, 0.09711102230545965, 0.10870244394188178, 0.11253883223376959, 0.10271409065771875, 0.1100942190128078, 0.10589116692490408, 0.1032699262483957, 0.08963959219748063, 0.08975651710680344, 0.10108499527013659, 0.09196430606281569, 0.087017555003718, 0.09515561255218419, 0.08950201785486245, 0.09004189900107795, 0.08425322283908077, 0.9422406949352691, 0.9433086573391383, 0.9703321306715395, 0.9331827232489784, 0.9195484499935498, 0.9591235018926786, 0.9509986193324821, 0.9730242893377619, 0.9389140432492129, 0.3528831042783015, 0.36731293026926437, 0.3696874537347312, 0.37771034549502625, 0.3366397107284792, 0.3580732123738961, 0.3815627016238107, 0.3574597068540636, 0.3572630315728009, 0.6438127089797783, 0.6394258191332831, 0.5602401632456759, 0.6193822687953531, 0.6436672334608058, 0.6525122543660753, 0.6347016861344785, 0.6147008185234284, 0.6749795357566231, 0.17506923632689408, 0.1936526803929698, 0.16508234706868785, 0.19110298977276108, 0.19403720792156942, 0.208140473620975, 0.32434122880445815, 0.1985030891121613, 0.20586772211259885, 0.4167476604148713, 0.2020680257282471, 0.2891622316534951, 0.16623280539585739, 0.1852319821431916, 0.19043127981739327, 0.2056927281801203, 0.1810810543834105, 0.19946847238749976, 0.2477673825225304, 0.26418822020828125, 0.28268416098091065, 0.285827225974043, 0.2773613057032118, 0.188773959728881, 0.27981425517015457, 0.30265163075710144, 0.24810912730055534, 0.4066560079555027, 0.3499015692329147, 0.3650236849998547, 0.3979698736491353, 0.33797371123289377, 0.37439555511423783, 0.40052815887111914, 0.43079029490133947, 0.3737425207672007, 0.09701464740184274, 0.0894324774946581, 0.09983427158218694, 0.13472239029603572, 0.11642803065301288, 0.12966639440225192, 0.087758135565705, 0.10473685963941937, 0.10379002174616381, 0.22437111858363712, 0.24553293597322068, 0.2144652259866502, 0.26552190901665884, 0.25537105190918685, 0.24840110870161358, 0.24535058270163368, 0.21384298862942808, 0.22907387397129308, 0.5884618146606102, 0.5867976141560072, 0.6066141450750275, 0.5716074026778855, 0.6019445645761137, 0.5924653240725618, 0.5978889438907456, 0.5555938238341418, 0.597262810740798, 0.09009334896015553, 0.08861525457028441, 0.09164868700359219, 0.11163222938480599, 0.0934407244375911, 0.09356074410747606, 0.10939628036665294, 0.07961687934678852, 0.08254215061390457, 0.16762049476224672, 0.16036355398778868, 0.16143480860624493, 0.17887322863222976, 0.18252668339842326, 0.1990710867165847, 0.17751008518028666, 0.17665327058597413, 0.1805291896326231, 0.35792073248886314, 0.359882777675385, 0.35946586638892053, 0.33129099109316384, 0.36748811786171254, 0.3536487202734797, 0.3881048011042082, 0.3757826235749724, 0.37124349130847345, 0.26184998217733435, 0.2779939151655274, 0.289484162015998, 0.2666061674353709, 0.25516634468174504, 0.27087548699762487, 0.2713926361687682, 0.27883912262846533, 0.29313907603873035, 0.18879765714740238, 0.18021154114001858, 0.17299995695223047, 0.20190749341392822, 0.19373337008636105, 0.1944086463788257, 0.20485669752197178, 0.19377016201383623, 0.20456540036620208, 0.20900102494516182, 0.19805746184984585, 0.19096154567347734, 0.18460546893788143, 0.1969971707242144, 0.18435695792586582, 0.2004587245841042, 0.1807199401086378, 0.1897370361032712, 0.7729256214372398, 0.1660480540086583, 0.741581655383842, 0.6508397162037352, 0.468030139366688, 0.5593108175693271, 0.6059660170216032, 0.5612402270838825, 0.6313077798179025, 0.6373432126912961, 0.21057684436025736, 0.555084825263708, 0.58965711453779, 0.20892621194061467, 0.5987323016595096, 0.21041146656458332, 0.20974796311522448, 0.20912280833717034, 0.19485223308098742, 0.19120036704835464, 0.1876457421544644, 0.17179599986957128, 0.19202530144522956, 0.17554171264851992, 0.19125976217298912, 0.18617855925794513, 0.19471502538714358, 0.07908637111615457, 0.07368576916892267, 0.08700480035958169, 0.0833944918566254, 0.07803286149322008, 0.07076553503613592, 0.07791515250978842, 0.06956739599265638, 0.08135547831575585]}, "mutation_prompt": null}
{"id": "0b41f04e-25fb-4cc4-a29c-eaec182b2982", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) using an enhanced dynamic mutation factor for improved convergence speed.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c459969f-50d7-4e3e-ac01-563d3a467525", "metadata": {"aucs": [0.6938020557061727, 0.6981896661863495, 0.6832572940694606, 0.7118201728758551, 0.7129978187803072, 0.7173963547599209, 0.6864217748144283, 0.702758150094549, 0.7044217309543193, 0.5128095982732479, 0.5171731757544356, 0.4890688084835998, 0.4863608326326545, 0.4873512782714371, 0.48929177690773273, 0.5062501959066199, 0.49714217269784733, 0.506742858219779, 0.08992500281273785, 0.1061396298697369, 0.09711102230545965, 0.10870244394188178, 0.11253883223376959, 0.10271409065771875, 0.1100942190128078, 0.10589116692490408, 0.1032699262483957, 0.08963959219748063, 0.08975651710680344, 0.10108499527013659, 0.09196430606281569, 0.087017555003718, 0.09515561255218419, 0.08950201785486245, 0.09004189900107795, 0.08425322283908077, 0.9422406949352691, 0.9433086573391383, 0.9703321306715395, 0.9331827232489784, 0.9195484499935498, 0.9591235018926786, 0.9509986193324821, 0.9730242893377619, 0.9389140432492129, 0.3528831042783015, 0.36731293026926437, 0.3696874537347312, 0.37771034549502625, 0.3366397107284792, 0.3580732123738961, 0.3815627016238107, 0.3574597068540636, 0.3572630315728009, 0.6438127089797783, 0.6394258191332831, 0.5602401632456759, 0.6193822687953531, 0.6436672334608058, 0.6525122543660753, 0.6347016861344785, 0.6147008185234284, 0.6749795357566231, 0.17506923632689408, 0.1936526803929698, 0.16508234706868785, 0.19110298977276108, 0.19403720792156942, 0.208140473620975, 0.32434122880445815, 0.1985030891121613, 0.20586772211259885, 0.4167476604148713, 0.2020680257282471, 0.2891622316534951, 0.16623280539585739, 0.1852319821431916, 0.19043127981739327, 0.2056927281801203, 0.1810810543834105, 0.19946847238749976, 0.2477673825225304, 0.26418822020828125, 0.28268416098091065, 0.285827225974043, 0.2773613057032118, 0.188773959728881, 0.27981425517015457, 0.30265163075710144, 0.24810912730055534, 0.4066560079555027, 0.3499015692329147, 0.3650236849998547, 0.3979698736491353, 0.33797371123289377, 0.37439555511423783, 0.40052815887111914, 0.43079029490133947, 0.3737425207672007, 0.09701464740184274, 0.0894324774946581, 0.09983427158218694, 0.13472239029603572, 0.11642803065301288, 0.12966639440225192, 0.087758135565705, 0.10473685963941937, 0.10379002174616381, 0.22437111858363712, 0.24553293597322068, 0.2144652259866502, 0.26552190901665884, 0.25537105190918685, 0.24840110870161358, 0.24535058270163368, 0.21384298862942808, 0.22907387397129308, 0.5884618146606102, 0.5867976141560072, 0.6066141450750275, 0.5716074026778855, 0.6019445645761137, 0.5924653240725618, 0.5978889438907456, 0.5555938238341418, 0.597262810740798, 0.09009334896015553, 0.08861525457028441, 0.09164868700359219, 0.11163222938480599, 0.0934407244375911, 0.09356074410747606, 0.10939628036665294, 0.07961687934678852, 0.08254215061390457, 0.16762049476224672, 0.16036355398778868, 0.16143480860624493, 0.17887322863222976, 0.18252668339842326, 0.1990710867165847, 0.17751008518028666, 0.17665327058597413, 0.1805291896326231, 0.35792073248886314, 0.359882777675385, 0.35946586638892053, 0.33129099109316384, 0.36748811786171254, 0.3536487202734797, 0.3881048011042082, 0.3757826235749724, 0.37124349130847345, 0.26184998217733435, 0.2779939151655274, 0.289484162015998, 0.2666061674353709, 0.25516634468174504, 0.27087548699762487, 0.2713926361687682, 0.27883912262846533, 0.29313907603873035, 0.18879765714740238, 0.18021154114001858, 0.17299995695223047, 0.20190749341392822, 0.19373337008636105, 0.1944086463788257, 0.20485669752197178, 0.19377016201383623, 0.20456540036620208, 0.20900102494516182, 0.19805746184984585, 0.19096154567347734, 0.18460546893788143, 0.1969971707242144, 0.18435695792586582, 0.2004587245841042, 0.1807199401086378, 0.1897370361032712, 0.7729256214372398, 0.1660480540086583, 0.741581655383842, 0.6508397162037352, 0.468030139366688, 0.5593108175693271, 0.6059660170216032, 0.5612402270838825, 0.6313077798179025, 0.6373432126912961, 0.21057684436025736, 0.555084825263708, 0.58965711453779, 0.20892621194061467, 0.5987323016595096, 0.21041146656458332, 0.20974796311522448, 0.20912280833717034, 0.19485223308098742, 0.19120036704835464, 0.1876457421544644, 0.17179599986957128, 0.19202530144522956, 0.17554171264851992, 0.19125976217298912, 0.18617855925794513, 0.19471502538714358, 0.07908637111615457, 0.07368576916892267, 0.08700480035958169, 0.0833944918566254, 0.07803286149322008, 0.07076553503613592, 0.07791515250978842, 0.06956739599265638, 0.08135547831575585]}, "mutation_prompt": null}
{"id": "13da8504-f06f-4f0f-af21-a537fe26b4c5", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) using an enhanced dynamic mutation factor for improved convergence speed.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c459969f-50d7-4e3e-ac01-563d3a467525", "metadata": {"aucs": [0.6938020557061727, 0.6981896661863495, 0.6832572940694606, 0.7118201728758551, 0.7129978187803072, 0.7173963547599209, 0.6864217748144283, 0.702758150094549, 0.7044217309543193, 0.5128095982732479, 0.5171731757544356, 0.4890688084835998, 0.4863608326326545, 0.4873512782714371, 0.48929177690773273, 0.5062501959066199, 0.49714217269784733, 0.506742858219779, 0.08992500281273785, 0.1061396298697369, 0.09711102230545965, 0.10870244394188178, 0.11253883223376959, 0.10271409065771875, 0.1100942190128078, 0.10589116692490408, 0.1032699262483957, 0.08963959219748063, 0.08975651710680344, 0.10108499527013659, 0.09196430606281569, 0.087017555003718, 0.09515561255218419, 0.08950201785486245, 0.09004189900107795, 0.08425322283908077, 0.9422406949352691, 0.9433086573391383, 0.9703321306715395, 0.9331827232489784, 0.9195484499935498, 0.9591235018926786, 0.9509986193324821, 0.9730242893377619, 0.9389140432492129, 0.3528831042783015, 0.36731293026926437, 0.3696874537347312, 0.37771034549502625, 0.3366397107284792, 0.3580732123738961, 0.3815627016238107, 0.3574597068540636, 0.3572630315728009, 0.6438127089797783, 0.6394258191332831, 0.5602401632456759, 0.6193822687953531, 0.6436672334608058, 0.6525122543660753, 0.6347016861344785, 0.6147008185234284, 0.6749795357566231, 0.17506923632689408, 0.1936526803929698, 0.16508234706868785, 0.19110298977276108, 0.19403720792156942, 0.208140473620975, 0.32434122880445815, 0.1985030891121613, 0.20586772211259885, 0.4167476604148713, 0.2020680257282471, 0.2891622316534951, 0.16623280539585739, 0.1852319821431916, 0.19043127981739327, 0.2056927281801203, 0.1810810543834105, 0.19946847238749976, 0.2477673825225304, 0.26418822020828125, 0.28268416098091065, 0.285827225974043, 0.2773613057032118, 0.188773959728881, 0.27981425517015457, 0.30265163075710144, 0.24810912730055534, 0.4066560079555027, 0.3499015692329147, 0.3650236849998547, 0.3979698736491353, 0.33797371123289377, 0.37439555511423783, 0.40052815887111914, 0.43079029490133947, 0.3737425207672007, 0.09701464740184274, 0.0894324774946581, 0.09983427158218694, 0.13472239029603572, 0.11642803065301288, 0.12966639440225192, 0.087758135565705, 0.10473685963941937, 0.10379002174616381, 0.22437111858363712, 0.24553293597322068, 0.2144652259866502, 0.26552190901665884, 0.25537105190918685, 0.24840110870161358, 0.24535058270163368, 0.21384298862942808, 0.22907387397129308, 0.5884618146606102, 0.5867976141560072, 0.6066141450750275, 0.5716074026778855, 0.6019445645761137, 0.5924653240725618, 0.5978889438907456, 0.5555938238341418, 0.597262810740798, 0.09009334896015553, 0.08861525457028441, 0.09164868700359219, 0.11163222938480599, 0.0934407244375911, 0.09356074410747606, 0.10939628036665294, 0.07961687934678852, 0.08254215061390457, 0.16762049476224672, 0.16036355398778868, 0.16143480860624493, 0.17887322863222976, 0.18252668339842326, 0.1990710867165847, 0.17751008518028666, 0.17665327058597413, 0.1805291896326231, 0.35792073248886314, 0.359882777675385, 0.35946586638892053, 0.33129099109316384, 0.36748811786171254, 0.3536487202734797, 0.3881048011042082, 0.3757826235749724, 0.37124349130847345, 0.26184998217733435, 0.2779939151655274, 0.289484162015998, 0.2666061674353709, 0.25516634468174504, 0.27087548699762487, 0.2713926361687682, 0.27883912262846533, 0.29313907603873035, 0.18879765714740238, 0.18021154114001858, 0.17299995695223047, 0.20190749341392822, 0.19373337008636105, 0.1944086463788257, 0.20485669752197178, 0.19377016201383623, 0.20456540036620208, 0.20900102494516182, 0.19805746184984585, 0.19096154567347734, 0.18460546893788143, 0.1969971707242144, 0.18435695792586582, 0.2004587245841042, 0.1807199401086378, 0.1897370361032712, 0.7729256214372398, 0.1660480540086583, 0.741581655383842, 0.6508397162037352, 0.468030139366688, 0.5593108175693271, 0.6059660170216032, 0.5612402270838825, 0.6313077798179025, 0.6373432126912961, 0.21057684436025736, 0.555084825263708, 0.58965711453779, 0.20892621194061467, 0.5987323016595096, 0.21041146656458332, 0.20974796311522448, 0.20912280833717034, 0.19485223308098742, 0.19120036704835464, 0.1876457421544644, 0.17179599986957128, 0.19202530144522956, 0.17554171264851992, 0.19125976217298912, 0.18617855925794513, 0.19471502538714358, 0.07908637111615457, 0.07368576916892267, 0.08700480035958169, 0.0833944918566254, 0.07803286149322008, 0.07076553503613592, 0.07791515250978842, 0.06956739599265638, 0.08135547831575585]}, "mutation_prompt": null}
{"id": "1f7c67ce-1cb2-48d7-adbf-b6b19315324b", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n        self.dynamic_CR = lambda evals: 0.9 - 0.4 * np.sin(np.pi * evals / self.budget)  # Added dynamic crossover\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                current_F = self.dynamic_F(eval_count)\n                current_CR = self.dynamic_CR(eval_count)  # Use dynamic crossover\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant, current_CR)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant, CR):\n        crossover_mask = np.random.rand(self.dim) < CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "Enhanced Differential Evolution with stochastic local search and dynamic crossover.", "configspace": "", "generation": 19, "fitness": 0.25553288588941686, "feedback": "The algorithm DEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "c459969f-50d7-4e3e-ac01-563d3a467525", "metadata": {"aucs": [0.7025567494744485, 0.6931751087700839, 0.6961964334439841, 0.7079241971721847, 0.7006941406646949, 0.7145544274142563, 0.7118809933978898, 0.7168378899923048, 0.7204544799384398, 0.4990713030442083, 0.5235917169582114, 0.4810006409147223, 0.5024540868857756, 0.515691509941852, 0.4880274801606823, 0.5140063277040485, 0.5235172400953154, 0.5069535941253963, 0.15846067227136196, 0.15517035846587546, 0.25112338291541536, 0.18620487282639242, 0.15128589438775675, 0.18024657199710115, 0.23173424462978576, 0.17314542787425435, 0.17601511770262335, 0.19180067121672406, 0.12152572241545934, 0.13874352225827247, 0.14061637964850093, 0.12977079018084992, 0.1437997570818883, 0.16287245181829257, 0.1317445945893132, 0.1244971377978421, 0.9311610769024719, 0.9375616497299802, 0.934579123841299, 0.950021372960605, 0.9180656934309714, 0.9394914015942148, 0.9546326984744963, 0.9398980885203538, 0.9188785179751597, 0.2785512284564049, 0.2921963910739852, 0.2646163475103075, 0.2844739436240922, 0.31319370793845747, 0.30486036006507033, 0.26148307658371595, 0.2918979324938048, 0.29050673814747063, 0.3764341552176895, 0.39067584688003076, 0.31633448859101987, 0.3103615093756249, 0.3336025771236826, 0.36451940161237595, 0.3169727956702718, 0.36486973966327696, 0.3989970212639775, 0.13960460207608683, 0.14793073227265618, 0.1297938831965454, 0.14156720555265634, 0.1580701133539837, 0.15844126018740012, 0.1638723111288718, 0.1422854206810087, 0.16935419410915764, 0.1398410177223608, 0.11363828795190678, 0.16334642281468148, 0.14215240277579555, 0.13887922833710586, 0.14704094609712426, 0.13360907634038977, 0.13461229307044376, 0.1523923290504715, 9.999999999998899e-05, 0.007237013866677855, 0.008999308718189214, 0.008493930327241106, 0.002338874358812082, 0.0015181203225381745, 0.0042531065244076904, 0.02553663438678977, 0.0021145268526800987, 0.10990056265415715, 0.07938243324319738, 0.09676177399152419, 0.09549248130098298, 0.061095120920823365, 0.06933634393059451, 0.13009091080725232, 0.10977593698898769, 0.09634090506264203, 0.0002952911769076305, 0.0011249377966096041, 0.003221457839733599, 0.0018201599456278972, 0.004055685726644498, 0.002285578386127085, 0.0033572687768528287, 0.00509363982590072, 0.004319906322667322, 0.10189926918926062, 0.10213642159073011, 0.09835166689375763, 0.10964757689959204, 0.10305113564287582, 0.11767733065690389, 0.08622209543992854, 0.10387305398216162, 0.11183378149102408, 0.44437661253450367, 0.46752291523244194, 0.4570396688046928, 0.4580473999091671, 0.46199714074212395, 0.4557244124674138, 0.4565190331395981, 0.43425119344087215, 0.4541547415325534, 0.08857007783612592, 0.09384064202386488, 0.0916708963033247, 0.10033894320686465, 0.09271629342976251, 0.08825130473736609, 0.10511685387711911, 0.09815710745725814, 0.09724995073615683, 0.2195936342558864, 0.225620358811232, 0.1672935939588699, 0.1888192614271691, 0.19725219573924035, 0.1985553564982282, 0.18844634027309837, 0.1417080446638842, 0.15724381404369592, 0.29761918002386123, 0.2723145746753991, 0.2699857191552363, 0.27606293717343644, 0.286331096802393, 0.2885480867565038, 0.32821448494125216, 0.34306767425494666, 0.3154675512710965, 0.20502901862826883, 0.2034261727456984, 0.2010649706222133, 0.18355005369538335, 0.19749174010353832, 0.1787335261569971, 0.23290753234081907, 0.22313007145862163, 0.18977687114676323, 0.21037274383963167, 0.17998502012785866, 0.19862051050936924, 0.21825735954669634, 0.19884108649562815, 0.18732328418481226, 0.19119788958371553, 0.20180208638706432, 0.18100755626683174, 0.2075748642066585, 0.21440512744461215, 0.20557882893090484, 0.19758000482230242, 0.1919226843883851, 0.2095189985791469, 0.20442119080322596, 0.20338375697209532, 0.2163913946339, 0.6551280858233239, 0.3670150629044492, 0.19608658477494167, 0.27810417501045614, 0.2563259708722806, 0.44756011238940596, 0.35643121542002765, 0.2715917498597059, 0.1863267826197853, 0.3661376613069721, 0.20898956334998242, 0.2766420279282932, 0.3184033575180033, 0.20810312305188083, 0.29472240663017935, 0.20680136828993334, 0.4270596633128786, 0.2092168466302804, 0.1829352613827021, 0.1780992762998268, 0.1833241520543546, 0.19738665729720606, 0.18949760790832804, 0.1881420611465836, 0.19193609477096918, 0.18188082646044101, 0.18172862453824, 0.08009310178960494, 0.08271163683201266, 0.08469903887323149, 0.07183051715732236, 0.08243259486519527, 0.07722355746491993, 0.07661759214633113, 0.08292298589967362, 0.07836382732006497]}, "mutation_prompt": null}
{"id": "7f00a2c2-8eec-41b0-985d-6eea65ee90c8", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) using an enhanced dynamic mutation factor for improved convergence speed.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c459969f-50d7-4e3e-ac01-563d3a467525", "metadata": {"aucs": [0.6938020557061727, 0.6981896661863495, 0.6832572940694606, 0.7118201728758551, 0.7129978187803072, 0.7173963547599209, 0.6864217748144283, 0.702758150094549, 0.7044217309543193, 0.5128095982732479, 0.5171731757544356, 0.4890688084835998, 0.4863608326326545, 0.4873512782714371, 0.48929177690773273, 0.5062501959066199, 0.49714217269784733, 0.506742858219779, 0.08992500281273785, 0.1061396298697369, 0.09711102230545965, 0.10870244394188178, 0.11253883223376959, 0.10271409065771875, 0.1100942190128078, 0.10589116692490408, 0.1032699262483957, 0.08963959219748063, 0.08975651710680344, 0.10108499527013659, 0.09196430606281569, 0.087017555003718, 0.09515561255218419, 0.08950201785486245, 0.09004189900107795, 0.08425322283908077, 0.9422406949352691, 0.9433086573391383, 0.9703321306715395, 0.9331827232489784, 0.9195484499935498, 0.9591235018926786, 0.9509986193324821, 0.9730242893377619, 0.9389140432492129, 0.3528831042783015, 0.36731293026926437, 0.3696874537347312, 0.37771034549502625, 0.3366397107284792, 0.3580732123738961, 0.3815627016238107, 0.3574597068540636, 0.3572630315728009, 0.6438127089797783, 0.6394258191332831, 0.5602401632456759, 0.6193822687953531, 0.6436672334608058, 0.6525122543660753, 0.6347016861344785, 0.6147008185234284, 0.6749795357566231, 0.17506923632689408, 0.1936526803929698, 0.16508234706868785, 0.19110298977276108, 0.19403720792156942, 0.208140473620975, 0.32434122880445815, 0.1985030891121613, 0.20586772211259885, 0.4167476604148713, 0.2020680257282471, 0.2891622316534951, 0.16623280539585739, 0.1852319821431916, 0.19043127981739327, 0.2056927281801203, 0.1810810543834105, 0.19946847238749976, 0.2477673825225304, 0.26418822020828125, 0.28268416098091065, 0.285827225974043, 0.2773613057032118, 0.188773959728881, 0.27981425517015457, 0.30265163075710144, 0.24810912730055534, 0.4066560079555027, 0.3499015692329147, 0.3650236849998547, 0.3979698736491353, 0.33797371123289377, 0.37439555511423783, 0.40052815887111914, 0.43079029490133947, 0.3737425207672007, 0.09701464740184274, 0.0894324774946581, 0.09983427158218694, 0.13472239029603572, 0.11642803065301288, 0.12966639440225192, 0.087758135565705, 0.10473685963941937, 0.10379002174616381, 0.22437111858363712, 0.24553293597322068, 0.2144652259866502, 0.26552190901665884, 0.25537105190918685, 0.24840110870161358, 0.24535058270163368, 0.21384298862942808, 0.22907387397129308, 0.5884618146606102, 0.5867976141560072, 0.6066141450750275, 0.5716074026778855, 0.6019445645761137, 0.5924653240725618, 0.5978889438907456, 0.5555938238341418, 0.597262810740798, 0.09009334896015553, 0.08861525457028441, 0.09164868700359219, 0.11163222938480599, 0.0934407244375911, 0.09356074410747606, 0.10939628036665294, 0.07961687934678852, 0.08254215061390457, 0.16762049476224672, 0.16036355398778868, 0.16143480860624493, 0.17887322863222976, 0.18252668339842326, 0.1990710867165847, 0.17751008518028666, 0.17665327058597413, 0.1805291896326231, 0.35792073248886314, 0.359882777675385, 0.35946586638892053, 0.33129099109316384, 0.36748811786171254, 0.3536487202734797, 0.3881048011042082, 0.3757826235749724, 0.37124349130847345, 0.26184998217733435, 0.2779939151655274, 0.289484162015998, 0.2666061674353709, 0.25516634468174504, 0.27087548699762487, 0.2713926361687682, 0.27883912262846533, 0.29313907603873035, 0.18879765714740238, 0.18021154114001858, 0.17299995695223047, 0.20190749341392822, 0.19373337008636105, 0.1944086463788257, 0.20485669752197178, 0.19377016201383623, 0.20456540036620208, 0.20900102494516182, 0.19805746184984585, 0.19096154567347734, 0.18460546893788143, 0.1969971707242144, 0.18435695792586582, 0.2004587245841042, 0.1807199401086378, 0.1897370361032712, 0.7729256214372398, 0.1660480540086583, 0.741581655383842, 0.6508397162037352, 0.468030139366688, 0.5593108175693271, 0.6059660170216032, 0.5612402270838825, 0.6313077798179025, 0.6373432126912961, 0.21057684436025736, 0.555084825263708, 0.58965711453779, 0.20892621194061467, 0.5987323016595096, 0.21041146656458332, 0.20974796311522448, 0.20912280833717034, 0.19485223308098742, 0.19120036704835464, 0.1876457421544644, 0.17179599986957128, 0.19202530144522956, 0.17554171264851992, 0.19125976217298912, 0.18617855925794513, 0.19471502538714358, 0.07908637111615457, 0.07368576916892267, 0.08700480035958169, 0.0833944918566254, 0.07803286149322008, 0.07076553503613592, 0.07791515250978842, 0.06956739599265638, 0.08135547831575585]}, "mutation_prompt": null}
{"id": "da1fed1f-c271-4fb4-93be-ef43daad7320", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) using an enhanced dynamic mutation factor for improved convergence speed.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c459969f-50d7-4e3e-ac01-563d3a467525", "metadata": {"aucs": [0.6938020557061727, 0.6981896661863495, 0.6832572940694606, 0.7118201728758551, 0.7129978187803072, 0.7173963547599209, 0.6864217748144283, 0.702758150094549, 0.7044217309543193, 0.5128095982732479, 0.5171731757544356, 0.4890688084835998, 0.4863608326326545, 0.4873512782714371, 0.48929177690773273, 0.5062501959066199, 0.49714217269784733, 0.506742858219779, 0.08992500281273785, 0.1061396298697369, 0.09711102230545965, 0.10870244394188178, 0.11253883223376959, 0.10271409065771875, 0.1100942190128078, 0.10589116692490408, 0.1032699262483957, 0.08963959219748063, 0.08975651710680344, 0.10108499527013659, 0.09196430606281569, 0.087017555003718, 0.09515561255218419, 0.08950201785486245, 0.09004189900107795, 0.08425322283908077, 0.9422406949352691, 0.9433086573391383, 0.9703321306715395, 0.9331827232489784, 0.9195484499935498, 0.9591235018926786, 0.9509986193324821, 0.9730242893377619, 0.9389140432492129, 0.3528831042783015, 0.36731293026926437, 0.3696874537347312, 0.37771034549502625, 0.3366397107284792, 0.3580732123738961, 0.3815627016238107, 0.3574597068540636, 0.3572630315728009, 0.6438127089797783, 0.6394258191332831, 0.5602401632456759, 0.6193822687953531, 0.6436672334608058, 0.6525122543660753, 0.6347016861344785, 0.6147008185234284, 0.6749795357566231, 0.17506923632689408, 0.1936526803929698, 0.16508234706868785, 0.19110298977276108, 0.19403720792156942, 0.208140473620975, 0.32434122880445815, 0.1985030891121613, 0.20586772211259885, 0.4167476604148713, 0.2020680257282471, 0.2891622316534951, 0.16623280539585739, 0.1852319821431916, 0.19043127981739327, 0.2056927281801203, 0.1810810543834105, 0.19946847238749976, 0.2477673825225304, 0.26418822020828125, 0.28268416098091065, 0.285827225974043, 0.2773613057032118, 0.188773959728881, 0.27981425517015457, 0.30265163075710144, 0.24810912730055534, 0.4066560079555027, 0.3499015692329147, 0.3650236849998547, 0.3979698736491353, 0.33797371123289377, 0.37439555511423783, 0.40052815887111914, 0.43079029490133947, 0.3737425207672007, 0.09701464740184274, 0.0894324774946581, 0.09983427158218694, 0.13472239029603572, 0.11642803065301288, 0.12966639440225192, 0.087758135565705, 0.10473685963941937, 0.10379002174616381, 0.22437111858363712, 0.24553293597322068, 0.2144652259866502, 0.26552190901665884, 0.25537105190918685, 0.24840110870161358, 0.24535058270163368, 0.21384298862942808, 0.22907387397129308, 0.5884618146606102, 0.5867976141560072, 0.6066141450750275, 0.5716074026778855, 0.6019445645761137, 0.5924653240725618, 0.5978889438907456, 0.5555938238341418, 0.597262810740798, 0.09009334896015553, 0.08861525457028441, 0.09164868700359219, 0.11163222938480599, 0.0934407244375911, 0.09356074410747606, 0.10939628036665294, 0.07961687934678852, 0.08254215061390457, 0.16762049476224672, 0.16036355398778868, 0.16143480860624493, 0.17887322863222976, 0.18252668339842326, 0.1990710867165847, 0.17751008518028666, 0.17665327058597413, 0.1805291896326231, 0.35792073248886314, 0.359882777675385, 0.35946586638892053, 0.33129099109316384, 0.36748811786171254, 0.3536487202734797, 0.3881048011042082, 0.3757826235749724, 0.37124349130847345, 0.26184998217733435, 0.2779939151655274, 0.289484162015998, 0.2666061674353709, 0.25516634468174504, 0.27087548699762487, 0.2713926361687682, 0.27883912262846533, 0.29313907603873035, 0.18879765714740238, 0.18021154114001858, 0.17299995695223047, 0.20190749341392822, 0.19373337008636105, 0.1944086463788257, 0.20485669752197178, 0.19377016201383623, 0.20456540036620208, 0.20900102494516182, 0.19805746184984585, 0.19096154567347734, 0.18460546893788143, 0.1969971707242144, 0.18435695792586582, 0.2004587245841042, 0.1807199401086378, 0.1897370361032712, 0.7729256214372398, 0.1660480540086583, 0.741581655383842, 0.6508397162037352, 0.468030139366688, 0.5593108175693271, 0.6059660170216032, 0.5612402270838825, 0.6313077798179025, 0.6373432126912961, 0.21057684436025736, 0.555084825263708, 0.58965711453779, 0.20892621194061467, 0.5987323016595096, 0.21041146656458332, 0.20974796311522448, 0.20912280833717034, 0.19485223308098742, 0.19120036704835464, 0.1876457421544644, 0.17179599986957128, 0.19202530144522956, 0.17554171264851992, 0.19125976217298912, 0.18617855925794513, 0.19471502538714358, 0.07908637111615457, 0.07368576916892267, 0.08700480035958169, 0.0833944918566254, 0.07803286149322008, 0.07076553503613592, 0.07791515250978842, 0.06956739599265638, 0.08135547831575585]}, "mutation_prompt": null}
{"id": "7eea0e23-6239-492a-9847-069405f79f30", "solution": "import numpy as np\n\nclass DEALS_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.sin(np.pi * evals / self.budget)  # Changed cosine to sine\n        self.dynamic_CR = lambda evals: 0.6 + 0.3 * np.cos(np.pi * evals / self.budget)  # Added dynamic crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                current_F = self.dynamic_F(eval_count)\n                current_CR = self.dynamic_CR(eval_count)  # Use dynamic crossover rate\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant, current_CR)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c + 0.5 * (np.random.rand() - 0.5))  # Added random factor for diversity\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant, CR):\n        crossover_mask = np.random.rand(self.dim) < CR  # Use dynamic CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS_Enhanced", "description": "Optimized DEALS by refining mutation and crossover strategies, and adding diversity through dynamic crossover rate.", "configspace": "", "generation": 22, "fitness": 0.2238737717185088, "feedback": "The algorithm DEALS_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "c459969f-50d7-4e3e-ac01-563d3a467525", "metadata": {"aucs": [0.5015734657694235, 0.4921763043516697, 0.48719126704913673, 0.5044666534835898, 0.49678897747487694, 0.49306943522055635, 0.48173474825031204, 0.47880810618501224, 0.48173693763331726, 0.10621615443562515, 0.0945735482849861, 0.09521047350382128, 0.09446202858913089, 0.10855556469122762, 0.10153740711189607, 0.10429352764269628, 0.09089777794487108, 0.11206758017825791, 0.11557495595969836, 0.12017312835082761, 0.10960433765477084, 0.11568528344237927, 0.12461228207949648, 0.11713824997555478, 0.1120642853005347, 0.11772639976836796, 0.1362928542920765, 0.09751727171049274, 0.10621873611297683, 0.11136154966983103, 0.1210447476675004, 0.11154102224697982, 0.11004612825711246, 0.1141721176688385, 0.1152134606576003, 0.11228712007805386, 0.9237329213157783, 0.9083357563297787, 0.9072135077162133, 0.9330536280806375, 0.911927196256946, 0.9163422779589472, 0.9616079550518726, 0.9664476487002225, 0.9078346379588008, 0.2750209245805706, 0.273625705939188, 0.26212038029522433, 0.25809418329609757, 0.2574419889548114, 0.2530525839452512, 0.2693269436753156, 0.27297563528455304, 0.2555729681361294, 0.31322041706395565, 0.28625910858239667, 0.2861962678550485, 0.3466781591106869, 0.3189558408881563, 0.3005136090150351, 0.330109772575239, 0.31478386718121076, 0.32229854499641786, 0.16844424272466563, 0.16744849159267539, 0.1704171314836478, 0.1515099410449393, 0.15638765171673985, 0.15031602528950438, 0.1565307714697476, 0.18426597860196903, 0.16906720361823468, 0.16620077893460616, 0.11502475683453683, 0.14446731788472045, 0.16070428374918122, 0.14109044852979546, 0.17327581113937573, 0.14632930469351613, 0.15567770600517616, 0.14529676870689656, 0.015255916590629748, 0.0022917869997145512, 0.0031219460191102, 0.022187309714203685, 0.011649633532059278, 0.0009370940669725103, 0.02407075246355128, 0.003637890794695675, 0.010367104776185965, 0.1258390034707385, 0.09986806179573249, 0.09809229119412188, 0.07577916073420454, 0.08501436683449592, 0.11540563799893466, 0.09513247663239399, 0.19408232155920213, 0.1053454216721651, 9.999999999998899e-05, 0.012972443187003746, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09061453765729788, 0.10321857853799743, 0.11598676485882553, 0.10153948536431745, 0.11209587998868631, 0.10539632907941143, 0.10609024395099009, 0.0997397847057131, 0.09415917410870589, 0.40809114441145666, 0.4119180678261404, 0.41719361560988477, 0.4268140735649427, 0.4242266513450911, 0.41491692545554426, 0.4227685334829735, 0.4089657799603139, 0.44086637621793956, 0.09107165244330917, 0.10230518944975198, 0.08973649449553689, 0.09303460055057222, 0.09877845850388989, 0.11184979069455803, 0.10980084814954283, 0.08401331910423482, 0.10068921368914485, 0.17740521692780387, 0.15690937990514398, 0.20327435303382413, 0.2139336262883258, 0.15288080418372996, 0.1777444415948849, 0.18828285041485837, 0.16392400477624158, 0.19658580078122534, 0.2809144374445133, 0.2637651710323444, 0.29802462971575117, 0.25410099688698606, 0.2686611546743801, 0.27620339631827606, 0.2910592465213263, 0.28997780967209663, 0.285627146917415, 0.21583050008434357, 0.2082228323225851, 0.21264040946328677, 0.19720477573336803, 0.20509921883197224, 0.19869173191356804, 0.22808242265512157, 0.22956837604150537, 0.2213774762274069, 0.19082900785771995, 0.18947378488147548, 0.18783104732017197, 0.18710264675358035, 0.20563097146344933, 0.19939478954624756, 0.19639071226051186, 0.19401236611248973, 0.20195635006264667, 0.19628531135002814, 0.19544553222769245, 0.21154799267112345, 0.19833499656097953, 0.19230253771949146, 0.19224579915417284, 0.19948537409719858, 0.1863202208739122, 0.19523612303815963, 0.18240864240157617, 0.3244176928665816, 0.1826141193627403, 0.42913100738365717, 0.6209727960026841, 0.44635310380693705, 0.48407097160307233, 0.26777262371714716, 0.4815531611188353, 0.504565533213962, 0.34682136647723616, 0.33263190063223247, 0.40078126066711917, 0.16497643996566635, 0.19857538582734657, 0.20927631030138572, 0.21116675525623463, 0.21278768085555433, 0.1840654004717348, 0.18263359245368105, 0.1877456176573422, 0.20609014268835757, 0.18138990669098043, 0.17842430416583122, 0.17045171116176439, 0.18572269827055576, 0.18951458428493884, 0.07984095130468682, 0.0705595096006939, 0.07644466927160898, 0.07698772635245588, 0.07491843367515161, 0.0780877225406672, 0.07480009682056477, 0.07231862562427582, 0.07348140568850503]}, "mutation_prompt": null}
{"id": "6b84a5d5-046d-471e-b3bc-d27d5ab83310", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) using an enhanced dynamic mutation factor for improved convergence speed.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c459969f-50d7-4e3e-ac01-563d3a467525", "metadata": {"aucs": [0.6938020557061727, 0.6981896661863495, 0.6832572940694606, 0.7118201728758551, 0.7129978187803072, 0.7173963547599209, 0.6864217748144283, 0.702758150094549, 0.7044217309543193, 0.5128095982732479, 0.5171731757544356, 0.4890688084835998, 0.4863608326326545, 0.4873512782714371, 0.48929177690773273, 0.5062501959066199, 0.49714217269784733, 0.506742858219779, 0.08992500281273785, 0.1061396298697369, 0.09711102230545965, 0.10870244394188178, 0.11253883223376959, 0.10271409065771875, 0.1100942190128078, 0.10589116692490408, 0.1032699262483957, 0.08963959219748063, 0.08975651710680344, 0.10108499527013659, 0.09196430606281569, 0.087017555003718, 0.09515561255218419, 0.08950201785486245, 0.09004189900107795, 0.08425322283908077, 0.9422406949352691, 0.9433086573391383, 0.9703321306715395, 0.9331827232489784, 0.9195484499935498, 0.9591235018926786, 0.9509986193324821, 0.9730242893377619, 0.9389140432492129, 0.3528831042783015, 0.36731293026926437, 0.3696874537347312, 0.37771034549502625, 0.3366397107284792, 0.3580732123738961, 0.3815627016238107, 0.3574597068540636, 0.3572630315728009, 0.6438127089797783, 0.6394258191332831, 0.5602401632456759, 0.6193822687953531, 0.6436672334608058, 0.6525122543660753, 0.6347016861344785, 0.6147008185234284, 0.6749795357566231, 0.17506923632689408, 0.1936526803929698, 0.16508234706868785, 0.19110298977276108, 0.19403720792156942, 0.208140473620975, 0.32434122880445815, 0.1985030891121613, 0.20586772211259885, 0.4167476604148713, 0.2020680257282471, 0.2891622316534951, 0.16623280539585739, 0.1852319821431916, 0.19043127981739327, 0.2056927281801203, 0.1810810543834105, 0.19946847238749976, 0.2477673825225304, 0.26418822020828125, 0.28268416098091065, 0.285827225974043, 0.2773613057032118, 0.188773959728881, 0.27981425517015457, 0.30265163075710144, 0.24810912730055534, 0.4066560079555027, 0.3499015692329147, 0.3650236849998547, 0.3979698736491353, 0.33797371123289377, 0.37439555511423783, 0.40052815887111914, 0.43079029490133947, 0.3737425207672007, 0.09701464740184274, 0.0894324774946581, 0.09983427158218694, 0.13472239029603572, 0.11642803065301288, 0.12966639440225192, 0.087758135565705, 0.10473685963941937, 0.10379002174616381, 0.22437111858363712, 0.24553293597322068, 0.2144652259866502, 0.26552190901665884, 0.25537105190918685, 0.24840110870161358, 0.24535058270163368, 0.21384298862942808, 0.22907387397129308, 0.5884618146606102, 0.5867976141560072, 0.6066141450750275, 0.5716074026778855, 0.6019445645761137, 0.5924653240725618, 0.5978889438907456, 0.5555938238341418, 0.597262810740798, 0.09009334896015553, 0.08861525457028441, 0.09164868700359219, 0.11163222938480599, 0.0934407244375911, 0.09356074410747606, 0.10939628036665294, 0.07961687934678852, 0.08254215061390457, 0.16762049476224672, 0.16036355398778868, 0.16143480860624493, 0.17887322863222976, 0.18252668339842326, 0.1990710867165847, 0.17751008518028666, 0.17665327058597413, 0.1805291896326231, 0.35792073248886314, 0.359882777675385, 0.35946586638892053, 0.33129099109316384, 0.36748811786171254, 0.3536487202734797, 0.3881048011042082, 0.3757826235749724, 0.37124349130847345, 0.26184998217733435, 0.2779939151655274, 0.289484162015998, 0.2666061674353709, 0.25516634468174504, 0.27087548699762487, 0.2713926361687682, 0.27883912262846533, 0.29313907603873035, 0.18879765714740238, 0.18021154114001858, 0.17299995695223047, 0.20190749341392822, 0.19373337008636105, 0.1944086463788257, 0.20485669752197178, 0.19377016201383623, 0.20456540036620208, 0.20900102494516182, 0.19805746184984585, 0.19096154567347734, 0.18460546893788143, 0.1969971707242144, 0.18435695792586582, 0.2004587245841042, 0.1807199401086378, 0.1897370361032712, 0.7729256214372398, 0.1660480540086583, 0.741581655383842, 0.6508397162037352, 0.468030139366688, 0.5593108175693271, 0.6059660170216032, 0.5612402270838825, 0.6313077798179025, 0.6373432126912961, 0.21057684436025736, 0.555084825263708, 0.58965711453779, 0.20892621194061467, 0.5987323016595096, 0.21041146656458332, 0.20974796311522448, 0.20912280833717034, 0.19485223308098742, 0.19120036704835464, 0.1876457421544644, 0.17179599986957128, 0.19202530144522956, 0.17554171264851992, 0.19125976217298912, 0.18617855925794513, 0.19471502538714358, 0.07908637111615457, 0.07368576916892267, 0.08700480035958169, 0.0833944918566254, 0.07803286149322008, 0.07076553503613592, 0.07791515250978842, 0.06956739599265638, 0.08135547831575585]}, "mutation_prompt": null}
{"id": "2db8a451-cdb1-441a-9910-70de5c2e59b3", "solution": "import numpy as np\n\nclass EnhancedDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Initial crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n        self.dynamic_CR = lambda evals: 0.9 - 0.3 * np.sin(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                current_F = self.dynamic_F(eval_count)\n                current_CR = self.dynamic_CR(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant, current_CR)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant, CR):\n        crossover_mask = np.random.rand(self.dim) < CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.03\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "EnhancedDEALS", "description": "Enhanced DEALS with adaptive crossover probability and dynamic step size for improved convergence.", "configspace": "", "generation": 24, "fitness": 0.26375124120220805, "feedback": "The algorithm EnhancedDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "c459969f-50d7-4e3e-ac01-563d3a467525", "metadata": {"aucs": [0.6944159774166669, 0.6996763787430031, 0.7117909130319598, 0.7157178970766631, 0.7171808597289484, 0.7149893988154676, 0.7026894269628152, 0.6940361982655084, 0.7003393517337444, 0.5232841610601822, 0.5031883721616214, 0.5041032080423556, 0.49339191212991773, 0.5127540950842921, 0.48280187535178876, 0.4896969962605946, 0.5119328917419446, 0.4979897478537888, 0.12480412521970552, 0.1254237199863314, 0.12170865818257348, 0.1609757499479607, 0.1322852236056249, 0.13078170036702208, 0.1361261370784803, 0.13804990567312103, 0.12566082731111183, 0.11391557371026428, 0.11203463289059379, 0.11899675105851859, 0.11805289817429343, 0.12541083561610067, 0.12246437818124378, 0.10623542644839457, 0.104983275602761, 0.11317868240981932, 0.9343091531039043, 0.9534617920551053, 0.942053617601132, 0.9256125037353368, 0.9013498221167077, 0.9616519555131535, 0.9511127980211422, 0.9297006592891459, 0.9464952010959096, 0.34331052432426845, 0.31470307463873726, 0.30860248923798395, 0.31799939340330663, 0.33472051428041383, 0.3126093788419987, 0.31556931969737934, 0.2949791914914105, 0.2803083718162501, 0.40638167791800583, 0.44238062804009637, 0.37181836759392384, 0.4689348886048583, 0.46475364094027516, 0.43413888215525753, 0.5772080143147655, 0.36016200848569946, 0.4160610495500877, 0.14964330152359984, 0.14128743639875885, 0.16028943993147693, 0.17861441954531887, 0.16018745801691003, 0.1631069305184486, 0.16918306669389316, 0.16206684710257324, 0.1573809007091217, 0.11397627317752834, 0.11529114270396879, 0.1433082687809316, 0.16425721188535758, 0.15516044894549452, 0.14862299958677871, 0.18998791928037262, 0.17153998632931233, 0.16564090377312568, 0.011378530558939337, 0.030782619219404284, 0.0563554888838127, 0.01592266988879132, 0.021609175830919813, 0.009904195079962874, 0.02056937692392491, 0.01349763502912571, 0.020838411593085082, 0.13533991268065404, 0.11633969859463344, 0.11123803142429856, 0.1134792554472448, 0.14076598729624934, 0.07492887922246483, 0.17252682076806924, 0.16163881139661385, 0.14633534854980046, 0.01676162430598238, 0.007324073030480216, 0.003456722030629633, 0.0050021769989815335, 0.03265973189814664, 0.010793832571502349, 0.028517165482776052, 0.009809193515554537, 0.019907914938941618, 0.1203605014809549, 0.12084328069963046, 0.10074040724131372, 0.1292087382243915, 0.13636650531359773, 0.12699528377990177, 0.11565016306377074, 0.12731461640711073, 0.1123285423259498, 0.47060106989038863, 0.48592630685256233, 0.4884120526295319, 0.4856032853434171, 0.49766879193071134, 0.47836722536087906, 0.4788675544908497, 0.4715186965932161, 0.5083349384086336, 0.10881086616867708, 0.09842605087005396, 0.07997979224685059, 0.09426505133567098, 0.08272442207377606, 0.1004808940344204, 0.0845031615151951, 0.08792063776205539, 0.11124651010374442, 0.16075238071967202, 0.16672654495950612, 0.2447294895191069, 0.21112856282162973, 0.17948416290381175, 0.17370071022160116, 0.25649882980972827, 0.20445176287527567, 0.17765650424679424, 0.2879102688058859, 0.30960893656800037, 0.30590737169871196, 0.29720684100896644, 0.28831085655793576, 0.2878248898650827, 0.3304596257663066, 0.3501616768874448, 0.33417767931297426, 0.21142408806854396, 0.19905493238288896, 0.23863312134304493, 0.19863418551347478, 0.2230428187676996, 0.2097071767460943, 0.21190144023029034, 0.2507701737447532, 0.24269867794511446, 0.19328372734429944, 0.19867535860475805, 0.183944484616114, 0.217945162478143, 0.1857357928407738, 0.1810134194609423, 0.18277941819849963, 0.20028681907552837, 0.21468285303875578, 0.21637234003037042, 0.2164692020725062, 0.21360547279886877, 0.19732684340371387, 0.24055521175725014, 0.20064342510103939, 0.21249302600241904, 0.19730024561456294, 0.18787689287941112, 0.5860740127571502, 0.1971407288063568, 0.18681117593924412, 0.554385923504455, 0.19931945644583537, 0.42314321266028865, 0.22190068795152562, 0.18353457545960594, 0.2701800649857792, 0.4989510514569545, 0.2106466721874264, 0.47313103683404345, 0.23179892262990798, 0.20757878312004718, 0.2811764322632927, 0.20642563128486213, 0.3169614420781056, 0.2089320717999521, 0.19270985112588757, 0.18368873903665062, 0.1969399453443249, 0.1836701163466835, 0.18811432114518734, 0.17391791068039752, 0.18825931855271394, 0.17151629566128845, 0.18166954789779544, 0.07945132623456197, 0.08716405821232998, 0.07828780876103014, 0.07306897753429786, 0.07349336122857386, 0.10175905886957115, 0.07925108045195262, 0.08197006289037567, 0.07154036792753793]}, "mutation_prompt": null}
{"id": "7731df58-a014-4b94-90c9-ac3a1a2402b5", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) using an enhanced dynamic mutation factor for improved convergence speed.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c459969f-50d7-4e3e-ac01-563d3a467525", "metadata": {"aucs": [0.6938020557061727, 0.6981896661863495, 0.6832572940694606, 0.7118201728758551, 0.7129978187803072, 0.7173963547599209, 0.6864217748144283, 0.702758150094549, 0.7044217309543193, 0.5128095982732479, 0.5171731757544356, 0.4890688084835998, 0.4863608326326545, 0.4873512782714371, 0.48929177690773273, 0.5062501959066199, 0.49714217269784733, 0.506742858219779, 0.08992500281273785, 0.1061396298697369, 0.09711102230545965, 0.10870244394188178, 0.11253883223376959, 0.10271409065771875, 0.1100942190128078, 0.10589116692490408, 0.1032699262483957, 0.08963959219748063, 0.08975651710680344, 0.10108499527013659, 0.09196430606281569, 0.087017555003718, 0.09515561255218419, 0.08950201785486245, 0.09004189900107795, 0.08425322283908077, 0.9422406949352691, 0.9433086573391383, 0.9703321306715395, 0.9331827232489784, 0.9195484499935498, 0.9591235018926786, 0.9509986193324821, 0.9730242893377619, 0.9389140432492129, 0.3528831042783015, 0.36731293026926437, 0.3696874537347312, 0.37771034549502625, 0.3366397107284792, 0.3580732123738961, 0.3815627016238107, 0.3574597068540636, 0.3572630315728009, 0.6438127089797783, 0.6394258191332831, 0.5602401632456759, 0.6193822687953531, 0.6436672334608058, 0.6525122543660753, 0.6347016861344785, 0.6147008185234284, 0.6749795357566231, 0.17506923632689408, 0.1936526803929698, 0.16508234706868785, 0.19110298977276108, 0.19403720792156942, 0.208140473620975, 0.32434122880445815, 0.1985030891121613, 0.20586772211259885, 0.4167476604148713, 0.2020680257282471, 0.2891622316534951, 0.16623280539585739, 0.1852319821431916, 0.19043127981739327, 0.2056927281801203, 0.1810810543834105, 0.19946847238749976, 0.2477673825225304, 0.26418822020828125, 0.28268416098091065, 0.285827225974043, 0.2773613057032118, 0.188773959728881, 0.27981425517015457, 0.30265163075710144, 0.24810912730055534, 0.4066560079555027, 0.3499015692329147, 0.3650236849998547, 0.3979698736491353, 0.33797371123289377, 0.37439555511423783, 0.40052815887111914, 0.43079029490133947, 0.3737425207672007, 0.09701464740184274, 0.0894324774946581, 0.09983427158218694, 0.13472239029603572, 0.11642803065301288, 0.12966639440225192, 0.087758135565705, 0.10473685963941937, 0.10379002174616381, 0.22437111858363712, 0.24553293597322068, 0.2144652259866502, 0.26552190901665884, 0.25537105190918685, 0.24840110870161358, 0.24535058270163368, 0.21384298862942808, 0.22907387397129308, 0.5884618146606102, 0.5867976141560072, 0.6066141450750275, 0.5716074026778855, 0.6019445645761137, 0.5924653240725618, 0.5978889438907456, 0.5555938238341418, 0.597262810740798, 0.09009334896015553, 0.08861525457028441, 0.09164868700359219, 0.11163222938480599, 0.0934407244375911, 0.09356074410747606, 0.10939628036665294, 0.07961687934678852, 0.08254215061390457, 0.16762049476224672, 0.16036355398778868, 0.16143480860624493, 0.17887322863222976, 0.18252668339842326, 0.1990710867165847, 0.17751008518028666, 0.17665327058597413, 0.1805291896326231, 0.35792073248886314, 0.359882777675385, 0.35946586638892053, 0.33129099109316384, 0.36748811786171254, 0.3536487202734797, 0.3881048011042082, 0.3757826235749724, 0.37124349130847345, 0.26184998217733435, 0.2779939151655274, 0.289484162015998, 0.2666061674353709, 0.25516634468174504, 0.27087548699762487, 0.2713926361687682, 0.27883912262846533, 0.29313907603873035, 0.18879765714740238, 0.18021154114001858, 0.17299995695223047, 0.20190749341392822, 0.19373337008636105, 0.1944086463788257, 0.20485669752197178, 0.19377016201383623, 0.20456540036620208, 0.20900102494516182, 0.19805746184984585, 0.19096154567347734, 0.18460546893788143, 0.1969971707242144, 0.18435695792586582, 0.2004587245841042, 0.1807199401086378, 0.1897370361032712, 0.7729256214372398, 0.1660480540086583, 0.741581655383842, 0.6508397162037352, 0.468030139366688, 0.5593108175693271, 0.6059660170216032, 0.5612402270838825, 0.6313077798179025, 0.6373432126912961, 0.21057684436025736, 0.555084825263708, 0.58965711453779, 0.20892621194061467, 0.5987323016595096, 0.21041146656458332, 0.20974796311522448, 0.20912280833717034, 0.19485223308098742, 0.19120036704835464, 0.1876457421544644, 0.17179599986957128, 0.19202530144522956, 0.17554171264851992, 0.19125976217298912, 0.18617855925794513, 0.19471502538714358, 0.07908637111615457, 0.07368576916892267, 0.08700480035958169, 0.0833944918566254, 0.07803286149322008, 0.07076553503613592, 0.07791515250978842, 0.06956739599265638, 0.08135547831575585]}, "mutation_prompt": null}
{"id": "83a42580-dce4-4041-a539-6faf31ddd536", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) using an enhanced dynamic mutation factor for improved convergence speed.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c459969f-50d7-4e3e-ac01-563d3a467525", "metadata": {"aucs": [0.6938020557061727, 0.6981896661863495, 0.6832572940694606, 0.7118201728758551, 0.7129978187803072, 0.7173963547599209, 0.6864217748144283, 0.702758150094549, 0.7044217309543193, 0.5128095982732479, 0.5171731757544356, 0.4890688084835998, 0.4863608326326545, 0.4873512782714371, 0.48929177690773273, 0.5062501959066199, 0.49714217269784733, 0.506742858219779, 0.08992500281273785, 0.1061396298697369, 0.09711102230545965, 0.10870244394188178, 0.11253883223376959, 0.10271409065771875, 0.1100942190128078, 0.10589116692490408, 0.1032699262483957, 0.08963959219748063, 0.08975651710680344, 0.10108499527013659, 0.09196430606281569, 0.087017555003718, 0.09515561255218419, 0.08950201785486245, 0.09004189900107795, 0.08425322283908077, 0.9422406949352691, 0.9433086573391383, 0.9703321306715395, 0.9331827232489784, 0.9195484499935498, 0.9591235018926786, 0.9509986193324821, 0.9730242893377619, 0.9389140432492129, 0.3528831042783015, 0.36731293026926437, 0.3696874537347312, 0.37771034549502625, 0.3366397107284792, 0.3580732123738961, 0.3815627016238107, 0.3574597068540636, 0.3572630315728009, 0.6438127089797783, 0.6394258191332831, 0.5602401632456759, 0.6193822687953531, 0.6436672334608058, 0.6525122543660753, 0.6347016861344785, 0.6147008185234284, 0.6749795357566231, 0.17506923632689408, 0.1936526803929698, 0.16508234706868785, 0.19110298977276108, 0.19403720792156942, 0.208140473620975, 0.32434122880445815, 0.1985030891121613, 0.20586772211259885, 0.4167476604148713, 0.2020680257282471, 0.2891622316534951, 0.16623280539585739, 0.1852319821431916, 0.19043127981739327, 0.2056927281801203, 0.1810810543834105, 0.19946847238749976, 0.2477673825225304, 0.26418822020828125, 0.28268416098091065, 0.285827225974043, 0.2773613057032118, 0.188773959728881, 0.27981425517015457, 0.30265163075710144, 0.24810912730055534, 0.4066560079555027, 0.3499015692329147, 0.3650236849998547, 0.3979698736491353, 0.33797371123289377, 0.37439555511423783, 0.40052815887111914, 0.43079029490133947, 0.3737425207672007, 0.09701464740184274, 0.0894324774946581, 0.09983427158218694, 0.13472239029603572, 0.11642803065301288, 0.12966639440225192, 0.087758135565705, 0.10473685963941937, 0.10379002174616381, 0.22437111858363712, 0.24553293597322068, 0.2144652259866502, 0.26552190901665884, 0.25537105190918685, 0.24840110870161358, 0.24535058270163368, 0.21384298862942808, 0.22907387397129308, 0.5884618146606102, 0.5867976141560072, 0.6066141450750275, 0.5716074026778855, 0.6019445645761137, 0.5924653240725618, 0.5978889438907456, 0.5555938238341418, 0.597262810740798, 0.09009334896015553, 0.08861525457028441, 0.09164868700359219, 0.11163222938480599, 0.0934407244375911, 0.09356074410747606, 0.10939628036665294, 0.07961687934678852, 0.08254215061390457, 0.16762049476224672, 0.16036355398778868, 0.16143480860624493, 0.17887322863222976, 0.18252668339842326, 0.1990710867165847, 0.17751008518028666, 0.17665327058597413, 0.1805291896326231, 0.35792073248886314, 0.359882777675385, 0.35946586638892053, 0.33129099109316384, 0.36748811786171254, 0.3536487202734797, 0.3881048011042082, 0.3757826235749724, 0.37124349130847345, 0.26184998217733435, 0.2779939151655274, 0.289484162015998, 0.2666061674353709, 0.25516634468174504, 0.27087548699762487, 0.2713926361687682, 0.27883912262846533, 0.29313907603873035, 0.18879765714740238, 0.18021154114001858, 0.17299995695223047, 0.20190749341392822, 0.19373337008636105, 0.1944086463788257, 0.20485669752197178, 0.19377016201383623, 0.20456540036620208, 0.20900102494516182, 0.19805746184984585, 0.19096154567347734, 0.18460546893788143, 0.1969971707242144, 0.18435695792586582, 0.2004587245841042, 0.1807199401086378, 0.1897370361032712, 0.7729256214372398, 0.1660480540086583, 0.741581655383842, 0.6508397162037352, 0.468030139366688, 0.5593108175693271, 0.6059660170216032, 0.5612402270838825, 0.6313077798179025, 0.6373432126912961, 0.21057684436025736, 0.555084825263708, 0.58965711453779, 0.20892621194061467, 0.5987323016595096, 0.21041146656458332, 0.20974796311522448, 0.20912280833717034, 0.19485223308098742, 0.19120036704835464, 0.1876457421544644, 0.17179599986957128, 0.19202530144522956, 0.17554171264851992, 0.19125976217298912, 0.18617855925794513, 0.19471502538714358, 0.07908637111615457, 0.07368576916892267, 0.08700480035958169, 0.0833944918566254, 0.07803286149322008, 0.07076553503613592, 0.07791515250978842, 0.06956739599265638, 0.08135547831575585]}, "mutation_prompt": null}
{"id": "7321faf6-1976-45ba-94b3-e756575998c9", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n        self.dynamic_CR = lambda evals: 0.9 - 0.4 * np.sin(np.pi * evals / self.budget)  # Adaptive Crossover\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant, eval_count)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant, eval_count):\n        current_CR = self.dynamic_CR(eval_count)\n        crossover_mask = np.random.rand(self.dim) < current_CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.03  # Slightly smaller step size\n        for _ in range(7):  # More local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "Introducing Adaptive Crossover and Enhanced Local Search in DEALS for Improved Convergence.", "configspace": "", "generation": 27, "fitness": 0.2570026045836607, "feedback": "The algorithm DEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "c459969f-50d7-4e3e-ac01-563d3a467525", "metadata": {"aucs": [0.6980503399840895, 0.693953353488771, 0.6995945992638593, 0.7043286387656907, 0.7152595885421014, 0.6996927944181146, 0.7085284554495441, 0.70327490733799, 0.7169309936657182, 0.5018198359439187, 0.4693535755789703, 0.48795720144320187, 0.47214377334793656, 0.48850692276293306, 0.48769299817280054, 0.4658909254020803, 0.5255702264668924, 0.5330779215052628, 0.17074810748700697, 0.21720960459886107, 0.15972611502697276, 0.18961524945749786, 0.14934271966141555, 0.14624423330276748, 0.16229035617967658, 0.16439513734574307, 0.17051902099362537, 0.1380202296129599, 0.12690418496371403, 0.13370750583254898, 0.15397281108530192, 0.12800331147653088, 0.12046210157714299, 0.11895487035866481, 0.12055316631868918, 0.12444512225163928, 0.9456675678888175, 0.9555691130554368, 0.930690097352242, 0.941652231547887, 0.941596504059559, 0.9303695954018685, 0.9352357916082888, 0.9705058761852771, 0.9415377029415307, 0.3097514798561416, 0.2784805703873552, 0.3066182475614644, 0.28181704424530585, 0.30783521682812676, 0.32063097583289524, 0.27345614931798157, 0.2815230933559143, 0.272948993208861, 0.2789789152270703, 0.3687273271355124, 0.3283675664625326, 0.3387670929939198, 0.3380929470832469, 0.36732849815059565, 0.30538547487029755, 0.3086296865598771, 0.4996500144316999, 0.16836297495829422, 0.14215669983698698, 0.1470767723208155, 0.17750367444739423, 0.1609746279293589, 0.153741042530103, 0.1603424608542997, 0.194254439926006, 0.17891077561014568, 0.17324160556951507, 0.11400557681243861, 0.17595829117553297, 0.1747160087333658, 0.1730969963422363, 0.20577513650682333, 0.15604462170799593, 0.13974832291552552, 0.14824519516880796, 0.0006107224606166639, 0.009339571918362877, 0.0007185315137921977, 0.01337222293400886, 0.007323647425260371, 0.013354379693210294, 0.00012975604766851667, 0.03781594502424834, 0.032986063883810535, 0.08897989108956739, 0.07790589980095775, 0.07442657235387051, 0.05704663611876404, 0.09398926060493196, 0.10798444586195655, 0.11461400070268624, 0.10450042272460958, 0.09847810136638291, 0.00013892633743672889, 0.00014173166049147312, 0.008078479148935558, 0.0016273194039299055, 9.999999999998899e-05, 0.0005348021908990752, 0.002885623893281397, 0.013007256297453917, 0.023201487245893437, 0.09700300629394643, 0.11125824454876387, 0.10051348096073853, 0.11138585159812142, 0.11077385333722944, 0.13065031366448243, 0.0990475856431614, 0.10023167125541355, 0.11684442332059175, 0.45591014165250476, 0.4801887910898266, 0.4833900624647782, 0.47305040960437794, 0.4571717170628904, 0.4666747535053478, 0.4466454605255461, 0.43750211178091003, 0.4581832396210679, 0.11211185121468903, 0.09160170788628874, 0.08712147143746829, 0.10401035055484864, 0.09608456263443299, 0.10194671459329419, 0.0940578163702569, 0.10820891921350939, 0.10918366517622757, 0.21576458663824283, 0.22396722307486894, 0.16043627575942188, 0.1520420258874634, 0.21773023047130502, 0.20266691547348636, 0.17141736023694087, 0.19209009082946682, 0.1389834013989799, 0.2935681644638398, 0.28818640814951, 0.2960471701078682, 0.26508658652662087, 0.2678180797252261, 0.27466978745008364, 0.30929327304722787, 0.3209779874896036, 0.3193418336129499, 0.18460252594726578, 0.20354941755824218, 0.21996128555215033, 0.1900296992573295, 0.19913927434648815, 0.19760583616050664, 0.20078776308004354, 0.2149477096610688, 0.21847120620697313, 0.19558894656727066, 0.2008994599786199, 0.20935428881566054, 0.20400842509683303, 0.1863708235152559, 0.1931400288557119, 0.1845065161656385, 0.1898572297957828, 0.18667394177976826, 0.20099305642472454, 0.21917807582031124, 0.18924974731410216, 0.21774705825014362, 0.1962861954174694, 0.21107792690255278, 0.20669551455188995, 0.204586687195649, 0.21838073120392343, 0.5487514557112423, 0.6474102566013566, 0.4790357249217799, 0.2684489230325201, 0.19879631122873287, 0.19588480788663554, 0.16202819575585692, 0.3513291610017417, 0.5603598813677957, 0.42367388863781297, 0.21186209107956833, 0.33586463749293005, 0.20684354979560715, 0.20929505596071707, 0.18058125307727024, 0.2108447029527466, 0.20348341103224443, 0.2106416260736852, 0.2027634238782835, 0.18890257453029746, 0.18242970926715574, 0.2041321483495685, 0.20743895534082457, 0.19183764479284493, 0.19172005114515678, 0.18166412307001722, 0.18992640405925998, 0.08453727971868263, 0.07787168683875911, 0.07402426285938268, 0.07376441863187122, 0.0830857715141341, 0.09300622621200905, 0.0764892077109336, 0.07928294165051608, 0.07602028444656772]}, "mutation_prompt": null}
{"id": "5b74e9e4-9914-4a23-8f20-b975c1770716", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) using an enhanced dynamic mutation factor for improved convergence speed.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c459969f-50d7-4e3e-ac01-563d3a467525", "metadata": {"aucs": [0.6938020557061727, 0.6981896661863495, 0.6832572940694606, 0.7118201728758551, 0.7129978187803072, 0.7173963547599209, 0.6864217748144283, 0.702758150094549, 0.7044217309543193, 0.5128095982732479, 0.5171731757544356, 0.4890688084835998, 0.4863608326326545, 0.4873512782714371, 0.48929177690773273, 0.5062501959066199, 0.49714217269784733, 0.506742858219779, 0.08992500281273785, 0.1061396298697369, 0.09711102230545965, 0.10870244394188178, 0.11253883223376959, 0.10271409065771875, 0.1100942190128078, 0.10589116692490408, 0.1032699262483957, 0.08963959219748063, 0.08975651710680344, 0.10108499527013659, 0.09196430606281569, 0.087017555003718, 0.09515561255218419, 0.08950201785486245, 0.09004189900107795, 0.08425322283908077, 0.9422406949352691, 0.9433086573391383, 0.9703321306715395, 0.9331827232489784, 0.9195484499935498, 0.9591235018926786, 0.9509986193324821, 0.9730242893377619, 0.9389140432492129, 0.3528831042783015, 0.36731293026926437, 0.3696874537347312, 0.37771034549502625, 0.3366397107284792, 0.3580732123738961, 0.3815627016238107, 0.3574597068540636, 0.3572630315728009, 0.6438127089797783, 0.6394258191332831, 0.5602401632456759, 0.6193822687953531, 0.6436672334608058, 0.6525122543660753, 0.6347016861344785, 0.6147008185234284, 0.6749795357566231, 0.17506923632689408, 0.1936526803929698, 0.16508234706868785, 0.19110298977276108, 0.19403720792156942, 0.208140473620975, 0.32434122880445815, 0.1985030891121613, 0.20586772211259885, 0.4167476604148713, 0.2020680257282471, 0.2891622316534951, 0.16623280539585739, 0.1852319821431916, 0.19043127981739327, 0.2056927281801203, 0.1810810543834105, 0.19946847238749976, 0.2477673825225304, 0.26418822020828125, 0.28268416098091065, 0.285827225974043, 0.2773613057032118, 0.188773959728881, 0.27981425517015457, 0.30265163075710144, 0.24810912730055534, 0.4066560079555027, 0.3499015692329147, 0.3650236849998547, 0.3979698736491353, 0.33797371123289377, 0.37439555511423783, 0.40052815887111914, 0.43079029490133947, 0.3737425207672007, 0.09701464740184274, 0.0894324774946581, 0.09983427158218694, 0.13472239029603572, 0.11642803065301288, 0.12966639440225192, 0.087758135565705, 0.10473685963941937, 0.10379002174616381, 0.22437111858363712, 0.24553293597322068, 0.2144652259866502, 0.26552190901665884, 0.25537105190918685, 0.24840110870161358, 0.24535058270163368, 0.21384298862942808, 0.22907387397129308, 0.5884618146606102, 0.5867976141560072, 0.6066141450750275, 0.5716074026778855, 0.6019445645761137, 0.5924653240725618, 0.5978889438907456, 0.5555938238341418, 0.597262810740798, 0.09009334896015553, 0.08861525457028441, 0.09164868700359219, 0.11163222938480599, 0.0934407244375911, 0.09356074410747606, 0.10939628036665294, 0.07961687934678852, 0.08254215061390457, 0.16762049476224672, 0.16036355398778868, 0.16143480860624493, 0.17887322863222976, 0.18252668339842326, 0.1990710867165847, 0.17751008518028666, 0.17665327058597413, 0.1805291896326231, 0.35792073248886314, 0.359882777675385, 0.35946586638892053, 0.33129099109316384, 0.36748811786171254, 0.3536487202734797, 0.3881048011042082, 0.3757826235749724, 0.37124349130847345, 0.26184998217733435, 0.2779939151655274, 0.289484162015998, 0.2666061674353709, 0.25516634468174504, 0.27087548699762487, 0.2713926361687682, 0.27883912262846533, 0.29313907603873035, 0.18879765714740238, 0.18021154114001858, 0.17299995695223047, 0.20190749341392822, 0.19373337008636105, 0.1944086463788257, 0.20485669752197178, 0.19377016201383623, 0.20456540036620208, 0.20900102494516182, 0.19805746184984585, 0.19096154567347734, 0.18460546893788143, 0.1969971707242144, 0.18435695792586582, 0.2004587245841042, 0.1807199401086378, 0.1897370361032712, 0.7729256214372398, 0.1660480540086583, 0.741581655383842, 0.6508397162037352, 0.468030139366688, 0.5593108175693271, 0.6059660170216032, 0.5612402270838825, 0.6313077798179025, 0.6373432126912961, 0.21057684436025736, 0.555084825263708, 0.58965711453779, 0.20892621194061467, 0.5987323016595096, 0.21041146656458332, 0.20974796311522448, 0.20912280833717034, 0.19485223308098742, 0.19120036704835464, 0.1876457421544644, 0.17179599986957128, 0.19202530144522956, 0.17554171264851992, 0.19125976217298912, 0.18617855925794513, 0.19471502538714358, 0.07908637111615457, 0.07368576916892267, 0.08700480035958169, 0.0833944918566254, 0.07803286149322008, 0.07076553503613592, 0.07791515250978842, 0.06956739599265638, 0.08135547831575585]}, "mutation_prompt": null}
{"id": "95e3f5ea-20ee-48dc-a0c1-1bb4a2b28f46", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) using an enhanced dynamic mutation factor for improved convergence speed.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c459969f-50d7-4e3e-ac01-563d3a467525", "metadata": {"aucs": [0.6938020557061727, 0.6981896661863495, 0.6832572940694606, 0.7118201728758551, 0.7129978187803072, 0.7173963547599209, 0.6864217748144283, 0.702758150094549, 0.7044217309543193, 0.5128095982732479, 0.5171731757544356, 0.4890688084835998, 0.4863608326326545, 0.4873512782714371, 0.48929177690773273, 0.5062501959066199, 0.49714217269784733, 0.506742858219779, 0.08992500281273785, 0.1061396298697369, 0.09711102230545965, 0.10870244394188178, 0.11253883223376959, 0.10271409065771875, 0.1100942190128078, 0.10589116692490408, 0.1032699262483957, 0.08963959219748063, 0.08975651710680344, 0.10108499527013659, 0.09196430606281569, 0.087017555003718, 0.09515561255218419, 0.08950201785486245, 0.09004189900107795, 0.08425322283908077, 0.9422406949352691, 0.9433086573391383, 0.9703321306715395, 0.9331827232489784, 0.9195484499935498, 0.9591235018926786, 0.9509986193324821, 0.9730242893377619, 0.9389140432492129, 0.3528831042783015, 0.36731293026926437, 0.3696874537347312, 0.37771034549502625, 0.3366397107284792, 0.3580732123738961, 0.3815627016238107, 0.3574597068540636, 0.3572630315728009, 0.6438127089797783, 0.6394258191332831, 0.5602401632456759, 0.6193822687953531, 0.6436672334608058, 0.6525122543660753, 0.6347016861344785, 0.6147008185234284, 0.6749795357566231, 0.17506923632689408, 0.1936526803929698, 0.16508234706868785, 0.19110298977276108, 0.19403720792156942, 0.208140473620975, 0.32434122880445815, 0.1985030891121613, 0.20586772211259885, 0.4167476604148713, 0.2020680257282471, 0.2891622316534951, 0.16623280539585739, 0.1852319821431916, 0.19043127981739327, 0.2056927281801203, 0.1810810543834105, 0.19946847238749976, 0.2477673825225304, 0.26418822020828125, 0.28268416098091065, 0.285827225974043, 0.2773613057032118, 0.188773959728881, 0.27981425517015457, 0.30265163075710144, 0.24810912730055534, 0.4066560079555027, 0.3499015692329147, 0.3650236849998547, 0.3979698736491353, 0.33797371123289377, 0.37439555511423783, 0.40052815887111914, 0.43079029490133947, 0.3737425207672007, 0.09701464740184274, 0.0894324774946581, 0.09983427158218694, 0.13472239029603572, 0.11642803065301288, 0.12966639440225192, 0.087758135565705, 0.10473685963941937, 0.10379002174616381, 0.22437111858363712, 0.24553293597322068, 0.2144652259866502, 0.26552190901665884, 0.25537105190918685, 0.24840110870161358, 0.24535058270163368, 0.21384298862942808, 0.22907387397129308, 0.5884618146606102, 0.5867976141560072, 0.6066141450750275, 0.5716074026778855, 0.6019445645761137, 0.5924653240725618, 0.5978889438907456, 0.5555938238341418, 0.597262810740798, 0.09009334896015553, 0.08861525457028441, 0.09164868700359219, 0.11163222938480599, 0.0934407244375911, 0.09356074410747606, 0.10939628036665294, 0.07961687934678852, 0.08254215061390457, 0.16762049476224672, 0.16036355398778868, 0.16143480860624493, 0.17887322863222976, 0.18252668339842326, 0.1990710867165847, 0.17751008518028666, 0.17665327058597413, 0.1805291896326231, 0.35792073248886314, 0.359882777675385, 0.35946586638892053, 0.33129099109316384, 0.36748811786171254, 0.3536487202734797, 0.3881048011042082, 0.3757826235749724, 0.37124349130847345, 0.26184998217733435, 0.2779939151655274, 0.289484162015998, 0.2666061674353709, 0.25516634468174504, 0.27087548699762487, 0.2713926361687682, 0.27883912262846533, 0.29313907603873035, 0.18879765714740238, 0.18021154114001858, 0.17299995695223047, 0.20190749341392822, 0.19373337008636105, 0.1944086463788257, 0.20485669752197178, 0.19377016201383623, 0.20456540036620208, 0.20900102494516182, 0.19805746184984585, 0.19096154567347734, 0.18460546893788143, 0.1969971707242144, 0.18435695792586582, 0.2004587245841042, 0.1807199401086378, 0.1897370361032712, 0.7729256214372398, 0.1660480540086583, 0.741581655383842, 0.6508397162037352, 0.468030139366688, 0.5593108175693271, 0.6059660170216032, 0.5612402270838825, 0.6313077798179025, 0.6373432126912961, 0.21057684436025736, 0.555084825263708, 0.58965711453779, 0.20892621194061467, 0.5987323016595096, 0.21041146656458332, 0.20974796311522448, 0.20912280833717034, 0.19485223308098742, 0.19120036704835464, 0.1876457421544644, 0.17179599986957128, 0.19202530144522956, 0.17554171264851992, 0.19125976217298912, 0.18617855925794513, 0.19471502538714358, 0.07908637111615457, 0.07368576916892267, 0.08700480035958169, 0.0833944918566254, 0.07803286149322008, 0.07076553503613592, 0.07791515250978842, 0.06956739599265638, 0.08135547831575585]}, "mutation_prompt": null}
{"id": "b027f079-fa65-4220-8456-7f685edacb5c", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) using an enhanced dynamic mutation factor for improved convergence speed.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c459969f-50d7-4e3e-ac01-563d3a467525", "metadata": {"aucs": [0.6938020557061727, 0.6981896661863495, 0.6832572940694606, 0.7118201728758551, 0.7129978187803072, 0.7173963547599209, 0.6864217748144283, 0.702758150094549, 0.7044217309543193, 0.5128095982732479, 0.5171731757544356, 0.4890688084835998, 0.4863608326326545, 0.4873512782714371, 0.48929177690773273, 0.5062501959066199, 0.49714217269784733, 0.506742858219779, 0.08992500281273785, 0.1061396298697369, 0.09711102230545965, 0.10870244394188178, 0.11253883223376959, 0.10271409065771875, 0.1100942190128078, 0.10589116692490408, 0.1032699262483957, 0.08963959219748063, 0.08975651710680344, 0.10108499527013659, 0.09196430606281569, 0.087017555003718, 0.09515561255218419, 0.08950201785486245, 0.09004189900107795, 0.08425322283908077, 0.9422406949352691, 0.9433086573391383, 0.9703321306715395, 0.9331827232489784, 0.9195484499935498, 0.9591235018926786, 0.9509986193324821, 0.9730242893377619, 0.9389140432492129, 0.3528831042783015, 0.36731293026926437, 0.3696874537347312, 0.37771034549502625, 0.3366397107284792, 0.3580732123738961, 0.3815627016238107, 0.3574597068540636, 0.3572630315728009, 0.6438127089797783, 0.6394258191332831, 0.5602401632456759, 0.6193822687953531, 0.6436672334608058, 0.6525122543660753, 0.6347016861344785, 0.6147008185234284, 0.6749795357566231, 0.17506923632689408, 0.1936526803929698, 0.16508234706868785, 0.19110298977276108, 0.19403720792156942, 0.208140473620975, 0.32434122880445815, 0.1985030891121613, 0.20586772211259885, 0.4167476604148713, 0.2020680257282471, 0.2891622316534951, 0.16623280539585739, 0.1852319821431916, 0.19043127981739327, 0.2056927281801203, 0.1810810543834105, 0.19946847238749976, 0.2477673825225304, 0.26418822020828125, 0.28268416098091065, 0.285827225974043, 0.2773613057032118, 0.188773959728881, 0.27981425517015457, 0.30265163075710144, 0.24810912730055534, 0.4066560079555027, 0.3499015692329147, 0.3650236849998547, 0.3979698736491353, 0.33797371123289377, 0.37439555511423783, 0.40052815887111914, 0.43079029490133947, 0.3737425207672007, 0.09701464740184274, 0.0894324774946581, 0.09983427158218694, 0.13472239029603572, 0.11642803065301288, 0.12966639440225192, 0.087758135565705, 0.10473685963941937, 0.10379002174616381, 0.22437111858363712, 0.24553293597322068, 0.2144652259866502, 0.26552190901665884, 0.25537105190918685, 0.24840110870161358, 0.24535058270163368, 0.21384298862942808, 0.22907387397129308, 0.5884618146606102, 0.5867976141560072, 0.6066141450750275, 0.5716074026778855, 0.6019445645761137, 0.5924653240725618, 0.5978889438907456, 0.5555938238341418, 0.597262810740798, 0.09009334896015553, 0.08861525457028441, 0.09164868700359219, 0.11163222938480599, 0.0934407244375911, 0.09356074410747606, 0.10939628036665294, 0.07961687934678852, 0.08254215061390457, 0.16762049476224672, 0.16036355398778868, 0.16143480860624493, 0.17887322863222976, 0.18252668339842326, 0.1990710867165847, 0.17751008518028666, 0.17665327058597413, 0.1805291896326231, 0.35792073248886314, 0.359882777675385, 0.35946586638892053, 0.33129099109316384, 0.36748811786171254, 0.3536487202734797, 0.3881048011042082, 0.3757826235749724, 0.37124349130847345, 0.26184998217733435, 0.2779939151655274, 0.289484162015998, 0.2666061674353709, 0.25516634468174504, 0.27087548699762487, 0.2713926361687682, 0.27883912262846533, 0.29313907603873035, 0.18879765714740238, 0.18021154114001858, 0.17299995695223047, 0.20190749341392822, 0.19373337008636105, 0.1944086463788257, 0.20485669752197178, 0.19377016201383623, 0.20456540036620208, 0.20900102494516182, 0.19805746184984585, 0.19096154567347734, 0.18460546893788143, 0.1969971707242144, 0.18435695792586582, 0.2004587245841042, 0.1807199401086378, 0.1897370361032712, 0.7729256214372398, 0.1660480540086583, 0.741581655383842, 0.6508397162037352, 0.468030139366688, 0.5593108175693271, 0.6059660170216032, 0.5612402270838825, 0.6313077798179025, 0.6373432126912961, 0.21057684436025736, 0.555084825263708, 0.58965711453779, 0.20892621194061467, 0.5987323016595096, 0.21041146656458332, 0.20974796311522448, 0.20912280833717034, 0.19485223308098742, 0.19120036704835464, 0.1876457421544644, 0.17179599986957128, 0.19202530144522956, 0.17554171264851992, 0.19125976217298912, 0.18617855925794513, 0.19471502538714358, 0.07908637111615457, 0.07368576916892267, 0.08700480035958169, 0.0833944918566254, 0.07803286149322008, 0.07076553503613592, 0.07791515250978842, 0.06956739599265638, 0.08135547831575585]}, "mutation_prompt": null}
{"id": "07e4176a-8065-4110-9365-0c8fad5f54f8", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) using an enhanced dynamic mutation factor for improved convergence speed.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c459969f-50d7-4e3e-ac01-563d3a467525", "metadata": {"aucs": [0.6938020557061727, 0.6981896661863495, 0.6832572940694606, 0.7118201728758551, 0.7129978187803072, 0.7173963547599209, 0.6864217748144283, 0.702758150094549, 0.7044217309543193, 0.5128095982732479, 0.5171731757544356, 0.4890688084835998, 0.4863608326326545, 0.4873512782714371, 0.48929177690773273, 0.5062501959066199, 0.49714217269784733, 0.506742858219779, 0.08992500281273785, 0.1061396298697369, 0.09711102230545965, 0.10870244394188178, 0.11253883223376959, 0.10271409065771875, 0.1100942190128078, 0.10589116692490408, 0.1032699262483957, 0.08963959219748063, 0.08975651710680344, 0.10108499527013659, 0.09196430606281569, 0.087017555003718, 0.09515561255218419, 0.08950201785486245, 0.09004189900107795, 0.08425322283908077, 0.9422406949352691, 0.9433086573391383, 0.9703321306715395, 0.9331827232489784, 0.9195484499935498, 0.9591235018926786, 0.9509986193324821, 0.9730242893377619, 0.9389140432492129, 0.3528831042783015, 0.36731293026926437, 0.3696874537347312, 0.37771034549502625, 0.3366397107284792, 0.3580732123738961, 0.3815627016238107, 0.3574597068540636, 0.3572630315728009, 0.6438127089797783, 0.6394258191332831, 0.5602401632456759, 0.6193822687953531, 0.6436672334608058, 0.6525122543660753, 0.6347016861344785, 0.6147008185234284, 0.6749795357566231, 0.17506923632689408, 0.1936526803929698, 0.16508234706868785, 0.19110298977276108, 0.19403720792156942, 0.208140473620975, 0.32434122880445815, 0.1985030891121613, 0.20586772211259885, 0.4167476604148713, 0.2020680257282471, 0.2891622316534951, 0.16623280539585739, 0.1852319821431916, 0.19043127981739327, 0.2056927281801203, 0.1810810543834105, 0.19946847238749976, 0.2477673825225304, 0.26418822020828125, 0.28268416098091065, 0.285827225974043, 0.2773613057032118, 0.188773959728881, 0.27981425517015457, 0.30265163075710144, 0.24810912730055534, 0.4066560079555027, 0.3499015692329147, 0.3650236849998547, 0.3979698736491353, 0.33797371123289377, 0.37439555511423783, 0.40052815887111914, 0.43079029490133947, 0.3737425207672007, 0.09701464740184274, 0.0894324774946581, 0.09983427158218694, 0.13472239029603572, 0.11642803065301288, 0.12966639440225192, 0.087758135565705, 0.10473685963941937, 0.10379002174616381, 0.22437111858363712, 0.24553293597322068, 0.2144652259866502, 0.26552190901665884, 0.25537105190918685, 0.24840110870161358, 0.24535058270163368, 0.21384298862942808, 0.22907387397129308, 0.5884618146606102, 0.5867976141560072, 0.6066141450750275, 0.5716074026778855, 0.6019445645761137, 0.5924653240725618, 0.5978889438907456, 0.5555938238341418, 0.597262810740798, 0.09009334896015553, 0.08861525457028441, 0.09164868700359219, 0.11163222938480599, 0.0934407244375911, 0.09356074410747606, 0.10939628036665294, 0.07961687934678852, 0.08254215061390457, 0.16762049476224672, 0.16036355398778868, 0.16143480860624493, 0.17887322863222976, 0.18252668339842326, 0.1990710867165847, 0.17751008518028666, 0.17665327058597413, 0.1805291896326231, 0.35792073248886314, 0.359882777675385, 0.35946586638892053, 0.33129099109316384, 0.36748811786171254, 0.3536487202734797, 0.3881048011042082, 0.3757826235749724, 0.37124349130847345, 0.26184998217733435, 0.2779939151655274, 0.289484162015998, 0.2666061674353709, 0.25516634468174504, 0.27087548699762487, 0.2713926361687682, 0.27883912262846533, 0.29313907603873035, 0.18879765714740238, 0.18021154114001858, 0.17299995695223047, 0.20190749341392822, 0.19373337008636105, 0.1944086463788257, 0.20485669752197178, 0.19377016201383623, 0.20456540036620208, 0.20900102494516182, 0.19805746184984585, 0.19096154567347734, 0.18460546893788143, 0.1969971707242144, 0.18435695792586582, 0.2004587245841042, 0.1807199401086378, 0.1897370361032712, 0.7729256214372398, 0.1660480540086583, 0.741581655383842, 0.6508397162037352, 0.468030139366688, 0.5593108175693271, 0.6059660170216032, 0.5612402270838825, 0.6313077798179025, 0.6373432126912961, 0.21057684436025736, 0.555084825263708, 0.58965711453779, 0.20892621194061467, 0.5987323016595096, 0.21041146656458332, 0.20974796311522448, 0.20912280833717034, 0.19485223308098742, 0.19120036704835464, 0.1876457421544644, 0.17179599986957128, 0.19202530144522956, 0.17554171264851992, 0.19125976217298912, 0.18617855925794513, 0.19471502538714358, 0.07908637111615457, 0.07368576916892267, 0.08700480035958169, 0.0833944918566254, 0.07803286149322008, 0.07076553503613592, 0.07791515250978842, 0.06956739599265638, 0.08135547831575585]}, "mutation_prompt": null}
{"id": "a145eaf3-8f9b-4df5-814c-133f96a84361", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) using an enhanced dynamic mutation factor for improved convergence speed.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c459969f-50d7-4e3e-ac01-563d3a467525", "metadata": {"aucs": [0.6938020557061727, 0.6981896661863495, 0.6832572940694606, 0.7118201728758551, 0.7129978187803072, 0.7173963547599209, 0.6864217748144283, 0.702758150094549, 0.7044217309543193, 0.5128095982732479, 0.5171731757544356, 0.4890688084835998, 0.4863608326326545, 0.4873512782714371, 0.48929177690773273, 0.5062501959066199, 0.49714217269784733, 0.506742858219779, 0.08992500281273785, 0.1061396298697369, 0.09711102230545965, 0.10870244394188178, 0.11253883223376959, 0.10271409065771875, 0.1100942190128078, 0.10589116692490408, 0.1032699262483957, 0.08963959219748063, 0.08975651710680344, 0.10108499527013659, 0.09196430606281569, 0.087017555003718, 0.09515561255218419, 0.08950201785486245, 0.09004189900107795, 0.08425322283908077, 0.9422406949352691, 0.9433086573391383, 0.9703321306715395, 0.9331827232489784, 0.9195484499935498, 0.9591235018926786, 0.9509986193324821, 0.9730242893377619, 0.9389140432492129, 0.3528831042783015, 0.36731293026926437, 0.3696874537347312, 0.37771034549502625, 0.3366397107284792, 0.3580732123738961, 0.3815627016238107, 0.3574597068540636, 0.3572630315728009, 0.6438127089797783, 0.6394258191332831, 0.5602401632456759, 0.6193822687953531, 0.6436672334608058, 0.6525122543660753, 0.6347016861344785, 0.6147008185234284, 0.6749795357566231, 0.17506923632689408, 0.1936526803929698, 0.16508234706868785, 0.19110298977276108, 0.19403720792156942, 0.208140473620975, 0.32434122880445815, 0.1985030891121613, 0.20586772211259885, 0.4167476604148713, 0.2020680257282471, 0.2891622316534951, 0.16623280539585739, 0.1852319821431916, 0.19043127981739327, 0.2056927281801203, 0.1810810543834105, 0.19946847238749976, 0.2477673825225304, 0.26418822020828125, 0.28268416098091065, 0.285827225974043, 0.2773613057032118, 0.188773959728881, 0.27981425517015457, 0.30265163075710144, 0.24810912730055534, 0.4066560079555027, 0.3499015692329147, 0.3650236849998547, 0.3979698736491353, 0.33797371123289377, 0.37439555511423783, 0.40052815887111914, 0.43079029490133947, 0.3737425207672007, 0.09701464740184274, 0.0894324774946581, 0.09983427158218694, 0.13472239029603572, 0.11642803065301288, 0.12966639440225192, 0.087758135565705, 0.10473685963941937, 0.10379002174616381, 0.22437111858363712, 0.24553293597322068, 0.2144652259866502, 0.26552190901665884, 0.25537105190918685, 0.24840110870161358, 0.24535058270163368, 0.21384298862942808, 0.22907387397129308, 0.5884618146606102, 0.5867976141560072, 0.6066141450750275, 0.5716074026778855, 0.6019445645761137, 0.5924653240725618, 0.5978889438907456, 0.5555938238341418, 0.597262810740798, 0.09009334896015553, 0.08861525457028441, 0.09164868700359219, 0.11163222938480599, 0.0934407244375911, 0.09356074410747606, 0.10939628036665294, 0.07961687934678852, 0.08254215061390457, 0.16762049476224672, 0.16036355398778868, 0.16143480860624493, 0.17887322863222976, 0.18252668339842326, 0.1990710867165847, 0.17751008518028666, 0.17665327058597413, 0.1805291896326231, 0.35792073248886314, 0.359882777675385, 0.35946586638892053, 0.33129099109316384, 0.36748811786171254, 0.3536487202734797, 0.3881048011042082, 0.3757826235749724, 0.37124349130847345, 0.26184998217733435, 0.2779939151655274, 0.289484162015998, 0.2666061674353709, 0.25516634468174504, 0.27087548699762487, 0.2713926361687682, 0.27883912262846533, 0.29313907603873035, 0.18879765714740238, 0.18021154114001858, 0.17299995695223047, 0.20190749341392822, 0.19373337008636105, 0.1944086463788257, 0.20485669752197178, 0.19377016201383623, 0.20456540036620208, 0.20900102494516182, 0.19805746184984585, 0.19096154567347734, 0.18460546893788143, 0.1969971707242144, 0.18435695792586582, 0.2004587245841042, 0.1807199401086378, 0.1897370361032712, 0.7729256214372398, 0.1660480540086583, 0.741581655383842, 0.6508397162037352, 0.468030139366688, 0.5593108175693271, 0.6059660170216032, 0.5612402270838825, 0.6313077798179025, 0.6373432126912961, 0.21057684436025736, 0.555084825263708, 0.58965711453779, 0.20892621194061467, 0.5987323016595096, 0.21041146656458332, 0.20974796311522448, 0.20912280833717034, 0.19485223308098742, 0.19120036704835464, 0.1876457421544644, 0.17179599986957128, 0.19202530144522956, 0.17554171264851992, 0.19125976217298912, 0.18617855925794513, 0.19471502538714358, 0.07908637111615457, 0.07368576916892267, 0.08700480035958169, 0.0833944918566254, 0.07803286149322008, 0.07076553503613592, 0.07791515250978842, 0.06956739599265638, 0.08135547831575585]}, "mutation_prompt": null}
{"id": "c4812387-812d-493b-942a-7a204cb65ab0", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) using an enhanced dynamic mutation factor for improved convergence speed.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c459969f-50d7-4e3e-ac01-563d3a467525", "metadata": {"aucs": [0.6938020557061727, 0.6981896661863495, 0.6832572940694606, 0.7118201728758551, 0.7129978187803072, 0.7173963547599209, 0.6864217748144283, 0.702758150094549, 0.7044217309543193, 0.5128095982732479, 0.5171731757544356, 0.4890688084835998, 0.4863608326326545, 0.4873512782714371, 0.48929177690773273, 0.5062501959066199, 0.49714217269784733, 0.506742858219779, 0.08992500281273785, 0.1061396298697369, 0.09711102230545965, 0.10870244394188178, 0.11253883223376959, 0.10271409065771875, 0.1100942190128078, 0.10589116692490408, 0.1032699262483957, 0.08963959219748063, 0.08975651710680344, 0.10108499527013659, 0.09196430606281569, 0.087017555003718, 0.09515561255218419, 0.08950201785486245, 0.09004189900107795, 0.08425322283908077, 0.9422406949352691, 0.9433086573391383, 0.9703321306715395, 0.9331827232489784, 0.9195484499935498, 0.9591235018926786, 0.9509986193324821, 0.9730242893377619, 0.9389140432492129, 0.3528831042783015, 0.36731293026926437, 0.3696874537347312, 0.37771034549502625, 0.3366397107284792, 0.3580732123738961, 0.3815627016238107, 0.3574597068540636, 0.3572630315728009, 0.6438127089797783, 0.6394258191332831, 0.5602401632456759, 0.6193822687953531, 0.6436672334608058, 0.6525122543660753, 0.6347016861344785, 0.6147008185234284, 0.6749795357566231, 0.17506923632689408, 0.1936526803929698, 0.16508234706868785, 0.19110298977276108, 0.19403720792156942, 0.208140473620975, 0.32434122880445815, 0.1985030891121613, 0.20586772211259885, 0.4167476604148713, 0.2020680257282471, 0.2891622316534951, 0.16623280539585739, 0.1852319821431916, 0.19043127981739327, 0.2056927281801203, 0.1810810543834105, 0.19946847238749976, 0.2477673825225304, 0.26418822020828125, 0.28268416098091065, 0.285827225974043, 0.2773613057032118, 0.188773959728881, 0.27981425517015457, 0.30265163075710144, 0.24810912730055534, 0.4066560079555027, 0.3499015692329147, 0.3650236849998547, 0.3979698736491353, 0.33797371123289377, 0.37439555511423783, 0.40052815887111914, 0.43079029490133947, 0.3737425207672007, 0.09701464740184274, 0.0894324774946581, 0.09983427158218694, 0.13472239029603572, 0.11642803065301288, 0.12966639440225192, 0.087758135565705, 0.10473685963941937, 0.10379002174616381, 0.22437111858363712, 0.24553293597322068, 0.2144652259866502, 0.26552190901665884, 0.25537105190918685, 0.24840110870161358, 0.24535058270163368, 0.21384298862942808, 0.22907387397129308, 0.5884618146606102, 0.5867976141560072, 0.6066141450750275, 0.5716074026778855, 0.6019445645761137, 0.5924653240725618, 0.5978889438907456, 0.5555938238341418, 0.597262810740798, 0.09009334896015553, 0.08861525457028441, 0.09164868700359219, 0.11163222938480599, 0.0934407244375911, 0.09356074410747606, 0.10939628036665294, 0.07961687934678852, 0.08254215061390457, 0.16762049476224672, 0.16036355398778868, 0.16143480860624493, 0.17887322863222976, 0.18252668339842326, 0.1990710867165847, 0.17751008518028666, 0.17665327058597413, 0.1805291896326231, 0.35792073248886314, 0.359882777675385, 0.35946586638892053, 0.33129099109316384, 0.36748811786171254, 0.3536487202734797, 0.3881048011042082, 0.3757826235749724, 0.37124349130847345, 0.26184998217733435, 0.2779939151655274, 0.289484162015998, 0.2666061674353709, 0.25516634468174504, 0.27087548699762487, 0.2713926361687682, 0.27883912262846533, 0.29313907603873035, 0.18879765714740238, 0.18021154114001858, 0.17299995695223047, 0.20190749341392822, 0.19373337008636105, 0.1944086463788257, 0.20485669752197178, 0.19377016201383623, 0.20456540036620208, 0.20900102494516182, 0.19805746184984585, 0.19096154567347734, 0.18460546893788143, 0.1969971707242144, 0.18435695792586582, 0.2004587245841042, 0.1807199401086378, 0.1897370361032712, 0.7729256214372398, 0.1660480540086583, 0.741581655383842, 0.6508397162037352, 0.468030139366688, 0.5593108175693271, 0.6059660170216032, 0.5612402270838825, 0.6313077798179025, 0.6373432126912961, 0.21057684436025736, 0.555084825263708, 0.58965711453779, 0.20892621194061467, 0.5987323016595096, 0.21041146656458332, 0.20974796311522448, 0.20912280833717034, 0.19485223308098742, 0.19120036704835464, 0.1876457421544644, 0.17179599986957128, 0.19202530144522956, 0.17554171264851992, 0.19125976217298912, 0.18617855925794513, 0.19471502538714358, 0.07908637111615457, 0.07368576916892267, 0.08700480035958169, 0.0833944918566254, 0.07803286149322008, 0.07076553503613592, 0.07791515250978842, 0.06956739599265638, 0.08135547831575585]}, "mutation_prompt": null}
{"id": "fcbff6f3-ac7d-46fe-98d2-a2402ed81689", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) using an enhanced dynamic mutation factor for improved convergence speed.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c459969f-50d7-4e3e-ac01-563d3a467525", "metadata": {"aucs": [0.6938020557061727, 0.6981896661863495, 0.6832572940694606, 0.7118201728758551, 0.7129978187803072, 0.7173963547599209, 0.6864217748144283, 0.702758150094549, 0.7044217309543193, 0.5128095982732479, 0.5171731757544356, 0.4890688084835998, 0.4863608326326545, 0.4873512782714371, 0.48929177690773273, 0.5062501959066199, 0.49714217269784733, 0.506742858219779, 0.08992500281273785, 0.1061396298697369, 0.09711102230545965, 0.10870244394188178, 0.11253883223376959, 0.10271409065771875, 0.1100942190128078, 0.10589116692490408, 0.1032699262483957, 0.08963959219748063, 0.08975651710680344, 0.10108499527013659, 0.09196430606281569, 0.087017555003718, 0.09515561255218419, 0.08950201785486245, 0.09004189900107795, 0.08425322283908077, 0.9422406949352691, 0.9433086573391383, 0.9703321306715395, 0.9331827232489784, 0.9195484499935498, 0.9591235018926786, 0.9509986193324821, 0.9730242893377619, 0.9389140432492129, 0.3528831042783015, 0.36731293026926437, 0.3696874537347312, 0.37771034549502625, 0.3366397107284792, 0.3580732123738961, 0.3815627016238107, 0.3574597068540636, 0.3572630315728009, 0.6438127089797783, 0.6394258191332831, 0.5602401632456759, 0.6193822687953531, 0.6436672334608058, 0.6525122543660753, 0.6347016861344785, 0.6147008185234284, 0.6749795357566231, 0.17506923632689408, 0.1936526803929698, 0.16508234706868785, 0.19110298977276108, 0.19403720792156942, 0.208140473620975, 0.32434122880445815, 0.1985030891121613, 0.20586772211259885, 0.4167476604148713, 0.2020680257282471, 0.2891622316534951, 0.16623280539585739, 0.1852319821431916, 0.19043127981739327, 0.2056927281801203, 0.1810810543834105, 0.19946847238749976, 0.2477673825225304, 0.26418822020828125, 0.28268416098091065, 0.285827225974043, 0.2773613057032118, 0.188773959728881, 0.27981425517015457, 0.30265163075710144, 0.24810912730055534, 0.4066560079555027, 0.3499015692329147, 0.3650236849998547, 0.3979698736491353, 0.33797371123289377, 0.37439555511423783, 0.40052815887111914, 0.43079029490133947, 0.3737425207672007, 0.09701464740184274, 0.0894324774946581, 0.09983427158218694, 0.13472239029603572, 0.11642803065301288, 0.12966639440225192, 0.087758135565705, 0.10473685963941937, 0.10379002174616381, 0.22437111858363712, 0.24553293597322068, 0.2144652259866502, 0.26552190901665884, 0.25537105190918685, 0.24840110870161358, 0.24535058270163368, 0.21384298862942808, 0.22907387397129308, 0.5884618146606102, 0.5867976141560072, 0.6066141450750275, 0.5716074026778855, 0.6019445645761137, 0.5924653240725618, 0.5978889438907456, 0.5555938238341418, 0.597262810740798, 0.09009334896015553, 0.08861525457028441, 0.09164868700359219, 0.11163222938480599, 0.0934407244375911, 0.09356074410747606, 0.10939628036665294, 0.07961687934678852, 0.08254215061390457, 0.16762049476224672, 0.16036355398778868, 0.16143480860624493, 0.17887322863222976, 0.18252668339842326, 0.1990710867165847, 0.17751008518028666, 0.17665327058597413, 0.1805291896326231, 0.35792073248886314, 0.359882777675385, 0.35946586638892053, 0.33129099109316384, 0.36748811786171254, 0.3536487202734797, 0.3881048011042082, 0.3757826235749724, 0.37124349130847345, 0.26184998217733435, 0.2779939151655274, 0.289484162015998, 0.2666061674353709, 0.25516634468174504, 0.27087548699762487, 0.2713926361687682, 0.27883912262846533, 0.29313907603873035, 0.18879765714740238, 0.18021154114001858, 0.17299995695223047, 0.20190749341392822, 0.19373337008636105, 0.1944086463788257, 0.20485669752197178, 0.19377016201383623, 0.20456540036620208, 0.20900102494516182, 0.19805746184984585, 0.19096154567347734, 0.18460546893788143, 0.1969971707242144, 0.18435695792586582, 0.2004587245841042, 0.1807199401086378, 0.1897370361032712, 0.7729256214372398, 0.1660480540086583, 0.741581655383842, 0.6508397162037352, 0.468030139366688, 0.5593108175693271, 0.6059660170216032, 0.5612402270838825, 0.6313077798179025, 0.6373432126912961, 0.21057684436025736, 0.555084825263708, 0.58965711453779, 0.20892621194061467, 0.5987323016595096, 0.21041146656458332, 0.20974796311522448, 0.20912280833717034, 0.19485223308098742, 0.19120036704835464, 0.1876457421544644, 0.17179599986957128, 0.19202530144522956, 0.17554171264851992, 0.19125976217298912, 0.18617855925794513, 0.19471502538714358, 0.07908637111615457, 0.07368576916892267, 0.08700480035958169, 0.0833944918566254, 0.07803286149322008, 0.07076553503613592, 0.07791515250978842, 0.06956739599265638, 0.08135547831575585]}, "mutation_prompt": null}
{"id": "1328be34-8e22-467b-819a-ab0ef828807b", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) using an enhanced dynamic mutation factor for improved convergence speed.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c459969f-50d7-4e3e-ac01-563d3a467525", "metadata": {"aucs": [0.6938020557061727, 0.6981896661863495, 0.6832572940694606, 0.7118201728758551, 0.7129978187803072, 0.7173963547599209, 0.6864217748144283, 0.702758150094549, 0.7044217309543193, 0.5128095982732479, 0.5171731757544356, 0.4890688084835998, 0.4863608326326545, 0.4873512782714371, 0.48929177690773273, 0.5062501959066199, 0.49714217269784733, 0.506742858219779, 0.08992500281273785, 0.1061396298697369, 0.09711102230545965, 0.10870244394188178, 0.11253883223376959, 0.10271409065771875, 0.1100942190128078, 0.10589116692490408, 0.1032699262483957, 0.08963959219748063, 0.08975651710680344, 0.10108499527013659, 0.09196430606281569, 0.087017555003718, 0.09515561255218419, 0.08950201785486245, 0.09004189900107795, 0.08425322283908077, 0.9422406949352691, 0.9433086573391383, 0.9703321306715395, 0.9331827232489784, 0.9195484499935498, 0.9591235018926786, 0.9509986193324821, 0.9730242893377619, 0.9389140432492129, 0.3528831042783015, 0.36731293026926437, 0.3696874537347312, 0.37771034549502625, 0.3366397107284792, 0.3580732123738961, 0.3815627016238107, 0.3574597068540636, 0.3572630315728009, 0.6438127089797783, 0.6394258191332831, 0.5602401632456759, 0.6193822687953531, 0.6436672334608058, 0.6525122543660753, 0.6347016861344785, 0.6147008185234284, 0.6749795357566231, 0.17506923632689408, 0.1936526803929698, 0.16508234706868785, 0.19110298977276108, 0.19403720792156942, 0.208140473620975, 0.32434122880445815, 0.1985030891121613, 0.20586772211259885, 0.4167476604148713, 0.2020680257282471, 0.2891622316534951, 0.16623280539585739, 0.1852319821431916, 0.19043127981739327, 0.2056927281801203, 0.1810810543834105, 0.19946847238749976, 0.2477673825225304, 0.26418822020828125, 0.28268416098091065, 0.285827225974043, 0.2773613057032118, 0.188773959728881, 0.27981425517015457, 0.30265163075710144, 0.24810912730055534, 0.4066560079555027, 0.3499015692329147, 0.3650236849998547, 0.3979698736491353, 0.33797371123289377, 0.37439555511423783, 0.40052815887111914, 0.43079029490133947, 0.3737425207672007, 0.09701464740184274, 0.0894324774946581, 0.09983427158218694, 0.13472239029603572, 0.11642803065301288, 0.12966639440225192, 0.087758135565705, 0.10473685963941937, 0.10379002174616381, 0.22437111858363712, 0.24553293597322068, 0.2144652259866502, 0.26552190901665884, 0.25537105190918685, 0.24840110870161358, 0.24535058270163368, 0.21384298862942808, 0.22907387397129308, 0.5884618146606102, 0.5867976141560072, 0.6066141450750275, 0.5716074026778855, 0.6019445645761137, 0.5924653240725618, 0.5978889438907456, 0.5555938238341418, 0.597262810740798, 0.09009334896015553, 0.08861525457028441, 0.09164868700359219, 0.11163222938480599, 0.0934407244375911, 0.09356074410747606, 0.10939628036665294, 0.07961687934678852, 0.08254215061390457, 0.16762049476224672, 0.16036355398778868, 0.16143480860624493, 0.17887322863222976, 0.18252668339842326, 0.1990710867165847, 0.17751008518028666, 0.17665327058597413, 0.1805291896326231, 0.35792073248886314, 0.359882777675385, 0.35946586638892053, 0.33129099109316384, 0.36748811786171254, 0.3536487202734797, 0.3881048011042082, 0.3757826235749724, 0.37124349130847345, 0.26184998217733435, 0.2779939151655274, 0.289484162015998, 0.2666061674353709, 0.25516634468174504, 0.27087548699762487, 0.2713926361687682, 0.27883912262846533, 0.29313907603873035, 0.18879765714740238, 0.18021154114001858, 0.17299995695223047, 0.20190749341392822, 0.19373337008636105, 0.1944086463788257, 0.20485669752197178, 0.19377016201383623, 0.20456540036620208, 0.20900102494516182, 0.19805746184984585, 0.19096154567347734, 0.18460546893788143, 0.1969971707242144, 0.18435695792586582, 0.2004587245841042, 0.1807199401086378, 0.1897370361032712, 0.7729256214372398, 0.1660480540086583, 0.741581655383842, 0.6508397162037352, 0.468030139366688, 0.5593108175693271, 0.6059660170216032, 0.5612402270838825, 0.6313077798179025, 0.6373432126912961, 0.21057684436025736, 0.555084825263708, 0.58965711453779, 0.20892621194061467, 0.5987323016595096, 0.21041146656458332, 0.20974796311522448, 0.20912280833717034, 0.19485223308098742, 0.19120036704835464, 0.1876457421544644, 0.17179599986957128, 0.19202530144522956, 0.17554171264851992, 0.19125976217298912, 0.18617855925794513, 0.19471502538714358, 0.07908637111615457, 0.07368576916892267, 0.08700480035958169, 0.0833944918566254, 0.07803286149322008, 0.07076553503613592, 0.07791515250978842, 0.06956739599265638, 0.08135547831575585]}, "mutation_prompt": null}
{"id": "0b798a13-5fc9-40e6-9187-4db80d34b89e", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) using an enhanced dynamic mutation factor for improved convergence speed.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c459969f-50d7-4e3e-ac01-563d3a467525", "metadata": {"aucs": [0.6938020557061727, 0.6981896661863495, 0.6832572940694606, 0.7118201728758551, 0.7129978187803072, 0.7173963547599209, 0.6864217748144283, 0.702758150094549, 0.7044217309543193, 0.5128095982732479, 0.5171731757544356, 0.4890688084835998, 0.4863608326326545, 0.4873512782714371, 0.48929177690773273, 0.5062501959066199, 0.49714217269784733, 0.506742858219779, 0.08992500281273785, 0.1061396298697369, 0.09711102230545965, 0.10870244394188178, 0.11253883223376959, 0.10271409065771875, 0.1100942190128078, 0.10589116692490408, 0.1032699262483957, 0.08963959219748063, 0.08975651710680344, 0.10108499527013659, 0.09196430606281569, 0.087017555003718, 0.09515561255218419, 0.08950201785486245, 0.09004189900107795, 0.08425322283908077, 0.9422406949352691, 0.9433086573391383, 0.9703321306715395, 0.9331827232489784, 0.9195484499935498, 0.9591235018926786, 0.9509986193324821, 0.9730242893377619, 0.9389140432492129, 0.3528831042783015, 0.36731293026926437, 0.3696874537347312, 0.37771034549502625, 0.3366397107284792, 0.3580732123738961, 0.3815627016238107, 0.3574597068540636, 0.3572630315728009, 0.6438127089797783, 0.6394258191332831, 0.5602401632456759, 0.6193822687953531, 0.6436672334608058, 0.6525122543660753, 0.6347016861344785, 0.6147008185234284, 0.6749795357566231, 0.17506923632689408, 0.1936526803929698, 0.16508234706868785, 0.19110298977276108, 0.19403720792156942, 0.208140473620975, 0.32434122880445815, 0.1985030891121613, 0.20586772211259885, 0.4167476604148713, 0.2020680257282471, 0.2891622316534951, 0.16623280539585739, 0.1852319821431916, 0.19043127981739327, 0.2056927281801203, 0.1810810543834105, 0.19946847238749976, 0.2477673825225304, 0.26418822020828125, 0.28268416098091065, 0.285827225974043, 0.2773613057032118, 0.188773959728881, 0.27981425517015457, 0.30265163075710144, 0.24810912730055534, 0.4066560079555027, 0.3499015692329147, 0.3650236849998547, 0.3979698736491353, 0.33797371123289377, 0.37439555511423783, 0.40052815887111914, 0.43079029490133947, 0.3737425207672007, 0.09701464740184274, 0.0894324774946581, 0.09983427158218694, 0.13472239029603572, 0.11642803065301288, 0.12966639440225192, 0.087758135565705, 0.10473685963941937, 0.10379002174616381, 0.22437111858363712, 0.24553293597322068, 0.2144652259866502, 0.26552190901665884, 0.25537105190918685, 0.24840110870161358, 0.24535058270163368, 0.21384298862942808, 0.22907387397129308, 0.5884618146606102, 0.5867976141560072, 0.6066141450750275, 0.5716074026778855, 0.6019445645761137, 0.5924653240725618, 0.5978889438907456, 0.5555938238341418, 0.597262810740798, 0.09009334896015553, 0.08861525457028441, 0.09164868700359219, 0.11163222938480599, 0.0934407244375911, 0.09356074410747606, 0.10939628036665294, 0.07961687934678852, 0.08254215061390457, 0.16762049476224672, 0.16036355398778868, 0.16143480860624493, 0.17887322863222976, 0.18252668339842326, 0.1990710867165847, 0.17751008518028666, 0.17665327058597413, 0.1805291896326231, 0.35792073248886314, 0.359882777675385, 0.35946586638892053, 0.33129099109316384, 0.36748811786171254, 0.3536487202734797, 0.3881048011042082, 0.3757826235749724, 0.37124349130847345, 0.26184998217733435, 0.2779939151655274, 0.289484162015998, 0.2666061674353709, 0.25516634468174504, 0.27087548699762487, 0.2713926361687682, 0.27883912262846533, 0.29313907603873035, 0.18879765714740238, 0.18021154114001858, 0.17299995695223047, 0.20190749341392822, 0.19373337008636105, 0.1944086463788257, 0.20485669752197178, 0.19377016201383623, 0.20456540036620208, 0.20900102494516182, 0.19805746184984585, 0.19096154567347734, 0.18460546893788143, 0.1969971707242144, 0.18435695792586582, 0.2004587245841042, 0.1807199401086378, 0.1897370361032712, 0.7729256214372398, 0.1660480540086583, 0.741581655383842, 0.6508397162037352, 0.468030139366688, 0.5593108175693271, 0.6059660170216032, 0.5612402270838825, 0.6313077798179025, 0.6373432126912961, 0.21057684436025736, 0.555084825263708, 0.58965711453779, 0.20892621194061467, 0.5987323016595096, 0.21041146656458332, 0.20974796311522448, 0.20912280833717034, 0.19485223308098742, 0.19120036704835464, 0.1876457421544644, 0.17179599986957128, 0.19202530144522956, 0.17554171264851992, 0.19125976217298912, 0.18617855925794513, 0.19471502538714358, 0.07908637111615457, 0.07368576916892267, 0.08700480035958169, 0.0833944918566254, 0.07803286149322008, 0.07076553503613592, 0.07791515250978842, 0.06956739599265638, 0.08135547831575585]}, "mutation_prompt": null}
{"id": "115f2798-439c-46a8-8c3e-df1448590280", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) using an enhanced dynamic mutation factor for improved convergence speed.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c459969f-50d7-4e3e-ac01-563d3a467525", "metadata": {"aucs": [0.6938020557061727, 0.6981896661863495, 0.6832572940694606, 0.7118201728758551, 0.7129978187803072, 0.7173963547599209, 0.6864217748144283, 0.702758150094549, 0.7044217309543193, 0.5128095982732479, 0.5171731757544356, 0.4890688084835998, 0.4863608326326545, 0.4873512782714371, 0.48929177690773273, 0.5062501959066199, 0.49714217269784733, 0.506742858219779, 0.08992500281273785, 0.1061396298697369, 0.09711102230545965, 0.10870244394188178, 0.11253883223376959, 0.10271409065771875, 0.1100942190128078, 0.10589116692490408, 0.1032699262483957, 0.08963959219748063, 0.08975651710680344, 0.10108499527013659, 0.09196430606281569, 0.087017555003718, 0.09515561255218419, 0.08950201785486245, 0.09004189900107795, 0.08425322283908077, 0.9422406949352691, 0.9433086573391383, 0.9703321306715395, 0.9331827232489784, 0.9195484499935498, 0.9591235018926786, 0.9509986193324821, 0.9730242893377619, 0.9389140432492129, 0.3528831042783015, 0.36731293026926437, 0.3696874537347312, 0.37771034549502625, 0.3366397107284792, 0.3580732123738961, 0.3815627016238107, 0.3574597068540636, 0.3572630315728009, 0.6438127089797783, 0.6394258191332831, 0.5602401632456759, 0.6193822687953531, 0.6436672334608058, 0.6525122543660753, 0.6347016861344785, 0.6147008185234284, 0.6749795357566231, 0.17506923632689408, 0.1936526803929698, 0.16508234706868785, 0.19110298977276108, 0.19403720792156942, 0.208140473620975, 0.32434122880445815, 0.1985030891121613, 0.20586772211259885, 0.4167476604148713, 0.2020680257282471, 0.2891622316534951, 0.16623280539585739, 0.1852319821431916, 0.19043127981739327, 0.2056927281801203, 0.1810810543834105, 0.19946847238749976, 0.2477673825225304, 0.26418822020828125, 0.28268416098091065, 0.285827225974043, 0.2773613057032118, 0.188773959728881, 0.27981425517015457, 0.30265163075710144, 0.24810912730055534, 0.4066560079555027, 0.3499015692329147, 0.3650236849998547, 0.3979698736491353, 0.33797371123289377, 0.37439555511423783, 0.40052815887111914, 0.43079029490133947, 0.3737425207672007, 0.09701464740184274, 0.0894324774946581, 0.09983427158218694, 0.13472239029603572, 0.11642803065301288, 0.12966639440225192, 0.087758135565705, 0.10473685963941937, 0.10379002174616381, 0.22437111858363712, 0.24553293597322068, 0.2144652259866502, 0.26552190901665884, 0.25537105190918685, 0.24840110870161358, 0.24535058270163368, 0.21384298862942808, 0.22907387397129308, 0.5884618146606102, 0.5867976141560072, 0.6066141450750275, 0.5716074026778855, 0.6019445645761137, 0.5924653240725618, 0.5978889438907456, 0.5555938238341418, 0.597262810740798, 0.09009334896015553, 0.08861525457028441, 0.09164868700359219, 0.11163222938480599, 0.0934407244375911, 0.09356074410747606, 0.10939628036665294, 0.07961687934678852, 0.08254215061390457, 0.16762049476224672, 0.16036355398778868, 0.16143480860624493, 0.17887322863222976, 0.18252668339842326, 0.1990710867165847, 0.17751008518028666, 0.17665327058597413, 0.1805291896326231, 0.35792073248886314, 0.359882777675385, 0.35946586638892053, 0.33129099109316384, 0.36748811786171254, 0.3536487202734797, 0.3881048011042082, 0.3757826235749724, 0.37124349130847345, 0.26184998217733435, 0.2779939151655274, 0.289484162015998, 0.2666061674353709, 0.25516634468174504, 0.27087548699762487, 0.2713926361687682, 0.27883912262846533, 0.29313907603873035, 0.18879765714740238, 0.18021154114001858, 0.17299995695223047, 0.20190749341392822, 0.19373337008636105, 0.1944086463788257, 0.20485669752197178, 0.19377016201383623, 0.20456540036620208, 0.20900102494516182, 0.19805746184984585, 0.19096154567347734, 0.18460546893788143, 0.1969971707242144, 0.18435695792586582, 0.2004587245841042, 0.1807199401086378, 0.1897370361032712, 0.7729256214372398, 0.1660480540086583, 0.741581655383842, 0.6508397162037352, 0.468030139366688, 0.5593108175693271, 0.6059660170216032, 0.5612402270838825, 0.6313077798179025, 0.6373432126912961, 0.21057684436025736, 0.555084825263708, 0.58965711453779, 0.20892621194061467, 0.5987323016595096, 0.21041146656458332, 0.20974796311522448, 0.20912280833717034, 0.19485223308098742, 0.19120036704835464, 0.1876457421544644, 0.17179599986957128, 0.19202530144522956, 0.17554171264851992, 0.19125976217298912, 0.18617855925794513, 0.19471502538714358, 0.07908637111615457, 0.07368576916892267, 0.08700480035958169, 0.0833944918566254, 0.07803286149322008, 0.07076553503613592, 0.07791515250978842, 0.06956739599265638, 0.08135547831575585]}, "mutation_prompt": null}
{"id": "935bfeee-048f-4fc6-aa98-e127597d534e", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) using an enhanced dynamic mutation factor for improved convergence speed.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c459969f-50d7-4e3e-ac01-563d3a467525", "metadata": {"aucs": [0.6938020557061727, 0.6981896661863495, 0.6832572940694606, 0.7118201728758551, 0.7129978187803072, 0.7173963547599209, 0.6864217748144283, 0.702758150094549, 0.7044217309543193, 0.5128095982732479, 0.5171731757544356, 0.4890688084835998, 0.4863608326326545, 0.4873512782714371, 0.48929177690773273, 0.5062501959066199, 0.49714217269784733, 0.506742858219779, 0.08992500281273785, 0.1061396298697369, 0.09711102230545965, 0.10870244394188178, 0.11253883223376959, 0.10271409065771875, 0.1100942190128078, 0.10589116692490408, 0.1032699262483957, 0.08963959219748063, 0.08975651710680344, 0.10108499527013659, 0.09196430606281569, 0.087017555003718, 0.09515561255218419, 0.08950201785486245, 0.09004189900107795, 0.08425322283908077, 0.9422406949352691, 0.9433086573391383, 0.9703321306715395, 0.9331827232489784, 0.9195484499935498, 0.9591235018926786, 0.9509986193324821, 0.9730242893377619, 0.9389140432492129, 0.3528831042783015, 0.36731293026926437, 0.3696874537347312, 0.37771034549502625, 0.3366397107284792, 0.3580732123738961, 0.3815627016238107, 0.3574597068540636, 0.3572630315728009, 0.6438127089797783, 0.6394258191332831, 0.5602401632456759, 0.6193822687953531, 0.6436672334608058, 0.6525122543660753, 0.6347016861344785, 0.6147008185234284, 0.6749795357566231, 0.17506923632689408, 0.1936526803929698, 0.16508234706868785, 0.19110298977276108, 0.19403720792156942, 0.208140473620975, 0.32434122880445815, 0.1985030891121613, 0.20586772211259885, 0.4167476604148713, 0.2020680257282471, 0.2891622316534951, 0.16623280539585739, 0.1852319821431916, 0.19043127981739327, 0.2056927281801203, 0.1810810543834105, 0.19946847238749976, 0.2477673825225304, 0.26418822020828125, 0.28268416098091065, 0.285827225974043, 0.2773613057032118, 0.188773959728881, 0.27981425517015457, 0.30265163075710144, 0.24810912730055534, 0.4066560079555027, 0.3499015692329147, 0.3650236849998547, 0.3979698736491353, 0.33797371123289377, 0.37439555511423783, 0.40052815887111914, 0.43079029490133947, 0.3737425207672007, 0.09701464740184274, 0.0894324774946581, 0.09983427158218694, 0.13472239029603572, 0.11642803065301288, 0.12966639440225192, 0.087758135565705, 0.10473685963941937, 0.10379002174616381, 0.22437111858363712, 0.24553293597322068, 0.2144652259866502, 0.26552190901665884, 0.25537105190918685, 0.24840110870161358, 0.24535058270163368, 0.21384298862942808, 0.22907387397129308, 0.5884618146606102, 0.5867976141560072, 0.6066141450750275, 0.5716074026778855, 0.6019445645761137, 0.5924653240725618, 0.5978889438907456, 0.5555938238341418, 0.597262810740798, 0.09009334896015553, 0.08861525457028441, 0.09164868700359219, 0.11163222938480599, 0.0934407244375911, 0.09356074410747606, 0.10939628036665294, 0.07961687934678852, 0.08254215061390457, 0.16762049476224672, 0.16036355398778868, 0.16143480860624493, 0.17887322863222976, 0.18252668339842326, 0.1990710867165847, 0.17751008518028666, 0.17665327058597413, 0.1805291896326231, 0.35792073248886314, 0.359882777675385, 0.35946586638892053, 0.33129099109316384, 0.36748811786171254, 0.3536487202734797, 0.3881048011042082, 0.3757826235749724, 0.37124349130847345, 0.26184998217733435, 0.2779939151655274, 0.289484162015998, 0.2666061674353709, 0.25516634468174504, 0.27087548699762487, 0.2713926361687682, 0.27883912262846533, 0.29313907603873035, 0.18879765714740238, 0.18021154114001858, 0.17299995695223047, 0.20190749341392822, 0.19373337008636105, 0.1944086463788257, 0.20485669752197178, 0.19377016201383623, 0.20456540036620208, 0.20900102494516182, 0.19805746184984585, 0.19096154567347734, 0.18460546893788143, 0.1969971707242144, 0.18435695792586582, 0.2004587245841042, 0.1807199401086378, 0.1897370361032712, 0.7729256214372398, 0.1660480540086583, 0.741581655383842, 0.6508397162037352, 0.468030139366688, 0.5593108175693271, 0.6059660170216032, 0.5612402270838825, 0.6313077798179025, 0.6373432126912961, 0.21057684436025736, 0.555084825263708, 0.58965711453779, 0.20892621194061467, 0.5987323016595096, 0.21041146656458332, 0.20974796311522448, 0.20912280833717034, 0.19485223308098742, 0.19120036704835464, 0.1876457421544644, 0.17179599986957128, 0.19202530144522956, 0.17554171264851992, 0.19125976217298912, 0.18617855925794513, 0.19471502538714358, 0.07908637111615457, 0.07368576916892267, 0.08700480035958169, 0.0833944918566254, 0.07803286149322008, 0.07076553503613592, 0.07791515250978842, 0.06956739599265638, 0.08135547831575585]}, "mutation_prompt": null}
{"id": "2e60f4ec-5402-4c06-8035-171d0a95b004", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) using an enhanced dynamic mutation factor for improved convergence speed.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c459969f-50d7-4e3e-ac01-563d3a467525", "metadata": {"aucs": [0.6938020557061727, 0.6981896661863495, 0.6832572940694606, 0.7118201728758551, 0.7129978187803072, 0.7173963547599209, 0.6864217748144283, 0.702758150094549, 0.7044217309543193, 0.5128095982732479, 0.5171731757544356, 0.4890688084835998, 0.4863608326326545, 0.4873512782714371, 0.48929177690773273, 0.5062501959066199, 0.49714217269784733, 0.506742858219779, 0.08992500281273785, 0.1061396298697369, 0.09711102230545965, 0.10870244394188178, 0.11253883223376959, 0.10271409065771875, 0.1100942190128078, 0.10589116692490408, 0.1032699262483957, 0.08963959219748063, 0.08975651710680344, 0.10108499527013659, 0.09196430606281569, 0.087017555003718, 0.09515561255218419, 0.08950201785486245, 0.09004189900107795, 0.08425322283908077, 0.9422406949352691, 0.9433086573391383, 0.9703321306715395, 0.9331827232489784, 0.9195484499935498, 0.9591235018926786, 0.9509986193324821, 0.9730242893377619, 0.9389140432492129, 0.3528831042783015, 0.36731293026926437, 0.3696874537347312, 0.37771034549502625, 0.3366397107284792, 0.3580732123738961, 0.3815627016238107, 0.3574597068540636, 0.3572630315728009, 0.6438127089797783, 0.6394258191332831, 0.5602401632456759, 0.6193822687953531, 0.6436672334608058, 0.6525122543660753, 0.6347016861344785, 0.6147008185234284, 0.6749795357566231, 0.17506923632689408, 0.1936526803929698, 0.16508234706868785, 0.19110298977276108, 0.19403720792156942, 0.208140473620975, 0.32434122880445815, 0.1985030891121613, 0.20586772211259885, 0.4167476604148713, 0.2020680257282471, 0.2891622316534951, 0.16623280539585739, 0.1852319821431916, 0.19043127981739327, 0.2056927281801203, 0.1810810543834105, 0.19946847238749976, 0.2477673825225304, 0.26418822020828125, 0.28268416098091065, 0.285827225974043, 0.2773613057032118, 0.188773959728881, 0.27981425517015457, 0.30265163075710144, 0.24810912730055534, 0.4066560079555027, 0.3499015692329147, 0.3650236849998547, 0.3979698736491353, 0.33797371123289377, 0.37439555511423783, 0.40052815887111914, 0.43079029490133947, 0.3737425207672007, 0.09701464740184274, 0.0894324774946581, 0.09983427158218694, 0.13472239029603572, 0.11642803065301288, 0.12966639440225192, 0.087758135565705, 0.10473685963941937, 0.10379002174616381, 0.22437111858363712, 0.24553293597322068, 0.2144652259866502, 0.26552190901665884, 0.25537105190918685, 0.24840110870161358, 0.24535058270163368, 0.21384298862942808, 0.22907387397129308, 0.5884618146606102, 0.5867976141560072, 0.6066141450750275, 0.5716074026778855, 0.6019445645761137, 0.5924653240725618, 0.5978889438907456, 0.5555938238341418, 0.597262810740798, 0.09009334896015553, 0.08861525457028441, 0.09164868700359219, 0.11163222938480599, 0.0934407244375911, 0.09356074410747606, 0.10939628036665294, 0.07961687934678852, 0.08254215061390457, 0.16762049476224672, 0.16036355398778868, 0.16143480860624493, 0.17887322863222976, 0.18252668339842326, 0.1990710867165847, 0.17751008518028666, 0.17665327058597413, 0.1805291896326231, 0.35792073248886314, 0.359882777675385, 0.35946586638892053, 0.33129099109316384, 0.36748811786171254, 0.3536487202734797, 0.3881048011042082, 0.3757826235749724, 0.37124349130847345, 0.26184998217733435, 0.2779939151655274, 0.289484162015998, 0.2666061674353709, 0.25516634468174504, 0.27087548699762487, 0.2713926361687682, 0.27883912262846533, 0.29313907603873035, 0.18879765714740238, 0.18021154114001858, 0.17299995695223047, 0.20190749341392822, 0.19373337008636105, 0.1944086463788257, 0.20485669752197178, 0.19377016201383623, 0.20456540036620208, 0.20900102494516182, 0.19805746184984585, 0.19096154567347734, 0.18460546893788143, 0.1969971707242144, 0.18435695792586582, 0.2004587245841042, 0.1807199401086378, 0.1897370361032712, 0.7729256214372398, 0.1660480540086583, 0.741581655383842, 0.6508397162037352, 0.468030139366688, 0.5593108175693271, 0.6059660170216032, 0.5612402270838825, 0.6313077798179025, 0.6373432126912961, 0.21057684436025736, 0.555084825263708, 0.58965711453779, 0.20892621194061467, 0.5987323016595096, 0.21041146656458332, 0.20974796311522448, 0.20912280833717034, 0.19485223308098742, 0.19120036704835464, 0.1876457421544644, 0.17179599986957128, 0.19202530144522956, 0.17554171264851992, 0.19125976217298912, 0.18617855925794513, 0.19471502538714358, 0.07908637111615457, 0.07368576916892267, 0.08700480035958169, 0.0833944918566254, 0.07803286149322008, 0.07076553503613592, 0.07791515250978842, 0.06956739599265638, 0.08135547831575585]}, "mutation_prompt": null}
{"id": "430f642f-52c1-4146-8696-5d0f1fbd16cc", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) using an enhanced dynamic mutation factor for improved convergence speed.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c459969f-50d7-4e3e-ac01-563d3a467525", "metadata": {"aucs": [0.6938020557061727, 0.6981896661863495, 0.6832572940694606, 0.7118201728758551, 0.7129978187803072, 0.7173963547599209, 0.6864217748144283, 0.702758150094549, 0.7044217309543193, 0.5128095982732479, 0.5171731757544356, 0.4890688084835998, 0.4863608326326545, 0.4873512782714371, 0.48929177690773273, 0.5062501959066199, 0.49714217269784733, 0.506742858219779, 0.08992500281273785, 0.1061396298697369, 0.09711102230545965, 0.10870244394188178, 0.11253883223376959, 0.10271409065771875, 0.1100942190128078, 0.10589116692490408, 0.1032699262483957, 0.08963959219748063, 0.08975651710680344, 0.10108499527013659, 0.09196430606281569, 0.087017555003718, 0.09515561255218419, 0.08950201785486245, 0.09004189900107795, 0.08425322283908077, 0.9422406949352691, 0.9433086573391383, 0.9703321306715395, 0.9331827232489784, 0.9195484499935498, 0.9591235018926786, 0.9509986193324821, 0.9730242893377619, 0.9389140432492129, 0.3528831042783015, 0.36731293026926437, 0.3696874537347312, 0.37771034549502625, 0.3366397107284792, 0.3580732123738961, 0.3815627016238107, 0.3574597068540636, 0.3572630315728009, 0.6438127089797783, 0.6394258191332831, 0.5602401632456759, 0.6193822687953531, 0.6436672334608058, 0.6525122543660753, 0.6347016861344785, 0.6147008185234284, 0.6749795357566231, 0.17506923632689408, 0.1936526803929698, 0.16508234706868785, 0.19110298977276108, 0.19403720792156942, 0.208140473620975, 0.32434122880445815, 0.1985030891121613, 0.20586772211259885, 0.4167476604148713, 0.2020680257282471, 0.2891622316534951, 0.16623280539585739, 0.1852319821431916, 0.19043127981739327, 0.2056927281801203, 0.1810810543834105, 0.19946847238749976, 0.2477673825225304, 0.26418822020828125, 0.28268416098091065, 0.285827225974043, 0.2773613057032118, 0.188773959728881, 0.27981425517015457, 0.30265163075710144, 0.24810912730055534, 0.4066560079555027, 0.3499015692329147, 0.3650236849998547, 0.3979698736491353, 0.33797371123289377, 0.37439555511423783, 0.40052815887111914, 0.43079029490133947, 0.3737425207672007, 0.09701464740184274, 0.0894324774946581, 0.09983427158218694, 0.13472239029603572, 0.11642803065301288, 0.12966639440225192, 0.087758135565705, 0.10473685963941937, 0.10379002174616381, 0.22437111858363712, 0.24553293597322068, 0.2144652259866502, 0.26552190901665884, 0.25537105190918685, 0.24840110870161358, 0.24535058270163368, 0.21384298862942808, 0.22907387397129308, 0.5884618146606102, 0.5867976141560072, 0.6066141450750275, 0.5716074026778855, 0.6019445645761137, 0.5924653240725618, 0.5978889438907456, 0.5555938238341418, 0.597262810740798, 0.09009334896015553, 0.08861525457028441, 0.09164868700359219, 0.11163222938480599, 0.0934407244375911, 0.09356074410747606, 0.10939628036665294, 0.07961687934678852, 0.08254215061390457, 0.16762049476224672, 0.16036355398778868, 0.16143480860624493, 0.17887322863222976, 0.18252668339842326, 0.1990710867165847, 0.17751008518028666, 0.17665327058597413, 0.1805291896326231, 0.35792073248886314, 0.359882777675385, 0.35946586638892053, 0.33129099109316384, 0.36748811786171254, 0.3536487202734797, 0.3881048011042082, 0.3757826235749724, 0.37124349130847345, 0.26184998217733435, 0.2779939151655274, 0.289484162015998, 0.2666061674353709, 0.25516634468174504, 0.27087548699762487, 0.2713926361687682, 0.27883912262846533, 0.29313907603873035, 0.18879765714740238, 0.18021154114001858, 0.17299995695223047, 0.20190749341392822, 0.19373337008636105, 0.1944086463788257, 0.20485669752197178, 0.19377016201383623, 0.20456540036620208, 0.20900102494516182, 0.19805746184984585, 0.19096154567347734, 0.18460546893788143, 0.1969971707242144, 0.18435695792586582, 0.2004587245841042, 0.1807199401086378, 0.1897370361032712, 0.7729256214372398, 0.1660480540086583, 0.741581655383842, 0.6508397162037352, 0.468030139366688, 0.5593108175693271, 0.6059660170216032, 0.5612402270838825, 0.6313077798179025, 0.6373432126912961, 0.21057684436025736, 0.555084825263708, 0.58965711453779, 0.20892621194061467, 0.5987323016595096, 0.21041146656458332, 0.20974796311522448, 0.20912280833717034, 0.19485223308098742, 0.19120036704835464, 0.1876457421544644, 0.17179599986957128, 0.19202530144522956, 0.17554171264851992, 0.19125976217298912, 0.18617855925794513, 0.19471502538714358, 0.07908637111615457, 0.07368576916892267, 0.08700480035958169, 0.0833944918566254, 0.07803286149322008, 0.07076553503613592, 0.07791515250978842, 0.06956739599265638, 0.08135547831575585]}, "mutation_prompt": null}
{"id": "f07f490d-4e0a-4503-b45a-23a73d77fe27", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) using an enhanced dynamic mutation factor for improved convergence speed.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c459969f-50d7-4e3e-ac01-563d3a467525", "metadata": {"aucs": [0.6938020557061727, 0.6981896661863495, 0.6832572940694606, 0.7118201728758551, 0.7129978187803072, 0.7173963547599209, 0.6864217748144283, 0.702758150094549, 0.7044217309543193, 0.5128095982732479, 0.5171731757544356, 0.4890688084835998, 0.4863608326326545, 0.4873512782714371, 0.48929177690773273, 0.5062501959066199, 0.49714217269784733, 0.506742858219779, 0.08992500281273785, 0.1061396298697369, 0.09711102230545965, 0.10870244394188178, 0.11253883223376959, 0.10271409065771875, 0.1100942190128078, 0.10589116692490408, 0.1032699262483957, 0.08963959219748063, 0.08975651710680344, 0.10108499527013659, 0.09196430606281569, 0.087017555003718, 0.09515561255218419, 0.08950201785486245, 0.09004189900107795, 0.08425322283908077, 0.9422406949352691, 0.9433086573391383, 0.9703321306715395, 0.9331827232489784, 0.9195484499935498, 0.9591235018926786, 0.9509986193324821, 0.9730242893377619, 0.9389140432492129, 0.3528831042783015, 0.36731293026926437, 0.3696874537347312, 0.37771034549502625, 0.3366397107284792, 0.3580732123738961, 0.3815627016238107, 0.3574597068540636, 0.3572630315728009, 0.6438127089797783, 0.6394258191332831, 0.5602401632456759, 0.6193822687953531, 0.6436672334608058, 0.6525122543660753, 0.6347016861344785, 0.6147008185234284, 0.6749795357566231, 0.17506923632689408, 0.1936526803929698, 0.16508234706868785, 0.19110298977276108, 0.19403720792156942, 0.208140473620975, 0.32434122880445815, 0.1985030891121613, 0.20586772211259885, 0.4167476604148713, 0.2020680257282471, 0.2891622316534951, 0.16623280539585739, 0.1852319821431916, 0.19043127981739327, 0.2056927281801203, 0.1810810543834105, 0.19946847238749976, 0.2477673825225304, 0.26418822020828125, 0.28268416098091065, 0.285827225974043, 0.2773613057032118, 0.188773959728881, 0.27981425517015457, 0.30265163075710144, 0.24810912730055534, 0.4066560079555027, 0.3499015692329147, 0.3650236849998547, 0.3979698736491353, 0.33797371123289377, 0.37439555511423783, 0.40052815887111914, 0.43079029490133947, 0.3737425207672007, 0.09701464740184274, 0.0894324774946581, 0.09983427158218694, 0.13472239029603572, 0.11642803065301288, 0.12966639440225192, 0.087758135565705, 0.10473685963941937, 0.10379002174616381, 0.22437111858363712, 0.24553293597322068, 0.2144652259866502, 0.26552190901665884, 0.25537105190918685, 0.24840110870161358, 0.24535058270163368, 0.21384298862942808, 0.22907387397129308, 0.5884618146606102, 0.5867976141560072, 0.6066141450750275, 0.5716074026778855, 0.6019445645761137, 0.5924653240725618, 0.5978889438907456, 0.5555938238341418, 0.597262810740798, 0.09009334896015553, 0.08861525457028441, 0.09164868700359219, 0.11163222938480599, 0.0934407244375911, 0.09356074410747606, 0.10939628036665294, 0.07961687934678852, 0.08254215061390457, 0.16762049476224672, 0.16036355398778868, 0.16143480860624493, 0.17887322863222976, 0.18252668339842326, 0.1990710867165847, 0.17751008518028666, 0.17665327058597413, 0.1805291896326231, 0.35792073248886314, 0.359882777675385, 0.35946586638892053, 0.33129099109316384, 0.36748811786171254, 0.3536487202734797, 0.3881048011042082, 0.3757826235749724, 0.37124349130847345, 0.26184998217733435, 0.2779939151655274, 0.289484162015998, 0.2666061674353709, 0.25516634468174504, 0.27087548699762487, 0.2713926361687682, 0.27883912262846533, 0.29313907603873035, 0.18879765714740238, 0.18021154114001858, 0.17299995695223047, 0.20190749341392822, 0.19373337008636105, 0.1944086463788257, 0.20485669752197178, 0.19377016201383623, 0.20456540036620208, 0.20900102494516182, 0.19805746184984585, 0.19096154567347734, 0.18460546893788143, 0.1969971707242144, 0.18435695792586582, 0.2004587245841042, 0.1807199401086378, 0.1897370361032712, 0.7729256214372398, 0.1660480540086583, 0.741581655383842, 0.6508397162037352, 0.468030139366688, 0.5593108175693271, 0.6059660170216032, 0.5612402270838825, 0.6313077798179025, 0.6373432126912961, 0.21057684436025736, 0.555084825263708, 0.58965711453779, 0.20892621194061467, 0.5987323016595096, 0.21041146656458332, 0.20974796311522448, 0.20912280833717034, 0.19485223308098742, 0.19120036704835464, 0.1876457421544644, 0.17179599986957128, 0.19202530144522956, 0.17554171264851992, 0.19125976217298912, 0.18617855925794513, 0.19471502538714358, 0.07908637111615457, 0.07368576916892267, 0.08700480035958169, 0.0833944918566254, 0.07803286149322008, 0.07076553503613592, 0.07791515250978842, 0.06956739599265638, 0.08135547831575585]}, "mutation_prompt": null}
{"id": "9e5df823-96ad-4a02-8b59-873cff06d2d9", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) using an enhanced dynamic mutation factor for improved convergence speed.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c459969f-50d7-4e3e-ac01-563d3a467525", "metadata": {"aucs": [0.6938020557061727, 0.6981896661863495, 0.6832572940694606, 0.7118201728758551, 0.7129978187803072, 0.7173963547599209, 0.6864217748144283, 0.702758150094549, 0.7044217309543193, 0.5128095982732479, 0.5171731757544356, 0.4890688084835998, 0.4863608326326545, 0.4873512782714371, 0.48929177690773273, 0.5062501959066199, 0.49714217269784733, 0.506742858219779, 0.08992500281273785, 0.1061396298697369, 0.09711102230545965, 0.10870244394188178, 0.11253883223376959, 0.10271409065771875, 0.1100942190128078, 0.10589116692490408, 0.1032699262483957, 0.08963959219748063, 0.08975651710680344, 0.10108499527013659, 0.09196430606281569, 0.087017555003718, 0.09515561255218419, 0.08950201785486245, 0.09004189900107795, 0.08425322283908077, 0.9422406949352691, 0.9433086573391383, 0.9703321306715395, 0.9331827232489784, 0.9195484499935498, 0.9591235018926786, 0.9509986193324821, 0.9730242893377619, 0.9389140432492129, 0.3528831042783015, 0.36731293026926437, 0.3696874537347312, 0.37771034549502625, 0.3366397107284792, 0.3580732123738961, 0.3815627016238107, 0.3574597068540636, 0.3572630315728009, 0.6438127089797783, 0.6394258191332831, 0.5602401632456759, 0.6193822687953531, 0.6436672334608058, 0.6525122543660753, 0.6347016861344785, 0.6147008185234284, 0.6749795357566231, 0.17506923632689408, 0.1936526803929698, 0.16508234706868785, 0.19110298977276108, 0.19403720792156942, 0.208140473620975, 0.32434122880445815, 0.1985030891121613, 0.20586772211259885, 0.4167476604148713, 0.2020680257282471, 0.2891622316534951, 0.16623280539585739, 0.1852319821431916, 0.19043127981739327, 0.2056927281801203, 0.1810810543834105, 0.19946847238749976, 0.2477673825225304, 0.26418822020828125, 0.28268416098091065, 0.285827225974043, 0.2773613057032118, 0.188773959728881, 0.27981425517015457, 0.30265163075710144, 0.24810912730055534, 0.4066560079555027, 0.3499015692329147, 0.3650236849998547, 0.3979698736491353, 0.33797371123289377, 0.37439555511423783, 0.40052815887111914, 0.43079029490133947, 0.3737425207672007, 0.09701464740184274, 0.0894324774946581, 0.09983427158218694, 0.13472239029603572, 0.11642803065301288, 0.12966639440225192, 0.087758135565705, 0.10473685963941937, 0.10379002174616381, 0.22437111858363712, 0.24553293597322068, 0.2144652259866502, 0.26552190901665884, 0.25537105190918685, 0.24840110870161358, 0.24535058270163368, 0.21384298862942808, 0.22907387397129308, 0.5884618146606102, 0.5867976141560072, 0.6066141450750275, 0.5716074026778855, 0.6019445645761137, 0.5924653240725618, 0.5978889438907456, 0.5555938238341418, 0.597262810740798, 0.09009334896015553, 0.08861525457028441, 0.09164868700359219, 0.11163222938480599, 0.0934407244375911, 0.09356074410747606, 0.10939628036665294, 0.07961687934678852, 0.08254215061390457, 0.16762049476224672, 0.16036355398778868, 0.16143480860624493, 0.17887322863222976, 0.18252668339842326, 0.1990710867165847, 0.17751008518028666, 0.17665327058597413, 0.1805291896326231, 0.35792073248886314, 0.359882777675385, 0.35946586638892053, 0.33129099109316384, 0.36748811786171254, 0.3536487202734797, 0.3881048011042082, 0.3757826235749724, 0.37124349130847345, 0.26184998217733435, 0.2779939151655274, 0.289484162015998, 0.2666061674353709, 0.25516634468174504, 0.27087548699762487, 0.2713926361687682, 0.27883912262846533, 0.29313907603873035, 0.18879765714740238, 0.18021154114001858, 0.17299995695223047, 0.20190749341392822, 0.19373337008636105, 0.1944086463788257, 0.20485669752197178, 0.19377016201383623, 0.20456540036620208, 0.20900102494516182, 0.19805746184984585, 0.19096154567347734, 0.18460546893788143, 0.1969971707242144, 0.18435695792586582, 0.2004587245841042, 0.1807199401086378, 0.1897370361032712, 0.7729256214372398, 0.1660480540086583, 0.741581655383842, 0.6508397162037352, 0.468030139366688, 0.5593108175693271, 0.6059660170216032, 0.5612402270838825, 0.6313077798179025, 0.6373432126912961, 0.21057684436025736, 0.555084825263708, 0.58965711453779, 0.20892621194061467, 0.5987323016595096, 0.21041146656458332, 0.20974796311522448, 0.20912280833717034, 0.19485223308098742, 0.19120036704835464, 0.1876457421544644, 0.17179599986957128, 0.19202530144522956, 0.17554171264851992, 0.19125976217298912, 0.18617855925794513, 0.19471502538714358, 0.07908637111615457, 0.07368576916892267, 0.08700480035958169, 0.0833944918566254, 0.07803286149322008, 0.07076553503613592, 0.07791515250978842, 0.06956739599265638, 0.08135547831575585]}, "mutation_prompt": null}
{"id": "0cb881e2-b3e9-4529-afd5-d10fe0c41d7d", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) using an enhanced dynamic mutation factor for improved convergence speed.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c459969f-50d7-4e3e-ac01-563d3a467525", "metadata": {"aucs": [0.6938020557061727, 0.6981896661863495, 0.6832572940694606, 0.7118201728758551, 0.7129978187803072, 0.7173963547599209, 0.6864217748144283, 0.702758150094549, 0.7044217309543193, 0.5128095982732479, 0.5171731757544356, 0.4890688084835998, 0.4863608326326545, 0.4873512782714371, 0.48929177690773273, 0.5062501959066199, 0.49714217269784733, 0.506742858219779, 0.08992500281273785, 0.1061396298697369, 0.09711102230545965, 0.10870244394188178, 0.11253883223376959, 0.10271409065771875, 0.1100942190128078, 0.10589116692490408, 0.1032699262483957, 0.08963959219748063, 0.08975651710680344, 0.10108499527013659, 0.09196430606281569, 0.087017555003718, 0.09515561255218419, 0.08950201785486245, 0.09004189900107795, 0.08425322283908077, 0.9422406949352691, 0.9433086573391383, 0.9703321306715395, 0.9331827232489784, 0.9195484499935498, 0.9591235018926786, 0.9509986193324821, 0.9730242893377619, 0.9389140432492129, 0.3528831042783015, 0.36731293026926437, 0.3696874537347312, 0.37771034549502625, 0.3366397107284792, 0.3580732123738961, 0.3815627016238107, 0.3574597068540636, 0.3572630315728009, 0.6438127089797783, 0.6394258191332831, 0.5602401632456759, 0.6193822687953531, 0.6436672334608058, 0.6525122543660753, 0.6347016861344785, 0.6147008185234284, 0.6749795357566231, 0.17506923632689408, 0.1936526803929698, 0.16508234706868785, 0.19110298977276108, 0.19403720792156942, 0.208140473620975, 0.32434122880445815, 0.1985030891121613, 0.20586772211259885, 0.4167476604148713, 0.2020680257282471, 0.2891622316534951, 0.16623280539585739, 0.1852319821431916, 0.19043127981739327, 0.2056927281801203, 0.1810810543834105, 0.19946847238749976, 0.2477673825225304, 0.26418822020828125, 0.28268416098091065, 0.285827225974043, 0.2773613057032118, 0.188773959728881, 0.27981425517015457, 0.30265163075710144, 0.24810912730055534, 0.4066560079555027, 0.3499015692329147, 0.3650236849998547, 0.3979698736491353, 0.33797371123289377, 0.37439555511423783, 0.40052815887111914, 0.43079029490133947, 0.3737425207672007, 0.09701464740184274, 0.0894324774946581, 0.09983427158218694, 0.13472239029603572, 0.11642803065301288, 0.12966639440225192, 0.087758135565705, 0.10473685963941937, 0.10379002174616381, 0.22437111858363712, 0.24553293597322068, 0.2144652259866502, 0.26552190901665884, 0.25537105190918685, 0.24840110870161358, 0.24535058270163368, 0.21384298862942808, 0.22907387397129308, 0.5884618146606102, 0.5867976141560072, 0.6066141450750275, 0.5716074026778855, 0.6019445645761137, 0.5924653240725618, 0.5978889438907456, 0.5555938238341418, 0.597262810740798, 0.09009334896015553, 0.08861525457028441, 0.09164868700359219, 0.11163222938480599, 0.0934407244375911, 0.09356074410747606, 0.10939628036665294, 0.07961687934678852, 0.08254215061390457, 0.16762049476224672, 0.16036355398778868, 0.16143480860624493, 0.17887322863222976, 0.18252668339842326, 0.1990710867165847, 0.17751008518028666, 0.17665327058597413, 0.1805291896326231, 0.35792073248886314, 0.359882777675385, 0.35946586638892053, 0.33129099109316384, 0.36748811786171254, 0.3536487202734797, 0.3881048011042082, 0.3757826235749724, 0.37124349130847345, 0.26184998217733435, 0.2779939151655274, 0.289484162015998, 0.2666061674353709, 0.25516634468174504, 0.27087548699762487, 0.2713926361687682, 0.27883912262846533, 0.29313907603873035, 0.18879765714740238, 0.18021154114001858, 0.17299995695223047, 0.20190749341392822, 0.19373337008636105, 0.1944086463788257, 0.20485669752197178, 0.19377016201383623, 0.20456540036620208, 0.20900102494516182, 0.19805746184984585, 0.19096154567347734, 0.18460546893788143, 0.1969971707242144, 0.18435695792586582, 0.2004587245841042, 0.1807199401086378, 0.1897370361032712, 0.7729256214372398, 0.1660480540086583, 0.741581655383842, 0.6508397162037352, 0.468030139366688, 0.5593108175693271, 0.6059660170216032, 0.5612402270838825, 0.6313077798179025, 0.6373432126912961, 0.21057684436025736, 0.555084825263708, 0.58965711453779, 0.20892621194061467, 0.5987323016595096, 0.21041146656458332, 0.20974796311522448, 0.20912280833717034, 0.19485223308098742, 0.19120036704835464, 0.1876457421544644, 0.17179599986957128, 0.19202530144522956, 0.17554171264851992, 0.19125976217298912, 0.18617855925794513, 0.19471502538714358, 0.07908637111615457, 0.07368576916892267, 0.08700480035958169, 0.0833944918566254, 0.07803286149322008, 0.07076553503613592, 0.07791515250978842, 0.06956739599265638, 0.08135547831575585]}, "mutation_prompt": null}
{"id": "8249595e-3616-4cc2-af59-ea9d193cd085", "solution": "import numpy as np\n\nclass DEALS_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.6 + 0.4 * np.cos(np.pi * evals / self.budget)  # Adjusted mutation dynamics\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                a, b, c = self.select_others(i)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count)\n                \n        return self.best_solution()\n\n    def select_others(self, index):\n        indices = list(range(self.population_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_rate = self.CR if self.scores[np.argmin(self.scores)] > 1 else 0.6  # Adjust crossover based on score\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count):\n        best_idx = np.argmin(self.scores)\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS_Enhanced", "description": "Improved convergence speed through adaptive strategy adjustments in mutation and crossover.", "configspace": "", "generation": 44, "fitness": 0.2671134055348403, "feedback": "The algorithm DEALS_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "c459969f-50d7-4e3e-ac01-563d3a467525", "metadata": {"aucs": [0.6159543506077717, 0.5991881935047059, 0.5896990494955412, 0.6357304963635377, 0.6191689072079216, 0.6466474734300509, 0.6417108549037837, 0.6388924743988067, 0.6605178178825866, 0.4233641471623164, 0.4023475579772602, 0.4155825375323582, 0.3938971074057719, 0.43968997847130753, 0.4136604309282951, 0.4257042238458927, 0.41837715575569234, 0.4296334101209842, 0.1443058974706033, 0.12501202283912793, 0.14963387207987722, 0.09775149839580444, 0.09222937842967205, 0.10268273788754778, 0.09896201283660355, 0.1048760122166712, 0.09067908940992042, 0.1345392021529337, 0.10663466533873112, 0.12663845700931797, 0.09115203350601442, 0.07787150476343563, 0.08537407708265277, 0.09436752618561417, 0.08190241431252265, 0.09355994647564603, 0.9523675570457248, 0.9702771255021423, 0.9513913032816226, 0.9256504071463404, 0.9604369395028276, 0.96045095798285, 0.9362213131563136, 0.9663409944863353, 0.9860495856041519, 0.31463663870547465, 0.32342882816864993, 0.3074468767392037, 0.33804145631127736, 0.32830662452700055, 0.31221634966577727, 0.2555437326029725, 0.2528265111102581, 0.2518877156506213, 0.5143616389490446, 0.529026391426435, 0.4822737593600783, 0.5037180662528747, 0.554080239142128, 0.5604330175816254, 0.5356204925297499, 0.46288129853652704, 0.531400244399375, 0.18005420122908855, 0.16704741264711298, 0.15615283509737543, 0.13249020712483084, 0.1475322901938333, 0.13366084389113242, 0.19672604048103526, 0.22791174461997266, 0.2112936183367906, 0.11787441609414906, 0.14484759979402861, 0.2884845730266681, 0.17356929872538063, 0.12511427752269233, 0.1488498486005465, 0.19521298559422606, 0.14726452089604303, 0.165866100793005, 0.06017151555642053, 0.03150316205291803, 0.04413993138835137, 0.19177341511269386, 0.16555162791377132, 0.18559398057088383, 0.00045503977660443784, 0.010882976202940209, 0.0007679478519431182, 0.275171946306748, 0.28983130526871015, 0.2867423543782375, 0.10320505475569264, 0.07889449947234894, 0.09674422728985077, 0.3678027651192427, 0.30774812326943735, 0.29079591027829643, 0.004555414619678566, 0.003979504914327081, 0.002564771016593692, 0.01644181786113219, 0.020260313156373222, 0.015529874842642344, 0.052796350947905024, 0.06264697524058827, 0.07123426964226076, 0.16989730637651823, 0.18192497170683308, 0.17585164351120397, 0.10316070681141731, 0.10018593809168919, 0.10521406385635967, 0.08468691818980556, 0.0950906778797278, 0.0897036098692493, 0.4505322212578614, 0.4407829776053177, 0.4284523767709284, 0.4221630890247998, 0.4456503868822914, 0.430639539181365, 0.5326730455082324, 0.5112561033227638, 0.515605563545739, 0.08636126198944272, 0.08088535604309, 0.07802011751002014, 0.08311114778678397, 0.08894491183996456, 0.07815300697827099, 0.08421294882410935, 0.09256128591340962, 0.08303715066563744, 0.18616102185896855, 0.22146493655757526, 0.17948375747255763, 0.21918660885788843, 0.2470965197497399, 0.16873022081464895, 0.16020398876696818, 0.19803303804068184, 0.18629953924521137, 0.26031668864008584, 0.27367966164260493, 0.26183993036167685, 0.2978095889718906, 0.29403458403620863, 0.28101860455406313, 0.32555712043660856, 0.31416837081848314, 0.307205938487356, 0.19566171107263763, 0.20269709951187886, 0.16879849807642644, 0.21382587488055038, 0.22800490763643744, 0.2173732587621059, 0.24307113466594477, 0.22204539333172357, 0.23886496336399965, 0.18869482972942497, 0.1791881194676631, 0.18684845645649106, 0.17651987848416162, 0.1737860844980369, 0.18598736757241563, 0.1926111612517306, 0.17701544300882865, 0.17273582572420543, 0.2003931690694596, 0.2129458311536533, 0.19843395066259095, 0.19559029700270936, 0.18581776234625835, 0.18657225423828805, 0.19361905041381855, 0.1844265296857468, 0.19031611847739593, 0.6376020783671881, 0.6232053270384582, 0.6532610613143661, 0.41247902117805446, 0.22185793393737563, 0.29294645011793596, 0.17610740591353935, 0.31786688482875625, 0.20240253709142786, 0.3735777944747364, 0.19575537733743853, 0.2843945657812549, 0.450656653495195, 0.4189492402818529, 0.18125908395419843, 0.20626685156979896, 0.2970346528508512, 0.30503651929323017, 0.17682237238283738, 0.1677333874121556, 0.19580009426423362, 0.19032023043513513, 0.18384645845377712, 0.19211424410420752, 0.1934290441003952, 0.19023361962045982, 0.18492343112646026, 0.07334420875175784, 0.06636471163063684, 0.0804033111141711, 0.06922281383730966, 0.07299618509067807, 0.06772548186019489, 0.07246431407565801, 0.07945063677456743, 0.08275572463541214]}, "mutation_prompt": null}
{"id": "8678eecb-2fc1-4c26-9fab-ffcefc4aa9aa", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring a dynamic population size to enhance convergence speed.", "configspace": "", "generation": 45, "fitness": 0.3534179778017534, "feedback": "The algorithm DEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "c459969f-50d7-4e3e-ac01-563d3a467525", "metadata": {"aucs": [0.7405973988741354, 0.7281226209939119, 0.7324233204340155, 0.7489552261542903, 0.7498559026369704, 0.757519831874169, 0.7347098623601342, 0.7602786636377387, 0.7377784648945536, 0.56554125587102, 0.5944505024215752, 0.5808904441751737, 0.5747972667444257, 0.5671564195916405, 0.5961916655424153, 0.5838793849099935, 0.5852024604491162, 0.6063062861246697, 0.11341909746813339, 0.12215541600561153, 0.10085692900524679, 0.10487565508288299, 0.11036818339911192, 0.1016077518681705, 0.13666213112505554, 0.12709043286256294, 0.10861595266627522, 0.10165318727335015, 0.10505953366608245, 0.09783802420298959, 0.10172217148102114, 0.10536819228798322, 0.10900367665295507, 0.0964455393395891, 0.09024177262467925, 0.10437305516394613, 0.9548869183682216, 0.9816209304069197, 0.9712607491984208, 0.9634026914341834, 0.9234496339538826, 0.9622203012390651, 0.985079184370999, 0.9582775702855542, 0.9611271121617417, 0.4313765997319954, 0.4618145994111096, 0.40984676643380813, 0.41472757262044546, 0.36354377548699346, 0.3986783408643845, 0.4379164888621577, 0.40934147613419813, 0.35998487468993845, 0.6806130514358448, 0.6955121767822976, 0.6866807490914777, 0.6701999875888693, 0.6347825436279659, 0.6646026866550377, 0.6567034530055915, 0.6819668428073227, 0.6865650804245118, 0.24016363313740974, 0.22090206531540513, 0.17297907809772384, 0.19886709320385698, 0.2609815145734389, 0.18127297647829888, 0.1957417735940552, 0.22920999827866495, 0.18310000474785193, 0.193110013501813, 0.27693749544418755, 0.11368476511095227, 0.2043950030984022, 0.220306450983471, 0.16484688126919844, 0.16381494823035447, 0.18179600745406732, 0.14778597331998222, 0.30639582001449794, 0.27031080642673355, 0.3372871936467656, 0.33126944253156676, 0.3168027670970488, 0.36890694251841194, 0.2710681818949614, 0.3304548812663224, 0.2636668768734898, 0.399363666198819, 0.4391896350173363, 0.4251106318701794, 0.3957391328356439, 0.4173071637112098, 0.49114169125133744, 0.4571763095341902, 0.44105907891793006, 0.47543054954069286, 0.06983850752350995, 0.20587215387818425, 0.20247406425544145, 0.16216146868714298, 0.16946602502848995, 0.1167350874180072, 0.18066366226210884, 0.10466453986036195, 0.08431960773622249, 0.29775472663503366, 0.2701635789954244, 0.2961391035212847, 0.26748150670562176, 0.3418746895885989, 0.26193853866475514, 0.2980231606880872, 0.2481920681467945, 0.29270775966039486, 0.6392765826679037, 0.6490275061328654, 0.6434311797354066, 0.6101548565800816, 0.6705163158216997, 0.581715485322932, 0.6302372799063853, 0.6572822223214339, 0.63667360276885, 0.10946979306955906, 0.10495685013288236, 0.09854458937774613, 0.09716371232282162, 0.11476060783481101, 0.10180537332611694, 0.08978362639479653, 0.09895539925489538, 0.10411653850132274, 0.2633268434969652, 0.1788873209645211, 0.2264473851374672, 0.2507217028230929, 0.17913228377985901, 0.22891227141535053, 0.19110001644461017, 0.2139585020176098, 0.18290495053256972, 0.4135147594879234, 0.42148645148468744, 0.4163750662420447, 0.3786119686270838, 0.4413315433472095, 0.3775701429488637, 0.43907987101758084, 0.4406275496723362, 0.3647495752161902, 0.35104771272631796, 0.32129370837133686, 0.3145722381892989, 0.2977847102879454, 0.2975529999725195, 0.28898620252116314, 0.3137956181835322, 0.3267581533766173, 0.3330980920336182, 0.1898882779819978, 0.1905400773304492, 0.18545963849958857, 0.18856014300619717, 0.21931369012724744, 0.1990457180226365, 0.20889701508602687, 0.17918548645071464, 0.18996285541952096, 0.23642946213293792, 0.3927603564406512, 0.24749623807951637, 0.19193963824809768, 0.18219160787894084, 0.21713294923741522, 0.221165022732153, 0.2170824145776833, 0.21595790950359184, 0.6431133147940391, 0.7910116517369107, 0.1526494517286039, 0.18367854971517794, 0.20943985436351187, 0.1959939509921974, 0.18284803815092687, 0.6095864501996766, 0.734668736213713, 0.6901716059296701, 0.20955375555447575, 0.6708621482076059, 0.6562094333851947, 0.7065753248293243, 0.2060075346519048, 0.749621608307204, 0.7240217086130991, 0.20907996605188905, 0.18263625118278404, 0.19256000426655284, 0.17657819589137957, 0.17729311771949818, 0.1922495866517835, 0.1990523094758524, 0.18017600315779692, 0.16894604412663083, 0.18586734217102652, 0.08068749109015605, 0.08347801844548375, 0.0782340926600047, 0.08345049371297841, 0.07374025617519131, 0.08647786369411792, 0.08067671222228345, 0.08609957232088361, 0.09423657106271999]}, "mutation_prompt": null}
{"id": "7ddd4fa2-3bc2-42fe-9fa0-57647e780c8a", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring a dynamic population size to enhance convergence speed.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8678eecb-2fc1-4c26-9fab-ffcefc4aa9aa", "metadata": {"aucs": [0.7405973988741354, 0.7281226209939119, 0.7324233204340155, 0.7489552261542903, 0.7498559026369704, 0.757519831874169, 0.7347098623601342, 0.7602786636377387, 0.7377784648945536, 0.56554125587102, 0.5944505024215752, 0.5808904441751737, 0.5747972667444257, 0.5671564195916405, 0.5961916655424153, 0.5838793849099935, 0.5852024604491162, 0.6063062861246697, 0.11341909746813339, 0.12215541600561153, 0.10085692900524679, 0.10487565508288299, 0.11036818339911192, 0.1016077518681705, 0.13666213112505554, 0.12709043286256294, 0.10861595266627522, 0.10165318727335015, 0.10505953366608245, 0.09783802420298959, 0.10172217148102114, 0.10536819228798322, 0.10900367665295507, 0.0964455393395891, 0.09024177262467925, 0.10437305516394613, 0.9548869183682216, 0.9816209304069197, 0.9712607491984208, 0.9634026914341834, 0.9234496339538826, 0.9622203012390651, 0.985079184370999, 0.9582775702855542, 0.9611271121617417, 0.4313765997319954, 0.4618145994111096, 0.40984676643380813, 0.41472757262044546, 0.36354377548699346, 0.3986783408643845, 0.4379164888621577, 0.40934147613419813, 0.35998487468993845, 0.6806130514358448, 0.6955121767822976, 0.6866807490914777, 0.6701999875888693, 0.6347825436279659, 0.6646026866550377, 0.6567034530055915, 0.6819668428073227, 0.6865650804245118, 0.24016363313740974, 0.22090206531540513, 0.17297907809772384, 0.19886709320385698, 0.2609815145734389, 0.18127297647829888, 0.1957417735940552, 0.22920999827866495, 0.18310000474785193, 0.193110013501813, 0.27693749544418755, 0.11368476511095227, 0.2043950030984022, 0.220306450983471, 0.16484688126919844, 0.16381494823035447, 0.18179600745406732, 0.14778597331998222, 0.30639582001449794, 0.27031080642673355, 0.3372871936467656, 0.33126944253156676, 0.3168027670970488, 0.36890694251841194, 0.2710681818949614, 0.3304548812663224, 0.2636668768734898, 0.399363666198819, 0.4391896350173363, 0.4251106318701794, 0.3957391328356439, 0.4173071637112098, 0.49114169125133744, 0.4571763095341902, 0.44105907891793006, 0.47543054954069286, 0.06983850752350995, 0.20587215387818425, 0.20247406425544145, 0.16216146868714298, 0.16946602502848995, 0.1167350874180072, 0.18066366226210884, 0.10466453986036195, 0.08431960773622249, 0.29775472663503366, 0.2701635789954244, 0.2961391035212847, 0.26748150670562176, 0.3418746895885989, 0.26193853866475514, 0.2980231606880872, 0.2481920681467945, 0.29270775966039486, 0.6392765826679037, 0.6490275061328654, 0.6434311797354066, 0.6101548565800816, 0.6705163158216997, 0.581715485322932, 0.6302372799063853, 0.6572822223214339, 0.63667360276885, 0.10946979306955906, 0.10495685013288236, 0.09854458937774613, 0.09716371232282162, 0.11476060783481101, 0.10180537332611694, 0.08978362639479653, 0.09895539925489538, 0.10411653850132274, 0.2633268434969652, 0.1788873209645211, 0.2264473851374672, 0.2507217028230929, 0.17913228377985901, 0.22891227141535053, 0.19110001644461017, 0.2139585020176098, 0.18290495053256972, 0.4135147594879234, 0.42148645148468744, 0.4163750662420447, 0.3786119686270838, 0.4413315433472095, 0.3775701429488637, 0.43907987101758084, 0.4406275496723362, 0.3647495752161902, 0.35104771272631796, 0.32129370837133686, 0.3145722381892989, 0.2977847102879454, 0.2975529999725195, 0.28898620252116314, 0.3137956181835322, 0.3267581533766173, 0.3330980920336182, 0.1898882779819978, 0.1905400773304492, 0.18545963849958857, 0.18856014300619717, 0.21931369012724744, 0.1990457180226365, 0.20889701508602687, 0.17918548645071464, 0.18996285541952096, 0.23642946213293792, 0.3927603564406512, 0.24749623807951637, 0.19193963824809768, 0.18219160787894084, 0.21713294923741522, 0.221165022732153, 0.2170824145776833, 0.21595790950359184, 0.6431133147940391, 0.7910116517369107, 0.1526494517286039, 0.18367854971517794, 0.20943985436351187, 0.1959939509921974, 0.18284803815092687, 0.6095864501996766, 0.734668736213713, 0.6901716059296701, 0.20955375555447575, 0.6708621482076059, 0.6562094333851947, 0.7065753248293243, 0.2060075346519048, 0.749621608307204, 0.7240217086130991, 0.20907996605188905, 0.18263625118278404, 0.19256000426655284, 0.17657819589137957, 0.17729311771949818, 0.1922495866517835, 0.1990523094758524, 0.18017600315779692, 0.16894604412663083, 0.18586734217102652, 0.08068749109015605, 0.08347801844548375, 0.0782340926600047, 0.08345049371297841, 0.07374025617519131, 0.08647786369411792, 0.08067671222228345, 0.08609957232088361, 0.09423657106271999]}, "mutation_prompt": null}
{"id": "e9001789-7fd6-4c4c-91da-e46a1741c183", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring a dynamic population size to enhance convergence speed.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8678eecb-2fc1-4c26-9fab-ffcefc4aa9aa", "metadata": {"aucs": [0.7405973988741354, 0.7281226209939119, 0.7324233204340155, 0.7489552261542903, 0.7498559026369704, 0.757519831874169, 0.7347098623601342, 0.7602786636377387, 0.7377784648945536, 0.56554125587102, 0.5944505024215752, 0.5808904441751737, 0.5747972667444257, 0.5671564195916405, 0.5961916655424153, 0.5838793849099935, 0.5852024604491162, 0.6063062861246697, 0.11341909746813339, 0.12215541600561153, 0.10085692900524679, 0.10487565508288299, 0.11036818339911192, 0.1016077518681705, 0.13666213112505554, 0.12709043286256294, 0.10861595266627522, 0.10165318727335015, 0.10505953366608245, 0.09783802420298959, 0.10172217148102114, 0.10536819228798322, 0.10900367665295507, 0.0964455393395891, 0.09024177262467925, 0.10437305516394613, 0.9548869183682216, 0.9816209304069197, 0.9712607491984208, 0.9634026914341834, 0.9234496339538826, 0.9622203012390651, 0.985079184370999, 0.9582775702855542, 0.9611271121617417, 0.4313765997319954, 0.4618145994111096, 0.40984676643380813, 0.41472757262044546, 0.36354377548699346, 0.3986783408643845, 0.4379164888621577, 0.40934147613419813, 0.35998487468993845, 0.6806130514358448, 0.6955121767822976, 0.6866807490914777, 0.6701999875888693, 0.6347825436279659, 0.6646026866550377, 0.6567034530055915, 0.6819668428073227, 0.6865650804245118, 0.24016363313740974, 0.22090206531540513, 0.17297907809772384, 0.19886709320385698, 0.2609815145734389, 0.18127297647829888, 0.1957417735940552, 0.22920999827866495, 0.18310000474785193, 0.193110013501813, 0.27693749544418755, 0.11368476511095227, 0.2043950030984022, 0.220306450983471, 0.16484688126919844, 0.16381494823035447, 0.18179600745406732, 0.14778597331998222, 0.30639582001449794, 0.27031080642673355, 0.3372871936467656, 0.33126944253156676, 0.3168027670970488, 0.36890694251841194, 0.2710681818949614, 0.3304548812663224, 0.2636668768734898, 0.399363666198819, 0.4391896350173363, 0.4251106318701794, 0.3957391328356439, 0.4173071637112098, 0.49114169125133744, 0.4571763095341902, 0.44105907891793006, 0.47543054954069286, 0.06983850752350995, 0.20587215387818425, 0.20247406425544145, 0.16216146868714298, 0.16946602502848995, 0.1167350874180072, 0.18066366226210884, 0.10466453986036195, 0.08431960773622249, 0.29775472663503366, 0.2701635789954244, 0.2961391035212847, 0.26748150670562176, 0.3418746895885989, 0.26193853866475514, 0.2980231606880872, 0.2481920681467945, 0.29270775966039486, 0.6392765826679037, 0.6490275061328654, 0.6434311797354066, 0.6101548565800816, 0.6705163158216997, 0.581715485322932, 0.6302372799063853, 0.6572822223214339, 0.63667360276885, 0.10946979306955906, 0.10495685013288236, 0.09854458937774613, 0.09716371232282162, 0.11476060783481101, 0.10180537332611694, 0.08978362639479653, 0.09895539925489538, 0.10411653850132274, 0.2633268434969652, 0.1788873209645211, 0.2264473851374672, 0.2507217028230929, 0.17913228377985901, 0.22891227141535053, 0.19110001644461017, 0.2139585020176098, 0.18290495053256972, 0.4135147594879234, 0.42148645148468744, 0.4163750662420447, 0.3786119686270838, 0.4413315433472095, 0.3775701429488637, 0.43907987101758084, 0.4406275496723362, 0.3647495752161902, 0.35104771272631796, 0.32129370837133686, 0.3145722381892989, 0.2977847102879454, 0.2975529999725195, 0.28898620252116314, 0.3137956181835322, 0.3267581533766173, 0.3330980920336182, 0.1898882779819978, 0.1905400773304492, 0.18545963849958857, 0.18856014300619717, 0.21931369012724744, 0.1990457180226365, 0.20889701508602687, 0.17918548645071464, 0.18996285541952096, 0.23642946213293792, 0.3927603564406512, 0.24749623807951637, 0.19193963824809768, 0.18219160787894084, 0.21713294923741522, 0.221165022732153, 0.2170824145776833, 0.21595790950359184, 0.6431133147940391, 0.7910116517369107, 0.1526494517286039, 0.18367854971517794, 0.20943985436351187, 0.1959939509921974, 0.18284803815092687, 0.6095864501996766, 0.734668736213713, 0.6901716059296701, 0.20955375555447575, 0.6708621482076059, 0.6562094333851947, 0.7065753248293243, 0.2060075346519048, 0.749621608307204, 0.7240217086130991, 0.20907996605188905, 0.18263625118278404, 0.19256000426655284, 0.17657819589137957, 0.17729311771949818, 0.1922495866517835, 0.1990523094758524, 0.18017600315779692, 0.16894604412663083, 0.18586734217102652, 0.08068749109015605, 0.08347801844548375, 0.0782340926600047, 0.08345049371297841, 0.07374025617519131, 0.08647786369411792, 0.08067671222228345, 0.08609957232088361, 0.09423657106271999]}, "mutation_prompt": null}
{"id": "32fd7058-b6f1-48a3-a940-d2ab19706b48", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring a dynamic population size to enhance convergence speed.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8678eecb-2fc1-4c26-9fab-ffcefc4aa9aa", "metadata": {"aucs": [0.7405973988741354, 0.7281226209939119, 0.7324233204340155, 0.7489552261542903, 0.7498559026369704, 0.757519831874169, 0.7347098623601342, 0.7602786636377387, 0.7377784648945536, 0.56554125587102, 0.5944505024215752, 0.5808904441751737, 0.5747972667444257, 0.5671564195916405, 0.5961916655424153, 0.5838793849099935, 0.5852024604491162, 0.6063062861246697, 0.11341909746813339, 0.12215541600561153, 0.10085692900524679, 0.10487565508288299, 0.11036818339911192, 0.1016077518681705, 0.13666213112505554, 0.12709043286256294, 0.10861595266627522, 0.10165318727335015, 0.10505953366608245, 0.09783802420298959, 0.10172217148102114, 0.10536819228798322, 0.10900367665295507, 0.0964455393395891, 0.09024177262467925, 0.10437305516394613, 0.9548869183682216, 0.9816209304069197, 0.9712607491984208, 0.9634026914341834, 0.9234496339538826, 0.9622203012390651, 0.985079184370999, 0.9582775702855542, 0.9611271121617417, 0.4313765997319954, 0.4618145994111096, 0.40984676643380813, 0.41472757262044546, 0.36354377548699346, 0.3986783408643845, 0.4379164888621577, 0.40934147613419813, 0.35998487468993845, 0.6806130514358448, 0.6955121767822976, 0.6866807490914777, 0.6701999875888693, 0.6347825436279659, 0.6646026866550377, 0.6567034530055915, 0.6819668428073227, 0.6865650804245118, 0.24016363313740974, 0.22090206531540513, 0.17297907809772384, 0.19886709320385698, 0.2609815145734389, 0.18127297647829888, 0.1957417735940552, 0.22920999827866495, 0.18310000474785193, 0.193110013501813, 0.27693749544418755, 0.11368476511095227, 0.2043950030984022, 0.220306450983471, 0.16484688126919844, 0.16381494823035447, 0.18179600745406732, 0.14778597331998222, 0.30639582001449794, 0.27031080642673355, 0.3372871936467656, 0.33126944253156676, 0.3168027670970488, 0.36890694251841194, 0.2710681818949614, 0.3304548812663224, 0.2636668768734898, 0.399363666198819, 0.4391896350173363, 0.4251106318701794, 0.3957391328356439, 0.4173071637112098, 0.49114169125133744, 0.4571763095341902, 0.44105907891793006, 0.47543054954069286, 0.06983850752350995, 0.20587215387818425, 0.20247406425544145, 0.16216146868714298, 0.16946602502848995, 0.1167350874180072, 0.18066366226210884, 0.10466453986036195, 0.08431960773622249, 0.29775472663503366, 0.2701635789954244, 0.2961391035212847, 0.26748150670562176, 0.3418746895885989, 0.26193853866475514, 0.2980231606880872, 0.2481920681467945, 0.29270775966039486, 0.6392765826679037, 0.6490275061328654, 0.6434311797354066, 0.6101548565800816, 0.6705163158216997, 0.581715485322932, 0.6302372799063853, 0.6572822223214339, 0.63667360276885, 0.10946979306955906, 0.10495685013288236, 0.09854458937774613, 0.09716371232282162, 0.11476060783481101, 0.10180537332611694, 0.08978362639479653, 0.09895539925489538, 0.10411653850132274, 0.2633268434969652, 0.1788873209645211, 0.2264473851374672, 0.2507217028230929, 0.17913228377985901, 0.22891227141535053, 0.19110001644461017, 0.2139585020176098, 0.18290495053256972, 0.4135147594879234, 0.42148645148468744, 0.4163750662420447, 0.3786119686270838, 0.4413315433472095, 0.3775701429488637, 0.43907987101758084, 0.4406275496723362, 0.3647495752161902, 0.35104771272631796, 0.32129370837133686, 0.3145722381892989, 0.2977847102879454, 0.2975529999725195, 0.28898620252116314, 0.3137956181835322, 0.3267581533766173, 0.3330980920336182, 0.1898882779819978, 0.1905400773304492, 0.18545963849958857, 0.18856014300619717, 0.21931369012724744, 0.1990457180226365, 0.20889701508602687, 0.17918548645071464, 0.18996285541952096, 0.23642946213293792, 0.3927603564406512, 0.24749623807951637, 0.19193963824809768, 0.18219160787894084, 0.21713294923741522, 0.221165022732153, 0.2170824145776833, 0.21595790950359184, 0.6431133147940391, 0.7910116517369107, 0.1526494517286039, 0.18367854971517794, 0.20943985436351187, 0.1959939509921974, 0.18284803815092687, 0.6095864501996766, 0.734668736213713, 0.6901716059296701, 0.20955375555447575, 0.6708621482076059, 0.6562094333851947, 0.7065753248293243, 0.2060075346519048, 0.749621608307204, 0.7240217086130991, 0.20907996605188905, 0.18263625118278404, 0.19256000426655284, 0.17657819589137957, 0.17729311771949818, 0.1922495866517835, 0.1990523094758524, 0.18017600315779692, 0.16894604412663083, 0.18586734217102652, 0.08068749109015605, 0.08347801844548375, 0.0782340926600047, 0.08345049371297841, 0.07374025617519131, 0.08647786369411792, 0.08067671222228345, 0.08609957232088361, 0.09423657106271999]}, "mutation_prompt": null}
{"id": "03c421de-81bf-4ca8-bf37-0e36fcaaf859", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring a dynamic population size to enhance convergence speed.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8678eecb-2fc1-4c26-9fab-ffcefc4aa9aa", "metadata": {"aucs": [0.7405973988741354, 0.7281226209939119, 0.7324233204340155, 0.7489552261542903, 0.7498559026369704, 0.757519831874169, 0.7347098623601342, 0.7602786636377387, 0.7377784648945536, 0.56554125587102, 0.5944505024215752, 0.5808904441751737, 0.5747972667444257, 0.5671564195916405, 0.5961916655424153, 0.5838793849099935, 0.5852024604491162, 0.6063062861246697, 0.11341909746813339, 0.12215541600561153, 0.10085692900524679, 0.10487565508288299, 0.11036818339911192, 0.1016077518681705, 0.13666213112505554, 0.12709043286256294, 0.10861595266627522, 0.10165318727335015, 0.10505953366608245, 0.09783802420298959, 0.10172217148102114, 0.10536819228798322, 0.10900367665295507, 0.0964455393395891, 0.09024177262467925, 0.10437305516394613, 0.9548869183682216, 0.9816209304069197, 0.9712607491984208, 0.9634026914341834, 0.9234496339538826, 0.9622203012390651, 0.985079184370999, 0.9582775702855542, 0.9611271121617417, 0.4313765997319954, 0.4618145994111096, 0.40984676643380813, 0.41472757262044546, 0.36354377548699346, 0.3986783408643845, 0.4379164888621577, 0.40934147613419813, 0.35998487468993845, 0.6806130514358448, 0.6955121767822976, 0.6866807490914777, 0.6701999875888693, 0.6347825436279659, 0.6646026866550377, 0.6567034530055915, 0.6819668428073227, 0.6865650804245118, 0.24016363313740974, 0.22090206531540513, 0.17297907809772384, 0.19886709320385698, 0.2609815145734389, 0.18127297647829888, 0.1957417735940552, 0.22920999827866495, 0.18310000474785193, 0.193110013501813, 0.27693749544418755, 0.11368476511095227, 0.2043950030984022, 0.220306450983471, 0.16484688126919844, 0.16381494823035447, 0.18179600745406732, 0.14778597331998222, 0.30639582001449794, 0.27031080642673355, 0.3372871936467656, 0.33126944253156676, 0.3168027670970488, 0.36890694251841194, 0.2710681818949614, 0.3304548812663224, 0.2636668768734898, 0.399363666198819, 0.4391896350173363, 0.4251106318701794, 0.3957391328356439, 0.4173071637112098, 0.49114169125133744, 0.4571763095341902, 0.44105907891793006, 0.47543054954069286, 0.06983850752350995, 0.20587215387818425, 0.20247406425544145, 0.16216146868714298, 0.16946602502848995, 0.1167350874180072, 0.18066366226210884, 0.10466453986036195, 0.08431960773622249, 0.29775472663503366, 0.2701635789954244, 0.2961391035212847, 0.26748150670562176, 0.3418746895885989, 0.26193853866475514, 0.2980231606880872, 0.2481920681467945, 0.29270775966039486, 0.6392765826679037, 0.6490275061328654, 0.6434311797354066, 0.6101548565800816, 0.6705163158216997, 0.581715485322932, 0.6302372799063853, 0.6572822223214339, 0.63667360276885, 0.10946979306955906, 0.10495685013288236, 0.09854458937774613, 0.09716371232282162, 0.11476060783481101, 0.10180537332611694, 0.08978362639479653, 0.09895539925489538, 0.10411653850132274, 0.2633268434969652, 0.1788873209645211, 0.2264473851374672, 0.2507217028230929, 0.17913228377985901, 0.22891227141535053, 0.19110001644461017, 0.2139585020176098, 0.18290495053256972, 0.4135147594879234, 0.42148645148468744, 0.4163750662420447, 0.3786119686270838, 0.4413315433472095, 0.3775701429488637, 0.43907987101758084, 0.4406275496723362, 0.3647495752161902, 0.35104771272631796, 0.32129370837133686, 0.3145722381892989, 0.2977847102879454, 0.2975529999725195, 0.28898620252116314, 0.3137956181835322, 0.3267581533766173, 0.3330980920336182, 0.1898882779819978, 0.1905400773304492, 0.18545963849958857, 0.18856014300619717, 0.21931369012724744, 0.1990457180226365, 0.20889701508602687, 0.17918548645071464, 0.18996285541952096, 0.23642946213293792, 0.3927603564406512, 0.24749623807951637, 0.19193963824809768, 0.18219160787894084, 0.21713294923741522, 0.221165022732153, 0.2170824145776833, 0.21595790950359184, 0.6431133147940391, 0.7910116517369107, 0.1526494517286039, 0.18367854971517794, 0.20943985436351187, 0.1959939509921974, 0.18284803815092687, 0.6095864501996766, 0.734668736213713, 0.6901716059296701, 0.20955375555447575, 0.6708621482076059, 0.6562094333851947, 0.7065753248293243, 0.2060075346519048, 0.749621608307204, 0.7240217086130991, 0.20907996605188905, 0.18263625118278404, 0.19256000426655284, 0.17657819589137957, 0.17729311771949818, 0.1922495866517835, 0.1990523094758524, 0.18017600315779692, 0.16894604412663083, 0.18586734217102652, 0.08068749109015605, 0.08347801844548375, 0.0782340926600047, 0.08345049371297841, 0.07374025617519131, 0.08647786369411792, 0.08067671222228345, 0.08609957232088361, 0.09423657106271999]}, "mutation_prompt": null}
{"id": "4fc465a1-292e-4db9-aeee-4d383b4647bb", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring a dynamic population size to enhance convergence speed.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8678eecb-2fc1-4c26-9fab-ffcefc4aa9aa", "metadata": {"aucs": [0.7405973988741354, 0.7281226209939119, 0.7324233204340155, 0.7489552261542903, 0.7498559026369704, 0.757519831874169, 0.7347098623601342, 0.7602786636377387, 0.7377784648945536, 0.56554125587102, 0.5944505024215752, 0.5808904441751737, 0.5747972667444257, 0.5671564195916405, 0.5961916655424153, 0.5838793849099935, 0.5852024604491162, 0.6063062861246697, 0.11341909746813339, 0.12215541600561153, 0.10085692900524679, 0.10487565508288299, 0.11036818339911192, 0.1016077518681705, 0.13666213112505554, 0.12709043286256294, 0.10861595266627522, 0.10165318727335015, 0.10505953366608245, 0.09783802420298959, 0.10172217148102114, 0.10536819228798322, 0.10900367665295507, 0.0964455393395891, 0.09024177262467925, 0.10437305516394613, 0.9548869183682216, 0.9816209304069197, 0.9712607491984208, 0.9634026914341834, 0.9234496339538826, 0.9622203012390651, 0.985079184370999, 0.9582775702855542, 0.9611271121617417, 0.4313765997319954, 0.4618145994111096, 0.40984676643380813, 0.41472757262044546, 0.36354377548699346, 0.3986783408643845, 0.4379164888621577, 0.40934147613419813, 0.35998487468993845, 0.6806130514358448, 0.6955121767822976, 0.6866807490914777, 0.6701999875888693, 0.6347825436279659, 0.6646026866550377, 0.6567034530055915, 0.6819668428073227, 0.6865650804245118, 0.24016363313740974, 0.22090206531540513, 0.17297907809772384, 0.19886709320385698, 0.2609815145734389, 0.18127297647829888, 0.1957417735940552, 0.22920999827866495, 0.18310000474785193, 0.193110013501813, 0.27693749544418755, 0.11368476511095227, 0.2043950030984022, 0.220306450983471, 0.16484688126919844, 0.16381494823035447, 0.18179600745406732, 0.14778597331998222, 0.30639582001449794, 0.27031080642673355, 0.3372871936467656, 0.33126944253156676, 0.3168027670970488, 0.36890694251841194, 0.2710681818949614, 0.3304548812663224, 0.2636668768734898, 0.399363666198819, 0.4391896350173363, 0.4251106318701794, 0.3957391328356439, 0.4173071637112098, 0.49114169125133744, 0.4571763095341902, 0.44105907891793006, 0.47543054954069286, 0.06983850752350995, 0.20587215387818425, 0.20247406425544145, 0.16216146868714298, 0.16946602502848995, 0.1167350874180072, 0.18066366226210884, 0.10466453986036195, 0.08431960773622249, 0.29775472663503366, 0.2701635789954244, 0.2961391035212847, 0.26748150670562176, 0.3418746895885989, 0.26193853866475514, 0.2980231606880872, 0.2481920681467945, 0.29270775966039486, 0.6392765826679037, 0.6490275061328654, 0.6434311797354066, 0.6101548565800816, 0.6705163158216997, 0.581715485322932, 0.6302372799063853, 0.6572822223214339, 0.63667360276885, 0.10946979306955906, 0.10495685013288236, 0.09854458937774613, 0.09716371232282162, 0.11476060783481101, 0.10180537332611694, 0.08978362639479653, 0.09895539925489538, 0.10411653850132274, 0.2633268434969652, 0.1788873209645211, 0.2264473851374672, 0.2507217028230929, 0.17913228377985901, 0.22891227141535053, 0.19110001644461017, 0.2139585020176098, 0.18290495053256972, 0.4135147594879234, 0.42148645148468744, 0.4163750662420447, 0.3786119686270838, 0.4413315433472095, 0.3775701429488637, 0.43907987101758084, 0.4406275496723362, 0.3647495752161902, 0.35104771272631796, 0.32129370837133686, 0.3145722381892989, 0.2977847102879454, 0.2975529999725195, 0.28898620252116314, 0.3137956181835322, 0.3267581533766173, 0.3330980920336182, 0.1898882779819978, 0.1905400773304492, 0.18545963849958857, 0.18856014300619717, 0.21931369012724744, 0.1990457180226365, 0.20889701508602687, 0.17918548645071464, 0.18996285541952096, 0.23642946213293792, 0.3927603564406512, 0.24749623807951637, 0.19193963824809768, 0.18219160787894084, 0.21713294923741522, 0.221165022732153, 0.2170824145776833, 0.21595790950359184, 0.6431133147940391, 0.7910116517369107, 0.1526494517286039, 0.18367854971517794, 0.20943985436351187, 0.1959939509921974, 0.18284803815092687, 0.6095864501996766, 0.734668736213713, 0.6901716059296701, 0.20955375555447575, 0.6708621482076059, 0.6562094333851947, 0.7065753248293243, 0.2060075346519048, 0.749621608307204, 0.7240217086130991, 0.20907996605188905, 0.18263625118278404, 0.19256000426655284, 0.17657819589137957, 0.17729311771949818, 0.1922495866517835, 0.1990523094758524, 0.18017600315779692, 0.16894604412663083, 0.18586734217102652, 0.08068749109015605, 0.08347801844548375, 0.0782340926600047, 0.08345049371297841, 0.07374025617519131, 0.08647786369411792, 0.08067671222228345, 0.08609957232088361, 0.09423657106271999]}, "mutation_prompt": null}
{"id": "39e794f7-accc-4191-b9d7-8beb2c48ae28", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring a dynamic population size to enhance convergence speed.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8678eecb-2fc1-4c26-9fab-ffcefc4aa9aa", "metadata": {"aucs": [0.7405973988741354, 0.7281226209939119, 0.7324233204340155, 0.7489552261542903, 0.7498559026369704, 0.757519831874169, 0.7347098623601342, 0.7602786636377387, 0.7377784648945536, 0.56554125587102, 0.5944505024215752, 0.5808904441751737, 0.5747972667444257, 0.5671564195916405, 0.5961916655424153, 0.5838793849099935, 0.5852024604491162, 0.6063062861246697, 0.11341909746813339, 0.12215541600561153, 0.10085692900524679, 0.10487565508288299, 0.11036818339911192, 0.1016077518681705, 0.13666213112505554, 0.12709043286256294, 0.10861595266627522, 0.10165318727335015, 0.10505953366608245, 0.09783802420298959, 0.10172217148102114, 0.10536819228798322, 0.10900367665295507, 0.0964455393395891, 0.09024177262467925, 0.10437305516394613, 0.9548869183682216, 0.9816209304069197, 0.9712607491984208, 0.9634026914341834, 0.9234496339538826, 0.9622203012390651, 0.985079184370999, 0.9582775702855542, 0.9611271121617417, 0.4313765997319954, 0.4618145994111096, 0.40984676643380813, 0.41472757262044546, 0.36354377548699346, 0.3986783408643845, 0.4379164888621577, 0.40934147613419813, 0.35998487468993845, 0.6806130514358448, 0.6955121767822976, 0.6866807490914777, 0.6701999875888693, 0.6347825436279659, 0.6646026866550377, 0.6567034530055915, 0.6819668428073227, 0.6865650804245118, 0.24016363313740974, 0.22090206531540513, 0.17297907809772384, 0.19886709320385698, 0.2609815145734389, 0.18127297647829888, 0.1957417735940552, 0.22920999827866495, 0.18310000474785193, 0.193110013501813, 0.27693749544418755, 0.11368476511095227, 0.2043950030984022, 0.220306450983471, 0.16484688126919844, 0.16381494823035447, 0.18179600745406732, 0.14778597331998222, 0.30639582001449794, 0.27031080642673355, 0.3372871936467656, 0.33126944253156676, 0.3168027670970488, 0.36890694251841194, 0.2710681818949614, 0.3304548812663224, 0.2636668768734898, 0.399363666198819, 0.4391896350173363, 0.4251106318701794, 0.3957391328356439, 0.4173071637112098, 0.49114169125133744, 0.4571763095341902, 0.44105907891793006, 0.47543054954069286, 0.06983850752350995, 0.20587215387818425, 0.20247406425544145, 0.16216146868714298, 0.16946602502848995, 0.1167350874180072, 0.18066366226210884, 0.10466453986036195, 0.08431960773622249, 0.29775472663503366, 0.2701635789954244, 0.2961391035212847, 0.26748150670562176, 0.3418746895885989, 0.26193853866475514, 0.2980231606880872, 0.2481920681467945, 0.29270775966039486, 0.6392765826679037, 0.6490275061328654, 0.6434311797354066, 0.6101548565800816, 0.6705163158216997, 0.581715485322932, 0.6302372799063853, 0.6572822223214339, 0.63667360276885, 0.10946979306955906, 0.10495685013288236, 0.09854458937774613, 0.09716371232282162, 0.11476060783481101, 0.10180537332611694, 0.08978362639479653, 0.09895539925489538, 0.10411653850132274, 0.2633268434969652, 0.1788873209645211, 0.2264473851374672, 0.2507217028230929, 0.17913228377985901, 0.22891227141535053, 0.19110001644461017, 0.2139585020176098, 0.18290495053256972, 0.4135147594879234, 0.42148645148468744, 0.4163750662420447, 0.3786119686270838, 0.4413315433472095, 0.3775701429488637, 0.43907987101758084, 0.4406275496723362, 0.3647495752161902, 0.35104771272631796, 0.32129370837133686, 0.3145722381892989, 0.2977847102879454, 0.2975529999725195, 0.28898620252116314, 0.3137956181835322, 0.3267581533766173, 0.3330980920336182, 0.1898882779819978, 0.1905400773304492, 0.18545963849958857, 0.18856014300619717, 0.21931369012724744, 0.1990457180226365, 0.20889701508602687, 0.17918548645071464, 0.18996285541952096, 0.23642946213293792, 0.3927603564406512, 0.24749623807951637, 0.19193963824809768, 0.18219160787894084, 0.21713294923741522, 0.221165022732153, 0.2170824145776833, 0.21595790950359184, 0.6431133147940391, 0.7910116517369107, 0.1526494517286039, 0.18367854971517794, 0.20943985436351187, 0.1959939509921974, 0.18284803815092687, 0.6095864501996766, 0.734668736213713, 0.6901716059296701, 0.20955375555447575, 0.6708621482076059, 0.6562094333851947, 0.7065753248293243, 0.2060075346519048, 0.749621608307204, 0.7240217086130991, 0.20907996605188905, 0.18263625118278404, 0.19256000426655284, 0.17657819589137957, 0.17729311771949818, 0.1922495866517835, 0.1990523094758524, 0.18017600315779692, 0.16894604412663083, 0.18586734217102652, 0.08068749109015605, 0.08347801844548375, 0.0782340926600047, 0.08345049371297841, 0.07374025617519131, 0.08647786369411792, 0.08067671222228345, 0.08609957232088361, 0.09423657106271999]}, "mutation_prompt": null}
{"id": "0b90c54e-7aef-453f-aab9-87b58c454c0f", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring a dynamic population size to enhance convergence speed.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8678eecb-2fc1-4c26-9fab-ffcefc4aa9aa", "metadata": {"aucs": [0.7405973988741354, 0.7281226209939119, 0.7324233204340155, 0.7489552261542903, 0.7498559026369704, 0.757519831874169, 0.7347098623601342, 0.7602786636377387, 0.7377784648945536, 0.56554125587102, 0.5944505024215752, 0.5808904441751737, 0.5747972667444257, 0.5671564195916405, 0.5961916655424153, 0.5838793849099935, 0.5852024604491162, 0.6063062861246697, 0.11341909746813339, 0.12215541600561153, 0.10085692900524679, 0.10487565508288299, 0.11036818339911192, 0.1016077518681705, 0.13666213112505554, 0.12709043286256294, 0.10861595266627522, 0.10165318727335015, 0.10505953366608245, 0.09783802420298959, 0.10172217148102114, 0.10536819228798322, 0.10900367665295507, 0.0964455393395891, 0.09024177262467925, 0.10437305516394613, 0.9548869183682216, 0.9816209304069197, 0.9712607491984208, 0.9634026914341834, 0.9234496339538826, 0.9622203012390651, 0.985079184370999, 0.9582775702855542, 0.9611271121617417, 0.4313765997319954, 0.4618145994111096, 0.40984676643380813, 0.41472757262044546, 0.36354377548699346, 0.3986783408643845, 0.4379164888621577, 0.40934147613419813, 0.35998487468993845, 0.6806130514358448, 0.6955121767822976, 0.6866807490914777, 0.6701999875888693, 0.6347825436279659, 0.6646026866550377, 0.6567034530055915, 0.6819668428073227, 0.6865650804245118, 0.24016363313740974, 0.22090206531540513, 0.17297907809772384, 0.19886709320385698, 0.2609815145734389, 0.18127297647829888, 0.1957417735940552, 0.22920999827866495, 0.18310000474785193, 0.193110013501813, 0.27693749544418755, 0.11368476511095227, 0.2043950030984022, 0.220306450983471, 0.16484688126919844, 0.16381494823035447, 0.18179600745406732, 0.14778597331998222, 0.30639582001449794, 0.27031080642673355, 0.3372871936467656, 0.33126944253156676, 0.3168027670970488, 0.36890694251841194, 0.2710681818949614, 0.3304548812663224, 0.2636668768734898, 0.399363666198819, 0.4391896350173363, 0.4251106318701794, 0.3957391328356439, 0.4173071637112098, 0.49114169125133744, 0.4571763095341902, 0.44105907891793006, 0.47543054954069286, 0.06983850752350995, 0.20587215387818425, 0.20247406425544145, 0.16216146868714298, 0.16946602502848995, 0.1167350874180072, 0.18066366226210884, 0.10466453986036195, 0.08431960773622249, 0.29775472663503366, 0.2701635789954244, 0.2961391035212847, 0.26748150670562176, 0.3418746895885989, 0.26193853866475514, 0.2980231606880872, 0.2481920681467945, 0.29270775966039486, 0.6392765826679037, 0.6490275061328654, 0.6434311797354066, 0.6101548565800816, 0.6705163158216997, 0.581715485322932, 0.6302372799063853, 0.6572822223214339, 0.63667360276885, 0.10946979306955906, 0.10495685013288236, 0.09854458937774613, 0.09716371232282162, 0.11476060783481101, 0.10180537332611694, 0.08978362639479653, 0.09895539925489538, 0.10411653850132274, 0.2633268434969652, 0.1788873209645211, 0.2264473851374672, 0.2507217028230929, 0.17913228377985901, 0.22891227141535053, 0.19110001644461017, 0.2139585020176098, 0.18290495053256972, 0.4135147594879234, 0.42148645148468744, 0.4163750662420447, 0.3786119686270838, 0.4413315433472095, 0.3775701429488637, 0.43907987101758084, 0.4406275496723362, 0.3647495752161902, 0.35104771272631796, 0.32129370837133686, 0.3145722381892989, 0.2977847102879454, 0.2975529999725195, 0.28898620252116314, 0.3137956181835322, 0.3267581533766173, 0.3330980920336182, 0.1898882779819978, 0.1905400773304492, 0.18545963849958857, 0.18856014300619717, 0.21931369012724744, 0.1990457180226365, 0.20889701508602687, 0.17918548645071464, 0.18996285541952096, 0.23642946213293792, 0.3927603564406512, 0.24749623807951637, 0.19193963824809768, 0.18219160787894084, 0.21713294923741522, 0.221165022732153, 0.2170824145776833, 0.21595790950359184, 0.6431133147940391, 0.7910116517369107, 0.1526494517286039, 0.18367854971517794, 0.20943985436351187, 0.1959939509921974, 0.18284803815092687, 0.6095864501996766, 0.734668736213713, 0.6901716059296701, 0.20955375555447575, 0.6708621482076059, 0.6562094333851947, 0.7065753248293243, 0.2060075346519048, 0.749621608307204, 0.7240217086130991, 0.20907996605188905, 0.18263625118278404, 0.19256000426655284, 0.17657819589137957, 0.17729311771949818, 0.1922495866517835, 0.1990523094758524, 0.18017600315779692, 0.16894604412663083, 0.18586734217102652, 0.08068749109015605, 0.08347801844548375, 0.0782340926600047, 0.08345049371297841, 0.07374025617519131, 0.08647786369411792, 0.08067671222228345, 0.08609957232088361, 0.09423657106271999]}, "mutation_prompt": null}
{"id": "303ea6fb-ba63-4e2a-9ad9-422fec307823", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring a dynamic population size to enhance convergence speed.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8678eecb-2fc1-4c26-9fab-ffcefc4aa9aa", "metadata": {"aucs": [0.7405973988741354, 0.7281226209939119, 0.7324233204340155, 0.7489552261542903, 0.7498559026369704, 0.757519831874169, 0.7347098623601342, 0.7602786636377387, 0.7377784648945536, 0.56554125587102, 0.5944505024215752, 0.5808904441751737, 0.5747972667444257, 0.5671564195916405, 0.5961916655424153, 0.5838793849099935, 0.5852024604491162, 0.6063062861246697, 0.11341909746813339, 0.12215541600561153, 0.10085692900524679, 0.10487565508288299, 0.11036818339911192, 0.1016077518681705, 0.13666213112505554, 0.12709043286256294, 0.10861595266627522, 0.10165318727335015, 0.10505953366608245, 0.09783802420298959, 0.10172217148102114, 0.10536819228798322, 0.10900367665295507, 0.0964455393395891, 0.09024177262467925, 0.10437305516394613, 0.9548869183682216, 0.9816209304069197, 0.9712607491984208, 0.9634026914341834, 0.9234496339538826, 0.9622203012390651, 0.985079184370999, 0.9582775702855542, 0.9611271121617417, 0.4313765997319954, 0.4618145994111096, 0.40984676643380813, 0.41472757262044546, 0.36354377548699346, 0.3986783408643845, 0.4379164888621577, 0.40934147613419813, 0.35998487468993845, 0.6806130514358448, 0.6955121767822976, 0.6866807490914777, 0.6701999875888693, 0.6347825436279659, 0.6646026866550377, 0.6567034530055915, 0.6819668428073227, 0.6865650804245118, 0.24016363313740974, 0.22090206531540513, 0.17297907809772384, 0.19886709320385698, 0.2609815145734389, 0.18127297647829888, 0.1957417735940552, 0.22920999827866495, 0.18310000474785193, 0.193110013501813, 0.27693749544418755, 0.11368476511095227, 0.2043950030984022, 0.220306450983471, 0.16484688126919844, 0.16381494823035447, 0.18179600745406732, 0.14778597331998222, 0.30639582001449794, 0.27031080642673355, 0.3372871936467656, 0.33126944253156676, 0.3168027670970488, 0.36890694251841194, 0.2710681818949614, 0.3304548812663224, 0.2636668768734898, 0.399363666198819, 0.4391896350173363, 0.4251106318701794, 0.3957391328356439, 0.4173071637112098, 0.49114169125133744, 0.4571763095341902, 0.44105907891793006, 0.47543054954069286, 0.06983850752350995, 0.20587215387818425, 0.20247406425544145, 0.16216146868714298, 0.16946602502848995, 0.1167350874180072, 0.18066366226210884, 0.10466453986036195, 0.08431960773622249, 0.29775472663503366, 0.2701635789954244, 0.2961391035212847, 0.26748150670562176, 0.3418746895885989, 0.26193853866475514, 0.2980231606880872, 0.2481920681467945, 0.29270775966039486, 0.6392765826679037, 0.6490275061328654, 0.6434311797354066, 0.6101548565800816, 0.6705163158216997, 0.581715485322932, 0.6302372799063853, 0.6572822223214339, 0.63667360276885, 0.10946979306955906, 0.10495685013288236, 0.09854458937774613, 0.09716371232282162, 0.11476060783481101, 0.10180537332611694, 0.08978362639479653, 0.09895539925489538, 0.10411653850132274, 0.2633268434969652, 0.1788873209645211, 0.2264473851374672, 0.2507217028230929, 0.17913228377985901, 0.22891227141535053, 0.19110001644461017, 0.2139585020176098, 0.18290495053256972, 0.4135147594879234, 0.42148645148468744, 0.4163750662420447, 0.3786119686270838, 0.4413315433472095, 0.3775701429488637, 0.43907987101758084, 0.4406275496723362, 0.3647495752161902, 0.35104771272631796, 0.32129370837133686, 0.3145722381892989, 0.2977847102879454, 0.2975529999725195, 0.28898620252116314, 0.3137956181835322, 0.3267581533766173, 0.3330980920336182, 0.1898882779819978, 0.1905400773304492, 0.18545963849958857, 0.18856014300619717, 0.21931369012724744, 0.1990457180226365, 0.20889701508602687, 0.17918548645071464, 0.18996285541952096, 0.23642946213293792, 0.3927603564406512, 0.24749623807951637, 0.19193963824809768, 0.18219160787894084, 0.21713294923741522, 0.221165022732153, 0.2170824145776833, 0.21595790950359184, 0.6431133147940391, 0.7910116517369107, 0.1526494517286039, 0.18367854971517794, 0.20943985436351187, 0.1959939509921974, 0.18284803815092687, 0.6095864501996766, 0.734668736213713, 0.6901716059296701, 0.20955375555447575, 0.6708621482076059, 0.6562094333851947, 0.7065753248293243, 0.2060075346519048, 0.749621608307204, 0.7240217086130991, 0.20907996605188905, 0.18263625118278404, 0.19256000426655284, 0.17657819589137957, 0.17729311771949818, 0.1922495866517835, 0.1990523094758524, 0.18017600315779692, 0.16894604412663083, 0.18586734217102652, 0.08068749109015605, 0.08347801844548375, 0.0782340926600047, 0.08345049371297841, 0.07374025617519131, 0.08647786369411792, 0.08067671222228345, 0.08609957232088361, 0.09423657106271999]}, "mutation_prompt": null}
{"id": "7d0d7d40-4098-401d-8271-de539382711c", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring a dynamic population size to enhance convergence speed.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8678eecb-2fc1-4c26-9fab-ffcefc4aa9aa", "metadata": {"aucs": [0.7405973988741354, 0.7281226209939119, 0.7324233204340155, 0.7489552261542903, 0.7498559026369704, 0.757519831874169, 0.7347098623601342, 0.7602786636377387, 0.7377784648945536, 0.56554125587102, 0.5944505024215752, 0.5808904441751737, 0.5747972667444257, 0.5671564195916405, 0.5961916655424153, 0.5838793849099935, 0.5852024604491162, 0.6063062861246697, 0.11341909746813339, 0.12215541600561153, 0.10085692900524679, 0.10487565508288299, 0.11036818339911192, 0.1016077518681705, 0.13666213112505554, 0.12709043286256294, 0.10861595266627522, 0.10165318727335015, 0.10505953366608245, 0.09783802420298959, 0.10172217148102114, 0.10536819228798322, 0.10900367665295507, 0.0964455393395891, 0.09024177262467925, 0.10437305516394613, 0.9548869183682216, 0.9816209304069197, 0.9712607491984208, 0.9634026914341834, 0.9234496339538826, 0.9622203012390651, 0.985079184370999, 0.9582775702855542, 0.9611271121617417, 0.4313765997319954, 0.4618145994111096, 0.40984676643380813, 0.41472757262044546, 0.36354377548699346, 0.3986783408643845, 0.4379164888621577, 0.40934147613419813, 0.35998487468993845, 0.6806130514358448, 0.6955121767822976, 0.6866807490914777, 0.6701999875888693, 0.6347825436279659, 0.6646026866550377, 0.6567034530055915, 0.6819668428073227, 0.6865650804245118, 0.24016363313740974, 0.22090206531540513, 0.17297907809772384, 0.19886709320385698, 0.2609815145734389, 0.18127297647829888, 0.1957417735940552, 0.22920999827866495, 0.18310000474785193, 0.193110013501813, 0.27693749544418755, 0.11368476511095227, 0.2043950030984022, 0.220306450983471, 0.16484688126919844, 0.16381494823035447, 0.18179600745406732, 0.14778597331998222, 0.30639582001449794, 0.27031080642673355, 0.3372871936467656, 0.33126944253156676, 0.3168027670970488, 0.36890694251841194, 0.2710681818949614, 0.3304548812663224, 0.2636668768734898, 0.399363666198819, 0.4391896350173363, 0.4251106318701794, 0.3957391328356439, 0.4173071637112098, 0.49114169125133744, 0.4571763095341902, 0.44105907891793006, 0.47543054954069286, 0.06983850752350995, 0.20587215387818425, 0.20247406425544145, 0.16216146868714298, 0.16946602502848995, 0.1167350874180072, 0.18066366226210884, 0.10466453986036195, 0.08431960773622249, 0.29775472663503366, 0.2701635789954244, 0.2961391035212847, 0.26748150670562176, 0.3418746895885989, 0.26193853866475514, 0.2980231606880872, 0.2481920681467945, 0.29270775966039486, 0.6392765826679037, 0.6490275061328654, 0.6434311797354066, 0.6101548565800816, 0.6705163158216997, 0.581715485322932, 0.6302372799063853, 0.6572822223214339, 0.63667360276885, 0.10946979306955906, 0.10495685013288236, 0.09854458937774613, 0.09716371232282162, 0.11476060783481101, 0.10180537332611694, 0.08978362639479653, 0.09895539925489538, 0.10411653850132274, 0.2633268434969652, 0.1788873209645211, 0.2264473851374672, 0.2507217028230929, 0.17913228377985901, 0.22891227141535053, 0.19110001644461017, 0.2139585020176098, 0.18290495053256972, 0.4135147594879234, 0.42148645148468744, 0.4163750662420447, 0.3786119686270838, 0.4413315433472095, 0.3775701429488637, 0.43907987101758084, 0.4406275496723362, 0.3647495752161902, 0.35104771272631796, 0.32129370837133686, 0.3145722381892989, 0.2977847102879454, 0.2975529999725195, 0.28898620252116314, 0.3137956181835322, 0.3267581533766173, 0.3330980920336182, 0.1898882779819978, 0.1905400773304492, 0.18545963849958857, 0.18856014300619717, 0.21931369012724744, 0.1990457180226365, 0.20889701508602687, 0.17918548645071464, 0.18996285541952096, 0.23642946213293792, 0.3927603564406512, 0.24749623807951637, 0.19193963824809768, 0.18219160787894084, 0.21713294923741522, 0.221165022732153, 0.2170824145776833, 0.21595790950359184, 0.6431133147940391, 0.7910116517369107, 0.1526494517286039, 0.18367854971517794, 0.20943985436351187, 0.1959939509921974, 0.18284803815092687, 0.6095864501996766, 0.734668736213713, 0.6901716059296701, 0.20955375555447575, 0.6708621482076059, 0.6562094333851947, 0.7065753248293243, 0.2060075346519048, 0.749621608307204, 0.7240217086130991, 0.20907996605188905, 0.18263625118278404, 0.19256000426655284, 0.17657819589137957, 0.17729311771949818, 0.1922495866517835, 0.1990523094758524, 0.18017600315779692, 0.16894604412663083, 0.18586734217102652, 0.08068749109015605, 0.08347801844548375, 0.0782340926600047, 0.08345049371297841, 0.07374025617519131, 0.08647786369411792, 0.08067671222228345, 0.08609957232088361, 0.09423657106271999]}, "mutation_prompt": null}
{"id": "67a5e41b-415a-43a0-846a-2c08af0032e6", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring a dynamic population size to enhance convergence speed.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8678eecb-2fc1-4c26-9fab-ffcefc4aa9aa", "metadata": {"aucs": [0.7405973988741354, 0.7281226209939119, 0.7324233204340155, 0.7489552261542903, 0.7498559026369704, 0.757519831874169, 0.7347098623601342, 0.7602786636377387, 0.7377784648945536, 0.56554125587102, 0.5944505024215752, 0.5808904441751737, 0.5747972667444257, 0.5671564195916405, 0.5961916655424153, 0.5838793849099935, 0.5852024604491162, 0.6063062861246697, 0.11341909746813339, 0.12215541600561153, 0.10085692900524679, 0.10487565508288299, 0.11036818339911192, 0.1016077518681705, 0.13666213112505554, 0.12709043286256294, 0.10861595266627522, 0.10165318727335015, 0.10505953366608245, 0.09783802420298959, 0.10172217148102114, 0.10536819228798322, 0.10900367665295507, 0.0964455393395891, 0.09024177262467925, 0.10437305516394613, 0.9548869183682216, 0.9816209304069197, 0.9712607491984208, 0.9634026914341834, 0.9234496339538826, 0.9622203012390651, 0.985079184370999, 0.9582775702855542, 0.9611271121617417, 0.4313765997319954, 0.4618145994111096, 0.40984676643380813, 0.41472757262044546, 0.36354377548699346, 0.3986783408643845, 0.4379164888621577, 0.40934147613419813, 0.35998487468993845, 0.6806130514358448, 0.6955121767822976, 0.6866807490914777, 0.6701999875888693, 0.6347825436279659, 0.6646026866550377, 0.6567034530055915, 0.6819668428073227, 0.6865650804245118, 0.24016363313740974, 0.22090206531540513, 0.17297907809772384, 0.19886709320385698, 0.2609815145734389, 0.18127297647829888, 0.1957417735940552, 0.22920999827866495, 0.18310000474785193, 0.193110013501813, 0.27693749544418755, 0.11368476511095227, 0.2043950030984022, 0.220306450983471, 0.16484688126919844, 0.16381494823035447, 0.18179600745406732, 0.14778597331998222, 0.30639582001449794, 0.27031080642673355, 0.3372871936467656, 0.33126944253156676, 0.3168027670970488, 0.36890694251841194, 0.2710681818949614, 0.3304548812663224, 0.2636668768734898, 0.399363666198819, 0.4391896350173363, 0.4251106318701794, 0.3957391328356439, 0.4173071637112098, 0.49114169125133744, 0.4571763095341902, 0.44105907891793006, 0.47543054954069286, 0.06983850752350995, 0.20587215387818425, 0.20247406425544145, 0.16216146868714298, 0.16946602502848995, 0.1167350874180072, 0.18066366226210884, 0.10466453986036195, 0.08431960773622249, 0.29775472663503366, 0.2701635789954244, 0.2961391035212847, 0.26748150670562176, 0.3418746895885989, 0.26193853866475514, 0.2980231606880872, 0.2481920681467945, 0.29270775966039486, 0.6392765826679037, 0.6490275061328654, 0.6434311797354066, 0.6101548565800816, 0.6705163158216997, 0.581715485322932, 0.6302372799063853, 0.6572822223214339, 0.63667360276885, 0.10946979306955906, 0.10495685013288236, 0.09854458937774613, 0.09716371232282162, 0.11476060783481101, 0.10180537332611694, 0.08978362639479653, 0.09895539925489538, 0.10411653850132274, 0.2633268434969652, 0.1788873209645211, 0.2264473851374672, 0.2507217028230929, 0.17913228377985901, 0.22891227141535053, 0.19110001644461017, 0.2139585020176098, 0.18290495053256972, 0.4135147594879234, 0.42148645148468744, 0.4163750662420447, 0.3786119686270838, 0.4413315433472095, 0.3775701429488637, 0.43907987101758084, 0.4406275496723362, 0.3647495752161902, 0.35104771272631796, 0.32129370837133686, 0.3145722381892989, 0.2977847102879454, 0.2975529999725195, 0.28898620252116314, 0.3137956181835322, 0.3267581533766173, 0.3330980920336182, 0.1898882779819978, 0.1905400773304492, 0.18545963849958857, 0.18856014300619717, 0.21931369012724744, 0.1990457180226365, 0.20889701508602687, 0.17918548645071464, 0.18996285541952096, 0.23642946213293792, 0.3927603564406512, 0.24749623807951637, 0.19193963824809768, 0.18219160787894084, 0.21713294923741522, 0.221165022732153, 0.2170824145776833, 0.21595790950359184, 0.6431133147940391, 0.7910116517369107, 0.1526494517286039, 0.18367854971517794, 0.20943985436351187, 0.1959939509921974, 0.18284803815092687, 0.6095864501996766, 0.734668736213713, 0.6901716059296701, 0.20955375555447575, 0.6708621482076059, 0.6562094333851947, 0.7065753248293243, 0.2060075346519048, 0.749621608307204, 0.7240217086130991, 0.20907996605188905, 0.18263625118278404, 0.19256000426655284, 0.17657819589137957, 0.17729311771949818, 0.1922495866517835, 0.1990523094758524, 0.18017600315779692, 0.16894604412663083, 0.18586734217102652, 0.08068749109015605, 0.08347801844548375, 0.0782340926600047, 0.08345049371297841, 0.07374025617519131, 0.08647786369411792, 0.08067671222228345, 0.08609957232088361, 0.09423657106271999]}, "mutation_prompt": null}
{"id": "0c69a89f-c964-47ea-8f74-4aab5b2ded63", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F = 0.8  # Mutation factor\n        self.base_CR = 0.9  # Base crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n        self.dynamic_CR = lambda evals: self.base_CR * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                current_CR = self.dynamic_CR(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant, current_CR)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant, CR):\n        crossover_mask = np.random.rand(self.dim) < CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.1  # Increased step size for more aggressive search\n        for _ in range(7):  # Increased local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "Enhanced DEALS with adaptive crossover probability and improved local search for faster convergence.", "configspace": "", "generation": 56, "fitness": 0.2887140357783092, "feedback": "The algorithm DEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "8678eecb-2fc1-4c26-9fab-ffcefc4aa9aa", "metadata": {"aucs": [0.7332118116307429, 0.7341881288248051, 0.7202689799130424, 0.7357584633536504, 0.7512456160208021, 0.7351839122967321, 0.7257570380428526, 0.7269567382311855, 0.724674970679049, 0.5647515648177623, 0.5652144361769202, 0.5663354217471409, 0.5510103306784804, 0.5587501706182452, 0.5789224909659418, 0.5806694746263275, 0.5622865398131363, 0.5703084227772798, 0.3163715930930443, 0.3259279019138269, 0.2968645609645332, 0.36735064235428505, 0.29493387920621117, 0.3218305079356222, 0.303401210477633, 0.3212941022867737, 0.33333215643443415, 0.28791372129943593, 0.282812042515977, 0.2616265986034374, 0.26874717611389964, 0.3049926827458248, 0.2674118592585164, 0.2190903247862217, 0.2801578058194516, 0.26554413822767076, 0.9512169860085337, 0.947038950362325, 0.9497009557118903, 0.9569650475721901, 0.928683515812826, 0.9743113471658356, 0.982555613462907, 0.9030684779351026, 0.9714212485527438, 0.3821520760307817, 0.3337515295204917, 0.30346425053215353, 0.33903296363454816, 0.3498331812562261, 0.3505317362546754, 0.3254781027466602, 0.3232073567276639, 0.3207989938480843, 0.5343903634188906, 0.6406634391497126, 0.4481415104486589, 0.5468851295668687, 0.6962933861707776, 0.4346986759035961, 0.4439537703030396, 0.597364469297484, 0.43868614074177537, 0.15437156946267938, 0.15654936763978844, 0.14388470657613028, 0.1406530197479111, 0.15023521776718984, 0.1525887108819829, 0.15889691562994468, 0.14438392833824654, 0.16770773601985056, 0.1898952126178166, 0.12059688197293728, 0.14233244599547712, 0.14706827423494628, 0.1345814540148258, 0.14279671971489283, 0.14458787331110956, 0.16730731316448766, 0.15887752447033032, 0.029044741401827, 0.031399336683053614, 0.022867495660753967, 0.03203171398072735, 0.007595318570154275, 0.035685155053537865, 9.999999999998899e-05, 0.040833705121608, 0.02370343346899806, 0.120468818920346, 0.13276967909644388, 0.12992798341054168, 0.13454950478377758, 0.11419858897498292, 0.12947171021165738, 0.16116658835998665, 0.15452430726526345, 0.17839930226311917, 0.004818135753570596, 0.012646563013169354, 9.999999999998899e-05, 0.0031815469671211405, 0.0002586660197677615, 0.0009086951022698742, 0.004137595000728522, 9.999999999998899e-05, 0.020286798829266983, 0.11727358024359968, 0.11424445043472564, 0.12577199056127153, 0.12248349644454704, 0.14507212440714934, 0.15193498137505668, 0.10256552103810157, 0.13263807417278417, 0.12795438496407585, 0.4562138226125655, 0.4606344316866583, 0.4768448046731376, 0.5109463732240123, 0.4659948945805097, 0.4630227464519817, 0.49089801021286694, 0.46741492350329117, 0.454593061479585, 0.08896138756007987, 0.10105966174992087, 0.09544211224359, 0.0995399573732233, 0.09661514330275967, 0.0950671923968317, 0.0860370555386828, 0.0917970693130199, 0.09896307806351867, 0.20077873345810826, 0.15855399926604974, 0.14214022379368108, 0.1809434954507677, 0.16039699648768235, 0.15225625484359584, 0.16404191023015136, 0.2066509395127113, 0.13668025042108944, 0.3160159693147545, 0.28520753651453423, 0.2967767404114887, 0.2650660473902965, 0.3108013675145396, 0.3020224017794211, 0.37891739092850296, 0.3583354906754127, 0.3389646562220241, 0.1918230346232811, 0.22036188185844585, 0.20125506394237602, 0.1742856214961095, 0.1947376605800928, 0.19487331970218347, 0.23792766752972772, 0.25633319472733795, 0.2072455045138264, 0.19139003546750266, 0.17429527875282635, 0.19140152134610067, 0.19658987481442758, 0.1902325631266676, 0.17556578210883966, 0.1880057853834245, 0.20101222784552453, 0.17344649491528386, 0.2045794506764168, 0.22043118823802454, 0.2170771450951512, 0.22890875373548003, 0.21304274338090412, 0.22063885184254828, 0.20825167559076196, 0.20085360885655457, 0.22667048408047796, 0.4664205152076826, 0.6692706563058395, 0.6535025984852603, 0.17449073583147312, 0.501266113316506, 0.31158064631651794, 0.3510569170640535, 0.5877578847236242, 0.18057265705835668, 0.3860266583819304, 0.2022197744289267, 0.33210568553148423, 0.24191742479474454, 0.25818443265664104, 0.1819191455809781, 0.20826596840122946, 0.21032793933910487, 0.3659234114366513, 0.17649893230579405, 0.18670631635536816, 0.1844623487117354, 0.1709785799470952, 0.1952997441041031, 0.19454790965678048, 0.18618630571211592, 0.17839770192852522, 0.18768032058077633, 0.07210063860530824, 0.06986177996593812, 0.08040469781945503, 0.08263141673751184, 0.07919628394455536, 0.07059856473645032, 0.0785481325848768, 0.08542721071985038, 0.08224764192433309]}, "mutation_prompt": null}
{"id": "4ba3e802-a388-4920-952e-243e4feef0a4", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F = 0.7  # Adjusted mutation factor for better exploration\n        self.CR = 0.85  # Adjusted crossover probability for maintaining diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.4 * np.cos(np.pi * evals / self.budget)  # Enhanced dynamic F\n        self.warmup_phase = 0.1 * self.budget  # Initial warmup phase to stabilize exploration\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                if eval_count < self.warmup_phase:\n                    current_F, current_CR = 0.5, 0.8  # Fixed F and CR during warmup phase\n                else:\n                    current_F = self.dynamic_F(eval_count)\n                    current_CR = 0.7 + 0.2 * np.cos(np.pi * eval_count / self.budget)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant, current_CR)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant, CR):\n        crossover_mask = np.random.rand(self.dim) < CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "Enhanced DEALS with adaptive F and CR parameters using warm-up phase to improve convergence speed.", "configspace": "", "generation": 57, "fitness": 0.3305613743636138, "feedback": "The algorithm DEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.23.", "error": "", "parent_id": "8678eecb-2fc1-4c26-9fab-ffcefc4aa9aa", "metadata": {"aucs": [0.7568556896373193, 0.7384823414922985, 0.7515814589414614, 0.755123736459614, 0.7410221238153851, 0.7501510988109935, 0.7569817167311454, 0.7587601877428544, 0.7562690366458928, 0.5905482925599166, 0.5800245405939882, 0.593976665230421, 0.5753615367192493, 0.5909651604288957, 0.5865259509091509, 0.5881827055458124, 0.5962537800577087, 0.6114518085369216, 0.13347617688173918, 0.23043733191867177, 0.23857568181945676, 0.23150125600586702, 0.2065823949593104, 0.17773024505869595, 0.16365087671603018, 0.18317440020463227, 0.1643947678937464, 0.17423661287947967, 0.1278537962896451, 0.11677338045665087, 0.15883089625831437, 0.1503766144169676, 0.11297470052213598, 0.18054231722507486, 0.18086479075452822, 0.1290207076661305, 0.9330410106537452, 0.948886338748609, 0.9098615640761218, 0.9083993609109765, 0.9523113309173795, 0.9458875201451846, 0.9861175639295882, 0.9317620261655775, 0.9571693981030596, 0.353025167418903, 0.3844174311498393, 0.40173586209582646, 0.41210841259095043, 0.38454946819392777, 0.42858404401636563, 0.36729410577173627, 0.36876991800947767, 0.43887355130214, 0.6541266711979152, 0.5831462803837998, 0.5606354145309702, 0.6202343901760284, 0.6785228978528652, 0.5920748662013546, 0.6184363754940747, 0.6433017324174679, 0.6547134520506943, 0.22060114506487394, 0.1916498967384319, 0.20577693902857253, 0.17047652020635284, 0.1910419480766543, 0.2321814204888648, 0.1802651629833908, 0.18446362827819573, 0.20565861782735495, 0.16667910267510455, 0.2021408841063409, 0.21411734971433893, 0.1915010777933821, 0.1845822591709887, 0.23110261440489754, 0.1787059459413276, 0.16483201882548126, 0.21293413368333136, 0.15544241040266538, 0.19214536439436913, 0.11813516159197812, 0.14578159430464, 0.1238637051209045, 0.1340379737590348, 0.11840738041457721, 0.14136917005942418, 0.07967097407149482, 0.2526957582026502, 0.2743682555062279, 0.2575374315076384, 0.24591720106395765, 0.23706386496204124, 0.21968981871531368, 0.310866622751394, 0.3050768878001494, 0.29623146085901586, 0.06380652518609209, 0.042840388653634376, 0.07509092336015089, 0.046193305815696695, 0.04467798993280303, 0.05155955333642137, 0.08674633425441935, 0.11139892286367958, 0.08055835639149533, 0.18912935648961515, 0.17758248293322088, 0.16360039370989088, 0.20061151266905486, 0.19209390516800517, 0.20546319597128349, 0.18638123266877693, 0.1721407279822018, 0.18978918482663598, 0.5409591173728094, 0.5664935628252208, 0.5666235114126894, 0.5664147683268621, 0.5325858672240285, 0.5405421642453718, 0.5259894892368607, 0.5509171635323579, 0.5358534960476736, 0.12185924633221834, 0.10955713601738903, 0.09542836144740052, 0.09653351155448942, 0.10338956337833827, 0.10009035884393747, 0.10262521718553852, 0.10210662179424856, 0.11822466218776295, 0.17416294203575866, 0.16025622506742698, 0.20024089271521095, 0.1915477118566863, 0.1831155055035587, 0.17681436174290788, 0.18162095510957055, 0.19550173151415084, 0.2170070468851183, 0.37748648495248116, 0.3660865977676153, 0.3544754220228058, 0.38087063026449863, 0.3609685618360471, 0.37525397338939215, 0.3853669656747021, 0.4808856938860794, 0.44787250692166747, 0.23697591322427092, 0.2634883131997009, 0.25607687998952966, 0.2547043637762244, 0.23357348575582004, 0.23811938114839426, 0.3063870910473403, 0.3086877142659735, 0.2711192884743304, 0.19731034137518388, 0.21448349769964903, 0.19727992020152196, 0.2083785030436014, 0.2079483333190757, 0.2104155429811717, 0.19629174379902503, 0.19085540307784754, 0.1879076661205208, 0.1882752966200083, 0.1953752879181635, 0.2832369194171114, 0.28987883992183117, 0.22711424022042315, 0.28207948058972754, 0.2527225259398388, 0.23838316041357865, 0.2424921492995442, 0.22837062953289666, 0.6462436483708409, 0.6652123875142304, 0.6912099889658789, 0.6783775065533244, 0.747892153638771, 0.7120539434497312, 0.5529913355184495, 0.5435249314867712, 0.6035066191761341, 0.21091971014821842, 0.5784377067291023, 0.20668477402331586, 0.45039537974348964, 0.4298470034621953, 0.5878871652725802, 0.5969619055999646, 0.20637562865275316, 0.17784619210355468, 0.1773369826120903, 0.1868858742216274, 0.1955583265620977, 0.2018873643263629, 0.17903387341081411, 0.1832176166800703, 0.18051530035525198, 0.18399401883595057, 0.09155981369314248, 0.08459513403909891, 0.0839704982719337, 0.08883397368304502, 0.07877942139687966, 0.08188452705070837, 0.08773399799496018, 0.09026234792679844, 0.07100294458814826]}, "mutation_prompt": null}
{"id": "1cb38a48-d424-4328-95e2-a171cde84aab", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring a dynamic population size to enhance convergence speed.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8678eecb-2fc1-4c26-9fab-ffcefc4aa9aa", "metadata": {"aucs": [0.7405973988741354, 0.7281226209939119, 0.7324233204340155, 0.7489552261542903, 0.7498559026369704, 0.757519831874169, 0.7347098623601342, 0.7602786636377387, 0.7377784648945536, 0.56554125587102, 0.5944505024215752, 0.5808904441751737, 0.5747972667444257, 0.5671564195916405, 0.5961916655424153, 0.5838793849099935, 0.5852024604491162, 0.6063062861246697, 0.11341909746813339, 0.12215541600561153, 0.10085692900524679, 0.10487565508288299, 0.11036818339911192, 0.1016077518681705, 0.13666213112505554, 0.12709043286256294, 0.10861595266627522, 0.10165318727335015, 0.10505953366608245, 0.09783802420298959, 0.10172217148102114, 0.10536819228798322, 0.10900367665295507, 0.0964455393395891, 0.09024177262467925, 0.10437305516394613, 0.9548869183682216, 0.9816209304069197, 0.9712607491984208, 0.9634026914341834, 0.9234496339538826, 0.9622203012390651, 0.985079184370999, 0.9582775702855542, 0.9611271121617417, 0.4313765997319954, 0.4618145994111096, 0.40984676643380813, 0.41472757262044546, 0.36354377548699346, 0.3986783408643845, 0.4379164888621577, 0.40934147613419813, 0.35998487468993845, 0.6806130514358448, 0.6955121767822976, 0.6866807490914777, 0.6701999875888693, 0.6347825436279659, 0.6646026866550377, 0.6567034530055915, 0.6819668428073227, 0.6865650804245118, 0.24016363313740974, 0.22090206531540513, 0.17297907809772384, 0.19886709320385698, 0.2609815145734389, 0.18127297647829888, 0.1957417735940552, 0.22920999827866495, 0.18310000474785193, 0.193110013501813, 0.27693749544418755, 0.11368476511095227, 0.2043950030984022, 0.220306450983471, 0.16484688126919844, 0.16381494823035447, 0.18179600745406732, 0.14778597331998222, 0.30639582001449794, 0.27031080642673355, 0.3372871936467656, 0.33126944253156676, 0.3168027670970488, 0.36890694251841194, 0.2710681818949614, 0.3304548812663224, 0.2636668768734898, 0.399363666198819, 0.4391896350173363, 0.4251106318701794, 0.3957391328356439, 0.4173071637112098, 0.49114169125133744, 0.4571763095341902, 0.44105907891793006, 0.47543054954069286, 0.06983850752350995, 0.20587215387818425, 0.20247406425544145, 0.16216146868714298, 0.16946602502848995, 0.1167350874180072, 0.18066366226210884, 0.10466453986036195, 0.08431960773622249, 0.29775472663503366, 0.2701635789954244, 0.2961391035212847, 0.26748150670562176, 0.3418746895885989, 0.26193853866475514, 0.2980231606880872, 0.2481920681467945, 0.29270775966039486, 0.6392765826679037, 0.6490275061328654, 0.6434311797354066, 0.6101548565800816, 0.6705163158216997, 0.581715485322932, 0.6302372799063853, 0.6572822223214339, 0.63667360276885, 0.10946979306955906, 0.10495685013288236, 0.09854458937774613, 0.09716371232282162, 0.11476060783481101, 0.10180537332611694, 0.08978362639479653, 0.09895539925489538, 0.10411653850132274, 0.2633268434969652, 0.1788873209645211, 0.2264473851374672, 0.2507217028230929, 0.17913228377985901, 0.22891227141535053, 0.19110001644461017, 0.2139585020176098, 0.18290495053256972, 0.4135147594879234, 0.42148645148468744, 0.4163750662420447, 0.3786119686270838, 0.4413315433472095, 0.3775701429488637, 0.43907987101758084, 0.4406275496723362, 0.3647495752161902, 0.35104771272631796, 0.32129370837133686, 0.3145722381892989, 0.2977847102879454, 0.2975529999725195, 0.28898620252116314, 0.3137956181835322, 0.3267581533766173, 0.3330980920336182, 0.1898882779819978, 0.1905400773304492, 0.18545963849958857, 0.18856014300619717, 0.21931369012724744, 0.1990457180226365, 0.20889701508602687, 0.17918548645071464, 0.18996285541952096, 0.23642946213293792, 0.3927603564406512, 0.24749623807951637, 0.19193963824809768, 0.18219160787894084, 0.21713294923741522, 0.221165022732153, 0.2170824145776833, 0.21595790950359184, 0.6431133147940391, 0.7910116517369107, 0.1526494517286039, 0.18367854971517794, 0.20943985436351187, 0.1959939509921974, 0.18284803815092687, 0.6095864501996766, 0.734668736213713, 0.6901716059296701, 0.20955375555447575, 0.6708621482076059, 0.6562094333851947, 0.7065753248293243, 0.2060075346519048, 0.749621608307204, 0.7240217086130991, 0.20907996605188905, 0.18263625118278404, 0.19256000426655284, 0.17657819589137957, 0.17729311771949818, 0.1922495866517835, 0.1990523094758524, 0.18017600315779692, 0.16894604412663083, 0.18586734217102652, 0.08068749109015605, 0.08347801844548375, 0.0782340926600047, 0.08345049371297841, 0.07374025617519131, 0.08647786369411792, 0.08067671222228345, 0.08609957232088361, 0.09423657106271999]}, "mutation_prompt": null}
{"id": "9a18e8d1-ed17-4223-81c8-78795c4b2f8e", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring a dynamic population size to enhance convergence speed.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8678eecb-2fc1-4c26-9fab-ffcefc4aa9aa", "metadata": {"aucs": [0.7405973988741354, 0.7281226209939119, 0.7324233204340155, 0.7489552261542903, 0.7498559026369704, 0.757519831874169, 0.7347098623601342, 0.7602786636377387, 0.7377784648945536, 0.56554125587102, 0.5944505024215752, 0.5808904441751737, 0.5747972667444257, 0.5671564195916405, 0.5961916655424153, 0.5838793849099935, 0.5852024604491162, 0.6063062861246697, 0.11341909746813339, 0.12215541600561153, 0.10085692900524679, 0.10487565508288299, 0.11036818339911192, 0.1016077518681705, 0.13666213112505554, 0.12709043286256294, 0.10861595266627522, 0.10165318727335015, 0.10505953366608245, 0.09783802420298959, 0.10172217148102114, 0.10536819228798322, 0.10900367665295507, 0.0964455393395891, 0.09024177262467925, 0.10437305516394613, 0.9548869183682216, 0.9816209304069197, 0.9712607491984208, 0.9634026914341834, 0.9234496339538826, 0.9622203012390651, 0.985079184370999, 0.9582775702855542, 0.9611271121617417, 0.4313765997319954, 0.4618145994111096, 0.40984676643380813, 0.41472757262044546, 0.36354377548699346, 0.3986783408643845, 0.4379164888621577, 0.40934147613419813, 0.35998487468993845, 0.6806130514358448, 0.6955121767822976, 0.6866807490914777, 0.6701999875888693, 0.6347825436279659, 0.6646026866550377, 0.6567034530055915, 0.6819668428073227, 0.6865650804245118, 0.24016363313740974, 0.22090206531540513, 0.17297907809772384, 0.19886709320385698, 0.2609815145734389, 0.18127297647829888, 0.1957417735940552, 0.22920999827866495, 0.18310000474785193, 0.193110013501813, 0.27693749544418755, 0.11368476511095227, 0.2043950030984022, 0.220306450983471, 0.16484688126919844, 0.16381494823035447, 0.18179600745406732, 0.14778597331998222, 0.30639582001449794, 0.27031080642673355, 0.3372871936467656, 0.33126944253156676, 0.3168027670970488, 0.36890694251841194, 0.2710681818949614, 0.3304548812663224, 0.2636668768734898, 0.399363666198819, 0.4391896350173363, 0.4251106318701794, 0.3957391328356439, 0.4173071637112098, 0.49114169125133744, 0.4571763095341902, 0.44105907891793006, 0.47543054954069286, 0.06983850752350995, 0.20587215387818425, 0.20247406425544145, 0.16216146868714298, 0.16946602502848995, 0.1167350874180072, 0.18066366226210884, 0.10466453986036195, 0.08431960773622249, 0.29775472663503366, 0.2701635789954244, 0.2961391035212847, 0.26748150670562176, 0.3418746895885989, 0.26193853866475514, 0.2980231606880872, 0.2481920681467945, 0.29270775966039486, 0.6392765826679037, 0.6490275061328654, 0.6434311797354066, 0.6101548565800816, 0.6705163158216997, 0.581715485322932, 0.6302372799063853, 0.6572822223214339, 0.63667360276885, 0.10946979306955906, 0.10495685013288236, 0.09854458937774613, 0.09716371232282162, 0.11476060783481101, 0.10180537332611694, 0.08978362639479653, 0.09895539925489538, 0.10411653850132274, 0.2633268434969652, 0.1788873209645211, 0.2264473851374672, 0.2507217028230929, 0.17913228377985901, 0.22891227141535053, 0.19110001644461017, 0.2139585020176098, 0.18290495053256972, 0.4135147594879234, 0.42148645148468744, 0.4163750662420447, 0.3786119686270838, 0.4413315433472095, 0.3775701429488637, 0.43907987101758084, 0.4406275496723362, 0.3647495752161902, 0.35104771272631796, 0.32129370837133686, 0.3145722381892989, 0.2977847102879454, 0.2975529999725195, 0.28898620252116314, 0.3137956181835322, 0.3267581533766173, 0.3330980920336182, 0.1898882779819978, 0.1905400773304492, 0.18545963849958857, 0.18856014300619717, 0.21931369012724744, 0.1990457180226365, 0.20889701508602687, 0.17918548645071464, 0.18996285541952096, 0.23642946213293792, 0.3927603564406512, 0.24749623807951637, 0.19193963824809768, 0.18219160787894084, 0.21713294923741522, 0.221165022732153, 0.2170824145776833, 0.21595790950359184, 0.6431133147940391, 0.7910116517369107, 0.1526494517286039, 0.18367854971517794, 0.20943985436351187, 0.1959939509921974, 0.18284803815092687, 0.6095864501996766, 0.734668736213713, 0.6901716059296701, 0.20955375555447575, 0.6708621482076059, 0.6562094333851947, 0.7065753248293243, 0.2060075346519048, 0.749621608307204, 0.7240217086130991, 0.20907996605188905, 0.18263625118278404, 0.19256000426655284, 0.17657819589137957, 0.17729311771949818, 0.1922495866517835, 0.1990523094758524, 0.18017600315779692, 0.16894604412663083, 0.18586734217102652, 0.08068749109015605, 0.08347801844548375, 0.0782340926600047, 0.08345049371297841, 0.07374025617519131, 0.08647786369411792, 0.08067671222228345, 0.08609957232088361, 0.09423657106271999]}, "mutation_prompt": null}
{"id": "1c04e911-2e90-4d66-a823-3ce6f044a1b5", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring a dynamic population size to enhance convergence speed.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8678eecb-2fc1-4c26-9fab-ffcefc4aa9aa", "metadata": {"aucs": [0.7405973988741354, 0.7281226209939119, 0.7324233204340155, 0.7489552261542903, 0.7498559026369704, 0.757519831874169, 0.7347098623601342, 0.7602786636377387, 0.7377784648945536, 0.56554125587102, 0.5944505024215752, 0.5808904441751737, 0.5747972667444257, 0.5671564195916405, 0.5961916655424153, 0.5838793849099935, 0.5852024604491162, 0.6063062861246697, 0.11341909746813339, 0.12215541600561153, 0.10085692900524679, 0.10487565508288299, 0.11036818339911192, 0.1016077518681705, 0.13666213112505554, 0.12709043286256294, 0.10861595266627522, 0.10165318727335015, 0.10505953366608245, 0.09783802420298959, 0.10172217148102114, 0.10536819228798322, 0.10900367665295507, 0.0964455393395891, 0.09024177262467925, 0.10437305516394613, 0.9548869183682216, 0.9816209304069197, 0.9712607491984208, 0.9634026914341834, 0.9234496339538826, 0.9622203012390651, 0.985079184370999, 0.9582775702855542, 0.9611271121617417, 0.4313765997319954, 0.4618145994111096, 0.40984676643380813, 0.41472757262044546, 0.36354377548699346, 0.3986783408643845, 0.4379164888621577, 0.40934147613419813, 0.35998487468993845, 0.6806130514358448, 0.6955121767822976, 0.6866807490914777, 0.6701999875888693, 0.6347825436279659, 0.6646026866550377, 0.6567034530055915, 0.6819668428073227, 0.6865650804245118, 0.24016363313740974, 0.22090206531540513, 0.17297907809772384, 0.19886709320385698, 0.2609815145734389, 0.18127297647829888, 0.1957417735940552, 0.22920999827866495, 0.18310000474785193, 0.193110013501813, 0.27693749544418755, 0.11368476511095227, 0.2043950030984022, 0.220306450983471, 0.16484688126919844, 0.16381494823035447, 0.18179600745406732, 0.14778597331998222, 0.30639582001449794, 0.27031080642673355, 0.3372871936467656, 0.33126944253156676, 0.3168027670970488, 0.36890694251841194, 0.2710681818949614, 0.3304548812663224, 0.2636668768734898, 0.399363666198819, 0.4391896350173363, 0.4251106318701794, 0.3957391328356439, 0.4173071637112098, 0.49114169125133744, 0.4571763095341902, 0.44105907891793006, 0.47543054954069286, 0.06983850752350995, 0.20587215387818425, 0.20247406425544145, 0.16216146868714298, 0.16946602502848995, 0.1167350874180072, 0.18066366226210884, 0.10466453986036195, 0.08431960773622249, 0.29775472663503366, 0.2701635789954244, 0.2961391035212847, 0.26748150670562176, 0.3418746895885989, 0.26193853866475514, 0.2980231606880872, 0.2481920681467945, 0.29270775966039486, 0.6392765826679037, 0.6490275061328654, 0.6434311797354066, 0.6101548565800816, 0.6705163158216997, 0.581715485322932, 0.6302372799063853, 0.6572822223214339, 0.63667360276885, 0.10946979306955906, 0.10495685013288236, 0.09854458937774613, 0.09716371232282162, 0.11476060783481101, 0.10180537332611694, 0.08978362639479653, 0.09895539925489538, 0.10411653850132274, 0.2633268434969652, 0.1788873209645211, 0.2264473851374672, 0.2507217028230929, 0.17913228377985901, 0.22891227141535053, 0.19110001644461017, 0.2139585020176098, 0.18290495053256972, 0.4135147594879234, 0.42148645148468744, 0.4163750662420447, 0.3786119686270838, 0.4413315433472095, 0.3775701429488637, 0.43907987101758084, 0.4406275496723362, 0.3647495752161902, 0.35104771272631796, 0.32129370837133686, 0.3145722381892989, 0.2977847102879454, 0.2975529999725195, 0.28898620252116314, 0.3137956181835322, 0.3267581533766173, 0.3330980920336182, 0.1898882779819978, 0.1905400773304492, 0.18545963849958857, 0.18856014300619717, 0.21931369012724744, 0.1990457180226365, 0.20889701508602687, 0.17918548645071464, 0.18996285541952096, 0.23642946213293792, 0.3927603564406512, 0.24749623807951637, 0.19193963824809768, 0.18219160787894084, 0.21713294923741522, 0.221165022732153, 0.2170824145776833, 0.21595790950359184, 0.6431133147940391, 0.7910116517369107, 0.1526494517286039, 0.18367854971517794, 0.20943985436351187, 0.1959939509921974, 0.18284803815092687, 0.6095864501996766, 0.734668736213713, 0.6901716059296701, 0.20955375555447575, 0.6708621482076059, 0.6562094333851947, 0.7065753248293243, 0.2060075346519048, 0.749621608307204, 0.7240217086130991, 0.20907996605188905, 0.18263625118278404, 0.19256000426655284, 0.17657819589137957, 0.17729311771949818, 0.1922495866517835, 0.1990523094758524, 0.18017600315779692, 0.16894604412663083, 0.18586734217102652, 0.08068749109015605, 0.08347801844548375, 0.0782340926600047, 0.08345049371297841, 0.07374025617519131, 0.08647786369411792, 0.08067671222228345, 0.08609957232088361, 0.09423657106271999]}, "mutation_prompt": null}
{"id": "ce426995-e56f-4f2d-8725-e8bcc0a0100e", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring a dynamic population size to enhance convergence speed.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8678eecb-2fc1-4c26-9fab-ffcefc4aa9aa", "metadata": {"aucs": [0.7405973988741354, 0.7281226209939119, 0.7324233204340155, 0.7489552261542903, 0.7498559026369704, 0.757519831874169, 0.7347098623601342, 0.7602786636377387, 0.7377784648945536, 0.56554125587102, 0.5944505024215752, 0.5808904441751737, 0.5747972667444257, 0.5671564195916405, 0.5961916655424153, 0.5838793849099935, 0.5852024604491162, 0.6063062861246697, 0.11341909746813339, 0.12215541600561153, 0.10085692900524679, 0.10487565508288299, 0.11036818339911192, 0.1016077518681705, 0.13666213112505554, 0.12709043286256294, 0.10861595266627522, 0.10165318727335015, 0.10505953366608245, 0.09783802420298959, 0.10172217148102114, 0.10536819228798322, 0.10900367665295507, 0.0964455393395891, 0.09024177262467925, 0.10437305516394613, 0.9548869183682216, 0.9816209304069197, 0.9712607491984208, 0.9634026914341834, 0.9234496339538826, 0.9622203012390651, 0.985079184370999, 0.9582775702855542, 0.9611271121617417, 0.4313765997319954, 0.4618145994111096, 0.40984676643380813, 0.41472757262044546, 0.36354377548699346, 0.3986783408643845, 0.4379164888621577, 0.40934147613419813, 0.35998487468993845, 0.6806130514358448, 0.6955121767822976, 0.6866807490914777, 0.6701999875888693, 0.6347825436279659, 0.6646026866550377, 0.6567034530055915, 0.6819668428073227, 0.6865650804245118, 0.24016363313740974, 0.22090206531540513, 0.17297907809772384, 0.19886709320385698, 0.2609815145734389, 0.18127297647829888, 0.1957417735940552, 0.22920999827866495, 0.18310000474785193, 0.193110013501813, 0.27693749544418755, 0.11368476511095227, 0.2043950030984022, 0.220306450983471, 0.16484688126919844, 0.16381494823035447, 0.18179600745406732, 0.14778597331998222, 0.30639582001449794, 0.27031080642673355, 0.3372871936467656, 0.33126944253156676, 0.3168027670970488, 0.36890694251841194, 0.2710681818949614, 0.3304548812663224, 0.2636668768734898, 0.399363666198819, 0.4391896350173363, 0.4251106318701794, 0.3957391328356439, 0.4173071637112098, 0.49114169125133744, 0.4571763095341902, 0.44105907891793006, 0.47543054954069286, 0.06983850752350995, 0.20587215387818425, 0.20247406425544145, 0.16216146868714298, 0.16946602502848995, 0.1167350874180072, 0.18066366226210884, 0.10466453986036195, 0.08431960773622249, 0.29775472663503366, 0.2701635789954244, 0.2961391035212847, 0.26748150670562176, 0.3418746895885989, 0.26193853866475514, 0.2980231606880872, 0.2481920681467945, 0.29270775966039486, 0.6392765826679037, 0.6490275061328654, 0.6434311797354066, 0.6101548565800816, 0.6705163158216997, 0.581715485322932, 0.6302372799063853, 0.6572822223214339, 0.63667360276885, 0.10946979306955906, 0.10495685013288236, 0.09854458937774613, 0.09716371232282162, 0.11476060783481101, 0.10180537332611694, 0.08978362639479653, 0.09895539925489538, 0.10411653850132274, 0.2633268434969652, 0.1788873209645211, 0.2264473851374672, 0.2507217028230929, 0.17913228377985901, 0.22891227141535053, 0.19110001644461017, 0.2139585020176098, 0.18290495053256972, 0.4135147594879234, 0.42148645148468744, 0.4163750662420447, 0.3786119686270838, 0.4413315433472095, 0.3775701429488637, 0.43907987101758084, 0.4406275496723362, 0.3647495752161902, 0.35104771272631796, 0.32129370837133686, 0.3145722381892989, 0.2977847102879454, 0.2975529999725195, 0.28898620252116314, 0.3137956181835322, 0.3267581533766173, 0.3330980920336182, 0.1898882779819978, 0.1905400773304492, 0.18545963849958857, 0.18856014300619717, 0.21931369012724744, 0.1990457180226365, 0.20889701508602687, 0.17918548645071464, 0.18996285541952096, 0.23642946213293792, 0.3927603564406512, 0.24749623807951637, 0.19193963824809768, 0.18219160787894084, 0.21713294923741522, 0.221165022732153, 0.2170824145776833, 0.21595790950359184, 0.6431133147940391, 0.7910116517369107, 0.1526494517286039, 0.18367854971517794, 0.20943985436351187, 0.1959939509921974, 0.18284803815092687, 0.6095864501996766, 0.734668736213713, 0.6901716059296701, 0.20955375555447575, 0.6708621482076059, 0.6562094333851947, 0.7065753248293243, 0.2060075346519048, 0.749621608307204, 0.7240217086130991, 0.20907996605188905, 0.18263625118278404, 0.19256000426655284, 0.17657819589137957, 0.17729311771949818, 0.1922495866517835, 0.1990523094758524, 0.18017600315779692, 0.16894604412663083, 0.18586734217102652, 0.08068749109015605, 0.08347801844548375, 0.0782340926600047, 0.08345049371297841, 0.07374025617519131, 0.08647786369411792, 0.08067671222228345, 0.08609957232088361, 0.09423657106271999]}, "mutation_prompt": null}
{"id": "2938e483-6101-4a5c-8a9b-422efae6274d", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring a dynamic population size to enhance convergence speed.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8678eecb-2fc1-4c26-9fab-ffcefc4aa9aa", "metadata": {"aucs": [0.7405973988741354, 0.7281226209939119, 0.7324233204340155, 0.7489552261542903, 0.7498559026369704, 0.757519831874169, 0.7347098623601342, 0.7602786636377387, 0.7377784648945536, 0.56554125587102, 0.5944505024215752, 0.5808904441751737, 0.5747972667444257, 0.5671564195916405, 0.5961916655424153, 0.5838793849099935, 0.5852024604491162, 0.6063062861246697, 0.11341909746813339, 0.12215541600561153, 0.10085692900524679, 0.10487565508288299, 0.11036818339911192, 0.1016077518681705, 0.13666213112505554, 0.12709043286256294, 0.10861595266627522, 0.10165318727335015, 0.10505953366608245, 0.09783802420298959, 0.10172217148102114, 0.10536819228798322, 0.10900367665295507, 0.0964455393395891, 0.09024177262467925, 0.10437305516394613, 0.9548869183682216, 0.9816209304069197, 0.9712607491984208, 0.9634026914341834, 0.9234496339538826, 0.9622203012390651, 0.985079184370999, 0.9582775702855542, 0.9611271121617417, 0.4313765997319954, 0.4618145994111096, 0.40984676643380813, 0.41472757262044546, 0.36354377548699346, 0.3986783408643845, 0.4379164888621577, 0.40934147613419813, 0.35998487468993845, 0.6806130514358448, 0.6955121767822976, 0.6866807490914777, 0.6701999875888693, 0.6347825436279659, 0.6646026866550377, 0.6567034530055915, 0.6819668428073227, 0.6865650804245118, 0.24016363313740974, 0.22090206531540513, 0.17297907809772384, 0.19886709320385698, 0.2609815145734389, 0.18127297647829888, 0.1957417735940552, 0.22920999827866495, 0.18310000474785193, 0.193110013501813, 0.27693749544418755, 0.11368476511095227, 0.2043950030984022, 0.220306450983471, 0.16484688126919844, 0.16381494823035447, 0.18179600745406732, 0.14778597331998222, 0.30639582001449794, 0.27031080642673355, 0.3372871936467656, 0.33126944253156676, 0.3168027670970488, 0.36890694251841194, 0.2710681818949614, 0.3304548812663224, 0.2636668768734898, 0.399363666198819, 0.4391896350173363, 0.4251106318701794, 0.3957391328356439, 0.4173071637112098, 0.49114169125133744, 0.4571763095341902, 0.44105907891793006, 0.47543054954069286, 0.06983850752350995, 0.20587215387818425, 0.20247406425544145, 0.16216146868714298, 0.16946602502848995, 0.1167350874180072, 0.18066366226210884, 0.10466453986036195, 0.08431960773622249, 0.29775472663503366, 0.2701635789954244, 0.2961391035212847, 0.26748150670562176, 0.3418746895885989, 0.26193853866475514, 0.2980231606880872, 0.2481920681467945, 0.29270775966039486, 0.6392765826679037, 0.6490275061328654, 0.6434311797354066, 0.6101548565800816, 0.6705163158216997, 0.581715485322932, 0.6302372799063853, 0.6572822223214339, 0.63667360276885, 0.10946979306955906, 0.10495685013288236, 0.09854458937774613, 0.09716371232282162, 0.11476060783481101, 0.10180537332611694, 0.08978362639479653, 0.09895539925489538, 0.10411653850132274, 0.2633268434969652, 0.1788873209645211, 0.2264473851374672, 0.2507217028230929, 0.17913228377985901, 0.22891227141535053, 0.19110001644461017, 0.2139585020176098, 0.18290495053256972, 0.4135147594879234, 0.42148645148468744, 0.4163750662420447, 0.3786119686270838, 0.4413315433472095, 0.3775701429488637, 0.43907987101758084, 0.4406275496723362, 0.3647495752161902, 0.35104771272631796, 0.32129370837133686, 0.3145722381892989, 0.2977847102879454, 0.2975529999725195, 0.28898620252116314, 0.3137956181835322, 0.3267581533766173, 0.3330980920336182, 0.1898882779819978, 0.1905400773304492, 0.18545963849958857, 0.18856014300619717, 0.21931369012724744, 0.1990457180226365, 0.20889701508602687, 0.17918548645071464, 0.18996285541952096, 0.23642946213293792, 0.3927603564406512, 0.24749623807951637, 0.19193963824809768, 0.18219160787894084, 0.21713294923741522, 0.221165022732153, 0.2170824145776833, 0.21595790950359184, 0.6431133147940391, 0.7910116517369107, 0.1526494517286039, 0.18367854971517794, 0.20943985436351187, 0.1959939509921974, 0.18284803815092687, 0.6095864501996766, 0.734668736213713, 0.6901716059296701, 0.20955375555447575, 0.6708621482076059, 0.6562094333851947, 0.7065753248293243, 0.2060075346519048, 0.749621608307204, 0.7240217086130991, 0.20907996605188905, 0.18263625118278404, 0.19256000426655284, 0.17657819589137957, 0.17729311771949818, 0.1922495866517835, 0.1990523094758524, 0.18017600315779692, 0.16894604412663083, 0.18586734217102652, 0.08068749109015605, 0.08347801844548375, 0.0782340926600047, 0.08345049371297841, 0.07374025617519131, 0.08647786369411792, 0.08067671222228345, 0.08609957232088361, 0.09423657106271999]}, "mutation_prompt": null}
{"id": "90628da5-8581-4534-baa5-bdacf4ccd3cd", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring a dynamic population size to enhance convergence speed.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8678eecb-2fc1-4c26-9fab-ffcefc4aa9aa", "metadata": {"aucs": [0.7405973988741354, 0.7281226209939119, 0.7324233204340155, 0.7489552261542903, 0.7498559026369704, 0.757519831874169, 0.7347098623601342, 0.7602786636377387, 0.7377784648945536, 0.56554125587102, 0.5944505024215752, 0.5808904441751737, 0.5747972667444257, 0.5671564195916405, 0.5961916655424153, 0.5838793849099935, 0.5852024604491162, 0.6063062861246697, 0.11341909746813339, 0.12215541600561153, 0.10085692900524679, 0.10487565508288299, 0.11036818339911192, 0.1016077518681705, 0.13666213112505554, 0.12709043286256294, 0.10861595266627522, 0.10165318727335015, 0.10505953366608245, 0.09783802420298959, 0.10172217148102114, 0.10536819228798322, 0.10900367665295507, 0.0964455393395891, 0.09024177262467925, 0.10437305516394613, 0.9548869183682216, 0.9816209304069197, 0.9712607491984208, 0.9634026914341834, 0.9234496339538826, 0.9622203012390651, 0.985079184370999, 0.9582775702855542, 0.9611271121617417, 0.4313765997319954, 0.4618145994111096, 0.40984676643380813, 0.41472757262044546, 0.36354377548699346, 0.3986783408643845, 0.4379164888621577, 0.40934147613419813, 0.35998487468993845, 0.6806130514358448, 0.6955121767822976, 0.6866807490914777, 0.6701999875888693, 0.6347825436279659, 0.6646026866550377, 0.6567034530055915, 0.6819668428073227, 0.6865650804245118, 0.24016363313740974, 0.22090206531540513, 0.17297907809772384, 0.19886709320385698, 0.2609815145734389, 0.18127297647829888, 0.1957417735940552, 0.22920999827866495, 0.18310000474785193, 0.193110013501813, 0.27693749544418755, 0.11368476511095227, 0.2043950030984022, 0.220306450983471, 0.16484688126919844, 0.16381494823035447, 0.18179600745406732, 0.14778597331998222, 0.30639582001449794, 0.27031080642673355, 0.3372871936467656, 0.33126944253156676, 0.3168027670970488, 0.36890694251841194, 0.2710681818949614, 0.3304548812663224, 0.2636668768734898, 0.399363666198819, 0.4391896350173363, 0.4251106318701794, 0.3957391328356439, 0.4173071637112098, 0.49114169125133744, 0.4571763095341902, 0.44105907891793006, 0.47543054954069286, 0.06983850752350995, 0.20587215387818425, 0.20247406425544145, 0.16216146868714298, 0.16946602502848995, 0.1167350874180072, 0.18066366226210884, 0.10466453986036195, 0.08431960773622249, 0.29775472663503366, 0.2701635789954244, 0.2961391035212847, 0.26748150670562176, 0.3418746895885989, 0.26193853866475514, 0.2980231606880872, 0.2481920681467945, 0.29270775966039486, 0.6392765826679037, 0.6490275061328654, 0.6434311797354066, 0.6101548565800816, 0.6705163158216997, 0.581715485322932, 0.6302372799063853, 0.6572822223214339, 0.63667360276885, 0.10946979306955906, 0.10495685013288236, 0.09854458937774613, 0.09716371232282162, 0.11476060783481101, 0.10180537332611694, 0.08978362639479653, 0.09895539925489538, 0.10411653850132274, 0.2633268434969652, 0.1788873209645211, 0.2264473851374672, 0.2507217028230929, 0.17913228377985901, 0.22891227141535053, 0.19110001644461017, 0.2139585020176098, 0.18290495053256972, 0.4135147594879234, 0.42148645148468744, 0.4163750662420447, 0.3786119686270838, 0.4413315433472095, 0.3775701429488637, 0.43907987101758084, 0.4406275496723362, 0.3647495752161902, 0.35104771272631796, 0.32129370837133686, 0.3145722381892989, 0.2977847102879454, 0.2975529999725195, 0.28898620252116314, 0.3137956181835322, 0.3267581533766173, 0.3330980920336182, 0.1898882779819978, 0.1905400773304492, 0.18545963849958857, 0.18856014300619717, 0.21931369012724744, 0.1990457180226365, 0.20889701508602687, 0.17918548645071464, 0.18996285541952096, 0.23642946213293792, 0.3927603564406512, 0.24749623807951637, 0.19193963824809768, 0.18219160787894084, 0.21713294923741522, 0.221165022732153, 0.2170824145776833, 0.21595790950359184, 0.6431133147940391, 0.7910116517369107, 0.1526494517286039, 0.18367854971517794, 0.20943985436351187, 0.1959939509921974, 0.18284803815092687, 0.6095864501996766, 0.734668736213713, 0.6901716059296701, 0.20955375555447575, 0.6708621482076059, 0.6562094333851947, 0.7065753248293243, 0.2060075346519048, 0.749621608307204, 0.7240217086130991, 0.20907996605188905, 0.18263625118278404, 0.19256000426655284, 0.17657819589137957, 0.17729311771949818, 0.1922495866517835, 0.1990523094758524, 0.18017600315779692, 0.16894604412663083, 0.18586734217102652, 0.08068749109015605, 0.08347801844548375, 0.0782340926600047, 0.08345049371297841, 0.07374025617519131, 0.08647786369411792, 0.08067671222228345, 0.08609957232088361, 0.09423657106271999]}, "mutation_prompt": null}
{"id": "9fe61b15-31ea-4a81-b854-dfd8356c775e", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring a dynamic population size to enhance convergence speed.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8678eecb-2fc1-4c26-9fab-ffcefc4aa9aa", "metadata": {"aucs": [0.7405973988741354, 0.7281226209939119, 0.7324233204340155, 0.7489552261542903, 0.7498559026369704, 0.757519831874169, 0.7347098623601342, 0.7602786636377387, 0.7377784648945536, 0.56554125587102, 0.5944505024215752, 0.5808904441751737, 0.5747972667444257, 0.5671564195916405, 0.5961916655424153, 0.5838793849099935, 0.5852024604491162, 0.6063062861246697, 0.11341909746813339, 0.12215541600561153, 0.10085692900524679, 0.10487565508288299, 0.11036818339911192, 0.1016077518681705, 0.13666213112505554, 0.12709043286256294, 0.10861595266627522, 0.10165318727335015, 0.10505953366608245, 0.09783802420298959, 0.10172217148102114, 0.10536819228798322, 0.10900367665295507, 0.0964455393395891, 0.09024177262467925, 0.10437305516394613, 0.9548869183682216, 0.9816209304069197, 0.9712607491984208, 0.9634026914341834, 0.9234496339538826, 0.9622203012390651, 0.985079184370999, 0.9582775702855542, 0.9611271121617417, 0.4313765997319954, 0.4618145994111096, 0.40984676643380813, 0.41472757262044546, 0.36354377548699346, 0.3986783408643845, 0.4379164888621577, 0.40934147613419813, 0.35998487468993845, 0.6806130514358448, 0.6955121767822976, 0.6866807490914777, 0.6701999875888693, 0.6347825436279659, 0.6646026866550377, 0.6567034530055915, 0.6819668428073227, 0.6865650804245118, 0.24016363313740974, 0.22090206531540513, 0.17297907809772384, 0.19886709320385698, 0.2609815145734389, 0.18127297647829888, 0.1957417735940552, 0.22920999827866495, 0.18310000474785193, 0.193110013501813, 0.27693749544418755, 0.11368476511095227, 0.2043950030984022, 0.220306450983471, 0.16484688126919844, 0.16381494823035447, 0.18179600745406732, 0.14778597331998222, 0.30639582001449794, 0.27031080642673355, 0.3372871936467656, 0.33126944253156676, 0.3168027670970488, 0.36890694251841194, 0.2710681818949614, 0.3304548812663224, 0.2636668768734898, 0.399363666198819, 0.4391896350173363, 0.4251106318701794, 0.3957391328356439, 0.4173071637112098, 0.49114169125133744, 0.4571763095341902, 0.44105907891793006, 0.47543054954069286, 0.06983850752350995, 0.20587215387818425, 0.20247406425544145, 0.16216146868714298, 0.16946602502848995, 0.1167350874180072, 0.18066366226210884, 0.10466453986036195, 0.08431960773622249, 0.29775472663503366, 0.2701635789954244, 0.2961391035212847, 0.26748150670562176, 0.3418746895885989, 0.26193853866475514, 0.2980231606880872, 0.2481920681467945, 0.29270775966039486, 0.6392765826679037, 0.6490275061328654, 0.6434311797354066, 0.6101548565800816, 0.6705163158216997, 0.581715485322932, 0.6302372799063853, 0.6572822223214339, 0.63667360276885, 0.10946979306955906, 0.10495685013288236, 0.09854458937774613, 0.09716371232282162, 0.11476060783481101, 0.10180537332611694, 0.08978362639479653, 0.09895539925489538, 0.10411653850132274, 0.2633268434969652, 0.1788873209645211, 0.2264473851374672, 0.2507217028230929, 0.17913228377985901, 0.22891227141535053, 0.19110001644461017, 0.2139585020176098, 0.18290495053256972, 0.4135147594879234, 0.42148645148468744, 0.4163750662420447, 0.3786119686270838, 0.4413315433472095, 0.3775701429488637, 0.43907987101758084, 0.4406275496723362, 0.3647495752161902, 0.35104771272631796, 0.32129370837133686, 0.3145722381892989, 0.2977847102879454, 0.2975529999725195, 0.28898620252116314, 0.3137956181835322, 0.3267581533766173, 0.3330980920336182, 0.1898882779819978, 0.1905400773304492, 0.18545963849958857, 0.18856014300619717, 0.21931369012724744, 0.1990457180226365, 0.20889701508602687, 0.17918548645071464, 0.18996285541952096, 0.23642946213293792, 0.3927603564406512, 0.24749623807951637, 0.19193963824809768, 0.18219160787894084, 0.21713294923741522, 0.221165022732153, 0.2170824145776833, 0.21595790950359184, 0.6431133147940391, 0.7910116517369107, 0.1526494517286039, 0.18367854971517794, 0.20943985436351187, 0.1959939509921974, 0.18284803815092687, 0.6095864501996766, 0.734668736213713, 0.6901716059296701, 0.20955375555447575, 0.6708621482076059, 0.6562094333851947, 0.7065753248293243, 0.2060075346519048, 0.749621608307204, 0.7240217086130991, 0.20907996605188905, 0.18263625118278404, 0.19256000426655284, 0.17657819589137957, 0.17729311771949818, 0.1922495866517835, 0.1990523094758524, 0.18017600315779692, 0.16894604412663083, 0.18586734217102652, 0.08068749109015605, 0.08347801844548375, 0.0782340926600047, 0.08345049371297841, 0.07374025617519131, 0.08647786369411792, 0.08067671222228345, 0.08609957232088361, 0.09423657106271999]}, "mutation_prompt": null}
{"id": "7c5d1b98-adc6-4337-8351-b6b76e3cedc4", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring a dynamic population size to enhance convergence speed.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8678eecb-2fc1-4c26-9fab-ffcefc4aa9aa", "metadata": {"aucs": [0.7405973988741354, 0.7281226209939119, 0.7324233204340155, 0.7489552261542903, 0.7498559026369704, 0.757519831874169, 0.7347098623601342, 0.7602786636377387, 0.7377784648945536, 0.56554125587102, 0.5944505024215752, 0.5808904441751737, 0.5747972667444257, 0.5671564195916405, 0.5961916655424153, 0.5838793849099935, 0.5852024604491162, 0.6063062861246697, 0.11341909746813339, 0.12215541600561153, 0.10085692900524679, 0.10487565508288299, 0.11036818339911192, 0.1016077518681705, 0.13666213112505554, 0.12709043286256294, 0.10861595266627522, 0.10165318727335015, 0.10505953366608245, 0.09783802420298959, 0.10172217148102114, 0.10536819228798322, 0.10900367665295507, 0.0964455393395891, 0.09024177262467925, 0.10437305516394613, 0.9548869183682216, 0.9816209304069197, 0.9712607491984208, 0.9634026914341834, 0.9234496339538826, 0.9622203012390651, 0.985079184370999, 0.9582775702855542, 0.9611271121617417, 0.4313765997319954, 0.4618145994111096, 0.40984676643380813, 0.41472757262044546, 0.36354377548699346, 0.3986783408643845, 0.4379164888621577, 0.40934147613419813, 0.35998487468993845, 0.6806130514358448, 0.6955121767822976, 0.6866807490914777, 0.6701999875888693, 0.6347825436279659, 0.6646026866550377, 0.6567034530055915, 0.6819668428073227, 0.6865650804245118, 0.24016363313740974, 0.22090206531540513, 0.17297907809772384, 0.19886709320385698, 0.2609815145734389, 0.18127297647829888, 0.1957417735940552, 0.22920999827866495, 0.18310000474785193, 0.193110013501813, 0.27693749544418755, 0.11368476511095227, 0.2043950030984022, 0.220306450983471, 0.16484688126919844, 0.16381494823035447, 0.18179600745406732, 0.14778597331998222, 0.30639582001449794, 0.27031080642673355, 0.3372871936467656, 0.33126944253156676, 0.3168027670970488, 0.36890694251841194, 0.2710681818949614, 0.3304548812663224, 0.2636668768734898, 0.399363666198819, 0.4391896350173363, 0.4251106318701794, 0.3957391328356439, 0.4173071637112098, 0.49114169125133744, 0.4571763095341902, 0.44105907891793006, 0.47543054954069286, 0.06983850752350995, 0.20587215387818425, 0.20247406425544145, 0.16216146868714298, 0.16946602502848995, 0.1167350874180072, 0.18066366226210884, 0.10466453986036195, 0.08431960773622249, 0.29775472663503366, 0.2701635789954244, 0.2961391035212847, 0.26748150670562176, 0.3418746895885989, 0.26193853866475514, 0.2980231606880872, 0.2481920681467945, 0.29270775966039486, 0.6392765826679037, 0.6490275061328654, 0.6434311797354066, 0.6101548565800816, 0.6705163158216997, 0.581715485322932, 0.6302372799063853, 0.6572822223214339, 0.63667360276885, 0.10946979306955906, 0.10495685013288236, 0.09854458937774613, 0.09716371232282162, 0.11476060783481101, 0.10180537332611694, 0.08978362639479653, 0.09895539925489538, 0.10411653850132274, 0.2633268434969652, 0.1788873209645211, 0.2264473851374672, 0.2507217028230929, 0.17913228377985901, 0.22891227141535053, 0.19110001644461017, 0.2139585020176098, 0.18290495053256972, 0.4135147594879234, 0.42148645148468744, 0.4163750662420447, 0.3786119686270838, 0.4413315433472095, 0.3775701429488637, 0.43907987101758084, 0.4406275496723362, 0.3647495752161902, 0.35104771272631796, 0.32129370837133686, 0.3145722381892989, 0.2977847102879454, 0.2975529999725195, 0.28898620252116314, 0.3137956181835322, 0.3267581533766173, 0.3330980920336182, 0.1898882779819978, 0.1905400773304492, 0.18545963849958857, 0.18856014300619717, 0.21931369012724744, 0.1990457180226365, 0.20889701508602687, 0.17918548645071464, 0.18996285541952096, 0.23642946213293792, 0.3927603564406512, 0.24749623807951637, 0.19193963824809768, 0.18219160787894084, 0.21713294923741522, 0.221165022732153, 0.2170824145776833, 0.21595790950359184, 0.6431133147940391, 0.7910116517369107, 0.1526494517286039, 0.18367854971517794, 0.20943985436351187, 0.1959939509921974, 0.18284803815092687, 0.6095864501996766, 0.734668736213713, 0.6901716059296701, 0.20955375555447575, 0.6708621482076059, 0.6562094333851947, 0.7065753248293243, 0.2060075346519048, 0.749621608307204, 0.7240217086130991, 0.20907996605188905, 0.18263625118278404, 0.19256000426655284, 0.17657819589137957, 0.17729311771949818, 0.1922495866517835, 0.1990523094758524, 0.18017600315779692, 0.16894604412663083, 0.18586734217102652, 0.08068749109015605, 0.08347801844548375, 0.0782340926600047, 0.08345049371297841, 0.07374025617519131, 0.08647786369411792, 0.08067671222228345, 0.08609957232088361, 0.09423657106271999]}, "mutation_prompt": null}
{"id": "4f4a6e52-b34b-4bd9-a01b-92ea01dbb391", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.5 * np.cos(np.pi * evals / self.budget)  # Increased dynamic range\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        sorted_indices = np.argsort(self.scores[:pop_size])\n        for best_idx in sorted_indices[:int(pop_size/3)]:  # More intensive local search on top-third best solutions\n            best = self.population[best_idx]\n            step_size = (self.upper_bound - self.lower_bound) * 0.05\n            for _ in range(3):  # Reduced local search steps\n                if eval_count >= self.budget:\n                    break\n                local_steps = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate)\n                eval_count += 1\n                if candidate_score < self.scores[best_idx]:\n                    self.population[best_idx] = candidate\n                    self.scores[best_idx] = candidate_score\n                    best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "An enhanced hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring a dynamic mutation factor and selective local search intensity to improve convergence speed.", "configspace": "", "generation": 66, "fitness": 0.2390905357346688, "feedback": "The algorithm DEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.20.", "error": "", "parent_id": "8678eecb-2fc1-4c26-9fab-ffcefc4aa9aa", "metadata": {"aucs": [0.5156990544112052, 0.5278966378082208, 0.5243561053580879, 0.5282838443367016, 0.5241236391785888, 0.5517655027443018, 0.5422302685925926, 0.5299469071341569, 0.5041234531314909, 0.1998412056507738, 0.19075547793898862, 0.22502852587902367, 0.2069689894026725, 0.2163589013426538, 0.21822230278591437, 0.21092902598360996, 0.20151433297282273, 0.2053948726798328, 0.09911574531617007, 0.09509167159926946, 0.08647505396961386, 0.07998525469182316, 0.08668565528156436, 0.08099997649036772, 0.09015856383601217, 0.11167114452942584, 0.1015556508732881, 0.07989383578349518, 0.0798208864683535, 0.07869997053201006, 0.0782965982033702, 0.07530678529537471, 0.07947101491985564, 0.08679399738622673, 0.08054503685938585, 0.07655278583575764, 0.9552400371310672, 0.9504297439802403, 0.9752558090903187, 0.9574797733904108, 0.9380000581979525, 0.9668557106604169, 0.9517705338945616, 0.9291980497355299, 0.9437158100127624, 0.2452929476599861, 0.24217960585508802, 0.25526121754733255, 0.23801050388829803, 0.24614036877946932, 0.2583162012271536, 0.2578930687066765, 0.23341616972814683, 0.25203231681712046, 0.44053061520047476, 0.3708757492029542, 0.38233283759169867, 0.41594285338983683, 0.4522914497211702, 0.4319092548459057, 0.38527222965314534, 0.3538246437102104, 0.3643746007845068, 0.14872444407739693, 0.15548365819508203, 0.12329314635037059, 0.1763216423150301, 0.1482897905600019, 0.16009131818491273, 0.15156702622566975, 0.1483795868491814, 0.1584262289139977, 0.21081169197303518, 0.17892933311776382, 0.16278986997795075, 0.1749841837854751, 0.1434215806305823, 0.1359733268090647, 0.18361939556603057, 0.13411098392769816, 0.17339325915902204, 0.08540552724814787, 0.050043062606472954, 0.054210698492749954, 0.07027987445008, 0.059476917581034794, 0.052638884234723404, 0.06816685072809725, 0.052670009329988554, 0.05591152673018207, 0.1704897725746709, 0.15941127365062002, 0.17181092415436416, 0.1778951882284664, 0.15487055039127284, 0.1475058055135734, 0.19413282137763088, 0.17250495709312474, 0.16826021586826523, 0.01720034400954662, 0.01685333546704537, 0.0051345289483810674, 0.003421119678185147, 0.02564350052303721, 0.01003011681056809, 0.01858284025087975, 0.017266405968943355, 0.019218288520674975, 0.1188411906224528, 0.11388788764416857, 0.12514255574257382, 0.1352642665872822, 0.10618193194409409, 0.13375243783241708, 0.1107314684383639, 0.12605520781687352, 0.129421519868955, 0.4330953573113261, 0.4472093598402149, 0.4444314704883, 0.4200767432439727, 0.43280824777008364, 0.4276453537211218, 0.46338160264874073, 0.4167280997944194, 0.4349190841899806, 0.08462268976952092, 0.09740996166297411, 0.10110249258747206, 0.08258313797233063, 0.07312078614560835, 0.08249901977154073, 0.1006608588877369, 0.08825888983684671, 0.09469709941893911, 0.19857769973915618, 0.2091285362363382, 0.21756052582431862, 0.19107483748601906, 0.18066387787402804, 0.2068804234575934, 0.21096023171307765, 0.18989255333904553, 0.22072454091029658, 0.2513533935752209, 0.2571465521207148, 0.24884320968882823, 0.24583441495046476, 0.2253496287503196, 0.2460807386693895, 0.24775784197620698, 0.28216948494302907, 0.26512729725004347, 0.1981794732461264, 0.17883783775484752, 0.18200194862118024, 0.17812807475357606, 0.19942317001772814, 0.17635449898812983, 0.19605116514933518, 0.21278105601419284, 0.2028021547671851, 0.1919632456617565, 0.19870335584616383, 0.18422569701390856, 0.19086147284510602, 0.19254644812633293, 0.19060611521414705, 0.17910654299026574, 0.19072598817322284, 0.18781709651791711, 0.20272498711068743, 0.18229358217610647, 0.17791821327283452, 0.18125895769148448, 0.18516679895528299, 0.1773663411374644, 0.17155283687089762, 0.18992133774010544, 0.18213021463665513, 0.4959510963471422, 0.508153394055359, 0.5500269017937476, 0.20491427026959053, 0.4838066108954272, 0.1897770155281372, 0.1986028587497849, 0.18497918791462997, 0.20339598875293108, 0.48136751757390095, 0.42574209076787983, 0.5552424538836086, 0.19665331260509467, 0.42607730146333356, 0.3590461143738698, 0.41767873733314154, 0.5610964058170794, 0.20674465645154838, 0.18515169740061133, 0.18910193209742376, 0.17793594978649452, 0.19605952632886114, 0.18732726495131902, 0.18432230218445578, 0.17439693971171943, 0.1896436582283616, 0.17989528532301613, 0.07408660423060831, 0.07217758142425168, 0.07552542990126332, 0.09289490983214765, 0.0807649663232669, 0.07180036317772898, 0.0746028842239237, 0.07693106797689142, 0.07853167700043051]}, "mutation_prompt": null}
{"id": "36358208-07aa-4ef7-ae72-b96adeb7c9a7", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring a dynamic population size to enhance convergence speed.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8678eecb-2fc1-4c26-9fab-ffcefc4aa9aa", "metadata": {"aucs": [0.7405973988741354, 0.7281226209939119, 0.7324233204340155, 0.7489552261542903, 0.7498559026369704, 0.757519831874169, 0.7347098623601342, 0.7602786636377387, 0.7377784648945536, 0.56554125587102, 0.5944505024215752, 0.5808904441751737, 0.5747972667444257, 0.5671564195916405, 0.5961916655424153, 0.5838793849099935, 0.5852024604491162, 0.6063062861246697, 0.11341909746813339, 0.12215541600561153, 0.10085692900524679, 0.10487565508288299, 0.11036818339911192, 0.1016077518681705, 0.13666213112505554, 0.12709043286256294, 0.10861595266627522, 0.10165318727335015, 0.10505953366608245, 0.09783802420298959, 0.10172217148102114, 0.10536819228798322, 0.10900367665295507, 0.0964455393395891, 0.09024177262467925, 0.10437305516394613, 0.9548869183682216, 0.9816209304069197, 0.9712607491984208, 0.9634026914341834, 0.9234496339538826, 0.9622203012390651, 0.985079184370999, 0.9582775702855542, 0.9611271121617417, 0.4313765997319954, 0.4618145994111096, 0.40984676643380813, 0.41472757262044546, 0.36354377548699346, 0.3986783408643845, 0.4379164888621577, 0.40934147613419813, 0.35998487468993845, 0.6806130514358448, 0.6955121767822976, 0.6866807490914777, 0.6701999875888693, 0.6347825436279659, 0.6646026866550377, 0.6567034530055915, 0.6819668428073227, 0.6865650804245118, 0.24016363313740974, 0.22090206531540513, 0.17297907809772384, 0.19886709320385698, 0.2609815145734389, 0.18127297647829888, 0.1957417735940552, 0.22920999827866495, 0.18310000474785193, 0.193110013501813, 0.27693749544418755, 0.11368476511095227, 0.2043950030984022, 0.220306450983471, 0.16484688126919844, 0.16381494823035447, 0.18179600745406732, 0.14778597331998222, 0.30639582001449794, 0.27031080642673355, 0.3372871936467656, 0.33126944253156676, 0.3168027670970488, 0.36890694251841194, 0.2710681818949614, 0.3304548812663224, 0.2636668768734898, 0.399363666198819, 0.4391896350173363, 0.4251106318701794, 0.3957391328356439, 0.4173071637112098, 0.49114169125133744, 0.4571763095341902, 0.44105907891793006, 0.47543054954069286, 0.06983850752350995, 0.20587215387818425, 0.20247406425544145, 0.16216146868714298, 0.16946602502848995, 0.1167350874180072, 0.18066366226210884, 0.10466453986036195, 0.08431960773622249, 0.29775472663503366, 0.2701635789954244, 0.2961391035212847, 0.26748150670562176, 0.3418746895885989, 0.26193853866475514, 0.2980231606880872, 0.2481920681467945, 0.29270775966039486, 0.6392765826679037, 0.6490275061328654, 0.6434311797354066, 0.6101548565800816, 0.6705163158216997, 0.581715485322932, 0.6302372799063853, 0.6572822223214339, 0.63667360276885, 0.10946979306955906, 0.10495685013288236, 0.09854458937774613, 0.09716371232282162, 0.11476060783481101, 0.10180537332611694, 0.08978362639479653, 0.09895539925489538, 0.10411653850132274, 0.2633268434969652, 0.1788873209645211, 0.2264473851374672, 0.2507217028230929, 0.17913228377985901, 0.22891227141535053, 0.19110001644461017, 0.2139585020176098, 0.18290495053256972, 0.4135147594879234, 0.42148645148468744, 0.4163750662420447, 0.3786119686270838, 0.4413315433472095, 0.3775701429488637, 0.43907987101758084, 0.4406275496723362, 0.3647495752161902, 0.35104771272631796, 0.32129370837133686, 0.3145722381892989, 0.2977847102879454, 0.2975529999725195, 0.28898620252116314, 0.3137956181835322, 0.3267581533766173, 0.3330980920336182, 0.1898882779819978, 0.1905400773304492, 0.18545963849958857, 0.18856014300619717, 0.21931369012724744, 0.1990457180226365, 0.20889701508602687, 0.17918548645071464, 0.18996285541952096, 0.23642946213293792, 0.3927603564406512, 0.24749623807951637, 0.19193963824809768, 0.18219160787894084, 0.21713294923741522, 0.221165022732153, 0.2170824145776833, 0.21595790950359184, 0.6431133147940391, 0.7910116517369107, 0.1526494517286039, 0.18367854971517794, 0.20943985436351187, 0.1959939509921974, 0.18284803815092687, 0.6095864501996766, 0.734668736213713, 0.6901716059296701, 0.20955375555447575, 0.6708621482076059, 0.6562094333851947, 0.7065753248293243, 0.2060075346519048, 0.749621608307204, 0.7240217086130991, 0.20907996605188905, 0.18263625118278404, 0.19256000426655284, 0.17657819589137957, 0.17729311771949818, 0.1922495866517835, 0.1990523094758524, 0.18017600315779692, 0.16894604412663083, 0.18586734217102652, 0.08068749109015605, 0.08347801844548375, 0.0782340926600047, 0.08345049371297841, 0.07374025617519131, 0.08647786369411792, 0.08067671222228345, 0.08609957232088361, 0.09423657106271999]}, "mutation_prompt": null}
{"id": "23824c1b-5630-47f4-93e7-aa3efc04f5b0", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring a dynamic population size to enhance convergence speed.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8678eecb-2fc1-4c26-9fab-ffcefc4aa9aa", "metadata": {"aucs": [0.7405973988741354, 0.7281226209939119, 0.7324233204340155, 0.7489552261542903, 0.7498559026369704, 0.757519831874169, 0.7347098623601342, 0.7602786636377387, 0.7377784648945536, 0.56554125587102, 0.5944505024215752, 0.5808904441751737, 0.5747972667444257, 0.5671564195916405, 0.5961916655424153, 0.5838793849099935, 0.5852024604491162, 0.6063062861246697, 0.11341909746813339, 0.12215541600561153, 0.10085692900524679, 0.10487565508288299, 0.11036818339911192, 0.1016077518681705, 0.13666213112505554, 0.12709043286256294, 0.10861595266627522, 0.10165318727335015, 0.10505953366608245, 0.09783802420298959, 0.10172217148102114, 0.10536819228798322, 0.10900367665295507, 0.0964455393395891, 0.09024177262467925, 0.10437305516394613, 0.9548869183682216, 0.9816209304069197, 0.9712607491984208, 0.9634026914341834, 0.9234496339538826, 0.9622203012390651, 0.985079184370999, 0.9582775702855542, 0.9611271121617417, 0.4313765997319954, 0.4618145994111096, 0.40984676643380813, 0.41472757262044546, 0.36354377548699346, 0.3986783408643845, 0.4379164888621577, 0.40934147613419813, 0.35998487468993845, 0.6806130514358448, 0.6955121767822976, 0.6866807490914777, 0.6701999875888693, 0.6347825436279659, 0.6646026866550377, 0.6567034530055915, 0.6819668428073227, 0.6865650804245118, 0.24016363313740974, 0.22090206531540513, 0.17297907809772384, 0.19886709320385698, 0.2609815145734389, 0.18127297647829888, 0.1957417735940552, 0.22920999827866495, 0.18310000474785193, 0.193110013501813, 0.27693749544418755, 0.11368476511095227, 0.2043950030984022, 0.220306450983471, 0.16484688126919844, 0.16381494823035447, 0.18179600745406732, 0.14778597331998222, 0.30639582001449794, 0.27031080642673355, 0.3372871936467656, 0.33126944253156676, 0.3168027670970488, 0.36890694251841194, 0.2710681818949614, 0.3304548812663224, 0.2636668768734898, 0.399363666198819, 0.4391896350173363, 0.4251106318701794, 0.3957391328356439, 0.4173071637112098, 0.49114169125133744, 0.4571763095341902, 0.44105907891793006, 0.47543054954069286, 0.06983850752350995, 0.20587215387818425, 0.20247406425544145, 0.16216146868714298, 0.16946602502848995, 0.1167350874180072, 0.18066366226210884, 0.10466453986036195, 0.08431960773622249, 0.29775472663503366, 0.2701635789954244, 0.2961391035212847, 0.26748150670562176, 0.3418746895885989, 0.26193853866475514, 0.2980231606880872, 0.2481920681467945, 0.29270775966039486, 0.6392765826679037, 0.6490275061328654, 0.6434311797354066, 0.6101548565800816, 0.6705163158216997, 0.581715485322932, 0.6302372799063853, 0.6572822223214339, 0.63667360276885, 0.10946979306955906, 0.10495685013288236, 0.09854458937774613, 0.09716371232282162, 0.11476060783481101, 0.10180537332611694, 0.08978362639479653, 0.09895539925489538, 0.10411653850132274, 0.2633268434969652, 0.1788873209645211, 0.2264473851374672, 0.2507217028230929, 0.17913228377985901, 0.22891227141535053, 0.19110001644461017, 0.2139585020176098, 0.18290495053256972, 0.4135147594879234, 0.42148645148468744, 0.4163750662420447, 0.3786119686270838, 0.4413315433472095, 0.3775701429488637, 0.43907987101758084, 0.4406275496723362, 0.3647495752161902, 0.35104771272631796, 0.32129370837133686, 0.3145722381892989, 0.2977847102879454, 0.2975529999725195, 0.28898620252116314, 0.3137956181835322, 0.3267581533766173, 0.3330980920336182, 0.1898882779819978, 0.1905400773304492, 0.18545963849958857, 0.18856014300619717, 0.21931369012724744, 0.1990457180226365, 0.20889701508602687, 0.17918548645071464, 0.18996285541952096, 0.23642946213293792, 0.3927603564406512, 0.24749623807951637, 0.19193963824809768, 0.18219160787894084, 0.21713294923741522, 0.221165022732153, 0.2170824145776833, 0.21595790950359184, 0.6431133147940391, 0.7910116517369107, 0.1526494517286039, 0.18367854971517794, 0.20943985436351187, 0.1959939509921974, 0.18284803815092687, 0.6095864501996766, 0.734668736213713, 0.6901716059296701, 0.20955375555447575, 0.6708621482076059, 0.6562094333851947, 0.7065753248293243, 0.2060075346519048, 0.749621608307204, 0.7240217086130991, 0.20907996605188905, 0.18263625118278404, 0.19256000426655284, 0.17657819589137957, 0.17729311771949818, 0.1922495866517835, 0.1990523094758524, 0.18017600315779692, 0.16894604412663083, 0.18586734217102652, 0.08068749109015605, 0.08347801844548375, 0.0782340926600047, 0.08345049371297841, 0.07374025617519131, 0.08647786369411792, 0.08067671222228345, 0.08609957232088361, 0.09423657106271999]}, "mutation_prompt": null}
{"id": "09d92345-c1fd-4691-8379-f6ecc5d90470", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring a dynamic population size to enhance convergence speed.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8678eecb-2fc1-4c26-9fab-ffcefc4aa9aa", "metadata": {"aucs": [0.7405973988741354, 0.7281226209939119, 0.7324233204340155, 0.7489552261542903, 0.7498559026369704, 0.757519831874169, 0.7347098623601342, 0.7602786636377387, 0.7377784648945536, 0.56554125587102, 0.5944505024215752, 0.5808904441751737, 0.5747972667444257, 0.5671564195916405, 0.5961916655424153, 0.5838793849099935, 0.5852024604491162, 0.6063062861246697, 0.11341909746813339, 0.12215541600561153, 0.10085692900524679, 0.10487565508288299, 0.11036818339911192, 0.1016077518681705, 0.13666213112505554, 0.12709043286256294, 0.10861595266627522, 0.10165318727335015, 0.10505953366608245, 0.09783802420298959, 0.10172217148102114, 0.10536819228798322, 0.10900367665295507, 0.0964455393395891, 0.09024177262467925, 0.10437305516394613, 0.9548869183682216, 0.9816209304069197, 0.9712607491984208, 0.9634026914341834, 0.9234496339538826, 0.9622203012390651, 0.985079184370999, 0.9582775702855542, 0.9611271121617417, 0.4313765997319954, 0.4618145994111096, 0.40984676643380813, 0.41472757262044546, 0.36354377548699346, 0.3986783408643845, 0.4379164888621577, 0.40934147613419813, 0.35998487468993845, 0.6806130514358448, 0.6955121767822976, 0.6866807490914777, 0.6701999875888693, 0.6347825436279659, 0.6646026866550377, 0.6567034530055915, 0.6819668428073227, 0.6865650804245118, 0.24016363313740974, 0.22090206531540513, 0.17297907809772384, 0.19886709320385698, 0.2609815145734389, 0.18127297647829888, 0.1957417735940552, 0.22920999827866495, 0.18310000474785193, 0.193110013501813, 0.27693749544418755, 0.11368476511095227, 0.2043950030984022, 0.220306450983471, 0.16484688126919844, 0.16381494823035447, 0.18179600745406732, 0.14778597331998222, 0.30639582001449794, 0.27031080642673355, 0.3372871936467656, 0.33126944253156676, 0.3168027670970488, 0.36890694251841194, 0.2710681818949614, 0.3304548812663224, 0.2636668768734898, 0.399363666198819, 0.4391896350173363, 0.4251106318701794, 0.3957391328356439, 0.4173071637112098, 0.49114169125133744, 0.4571763095341902, 0.44105907891793006, 0.47543054954069286, 0.06983850752350995, 0.20587215387818425, 0.20247406425544145, 0.16216146868714298, 0.16946602502848995, 0.1167350874180072, 0.18066366226210884, 0.10466453986036195, 0.08431960773622249, 0.29775472663503366, 0.2701635789954244, 0.2961391035212847, 0.26748150670562176, 0.3418746895885989, 0.26193853866475514, 0.2980231606880872, 0.2481920681467945, 0.29270775966039486, 0.6392765826679037, 0.6490275061328654, 0.6434311797354066, 0.6101548565800816, 0.6705163158216997, 0.581715485322932, 0.6302372799063853, 0.6572822223214339, 0.63667360276885, 0.10946979306955906, 0.10495685013288236, 0.09854458937774613, 0.09716371232282162, 0.11476060783481101, 0.10180537332611694, 0.08978362639479653, 0.09895539925489538, 0.10411653850132274, 0.2633268434969652, 0.1788873209645211, 0.2264473851374672, 0.2507217028230929, 0.17913228377985901, 0.22891227141535053, 0.19110001644461017, 0.2139585020176098, 0.18290495053256972, 0.4135147594879234, 0.42148645148468744, 0.4163750662420447, 0.3786119686270838, 0.4413315433472095, 0.3775701429488637, 0.43907987101758084, 0.4406275496723362, 0.3647495752161902, 0.35104771272631796, 0.32129370837133686, 0.3145722381892989, 0.2977847102879454, 0.2975529999725195, 0.28898620252116314, 0.3137956181835322, 0.3267581533766173, 0.3330980920336182, 0.1898882779819978, 0.1905400773304492, 0.18545963849958857, 0.18856014300619717, 0.21931369012724744, 0.1990457180226365, 0.20889701508602687, 0.17918548645071464, 0.18996285541952096, 0.23642946213293792, 0.3927603564406512, 0.24749623807951637, 0.19193963824809768, 0.18219160787894084, 0.21713294923741522, 0.221165022732153, 0.2170824145776833, 0.21595790950359184, 0.6431133147940391, 0.7910116517369107, 0.1526494517286039, 0.18367854971517794, 0.20943985436351187, 0.1959939509921974, 0.18284803815092687, 0.6095864501996766, 0.734668736213713, 0.6901716059296701, 0.20955375555447575, 0.6708621482076059, 0.6562094333851947, 0.7065753248293243, 0.2060075346519048, 0.749621608307204, 0.7240217086130991, 0.20907996605188905, 0.18263625118278404, 0.19256000426655284, 0.17657819589137957, 0.17729311771949818, 0.1922495866517835, 0.1990523094758524, 0.18017600315779692, 0.16894604412663083, 0.18586734217102652, 0.08068749109015605, 0.08347801844548375, 0.0782340926600047, 0.08345049371297841, 0.07374025617519131, 0.08647786369411792, 0.08067671222228345, 0.08609957232088361, 0.09423657106271999]}, "mutation_prompt": null}
{"id": "cc790f62-aa6f-4114-81f3-eab868519eee", "solution": "import numpy as np\n\nclass EnhancedDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F = 0.8  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n        self.dynamic_CR = lambda evals: 0.7 + 0.2 * np.sin(np.pi * evals / self.budget)  # New dynamic crossover\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                current_CR = self.dynamic_CR(eval_count)  # Use dynamic CR\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant, current_CR)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant, CR):\n        crossover_mask = np.random.rand(self.dim) < CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "EnhancedDEALS", "description": "An enhanced version of DEALS with dynamic adaptive mutation and crossover strategies for improved convergence speed.", "configspace": "", "generation": 70, "fitness": 0.34039342846395176, "feedback": "The algorithm EnhancedDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.24.", "error": "", "parent_id": "8678eecb-2fc1-4c26-9fab-ffcefc4aa9aa", "metadata": {"aucs": [0.7357697859127665, 0.7429340655622662, 0.7398162651992984, 0.7511294330534317, 0.7482606208651644, 0.7367497846695341, 0.7318944735542747, 0.7406711538801485, 0.743424330171167, 0.5706026739887894, 0.5922740253113347, 0.5832165475804523, 0.5766014379804871, 0.586504093201125, 0.592472182448272, 0.6027353094898024, 0.5861666347242775, 0.6006686103437899, 0.11206449910807437, 0.12065469778131266, 0.10271347853964685, 0.11317429766621667, 0.12596910194488087, 0.11959688120797196, 0.10362707700846385, 0.11164889030293412, 0.13047489124927725, 0.10923344248910494, 0.10993457973402132, 0.11004162179763244, 0.1119633908559079, 0.10033327671131864, 0.11034878329960174, 0.10663179613385765, 0.1042809353775227, 0.09953878344220468, 0.9520735115968972, 0.9852483605417505, 0.9482596058915369, 0.9538490858595248, 0.9695113658697108, 0.9606155848559221, 0.9524928636451229, 0.9662403091732882, 0.9562094424998724, 0.3885577193295231, 0.42849873288529206, 0.3759563654765665, 0.43504234664907404, 0.401426325476254, 0.3693249262900108, 0.3768855144896148, 0.40905388922103403, 0.39220784569749745, 0.613637577686782, 0.6429222554199907, 0.6321840413069956, 0.6747030153375804, 0.6388793009641944, 0.6436555939578303, 0.6285835696090745, 0.6420550361325983, 0.6404413147039578, 0.14433526655107887, 0.1958092393813584, 0.29473582435116064, 0.17649844124256064, 0.19324243072619618, 0.2108457286520986, 0.17044233526373243, 0.18871747892975155, 0.2737381765703978, 0.21930100219920545, 0.22550998570547454, 0.14959760129990718, 0.1799818149047564, 0.15990463191141824, 0.2067435124907735, 0.1853055620118883, 0.20251023181932892, 0.1454453970331855, 0.199694867306768, 0.23120037187812403, 0.19660688657851433, 0.3937331058907738, 0.26307152965961655, 0.2534493972315086, 0.3302313631479331, 0.20834105027874816, 0.374546668423025, 0.32335212210636965, 0.30795196140544967, 0.33289429132531867, 0.31009290312150806, 0.41845668401108194, 0.3569714659835227, 0.4324449833028272, 0.4711266390576041, 0.3356607971679253, 0.08891220688261325, 0.11987401927747543, 0.12016368566484492, 0.1242309525335209, 0.14073215454769838, 0.13410127607551459, 0.09923397335673634, 0.10992059548772526, 0.115569531261143, 0.2570800582145819, 0.29183536283134803, 0.28955833665869823, 0.28786587751290194, 0.2999204006338003, 0.29825520694491314, 0.23811410045209158, 0.27351489483245306, 0.2624875557721894, 0.6443833467819702, 0.6189603627581706, 0.5976008001941135, 0.6704127706148548, 0.630008100072412, 0.6542955448423797, 0.6419642086768405, 0.6488302739302492, 0.6175675408339442, 0.09633654743695674, 0.10863867545329464, 0.09484935363495572, 0.09534056170581173, 0.08282833279307511, 0.09825085801551192, 0.09159598664866841, 0.0905915294298908, 0.1053075876955003, 0.19660186248993883, 0.1758425634608749, 0.20241152389963135, 0.20190717975372774, 0.18276759126557396, 0.21390576450455245, 0.1884410538347363, 0.18664751972442528, 0.17006659251608658, 0.3466194965721483, 0.3867634675801124, 0.412097097268348, 0.3681605844097955, 0.374020162210862, 0.39080465656676544, 0.4166893433756169, 0.44641903519516657, 0.4204050015768669, 0.3307034229534831, 0.28195234785140555, 0.3000795874774608, 0.29049022907745026, 0.3394005898483169, 0.28445745776402465, 0.29721942862058937, 0.32159210656519577, 0.3423072681121244, 0.18547704423996525, 0.1812352339332559, 0.18504790501007662, 0.18843647485401938, 0.17847096322096145, 0.19055271636710913, 0.18463619269979292, 0.22883860128030942, 0.21407027307348325, 0.29667949864235, 0.2132353421266021, 0.1837035335216186, 0.212309767596638, 0.2228540603457564, 0.23373211258978832, 0.21162361374951466, 0.23065447204571932, 0.24061061695120456, 0.6327909027154359, 0.16419231573205617, 0.1676027028413526, 0.6787256812715663, 0.19717489768707175, 0.16321760818213626, 0.644746445241942, 0.36318612165219444, 0.647558652060092, 0.6567957615231925, 0.5042221249082302, 0.5982671018167245, 0.187269597711756, 0.2987215343016033, 0.42722796317368283, 0.20932818081911408, 0.6881369222729579, 0.6942061166028051, 0.1982686006020774, 0.19497130752160385, 0.18729486516433058, 0.19323732032980157, 0.19685247580854348, 0.17067731521104268, 0.17257484158012704, 0.1922580165742328, 0.18514222901352761, 0.07802389412644029, 0.0802419091029758, 0.08332849861042269, 0.08212460125005472, 0.07789944160342877, 0.07302752002592339, 0.08027408348832354, 0.07511694107273759, 0.08509302735705404]}, "mutation_prompt": null}
{"id": "6471d923-45e7-4796-b2d8-b8072658575f", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring a dynamic population size to enhance convergence speed.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8678eecb-2fc1-4c26-9fab-ffcefc4aa9aa", "metadata": {"aucs": [0.7405973988741354, 0.7281226209939119, 0.7324233204340155, 0.7489552261542903, 0.7498559026369704, 0.757519831874169, 0.7347098623601342, 0.7602786636377387, 0.7377784648945536, 0.56554125587102, 0.5944505024215752, 0.5808904441751737, 0.5747972667444257, 0.5671564195916405, 0.5961916655424153, 0.5838793849099935, 0.5852024604491162, 0.6063062861246697, 0.11341909746813339, 0.12215541600561153, 0.10085692900524679, 0.10487565508288299, 0.11036818339911192, 0.1016077518681705, 0.13666213112505554, 0.12709043286256294, 0.10861595266627522, 0.10165318727335015, 0.10505953366608245, 0.09783802420298959, 0.10172217148102114, 0.10536819228798322, 0.10900367665295507, 0.0964455393395891, 0.09024177262467925, 0.10437305516394613, 0.9548869183682216, 0.9816209304069197, 0.9712607491984208, 0.9634026914341834, 0.9234496339538826, 0.9622203012390651, 0.985079184370999, 0.9582775702855542, 0.9611271121617417, 0.4313765997319954, 0.4618145994111096, 0.40984676643380813, 0.41472757262044546, 0.36354377548699346, 0.3986783408643845, 0.4379164888621577, 0.40934147613419813, 0.35998487468993845, 0.6806130514358448, 0.6955121767822976, 0.6866807490914777, 0.6701999875888693, 0.6347825436279659, 0.6646026866550377, 0.6567034530055915, 0.6819668428073227, 0.6865650804245118, 0.24016363313740974, 0.22090206531540513, 0.17297907809772384, 0.19886709320385698, 0.2609815145734389, 0.18127297647829888, 0.1957417735940552, 0.22920999827866495, 0.18310000474785193, 0.193110013501813, 0.27693749544418755, 0.11368476511095227, 0.2043950030984022, 0.220306450983471, 0.16484688126919844, 0.16381494823035447, 0.18179600745406732, 0.14778597331998222, 0.30639582001449794, 0.27031080642673355, 0.3372871936467656, 0.33126944253156676, 0.3168027670970488, 0.36890694251841194, 0.2710681818949614, 0.3304548812663224, 0.2636668768734898, 0.399363666198819, 0.4391896350173363, 0.4251106318701794, 0.3957391328356439, 0.4173071637112098, 0.49114169125133744, 0.4571763095341902, 0.44105907891793006, 0.47543054954069286, 0.06983850752350995, 0.20587215387818425, 0.20247406425544145, 0.16216146868714298, 0.16946602502848995, 0.1167350874180072, 0.18066366226210884, 0.10466453986036195, 0.08431960773622249, 0.29775472663503366, 0.2701635789954244, 0.2961391035212847, 0.26748150670562176, 0.3418746895885989, 0.26193853866475514, 0.2980231606880872, 0.2481920681467945, 0.29270775966039486, 0.6392765826679037, 0.6490275061328654, 0.6434311797354066, 0.6101548565800816, 0.6705163158216997, 0.581715485322932, 0.6302372799063853, 0.6572822223214339, 0.63667360276885, 0.10946979306955906, 0.10495685013288236, 0.09854458937774613, 0.09716371232282162, 0.11476060783481101, 0.10180537332611694, 0.08978362639479653, 0.09895539925489538, 0.10411653850132274, 0.2633268434969652, 0.1788873209645211, 0.2264473851374672, 0.2507217028230929, 0.17913228377985901, 0.22891227141535053, 0.19110001644461017, 0.2139585020176098, 0.18290495053256972, 0.4135147594879234, 0.42148645148468744, 0.4163750662420447, 0.3786119686270838, 0.4413315433472095, 0.3775701429488637, 0.43907987101758084, 0.4406275496723362, 0.3647495752161902, 0.35104771272631796, 0.32129370837133686, 0.3145722381892989, 0.2977847102879454, 0.2975529999725195, 0.28898620252116314, 0.3137956181835322, 0.3267581533766173, 0.3330980920336182, 0.1898882779819978, 0.1905400773304492, 0.18545963849958857, 0.18856014300619717, 0.21931369012724744, 0.1990457180226365, 0.20889701508602687, 0.17918548645071464, 0.18996285541952096, 0.23642946213293792, 0.3927603564406512, 0.24749623807951637, 0.19193963824809768, 0.18219160787894084, 0.21713294923741522, 0.221165022732153, 0.2170824145776833, 0.21595790950359184, 0.6431133147940391, 0.7910116517369107, 0.1526494517286039, 0.18367854971517794, 0.20943985436351187, 0.1959939509921974, 0.18284803815092687, 0.6095864501996766, 0.734668736213713, 0.6901716059296701, 0.20955375555447575, 0.6708621482076059, 0.6562094333851947, 0.7065753248293243, 0.2060075346519048, 0.749621608307204, 0.7240217086130991, 0.20907996605188905, 0.18263625118278404, 0.19256000426655284, 0.17657819589137957, 0.17729311771949818, 0.1922495866517835, 0.1990523094758524, 0.18017600315779692, 0.16894604412663083, 0.18586734217102652, 0.08068749109015605, 0.08347801844548375, 0.0782340926600047, 0.08345049371297841, 0.07374025617519131, 0.08647786369411792, 0.08067671222228345, 0.08609957232088361, 0.09423657106271999]}, "mutation_prompt": null}
{"id": "adda5703-7fb4-4e70-b5b9-6c26cb8a5895", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n        self.dynamic_CR = lambda evals: 0.8 + 0.1 * np.sin(np.pi * evals / self.budget)  # New dynamic crossover rate\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                current_CR = self.dynamic_CR(eval_count)  # Use dynamic crossover rate\n                trial = self.crossover(self.population[i], mutant, current_CR)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        # Improved mutation strategy using weighted random selection\n        mutation = a + F * ((b - c) + 0.5 * (a - b))\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant, CR):\n        crossover_mask = np.random.rand(self.dim) < CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) using an improved mutation strategy and dynamic crossover rate to enhance convergence speed.", "configspace": "", "generation": 72, "fitness": 0.2898963242109926, "feedback": "The algorithm DEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "8678eecb-2fc1-4c26-9fab-ffcefc4aa9aa", "metadata": {"aucs": [0.6786461201368039, 0.6674716179990481, 0.6438921931726944, 0.6802850034458909, 0.6824668895810108, 0.6475221259350916, 0.6871296126256288, 0.678607708266578, 0.6758646242268329, 0.5148735943106686, 0.5351547915048487, 0.49684042082366797, 0.48630220739634056, 0.4963952379979838, 0.4999109183196061, 0.426462707986457, 0.4904863948938478, 0.4539689469773882, 0.09730582806056354, 0.09957268867073199, 0.1487946532185217, 0.1130883841440733, 0.09858215648864566, 0.10806660210768315, 0.09870411371553223, 0.10096074679840017, 0.09599229130391485, 0.0946070846256909, 0.1010926671611656, 0.09510475925169681, 0.0935299705158773, 0.10339301278376478, 0.08384980113081342, 0.10476399074112464, 0.09335701089277681, 0.09620976115816904, 0.9632954091290261, 0.9728736684137207, 0.9602658421575448, 0.9714783624705028, 0.9429611481074464, 0.9726194991678928, 0.9862416501798467, 0.9616447273931752, 0.9703941087756377, 0.3628050154782917, 0.3658164642030347, 0.34486950557009854, 0.41277347466600545, 0.37136940009005204, 0.32820111253877593, 0.42542371627986375, 0.3893021271308814, 0.39045841204394316, 0.5905993666770053, 0.5928158025437797, 0.5587851232871013, 0.6404083312126105, 0.5906361574113812, 0.5881359493661085, 0.5992614399050327, 0.6176840494611162, 0.6016925084378999, 0.14069611619214173, 0.29493927539578113, 0.13960457202780585, 0.15941120657706342, 0.1648509010735283, 0.16771952281939484, 0.18630087791487548, 0.1293072267658536, 0.17756246726031277, 0.14540853895284456, 0.12983171436303342, 0.16821119022848763, 0.18003233261866458, 0.28141310634352545, 0.17903092687912758, 0.22723238390228506, 0.14884105307900863, 0.19337595158003051, 0.1615583610692949, 0.09734482670484579, 0.12806609680806635, 0.18519454225878895, 0.11030844047705757, 0.25624127077956294, 0.1842937486506403, 0.15477205263145277, 0.06761793920537706, 0.2001294773624207, 0.25910916861384126, 0.3018262775879855, 0.1980131504137307, 0.24451996594576753, 0.16436941048981624, 0.23252947016604641, 0.33496166434204655, 0.35421766086444373, 0.1059615337811105, 0.02411450409675675, 0.07580675436097972, 0.08019973812701375, 0.12115319389360013, 0.057594787070854525, 0.10575304599830448, 0.05460008270307515, 0.09836008609956604, 0.22498023005986656, 0.19046696888942383, 0.22133320095179343, 0.1996085244674599, 0.13659055091368633, 0.20313399700407742, 0.1735381528968808, 0.1692959014234381, 0.20728380577170757, 0.5355105467973749, 0.5777076584598435, 0.5027662180841528, 0.5526210478793694, 0.5598686125551483, 0.47041606327055574, 0.49079608754315707, 0.47495511145593605, 0.49550535565349296, 0.09007869672837054, 0.09499384774997688, 0.09260273568003252, 0.09781037293130335, 0.11216941943073722, 0.09307852321771681, 0.09661286164473681, 0.08819242747264455, 0.0974692122108447, 0.19040051431146776, 0.17649383452069978, 0.19256903261544345, 0.1915477118566863, 0.19065294432287272, 0.18018727462911133, 0.18656945162471017, 0.21602465851194486, 0.2304569842086971, 0.3371339861386494, 0.36028074320047476, 0.3467394789175616, 0.3464289125378144, 0.4076580279623552, 0.3500699168401957, 0.3596649956821616, 0.35087673115145324, 0.30820929558912646, 0.2515818591150276, 0.24971064772366613, 0.27467141239141935, 0.2737251615168348, 0.25962345569540335, 0.22142666778063091, 0.282931726748161, 0.31692929707442075, 0.3173296485191993, 0.1924433198190174, 0.18576496096180495, 0.2059688411099191, 0.17957966144229598, 0.1759239084255223, 0.19293941013391913, 0.18184378300379245, 0.1788937462905582, 0.19428266771341174, 0.20454697348888928, 0.20950955356103196, 0.19530948348756128, 0.19403057082567632, 0.20578237500015106, 0.24559151338112395, 0.17847642326251167, 0.1995572189375272, 0.18042356863745135, 0.43869459427489044, 0.15935148757057727, 0.16396831865112327, 0.18317410841690207, 0.19224635845469662, 0.19353921933911666, 0.18410618352096608, 0.4266567776706026, 0.2028404263348279, 0.33154355598571605, 0.26929945183379556, 0.20584444489460685, 0.5982249009171945, 0.20573895658635133, 0.26980049698836195, 0.4504232144626903, 0.12633550821343886, 0.21085821318315134, 0.17727425802437013, 0.22043517890965036, 0.1836426209832217, 0.1908457470633098, 0.19238086424846756, 0.18687866576254852, 0.18823453419729907, 0.1681654488488895, 0.18370363136775714, 0.08532147530375478, 0.07427420679885943, 0.06768368793882296, 0.07162911037622965, 0.08724345061454353, 0.07598002611275201, 0.06943449556119718, 0.07117347728765366, 0.07605482612047088]}, "mutation_prompt": null}
{"id": "7f607c4d-87b5-4080-b9a5-294d7422fef7", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F = 0.8  # Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: 0.5 + 0.3 * np.cos(np.pi * evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring a dynamic population size to enhance convergence speed.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8678eecb-2fc1-4c26-9fab-ffcefc4aa9aa", "metadata": {"aucs": [0.7405973988741354, 0.7281226209939119, 0.7324233204340155, 0.7489552261542903, 0.7498559026369704, 0.757519831874169, 0.7347098623601342, 0.7602786636377387, 0.7377784648945536, 0.56554125587102, 0.5944505024215752, 0.5808904441751737, 0.5747972667444257, 0.5671564195916405, 0.5961916655424153, 0.5838793849099935, 0.5852024604491162, 0.6063062861246697, 0.11341909746813339, 0.12215541600561153, 0.10085692900524679, 0.10487565508288299, 0.11036818339911192, 0.1016077518681705, 0.13666213112505554, 0.12709043286256294, 0.10861595266627522, 0.10165318727335015, 0.10505953366608245, 0.09783802420298959, 0.10172217148102114, 0.10536819228798322, 0.10900367665295507, 0.0964455393395891, 0.09024177262467925, 0.10437305516394613, 0.9548869183682216, 0.9816209304069197, 0.9712607491984208, 0.9634026914341834, 0.9234496339538826, 0.9622203012390651, 0.985079184370999, 0.9582775702855542, 0.9611271121617417, 0.4313765997319954, 0.4618145994111096, 0.40984676643380813, 0.41472757262044546, 0.36354377548699346, 0.3986783408643845, 0.4379164888621577, 0.40934147613419813, 0.35998487468993845, 0.6806130514358448, 0.6955121767822976, 0.6866807490914777, 0.6701999875888693, 0.6347825436279659, 0.6646026866550377, 0.6567034530055915, 0.6819668428073227, 0.6865650804245118, 0.24016363313740974, 0.22090206531540513, 0.17297907809772384, 0.19886709320385698, 0.2609815145734389, 0.18127297647829888, 0.1957417735940552, 0.22920999827866495, 0.18310000474785193, 0.193110013501813, 0.27693749544418755, 0.11368476511095227, 0.2043950030984022, 0.220306450983471, 0.16484688126919844, 0.16381494823035447, 0.18179600745406732, 0.14778597331998222, 0.30639582001449794, 0.27031080642673355, 0.3372871936467656, 0.33126944253156676, 0.3168027670970488, 0.36890694251841194, 0.2710681818949614, 0.3304548812663224, 0.2636668768734898, 0.399363666198819, 0.4391896350173363, 0.4251106318701794, 0.3957391328356439, 0.4173071637112098, 0.49114169125133744, 0.4571763095341902, 0.44105907891793006, 0.47543054954069286, 0.06983850752350995, 0.20587215387818425, 0.20247406425544145, 0.16216146868714298, 0.16946602502848995, 0.1167350874180072, 0.18066366226210884, 0.10466453986036195, 0.08431960773622249, 0.29775472663503366, 0.2701635789954244, 0.2961391035212847, 0.26748150670562176, 0.3418746895885989, 0.26193853866475514, 0.2980231606880872, 0.2481920681467945, 0.29270775966039486, 0.6392765826679037, 0.6490275061328654, 0.6434311797354066, 0.6101548565800816, 0.6705163158216997, 0.581715485322932, 0.6302372799063853, 0.6572822223214339, 0.63667360276885, 0.10946979306955906, 0.10495685013288236, 0.09854458937774613, 0.09716371232282162, 0.11476060783481101, 0.10180537332611694, 0.08978362639479653, 0.09895539925489538, 0.10411653850132274, 0.2633268434969652, 0.1788873209645211, 0.2264473851374672, 0.2507217028230929, 0.17913228377985901, 0.22891227141535053, 0.19110001644461017, 0.2139585020176098, 0.18290495053256972, 0.4135147594879234, 0.42148645148468744, 0.4163750662420447, 0.3786119686270838, 0.4413315433472095, 0.3775701429488637, 0.43907987101758084, 0.4406275496723362, 0.3647495752161902, 0.35104771272631796, 0.32129370837133686, 0.3145722381892989, 0.2977847102879454, 0.2975529999725195, 0.28898620252116314, 0.3137956181835322, 0.3267581533766173, 0.3330980920336182, 0.1898882779819978, 0.1905400773304492, 0.18545963849958857, 0.18856014300619717, 0.21931369012724744, 0.1990457180226365, 0.20889701508602687, 0.17918548645071464, 0.18996285541952096, 0.23642946213293792, 0.3927603564406512, 0.24749623807951637, 0.19193963824809768, 0.18219160787894084, 0.21713294923741522, 0.221165022732153, 0.2170824145776833, 0.21595790950359184, 0.6431133147940391, 0.7910116517369107, 0.1526494517286039, 0.18367854971517794, 0.20943985436351187, 0.1959939509921974, 0.18284803815092687, 0.6095864501996766, 0.734668736213713, 0.6901716059296701, 0.20955375555447575, 0.6708621482076059, 0.6562094333851947, 0.7065753248293243, 0.2060075346519048, 0.749621608307204, 0.7240217086130991, 0.20907996605188905, 0.18263625118278404, 0.19256000426655284, 0.17657819589137957, 0.17729311771949818, 0.1922495866517835, 0.1990523094758524, 0.18017600315779692, 0.16894604412663083, 0.18586734217102652, 0.08068749109015605, 0.08347801844548375, 0.0782340926600047, 0.08345049371297841, 0.07374025617519131, 0.08647786369411792, 0.08067671222228345, 0.08609957232088361, 0.09423657106271999]}, "mutation_prompt": null}
{"id": "14651833-3775-4889-a373-46486d0b368a", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F_min = 0.5\n        self.F_max = 0.9\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: self.F_min + (self.F_max - self.F_min) * np.sin(np.pi * evals / (2 * self.budget))\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring dynamic mutation factors for enhanced convergence speed.", "configspace": "", "generation": 74, "fitness": 0.3926739166834523, "feedback": "The algorithm DEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.25.", "error": "", "parent_id": "8678eecb-2fc1-4c26-9fab-ffcefc4aa9aa", "metadata": {"aucs": [0.7968801489948274, 0.7857497924017587, 0.7930328545470777, 0.7914670047123273, 0.8023822238935016, 0.8109194771862845, 0.800164806998958, 0.817803200297867, 0.7870132232830508, 0.6216307169653656, 0.6310550899106175, 0.6185505089884191, 0.6313678290375803, 0.6213181784600736, 0.6096564997091771, 0.6297841861499857, 0.6207330176311852, 0.5931058184961518, 0.13737654245243613, 0.12566714026964232, 0.1323614882800892, 0.15243616969966656, 0.13647791516802266, 0.12230712883238015, 0.11664204857317162, 0.10768905512354976, 0.11664567084069022, 0.10784737916717935, 0.10739655010257287, 0.11874664006138591, 0.11910921784580186, 0.09143043726144406, 0.11274734910169304, 0.15174149395845238, 0.10834452291541097, 0.11973330592501663, 0.9096515280251296, 0.9183820322978025, 0.9495766660581665, 0.913165975605537, 0.9071735649436963, 0.9742419185151416, 0.9554495952410039, 0.9577221069478945, 0.9339532000363818, 0.4948587276718043, 0.4912386491947567, 0.49171309659023077, 0.46530489784880624, 0.4934932895349048, 0.4949316352588573, 0.4829406382289163, 0.5182233521159227, 0.47568118628136224, 0.7117668763266587, 0.7340625175351826, 0.7433994019965051, 0.8023638858124337, 0.7190853253609248, 0.7623176440052908, 0.7939579330401683, 0.7906651634599782, 0.7236487124153514, 0.3730231263477255, 0.49082441917973707, 0.4623422724469112, 0.35929913761048304, 0.40103892398486873, 0.4092785895373692, 0.39520382427794143, 0.430617315906472, 0.41580561422114226, 0.36753347796792646, 0.3750264212737079, 0.3992107458674461, 0.466457131992021, 0.33824053597553283, 0.3484331405261333, 0.4622107427895388, 0.3758862649125817, 0.2801304539465099, 0.3332805760225239, 0.4192409133125341, 0.3343879556072872, 0.32925116693639744, 0.41137277102632663, 0.3102673764572109, 0.3940592140626512, 0.37311340492507294, 0.3707269942090258, 0.48097457640495245, 0.5390931009803086, 0.48682253515143825, 0.5362483944519797, 0.4819595570358778, 0.4627653023451026, 0.5836428255038342, 0.534601601122068, 0.5352783035821425, 0.08866524732393466, 0.17506990020357238, 0.18534281864119795, 0.2304426565033093, 0.19827125080973584, 0.11051004148679766, 0.1550693837149658, 0.11420866074474978, 0.1306895525641979, 0.28959801324507706, 0.29908892847302593, 0.2918800890901775, 0.3024327008260529, 0.3117848649635395, 0.3253268980581727, 0.3130051555574781, 0.3076676499890503, 0.31571497213032107, 0.6697855778139568, 0.6936969533890074, 0.6854895481878877, 0.7119366061329894, 0.697375012028574, 0.6748624123489337, 0.6845304842801586, 0.6790533693952605, 0.6734280992634145, 0.09940890594684282, 0.09343834904036197, 0.09330127195203008, 0.08333612694261372, 0.08919765893650311, 0.0876218867601819, 0.10439273861051934, 0.1001489326751851, 0.13660297936284738, 0.21811148677381742, 0.17476641618692246, 0.18943278927380602, 0.24040655086747298, 0.20150416695879714, 0.17681436174290788, 0.21067518506773963, 0.1381594299726132, 0.18303364543391676, 0.3679811763375812, 0.41510750779204586, 0.36695104387760213, 0.38799332908600104, 0.35407170205609473, 0.3947860441300203, 0.3895040994176343, 0.41279359636579604, 0.4078647130978882, 0.30559786019727375, 0.28829009583079757, 0.29131941133234074, 0.28117078634894854, 0.2937930756440188, 0.24762979074399116, 0.2920349921190002, 0.3073228753477335, 0.2724593879656705, 0.19709407127287693, 0.18783462505853676, 0.19942130678289982, 0.20304980720028265, 0.2009527529496855, 0.19493476431707102, 0.2078583972640059, 0.24994656170849805, 0.21465590785967925, 0.2271264099898871, 0.22439399023436513, 0.21443620353130355, 0.22119584596264152, 0.25084873443448663, 0.25491823871306274, 0.2139619204484835, 0.24634015177959379, 0.40924332108316874, 0.7574758399316956, 0.7727242628973505, 0.6601891228251205, 0.7936803247603185, 0.6771778238998505, 0.7454137703686081, 0.7474043847396739, 0.5972912148934852, 0.17982048541720363, 0.7037337623192819, 0.21118439612864892, 0.20323176479608118, 0.6297568416840995, 0.20485685093579142, 0.659103604663279, 0.2064461438875661, 0.7171654688005993, 0.20733309182972692, 0.17814054595856577, 0.19554209835120773, 0.20708982435329437, 0.18363440895001537, 0.18487380513927287, 0.18668609301784644, 0.18454501277684754, 0.1817696453445199, 0.1801338024177438, 0.07155617289002947, 0.07902451483597162, 0.07801777867482995, 0.07325130869619512, 0.07523069297581186, 0.0772123787015454, 0.07857773423967429, 0.08477147486122172, 0.08942246721873193]}, "mutation_prompt": null}
{"id": "1c340a5e-c4ee-4400-90bc-5f771ee571fc", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F_min = 0.5\n        self.F_max = 0.9\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: self.F_min + (self.F_max - self.F_min) * np.sin(np.pi * evals / (2 * self.budget))\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring dynamic mutation factors for enhanced convergence speed.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "14651833-3775-4889-a373-46486d0b368a", "metadata": {"aucs": [0.7968801489948274, 0.7857497924017587, 0.7930328545470777, 0.7914670047123273, 0.8023822238935016, 0.8109194771862845, 0.800164806998958, 0.817803200297867, 0.7870132232830508, 0.6216307169653656, 0.6310550899106175, 0.6185505089884191, 0.6313678290375803, 0.6213181784600736, 0.6096564997091771, 0.6297841861499857, 0.6207330176311852, 0.5931058184961518, 0.13737654245243613, 0.12566714026964232, 0.1323614882800892, 0.15243616969966656, 0.13647791516802266, 0.12230712883238015, 0.11664204857317162, 0.10768905512354976, 0.11664567084069022, 0.10784737916717935, 0.10739655010257287, 0.11874664006138591, 0.11910921784580186, 0.09143043726144406, 0.11274734910169304, 0.15174149395845238, 0.10834452291541097, 0.11973330592501663, 0.9096515280251296, 0.9183820322978025, 0.9495766660581665, 0.913165975605537, 0.9071735649436963, 0.9742419185151416, 0.9554495952410039, 0.9577221069478945, 0.9339532000363818, 0.4948587276718043, 0.4912386491947567, 0.49171309659023077, 0.46530489784880624, 0.4934932895349048, 0.4949316352588573, 0.4829406382289163, 0.5182233521159227, 0.47568118628136224, 0.7117668763266587, 0.7340625175351826, 0.7433994019965051, 0.8023638858124337, 0.7190853253609248, 0.7623176440052908, 0.7939579330401683, 0.7906651634599782, 0.7236487124153514, 0.3730231263477255, 0.49082441917973707, 0.4623422724469112, 0.35929913761048304, 0.40103892398486873, 0.4092785895373692, 0.39520382427794143, 0.430617315906472, 0.41580561422114226, 0.36753347796792646, 0.3750264212737079, 0.3992107458674461, 0.466457131992021, 0.33824053597553283, 0.3484331405261333, 0.4622107427895388, 0.3758862649125817, 0.2801304539465099, 0.3332805760225239, 0.4192409133125341, 0.3343879556072872, 0.32925116693639744, 0.41137277102632663, 0.3102673764572109, 0.3940592140626512, 0.37311340492507294, 0.3707269942090258, 0.48097457640495245, 0.5390931009803086, 0.48682253515143825, 0.5362483944519797, 0.4819595570358778, 0.4627653023451026, 0.5836428255038342, 0.534601601122068, 0.5352783035821425, 0.08866524732393466, 0.17506990020357238, 0.18534281864119795, 0.2304426565033093, 0.19827125080973584, 0.11051004148679766, 0.1550693837149658, 0.11420866074474978, 0.1306895525641979, 0.28959801324507706, 0.29908892847302593, 0.2918800890901775, 0.3024327008260529, 0.3117848649635395, 0.3253268980581727, 0.3130051555574781, 0.3076676499890503, 0.31571497213032107, 0.6697855778139568, 0.6936969533890074, 0.6854895481878877, 0.7119366061329894, 0.697375012028574, 0.6748624123489337, 0.6845304842801586, 0.6790533693952605, 0.6734280992634145, 0.09940890594684282, 0.09343834904036197, 0.09330127195203008, 0.08333612694261372, 0.08919765893650311, 0.0876218867601819, 0.10439273861051934, 0.1001489326751851, 0.13660297936284738, 0.21811148677381742, 0.17476641618692246, 0.18943278927380602, 0.24040655086747298, 0.20150416695879714, 0.17681436174290788, 0.21067518506773963, 0.1381594299726132, 0.18303364543391676, 0.3679811763375812, 0.41510750779204586, 0.36695104387760213, 0.38799332908600104, 0.35407170205609473, 0.3947860441300203, 0.3895040994176343, 0.41279359636579604, 0.4078647130978882, 0.30559786019727375, 0.28829009583079757, 0.29131941133234074, 0.28117078634894854, 0.2937930756440188, 0.24762979074399116, 0.2920349921190002, 0.3073228753477335, 0.2724593879656705, 0.19709407127287693, 0.18783462505853676, 0.19942130678289982, 0.20304980720028265, 0.2009527529496855, 0.19493476431707102, 0.2078583972640059, 0.24994656170849805, 0.21465590785967925, 0.2271264099898871, 0.22439399023436513, 0.21443620353130355, 0.22119584596264152, 0.25084873443448663, 0.25491823871306274, 0.2139619204484835, 0.24634015177959379, 0.40924332108316874, 0.7574758399316956, 0.7727242628973505, 0.6601891228251205, 0.7936803247603185, 0.6771778238998505, 0.7454137703686081, 0.7474043847396739, 0.5972912148934852, 0.17982048541720363, 0.7037337623192819, 0.21118439612864892, 0.20323176479608118, 0.6297568416840995, 0.20485685093579142, 0.659103604663279, 0.2064461438875661, 0.7171654688005993, 0.20733309182972692, 0.17814054595856577, 0.19554209835120773, 0.20708982435329437, 0.18363440895001537, 0.18487380513927287, 0.18668609301784644, 0.18454501277684754, 0.1817696453445199, 0.1801338024177438, 0.07155617289002947, 0.07902451483597162, 0.07801777867482995, 0.07325130869619512, 0.07523069297581186, 0.0772123787015454, 0.07857773423967429, 0.08477147486122172, 0.08942246721873193]}, "mutation_prompt": null}
{"id": "050537a2-f7cb-40ce-bac6-b96a7e0e9580", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F_min = 0.5\n        self.F_max = 0.9\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: self.F_min + (self.F_max - self.F_min) * np.sin(np.pi * evals / (2 * self.budget))\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring dynamic mutation factors for enhanced convergence speed.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "14651833-3775-4889-a373-46486d0b368a", "metadata": {"aucs": [0.7968801489948274, 0.7857497924017587, 0.7930328545470777, 0.7914670047123273, 0.8023822238935016, 0.8109194771862845, 0.800164806998958, 0.817803200297867, 0.7870132232830508, 0.6216307169653656, 0.6310550899106175, 0.6185505089884191, 0.6313678290375803, 0.6213181784600736, 0.6096564997091771, 0.6297841861499857, 0.6207330176311852, 0.5931058184961518, 0.13737654245243613, 0.12566714026964232, 0.1323614882800892, 0.15243616969966656, 0.13647791516802266, 0.12230712883238015, 0.11664204857317162, 0.10768905512354976, 0.11664567084069022, 0.10784737916717935, 0.10739655010257287, 0.11874664006138591, 0.11910921784580186, 0.09143043726144406, 0.11274734910169304, 0.15174149395845238, 0.10834452291541097, 0.11973330592501663, 0.9096515280251296, 0.9183820322978025, 0.9495766660581665, 0.913165975605537, 0.9071735649436963, 0.9742419185151416, 0.9554495952410039, 0.9577221069478945, 0.9339532000363818, 0.4948587276718043, 0.4912386491947567, 0.49171309659023077, 0.46530489784880624, 0.4934932895349048, 0.4949316352588573, 0.4829406382289163, 0.5182233521159227, 0.47568118628136224, 0.7117668763266587, 0.7340625175351826, 0.7433994019965051, 0.8023638858124337, 0.7190853253609248, 0.7623176440052908, 0.7939579330401683, 0.7906651634599782, 0.7236487124153514, 0.3730231263477255, 0.49082441917973707, 0.4623422724469112, 0.35929913761048304, 0.40103892398486873, 0.4092785895373692, 0.39520382427794143, 0.430617315906472, 0.41580561422114226, 0.36753347796792646, 0.3750264212737079, 0.3992107458674461, 0.466457131992021, 0.33824053597553283, 0.3484331405261333, 0.4622107427895388, 0.3758862649125817, 0.2801304539465099, 0.3332805760225239, 0.4192409133125341, 0.3343879556072872, 0.32925116693639744, 0.41137277102632663, 0.3102673764572109, 0.3940592140626512, 0.37311340492507294, 0.3707269942090258, 0.48097457640495245, 0.5390931009803086, 0.48682253515143825, 0.5362483944519797, 0.4819595570358778, 0.4627653023451026, 0.5836428255038342, 0.534601601122068, 0.5352783035821425, 0.08866524732393466, 0.17506990020357238, 0.18534281864119795, 0.2304426565033093, 0.19827125080973584, 0.11051004148679766, 0.1550693837149658, 0.11420866074474978, 0.1306895525641979, 0.28959801324507706, 0.29908892847302593, 0.2918800890901775, 0.3024327008260529, 0.3117848649635395, 0.3253268980581727, 0.3130051555574781, 0.3076676499890503, 0.31571497213032107, 0.6697855778139568, 0.6936969533890074, 0.6854895481878877, 0.7119366061329894, 0.697375012028574, 0.6748624123489337, 0.6845304842801586, 0.6790533693952605, 0.6734280992634145, 0.09940890594684282, 0.09343834904036197, 0.09330127195203008, 0.08333612694261372, 0.08919765893650311, 0.0876218867601819, 0.10439273861051934, 0.1001489326751851, 0.13660297936284738, 0.21811148677381742, 0.17476641618692246, 0.18943278927380602, 0.24040655086747298, 0.20150416695879714, 0.17681436174290788, 0.21067518506773963, 0.1381594299726132, 0.18303364543391676, 0.3679811763375812, 0.41510750779204586, 0.36695104387760213, 0.38799332908600104, 0.35407170205609473, 0.3947860441300203, 0.3895040994176343, 0.41279359636579604, 0.4078647130978882, 0.30559786019727375, 0.28829009583079757, 0.29131941133234074, 0.28117078634894854, 0.2937930756440188, 0.24762979074399116, 0.2920349921190002, 0.3073228753477335, 0.2724593879656705, 0.19709407127287693, 0.18783462505853676, 0.19942130678289982, 0.20304980720028265, 0.2009527529496855, 0.19493476431707102, 0.2078583972640059, 0.24994656170849805, 0.21465590785967925, 0.2271264099898871, 0.22439399023436513, 0.21443620353130355, 0.22119584596264152, 0.25084873443448663, 0.25491823871306274, 0.2139619204484835, 0.24634015177959379, 0.40924332108316874, 0.7574758399316956, 0.7727242628973505, 0.6601891228251205, 0.7936803247603185, 0.6771778238998505, 0.7454137703686081, 0.7474043847396739, 0.5972912148934852, 0.17982048541720363, 0.7037337623192819, 0.21118439612864892, 0.20323176479608118, 0.6297568416840995, 0.20485685093579142, 0.659103604663279, 0.2064461438875661, 0.7171654688005993, 0.20733309182972692, 0.17814054595856577, 0.19554209835120773, 0.20708982435329437, 0.18363440895001537, 0.18487380513927287, 0.18668609301784644, 0.18454501277684754, 0.1817696453445199, 0.1801338024177438, 0.07155617289002947, 0.07902451483597162, 0.07801777867482995, 0.07325130869619512, 0.07523069297581186, 0.0772123787015454, 0.07857773423967429, 0.08477147486122172, 0.08942246721873193]}, "mutation_prompt": null}
{"id": "01d353dc-8a9f-4d24-942b-c5401466e8cd", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F_min = 0.5\n        self.F_max = 0.9\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: self.F_min + (self.F_max - self.F_min) * np.sin(np.pi * evals / (2 * self.budget))\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring dynamic mutation factors for enhanced convergence speed.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "14651833-3775-4889-a373-46486d0b368a", "metadata": {"aucs": [0.7968801489948274, 0.7857497924017587, 0.7930328545470777, 0.7914670047123273, 0.8023822238935016, 0.8109194771862845, 0.800164806998958, 0.817803200297867, 0.7870132232830508, 0.6216307169653656, 0.6310550899106175, 0.6185505089884191, 0.6313678290375803, 0.6213181784600736, 0.6096564997091771, 0.6297841861499857, 0.6207330176311852, 0.5931058184961518, 0.13737654245243613, 0.12566714026964232, 0.1323614882800892, 0.15243616969966656, 0.13647791516802266, 0.12230712883238015, 0.11664204857317162, 0.10768905512354976, 0.11664567084069022, 0.10784737916717935, 0.10739655010257287, 0.11874664006138591, 0.11910921784580186, 0.09143043726144406, 0.11274734910169304, 0.15174149395845238, 0.10834452291541097, 0.11973330592501663, 0.9096515280251296, 0.9183820322978025, 0.9495766660581665, 0.913165975605537, 0.9071735649436963, 0.9742419185151416, 0.9554495952410039, 0.9577221069478945, 0.9339532000363818, 0.4948587276718043, 0.4912386491947567, 0.49171309659023077, 0.46530489784880624, 0.4934932895349048, 0.4949316352588573, 0.4829406382289163, 0.5182233521159227, 0.47568118628136224, 0.7117668763266587, 0.7340625175351826, 0.7433994019965051, 0.8023638858124337, 0.7190853253609248, 0.7623176440052908, 0.7939579330401683, 0.7906651634599782, 0.7236487124153514, 0.3730231263477255, 0.49082441917973707, 0.4623422724469112, 0.35929913761048304, 0.40103892398486873, 0.4092785895373692, 0.39520382427794143, 0.430617315906472, 0.41580561422114226, 0.36753347796792646, 0.3750264212737079, 0.3992107458674461, 0.466457131992021, 0.33824053597553283, 0.3484331405261333, 0.4622107427895388, 0.3758862649125817, 0.2801304539465099, 0.3332805760225239, 0.4192409133125341, 0.3343879556072872, 0.32925116693639744, 0.41137277102632663, 0.3102673764572109, 0.3940592140626512, 0.37311340492507294, 0.3707269942090258, 0.48097457640495245, 0.5390931009803086, 0.48682253515143825, 0.5362483944519797, 0.4819595570358778, 0.4627653023451026, 0.5836428255038342, 0.534601601122068, 0.5352783035821425, 0.08866524732393466, 0.17506990020357238, 0.18534281864119795, 0.2304426565033093, 0.19827125080973584, 0.11051004148679766, 0.1550693837149658, 0.11420866074474978, 0.1306895525641979, 0.28959801324507706, 0.29908892847302593, 0.2918800890901775, 0.3024327008260529, 0.3117848649635395, 0.3253268980581727, 0.3130051555574781, 0.3076676499890503, 0.31571497213032107, 0.6697855778139568, 0.6936969533890074, 0.6854895481878877, 0.7119366061329894, 0.697375012028574, 0.6748624123489337, 0.6845304842801586, 0.6790533693952605, 0.6734280992634145, 0.09940890594684282, 0.09343834904036197, 0.09330127195203008, 0.08333612694261372, 0.08919765893650311, 0.0876218867601819, 0.10439273861051934, 0.1001489326751851, 0.13660297936284738, 0.21811148677381742, 0.17476641618692246, 0.18943278927380602, 0.24040655086747298, 0.20150416695879714, 0.17681436174290788, 0.21067518506773963, 0.1381594299726132, 0.18303364543391676, 0.3679811763375812, 0.41510750779204586, 0.36695104387760213, 0.38799332908600104, 0.35407170205609473, 0.3947860441300203, 0.3895040994176343, 0.41279359636579604, 0.4078647130978882, 0.30559786019727375, 0.28829009583079757, 0.29131941133234074, 0.28117078634894854, 0.2937930756440188, 0.24762979074399116, 0.2920349921190002, 0.3073228753477335, 0.2724593879656705, 0.19709407127287693, 0.18783462505853676, 0.19942130678289982, 0.20304980720028265, 0.2009527529496855, 0.19493476431707102, 0.2078583972640059, 0.24994656170849805, 0.21465590785967925, 0.2271264099898871, 0.22439399023436513, 0.21443620353130355, 0.22119584596264152, 0.25084873443448663, 0.25491823871306274, 0.2139619204484835, 0.24634015177959379, 0.40924332108316874, 0.7574758399316956, 0.7727242628973505, 0.6601891228251205, 0.7936803247603185, 0.6771778238998505, 0.7454137703686081, 0.7474043847396739, 0.5972912148934852, 0.17982048541720363, 0.7037337623192819, 0.21118439612864892, 0.20323176479608118, 0.6297568416840995, 0.20485685093579142, 0.659103604663279, 0.2064461438875661, 0.7171654688005993, 0.20733309182972692, 0.17814054595856577, 0.19554209835120773, 0.20708982435329437, 0.18363440895001537, 0.18487380513927287, 0.18668609301784644, 0.18454501277684754, 0.1817696453445199, 0.1801338024177438, 0.07155617289002947, 0.07902451483597162, 0.07801777867482995, 0.07325130869619512, 0.07523069297581186, 0.0772123787015454, 0.07857773423967429, 0.08477147486122172, 0.08942246721873193]}, "mutation_prompt": null}
{"id": "fe363a97-64da-41ac-aed5-bb9eb60df77c", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F_min = 0.5\n        self.F_max = 0.9\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: self.F_min + (self.F_max - self.F_min) * np.sin(np.pi * evals / (2 * self.budget))\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring dynamic mutation factors for enhanced convergence speed.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "14651833-3775-4889-a373-46486d0b368a", "metadata": {"aucs": [0.7968801489948274, 0.7857497924017587, 0.7930328545470777, 0.7914670047123273, 0.8023822238935016, 0.8109194771862845, 0.800164806998958, 0.817803200297867, 0.7870132232830508, 0.6216307169653656, 0.6310550899106175, 0.6185505089884191, 0.6313678290375803, 0.6213181784600736, 0.6096564997091771, 0.6297841861499857, 0.6207330176311852, 0.5931058184961518, 0.13737654245243613, 0.12566714026964232, 0.1323614882800892, 0.15243616969966656, 0.13647791516802266, 0.12230712883238015, 0.11664204857317162, 0.10768905512354976, 0.11664567084069022, 0.10784737916717935, 0.10739655010257287, 0.11874664006138591, 0.11910921784580186, 0.09143043726144406, 0.11274734910169304, 0.15174149395845238, 0.10834452291541097, 0.11973330592501663, 0.9096515280251296, 0.9183820322978025, 0.9495766660581665, 0.913165975605537, 0.9071735649436963, 0.9742419185151416, 0.9554495952410039, 0.9577221069478945, 0.9339532000363818, 0.4948587276718043, 0.4912386491947567, 0.49171309659023077, 0.46530489784880624, 0.4934932895349048, 0.4949316352588573, 0.4829406382289163, 0.5182233521159227, 0.47568118628136224, 0.7117668763266587, 0.7340625175351826, 0.7433994019965051, 0.8023638858124337, 0.7190853253609248, 0.7623176440052908, 0.7939579330401683, 0.7906651634599782, 0.7236487124153514, 0.3730231263477255, 0.49082441917973707, 0.4623422724469112, 0.35929913761048304, 0.40103892398486873, 0.4092785895373692, 0.39520382427794143, 0.430617315906472, 0.41580561422114226, 0.36753347796792646, 0.3750264212737079, 0.3992107458674461, 0.466457131992021, 0.33824053597553283, 0.3484331405261333, 0.4622107427895388, 0.3758862649125817, 0.2801304539465099, 0.3332805760225239, 0.4192409133125341, 0.3343879556072872, 0.32925116693639744, 0.41137277102632663, 0.3102673764572109, 0.3940592140626512, 0.37311340492507294, 0.3707269942090258, 0.48097457640495245, 0.5390931009803086, 0.48682253515143825, 0.5362483944519797, 0.4819595570358778, 0.4627653023451026, 0.5836428255038342, 0.534601601122068, 0.5352783035821425, 0.08866524732393466, 0.17506990020357238, 0.18534281864119795, 0.2304426565033093, 0.19827125080973584, 0.11051004148679766, 0.1550693837149658, 0.11420866074474978, 0.1306895525641979, 0.28959801324507706, 0.29908892847302593, 0.2918800890901775, 0.3024327008260529, 0.3117848649635395, 0.3253268980581727, 0.3130051555574781, 0.3076676499890503, 0.31571497213032107, 0.6697855778139568, 0.6936969533890074, 0.6854895481878877, 0.7119366061329894, 0.697375012028574, 0.6748624123489337, 0.6845304842801586, 0.6790533693952605, 0.6734280992634145, 0.09940890594684282, 0.09343834904036197, 0.09330127195203008, 0.08333612694261372, 0.08919765893650311, 0.0876218867601819, 0.10439273861051934, 0.1001489326751851, 0.13660297936284738, 0.21811148677381742, 0.17476641618692246, 0.18943278927380602, 0.24040655086747298, 0.20150416695879714, 0.17681436174290788, 0.21067518506773963, 0.1381594299726132, 0.18303364543391676, 0.3679811763375812, 0.41510750779204586, 0.36695104387760213, 0.38799332908600104, 0.35407170205609473, 0.3947860441300203, 0.3895040994176343, 0.41279359636579604, 0.4078647130978882, 0.30559786019727375, 0.28829009583079757, 0.29131941133234074, 0.28117078634894854, 0.2937930756440188, 0.24762979074399116, 0.2920349921190002, 0.3073228753477335, 0.2724593879656705, 0.19709407127287693, 0.18783462505853676, 0.19942130678289982, 0.20304980720028265, 0.2009527529496855, 0.19493476431707102, 0.2078583972640059, 0.24994656170849805, 0.21465590785967925, 0.2271264099898871, 0.22439399023436513, 0.21443620353130355, 0.22119584596264152, 0.25084873443448663, 0.25491823871306274, 0.2139619204484835, 0.24634015177959379, 0.40924332108316874, 0.7574758399316956, 0.7727242628973505, 0.6601891228251205, 0.7936803247603185, 0.6771778238998505, 0.7454137703686081, 0.7474043847396739, 0.5972912148934852, 0.17982048541720363, 0.7037337623192819, 0.21118439612864892, 0.20323176479608118, 0.6297568416840995, 0.20485685093579142, 0.659103604663279, 0.2064461438875661, 0.7171654688005993, 0.20733309182972692, 0.17814054595856577, 0.19554209835120773, 0.20708982435329437, 0.18363440895001537, 0.18487380513927287, 0.18668609301784644, 0.18454501277684754, 0.1817696453445199, 0.1801338024177438, 0.07155617289002947, 0.07902451483597162, 0.07801777867482995, 0.07325130869619512, 0.07523069297581186, 0.0772123787015454, 0.07857773423967429, 0.08477147486122172, 0.08942246721873193]}, "mutation_prompt": null}
{"id": "fb8c1281-0c8b-4575-8305-113302d16c14", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F_min = 0.5\n        self.F_max = 0.9\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: self.F_min + (self.F_max - self.F_min) * np.sin(np.pi * evals / (2 * self.budget))\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring dynamic mutation factors for enhanced convergence speed.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "14651833-3775-4889-a373-46486d0b368a", "metadata": {"aucs": [0.7968801489948274, 0.7857497924017587, 0.7930328545470777, 0.7914670047123273, 0.8023822238935016, 0.8109194771862845, 0.800164806998958, 0.817803200297867, 0.7870132232830508, 0.6216307169653656, 0.6310550899106175, 0.6185505089884191, 0.6313678290375803, 0.6213181784600736, 0.6096564997091771, 0.6297841861499857, 0.6207330176311852, 0.5931058184961518, 0.13737654245243613, 0.12566714026964232, 0.1323614882800892, 0.15243616969966656, 0.13647791516802266, 0.12230712883238015, 0.11664204857317162, 0.10768905512354976, 0.11664567084069022, 0.10784737916717935, 0.10739655010257287, 0.11874664006138591, 0.11910921784580186, 0.09143043726144406, 0.11274734910169304, 0.15174149395845238, 0.10834452291541097, 0.11973330592501663, 0.9096515280251296, 0.9183820322978025, 0.9495766660581665, 0.913165975605537, 0.9071735649436963, 0.9742419185151416, 0.9554495952410039, 0.9577221069478945, 0.9339532000363818, 0.4948587276718043, 0.4912386491947567, 0.49171309659023077, 0.46530489784880624, 0.4934932895349048, 0.4949316352588573, 0.4829406382289163, 0.5182233521159227, 0.47568118628136224, 0.7117668763266587, 0.7340625175351826, 0.7433994019965051, 0.8023638858124337, 0.7190853253609248, 0.7623176440052908, 0.7939579330401683, 0.7906651634599782, 0.7236487124153514, 0.3730231263477255, 0.49082441917973707, 0.4623422724469112, 0.35929913761048304, 0.40103892398486873, 0.4092785895373692, 0.39520382427794143, 0.430617315906472, 0.41580561422114226, 0.36753347796792646, 0.3750264212737079, 0.3992107458674461, 0.466457131992021, 0.33824053597553283, 0.3484331405261333, 0.4622107427895388, 0.3758862649125817, 0.2801304539465099, 0.3332805760225239, 0.4192409133125341, 0.3343879556072872, 0.32925116693639744, 0.41137277102632663, 0.3102673764572109, 0.3940592140626512, 0.37311340492507294, 0.3707269942090258, 0.48097457640495245, 0.5390931009803086, 0.48682253515143825, 0.5362483944519797, 0.4819595570358778, 0.4627653023451026, 0.5836428255038342, 0.534601601122068, 0.5352783035821425, 0.08866524732393466, 0.17506990020357238, 0.18534281864119795, 0.2304426565033093, 0.19827125080973584, 0.11051004148679766, 0.1550693837149658, 0.11420866074474978, 0.1306895525641979, 0.28959801324507706, 0.29908892847302593, 0.2918800890901775, 0.3024327008260529, 0.3117848649635395, 0.3253268980581727, 0.3130051555574781, 0.3076676499890503, 0.31571497213032107, 0.6697855778139568, 0.6936969533890074, 0.6854895481878877, 0.7119366061329894, 0.697375012028574, 0.6748624123489337, 0.6845304842801586, 0.6790533693952605, 0.6734280992634145, 0.09940890594684282, 0.09343834904036197, 0.09330127195203008, 0.08333612694261372, 0.08919765893650311, 0.0876218867601819, 0.10439273861051934, 0.1001489326751851, 0.13660297936284738, 0.21811148677381742, 0.17476641618692246, 0.18943278927380602, 0.24040655086747298, 0.20150416695879714, 0.17681436174290788, 0.21067518506773963, 0.1381594299726132, 0.18303364543391676, 0.3679811763375812, 0.41510750779204586, 0.36695104387760213, 0.38799332908600104, 0.35407170205609473, 0.3947860441300203, 0.3895040994176343, 0.41279359636579604, 0.4078647130978882, 0.30559786019727375, 0.28829009583079757, 0.29131941133234074, 0.28117078634894854, 0.2937930756440188, 0.24762979074399116, 0.2920349921190002, 0.3073228753477335, 0.2724593879656705, 0.19709407127287693, 0.18783462505853676, 0.19942130678289982, 0.20304980720028265, 0.2009527529496855, 0.19493476431707102, 0.2078583972640059, 0.24994656170849805, 0.21465590785967925, 0.2271264099898871, 0.22439399023436513, 0.21443620353130355, 0.22119584596264152, 0.25084873443448663, 0.25491823871306274, 0.2139619204484835, 0.24634015177959379, 0.40924332108316874, 0.7574758399316956, 0.7727242628973505, 0.6601891228251205, 0.7936803247603185, 0.6771778238998505, 0.7454137703686081, 0.7474043847396739, 0.5972912148934852, 0.17982048541720363, 0.7037337623192819, 0.21118439612864892, 0.20323176479608118, 0.6297568416840995, 0.20485685093579142, 0.659103604663279, 0.2064461438875661, 0.7171654688005993, 0.20733309182972692, 0.17814054595856577, 0.19554209835120773, 0.20708982435329437, 0.18363440895001537, 0.18487380513927287, 0.18668609301784644, 0.18454501277684754, 0.1817696453445199, 0.1801338024177438, 0.07155617289002947, 0.07902451483597162, 0.07801777867482995, 0.07325130869619512, 0.07523069297581186, 0.0772123787015454, 0.07857773423967429, 0.08477147486122172, 0.08942246721873193]}, "mutation_prompt": null}
{"id": "8f685276-4c67-441f-b853-455c472a2c1d", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F_min = 0.5\n        self.F_max = 0.9\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: self.F_min + (self.F_max - self.F_min) * np.sin(np.pi * evals / (2 * self.budget))\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring dynamic mutation factors for enhanced convergence speed.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "14651833-3775-4889-a373-46486d0b368a", "metadata": {"aucs": [0.7968801489948274, 0.7857497924017587, 0.7930328545470777, 0.7914670047123273, 0.8023822238935016, 0.8109194771862845, 0.800164806998958, 0.817803200297867, 0.7870132232830508, 0.6216307169653656, 0.6310550899106175, 0.6185505089884191, 0.6313678290375803, 0.6213181784600736, 0.6096564997091771, 0.6297841861499857, 0.6207330176311852, 0.5931058184961518, 0.13737654245243613, 0.12566714026964232, 0.1323614882800892, 0.15243616969966656, 0.13647791516802266, 0.12230712883238015, 0.11664204857317162, 0.10768905512354976, 0.11664567084069022, 0.10784737916717935, 0.10739655010257287, 0.11874664006138591, 0.11910921784580186, 0.09143043726144406, 0.11274734910169304, 0.15174149395845238, 0.10834452291541097, 0.11973330592501663, 0.9096515280251296, 0.9183820322978025, 0.9495766660581665, 0.913165975605537, 0.9071735649436963, 0.9742419185151416, 0.9554495952410039, 0.9577221069478945, 0.9339532000363818, 0.4948587276718043, 0.4912386491947567, 0.49171309659023077, 0.46530489784880624, 0.4934932895349048, 0.4949316352588573, 0.4829406382289163, 0.5182233521159227, 0.47568118628136224, 0.7117668763266587, 0.7340625175351826, 0.7433994019965051, 0.8023638858124337, 0.7190853253609248, 0.7623176440052908, 0.7939579330401683, 0.7906651634599782, 0.7236487124153514, 0.3730231263477255, 0.49082441917973707, 0.4623422724469112, 0.35929913761048304, 0.40103892398486873, 0.4092785895373692, 0.39520382427794143, 0.430617315906472, 0.41580561422114226, 0.36753347796792646, 0.3750264212737079, 0.3992107458674461, 0.466457131992021, 0.33824053597553283, 0.3484331405261333, 0.4622107427895388, 0.3758862649125817, 0.2801304539465099, 0.3332805760225239, 0.4192409133125341, 0.3343879556072872, 0.32925116693639744, 0.41137277102632663, 0.3102673764572109, 0.3940592140626512, 0.37311340492507294, 0.3707269942090258, 0.48097457640495245, 0.5390931009803086, 0.48682253515143825, 0.5362483944519797, 0.4819595570358778, 0.4627653023451026, 0.5836428255038342, 0.534601601122068, 0.5352783035821425, 0.08866524732393466, 0.17506990020357238, 0.18534281864119795, 0.2304426565033093, 0.19827125080973584, 0.11051004148679766, 0.1550693837149658, 0.11420866074474978, 0.1306895525641979, 0.28959801324507706, 0.29908892847302593, 0.2918800890901775, 0.3024327008260529, 0.3117848649635395, 0.3253268980581727, 0.3130051555574781, 0.3076676499890503, 0.31571497213032107, 0.6697855778139568, 0.6936969533890074, 0.6854895481878877, 0.7119366061329894, 0.697375012028574, 0.6748624123489337, 0.6845304842801586, 0.6790533693952605, 0.6734280992634145, 0.09940890594684282, 0.09343834904036197, 0.09330127195203008, 0.08333612694261372, 0.08919765893650311, 0.0876218867601819, 0.10439273861051934, 0.1001489326751851, 0.13660297936284738, 0.21811148677381742, 0.17476641618692246, 0.18943278927380602, 0.24040655086747298, 0.20150416695879714, 0.17681436174290788, 0.21067518506773963, 0.1381594299726132, 0.18303364543391676, 0.3679811763375812, 0.41510750779204586, 0.36695104387760213, 0.38799332908600104, 0.35407170205609473, 0.3947860441300203, 0.3895040994176343, 0.41279359636579604, 0.4078647130978882, 0.30559786019727375, 0.28829009583079757, 0.29131941133234074, 0.28117078634894854, 0.2937930756440188, 0.24762979074399116, 0.2920349921190002, 0.3073228753477335, 0.2724593879656705, 0.19709407127287693, 0.18783462505853676, 0.19942130678289982, 0.20304980720028265, 0.2009527529496855, 0.19493476431707102, 0.2078583972640059, 0.24994656170849805, 0.21465590785967925, 0.2271264099898871, 0.22439399023436513, 0.21443620353130355, 0.22119584596264152, 0.25084873443448663, 0.25491823871306274, 0.2139619204484835, 0.24634015177959379, 0.40924332108316874, 0.7574758399316956, 0.7727242628973505, 0.6601891228251205, 0.7936803247603185, 0.6771778238998505, 0.7454137703686081, 0.7474043847396739, 0.5972912148934852, 0.17982048541720363, 0.7037337623192819, 0.21118439612864892, 0.20323176479608118, 0.6297568416840995, 0.20485685093579142, 0.659103604663279, 0.2064461438875661, 0.7171654688005993, 0.20733309182972692, 0.17814054595856577, 0.19554209835120773, 0.20708982435329437, 0.18363440895001537, 0.18487380513927287, 0.18668609301784644, 0.18454501277684754, 0.1817696453445199, 0.1801338024177438, 0.07155617289002947, 0.07902451483597162, 0.07801777867482995, 0.07325130869619512, 0.07523069297581186, 0.0772123787015454, 0.07857773423967429, 0.08477147486122172, 0.08942246721873193]}, "mutation_prompt": null}
{"id": "bb0256e2-7313-453c-8bc7-9e0b2dc7e1ff", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F_min = 0.5\n        self.F_max = 0.9\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: self.F_min + (self.F_max - self.F_min) * np.sin(np.pi * evals / (2 * self.budget))\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring dynamic mutation factors for enhanced convergence speed.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "14651833-3775-4889-a373-46486d0b368a", "metadata": {"aucs": [0.7968801489948274, 0.7857497924017587, 0.7930328545470777, 0.7914670047123273, 0.8023822238935016, 0.8109194771862845, 0.800164806998958, 0.817803200297867, 0.7870132232830508, 0.6216307169653656, 0.6310550899106175, 0.6185505089884191, 0.6313678290375803, 0.6213181784600736, 0.6096564997091771, 0.6297841861499857, 0.6207330176311852, 0.5931058184961518, 0.13737654245243613, 0.12566714026964232, 0.1323614882800892, 0.15243616969966656, 0.13647791516802266, 0.12230712883238015, 0.11664204857317162, 0.10768905512354976, 0.11664567084069022, 0.10784737916717935, 0.10739655010257287, 0.11874664006138591, 0.11910921784580186, 0.09143043726144406, 0.11274734910169304, 0.15174149395845238, 0.10834452291541097, 0.11973330592501663, 0.9096515280251296, 0.9183820322978025, 0.9495766660581665, 0.913165975605537, 0.9071735649436963, 0.9742419185151416, 0.9554495952410039, 0.9577221069478945, 0.9339532000363818, 0.4948587276718043, 0.4912386491947567, 0.49171309659023077, 0.46530489784880624, 0.4934932895349048, 0.4949316352588573, 0.4829406382289163, 0.5182233521159227, 0.47568118628136224, 0.7117668763266587, 0.7340625175351826, 0.7433994019965051, 0.8023638858124337, 0.7190853253609248, 0.7623176440052908, 0.7939579330401683, 0.7906651634599782, 0.7236487124153514, 0.3730231263477255, 0.49082441917973707, 0.4623422724469112, 0.35929913761048304, 0.40103892398486873, 0.4092785895373692, 0.39520382427794143, 0.430617315906472, 0.41580561422114226, 0.36753347796792646, 0.3750264212737079, 0.3992107458674461, 0.466457131992021, 0.33824053597553283, 0.3484331405261333, 0.4622107427895388, 0.3758862649125817, 0.2801304539465099, 0.3332805760225239, 0.4192409133125341, 0.3343879556072872, 0.32925116693639744, 0.41137277102632663, 0.3102673764572109, 0.3940592140626512, 0.37311340492507294, 0.3707269942090258, 0.48097457640495245, 0.5390931009803086, 0.48682253515143825, 0.5362483944519797, 0.4819595570358778, 0.4627653023451026, 0.5836428255038342, 0.534601601122068, 0.5352783035821425, 0.08866524732393466, 0.17506990020357238, 0.18534281864119795, 0.2304426565033093, 0.19827125080973584, 0.11051004148679766, 0.1550693837149658, 0.11420866074474978, 0.1306895525641979, 0.28959801324507706, 0.29908892847302593, 0.2918800890901775, 0.3024327008260529, 0.3117848649635395, 0.3253268980581727, 0.3130051555574781, 0.3076676499890503, 0.31571497213032107, 0.6697855778139568, 0.6936969533890074, 0.6854895481878877, 0.7119366061329894, 0.697375012028574, 0.6748624123489337, 0.6845304842801586, 0.6790533693952605, 0.6734280992634145, 0.09940890594684282, 0.09343834904036197, 0.09330127195203008, 0.08333612694261372, 0.08919765893650311, 0.0876218867601819, 0.10439273861051934, 0.1001489326751851, 0.13660297936284738, 0.21811148677381742, 0.17476641618692246, 0.18943278927380602, 0.24040655086747298, 0.20150416695879714, 0.17681436174290788, 0.21067518506773963, 0.1381594299726132, 0.18303364543391676, 0.3679811763375812, 0.41510750779204586, 0.36695104387760213, 0.38799332908600104, 0.35407170205609473, 0.3947860441300203, 0.3895040994176343, 0.41279359636579604, 0.4078647130978882, 0.30559786019727375, 0.28829009583079757, 0.29131941133234074, 0.28117078634894854, 0.2937930756440188, 0.24762979074399116, 0.2920349921190002, 0.3073228753477335, 0.2724593879656705, 0.19709407127287693, 0.18783462505853676, 0.19942130678289982, 0.20304980720028265, 0.2009527529496855, 0.19493476431707102, 0.2078583972640059, 0.24994656170849805, 0.21465590785967925, 0.2271264099898871, 0.22439399023436513, 0.21443620353130355, 0.22119584596264152, 0.25084873443448663, 0.25491823871306274, 0.2139619204484835, 0.24634015177959379, 0.40924332108316874, 0.7574758399316956, 0.7727242628973505, 0.6601891228251205, 0.7936803247603185, 0.6771778238998505, 0.7454137703686081, 0.7474043847396739, 0.5972912148934852, 0.17982048541720363, 0.7037337623192819, 0.21118439612864892, 0.20323176479608118, 0.6297568416840995, 0.20485685093579142, 0.659103604663279, 0.2064461438875661, 0.7171654688005993, 0.20733309182972692, 0.17814054595856577, 0.19554209835120773, 0.20708982435329437, 0.18363440895001537, 0.18487380513927287, 0.18668609301784644, 0.18454501277684754, 0.1817696453445199, 0.1801338024177438, 0.07155617289002947, 0.07902451483597162, 0.07801777867482995, 0.07325130869619512, 0.07523069297581186, 0.0772123787015454, 0.07857773423967429, 0.08477147486122172, 0.08942246721873193]}, "mutation_prompt": null}
{"id": "5d346d64-7aa9-4c97-9f89-0355a324d9cf", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 12 * dim  # Increased initial population size for better exploration\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F_min = 0.4  # Adjusted mutation factor range\n        self.F_max = 0.8\n        self.CR = 0.95  # Increased crossover probability for more diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: self.F_min + (self.F_max - self.F_min) * np.cos(np.pi * evals / (2 * self.budget))  # Changed function for dynamic F\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.03  # Reduced step size for finer local search\n        for _ in range(7):  # Increased number of local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring dynamic mutation factors and improved local search for enhanced convergence speed.", "configspace": "", "generation": 82, "fitness": 0.3390763309094801, "feedback": "The algorithm DEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.22.", "error": "", "parent_id": "14651833-3775-4889-a373-46486d0b368a", "metadata": {"aucs": [0.6694425226539267, 0.6696598771304756, 0.6736159940327039, 0.6770481022991424, 0.6878605703809153, 0.6858707128161161, 0.67260613823736, 0.6974168414002571, 0.6914530913413361, 0.44258841536014093, 0.47209997721925456, 0.47515408332993914, 0.4765269079407334, 0.45767126963186966, 0.47685060193735873, 0.4965796515261365, 0.46904864500629906, 0.4737761879417439, 0.08282784195689297, 0.09807362187119728, 0.09503780954019658, 0.09635452554800727, 0.09860020034048433, 0.13532389580298043, 0.1051796054950419, 0.1032572193994471, 0.09355024548400193, 0.08327742612329692, 0.08561035019512597, 0.09669997557910626, 0.09346325595099425, 0.07922044397034356, 0.10025143335974518, 0.09958986513391987, 0.0953667740031573, 0.1004721208236482, 0.9457415873242206, 0.9492688360052719, 0.9145032920010605, 0.9309078601960074, 0.9338465065029771, 0.9431538043719142, 0.8793508978375725, 0.918056798893474, 0.946916938033183, 0.395353018393361, 0.413822601633806, 0.4021675186828798, 0.3729530009329125, 0.3587941420435822, 0.3647235307336011, 0.3938152935206417, 0.3903020729673967, 0.4174814851263624, 0.6212017057120944, 0.6208182190995548, 0.5974656615688205, 0.6054890974460704, 0.6309833969694995, 0.6614173449849324, 0.634353832224119, 0.6135288658072451, 0.6416785695559988, 0.23037185240256108, 0.15236002162347673, 0.39177224963186086, 0.22134532143366392, 0.3741365620191267, 0.3328604251209111, 0.20354696372376413, 0.22213563013585347, 0.2500023012578756, 0.40185803181169877, 0.23640480540047593, 0.379665387865859, 0.37834391059424666, 0.3841296412601629, 0.24937388496191448, 0.2096633619323417, 0.19437506159051676, 0.2292548023182921, 0.34738287291298653, 0.3208468751030147, 0.24119708708896037, 0.35284090818014757, 0.3257365892930556, 0.3490226912434159, 0.3289325820462806, 0.3228531623992974, 0.2528832298340463, 0.43283776966242316, 0.4985026380359465, 0.46225750594835546, 0.42437746253226893, 0.4474594699623814, 0.4098141525249238, 0.4698834152792434, 0.5006795536523003, 0.47766027389723276, 0.08748757464669799, 0.09896063503086394, 0.09543261859284757, 0.17998845224769155, 0.16953502039500723, 0.24734401367877845, 0.1038423505720446, 0.12198646809106062, 0.08874929109821783, 0.24604331991490402, 0.2718776207243665, 0.29467049210500673, 0.27420529439658425, 0.2650064702550873, 0.27159961919185394, 0.28856869561987186, 0.27321201481881796, 0.26574699890109266, 0.6028462258030894, 0.6097422040350369, 0.601899709271609, 0.6100757562778931, 0.5853871257673331, 0.6162918881453663, 0.6108782806366504, 0.5903860229390765, 0.6116282555976353, 0.08489308932206352, 0.09374694057302235, 0.0933816438300632, 0.10071221946634978, 0.0950034525661948, 0.08380456560891547, 0.09556154881099843, 0.08964623648384662, 0.08866331020249874, 0.28257563170654165, 0.44473660676293414, 0.18153760190832768, 0.16932209713112156, 0.21654374128756892, 0.4893706978889657, 0.1785314361710496, 0.24157409430805998, 0.2151968328343653, 0.3462073302690485, 0.3443583685981346, 0.34908922155292965, 0.3496782115549524, 0.343961789864102, 0.3076932315397094, 0.34793573514926446, 0.3502878232912682, 0.35617071401829403, 0.24863397734782744, 0.28049857741428286, 0.2868979894684782, 0.26583167045204503, 0.2373893531816037, 0.27365965239029555, 0.28447830989237677, 0.2701219494837861, 0.2609124294284103, 0.2009832418116816, 0.19170601346173832, 0.18276783705665978, 0.18392090232519298, 0.21614154405395114, 0.18280297060415174, 0.19669033291899574, 0.19445172966177715, 0.17136616059904752, 0.25227939715228076, 0.19772509582996267, 0.270863302254004, 0.20462820588287622, 0.2242514308069764, 0.1923438839577195, 0.1839685628706712, 0.1771041670242265, 0.19735276909357058, 0.1893315732080213, 0.19697407525410848, 0.5843334309490901, 0.5827828430576878, 0.1997205885068969, 0.6367990074023364, 0.6592278155969491, 0.649390681090934, 0.7479476858081671, 0.7322401271967514, 0.2113423781825433, 0.16499480911514397, 0.5370141872718905, 0.20621536856866296, 0.5276446902806845, 0.6321708786812699, 0.20796255848907308, 0.21050381538317875, 0.1869603013617599, 0.17309581333923907, 0.17783411725172427, 0.18093379765491435, 0.19688629869844554, 0.19293881313324912, 0.17662978073486024, 0.18937993476290682, 0.17901114474027768, 0.06648776594785122, 0.06863465478865549, 0.07553667800017339, 0.07529979030012457, 0.06294325990180838, 0.07217037618253341, 0.06960509071797405, 0.07661315731633478, 0.07729160567906235]}, "mutation_prompt": null}
{"id": "0dbbb326-f34f-4317-bb57-cac26e68ce2e", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F_min = 0.5\n        self.F_max = 0.9\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: self.F_min + (self.F_max - self.F_min) * np.sin(np.pi * evals / (2 * self.budget))\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring dynamic mutation factors for enhanced convergence speed.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "14651833-3775-4889-a373-46486d0b368a", "metadata": {"aucs": [0.7968801489948274, 0.7857497924017587, 0.7930328545470777, 0.7914670047123273, 0.8023822238935016, 0.8109194771862845, 0.800164806998958, 0.817803200297867, 0.7870132232830508, 0.6216307169653656, 0.6310550899106175, 0.6185505089884191, 0.6313678290375803, 0.6213181784600736, 0.6096564997091771, 0.6297841861499857, 0.6207330176311852, 0.5931058184961518, 0.13737654245243613, 0.12566714026964232, 0.1323614882800892, 0.15243616969966656, 0.13647791516802266, 0.12230712883238015, 0.11664204857317162, 0.10768905512354976, 0.11664567084069022, 0.10784737916717935, 0.10739655010257287, 0.11874664006138591, 0.11910921784580186, 0.09143043726144406, 0.11274734910169304, 0.15174149395845238, 0.10834452291541097, 0.11973330592501663, 0.9096515280251296, 0.9183820322978025, 0.9495766660581665, 0.913165975605537, 0.9071735649436963, 0.9742419185151416, 0.9554495952410039, 0.9577221069478945, 0.9339532000363818, 0.4948587276718043, 0.4912386491947567, 0.49171309659023077, 0.46530489784880624, 0.4934932895349048, 0.4949316352588573, 0.4829406382289163, 0.5182233521159227, 0.47568118628136224, 0.7117668763266587, 0.7340625175351826, 0.7433994019965051, 0.8023638858124337, 0.7190853253609248, 0.7623176440052908, 0.7939579330401683, 0.7906651634599782, 0.7236487124153514, 0.3730231263477255, 0.49082441917973707, 0.4623422724469112, 0.35929913761048304, 0.40103892398486873, 0.4092785895373692, 0.39520382427794143, 0.430617315906472, 0.41580561422114226, 0.36753347796792646, 0.3750264212737079, 0.3992107458674461, 0.466457131992021, 0.33824053597553283, 0.3484331405261333, 0.4622107427895388, 0.3758862649125817, 0.2801304539465099, 0.3332805760225239, 0.4192409133125341, 0.3343879556072872, 0.32925116693639744, 0.41137277102632663, 0.3102673764572109, 0.3940592140626512, 0.37311340492507294, 0.3707269942090258, 0.48097457640495245, 0.5390931009803086, 0.48682253515143825, 0.5362483944519797, 0.4819595570358778, 0.4627653023451026, 0.5836428255038342, 0.534601601122068, 0.5352783035821425, 0.08866524732393466, 0.17506990020357238, 0.18534281864119795, 0.2304426565033093, 0.19827125080973584, 0.11051004148679766, 0.1550693837149658, 0.11420866074474978, 0.1306895525641979, 0.28959801324507706, 0.29908892847302593, 0.2918800890901775, 0.3024327008260529, 0.3117848649635395, 0.3253268980581727, 0.3130051555574781, 0.3076676499890503, 0.31571497213032107, 0.6697855778139568, 0.6936969533890074, 0.6854895481878877, 0.7119366061329894, 0.697375012028574, 0.6748624123489337, 0.6845304842801586, 0.6790533693952605, 0.6734280992634145, 0.09940890594684282, 0.09343834904036197, 0.09330127195203008, 0.08333612694261372, 0.08919765893650311, 0.0876218867601819, 0.10439273861051934, 0.1001489326751851, 0.13660297936284738, 0.21811148677381742, 0.17476641618692246, 0.18943278927380602, 0.24040655086747298, 0.20150416695879714, 0.17681436174290788, 0.21067518506773963, 0.1381594299726132, 0.18303364543391676, 0.3679811763375812, 0.41510750779204586, 0.36695104387760213, 0.38799332908600104, 0.35407170205609473, 0.3947860441300203, 0.3895040994176343, 0.41279359636579604, 0.4078647130978882, 0.30559786019727375, 0.28829009583079757, 0.29131941133234074, 0.28117078634894854, 0.2937930756440188, 0.24762979074399116, 0.2920349921190002, 0.3073228753477335, 0.2724593879656705, 0.19709407127287693, 0.18783462505853676, 0.19942130678289982, 0.20304980720028265, 0.2009527529496855, 0.19493476431707102, 0.2078583972640059, 0.24994656170849805, 0.21465590785967925, 0.2271264099898871, 0.22439399023436513, 0.21443620353130355, 0.22119584596264152, 0.25084873443448663, 0.25491823871306274, 0.2139619204484835, 0.24634015177959379, 0.40924332108316874, 0.7574758399316956, 0.7727242628973505, 0.6601891228251205, 0.7936803247603185, 0.6771778238998505, 0.7454137703686081, 0.7474043847396739, 0.5972912148934852, 0.17982048541720363, 0.7037337623192819, 0.21118439612864892, 0.20323176479608118, 0.6297568416840995, 0.20485685093579142, 0.659103604663279, 0.2064461438875661, 0.7171654688005993, 0.20733309182972692, 0.17814054595856577, 0.19554209835120773, 0.20708982435329437, 0.18363440895001537, 0.18487380513927287, 0.18668609301784644, 0.18454501277684754, 0.1817696453445199, 0.1801338024177438, 0.07155617289002947, 0.07902451483597162, 0.07801777867482995, 0.07325130869619512, 0.07523069297581186, 0.0772123787015454, 0.07857773423967429, 0.08477147486122172, 0.08942246721873193]}, "mutation_prompt": null}
{"id": "4b324ae6-28a5-4e87-abc8-6387dcb7dafc", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F_min = 0.5\n        self.F_max = 0.9\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: self.F_min + (self.F_max - self.F_min) * np.sin(np.pi * evals / (2 * self.budget))\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring dynamic mutation factors for enhanced convergence speed.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "14651833-3775-4889-a373-46486d0b368a", "metadata": {"aucs": [0.7968801489948274, 0.7857497924017587, 0.7930328545470777, 0.7914670047123273, 0.8023822238935016, 0.8109194771862845, 0.800164806998958, 0.817803200297867, 0.7870132232830508, 0.6216307169653656, 0.6310550899106175, 0.6185505089884191, 0.6313678290375803, 0.6213181784600736, 0.6096564997091771, 0.6297841861499857, 0.6207330176311852, 0.5931058184961518, 0.13737654245243613, 0.12566714026964232, 0.1323614882800892, 0.15243616969966656, 0.13647791516802266, 0.12230712883238015, 0.11664204857317162, 0.10768905512354976, 0.11664567084069022, 0.10784737916717935, 0.10739655010257287, 0.11874664006138591, 0.11910921784580186, 0.09143043726144406, 0.11274734910169304, 0.15174149395845238, 0.10834452291541097, 0.11973330592501663, 0.9096515280251296, 0.9183820322978025, 0.9495766660581665, 0.913165975605537, 0.9071735649436963, 0.9742419185151416, 0.9554495952410039, 0.9577221069478945, 0.9339532000363818, 0.4948587276718043, 0.4912386491947567, 0.49171309659023077, 0.46530489784880624, 0.4934932895349048, 0.4949316352588573, 0.4829406382289163, 0.5182233521159227, 0.47568118628136224, 0.7117668763266587, 0.7340625175351826, 0.7433994019965051, 0.8023638858124337, 0.7190853253609248, 0.7623176440052908, 0.7939579330401683, 0.7906651634599782, 0.7236487124153514, 0.3730231263477255, 0.49082441917973707, 0.4623422724469112, 0.35929913761048304, 0.40103892398486873, 0.4092785895373692, 0.39520382427794143, 0.430617315906472, 0.41580561422114226, 0.36753347796792646, 0.3750264212737079, 0.3992107458674461, 0.466457131992021, 0.33824053597553283, 0.3484331405261333, 0.4622107427895388, 0.3758862649125817, 0.2801304539465099, 0.3332805760225239, 0.4192409133125341, 0.3343879556072872, 0.32925116693639744, 0.41137277102632663, 0.3102673764572109, 0.3940592140626512, 0.37311340492507294, 0.3707269942090258, 0.48097457640495245, 0.5390931009803086, 0.48682253515143825, 0.5362483944519797, 0.4819595570358778, 0.4627653023451026, 0.5836428255038342, 0.534601601122068, 0.5352783035821425, 0.08866524732393466, 0.17506990020357238, 0.18534281864119795, 0.2304426565033093, 0.19827125080973584, 0.11051004148679766, 0.1550693837149658, 0.11420866074474978, 0.1306895525641979, 0.28959801324507706, 0.29908892847302593, 0.2918800890901775, 0.3024327008260529, 0.3117848649635395, 0.3253268980581727, 0.3130051555574781, 0.3076676499890503, 0.31571497213032107, 0.6697855778139568, 0.6936969533890074, 0.6854895481878877, 0.7119366061329894, 0.697375012028574, 0.6748624123489337, 0.6845304842801586, 0.6790533693952605, 0.6734280992634145, 0.09940890594684282, 0.09343834904036197, 0.09330127195203008, 0.08333612694261372, 0.08919765893650311, 0.0876218867601819, 0.10439273861051934, 0.1001489326751851, 0.13660297936284738, 0.21811148677381742, 0.17476641618692246, 0.18943278927380602, 0.24040655086747298, 0.20150416695879714, 0.17681436174290788, 0.21067518506773963, 0.1381594299726132, 0.18303364543391676, 0.3679811763375812, 0.41510750779204586, 0.36695104387760213, 0.38799332908600104, 0.35407170205609473, 0.3947860441300203, 0.3895040994176343, 0.41279359636579604, 0.4078647130978882, 0.30559786019727375, 0.28829009583079757, 0.29131941133234074, 0.28117078634894854, 0.2937930756440188, 0.24762979074399116, 0.2920349921190002, 0.3073228753477335, 0.2724593879656705, 0.19709407127287693, 0.18783462505853676, 0.19942130678289982, 0.20304980720028265, 0.2009527529496855, 0.19493476431707102, 0.2078583972640059, 0.24994656170849805, 0.21465590785967925, 0.2271264099898871, 0.22439399023436513, 0.21443620353130355, 0.22119584596264152, 0.25084873443448663, 0.25491823871306274, 0.2139619204484835, 0.24634015177959379, 0.40924332108316874, 0.7574758399316956, 0.7727242628973505, 0.6601891228251205, 0.7936803247603185, 0.6771778238998505, 0.7454137703686081, 0.7474043847396739, 0.5972912148934852, 0.17982048541720363, 0.7037337623192819, 0.21118439612864892, 0.20323176479608118, 0.6297568416840995, 0.20485685093579142, 0.659103604663279, 0.2064461438875661, 0.7171654688005993, 0.20733309182972692, 0.17814054595856577, 0.19554209835120773, 0.20708982435329437, 0.18363440895001537, 0.18487380513927287, 0.18668609301784644, 0.18454501277684754, 0.1817696453445199, 0.1801338024177438, 0.07155617289002947, 0.07902451483597162, 0.07801777867482995, 0.07325130869619512, 0.07523069297581186, 0.0772123787015454, 0.07857773423967429, 0.08477147486122172, 0.08942246721873193]}, "mutation_prompt": null}
{"id": "2bfe9618-d64c-4f80-b239-11cfec59fe66", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F_min = 0.5\n        self.F_max = 0.9\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: self.F_min + (self.F_max - self.F_min) * np.sin(np.pi * evals / (2 * self.budget))\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring dynamic mutation factors for enhanced convergence speed.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "14651833-3775-4889-a373-46486d0b368a", "metadata": {"aucs": [0.7968801489948274, 0.7857497924017587, 0.7930328545470777, 0.7914670047123273, 0.8023822238935016, 0.8109194771862845, 0.800164806998958, 0.817803200297867, 0.7870132232830508, 0.6216307169653656, 0.6310550899106175, 0.6185505089884191, 0.6313678290375803, 0.6213181784600736, 0.6096564997091771, 0.6297841861499857, 0.6207330176311852, 0.5931058184961518, 0.13737654245243613, 0.12566714026964232, 0.1323614882800892, 0.15243616969966656, 0.13647791516802266, 0.12230712883238015, 0.11664204857317162, 0.10768905512354976, 0.11664567084069022, 0.10784737916717935, 0.10739655010257287, 0.11874664006138591, 0.11910921784580186, 0.09143043726144406, 0.11274734910169304, 0.15174149395845238, 0.10834452291541097, 0.11973330592501663, 0.9096515280251296, 0.9183820322978025, 0.9495766660581665, 0.913165975605537, 0.9071735649436963, 0.9742419185151416, 0.9554495952410039, 0.9577221069478945, 0.9339532000363818, 0.4948587276718043, 0.4912386491947567, 0.49171309659023077, 0.46530489784880624, 0.4934932895349048, 0.4949316352588573, 0.4829406382289163, 0.5182233521159227, 0.47568118628136224, 0.7117668763266587, 0.7340625175351826, 0.7433994019965051, 0.8023638858124337, 0.7190853253609248, 0.7623176440052908, 0.7939579330401683, 0.7906651634599782, 0.7236487124153514, 0.3730231263477255, 0.49082441917973707, 0.4623422724469112, 0.35929913761048304, 0.40103892398486873, 0.4092785895373692, 0.39520382427794143, 0.430617315906472, 0.41580561422114226, 0.36753347796792646, 0.3750264212737079, 0.3992107458674461, 0.466457131992021, 0.33824053597553283, 0.3484331405261333, 0.4622107427895388, 0.3758862649125817, 0.2801304539465099, 0.3332805760225239, 0.4192409133125341, 0.3343879556072872, 0.32925116693639744, 0.41137277102632663, 0.3102673764572109, 0.3940592140626512, 0.37311340492507294, 0.3707269942090258, 0.48097457640495245, 0.5390931009803086, 0.48682253515143825, 0.5362483944519797, 0.4819595570358778, 0.4627653023451026, 0.5836428255038342, 0.534601601122068, 0.5352783035821425, 0.08866524732393466, 0.17506990020357238, 0.18534281864119795, 0.2304426565033093, 0.19827125080973584, 0.11051004148679766, 0.1550693837149658, 0.11420866074474978, 0.1306895525641979, 0.28959801324507706, 0.29908892847302593, 0.2918800890901775, 0.3024327008260529, 0.3117848649635395, 0.3253268980581727, 0.3130051555574781, 0.3076676499890503, 0.31571497213032107, 0.6697855778139568, 0.6936969533890074, 0.6854895481878877, 0.7119366061329894, 0.697375012028574, 0.6748624123489337, 0.6845304842801586, 0.6790533693952605, 0.6734280992634145, 0.09940890594684282, 0.09343834904036197, 0.09330127195203008, 0.08333612694261372, 0.08919765893650311, 0.0876218867601819, 0.10439273861051934, 0.1001489326751851, 0.13660297936284738, 0.21811148677381742, 0.17476641618692246, 0.18943278927380602, 0.24040655086747298, 0.20150416695879714, 0.17681436174290788, 0.21067518506773963, 0.1381594299726132, 0.18303364543391676, 0.3679811763375812, 0.41510750779204586, 0.36695104387760213, 0.38799332908600104, 0.35407170205609473, 0.3947860441300203, 0.3895040994176343, 0.41279359636579604, 0.4078647130978882, 0.30559786019727375, 0.28829009583079757, 0.29131941133234074, 0.28117078634894854, 0.2937930756440188, 0.24762979074399116, 0.2920349921190002, 0.3073228753477335, 0.2724593879656705, 0.19709407127287693, 0.18783462505853676, 0.19942130678289982, 0.20304980720028265, 0.2009527529496855, 0.19493476431707102, 0.2078583972640059, 0.24994656170849805, 0.21465590785967925, 0.2271264099898871, 0.22439399023436513, 0.21443620353130355, 0.22119584596264152, 0.25084873443448663, 0.25491823871306274, 0.2139619204484835, 0.24634015177959379, 0.40924332108316874, 0.7574758399316956, 0.7727242628973505, 0.6601891228251205, 0.7936803247603185, 0.6771778238998505, 0.7454137703686081, 0.7474043847396739, 0.5972912148934852, 0.17982048541720363, 0.7037337623192819, 0.21118439612864892, 0.20323176479608118, 0.6297568416840995, 0.20485685093579142, 0.659103604663279, 0.2064461438875661, 0.7171654688005993, 0.20733309182972692, 0.17814054595856577, 0.19554209835120773, 0.20708982435329437, 0.18363440895001537, 0.18487380513927287, 0.18668609301784644, 0.18454501277684754, 0.1817696453445199, 0.1801338024177438, 0.07155617289002947, 0.07902451483597162, 0.07801777867482995, 0.07325130869619512, 0.07523069297581186, 0.0772123787015454, 0.07857773423967429, 0.08477147486122172, 0.08942246721873193]}, "mutation_prompt": null}
{"id": "f6f8044b-c0e3-4e16-b606-174095dc25af", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F_min = 0.5\n        self.F_max = 0.9\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: self.F_min + (self.F_max - self.F_min) * np.sin(np.pi * evals / (2 * self.budget))\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring dynamic mutation factors for enhanced convergence speed.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "14651833-3775-4889-a373-46486d0b368a", "metadata": {"aucs": [0.7968801489948274, 0.7857497924017587, 0.7930328545470777, 0.7914670047123273, 0.8023822238935016, 0.8109194771862845, 0.800164806998958, 0.817803200297867, 0.7870132232830508, 0.6216307169653656, 0.6310550899106175, 0.6185505089884191, 0.6313678290375803, 0.6213181784600736, 0.6096564997091771, 0.6297841861499857, 0.6207330176311852, 0.5931058184961518, 0.13737654245243613, 0.12566714026964232, 0.1323614882800892, 0.15243616969966656, 0.13647791516802266, 0.12230712883238015, 0.11664204857317162, 0.10768905512354976, 0.11664567084069022, 0.10784737916717935, 0.10739655010257287, 0.11874664006138591, 0.11910921784580186, 0.09143043726144406, 0.11274734910169304, 0.15174149395845238, 0.10834452291541097, 0.11973330592501663, 0.9096515280251296, 0.9183820322978025, 0.9495766660581665, 0.913165975605537, 0.9071735649436963, 0.9742419185151416, 0.9554495952410039, 0.9577221069478945, 0.9339532000363818, 0.4948587276718043, 0.4912386491947567, 0.49171309659023077, 0.46530489784880624, 0.4934932895349048, 0.4949316352588573, 0.4829406382289163, 0.5182233521159227, 0.47568118628136224, 0.7117668763266587, 0.7340625175351826, 0.7433994019965051, 0.8023638858124337, 0.7190853253609248, 0.7623176440052908, 0.7939579330401683, 0.7906651634599782, 0.7236487124153514, 0.3730231263477255, 0.49082441917973707, 0.4623422724469112, 0.35929913761048304, 0.40103892398486873, 0.4092785895373692, 0.39520382427794143, 0.430617315906472, 0.41580561422114226, 0.36753347796792646, 0.3750264212737079, 0.3992107458674461, 0.466457131992021, 0.33824053597553283, 0.3484331405261333, 0.4622107427895388, 0.3758862649125817, 0.2801304539465099, 0.3332805760225239, 0.4192409133125341, 0.3343879556072872, 0.32925116693639744, 0.41137277102632663, 0.3102673764572109, 0.3940592140626512, 0.37311340492507294, 0.3707269942090258, 0.48097457640495245, 0.5390931009803086, 0.48682253515143825, 0.5362483944519797, 0.4819595570358778, 0.4627653023451026, 0.5836428255038342, 0.534601601122068, 0.5352783035821425, 0.08866524732393466, 0.17506990020357238, 0.18534281864119795, 0.2304426565033093, 0.19827125080973584, 0.11051004148679766, 0.1550693837149658, 0.11420866074474978, 0.1306895525641979, 0.28959801324507706, 0.29908892847302593, 0.2918800890901775, 0.3024327008260529, 0.3117848649635395, 0.3253268980581727, 0.3130051555574781, 0.3076676499890503, 0.31571497213032107, 0.6697855778139568, 0.6936969533890074, 0.6854895481878877, 0.7119366061329894, 0.697375012028574, 0.6748624123489337, 0.6845304842801586, 0.6790533693952605, 0.6734280992634145, 0.09940890594684282, 0.09343834904036197, 0.09330127195203008, 0.08333612694261372, 0.08919765893650311, 0.0876218867601819, 0.10439273861051934, 0.1001489326751851, 0.13660297936284738, 0.21811148677381742, 0.17476641618692246, 0.18943278927380602, 0.24040655086747298, 0.20150416695879714, 0.17681436174290788, 0.21067518506773963, 0.1381594299726132, 0.18303364543391676, 0.3679811763375812, 0.41510750779204586, 0.36695104387760213, 0.38799332908600104, 0.35407170205609473, 0.3947860441300203, 0.3895040994176343, 0.41279359636579604, 0.4078647130978882, 0.30559786019727375, 0.28829009583079757, 0.29131941133234074, 0.28117078634894854, 0.2937930756440188, 0.24762979074399116, 0.2920349921190002, 0.3073228753477335, 0.2724593879656705, 0.19709407127287693, 0.18783462505853676, 0.19942130678289982, 0.20304980720028265, 0.2009527529496855, 0.19493476431707102, 0.2078583972640059, 0.24994656170849805, 0.21465590785967925, 0.2271264099898871, 0.22439399023436513, 0.21443620353130355, 0.22119584596264152, 0.25084873443448663, 0.25491823871306274, 0.2139619204484835, 0.24634015177959379, 0.40924332108316874, 0.7574758399316956, 0.7727242628973505, 0.6601891228251205, 0.7936803247603185, 0.6771778238998505, 0.7454137703686081, 0.7474043847396739, 0.5972912148934852, 0.17982048541720363, 0.7037337623192819, 0.21118439612864892, 0.20323176479608118, 0.6297568416840995, 0.20485685093579142, 0.659103604663279, 0.2064461438875661, 0.7171654688005993, 0.20733309182972692, 0.17814054595856577, 0.19554209835120773, 0.20708982435329437, 0.18363440895001537, 0.18487380513927287, 0.18668609301784644, 0.18454501277684754, 0.1817696453445199, 0.1801338024177438, 0.07155617289002947, 0.07902451483597162, 0.07801777867482995, 0.07325130869619512, 0.07523069297581186, 0.0772123787015454, 0.07857773423967429, 0.08477147486122172, 0.08942246721873193]}, "mutation_prompt": null}
{"id": "02036316-a510-41a2-9e2a-c303f9cb52af", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F_min = 0.5\n        self.F_max = 0.9\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: self.F_min + (self.F_max - self.F_min) * np.sin(np.pi * evals / (2 * self.budget))\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring dynamic mutation factors for enhanced convergence speed.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "14651833-3775-4889-a373-46486d0b368a", "metadata": {"aucs": [0.7968801489948274, 0.7857497924017587, 0.7930328545470777, 0.7914670047123273, 0.8023822238935016, 0.8109194771862845, 0.800164806998958, 0.817803200297867, 0.7870132232830508, 0.6216307169653656, 0.6310550899106175, 0.6185505089884191, 0.6313678290375803, 0.6213181784600736, 0.6096564997091771, 0.6297841861499857, 0.6207330176311852, 0.5931058184961518, 0.13737654245243613, 0.12566714026964232, 0.1323614882800892, 0.15243616969966656, 0.13647791516802266, 0.12230712883238015, 0.11664204857317162, 0.10768905512354976, 0.11664567084069022, 0.10784737916717935, 0.10739655010257287, 0.11874664006138591, 0.11910921784580186, 0.09143043726144406, 0.11274734910169304, 0.15174149395845238, 0.10834452291541097, 0.11973330592501663, 0.9096515280251296, 0.9183820322978025, 0.9495766660581665, 0.913165975605537, 0.9071735649436963, 0.9742419185151416, 0.9554495952410039, 0.9577221069478945, 0.9339532000363818, 0.4948587276718043, 0.4912386491947567, 0.49171309659023077, 0.46530489784880624, 0.4934932895349048, 0.4949316352588573, 0.4829406382289163, 0.5182233521159227, 0.47568118628136224, 0.7117668763266587, 0.7340625175351826, 0.7433994019965051, 0.8023638858124337, 0.7190853253609248, 0.7623176440052908, 0.7939579330401683, 0.7906651634599782, 0.7236487124153514, 0.3730231263477255, 0.49082441917973707, 0.4623422724469112, 0.35929913761048304, 0.40103892398486873, 0.4092785895373692, 0.39520382427794143, 0.430617315906472, 0.41580561422114226, 0.36753347796792646, 0.3750264212737079, 0.3992107458674461, 0.466457131992021, 0.33824053597553283, 0.3484331405261333, 0.4622107427895388, 0.3758862649125817, 0.2801304539465099, 0.3332805760225239, 0.4192409133125341, 0.3343879556072872, 0.32925116693639744, 0.41137277102632663, 0.3102673764572109, 0.3940592140626512, 0.37311340492507294, 0.3707269942090258, 0.48097457640495245, 0.5390931009803086, 0.48682253515143825, 0.5362483944519797, 0.4819595570358778, 0.4627653023451026, 0.5836428255038342, 0.534601601122068, 0.5352783035821425, 0.08866524732393466, 0.17506990020357238, 0.18534281864119795, 0.2304426565033093, 0.19827125080973584, 0.11051004148679766, 0.1550693837149658, 0.11420866074474978, 0.1306895525641979, 0.28959801324507706, 0.29908892847302593, 0.2918800890901775, 0.3024327008260529, 0.3117848649635395, 0.3253268980581727, 0.3130051555574781, 0.3076676499890503, 0.31571497213032107, 0.6697855778139568, 0.6936969533890074, 0.6854895481878877, 0.7119366061329894, 0.697375012028574, 0.6748624123489337, 0.6845304842801586, 0.6790533693952605, 0.6734280992634145, 0.09940890594684282, 0.09343834904036197, 0.09330127195203008, 0.08333612694261372, 0.08919765893650311, 0.0876218867601819, 0.10439273861051934, 0.1001489326751851, 0.13660297936284738, 0.21811148677381742, 0.17476641618692246, 0.18943278927380602, 0.24040655086747298, 0.20150416695879714, 0.17681436174290788, 0.21067518506773963, 0.1381594299726132, 0.18303364543391676, 0.3679811763375812, 0.41510750779204586, 0.36695104387760213, 0.38799332908600104, 0.35407170205609473, 0.3947860441300203, 0.3895040994176343, 0.41279359636579604, 0.4078647130978882, 0.30559786019727375, 0.28829009583079757, 0.29131941133234074, 0.28117078634894854, 0.2937930756440188, 0.24762979074399116, 0.2920349921190002, 0.3073228753477335, 0.2724593879656705, 0.19709407127287693, 0.18783462505853676, 0.19942130678289982, 0.20304980720028265, 0.2009527529496855, 0.19493476431707102, 0.2078583972640059, 0.24994656170849805, 0.21465590785967925, 0.2271264099898871, 0.22439399023436513, 0.21443620353130355, 0.22119584596264152, 0.25084873443448663, 0.25491823871306274, 0.2139619204484835, 0.24634015177959379, 0.40924332108316874, 0.7574758399316956, 0.7727242628973505, 0.6601891228251205, 0.7936803247603185, 0.6771778238998505, 0.7454137703686081, 0.7474043847396739, 0.5972912148934852, 0.17982048541720363, 0.7037337623192819, 0.21118439612864892, 0.20323176479608118, 0.6297568416840995, 0.20485685093579142, 0.659103604663279, 0.2064461438875661, 0.7171654688005993, 0.20733309182972692, 0.17814054595856577, 0.19554209835120773, 0.20708982435329437, 0.18363440895001537, 0.18487380513927287, 0.18668609301784644, 0.18454501277684754, 0.1817696453445199, 0.1801338024177438, 0.07155617289002947, 0.07902451483597162, 0.07801777867482995, 0.07325130869619512, 0.07523069297581186, 0.0772123787015454, 0.07857773423967429, 0.08477147486122172, 0.08942246721873193]}, "mutation_prompt": null}
{"id": "83d381a8-ab77-44da-bf30-9a3df7be3f0c", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F_min = 0.5\n        self.F_max = 0.9\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: self.F_min + (self.F_max - self.F_min) * np.sin(np.pi * evals / (2 * self.budget))\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring dynamic mutation factors for enhanced convergence speed.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "14651833-3775-4889-a373-46486d0b368a", "metadata": {"aucs": [0.7968801489948274, 0.7857497924017587, 0.7930328545470777, 0.7914670047123273, 0.8023822238935016, 0.8109194771862845, 0.800164806998958, 0.817803200297867, 0.7870132232830508, 0.6216307169653656, 0.6310550899106175, 0.6185505089884191, 0.6313678290375803, 0.6213181784600736, 0.6096564997091771, 0.6297841861499857, 0.6207330176311852, 0.5931058184961518, 0.13737654245243613, 0.12566714026964232, 0.1323614882800892, 0.15243616969966656, 0.13647791516802266, 0.12230712883238015, 0.11664204857317162, 0.10768905512354976, 0.11664567084069022, 0.10784737916717935, 0.10739655010257287, 0.11874664006138591, 0.11910921784580186, 0.09143043726144406, 0.11274734910169304, 0.15174149395845238, 0.10834452291541097, 0.11973330592501663, 0.9096515280251296, 0.9183820322978025, 0.9495766660581665, 0.913165975605537, 0.9071735649436963, 0.9742419185151416, 0.9554495952410039, 0.9577221069478945, 0.9339532000363818, 0.4948587276718043, 0.4912386491947567, 0.49171309659023077, 0.46530489784880624, 0.4934932895349048, 0.4949316352588573, 0.4829406382289163, 0.5182233521159227, 0.47568118628136224, 0.7117668763266587, 0.7340625175351826, 0.7433994019965051, 0.8023638858124337, 0.7190853253609248, 0.7623176440052908, 0.7939579330401683, 0.7906651634599782, 0.7236487124153514, 0.3730231263477255, 0.49082441917973707, 0.4623422724469112, 0.35929913761048304, 0.40103892398486873, 0.4092785895373692, 0.39520382427794143, 0.430617315906472, 0.41580561422114226, 0.36753347796792646, 0.3750264212737079, 0.3992107458674461, 0.466457131992021, 0.33824053597553283, 0.3484331405261333, 0.4622107427895388, 0.3758862649125817, 0.2801304539465099, 0.3332805760225239, 0.4192409133125341, 0.3343879556072872, 0.32925116693639744, 0.41137277102632663, 0.3102673764572109, 0.3940592140626512, 0.37311340492507294, 0.3707269942090258, 0.48097457640495245, 0.5390931009803086, 0.48682253515143825, 0.5362483944519797, 0.4819595570358778, 0.4627653023451026, 0.5836428255038342, 0.534601601122068, 0.5352783035821425, 0.08866524732393466, 0.17506990020357238, 0.18534281864119795, 0.2304426565033093, 0.19827125080973584, 0.11051004148679766, 0.1550693837149658, 0.11420866074474978, 0.1306895525641979, 0.28959801324507706, 0.29908892847302593, 0.2918800890901775, 0.3024327008260529, 0.3117848649635395, 0.3253268980581727, 0.3130051555574781, 0.3076676499890503, 0.31571497213032107, 0.6697855778139568, 0.6936969533890074, 0.6854895481878877, 0.7119366061329894, 0.697375012028574, 0.6748624123489337, 0.6845304842801586, 0.6790533693952605, 0.6734280992634145, 0.09940890594684282, 0.09343834904036197, 0.09330127195203008, 0.08333612694261372, 0.08919765893650311, 0.0876218867601819, 0.10439273861051934, 0.1001489326751851, 0.13660297936284738, 0.21811148677381742, 0.17476641618692246, 0.18943278927380602, 0.24040655086747298, 0.20150416695879714, 0.17681436174290788, 0.21067518506773963, 0.1381594299726132, 0.18303364543391676, 0.3679811763375812, 0.41510750779204586, 0.36695104387760213, 0.38799332908600104, 0.35407170205609473, 0.3947860441300203, 0.3895040994176343, 0.41279359636579604, 0.4078647130978882, 0.30559786019727375, 0.28829009583079757, 0.29131941133234074, 0.28117078634894854, 0.2937930756440188, 0.24762979074399116, 0.2920349921190002, 0.3073228753477335, 0.2724593879656705, 0.19709407127287693, 0.18783462505853676, 0.19942130678289982, 0.20304980720028265, 0.2009527529496855, 0.19493476431707102, 0.2078583972640059, 0.24994656170849805, 0.21465590785967925, 0.2271264099898871, 0.22439399023436513, 0.21443620353130355, 0.22119584596264152, 0.25084873443448663, 0.25491823871306274, 0.2139619204484835, 0.24634015177959379, 0.40924332108316874, 0.7574758399316956, 0.7727242628973505, 0.6601891228251205, 0.7936803247603185, 0.6771778238998505, 0.7454137703686081, 0.7474043847396739, 0.5972912148934852, 0.17982048541720363, 0.7037337623192819, 0.21118439612864892, 0.20323176479608118, 0.6297568416840995, 0.20485685093579142, 0.659103604663279, 0.2064461438875661, 0.7171654688005993, 0.20733309182972692, 0.17814054595856577, 0.19554209835120773, 0.20708982435329437, 0.18363440895001537, 0.18487380513927287, 0.18668609301784644, 0.18454501277684754, 0.1817696453445199, 0.1801338024177438, 0.07155617289002947, 0.07902451483597162, 0.07801777867482995, 0.07325130869619512, 0.07523069297581186, 0.0772123787015454, 0.07857773423967429, 0.08477147486122172, 0.08942246721873193]}, "mutation_prompt": null}
{"id": "b2d3a9e8-a51d-41c7-a52a-120f34a79caa", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F_min = 0.5\n        self.F_max = 0.9\n        self.CR_min = 0.6  # Dynamic crossover probability range\n        self.CR_max = 0.95\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: self.F_min + (self.F_max - self.F_min) * np.sin(np.pi * evals / (2 * self.budget))\n        self.dynamic_CR = lambda evals: self.CR_min + (self.CR_max - self.CR_min) * (1 - evals / self.budget)\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                current_CR = self.dynamic_CR(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant, current_CR)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant, CR):\n        crossover_mask = np.random.rand(self.dim) < CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "An improved version of DEALS with a dynamic crossover probability and enhanced local search mechanism to boost convergence speed while staying within a 5% code modification limit.", "configspace": "", "generation": 89, "fitness": 0.3690504894213491, "feedback": "The algorithm DEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.25.", "error": "", "parent_id": "14651833-3775-4889-a373-46486d0b368a", "metadata": {"aucs": [0.8072177098411975, 0.7834666287090714, 0.7908768461500566, 0.7956823008795382, 0.7954212020340727, 0.7910628132366413, 0.8147654448803912, 0.8074462182982158, 0.7681156440497368, 0.6255774576746127, 0.6268879688565325, 0.6520373185648095, 0.6688380825043543, 0.6204184442568597, 0.649104997803166, 0.6206761913539973, 0.6364544619740358, 0.6241133847737692, 0.1809869314662833, 0.1583113256738079, 0.11346749197770556, 0.19151306322027062, 0.12211820658266659, 0.18434293396502333, 0.16434960254739617, 0.13784555067240212, 0.1562389011211528, 0.1303101372656703, 0.11849911442259253, 0.12693312703727222, 0.13826095966197405, 0.12847939895799354, 0.17595232916256442, 0.13884719961581682, 0.2227666380684713, 0.13571645282524658, 0.907133921669853, 0.9187483604355153, 0.933110413673879, 0.8942447995168059, 0.934434119441, 0.9746712925862048, 0.9251374856127819, 0.9279559413459545, 0.9341458002261378, 0.48262022846628794, 0.4732625572210114, 0.4663959194891728, 0.4800142280034859, 0.44248662237034975, 0.44231026772810356, 0.48833039250505017, 0.5065349206890071, 0.4535601823450508, 0.7729057087478524, 0.6855910125190703, 0.7363411403423894, 0.7618336730029658, 0.7322042873238834, 0.7310776032660489, 0.7277054286946274, 0.7247667360617533, 0.7201069126793234, 0.32175448579300836, 0.3511530031948009, 0.25909356081124846, 0.2972258029390319, 0.23468868729209968, 0.290627299850574, 0.2979506980674711, 0.300536882333857, 0.2919844360821632, 0.3255240240998113, 0.2928935081104709, 0.29345701512683053, 0.29651470354672693, 0.2964847844764622, 0.29735147055753897, 0.2750411311721811, 0.3141608922037816, 0.2478344318646758, 0.2061247808333786, 0.2583810123492719, 0.26818358200107395, 0.2624332292931114, 0.2371101328322065, 0.21450865511522155, 0.24299781446333024, 0.2070929693613036, 0.23812406816303266, 0.3766068410629648, 0.4211444587841138, 0.33724265541056797, 0.41028247417183306, 0.3332413967667871, 0.3474338324969294, 0.36430569667723034, 0.4836704519797238, 0.38226395082089837, 0.028208878629915723, 0.058428778246565116, 0.05606139684460354, 0.08611908393322865, 0.09573906638652407, 0.09631938736699519, 0.07777360539827383, 0.10562921214039855, 0.13852238335188993, 0.2171577885118361, 0.22279278964989468, 0.20442827513137196, 0.25363035227541064, 0.2356694193427714, 0.24049794811993996, 0.21880065964405015, 0.225570435837672, 0.23795643073979544, 0.5882579805376651, 0.5944067805240135, 0.619612468077515, 0.5878890207474418, 0.6210948478120406, 0.5499506989726495, 0.5716205707240268, 0.6031161655240791, 0.5628905003320296, 0.09417147815928961, 0.09300502189338422, 0.11344674897460005, 0.09823184478757341, 0.10179850204998098, 0.11289979869965738, 0.09412442080532779, 0.09483323565616242, 0.09266922600692729, 0.1616904558057859, 0.17738139373262507, 0.20428925229708628, 0.17244090257821387, 0.18203013954525138, 0.21240716324852582, 0.19343859372111227, 0.24380262301875844, 0.1734212632334502, 0.36716671828280856, 0.37437056756316756, 0.3474658200957882, 0.35855839664171685, 0.36117471530940115, 0.3757894159962929, 0.4267065729932382, 0.40865945184399666, 0.409346867490313, 0.2786037252826241, 0.266251680869814, 0.27329549123935803, 0.2623475775952552, 0.24284493316559508, 0.2319248777809585, 0.27769163703142963, 0.27658617637912397, 0.2704041549314201, 0.20156472779737256, 0.21043948776601773, 0.20258975293324766, 0.19377056299130235, 0.18964897880938436, 0.18949962490955452, 0.204098595354963, 0.19223981423301462, 0.1940475024357483, 0.19351116282136216, 0.19593250976437626, 0.20624408764222535, 0.18805029733676026, 0.21188266415256518, 0.20138734015557413, 0.25671031043102077, 0.20355173291416073, 0.3578612834679038, 0.8025183761161618, 0.7853212079629948, 0.8165758638724019, 0.7375017664257544, 0.1974802838995544, 0.6579983039909483, 0.7497530256673415, 0.7449270303614572, 0.7301135311453253, 0.6879591627356538, 0.21108441768684905, 0.6852561314506234, 0.595713099479642, 0.6706326464377976, 0.6382746565130721, 0.6673585021273489, 0.20837500621213312, 0.7463351429763219, 0.17875390553428805, 0.18366481617085306, 0.1844426117196376, 0.2005990023298565, 0.1813129610660862, 0.19252956003081723, 0.18334812796037336, 0.2007043590292581, 0.20081196169055304, 0.07570505125460603, 0.0739650783481447, 0.08357411732699749, 0.0773880105973993, 0.07719946917953346, 0.07513877193739771, 0.07820036658856189, 0.07786206230779569, 0.08392386529805995]}, "mutation_prompt": null}
{"id": "d0e697f8-33f6-40f9-9132-5beb3e12f4e8", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F_min = 0.5\n        self.F_max = 0.9\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: self.F_min + (self.F_max - self.F_min) * np.sin(np.pi * evals / (2 * self.budget))\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring dynamic mutation factors for enhanced convergence speed.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "14651833-3775-4889-a373-46486d0b368a", "metadata": {"aucs": [0.7968801489948274, 0.7857497924017587, 0.7930328545470777, 0.7914670047123273, 0.8023822238935016, 0.8109194771862845, 0.800164806998958, 0.817803200297867, 0.7870132232830508, 0.6216307169653656, 0.6310550899106175, 0.6185505089884191, 0.6313678290375803, 0.6213181784600736, 0.6096564997091771, 0.6297841861499857, 0.6207330176311852, 0.5931058184961518, 0.13737654245243613, 0.12566714026964232, 0.1323614882800892, 0.15243616969966656, 0.13647791516802266, 0.12230712883238015, 0.11664204857317162, 0.10768905512354976, 0.11664567084069022, 0.10784737916717935, 0.10739655010257287, 0.11874664006138591, 0.11910921784580186, 0.09143043726144406, 0.11274734910169304, 0.15174149395845238, 0.10834452291541097, 0.11973330592501663, 0.9096515280251296, 0.9183820322978025, 0.9495766660581665, 0.913165975605537, 0.9071735649436963, 0.9742419185151416, 0.9554495952410039, 0.9577221069478945, 0.9339532000363818, 0.4948587276718043, 0.4912386491947567, 0.49171309659023077, 0.46530489784880624, 0.4934932895349048, 0.4949316352588573, 0.4829406382289163, 0.5182233521159227, 0.47568118628136224, 0.7117668763266587, 0.7340625175351826, 0.7433994019965051, 0.8023638858124337, 0.7190853253609248, 0.7623176440052908, 0.7939579330401683, 0.7906651634599782, 0.7236487124153514, 0.3730231263477255, 0.49082441917973707, 0.4623422724469112, 0.35929913761048304, 0.40103892398486873, 0.4092785895373692, 0.39520382427794143, 0.430617315906472, 0.41580561422114226, 0.36753347796792646, 0.3750264212737079, 0.3992107458674461, 0.466457131992021, 0.33824053597553283, 0.3484331405261333, 0.4622107427895388, 0.3758862649125817, 0.2801304539465099, 0.3332805760225239, 0.4192409133125341, 0.3343879556072872, 0.32925116693639744, 0.41137277102632663, 0.3102673764572109, 0.3940592140626512, 0.37311340492507294, 0.3707269942090258, 0.48097457640495245, 0.5390931009803086, 0.48682253515143825, 0.5362483944519797, 0.4819595570358778, 0.4627653023451026, 0.5836428255038342, 0.534601601122068, 0.5352783035821425, 0.08866524732393466, 0.17506990020357238, 0.18534281864119795, 0.2304426565033093, 0.19827125080973584, 0.11051004148679766, 0.1550693837149658, 0.11420866074474978, 0.1306895525641979, 0.28959801324507706, 0.29908892847302593, 0.2918800890901775, 0.3024327008260529, 0.3117848649635395, 0.3253268980581727, 0.3130051555574781, 0.3076676499890503, 0.31571497213032107, 0.6697855778139568, 0.6936969533890074, 0.6854895481878877, 0.7119366061329894, 0.697375012028574, 0.6748624123489337, 0.6845304842801586, 0.6790533693952605, 0.6734280992634145, 0.09940890594684282, 0.09343834904036197, 0.09330127195203008, 0.08333612694261372, 0.08919765893650311, 0.0876218867601819, 0.10439273861051934, 0.1001489326751851, 0.13660297936284738, 0.21811148677381742, 0.17476641618692246, 0.18943278927380602, 0.24040655086747298, 0.20150416695879714, 0.17681436174290788, 0.21067518506773963, 0.1381594299726132, 0.18303364543391676, 0.3679811763375812, 0.41510750779204586, 0.36695104387760213, 0.38799332908600104, 0.35407170205609473, 0.3947860441300203, 0.3895040994176343, 0.41279359636579604, 0.4078647130978882, 0.30559786019727375, 0.28829009583079757, 0.29131941133234074, 0.28117078634894854, 0.2937930756440188, 0.24762979074399116, 0.2920349921190002, 0.3073228753477335, 0.2724593879656705, 0.19709407127287693, 0.18783462505853676, 0.19942130678289982, 0.20304980720028265, 0.2009527529496855, 0.19493476431707102, 0.2078583972640059, 0.24994656170849805, 0.21465590785967925, 0.2271264099898871, 0.22439399023436513, 0.21443620353130355, 0.22119584596264152, 0.25084873443448663, 0.25491823871306274, 0.2139619204484835, 0.24634015177959379, 0.40924332108316874, 0.7574758399316956, 0.7727242628973505, 0.6601891228251205, 0.7936803247603185, 0.6771778238998505, 0.7454137703686081, 0.7474043847396739, 0.5972912148934852, 0.17982048541720363, 0.7037337623192819, 0.21118439612864892, 0.20323176479608118, 0.6297568416840995, 0.20485685093579142, 0.659103604663279, 0.2064461438875661, 0.7171654688005993, 0.20733309182972692, 0.17814054595856577, 0.19554209835120773, 0.20708982435329437, 0.18363440895001537, 0.18487380513927287, 0.18668609301784644, 0.18454501277684754, 0.1817696453445199, 0.1801338024177438, 0.07155617289002947, 0.07902451483597162, 0.07801777867482995, 0.07325130869619512, 0.07523069297581186, 0.0772123787015454, 0.07857773423967429, 0.08477147486122172, 0.08942246721873193]}, "mutation_prompt": null}
{"id": "e590f72e-76ee-4844-8a36-75245eed1808", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F_min = 0.5\n        self.F_max = 0.9\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: self.F_min + (self.F_max - self.F_min) * np.sin(np.pi * evals / (2 * self.budget))\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring dynamic mutation factors for enhanced convergence speed.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "14651833-3775-4889-a373-46486d0b368a", "metadata": {"aucs": [0.7968801489948274, 0.7857497924017587, 0.7930328545470777, 0.7914670047123273, 0.8023822238935016, 0.8109194771862845, 0.800164806998958, 0.817803200297867, 0.7870132232830508, 0.6216307169653656, 0.6310550899106175, 0.6185505089884191, 0.6313678290375803, 0.6213181784600736, 0.6096564997091771, 0.6297841861499857, 0.6207330176311852, 0.5931058184961518, 0.13737654245243613, 0.12566714026964232, 0.1323614882800892, 0.15243616969966656, 0.13647791516802266, 0.12230712883238015, 0.11664204857317162, 0.10768905512354976, 0.11664567084069022, 0.10784737916717935, 0.10739655010257287, 0.11874664006138591, 0.11910921784580186, 0.09143043726144406, 0.11274734910169304, 0.15174149395845238, 0.10834452291541097, 0.11973330592501663, 0.9096515280251296, 0.9183820322978025, 0.9495766660581665, 0.913165975605537, 0.9071735649436963, 0.9742419185151416, 0.9554495952410039, 0.9577221069478945, 0.9339532000363818, 0.4948587276718043, 0.4912386491947567, 0.49171309659023077, 0.46530489784880624, 0.4934932895349048, 0.4949316352588573, 0.4829406382289163, 0.5182233521159227, 0.47568118628136224, 0.7117668763266587, 0.7340625175351826, 0.7433994019965051, 0.8023638858124337, 0.7190853253609248, 0.7623176440052908, 0.7939579330401683, 0.7906651634599782, 0.7236487124153514, 0.3730231263477255, 0.49082441917973707, 0.4623422724469112, 0.35929913761048304, 0.40103892398486873, 0.4092785895373692, 0.39520382427794143, 0.430617315906472, 0.41580561422114226, 0.36753347796792646, 0.3750264212737079, 0.3992107458674461, 0.466457131992021, 0.33824053597553283, 0.3484331405261333, 0.4622107427895388, 0.3758862649125817, 0.2801304539465099, 0.3332805760225239, 0.4192409133125341, 0.3343879556072872, 0.32925116693639744, 0.41137277102632663, 0.3102673764572109, 0.3940592140626512, 0.37311340492507294, 0.3707269942090258, 0.48097457640495245, 0.5390931009803086, 0.48682253515143825, 0.5362483944519797, 0.4819595570358778, 0.4627653023451026, 0.5836428255038342, 0.534601601122068, 0.5352783035821425, 0.08866524732393466, 0.17506990020357238, 0.18534281864119795, 0.2304426565033093, 0.19827125080973584, 0.11051004148679766, 0.1550693837149658, 0.11420866074474978, 0.1306895525641979, 0.28959801324507706, 0.29908892847302593, 0.2918800890901775, 0.3024327008260529, 0.3117848649635395, 0.3253268980581727, 0.3130051555574781, 0.3076676499890503, 0.31571497213032107, 0.6697855778139568, 0.6936969533890074, 0.6854895481878877, 0.7119366061329894, 0.697375012028574, 0.6748624123489337, 0.6845304842801586, 0.6790533693952605, 0.6734280992634145, 0.09940890594684282, 0.09343834904036197, 0.09330127195203008, 0.08333612694261372, 0.08919765893650311, 0.0876218867601819, 0.10439273861051934, 0.1001489326751851, 0.13660297936284738, 0.21811148677381742, 0.17476641618692246, 0.18943278927380602, 0.24040655086747298, 0.20150416695879714, 0.17681436174290788, 0.21067518506773963, 0.1381594299726132, 0.18303364543391676, 0.3679811763375812, 0.41510750779204586, 0.36695104387760213, 0.38799332908600104, 0.35407170205609473, 0.3947860441300203, 0.3895040994176343, 0.41279359636579604, 0.4078647130978882, 0.30559786019727375, 0.28829009583079757, 0.29131941133234074, 0.28117078634894854, 0.2937930756440188, 0.24762979074399116, 0.2920349921190002, 0.3073228753477335, 0.2724593879656705, 0.19709407127287693, 0.18783462505853676, 0.19942130678289982, 0.20304980720028265, 0.2009527529496855, 0.19493476431707102, 0.2078583972640059, 0.24994656170849805, 0.21465590785967925, 0.2271264099898871, 0.22439399023436513, 0.21443620353130355, 0.22119584596264152, 0.25084873443448663, 0.25491823871306274, 0.2139619204484835, 0.24634015177959379, 0.40924332108316874, 0.7574758399316956, 0.7727242628973505, 0.6601891228251205, 0.7936803247603185, 0.6771778238998505, 0.7454137703686081, 0.7474043847396739, 0.5972912148934852, 0.17982048541720363, 0.7037337623192819, 0.21118439612864892, 0.20323176479608118, 0.6297568416840995, 0.20485685093579142, 0.659103604663279, 0.2064461438875661, 0.7171654688005993, 0.20733309182972692, 0.17814054595856577, 0.19554209835120773, 0.20708982435329437, 0.18363440895001537, 0.18487380513927287, 0.18668609301784644, 0.18454501277684754, 0.1817696453445199, 0.1801338024177438, 0.07155617289002947, 0.07902451483597162, 0.07801777867482995, 0.07325130869619512, 0.07523069297581186, 0.0772123787015454, 0.07857773423967429, 0.08477147486122172, 0.08942246721873193]}, "mutation_prompt": null}
{"id": "26c248f0-25a3-4fc2-b85d-e7191307bf8f", "solution": "# Description: Improved the DEALS algorithm by enhancing mutation strategy and increasing local search steps for better convergence speed.\n# Code:\nimport numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F_min = 0.6\n        self.F_max = 0.95\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: self.F_min + (self.F_max - self.F_min) * np.sin(np.pi * evals / (2 * self.budget))\n\n    def __call__(self, func):\n        eval_count = 0\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.04\n        for _ in range(10):\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "Improved the DEALS algorithm by enhancing mutation strategy and increasing local search steps for better convergence speed.", "configspace": "", "generation": 92, "fitness": 0.32573371885021324, "feedback": "The algorithm DEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.23.", "error": "", "parent_id": "14651833-3775-4889-a373-46486d0b368a", "metadata": {"aucs": [0.7130244731525012, 0.7237825706322141, 0.7113451580653017, 0.720259172904415, 0.7404831909489311, 0.7180733304069202, 0.736907978274036, 0.7278133515576515, 0.7274230662986552, 0.5009856192389874, 0.5187639345325914, 0.501650083087398, 0.5146903942571828, 0.4883896304726091, 0.48454158883178466, 0.5149751917519985, 0.49899278278344095, 0.5391282393159353, 0.10273109436141803, 0.10228507634021278, 0.10892245761203267, 0.12169981748409153, 0.09750191750017967, 0.11971113257453403, 0.09428926026427731, 0.10426145298070733, 0.10369800746252456, 0.09258142665623237, 0.0956245487081584, 0.10759128236964477, 0.10827969579012164, 0.09127873252825047, 0.10134631956507456, 0.11552302081841281, 0.09334222379201351, 0.10334911302527838, 0.9471162593474768, 0.9347235979876601, 0.9274428798824745, 0.9402105529593703, 0.9480797267205091, 0.9646282067905216, 0.9106308196423262, 0.9366059720705281, 0.9519217796345467, 0.3489559260355578, 0.3704248177979923, 0.36819581803628953, 0.3677371024022026, 0.36954407390564015, 0.4044817947231898, 0.38734489300218555, 0.40355294054231805, 0.3806662176406638, 0.634210596108165, 0.6664815041899248, 0.6694320327006277, 0.6963379057449728, 0.7116373710477957, 0.7016736796328957, 0.6366567454333405, 0.5678530814841259, 0.6599740980374542, 0.32606224889964897, 0.28908735246260486, 0.29182891670660716, 0.3094984242865534, 0.2767106306927375, 0.3128132280753535, 0.3296861771269649, 0.27911083282769933, 0.27896319429275096, 0.22227148533126184, 0.21965537751919895, 0.2567007858334046, 0.30345867714304264, 0.28164005897953803, 0.2820016666134818, 0.2736490168673351, 0.2626582061120061, 0.28185439357193476, 0.2288491850813147, 0.2198137340346561, 0.2590304294602852, 0.16212508906082224, 0.20414877505276097, 0.1866327357927433, 0.19641489215956576, 0.17660430470773159, 0.21175275436008378, 0.3453333645812169, 0.3357549527845901, 0.3492934024714114, 0.3635195938731798, 0.31491740612429564, 0.33977830984594015, 0.35283222504888034, 0.38622147275006313, 0.3378139940823778, 0.05184953954522076, 0.06221940693489125, 0.049494825886589044, 0.10757583843848606, 0.09818399544780843, 0.09460754823572737, 0.11532211656374491, 0.08136858354190024, 0.07440594494257857, 0.2201556034055865, 0.20818340341709596, 0.21689525788663955, 0.22800599882974093, 0.22189974762675924, 0.2261023333167823, 0.20217270895909045, 0.20280042937927545, 0.18864443661971497, 0.6014662036147455, 0.5429048177724791, 0.5619944033440931, 0.5969165152163785, 0.609525468535132, 0.6025265965263372, 0.5502986945892001, 0.5600555005575926, 0.5700644556154457, 0.11298902015217427, 0.09524550864670944, 0.09014371073512362, 0.09576829710815893, 0.09323965962417247, 0.09205324285777683, 0.08589784875447859, 0.08968971765470801, 0.10034535291652646, 0.15035126953035594, 0.18638465888125166, 0.19890957420673794, 0.18510471160398112, 0.22878840997957128, 0.19918134491296613, 0.1867144798844249, 0.22446263632669328, 0.15857795650964213, 0.32953327692403744, 0.3229538635529383, 0.30487822900235295, 0.30824376889497307, 0.3215022775935952, 0.30977943129276286, 0.3547823650582307, 0.3528750547417361, 0.2907118594931295, 0.24392222405384822, 0.24477177819439166, 0.23982996169089232, 0.2157931535648684, 0.24385366668313202, 0.2458776649836789, 0.27139520046451815, 0.2185161017443349, 0.2621046993408025, 0.19090652614789483, 0.19822235484168116, 0.18853682095028435, 0.20253304433934194, 0.2280804252218397, 0.22629191033412444, 0.2028548958631995, 0.19542798238673043, 0.21667084855276197, 0.1904760600960843, 0.18994882281535452, 0.1954448338767002, 0.20729924356621665, 0.185096380276636, 0.20350006780419816, 0.19648157391359333, 0.20609243999193994, 0.18246298840675512, 0.6893711413445657, 0.20369129739777914, 0.674815403639444, 0.4912315311755382, 0.43785603343634383, 0.46601263039915497, 0.5627594884173119, 0.6216910936050551, 0.7159713754518839, 0.6683769033827368, 0.21161136203511233, 0.2059788214304229, 0.16799051787184327, 0.6143316585716896, 0.19566819217617581, 0.20641624907803857, 0.6808434233737992, 0.20407235288387515, 0.17645952604466442, 0.17934190500259806, 0.1994459534598061, 0.180626829343427, 0.1911941089045861, 0.1936418469201341, 0.1885601640578244, 0.1825642004360244, 0.19773488095984826, 0.1024120011667552, 0.0746319538590624, 0.06926727560658252, 0.07662793678020863, 0.08033409196449615, 0.07937809528294115, 0.08296350462668955, 0.0813251992439884, 0.09589072616107419]}, "mutation_prompt": null}
{"id": "83d3cbbc-77f6-4a56-ac3d-149e77b1e253", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F_min = 0.5\n        self.F_max = 0.9\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: self.F_min + (self.F_max - self.F_min) * np.sin(np.pi * evals / (2 * self.budget))\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring dynamic mutation factors for enhanced convergence speed.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "14651833-3775-4889-a373-46486d0b368a", "metadata": {"aucs": [0.7968801489948274, 0.7857497924017587, 0.7930328545470777, 0.7914670047123273, 0.8023822238935016, 0.8109194771862845, 0.800164806998958, 0.817803200297867, 0.7870132232830508, 0.6216307169653656, 0.6310550899106175, 0.6185505089884191, 0.6313678290375803, 0.6213181784600736, 0.6096564997091771, 0.6297841861499857, 0.6207330176311852, 0.5931058184961518, 0.13737654245243613, 0.12566714026964232, 0.1323614882800892, 0.15243616969966656, 0.13647791516802266, 0.12230712883238015, 0.11664204857317162, 0.10768905512354976, 0.11664567084069022, 0.10784737916717935, 0.10739655010257287, 0.11874664006138591, 0.11910921784580186, 0.09143043726144406, 0.11274734910169304, 0.15174149395845238, 0.10834452291541097, 0.11973330592501663, 0.9096515280251296, 0.9183820322978025, 0.9495766660581665, 0.913165975605537, 0.9071735649436963, 0.9742419185151416, 0.9554495952410039, 0.9577221069478945, 0.9339532000363818, 0.4948587276718043, 0.4912386491947567, 0.49171309659023077, 0.46530489784880624, 0.4934932895349048, 0.4949316352588573, 0.4829406382289163, 0.5182233521159227, 0.47568118628136224, 0.7117668763266587, 0.7340625175351826, 0.7433994019965051, 0.8023638858124337, 0.7190853253609248, 0.7623176440052908, 0.7939579330401683, 0.7906651634599782, 0.7236487124153514, 0.3730231263477255, 0.49082441917973707, 0.4623422724469112, 0.35929913761048304, 0.40103892398486873, 0.4092785895373692, 0.39520382427794143, 0.430617315906472, 0.41580561422114226, 0.36753347796792646, 0.3750264212737079, 0.3992107458674461, 0.466457131992021, 0.33824053597553283, 0.3484331405261333, 0.4622107427895388, 0.3758862649125817, 0.2801304539465099, 0.3332805760225239, 0.4192409133125341, 0.3343879556072872, 0.32925116693639744, 0.41137277102632663, 0.3102673764572109, 0.3940592140626512, 0.37311340492507294, 0.3707269942090258, 0.48097457640495245, 0.5390931009803086, 0.48682253515143825, 0.5362483944519797, 0.4819595570358778, 0.4627653023451026, 0.5836428255038342, 0.534601601122068, 0.5352783035821425, 0.08866524732393466, 0.17506990020357238, 0.18534281864119795, 0.2304426565033093, 0.19827125080973584, 0.11051004148679766, 0.1550693837149658, 0.11420866074474978, 0.1306895525641979, 0.28959801324507706, 0.29908892847302593, 0.2918800890901775, 0.3024327008260529, 0.3117848649635395, 0.3253268980581727, 0.3130051555574781, 0.3076676499890503, 0.31571497213032107, 0.6697855778139568, 0.6936969533890074, 0.6854895481878877, 0.7119366061329894, 0.697375012028574, 0.6748624123489337, 0.6845304842801586, 0.6790533693952605, 0.6734280992634145, 0.09940890594684282, 0.09343834904036197, 0.09330127195203008, 0.08333612694261372, 0.08919765893650311, 0.0876218867601819, 0.10439273861051934, 0.1001489326751851, 0.13660297936284738, 0.21811148677381742, 0.17476641618692246, 0.18943278927380602, 0.24040655086747298, 0.20150416695879714, 0.17681436174290788, 0.21067518506773963, 0.1381594299726132, 0.18303364543391676, 0.3679811763375812, 0.41510750779204586, 0.36695104387760213, 0.38799332908600104, 0.35407170205609473, 0.3947860441300203, 0.3895040994176343, 0.41279359636579604, 0.4078647130978882, 0.30559786019727375, 0.28829009583079757, 0.29131941133234074, 0.28117078634894854, 0.2937930756440188, 0.24762979074399116, 0.2920349921190002, 0.3073228753477335, 0.2724593879656705, 0.19709407127287693, 0.18783462505853676, 0.19942130678289982, 0.20304980720028265, 0.2009527529496855, 0.19493476431707102, 0.2078583972640059, 0.24994656170849805, 0.21465590785967925, 0.2271264099898871, 0.22439399023436513, 0.21443620353130355, 0.22119584596264152, 0.25084873443448663, 0.25491823871306274, 0.2139619204484835, 0.24634015177959379, 0.40924332108316874, 0.7574758399316956, 0.7727242628973505, 0.6601891228251205, 0.7936803247603185, 0.6771778238998505, 0.7454137703686081, 0.7474043847396739, 0.5972912148934852, 0.17982048541720363, 0.7037337623192819, 0.21118439612864892, 0.20323176479608118, 0.6297568416840995, 0.20485685093579142, 0.659103604663279, 0.2064461438875661, 0.7171654688005993, 0.20733309182972692, 0.17814054595856577, 0.19554209835120773, 0.20708982435329437, 0.18363440895001537, 0.18487380513927287, 0.18668609301784644, 0.18454501277684754, 0.1817696453445199, 0.1801338024177438, 0.07155617289002947, 0.07902451483597162, 0.07801777867482995, 0.07325130869619512, 0.07523069297581186, 0.0772123787015454, 0.07857773423967429, 0.08477147486122172, 0.08942246721873193]}, "mutation_prompt": null}
{"id": "81dae77c-d933-4ee2-ba26-a9371568b8f8", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F_min = 0.5\n        self.F_max = 0.9\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: self.F_min + (self.F_max - self.F_min) * np.sin(np.pi * evals / (2 * self.budget))\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring dynamic mutation factors for enhanced convergence speed.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "14651833-3775-4889-a373-46486d0b368a", "metadata": {"aucs": [0.7968801489948274, 0.7857497924017587, 0.7930328545470777, 0.7914670047123273, 0.8023822238935016, 0.8109194771862845, 0.800164806998958, 0.817803200297867, 0.7870132232830508, 0.6216307169653656, 0.6310550899106175, 0.6185505089884191, 0.6313678290375803, 0.6213181784600736, 0.6096564997091771, 0.6297841861499857, 0.6207330176311852, 0.5931058184961518, 0.13737654245243613, 0.12566714026964232, 0.1323614882800892, 0.15243616969966656, 0.13647791516802266, 0.12230712883238015, 0.11664204857317162, 0.10768905512354976, 0.11664567084069022, 0.10784737916717935, 0.10739655010257287, 0.11874664006138591, 0.11910921784580186, 0.09143043726144406, 0.11274734910169304, 0.15174149395845238, 0.10834452291541097, 0.11973330592501663, 0.9096515280251296, 0.9183820322978025, 0.9495766660581665, 0.913165975605537, 0.9071735649436963, 0.9742419185151416, 0.9554495952410039, 0.9577221069478945, 0.9339532000363818, 0.4948587276718043, 0.4912386491947567, 0.49171309659023077, 0.46530489784880624, 0.4934932895349048, 0.4949316352588573, 0.4829406382289163, 0.5182233521159227, 0.47568118628136224, 0.7117668763266587, 0.7340625175351826, 0.7433994019965051, 0.8023638858124337, 0.7190853253609248, 0.7623176440052908, 0.7939579330401683, 0.7906651634599782, 0.7236487124153514, 0.3730231263477255, 0.49082441917973707, 0.4623422724469112, 0.35929913761048304, 0.40103892398486873, 0.4092785895373692, 0.39520382427794143, 0.430617315906472, 0.41580561422114226, 0.36753347796792646, 0.3750264212737079, 0.3992107458674461, 0.466457131992021, 0.33824053597553283, 0.3484331405261333, 0.4622107427895388, 0.3758862649125817, 0.2801304539465099, 0.3332805760225239, 0.4192409133125341, 0.3343879556072872, 0.32925116693639744, 0.41137277102632663, 0.3102673764572109, 0.3940592140626512, 0.37311340492507294, 0.3707269942090258, 0.48097457640495245, 0.5390931009803086, 0.48682253515143825, 0.5362483944519797, 0.4819595570358778, 0.4627653023451026, 0.5836428255038342, 0.534601601122068, 0.5352783035821425, 0.08866524732393466, 0.17506990020357238, 0.18534281864119795, 0.2304426565033093, 0.19827125080973584, 0.11051004148679766, 0.1550693837149658, 0.11420866074474978, 0.1306895525641979, 0.28959801324507706, 0.29908892847302593, 0.2918800890901775, 0.3024327008260529, 0.3117848649635395, 0.3253268980581727, 0.3130051555574781, 0.3076676499890503, 0.31571497213032107, 0.6697855778139568, 0.6936969533890074, 0.6854895481878877, 0.7119366061329894, 0.697375012028574, 0.6748624123489337, 0.6845304842801586, 0.6790533693952605, 0.6734280992634145, 0.09940890594684282, 0.09343834904036197, 0.09330127195203008, 0.08333612694261372, 0.08919765893650311, 0.0876218867601819, 0.10439273861051934, 0.1001489326751851, 0.13660297936284738, 0.21811148677381742, 0.17476641618692246, 0.18943278927380602, 0.24040655086747298, 0.20150416695879714, 0.17681436174290788, 0.21067518506773963, 0.1381594299726132, 0.18303364543391676, 0.3679811763375812, 0.41510750779204586, 0.36695104387760213, 0.38799332908600104, 0.35407170205609473, 0.3947860441300203, 0.3895040994176343, 0.41279359636579604, 0.4078647130978882, 0.30559786019727375, 0.28829009583079757, 0.29131941133234074, 0.28117078634894854, 0.2937930756440188, 0.24762979074399116, 0.2920349921190002, 0.3073228753477335, 0.2724593879656705, 0.19709407127287693, 0.18783462505853676, 0.19942130678289982, 0.20304980720028265, 0.2009527529496855, 0.19493476431707102, 0.2078583972640059, 0.24994656170849805, 0.21465590785967925, 0.2271264099898871, 0.22439399023436513, 0.21443620353130355, 0.22119584596264152, 0.25084873443448663, 0.25491823871306274, 0.2139619204484835, 0.24634015177959379, 0.40924332108316874, 0.7574758399316956, 0.7727242628973505, 0.6601891228251205, 0.7936803247603185, 0.6771778238998505, 0.7454137703686081, 0.7474043847396739, 0.5972912148934852, 0.17982048541720363, 0.7037337623192819, 0.21118439612864892, 0.20323176479608118, 0.6297568416840995, 0.20485685093579142, 0.659103604663279, 0.2064461438875661, 0.7171654688005993, 0.20733309182972692, 0.17814054595856577, 0.19554209835120773, 0.20708982435329437, 0.18363440895001537, 0.18487380513927287, 0.18668609301784644, 0.18454501277684754, 0.1817696453445199, 0.1801338024177438, 0.07155617289002947, 0.07902451483597162, 0.07801777867482995, 0.07325130869619512, 0.07523069297581186, 0.0772123787015454, 0.07857773423967429, 0.08477147486122172, 0.08942246721873193]}, "mutation_prompt": null}
{"id": "6e0804a3-2e82-4308-9b51-533eae45c46c", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F_min = 0.5\n        self.F_max = 0.9\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: self.F_min + (self.F_max - self.F_min) * np.sin(np.pi * evals / (2 * self.budget))\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring dynamic mutation factors for enhanced convergence speed.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "14651833-3775-4889-a373-46486d0b368a", "metadata": {"aucs": [0.7968801489948274, 0.7857497924017587, 0.7930328545470777, 0.7914670047123273, 0.8023822238935016, 0.8109194771862845, 0.800164806998958, 0.817803200297867, 0.7870132232830508, 0.6216307169653656, 0.6310550899106175, 0.6185505089884191, 0.6313678290375803, 0.6213181784600736, 0.6096564997091771, 0.6297841861499857, 0.6207330176311852, 0.5931058184961518, 0.13737654245243613, 0.12566714026964232, 0.1323614882800892, 0.15243616969966656, 0.13647791516802266, 0.12230712883238015, 0.11664204857317162, 0.10768905512354976, 0.11664567084069022, 0.10784737916717935, 0.10739655010257287, 0.11874664006138591, 0.11910921784580186, 0.09143043726144406, 0.11274734910169304, 0.15174149395845238, 0.10834452291541097, 0.11973330592501663, 0.9096515280251296, 0.9183820322978025, 0.9495766660581665, 0.913165975605537, 0.9071735649436963, 0.9742419185151416, 0.9554495952410039, 0.9577221069478945, 0.9339532000363818, 0.4948587276718043, 0.4912386491947567, 0.49171309659023077, 0.46530489784880624, 0.4934932895349048, 0.4949316352588573, 0.4829406382289163, 0.5182233521159227, 0.47568118628136224, 0.7117668763266587, 0.7340625175351826, 0.7433994019965051, 0.8023638858124337, 0.7190853253609248, 0.7623176440052908, 0.7939579330401683, 0.7906651634599782, 0.7236487124153514, 0.3730231263477255, 0.49082441917973707, 0.4623422724469112, 0.35929913761048304, 0.40103892398486873, 0.4092785895373692, 0.39520382427794143, 0.430617315906472, 0.41580561422114226, 0.36753347796792646, 0.3750264212737079, 0.3992107458674461, 0.466457131992021, 0.33824053597553283, 0.3484331405261333, 0.4622107427895388, 0.3758862649125817, 0.2801304539465099, 0.3332805760225239, 0.4192409133125341, 0.3343879556072872, 0.32925116693639744, 0.41137277102632663, 0.3102673764572109, 0.3940592140626512, 0.37311340492507294, 0.3707269942090258, 0.48097457640495245, 0.5390931009803086, 0.48682253515143825, 0.5362483944519797, 0.4819595570358778, 0.4627653023451026, 0.5836428255038342, 0.534601601122068, 0.5352783035821425, 0.08866524732393466, 0.17506990020357238, 0.18534281864119795, 0.2304426565033093, 0.19827125080973584, 0.11051004148679766, 0.1550693837149658, 0.11420866074474978, 0.1306895525641979, 0.28959801324507706, 0.29908892847302593, 0.2918800890901775, 0.3024327008260529, 0.3117848649635395, 0.3253268980581727, 0.3130051555574781, 0.3076676499890503, 0.31571497213032107, 0.6697855778139568, 0.6936969533890074, 0.6854895481878877, 0.7119366061329894, 0.697375012028574, 0.6748624123489337, 0.6845304842801586, 0.6790533693952605, 0.6734280992634145, 0.09940890594684282, 0.09343834904036197, 0.09330127195203008, 0.08333612694261372, 0.08919765893650311, 0.0876218867601819, 0.10439273861051934, 0.1001489326751851, 0.13660297936284738, 0.21811148677381742, 0.17476641618692246, 0.18943278927380602, 0.24040655086747298, 0.20150416695879714, 0.17681436174290788, 0.21067518506773963, 0.1381594299726132, 0.18303364543391676, 0.3679811763375812, 0.41510750779204586, 0.36695104387760213, 0.38799332908600104, 0.35407170205609473, 0.3947860441300203, 0.3895040994176343, 0.41279359636579604, 0.4078647130978882, 0.30559786019727375, 0.28829009583079757, 0.29131941133234074, 0.28117078634894854, 0.2937930756440188, 0.24762979074399116, 0.2920349921190002, 0.3073228753477335, 0.2724593879656705, 0.19709407127287693, 0.18783462505853676, 0.19942130678289982, 0.20304980720028265, 0.2009527529496855, 0.19493476431707102, 0.2078583972640059, 0.24994656170849805, 0.21465590785967925, 0.2271264099898871, 0.22439399023436513, 0.21443620353130355, 0.22119584596264152, 0.25084873443448663, 0.25491823871306274, 0.2139619204484835, 0.24634015177959379, 0.40924332108316874, 0.7574758399316956, 0.7727242628973505, 0.6601891228251205, 0.7936803247603185, 0.6771778238998505, 0.7454137703686081, 0.7474043847396739, 0.5972912148934852, 0.17982048541720363, 0.7037337623192819, 0.21118439612864892, 0.20323176479608118, 0.6297568416840995, 0.20485685093579142, 0.659103604663279, 0.2064461438875661, 0.7171654688005993, 0.20733309182972692, 0.17814054595856577, 0.19554209835120773, 0.20708982435329437, 0.18363440895001537, 0.18487380513927287, 0.18668609301784644, 0.18454501277684754, 0.1817696453445199, 0.1801338024177438, 0.07155617289002947, 0.07902451483597162, 0.07801777867482995, 0.07325130869619512, 0.07523069297581186, 0.0772123787015454, 0.07857773423967429, 0.08477147486122172, 0.08942246721873193]}, "mutation_prompt": null}
{"id": "ca00cce5-8747-4985-9199-901695402492", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F_min = 0.5\n        self.F_max = 0.9\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: self.F_min + (self.F_max - self.F_min) * np.sin(np.pi * evals / (2 * self.budget))\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring dynamic mutation factors for enhanced convergence speed.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "14651833-3775-4889-a373-46486d0b368a", "metadata": {"aucs": [0.7968801489948274, 0.7857497924017587, 0.7930328545470777, 0.7914670047123273, 0.8023822238935016, 0.8109194771862845, 0.800164806998958, 0.817803200297867, 0.7870132232830508, 0.6216307169653656, 0.6310550899106175, 0.6185505089884191, 0.6313678290375803, 0.6213181784600736, 0.6096564997091771, 0.6297841861499857, 0.6207330176311852, 0.5931058184961518, 0.13737654245243613, 0.12566714026964232, 0.1323614882800892, 0.15243616969966656, 0.13647791516802266, 0.12230712883238015, 0.11664204857317162, 0.10768905512354976, 0.11664567084069022, 0.10784737916717935, 0.10739655010257287, 0.11874664006138591, 0.11910921784580186, 0.09143043726144406, 0.11274734910169304, 0.15174149395845238, 0.10834452291541097, 0.11973330592501663, 0.9096515280251296, 0.9183820322978025, 0.9495766660581665, 0.913165975605537, 0.9071735649436963, 0.9742419185151416, 0.9554495952410039, 0.9577221069478945, 0.9339532000363818, 0.4948587276718043, 0.4912386491947567, 0.49171309659023077, 0.46530489784880624, 0.4934932895349048, 0.4949316352588573, 0.4829406382289163, 0.5182233521159227, 0.47568118628136224, 0.7117668763266587, 0.7340625175351826, 0.7433994019965051, 0.8023638858124337, 0.7190853253609248, 0.7623176440052908, 0.7939579330401683, 0.7906651634599782, 0.7236487124153514, 0.3730231263477255, 0.49082441917973707, 0.4623422724469112, 0.35929913761048304, 0.40103892398486873, 0.4092785895373692, 0.39520382427794143, 0.430617315906472, 0.41580561422114226, 0.36753347796792646, 0.3750264212737079, 0.3992107458674461, 0.466457131992021, 0.33824053597553283, 0.3484331405261333, 0.4622107427895388, 0.3758862649125817, 0.2801304539465099, 0.3332805760225239, 0.4192409133125341, 0.3343879556072872, 0.32925116693639744, 0.41137277102632663, 0.3102673764572109, 0.3940592140626512, 0.37311340492507294, 0.3707269942090258, 0.48097457640495245, 0.5390931009803086, 0.48682253515143825, 0.5362483944519797, 0.4819595570358778, 0.4627653023451026, 0.5836428255038342, 0.534601601122068, 0.5352783035821425, 0.08866524732393466, 0.17506990020357238, 0.18534281864119795, 0.2304426565033093, 0.19827125080973584, 0.11051004148679766, 0.1550693837149658, 0.11420866074474978, 0.1306895525641979, 0.28959801324507706, 0.29908892847302593, 0.2918800890901775, 0.3024327008260529, 0.3117848649635395, 0.3253268980581727, 0.3130051555574781, 0.3076676499890503, 0.31571497213032107, 0.6697855778139568, 0.6936969533890074, 0.6854895481878877, 0.7119366061329894, 0.697375012028574, 0.6748624123489337, 0.6845304842801586, 0.6790533693952605, 0.6734280992634145, 0.09940890594684282, 0.09343834904036197, 0.09330127195203008, 0.08333612694261372, 0.08919765893650311, 0.0876218867601819, 0.10439273861051934, 0.1001489326751851, 0.13660297936284738, 0.21811148677381742, 0.17476641618692246, 0.18943278927380602, 0.24040655086747298, 0.20150416695879714, 0.17681436174290788, 0.21067518506773963, 0.1381594299726132, 0.18303364543391676, 0.3679811763375812, 0.41510750779204586, 0.36695104387760213, 0.38799332908600104, 0.35407170205609473, 0.3947860441300203, 0.3895040994176343, 0.41279359636579604, 0.4078647130978882, 0.30559786019727375, 0.28829009583079757, 0.29131941133234074, 0.28117078634894854, 0.2937930756440188, 0.24762979074399116, 0.2920349921190002, 0.3073228753477335, 0.2724593879656705, 0.19709407127287693, 0.18783462505853676, 0.19942130678289982, 0.20304980720028265, 0.2009527529496855, 0.19493476431707102, 0.2078583972640059, 0.24994656170849805, 0.21465590785967925, 0.2271264099898871, 0.22439399023436513, 0.21443620353130355, 0.22119584596264152, 0.25084873443448663, 0.25491823871306274, 0.2139619204484835, 0.24634015177959379, 0.40924332108316874, 0.7574758399316956, 0.7727242628973505, 0.6601891228251205, 0.7936803247603185, 0.6771778238998505, 0.7454137703686081, 0.7474043847396739, 0.5972912148934852, 0.17982048541720363, 0.7037337623192819, 0.21118439612864892, 0.20323176479608118, 0.6297568416840995, 0.20485685093579142, 0.659103604663279, 0.2064461438875661, 0.7171654688005993, 0.20733309182972692, 0.17814054595856577, 0.19554209835120773, 0.20708982435329437, 0.18363440895001537, 0.18487380513927287, 0.18668609301784644, 0.18454501277684754, 0.1817696453445199, 0.1801338024177438, 0.07155617289002947, 0.07902451483597162, 0.07801777867482995, 0.07325130869619512, 0.07523069297581186, 0.0772123787015454, 0.07857773423967429, 0.08477147486122172, 0.08942246721873193]}, "mutation_prompt": null}
{"id": "f881e337-3a43-48e7-9567-b58fb217fe55", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F_min = 0.5\n        self.F_max = 0.9\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: self.F_min + (self.F_max - self.F_min) * np.sin(np.pi * evals / (2 * self.budget))\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring dynamic mutation factors for enhanced convergence speed.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "14651833-3775-4889-a373-46486d0b368a", "metadata": {"aucs": [0.7968801489948274, 0.7857497924017587, 0.7930328545470777, 0.7914670047123273, 0.8023822238935016, 0.8109194771862845, 0.800164806998958, 0.817803200297867, 0.7870132232830508, 0.6216307169653656, 0.6310550899106175, 0.6185505089884191, 0.6313678290375803, 0.6213181784600736, 0.6096564997091771, 0.6297841861499857, 0.6207330176311852, 0.5931058184961518, 0.13737654245243613, 0.12566714026964232, 0.1323614882800892, 0.15243616969966656, 0.13647791516802266, 0.12230712883238015, 0.11664204857317162, 0.10768905512354976, 0.11664567084069022, 0.10784737916717935, 0.10739655010257287, 0.11874664006138591, 0.11910921784580186, 0.09143043726144406, 0.11274734910169304, 0.15174149395845238, 0.10834452291541097, 0.11973330592501663, 0.9096515280251296, 0.9183820322978025, 0.9495766660581665, 0.913165975605537, 0.9071735649436963, 0.9742419185151416, 0.9554495952410039, 0.9577221069478945, 0.9339532000363818, 0.4948587276718043, 0.4912386491947567, 0.49171309659023077, 0.46530489784880624, 0.4934932895349048, 0.4949316352588573, 0.4829406382289163, 0.5182233521159227, 0.47568118628136224, 0.7117668763266587, 0.7340625175351826, 0.7433994019965051, 0.8023638858124337, 0.7190853253609248, 0.7623176440052908, 0.7939579330401683, 0.7906651634599782, 0.7236487124153514, 0.3730231263477255, 0.49082441917973707, 0.4623422724469112, 0.35929913761048304, 0.40103892398486873, 0.4092785895373692, 0.39520382427794143, 0.430617315906472, 0.41580561422114226, 0.36753347796792646, 0.3750264212737079, 0.3992107458674461, 0.466457131992021, 0.33824053597553283, 0.3484331405261333, 0.4622107427895388, 0.3758862649125817, 0.2801304539465099, 0.3332805760225239, 0.4192409133125341, 0.3343879556072872, 0.32925116693639744, 0.41137277102632663, 0.3102673764572109, 0.3940592140626512, 0.37311340492507294, 0.3707269942090258, 0.48097457640495245, 0.5390931009803086, 0.48682253515143825, 0.5362483944519797, 0.4819595570358778, 0.4627653023451026, 0.5836428255038342, 0.534601601122068, 0.5352783035821425, 0.08866524732393466, 0.17506990020357238, 0.18534281864119795, 0.2304426565033093, 0.19827125080973584, 0.11051004148679766, 0.1550693837149658, 0.11420866074474978, 0.1306895525641979, 0.28959801324507706, 0.29908892847302593, 0.2918800890901775, 0.3024327008260529, 0.3117848649635395, 0.3253268980581727, 0.3130051555574781, 0.3076676499890503, 0.31571497213032107, 0.6697855778139568, 0.6936969533890074, 0.6854895481878877, 0.7119366061329894, 0.697375012028574, 0.6748624123489337, 0.6845304842801586, 0.6790533693952605, 0.6734280992634145, 0.09940890594684282, 0.09343834904036197, 0.09330127195203008, 0.08333612694261372, 0.08919765893650311, 0.0876218867601819, 0.10439273861051934, 0.1001489326751851, 0.13660297936284738, 0.21811148677381742, 0.17476641618692246, 0.18943278927380602, 0.24040655086747298, 0.20150416695879714, 0.17681436174290788, 0.21067518506773963, 0.1381594299726132, 0.18303364543391676, 0.3679811763375812, 0.41510750779204586, 0.36695104387760213, 0.38799332908600104, 0.35407170205609473, 0.3947860441300203, 0.3895040994176343, 0.41279359636579604, 0.4078647130978882, 0.30559786019727375, 0.28829009583079757, 0.29131941133234074, 0.28117078634894854, 0.2937930756440188, 0.24762979074399116, 0.2920349921190002, 0.3073228753477335, 0.2724593879656705, 0.19709407127287693, 0.18783462505853676, 0.19942130678289982, 0.20304980720028265, 0.2009527529496855, 0.19493476431707102, 0.2078583972640059, 0.24994656170849805, 0.21465590785967925, 0.2271264099898871, 0.22439399023436513, 0.21443620353130355, 0.22119584596264152, 0.25084873443448663, 0.25491823871306274, 0.2139619204484835, 0.24634015177959379, 0.40924332108316874, 0.7574758399316956, 0.7727242628973505, 0.6601891228251205, 0.7936803247603185, 0.6771778238998505, 0.7454137703686081, 0.7474043847396739, 0.5972912148934852, 0.17982048541720363, 0.7037337623192819, 0.21118439612864892, 0.20323176479608118, 0.6297568416840995, 0.20485685093579142, 0.659103604663279, 0.2064461438875661, 0.7171654688005993, 0.20733309182972692, 0.17814054595856577, 0.19554209835120773, 0.20708982435329437, 0.18363440895001537, 0.18487380513927287, 0.18668609301784644, 0.18454501277684754, 0.1817696453445199, 0.1801338024177438, 0.07155617289002947, 0.07902451483597162, 0.07801777867482995, 0.07325130869619512, 0.07523069297581186, 0.0772123787015454, 0.07857773423967429, 0.08477147486122172, 0.08942246721873193]}, "mutation_prompt": null}
{"id": "6841ba28-d446-44d0-ba26-0b898223e744", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F_min = 0.5\n        self.F_max = 0.9\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: self.F_min + (self.F_max - self.F_min) * np.sin(np.pi * evals / (2 * self.budget))\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring dynamic mutation factors for enhanced convergence speed.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "14651833-3775-4889-a373-46486d0b368a", "metadata": {"aucs": [0.7968801489948274, 0.7857497924017587, 0.7930328545470777, 0.7914670047123273, 0.8023822238935016, 0.8109194771862845, 0.800164806998958, 0.817803200297867, 0.7870132232830508, 0.6216307169653656, 0.6310550899106175, 0.6185505089884191, 0.6313678290375803, 0.6213181784600736, 0.6096564997091771, 0.6297841861499857, 0.6207330176311852, 0.5931058184961518, 0.13737654245243613, 0.12566714026964232, 0.1323614882800892, 0.15243616969966656, 0.13647791516802266, 0.12230712883238015, 0.11664204857317162, 0.10768905512354976, 0.11664567084069022, 0.10784737916717935, 0.10739655010257287, 0.11874664006138591, 0.11910921784580186, 0.09143043726144406, 0.11274734910169304, 0.15174149395845238, 0.10834452291541097, 0.11973330592501663, 0.9096515280251296, 0.9183820322978025, 0.9495766660581665, 0.913165975605537, 0.9071735649436963, 0.9742419185151416, 0.9554495952410039, 0.9577221069478945, 0.9339532000363818, 0.4948587276718043, 0.4912386491947567, 0.49171309659023077, 0.46530489784880624, 0.4934932895349048, 0.4949316352588573, 0.4829406382289163, 0.5182233521159227, 0.47568118628136224, 0.7117668763266587, 0.7340625175351826, 0.7433994019965051, 0.8023638858124337, 0.7190853253609248, 0.7623176440052908, 0.7939579330401683, 0.7906651634599782, 0.7236487124153514, 0.3730231263477255, 0.49082441917973707, 0.4623422724469112, 0.35929913761048304, 0.40103892398486873, 0.4092785895373692, 0.39520382427794143, 0.430617315906472, 0.41580561422114226, 0.36753347796792646, 0.3750264212737079, 0.3992107458674461, 0.466457131992021, 0.33824053597553283, 0.3484331405261333, 0.4622107427895388, 0.3758862649125817, 0.2801304539465099, 0.3332805760225239, 0.4192409133125341, 0.3343879556072872, 0.32925116693639744, 0.41137277102632663, 0.3102673764572109, 0.3940592140626512, 0.37311340492507294, 0.3707269942090258, 0.48097457640495245, 0.5390931009803086, 0.48682253515143825, 0.5362483944519797, 0.4819595570358778, 0.4627653023451026, 0.5836428255038342, 0.534601601122068, 0.5352783035821425, 0.08866524732393466, 0.17506990020357238, 0.18534281864119795, 0.2304426565033093, 0.19827125080973584, 0.11051004148679766, 0.1550693837149658, 0.11420866074474978, 0.1306895525641979, 0.28959801324507706, 0.29908892847302593, 0.2918800890901775, 0.3024327008260529, 0.3117848649635395, 0.3253268980581727, 0.3130051555574781, 0.3076676499890503, 0.31571497213032107, 0.6697855778139568, 0.6936969533890074, 0.6854895481878877, 0.7119366061329894, 0.697375012028574, 0.6748624123489337, 0.6845304842801586, 0.6790533693952605, 0.6734280992634145, 0.09940890594684282, 0.09343834904036197, 0.09330127195203008, 0.08333612694261372, 0.08919765893650311, 0.0876218867601819, 0.10439273861051934, 0.1001489326751851, 0.13660297936284738, 0.21811148677381742, 0.17476641618692246, 0.18943278927380602, 0.24040655086747298, 0.20150416695879714, 0.17681436174290788, 0.21067518506773963, 0.1381594299726132, 0.18303364543391676, 0.3679811763375812, 0.41510750779204586, 0.36695104387760213, 0.38799332908600104, 0.35407170205609473, 0.3947860441300203, 0.3895040994176343, 0.41279359636579604, 0.4078647130978882, 0.30559786019727375, 0.28829009583079757, 0.29131941133234074, 0.28117078634894854, 0.2937930756440188, 0.24762979074399116, 0.2920349921190002, 0.3073228753477335, 0.2724593879656705, 0.19709407127287693, 0.18783462505853676, 0.19942130678289982, 0.20304980720028265, 0.2009527529496855, 0.19493476431707102, 0.2078583972640059, 0.24994656170849805, 0.21465590785967925, 0.2271264099898871, 0.22439399023436513, 0.21443620353130355, 0.22119584596264152, 0.25084873443448663, 0.25491823871306274, 0.2139619204484835, 0.24634015177959379, 0.40924332108316874, 0.7574758399316956, 0.7727242628973505, 0.6601891228251205, 0.7936803247603185, 0.6771778238998505, 0.7454137703686081, 0.7474043847396739, 0.5972912148934852, 0.17982048541720363, 0.7037337623192819, 0.21118439612864892, 0.20323176479608118, 0.6297568416840995, 0.20485685093579142, 0.659103604663279, 0.2064461438875661, 0.7171654688005993, 0.20733309182972692, 0.17814054595856577, 0.19554209835120773, 0.20708982435329437, 0.18363440895001537, 0.18487380513927287, 0.18668609301784644, 0.18454501277684754, 0.1817696453445199, 0.1801338024177438, 0.07155617289002947, 0.07902451483597162, 0.07801777867482995, 0.07325130869619512, 0.07523069297581186, 0.0772123787015454, 0.07857773423967429, 0.08477147486122172, 0.08942246721873193]}, "mutation_prompt": null}
{"id": "4f88577b-b0cd-4443-86d8-08a533aedc68", "solution": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = lambda evals: max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n        self.F_min = 0.5\n        self.F_max = 0.9\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.adaptive_local_search = True\n        self.dynamic_F = lambda evals: self.F_min + (self.F_max - self.F_min) * np.sin(np.pi * evals / (2 * self.budget))\n\n    def __call__(self, func):\n        eval_count = 0\n        # Initial evaluation\n        for i in range(self.initial_population_size):\n            self.scores[i] = func(self.population[i])\n            eval_count += 1\n            if eval_count >= self.budget:\n                return self.best_solution()\n\n        while eval_count < self.budget:\n            current_population_size = self.dynamic_population_size(eval_count)\n            for i in range(current_population_size):\n                a, b, c = self.select_others(i, current_population_size)\n                current_F = self.dynamic_F(eval_count)\n                mutant = self.mutate(a, b, c, current_F)\n                trial = self.crossover(self.population[i], mutant)\n                trial_score = func(trial)\n                eval_count += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if eval_count >= self.budget:\n                    return self.best_solution()\n\n            if self.adaptive_local_search:\n                self.local_search(func, eval_count, current_population_size)\n\n        return self.best_solution()\n\n    def select_others(self, index, pop_size):\n        indices = list(range(pop_size))\n        indices.remove(index)\n        selected = np.random.choice(indices, 3, replace=False)\n        return self.population[selected[0]], self.population[selected[1]], self.population[selected[2]]\n\n    def mutate(self, a, b, c, F):\n        mutation = a + F * (b - c)\n        return np.clip(mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self, func, eval_count, pop_size):\n        best_idx = np.argmin(self.scores[:pop_size])\n        best = self.population[best_idx]\n        step_size = (self.upper_bound - self.lower_bound) * 0.05\n        for _ in range(5):  # Limited local search steps\n            if eval_count >= self.budget:\n                break\n            local_steps = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best + local_steps, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            eval_count += 1\n            if candidate_score < self.scores[best_idx]:\n                self.population[best_idx] = candidate\n                self.scores[best_idx] = candidate_score\n                best = candidate\n\n    def best_solution(self):\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "name": "DEALS", "description": "A refined hybrid Differential Evolution with Adaptive Local Search (DEALS) featuring dynamic mutation factors for enhanced convergence speed.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "14651833-3775-4889-a373-46486d0b368a", "metadata": {"aucs": [0.7968801489948274, 0.7857497924017587, 0.7930328545470777, 0.7914670047123273, 0.8023822238935016, 0.8109194771862845, 0.800164806998958, 0.817803200297867, 0.7870132232830508, 0.6216307169653656, 0.6310550899106175, 0.6185505089884191, 0.6313678290375803, 0.6213181784600736, 0.6096564997091771, 0.6297841861499857, 0.6207330176311852, 0.5931058184961518, 0.13737654245243613, 0.12566714026964232, 0.1323614882800892, 0.15243616969966656, 0.13647791516802266, 0.12230712883238015, 0.11664204857317162, 0.10768905512354976, 0.11664567084069022, 0.10784737916717935, 0.10739655010257287, 0.11874664006138591, 0.11910921784580186, 0.09143043726144406, 0.11274734910169304, 0.15174149395845238, 0.10834452291541097, 0.11973330592501663, 0.9096515280251296, 0.9183820322978025, 0.9495766660581665, 0.913165975605537, 0.9071735649436963, 0.9742419185151416, 0.9554495952410039, 0.9577221069478945, 0.9339532000363818, 0.4948587276718043, 0.4912386491947567, 0.49171309659023077, 0.46530489784880624, 0.4934932895349048, 0.4949316352588573, 0.4829406382289163, 0.5182233521159227, 0.47568118628136224, 0.7117668763266587, 0.7340625175351826, 0.7433994019965051, 0.8023638858124337, 0.7190853253609248, 0.7623176440052908, 0.7939579330401683, 0.7906651634599782, 0.7236487124153514, 0.3730231263477255, 0.49082441917973707, 0.4623422724469112, 0.35929913761048304, 0.40103892398486873, 0.4092785895373692, 0.39520382427794143, 0.430617315906472, 0.41580561422114226, 0.36753347796792646, 0.3750264212737079, 0.3992107458674461, 0.466457131992021, 0.33824053597553283, 0.3484331405261333, 0.4622107427895388, 0.3758862649125817, 0.2801304539465099, 0.3332805760225239, 0.4192409133125341, 0.3343879556072872, 0.32925116693639744, 0.41137277102632663, 0.3102673764572109, 0.3940592140626512, 0.37311340492507294, 0.3707269942090258, 0.48097457640495245, 0.5390931009803086, 0.48682253515143825, 0.5362483944519797, 0.4819595570358778, 0.4627653023451026, 0.5836428255038342, 0.534601601122068, 0.5352783035821425, 0.08866524732393466, 0.17506990020357238, 0.18534281864119795, 0.2304426565033093, 0.19827125080973584, 0.11051004148679766, 0.1550693837149658, 0.11420866074474978, 0.1306895525641979, 0.28959801324507706, 0.29908892847302593, 0.2918800890901775, 0.3024327008260529, 0.3117848649635395, 0.3253268980581727, 0.3130051555574781, 0.3076676499890503, 0.31571497213032107, 0.6697855778139568, 0.6936969533890074, 0.6854895481878877, 0.7119366061329894, 0.697375012028574, 0.6748624123489337, 0.6845304842801586, 0.6790533693952605, 0.6734280992634145, 0.09940890594684282, 0.09343834904036197, 0.09330127195203008, 0.08333612694261372, 0.08919765893650311, 0.0876218867601819, 0.10439273861051934, 0.1001489326751851, 0.13660297936284738, 0.21811148677381742, 0.17476641618692246, 0.18943278927380602, 0.24040655086747298, 0.20150416695879714, 0.17681436174290788, 0.21067518506773963, 0.1381594299726132, 0.18303364543391676, 0.3679811763375812, 0.41510750779204586, 0.36695104387760213, 0.38799332908600104, 0.35407170205609473, 0.3947860441300203, 0.3895040994176343, 0.41279359636579604, 0.4078647130978882, 0.30559786019727375, 0.28829009583079757, 0.29131941133234074, 0.28117078634894854, 0.2937930756440188, 0.24762979074399116, 0.2920349921190002, 0.3073228753477335, 0.2724593879656705, 0.19709407127287693, 0.18783462505853676, 0.19942130678289982, 0.20304980720028265, 0.2009527529496855, 0.19493476431707102, 0.2078583972640059, 0.24994656170849805, 0.21465590785967925, 0.2271264099898871, 0.22439399023436513, 0.21443620353130355, 0.22119584596264152, 0.25084873443448663, 0.25491823871306274, 0.2139619204484835, 0.24634015177959379, 0.40924332108316874, 0.7574758399316956, 0.7727242628973505, 0.6601891228251205, 0.7936803247603185, 0.6771778238998505, 0.7454137703686081, 0.7474043847396739, 0.5972912148934852, 0.17982048541720363, 0.7037337623192819, 0.21118439612864892, 0.20323176479608118, 0.6297568416840995, 0.20485685093579142, 0.659103604663279, 0.2064461438875661, 0.7171654688005993, 0.20733309182972692, 0.17814054595856577, 0.19554209835120773, 0.20708982435329437, 0.18363440895001537, 0.18487380513927287, 0.18668609301784644, 0.18454501277684754, 0.1817696453445199, 0.1801338024177438, 0.07155617289002947, 0.07902451483597162, 0.07801777867482995, 0.07325130869619512, 0.07523069297581186, 0.0772123787015454, 0.07857773423967429, 0.08477147486122172, 0.08942246721873193]}, "mutation_prompt": null}
