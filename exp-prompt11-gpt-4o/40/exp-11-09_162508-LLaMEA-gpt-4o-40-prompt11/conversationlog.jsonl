{"role": "LLaMEA", "time": "2024-11-09 16:25:08.989280", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# "}
{"role": "gpt-4o", "time": "2024-11-09 16:25:15.195715", "content": "# Description: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n# Code: \n```python\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n```"}
{"role": "LLaMEA", "time": "2024-11-09 16:28:13.618024", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:28:20.729540", "content": "# Description: Enhanced Hybrid Differential Evolution with Adaptive Lévy Flight and Dynamic Adaptation Mechanism to improve convergence speed and balance exploration-exploitation.\n# Code: \n# ```python\nimport numpy as np\n\nclass EnhancedHybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # increased to enhance diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # reduced to control mutation impact\n        self.CR = 0.7  # decreased to add more diversity in crossover\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/2))  # adjusted exponent for different step size\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/2))  # adjusted to control step length\n        return step\n\n    def dynamic_adaptation(self):\n        factor = 1 - (self.func_evals / self.budget)\n        self.F = 0.4 + 0.6 * factor  # linearly adapt F based on budget usage\n        \n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.dynamic_adaptation()  # adapt parameters dynamically\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.3) * (trial - best)  # adjusted scale\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:28:20.732488", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:28:29.877138", "content": "# Description: Hybrid Differential Evolution with Adaptive Lévy Flight employing dynamic population resizing and self-adaptive parameters for faster convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = self.initial_population_size\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def dynamic_population_size(self):\n        # Reduce population size dynamically to focus search\n        if self.func_evals > self.budget * 0.5:\n            self.population_size = max(4, self.initial_population_size // 2)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def adaptive_parameters(self):\n        # Adapt F and CR based on progress\n        if self.func_evals > 0:\n            self.F = np.random.uniform(0.5, 0.9)\n            self.CR = np.random.uniform(0.7, 1.0)\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n\n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.dynamic_population_size()  # Adjust population size\n            self.adaptive_parameters()  # Adjust F and CR\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:28:29.880050", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:28:36.573322", "content": "# Description: Enhanced Hybrid Differential Evolution using Adaptive Lévy Flight and Dynamic Population Sizing to improve convergence speed.\n# Code: \n# ```python\nimport numpy as np\n\nclass EnhancedHybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * (L ** (-1/3))\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def reduce_population(self):\n        sorted_indices = np.argsort(self.scores)\n        self.population = self.population[sorted_indices[:len(self.population)//2]]\n        self.scores = self.scores[sorted_indices[:len(self.scores)//2]]\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.initial_population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(len(self.population)):\n                indices = list(range(len(self.population)))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n                levy_step = 0.5 * self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n            if len(self.population) > 5 and self.func_evals % (self.budget // 5) == 0:\n                self.reduce_population()\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:28:36.576199", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:28:43.906613", "content": "# Description: Enhanced Hybrid Differential Evolution with Dynamic Population Size Adjustment for Improved Convergence Speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v)**(1/beta))\n        return step\n\n    def adaptive_population_adjustment(self):\n        return max(5, int(self.initial_population_size * (1 - self.func_evals / self.budget)))\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(len(self.population)):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            new_population_size = self.adaptive_population_adjustment()\n            self.population = self.population[:new_population_size]\n            self.scores = self.scores[:new_population_size]\n            for i in range(new_population_size):\n                indices = list(range(new_population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:28:43.909385", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:28:51.275587", "content": "\n# Description: Enhanced Differential Evolution with Dynamic Scaling and Adaptive Mutation for improved convergence.\n# Code: \n# ```python\nimport numpy as np\n\nclass EnhancedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increase population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_init = 0.5  # Initial DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            F_dynamic = self.F_init * (1 - self.func_evals / self.budget)  # Decrease F as evaluations increase\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation with dynamic F\n                mutant = self.population[a] + F_dynamic * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Dynamic Scaling\n                scaling_factor = np.random.uniform(0.5, 1.0)\n                trial = trial + scaling_factor * self.levy_flight(1.5) * (trial - best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:28:51.278362", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:28:57.729932", "content": "# Description: Enhanced Hybrid Differential Evolution with Randomized Adaptive Lévy Flight and Dynamic Population Size to improve convergence speed in diverse search spaces.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedHybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, min(50, 5 + int(0.2 * dim)))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.9  # Increased DE Mutation factor\n        self.CR = 0.85  # Slightly reduced Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n        self.random_adaptive_levy = True\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        if self.random_adaptive_levy:\n            step *= np.random.uniform(0.5, 1.5)\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:28:57.732997", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:29:04.384010", "content": "# Description: Enhanced Hybrid Differential Evolution with dynamic population sizing and adaptive mutation for improved convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n        self.dynamic_adjustment_factor = 0.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def adaptive_mutation(self, score):\n        return 0.5 + 0.5 * (self.budget - self.func_evals) / self.budget * score / np.min(self.scores)\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n\n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Dynamic mutation factor\n                dynamic_F = self.adaptive_mutation(self.scores[i])\n\n                # Mutation\n                mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n            # Dynamic adjustment of population size\n            if self.func_evals < self.budget // 2:\n                self.population_size = int(self.population_size * (1 + self.dynamic_adjustment_factor * (1 - self.func_evals / self.budget)))\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:29:04.387262", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:29:13.113135", "content": "# Description: Enhanced Hybrid Differential Evolution with Adaptive Lévy Flight integrating opposition-based learning for improved convergence speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedHybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def opposition_based_learning(self, population):\n        opposite_population = self.lower_bound + self.upper_bound - population\n        return np.clip(opposite_population, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Opposition-based learning\n                opposite_trial = self.opposition_based_learning(trial)\n\n                # Evaluate original and opposite trials\n                trial_score = evaluate(trial)\n                opposite_score = evaluate(opposite_trial)\n\n                # Selection\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n                elif opposite_score is not None and opposite_score < self.scores[i]:\n                    self.population[i] = opposite_trial\n                    self.scores[i] = opposite_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:29:13.116013", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:29:23.550054", "content": "# Description: Enhanced Hybrid Differential Evolution with Dynamic Adaptive Parameters and Intelligent Crossover for Accelerated Convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Starting DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def dynamic_factor(self, iteration):\n        return self.F * (1 - iteration / self.budget)\n\n    def intelligent_crossover(self, target, mutant, best):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        trial += 0.1 * np.random.normal(0, 1, self.dim) * (best - trial)\n        return np.clip(trial, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        iteration = 0\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation with dynamic adaptation\n                F_dynamic = self.dynamic_factor(iteration)\n                mutant = self.population[a] + F_dynamic * (self.population[b] - self.population[c])\n\n                # Intelligent Crossover\n                trial = self.intelligent_crossover(self.population[i], mutant, best)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n            iteration += 1\n\n        return best, best_score\n# ```\n"}
{"role": "LLaMEA", "time": "2024-11-09 16:29:23.552969", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:29:30.605235", "content": "# Description: Enhanced Hybrid Differential Evolution with Lévy Flight and Competitive Selection for improved convergence speed in high-dimensional spaces.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedHybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.7  # Reduced DE Mutation factor for finer search\n        self.CR = 0.85  # Adjusted Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return 0.1 * step  # Scaled down step size\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Competitive Selection\n                trial_score = evaluate(trial)\n                random_opponent = np.random.choice(self.population_size)\n                if trial_score is not None and trial_score < self.scores[random_opponent]:\n                    self.population[random_opponent] = trial\n                    self.scores[random_opponent] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:29:30.607927", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:29:39.277093", "content": "\n# Description: Improved Hybrid Differential Evolution with Lévy Flight using dynamic parameter adaptation for enhanced convergence speed.\n# Code: \n# ```python\nimport numpy as np\n\nclass ImprovedHybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.7  # Reduced DE Mutation factor for better exploitation\n        self.CR = 0.85  # Slightly reduced crossover probability for more diversity\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n        self.alpha = 0.1  # Initial weight for levy flight influence\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def adapt_parameters(self):\n        # Dynamic parameter adaptation based on evaluation progress\n        progress = self.func_evals / self.budget\n        self.F = 0.7 + 0.3 * np.cos(progress * np.pi / 2)\n        self.CR = 0.85 * (1 - progress) + 0.1\n        self.alpha = 0.1 + 0.4 * (1 - progress)\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                jrand = np.random.randint(self.dim)\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                crossover_mask[jrand] = True  # Ensure at least one element is from the mutant\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.alpha * self.levy_flight(1.5) * (trial - self.population[i])\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:29:39.279788", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:29:46.299098", "content": "# Description: Enhanced Hybrid Differential Evolution with Adaptive Lévy Flight and Dynamic Parameter Control to improve convergence speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedHybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size to improve diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_min = 0.5  # Dynamic mutation factor range\n        self.F_max = 0.9\n        self.CR_min = 0.6  # Dynamic crossover probability range\n        self.CR_max = 0.95\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def dynamic_parameters(self, iteration, max_iter):\n        self.F = self.F_min + (self.F_max - self.F_min) * (1 - iteration / max_iter)\n        self.CR = self.CR_max - (self.CR_max - self.CR_min) * (1 - iteration / max_iter)\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        max_iter = self.budget // self.population_size\n        iteration = 0\n\n        while self.func_evals < self.budget:\n            self.dynamic_parameters(iteration, max_iter)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation with dynamic F\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover with dynamic CR\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n            iteration += 1\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:29:46.301956", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:29:53.196901", "content": "# Description: Improved Hybrid Differential Evolution with Dynamic Population and Exponential Crossover for accelerated convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass HybridDELevyImproved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8\n        self.CR = 0.9\n        self.population_size = max(10, int(0.5 * dim))  # Dynamic population size\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def dynamic_crossover(self, parent, mutant):\n        jrand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == jrand else parent[j] \n                          for j in range(self.dim)])\n        return trial\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                \n                trial = self.dynamic_crossover(self.population[i], mutant)\n\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:29:53.199540", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:30:03.007106", "content": "# Description: Enhanced Hybrid Differential Evolution with Dynamic Population and Adaptive Lévy Strategy for Improved Convergence Speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedHybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, 5 * dim)  # Dynamic population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5 + np.random.rand() * 0.5  # Randomized DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n        self.scale_factor = 0.5  # Scaling factor for Lévy step\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover using a random component update\n                crossover_mask = np.random.rand(self.dim) < (self.CR + np.random.rand() * 0.1)\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Adaptive Lévy flight step\n                levy_step = self.scale_factor * self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:30:03.010259", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:30:11.021633", "content": "# Description: Enhanced Hybrid Differential Evolution with Adaptive Lévy Flight and Dynamic Parameter Adjustments for Improved Convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedHybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.9  # Increased DE Mutation factor for better exploration\n        self.CR = 0.95  # Increased Crossover probability for better combination\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def adjust_parameters(self, iteration, max_iterations):\n        self.F = 0.5 + 0.4 * (1 - iteration / max_iterations)  # Dynamically adjust mutation factor\n        self.CR = 0.9 + 0.05 * (iteration / max_iterations)  # Dynamically adjust crossover rate\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        max_iterations = self.budget // self.population_size\n        iteration = 0\n\n        while self.func_evals < self.budget:\n            self.adjust_parameters(iteration, max_iterations)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n            iteration += 1\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:30:11.024287", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:30:17.742162", "content": "# Description: Enhanced Differential Evolution with Stochastic Adaptive Crossover and Dynamic Scaling for improved convergence.\n# Code: \n```python\nimport numpy as np\n\nclass EnhancedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_min = 0.5  # Dynamic scaling factor\n        self.F_max = 0.9\n        self.CR_min = 0.1  # Adaptive crossover probability\n        self.CR_max = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def adaptive_crossover(self, score):\n        \"\"\"Adapt the crossover rate based on current score.\"\"\"\n        return self.CR_min + (self.CR_max - self.CR_min) * ((score - min(self.scores)) / (max(self.scores) - min(self.scores) + 1e-9))\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Dynamic Mutation\n                F = self.F_min + np.random.rand() * (self.F_max - self.F_min)\n                mutant = self.population[a] + F * (self.population[b] - self.population[c])\n\n                # Adaptive Crossover\n                CR = self.adaptive_crossover(self.scores[i])\n                crossover_mask = np.random.rand(self.dim) < CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Clipping and Evaluation\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n```"}
{"role": "LLaMEA", "time": "2024-11-09 16:33:25.091497", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:33:33.877439", "content": "# Description: Enhanced Hybrid Differential Evolution with Dynamic Population and Adaptive Crossover for improved convergence speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR_initial = 0.9  # Initial Crossover probability\n        self.CR_final = 0.5  # Final Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def dynamic_crossover(self, current_eval):\n        # Adaptive crossover probability\n        return self.CR_initial - ((self.CR_initial - self.CR_final) * (current_eval / self.budget))\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        # Dynamic population strategy\n        while self.func_evals < self.budget:\n            if self.func_evals > self.budget * 0.5:\n                self.population_size = max(10, int(self.population_size * 0.8))\n                self.population = self.population[:self.population_size]\n                self.scores = self.scores[:self.population_size]\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover with adaptive CR\n                CR = self.dynamic_crossover(self.func_evals)\n                crossover_mask = np.random.rand(self.dim) < CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:33:33.881707", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:33:45.010474", "content": "# Description: Enhanced Hybrid Differential Evolution using Adaptive Lévy Flight with Dynamic Population Size for Improved Convergence Speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedHybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.func_evals = 0\n        self.dynamic_population_size = self.initial_population_size\n        \n    def levy_flight(self, L):\n        u = np.random.standard_normal() * (L ** (-1/3))\n        v = np.random.standard_normal()\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def dynamic_resizing(self):\n        if self.func_evals > self.budget / 2:\n            self.dynamic_population_size = max(10, int(self.initial_population_size / 2))\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = np.copy(ind)\n                return score\n            else:\n                return None\n\n        for i in range(self.initial_population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.dynamic_resizing()\n            for i in range(self.dynamic_population_size):\n                indices = list(range(self.dynamic_population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:33:45.013078", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:33:53.466056", "content": "# Description: Enhanced Hybrid Differential Evolution with Stochastic Adaptive Techniques for Improved Convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedHybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        # Adaptive Mutation factor and Crossover probability\n        self.F_base = 0.6\n        self.CR_base = 0.7\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, scale):\n        u = np.random.normal(0, 1) * scale\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))  # Scaled step size\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            # Update mutation and crossover rates adaptively\n            self.F = self.F_base + 0.3 * np.random.rand()\n            self.CR = self.CR_base + 0.2 * np.random.rand()\n            \n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation with adaptive F\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover with adaptive CR\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Stochastic Lévy flight step\n                levy_scale = 1.5 * np.random.rand()\n                levy_step = self.levy_flight(levy_scale) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:33:53.468391", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:34:01.696179", "content": "# Description: Enhanced Hybrid Differential Evolution with Adaptive Lévy Flight and Dynamic Population Sizing for Improved Convergence Speed\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedHybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def dynamic_population_size(self):\n        current_ratio = self.func_evals / self.budget\n        return max(5, int(self.initial_population_size * (1 - current_ratio)))\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.initial_population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            current_population_size = self.dynamic_population_size()\n            for i in range(current_population_size):\n                indices = list(range(current_population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:34:01.698961", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:34:09.718563", "content": "# Description: Improved Hybrid Differential Evolution with Lévy Flight and Adaptive Mutation Strategy for Enhanced Convergence Rate.\n# Code:\n# ```python\nimport numpy as np\n\nclass ImprovedHybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.9  # Slightly increased DE Mutation factor\n        self.CR = 0.85  # Adjusted crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n        self.adaptive_f = np.full(self.population_size, self.F)\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def adaptive_mutation(self, index, trial_score):\n        if trial_score < self.scores[index]:\n            self.adaptive_f[index] = self.F * 1.1\n        else:\n            self.adaptive_f[index] = self.F * 0.9\n        self.adaptive_f[index] = np.clip(self.adaptive_f[index], 0.5, 1.0)\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Adaptive Mutation\n                mutant = self.population[a] + self.adaptive_f[i] * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection with adaptive mutation update\n                trial_score = evaluate(trial)\n                if trial_score is not None:\n                    self.adaptive_mutation(i, trial_score)\n                    if trial_score < self.scores[i]:\n                        self.population[i] = trial\n                        self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:34:09.721514", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:34:18.170805", "content": "# Description: Hybrid Differential Evolution with Adaptive Lévy Flight and Dynamic Population Sizing to improve convergence speed.\n# Code: \n```python\nimport numpy as np\n\nclass HybridDELevyDynamic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n        self.dynamic_factor = 0.5  # Factor for dynamic population changes\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def dynamic_population_size(self):\n        new_size = int(self.population_size * (1 - self.dynamic_factor * self.func_evals / self.budget))\n        return max(5, new_size)\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            new_population_size = self.dynamic_population_size()\n            if new_population_size < self.population_size:\n                indices = np.argsort(self.scores)[:new_population_size]\n                self.population = self.population[indices]\n                self.scores = self.scores[indices]\n            self.population_size = new_population_size\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n```"}
{"role": "LLaMEA", "time": "2024-11-09 16:37:15.753535", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:37:23.621926", "content": "# Description: Hybrid Differential Evolution with Dynamic Population Control and Lévy Flight Adaptation to boost convergence speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.func_evals = 0\n        self.current_population_size = self.initial_population_size\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def adapt_population_size(self):\n        new_size = max(5, self.initial_population_size - (self.func_evals // (self.budget // 3)))\n        if new_size < self.current_population_size:\n            self.population = self.population[:new_size]\n            self.scores = self.scores[:new_size]\n        self.current_population_size = new_size\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n\n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.current_population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_population_size()\n            for i in range(self.current_population_size):\n                indices = list(range(self.current_population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                if np.random.rand() < 0.5:  # Randomly apply Lévy flight\n                    levy_step = self.levy_flight(1.5) * (trial - best)\n                    trial += levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:37:23.625129", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:37:31.554260", "content": "# Description: Enhanced Hybrid Differential Evolution with Stochastic Mirroring and Dynamic Population Management for improved convergence speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedHybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.min_population_size = 10\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.7  # DE Mutation factor\n        self.CR = 0.85  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def mirror(self, ind):\n        return self.lower_bound + self.upper_bound - ind\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.initial_population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(len(self.population)):\n                indices = list(range(len(self.population)))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Stochastic Mirroring\n                if np.random.rand() < 0.3:  \n                    mutant = self.mirror(mutant)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n            \n            # Dynamic Population Management\n            if len(self.population) > self.min_population_size and self.func_evals > self.budget * 0.5:\n                self.population = self.population[:len(self.population) - 1]\n                self.scores = self.scores[:len(self.scores) - 1]\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:37:31.557063", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:37:40.789210", "content": "# Description: Enhanced Hybrid Differential Evolution with Lévy Flight and Dynamic Population Size to improve convergence speed.\n# Code: \n# ```python\nimport numpy as np\n\nclass EnhancedHybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.7  # Adjusted DE Mutation factor for improved balance\n        self.CR = 0.85  # Adjusted Crossover probability for better exploration\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.func_evals = 0\n        self.dynamic_pop_size = int(self.initial_population_size * 1.5)\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.initial_population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.dynamic_pop_size):\n                indices = list(range(self.initial_population_size))\n                indices.remove(i % self.initial_population_size)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation with dynamic factor\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i % self.initial_population_size])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i % self.initial_population_size]:\n                    self.population[i % self.initial_population_size] = trial\n                    self.scores[i % self.initial_population_size] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:37:40.791728", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:37:47.551377", "content": "# Description: Enhanced Hybrid Differential Evolution with Dynamic Step Size Control for Improved Convergence Speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.dynamic_step_size = True\n        self.initial_step_size = 0.5\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Dynamic step size adjustment\n                if self.dynamic_step_size:\n                    step_size = self.initial_step_size * (1 - self.func_evals / self.budget)\n                else:\n                    step_size = self.initial_step_size\n                \n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best) * step_size\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:37:47.554014", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:37:55.441467", "content": "# Description: Enhanced Hybrid Differential Evolution with Adaptive Lévy Flight and Rank-Based Selection for improved convergence speed and solution quality.\n# Code: \n```python\nimport numpy as np\n\nclass EnhancedHybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Increased population size for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.7  # Adjusted mutation factor for improved control\n        self.CR = 0.8  # Adjusted crossover probability for better diversity\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma_u = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            ranked_indices = np.argsort(self.scores)\n            for i in range(self.population_size):\n                # Rank-based selection for diversity\n                if i < self.population_size // 2:\n                    # Select from top half\n                    a, b, c = np.random.choice(ranked_indices[:self.population_size // 2], 3, replace=False)\n                else:\n                    # Select from entire population\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n```"}
{"role": "LLaMEA", "time": "2024-11-09 16:37:55.447349", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:38:04.056149", "content": "# Description: Enhanced Differential Evolution with Strategic Lévy Flight and Dynamic Parameters for accelerated convergence in optimization scenarios.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.7 + np.random.rand() * 0.3  # Randomized DE Mutation factor for diversity\n        self.CR = 0.8  # Adjusted crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation with adaptive scaling\n                scale_factor = 0.5 + np.random.rand() * (self.F - 0.5)\n                mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n\n                # Crossover with strategy\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Improved Lévy flight step\n                levy_multiplier = np.random.rand(self.dim) * 0.1\n                levy_step = levy_multiplier * self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:38:04.058957", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:38:12.609041", "content": "# Description: Enhanced Hybrid Differential Evolution by incorporating dynamic population size adjustment and adaptive mutation to improve convergence speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.min_population_size = 5\n        self.current_population_size = self.initial_population_size\n        self.F = 0.9  # Increased DE Mutation factor\n        self.CR = 0.8  # Reduced Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.current_population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            if self.func_evals % (self.budget // 4) == 0 and self.current_population_size > self.min_population_size:\n                self.current_population_size -= 1\n                self.population = self.population[:self.current_population_size]\n                self.scores = self.scores[:self.current_population_size]\n\n            for i in range(self.current_population_size):\n                indices = list(range(self.current_population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Adaptive Mutation\n                F_adaptive = self.F * np.random.rand()\n                mutant = self.population[a] + F_adaptive * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:38:12.611825", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:38:21.659769", "content": "# Description: Enhanced Hybrid Differential Evolution with Adaptive Lévy Flight incorporated with Self-Adaptive Parameters to improve convergence speed and robustness in optimization tasks.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedHybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def adapt_parameters(self):\n        self.F = np.clip(0.5 + np.random.normal(0, 0.1), 0.4, 0.9)\n        self.CR = np.clip(0.7 + np.random.normal(0, 0.1), 0.6, 1.0)\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()  # Adapt parameters at each iteration\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation with dynamic scaling\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:38:21.662704", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:38:29.978454", "content": "# Description: Enhanced Hybrid Differential Evolution leveraging Quasi-Oppositional Learning and Dynamic Control Parameters to improve convergence speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n        self.best = None\n        self.best_score = np.inf\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def quasi_oppositional_learning(self, ind):\n        return 2 * np.mean([self.lower_bound, self.upper_bound]) - ind\n\n    def __call__(self, func):\n        def evaluate(ind):\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < self.best_score:\n                    self.best_score = score\n                    self.best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Dynamic Mutation factor\n                self.F = 0.5 + (0.5 * (self.budget - self.func_evals) / self.budget)\n\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial = trial + self.levy_flight(1.5) * (trial - self.best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Quasi-Oppositional Learning\n                quasi_trial = self.quasi_oppositional_learning(trial)\n                quasi_trial = np.clip(quasi_trial, self.lower_bound, self.upper_bound)\n\n                trial_score = evaluate(trial)\n                quasi_score = evaluate(quasi_trial)\n\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n                elif quasi_score is not None and quasi_score < self.scores[i]:\n                    self.population[i] = quasi_trial\n                    self.scores[i] = quasi_score\n\n        return self.best, self.best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:38:29.981002", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:38:37.228115", "content": "\n# Description: Enhanced Hybrid Differential Evolution with Dynamic Population Control and Lévy Flight for improved convergence speed.\n# Code: \n# ```python\nimport numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20  # Changed to dynamic later\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.9  # Increased DE Mutation factor\n        self.CR = 0.85  # Adjusted Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def adaptive_population_size(self):\n        return max(5, int(self.initial_population_size * (1 - self.func_evals / self.budget)))  # Dynamic population size\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()  # Ensure best is not overwritten\n                return score\n            return None\n\n        for i in range(self.initial_population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            current_population_size = self.adaptive_population_size()\n            for i in range(current_population_size):\n                indices = np.random.choice(self.initial_population_size, 3, replace=False)\n                a, b, c = indices[0], indices[1], indices[2]\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial += levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:38:37.230787", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:38:54.451937", "content": "# Description: Enhanced Hybrid Differential Evolution leveraging a dynamic population size and energy-boosted Lévy Flight for improved convergence speed.\n# Code:\n```python\nimport numpy as np\n\nclass EnhancedHybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20  # Initial population size\n        self.population_growth_rate = 1.1  # Dynamic population growth rate\n        self.max_population_size = 50  # Maximum allowed population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.7  # DE Mutation factor (adjusted)\n        self.CR = 0.85  # Crossover probability (adjusted)\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        energy_boost = np.random.uniform(0.9, 1.1)  # Energy boost factor\n        return step * energy_boost\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(len(self.population)):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            population_size = min(int(len(self.population) * self.population_growth_rate), self.max_population_size)\n            new_population = []\n            new_scores = []\n\n            for i in range(len(self.population)):\n                indices = list(range(len(self.population)))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    new_population.append(trial)\n                    new_scores.append(trial_score)\n                else:\n                    new_population.append(self.population[i])\n                    new_scores.append(self.scores[i])\n\n            self.population = np.array(new_population)\n            self.scores = np.array(new_scores)\n\n        return best, best_score\n```\n"}
{"role": "LLaMEA", "time": "2024-11-09 16:42:00.043083", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:42:09.023264", "content": "# Description: Hybrid Differential Evolution with Dynamic Strategy Adjustment and Beta-Distributed Crossover to improve convergence speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass HybridDEBeta:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.8  \n        self.CR_base = 0.9  \n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def dynamic_strategy(self):\n        return np.random.uniform(0.5, 1.0), np.random.beta(2, 5)  # Dynamic F and Beta-distributed CR\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            F, CR = self.dynamic_strategy()\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                mutant = self.population[a] + F * (self.population[b] - self.population[c])\n\n                crossover_mask = np.random.rand(self.dim) < CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = np.clip(trial + levy_step, self.lower_bound, self.upper_bound)\n\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:42:09.026392", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:42:17.522090", "content": "# Description: Hybrid Differential Evolution with Adaptive Lévy Flight and Enhanced Population Diversity for faster convergence in high-dimensional spaces.\n# Code:\n# ```python\nimport numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Increased population size for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.7  # Adjusted DE Mutation factor for stability\n        self.CR = 0.8  # Adjusted crossover probability\n        self.initial_weight = 0.5  # Introduce weight for exploration\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation with diversity enhancement\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c]) + \\\n                         self.initial_weight * (self.population[i] - self.population[c])\n\n                # Crossover with adaptive scaling\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:42:17.524885", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:42:28.247604", "content": "# Description: Enhanced Hybrid Differential Evolution with Adaptive Lévy Flight and Dynamic Population Resizing to improve convergence speed.\n# Code:\n```python\nimport numpy as np\n\nclass EnhancedHybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8 \n        self.CR = 0.9 \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def dynamic_population_size(self):\n        return max(5, int(20 * (1 - (self.func_evals / self.budget))))\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n\n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = np.copy(ind)\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.population_size = self.dynamic_population_size()\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n                \n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n```\n"}
{"role": "LLaMEA", "time": "2024-11-09 16:45:21.405803", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:45:29.034220", "content": "# Description: Enhanced Differential Evolution with Dynamic Population Sizing and Adaptive Mutation to improve convergence speed in global optimization.\n# Code: \n# ```python\nimport numpy as np\n\nclass EnhancedDEDynamic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_min = 0.5  # Minimum DE Mutation factor\n        self.F_max = 0.9  # Maximum DE Mutation factor\n        self.CR = 0.8  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.func_evals = 0\n\n    def adaptive_mutation_factor(self, score, best_score):\n        return self.F_min + (self.F_max - self.F_min) * (best_score - score) / max(1e-10, best_score)\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.initial_population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(len(self.population)):\n                indices = list(range(len(self.population)))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Dynamic mutation factor\n                F = self.adaptive_mutation_factor(self.scores[a], best_score)\n                \n                # Mutation\n                mutant = self.population[a] + F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n            # Dynamic population adjustment\n            if self.func_evals > self.budget / 2 and len(self.population) > 5:\n                self.population = self.population[:max(5, len(self.population)//2)]\n                self.scores = self.scores[:len(self.population)]\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:45:29.037210", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:45:39.198067", "content": "# Description: Enhanced Hybrid Differential Evolution with Dynamic Population and Adaptive Parameter Control for improved convergence speed.\n# Code: \n# ```python\nimport numpy as np\n\nclass EnhancedHybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(15 + np.sqrt(dim))  # Dynamic population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.8  # Base DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Dynamic mutation factor\n                F = self.F_base * (1 - self.func_evals / self.budget) + 0.1\n                \n                # Mutation\n                mutant = self.population[a] + F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:45:39.200909", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:45:47.928152", "content": "# Description: Accelerated Hybrid Differential Evolution with Adaptive Lévy Flight and Dynamic Population Size for faster convergence in diverse optimization landscapes.\n# Code:\n# ```python\nimport numpy as np\n\nclass AcceleratedHybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Increased initial population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Reduced DE Mutation factor for finer exploration\n        self.CR = 0.7  # Adjusted Crossover probability for better diversity\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            dynamic_F = self.F + (0.9 - self.F) * (1 - self.func_evals / self.budget)  # Dynamic mutation factor\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.3) * (trial - best)  # Adjusted Lévy flight parameter for balance\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n            \n            if self.func_evals >= 0.7 * self.budget:  # Reduce population size to focus on exploitation\n                self.population_size = max(10, self.population_size - 1)\n                self.population = self.population[:self.population_size]\n                self.scores = self.scores[:self.population_size]\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:45:47.931191", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:45:57.138216", "content": "# Description: Hybrid Differential Evolution with Adaptive Lévy Flight and Dynamic Population Size for improved exploration and convergence speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass HybridDELevyDynamic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def adjust_population_size(self):\n        # Dynamically adjust population size based on remaining budget\n        factor = self.budget / (self.func_evals + 1)\n        new_size = int(max(5, self.initial_population_size * factor))\n        return new_size\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n\n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(len(self.population)):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            pop_size = self.adjust_population_size()\n            for i in range(len(self.population)):\n                indices = list(range(len(self.population)))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n            # Adjust population size if needed\n            if len(self.population) != pop_size:\n                self.population = self.population[:pop_size]\n                self.scores = self.scores[:pop_size]\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:45:57.141477", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:46:04.998130", "content": "# Description: Enhanced Hybrid Differential Evolution with Adaptive Lévy Flight and Dynamic Population Size for Improved Convergence Speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedHybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.min_population_size = 10\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def adjust_population_size(self):\n        reduction_step = (self.population_size - self.min_population_size) / (self.budget / 10)\n        if self.population_size > self.min_population_size:\n            self.population_size -= int(reduction_step)\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n\n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n            # Dynamic population size adjustment\n            self.adjust_population_size()\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:46:05.001216", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:46:14.469136", "content": "# Description: Enhanced Hybrid Differential Evolution with Dynamic Population Size and Adaptive Mutation to improve convergence speed across various dimensions.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.initial_population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            dynamic_population_size = min(\n                self.initial_population_size + (self.func_evals // 100), \n                self.budget - self.func_evals)\n            for i in range(dynamic_population_size):\n                indices = list(range(dynamic_population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Dynamic Mutation Factor\n                dynamic_F = self.F * (1 - self.func_evals / self.budget)\n\n                # Mutation\n                mutant = self.population[a] + dynamic_F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```\n"}
{"role": "LLaMEA", "time": "2024-11-09 16:46:14.471718", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:46:21.006681", "content": "# Description: Enhanced Hybrid Differential Evolution incorporating dynamic learning rates and adaptive mutation strategies to boost convergence speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Increased population for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.7  # Base DE mutation factor\n        self.CR_base = 0.9  # Base crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n        self.learning_rate_decay = 0.99  # Learning rate decay factor\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n\n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            learning_rate = self.F_base * (self.learning_rate_decay ** (self.func_evals // self.population_size))\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Adaptive Mutation\n                mutant = self.population[a] + learning_rate * (self.population[b] - self.population[c])\n\n                # Adaptive Crossover\n                crossover_mask = np.random.rand(self.dim) < (self.CR_base * np.random.rand())\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:46:21.009184", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:46:33.971235", "content": "# Description: Enhanced Hybrid Differential Evolution with Adaptive Lévy Flight and Randomized Parameter Control to improve convergence speed and adaptability.\n# Code: \n# ```python\nimport numpy as np\n\nclass EnhancedHybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20 + dim  # Dynamic population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5 + np.random.rand() * 0.4  # Randomized DE Mutation factor\n        self.CR = 0.8 + np.random.rand() * 0.2  # Randomized Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n\n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with dynamic factor\n                self.F = 0.5 + np.random.rand() * 0.4\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover with dynamic probability\n                self.CR = 0.8 + np.random.rand() * 0.2\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:46:33.974209", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:46:43.783547", "content": "# Description: Enhanced Hybrid Differential Evolution featuring Adaptive Lévy Flight and Adaptive Population Size to improve convergence speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedHybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def adaptive_population_size(self):\n        # Reduce population size over time\n        max_reduction = 0.5\n        reduction_factor = (self.func_evals / self.budget) * max_reduction\n        self.population_size = max(2, int(self.initial_population_size * (1 - reduction_factor)))\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adaptive_population_size()\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                if len(indices) < 3:\n                    continue\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:46:43.786027", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:46:55.863969", "content": "# Description: Enhanced Hybrid Differential Evolution with Adaptive Lévy Flight and Dynamic Population Sizing for Accelerated Convergence.\n# Code: \n# ```python\nimport numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = 20\n        self.min_pop_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_pop_size, dim))\n        self.scores = np.full(self.initial_pop_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def dynamic_population_size(self):\n        # Dynamically reduce population size as budget decreases to speed up convergence\n        progress = self.func_evals / self.budget\n        current_size = int(self.initial_pop_size - progress * (self.initial_pop_size - self.min_pop_size))\n        return max(self.min_pop_size, current_size)\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.initial_pop_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            current_pop_size = self.dynamic_population_size()\n            for i in range(current_pop_size):\n                indices = list(range(current_pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n            # Adjust population size\n            if current_pop_size < len(self.population):\n                self.population = self.population[:current_pop_size]\n                self.scores = self.scores[:current_pop_size]\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:46:55.866766", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:47:05.734807", "content": "# Description: Enhanced DE-Lévy with dynamic population size and step-size adaptation to improve convergence speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30  # Increased initial population\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Adjusted DE Mutation factor\n        self.CR = 0.7  # Adjusted Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def adapt_population_size(self):\n        # Dynamically adjust population size during search\n        if self.func_evals < self.budget / 2:\n            return self.initial_population_size\n        else:\n            return max(10, int(self.initial_population_size * 0.5))\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.initial_population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            current_population_size = self.adapt_population_size()\n            indices_list = list(range(current_population_size))\n\n            for i in range(current_population_size):\n                indices = list(set(indices_list) - {i})\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step with adaptive step size\n                levy_step = self.levy_flight(1.5) * (trial - best) * (0.5 + 0.5 * np.random.rand())\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:47:05.737931", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:47:13.487909", "content": "# Description: Hybrid Differential Evolution enhanced with Adaptive Lévy Flight and Dynamic Population Size for improved convergence speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass HybridDELevyDynamic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def dynamic_population_adjustment(self):\n        if self.func_evals < self.budget / 2:\n            return self.population_size\n        else:\n            return max(5, int(self.population_size * 0.5))\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n\n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()  # ensure best is not mutated inadvertently\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            current_pop_size = self.dynamic_population_adjustment()\n            for i in range(current_pop_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:47:13.490208", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:47:21.377167", "content": "\n# Description: Enhanced Hybrid Differential Evolution with Dynamic Population and Adaptive Mutation to expedite convergence rates.\n# Code: \n```python\nimport numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Initial DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.func_evals = 0\n        self.dynamic_population_size = self.initial_population_size\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def dynamic_mutation_factor(self, current_eval):\n        return self.F * (1 - current_eval / self.budget)\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.dynamic_population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.dynamic_population_size = max(5, int(self.initial_population_size * (1 - self.func_evals / self.budget)))\n\n            for i in range(self.dynamic_population_size):\n                indices = list(range(self.dynamic_population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Dynamic Mutation\n                F_dynamic = self.dynamic_mutation_factor(self.func_evals)\n                mutant = self.population[a] + F_dynamic * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n```\n"}
{"role": "LLaMEA", "time": "2024-11-09 16:50:15.970618", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:50:23.082753", "content": "# Description: Dynamic Adaptive Differential Evolution with Enhanced Lévy Flight and Fitness-based Adaptation for faster convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass DynamicADELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n        self.F_base = 0.5  # Base mutation factor\n        self.CR_base = 0.7  # Base crossover probability\n\n    def adaptive_parameters(self, fitness):\n        # Adapting parameters based on fitness\n        self.F = self.F_base + 0.3 * (1 - fitness) \n        self.CR = self.CR_base + 0.2 * (1 - fitness)\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                fitness = 1 - (self.scores[i] / (best_score if best_score != 0 else 1))\n                self.adaptive_parameters(fitness)\n                \n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                levy_step = self.levy_flight(1.2) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:50:23.085307", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:50:30.968690", "content": "# Description: Enhanced Hybrid Differential Evolution with Dynamic Population Size and Adaptive Mutation for improved convergence speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Reduced DE Mutation factor for stability\n        self.CR = 0.7  # Adjusted Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * (2 ** ((beta - 1) / 2))))**(1 / beta)\n        u = np.random.normal(0, sigma, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n\n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.initial_population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            pop_size = max(5, self.initial_population_size - \n                           int((self.initial_population_size * self.func_evals) / self.budget))\n            for i in range(pop_size):\n                indices = list(range(pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Lévy flight step\n                levy_step = self.levy_flight(1) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:50:30.972128", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:50:40.734594", "content": "# Description: Enhanced Hybrid DE with Dynamic Population Size and Archive-based Mutation for improved convergence speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.archive = []\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n\n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            if self.func_evals % (self.budget // 3) == 0:  # Dynamic population resizing\n                self.population_size = max(10, int(self.initial_population_size * 0.5))\n                self.population = self.population[:self.population_size]\n                self.scores = self.scores[:self.population_size]\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation using archive\n                if len(self.archive) > 0:\n                    archive_index = np.random.randint(len(self.archive))\n                    mutant = self.population[a] + self.F * (self.population[b] - self.archive[archive_index])\n                else:\n                    mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.archive.append(self.population[i])\n                    if len(self.archive) > self.initial_population_size:\n                        self.archive.pop(0)\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:50:40.737737", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:50:48.123987", "content": "# Description: Enhanced Differential Evolution with Adaptive Lévy Flight and Opposition-Based Learning to improve convergence speed.\n# Code: \n# ```python\nimport numpy as np\n\nclass EnhancedDELevyOBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.7  # DE Mutation factor (slightly reduced)\n        self.CR = 0.85  # Crossover probability (slightly reduced)\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def opposition_based_learning(self, individual):\n        return self.lower_bound + self.upper_bound - individual\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n\n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                # Opposition-based learning\n                opposite = self.opposition_based_learning(trial)\n                opposite_score = evaluate(opposite)\n                if opposite_score is not None and opposite_score < self.scores[i]:\n                    self.population[i] = opposite\n                    self.scores[i] = opposite_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:50:48.126878", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:50:55.279592", "content": "# Description: Enhanced Hybrid Differential Evolution with Dynamic Lévy Flight and Adaptive Population for Faster Convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedHybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size for better exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_min = 0.5\n        self.F_max = 0.9  # Adaptable DE Mutation factor\n        self.CR = 0.8  # Lower crossover probability to encourage more diversity\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L, scale=0.1):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3)) * scale\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n\n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Dynamic Mutation factor\n                F = self.F_min + (self.F_max - self.F_min) * np.random.rand()\n\n                # Mutation\n                mutant = self.population[a] + F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Dynamic Lévy flight step\n                levy_step = self.levy_flight(1.5, scale=np.random.rand()) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:50:55.282712", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:51:04.638655", "content": "# Description: Enhanced Hybrid DE with Dynamic Population and Adaptive Mutation for improved convergence speed in varied dimensional spaces.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 25  # Increased initial population\n        self.population_size = self.initial_population_size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_min, self.F_max = 0.5, 0.9  # Dynamic mutation factor range\n        self.CR = 0.8  # Adjusted crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def adaptive_mutation(self):\n        # Adjust mutation factor based on evaluations ratio\n        return self.F_min + (self.F_max - self.F_min) * (self.func_evals / self.budget)\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n\n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Dynamic Mutation\n                F = self.adaptive_mutation()\n                mutant = self.population[a] + F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n            # Reduce population size dynamically if budget is nearing completion\n            if self.func_evals > self.budget * 0.75 and self.population_size > 5:\n                self.population_size -= 1\n                self.scores = np.delete(self.scores, -1)\n                self.population = np.delete(self.population, -1, axis=0)\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:51:04.642084", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:51:13.574505", "content": "# Description: Adaptive Differential Evolution with Dynamic Parameter Tuning and Refined Lévy Flight for Accelerated Convergence.\n# Code: \n# ```python\nimport numpy as np\n\nclass AdaptiveDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_min, self.F_max = 0.5, 0.9  # Dynamic mutation factor range\n        self.CR_min, self.CR_max = 0.1, 0.9  # Dynamic crossover probability range\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (abs(v) ** (1/beta))\n        return step\n\n    def adapt_params(self, iteration, max_iterations):\n        adapt_factor = iteration / max_iterations\n        F = self.F_min + adapt_factor * (self.F_max - self.F_min)\n        CR = self.CR_max - adapt_factor * (self.CR_max - self.CR_min)\n        return F, CR\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        iteration = 0\n        while self.func_evals < self.budget:\n            F, CR = self.adapt_params(iteration, self.budget // self.population_size)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Refined Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n            iteration += 1\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:51:13.577702", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:51:26.668378", "content": "# Description: Enhanced Hybrid Differential Evolution with Dynamic Population Adaption and Lévy Flight for accelerated convergence in diverse optimization landscapes.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedHybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(dim * 2))  # Dynamic population size based on dimension\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_min, self.F_max = 0.5, 0.9  # Adaptive mutation factor range\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def dynamic_mutation_factor(self, normalized_budget):\n        return self.F_max - (self.F_max - self.F_min) * normalized_budget\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            normalized_budget = self.func_evals / self.budget\n            F = self.dynamic_mutation_factor(normalized_budget)\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:51:26.671756", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:51:35.558187", "content": "\n# Description: Enhanced Hybrid Differential Evolution with Adaptive Lévy Flight and Dynamic Population Size for improved convergence speed and adaptability.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedHybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population_size = self.base_population_size\n        self.adaptive_population = True  # New adaptive population flag\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def dynamic_population_adjustment(self):\n        if self.adaptive_population:\n            self.population_size = max(10, int(self.base_population_size * (1 - self.func_evals / self.budget)))\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.dynamic_population_adjustment()  # New dynamic adjustment call\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:51:35.561366", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:51:45.962649", "content": "# Description: Enhanced Differential Evolution with Dynamic Crossover and Adaptive Levy Step for Improved Convergence Speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Increase population size for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.9  # Increase DE Mutation factor for stronger mutation\n        self.CR_initial = 0.7  # Start with lower crossover probability\n        self.CR_final = 0.95  # Gradually increase CR over time\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.abs(v) ** (1 / beta)\n        return 0.01 * step  # Scale down the step size\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            CR = self.CR_initial + (self.CR_final - self.CR_initial) * (self.func_evals / self.budget)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:51:45.966173", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:51:54.171007", "content": "# Description: Hybrid Differential Evolution with Lévy flight and Adaptive Population Size to balance exploration and exploitation for faster convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass HybridDELevyAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population_size = 20\n        self.initial_population_size = self.population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def adapt_population(self):\n        if self.func_evals > self.budget * 0.5:\n            self.population_size = max(int(self.initial_population_size / 2), 5)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_population()\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:51:54.174569", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridDELevy: Hybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces. (Score: 0.3740534804657194)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Lévy Flight to enhance exploration and exploitation balance in high-dimensional spaces.\n\nWith code:\nimport numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # DE Mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1) * (L ** (-1/3))\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1/3))\n        return step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:52:03.797313", "content": "# Description: Enhanced Hybrid DE with Dynamic Population and Adaptive Parameters for Improved Convergence Speed in Black Box Optimization.\n# Code: \n```python\nimport numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.population_size = int(self.initial_population_size * 1.5)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.7  # Slightly reduced DE Mutation factor\n        self.CR = 0.8  # Reduced Crossover probability for diversity\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.5 + 0.3 * np.random.rand()  # Vary mutation factor\n        self.CR = 0.6 + 0.4 * np.random.rand()  # Vary crossover probability\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n```\n"}
{"role": "LLaMEA", "time": "2024-11-09 16:55:06.719359", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedHybridDE: Enhanced Hybrid DE with Dynamic Population and Adaptive Parameters for Improved Convergence Speed in Black Box Optimization. (Score: 0.40383754379577314)\n\nThe selected solution to update is:\nEnhanced Hybrid DE with Dynamic Population and Adaptive Parameters for Improved Convergence Speed in Black Box Optimization.\n\nWith code:\nimport numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.population_size = int(self.initial_population_size * 1.5)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.7  # Slightly reduced DE Mutation factor\n        self.CR = 0.8  # Reduced Crossover probability for diversity\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.5 + 0.3 * np.random.rand()  # Vary mutation factor\n        self.CR = 0.6 + 0.4 * np.random.rand()  # Vary crossover probability\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm EnhancedHybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.30.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:55:16.882077", "content": "# Description: Hybrid DE with Adaptive Opposition Strategy and Concentrated Exploitation for Faster Convergence in Black Box Optimization.\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveOppositionDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.population_size = int(self.initial_population_size * 1.2)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Slightly increased DE Mutation factor\n        self.CR = 0.9  # Increased Crossover probability for exploitation\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def opposition_based_learning(self, ind):\n        return self.lower_bound + self.upper_bound - ind\n\n    def adapt_parameters(self, iteration, max_iterations):\n        self.F = 0.5 + 0.5 * np.random.rand() * (1 - iteration / max_iterations)\n        self.CR = 0.7 + 0.3 * np.random.rand() * (iteration / max_iterations)\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n\n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        max_iterations = int(self.budget / self.population_size)\n        iteration = 0\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters(iteration, max_iterations)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Opposition-based learning\n                opposite_trial = self.opposition_based_learning(trial)\n                opposite_trial_score = evaluate(opposite_trial)\n\n                # Selection\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n                elif opposite_trial_score is not None and opposite_trial_score < self.scores[i]:\n                    self.population[i] = opposite_trial\n                    self.scores[i] = opposite_trial_score\n\n            iteration += 1\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:55:16.884867", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nEnhancedHybridDE: Enhanced Hybrid DE with Dynamic Population and Adaptive Parameters for Improved Convergence Speed in Black Box Optimization. (Score: 0.40383754379577314)\n\nThe selected solution to update is:\nEnhanced Hybrid DE with Dynamic Population and Adaptive Parameters for Improved Convergence Speed in Black Box Optimization.\n\nWith code:\nimport numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.population_size = int(self.initial_population_size * 1.5)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.7  # Slightly reduced DE Mutation factor\n        self.CR = 0.8  # Reduced Crossover probability for diversity\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.5 + 0.3 * np.random.rand()  # Vary mutation factor\n        self.CR = 0.6 + 0.4 * np.random.rand()  # Vary crossover probability\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm EnhancedHybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.30.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:55:28.783011", "content": "# Description: Adaptive Differential Evolution with Multi-Strategy Mutation and Dynamic Subpopulation for Accelerated Convergence.\n# Code: \n```python\nimport numpy as np\n\nclass AdaptiveMultiStrategyDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30  # Increased initial population for diversity\n        self.population_size = int(self.initial_population_size * 1.2)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Adjusted mutation factor for more stability\n        self.CR = 0.9  # Higher crossover probability to encourage exploration\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        beta = 1.7\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.4 + 0.4 * np.random.rand()  # Wider variation in mutation factor\n        self.CR = 0.7 + 0.3 * np.random.rand()  # Adjusted crossover range\n\n    def multi_strategy_mutation(self, best, idx):\n        if np.random.rand() < 0.5:\n            # DE/rand/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n        else:\n            # DE/best/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            best_indices = np.argsort(self.scores)[:5]  # Select top 5 as potential best\n            a, b = np.random.choice(best_indices, 2, replace=False)\n            c, d = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[c] + self.population[b] - self.population[d])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.multi_strategy_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n```"}
{"role": "LLaMEA", "time": "2024-11-09 16:58:58.374178", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveMultiStrategyDE: Adaptive Differential Evolution with Multi-Strategy Mutation and Dynamic Subpopulation for Accelerated Convergence. (Score: 0.41193693925860125)\n\nThe selected solution to update is:\nAdaptive Differential Evolution with Multi-Strategy Mutation and Dynamic Subpopulation for Accelerated Convergence.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveMultiStrategyDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30  # Increased initial population for diversity\n        self.population_size = int(self.initial_population_size * 1.2)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Adjusted mutation factor for more stability\n        self.CR = 0.9  # Higher crossover probability to encourage exploration\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        beta = 1.7\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.4 + 0.4 * np.random.rand()  # Wider variation in mutation factor\n        self.CR = 0.7 + 0.3 * np.random.rand()  # Adjusted crossover range\n\n    def multi_strategy_mutation(self, best, idx):\n        if np.random.rand() < 0.5:\n            # DE/rand/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n        else:\n            # DE/best/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            best_indices = np.argsort(self.scores)[:5]  # Select top 5 as potential best\n            a, b = np.random.choice(best_indices, 2, replace=False)\n            c, d = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[c] + self.population[b] - self.population[d])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.multi_strategy_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm AdaptiveMultiStrategyDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.32.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:59:13.668740", "content": "# Description: Synergistic Adaptive Differential Evolution integrating Lévy Flights and Dynamic Strategy Mutation to enhance convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass SynergisticAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Increased population size for exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.6  # Higher mutation factor for increased diversity\n        self.CR = 0.8  # Balanced crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.5 + 0.5 * np.random.rand()  # Enhanced mutation factor variability\n        self.CR = 0.6 + 0.4 * np.random.rand()  # Wider crossover probability range\n\n    def dynamic_strategy_mutation(self, best, idx):\n        mutation_choice = np.random.rand()\n        if mutation_choice < 0.3:\n            # DE/rand/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n        elif mutation_choice < 0.6:\n            # DE/best/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            best_indices = np.argsort(self.scores)[:5]  # Select top 5 as candidates\n            a, b = np.random.choice(best_indices, 2, replace=False)\n            c, d = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[c] + self.population[b] - self.population[d])\n        else:\n            # DE/current-to-best/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b = np.random.choice(indices, 2, replace=False)\n            return self.population[idx] + self.F * (best - self.population[idx]) + self.F * (self.population[a] - self.population[b])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n\n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.dynamic_strategy_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Lévy flight step for enhanced exploration\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:59:13.672043", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveMultiStrategyDE: Adaptive Differential Evolution with Multi-Strategy Mutation and Dynamic Subpopulation for Accelerated Convergence. (Score: 0.41193693925860125)\n\nThe selected solution to update is:\nAdaptive Differential Evolution with Multi-Strategy Mutation and Dynamic Subpopulation for Accelerated Convergence.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveMultiStrategyDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30  # Increased initial population for diversity\n        self.population_size = int(self.initial_population_size * 1.2)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Adjusted mutation factor for more stability\n        self.CR = 0.9  # Higher crossover probability to encourage exploration\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        beta = 1.7\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.4 + 0.4 * np.random.rand()  # Wider variation in mutation factor\n        self.CR = 0.7 + 0.3 * np.random.rand()  # Adjusted crossover range\n\n    def multi_strategy_mutation(self, best, idx):\n        if np.random.rand() < 0.5:\n            # DE/rand/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n        else:\n            # DE/best/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            best_indices = np.argsort(self.scores)[:5]  # Select top 5 as potential best\n            a, b = np.random.choice(best_indices, 2, replace=False)\n            c, d = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[c] + self.population[b] - self.population[d])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.multi_strategy_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm AdaptiveMultiStrategyDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.32.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:59:29.015369", "content": "# Description: Enhanced Adaptive Differential Evolution with Differential Strategy Mixing, Dynamic Archive, and Improved Parameter Adaptation.\n# Code: \n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 40  # Increased initial population for more diversity\n        self.population_size = int(self.initial_population_size * 1.3)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.6  # Fine-tuned mutation factor\n        self.CR = 0.8  # Adjusted crossover probability for better balance\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n        self.archive = []  # Introducing an archive to improve exploration\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.3 + 0.6 * np.random.rand()  # Increased range for mutation factor\n        self.CR = 0.6 + 0.4 * np.random.rand()  # Adjusted crossover range\n\n    def mixed_strategy_mutation(self, best, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        if np.random.rand() < 0.3:\n            # DE/rand/1 strategy\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n        elif np.random.rand() < 0.6:\n            # DE/best/2 strategy\n            best_indices = np.argsort(self.scores)[:5]\n            a, b = np.random.choice(best_indices, 2, replace=False)\n            c, d = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[c] + self.population[b] - self.population[d])\n        else:\n            # DE/current-to-best/1 strategy\n            a, b = np.random.choice(indices, 2, replace=False)\n            return self.population[idx] + self.F * (best - self.population[idx]) + self.F * (self.population[a] - self.population[b])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n\n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                    if len(self.archive) < self.population_size / 2:\n                        self.archive.append(ind.copy())\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.mixed_strategy_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                if np.random.rand() < 0.3:\n                    levy_step = self.levy_flight() * (trial - best)\n                    trial += levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and (trial_score < self.scores[i] or (self.archive and trial_score < min(self.scores))):\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:59:29.018370", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveMultiStrategyDE: Adaptive Differential Evolution with Multi-Strategy Mutation and Dynamic Subpopulation for Accelerated Convergence. (Score: 0.41193693925860125)\n\nThe selected solution to update is:\nAdaptive Differential Evolution with Multi-Strategy Mutation and Dynamic Subpopulation for Accelerated Convergence.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveMultiStrategyDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30  # Increased initial population for diversity\n        self.population_size = int(self.initial_population_size * 1.2)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Adjusted mutation factor for more stability\n        self.CR = 0.9  # Higher crossover probability to encourage exploration\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        beta = 1.7\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.4 + 0.4 * np.random.rand()  # Wider variation in mutation factor\n        self.CR = 0.7 + 0.3 * np.random.rand()  # Adjusted crossover range\n\n    def multi_strategy_mutation(self, best, idx):\n        if np.random.rand() < 0.5:\n            # DE/rand/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n        else:\n            # DE/best/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            best_indices = np.argsort(self.scores)[:5]  # Select top 5 as potential best\n            a, b = np.random.choice(best_indices, 2, replace=False)\n            c, d = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[c] + self.population[b] - self.population[d])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.multi_strategy_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm AdaptiveMultiStrategyDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.32.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:59:40.734339", "content": "# Description: Enhanced Differential Evolution with Dynamic Adaptive Strategies and Quantum-inspired Levy Flight for Accelerated Convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20  # Reduced initial population for quicker convergence\n        self.population_size = int(self.initial_population_size * 1.5)  # Adjusted for balance\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.6  # Increased mutation factor for better exploration\n        self.CR = 0.8  # Optimal crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def quantum_levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.3 + 0.5 * np.random.rand()  # More flexible mutation factor\n        self.CR = 0.6 + 0.4 * np.random.rand()  # Expanded crossover range\n\n    def multi_strategy_mutation(self, best, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        if np.random.rand() < 0.7:  # Bias towards DE/rand/1\n            # DE/rand/1 mutation\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n        else:\n            # DE/current-to-best/1 mutation\n            a, b = np.random.choice(indices, 2, replace=False)\n            return self.population[idx] + self.F * (best - self.population[idx]) + self.F * (self.population[a] - self.population[b])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.multi_strategy_mutation(best, i)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Quantum-inspired Lévy step\n                levy_step = self.quantum_levy_flight() * (best - trial)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:59:40.737674", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveMultiStrategyDE: Adaptive Differential Evolution with Multi-Strategy Mutation and Dynamic Subpopulation for Accelerated Convergence. (Score: 0.41193693925860125)\n\nThe selected solution to update is:\nAdaptive Differential Evolution with Multi-Strategy Mutation and Dynamic Subpopulation for Accelerated Convergence.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveMultiStrategyDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30  # Increased initial population for diversity\n        self.population_size = int(self.initial_population_size * 1.2)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Adjusted mutation factor for more stability\n        self.CR = 0.9  # Higher crossover probability to encourage exploration\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        beta = 1.7\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.4 + 0.4 * np.random.rand()  # Wider variation in mutation factor\n        self.CR = 0.7 + 0.3 * np.random.rand()  # Adjusted crossover range\n\n    def multi_strategy_mutation(self, best, idx):\n        if np.random.rand() < 0.5:\n            # DE/rand/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n        else:\n            # DE/best/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            best_indices = np.argsort(self.scores)[:5]  # Select top 5 as potential best\n            a, b = np.random.choice(best_indices, 2, replace=False)\n            c, d = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[c] + self.population[b] - self.population[d])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.multi_strategy_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm AdaptiveMultiStrategyDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.32.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 16:59:51.308875", "content": "# Description: Enhanced Adaptive Differential Evolution with Diversity Control and Opposition-Based Learning for Improved Convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 35  # Slightly increased for better exploration\n        self.population_size = int(self.initial_population_size * 1.3)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.6  # Increased mutation factor for stronger differential variation\n        self.CR = 0.85  # Increased exploration with a varied crossover\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def opposition_based_learning(self, individual):\n        return self.lower_bound + self.upper_bound - individual\n\n    def adapt_parameters(self):\n        self.F = 0.5 + 0.3 * np.random.rand()  # Adjusted mutation factor range\n        self.CR = 0.8 + 0.2 * np.random.rand()  # Refined crossover range\n\n    def multi_strategy_mutation(self, best, idx):\n        if np.random.rand() < 0.6:\n            # DE/best/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            best_indices = np.argsort(self.scores)[:5]\n            a, b = np.random.choice(best_indices, 2, replace=False)\n            c, d = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[c] + self.population[b] - self.population[d])\n        else:\n            # DE/rand/1/exp mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n            jrand = np.random.randint(0, self.dim)\n            crossover_mask = np.random.rand(self.dim) < self.CR\n            crossover_mask[jrand] = True\n            return np.where(crossover_mask, mutant, self.population[idx])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n\n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.multi_strategy_mutation(best, i)\n\n                # Crossover and Opposition-based Learning\n                opp_candidate = self.opposition_based_learning(self.population[i])\n                opp_score = evaluate(opp_candidate)\n                if opp_score is not None and opp_score < self.scores[i]:\n                    self.population[i] = opp_candidate\n                    self.scores[i] = opp_score\n\n                trial_score = evaluate(mutant)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = mutant\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 16:59:51.311594", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveMultiStrategyDE: Adaptive Differential Evolution with Multi-Strategy Mutation and Dynamic Subpopulation for Accelerated Convergence. (Score: 0.41193693925860125)\n\nThe selected solution to update is:\nAdaptive Differential Evolution with Multi-Strategy Mutation and Dynamic Subpopulation for Accelerated Convergence.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveMultiStrategyDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30  # Increased initial population for diversity\n        self.population_size = int(self.initial_population_size * 1.2)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Adjusted mutation factor for more stability\n        self.CR = 0.9  # Higher crossover probability to encourage exploration\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        beta = 1.7\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.4 + 0.4 * np.random.rand()  # Wider variation in mutation factor\n        self.CR = 0.7 + 0.3 * np.random.rand()  # Adjusted crossover range\n\n    def multi_strategy_mutation(self, best, idx):\n        if np.random.rand() < 0.5:\n            # DE/rand/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n        else:\n            # DE/best/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            best_indices = np.argsort(self.scores)[:5]  # Select top 5 as potential best\n            a, b = np.random.choice(best_indices, 2, replace=False)\n            c, d = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[c] + self.population[b] - self.population[d])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.multi_strategy_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm AdaptiveMultiStrategyDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.32.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:00:03.219827", "content": "# Description: Enhanced Adaptive Differential Evolution with Dynamic Population Resizing and Randomization of Parameters for Improved Convergence Speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 40  # Further increased initial population for exploration\n        self.population_size = self.initial_population_size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.6  # Slightly higher mutation factor for increased diversity\n        self.CR = 0.8  # Modified crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.5  # Adjusted beta for Lévy flight\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = np.random.uniform(0.3, 0.8)  # Randomized mutation factor within range\n        self.CR = np.random.uniform(0.6, 0.9)  # Randomized crossover probability\n\n    def dynamic_population_resize(self):\n        if self.func_evals / self.budget > 0.5:\n            self.population_size = max(10, int(self.initial_population_size * 0.7))  # Reduce population to focus on exploitation\n\n    def multi_strategy_mutation(self, best, idx):\n        if np.random.rand() < 0.3:\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[b])  # DE/best/1 mutation\n        else:\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            best_indices = np.argsort(self.scores)[:3]  # Select top 3 as potential best\n            a, b = np.random.choice(best_indices, 2, replace=False)\n            c, d = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[c] + self.population[b] - self.population[d])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            self.dynamic_population_resize()\n            for i in range(self.population_size):\n                mutant = self.multi_strategy_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 17:00:03.222831", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveMultiStrategyDE: Adaptive Differential Evolution with Multi-Strategy Mutation and Dynamic Subpopulation for Accelerated Convergence. (Score: 0.41193693925860125)\n\nThe selected solution to update is:\nAdaptive Differential Evolution with Multi-Strategy Mutation and Dynamic Subpopulation for Accelerated Convergence.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveMultiStrategyDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30  # Increased initial population for diversity\n        self.population_size = int(self.initial_population_size * 1.2)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Adjusted mutation factor for more stability\n        self.CR = 0.9  # Higher crossover probability to encourage exploration\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        beta = 1.7\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.4 + 0.4 * np.random.rand()  # Wider variation in mutation factor\n        self.CR = 0.7 + 0.3 * np.random.rand()  # Adjusted crossover range\n\n    def multi_strategy_mutation(self, best, idx):\n        if np.random.rand() < 0.5:\n            # DE/rand/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n        else:\n            # DE/best/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            best_indices = np.argsort(self.scores)[:5]  # Select top 5 as potential best\n            a, b = np.random.choice(best_indices, 2, replace=False)\n            c, d = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[c] + self.population[b] - self.population[d])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.multi_strategy_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm AdaptiveMultiStrategyDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.32.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:00:16.815395", "content": "# Description: Hybrid Differential Evolution with Dynamic Learning and Adaptive Parameters for Enhanced Convergence Speed.\n# Code: \n```python\nimport numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Increase population for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.3  # Lower initial mutation factor for better stability\n        self.CR = 0.8  # Crossover probability to balance exploration and exploitation\n        self.alpha = 0.3  # Weight for history learning\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n        self.history = np.zeros((self.population_size, dim))  # History buffer for learning\n\n    def adapt_parameters(self):\n        self.F = 0.2 + 0.5 * np.random.rand()  # Broader mutation factor range\n        self.CR = 0.6 + 0.4 * np.random.rand()  # Enhanced crossover variability\n\n    def multi_strategy_mutation(self, best, idx):\n        if np.random.rand() < 0.6:\n            # DE/rand/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c, d, e = np.random.choice(indices, 5, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c] + self.population[d] - self.population[e])\n        else:\n            # DE/best/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[b])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.multi_strategy_mutation(best, i)\n\n                # Crossover with dynamic learning\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n                trial = trial + self.alpha * self.history[i]  # Learning from history\n\n                # Selection\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.history[i] = trial - self.population[i]  # Update history\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n```"}
{"role": "LLaMEA", "time": "2024-11-09 17:03:10.404206", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveMultiStrategyDE: Adaptive Differential Evolution with Multi-Strategy Mutation and Dynamic Subpopulation for Accelerated Convergence. (Score: 0.41193693925860125)\n\nThe selected solution to update is:\nAdaptive Differential Evolution with Multi-Strategy Mutation and Dynamic Subpopulation for Accelerated Convergence.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveMultiStrategyDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30  # Increased initial population for diversity\n        self.population_size = int(self.initial_population_size * 1.2)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Adjusted mutation factor for more stability\n        self.CR = 0.9  # Higher crossover probability to encourage exploration\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        beta = 1.7\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.4 + 0.4 * np.random.rand()  # Wider variation in mutation factor\n        self.CR = 0.7 + 0.3 * np.random.rand()  # Adjusted crossover range\n\n    def multi_strategy_mutation(self, best, idx):\n        if np.random.rand() < 0.5:\n            # DE/rand/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n        else:\n            # DE/best/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            best_indices = np.argsort(self.scores)[:5]  # Select top 5 as potential best\n            a, b = np.random.choice(best_indices, 2, replace=False)\n            c, d = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[c] + self.population[b] - self.population[d])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.multi_strategy_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm AdaptiveMultiStrategyDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.32.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:03:23.634583", "content": "# Description: Enhanced Adaptive DE with Dynamic Fitness-Based Parameter Control and Chaos-Induced Diversity for Accelerated Convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveMultiStrategyDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50  # Increased population size for enhanced exploration\n        self.population_size = int(self.initial_population_size)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def chaos_induced_diversity(self):\n        return np.random.uniform(-0.5, 0.5, self.dim)\n\n    def dynamic_parameter_control(self):\n        mean_score = np.mean(self.scores)\n        self.F = 0.3 + 0.7 * (mean_score / (mean_score + 1))\n        self.CR = 0.5 + 0.5 * (1 - mean_score / (mean_score + 1))\n    \n    def multi_strategy_mutation(self, best, idx):\n        if np.random.rand() < 0.5:\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c]) + self.chaos_induced_diversity()\n        else:\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            best_indices = np.argsort(self.scores)[:5]\n            a, b = np.random.choice(best_indices, 2, replace=False)\n            c, d = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[c] + self.population[b] - self.population[d]) + self.chaos_induced_diversity()\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.dynamic_parameter_control()  # Adjust based on fitness scores\n            for i in range(self.population_size):\n                mutant = self.multi_strategy_mutation(best, i)\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 17:03:23.638141", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveMultiStrategyDE: Adaptive Differential Evolution with Multi-Strategy Mutation and Dynamic Subpopulation for Accelerated Convergence. (Score: 0.41193693925860125)\n\nThe selected solution to update is:\nAdaptive Differential Evolution with Multi-Strategy Mutation and Dynamic Subpopulation for Accelerated Convergence.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveMultiStrategyDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30  # Increased initial population for diversity\n        self.population_size = int(self.initial_population_size * 1.2)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Adjusted mutation factor for more stability\n        self.CR = 0.9  # Higher crossover probability to encourage exploration\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        beta = 1.7\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.4 + 0.4 * np.random.rand()  # Wider variation in mutation factor\n        self.CR = 0.7 + 0.3 * np.random.rand()  # Adjusted crossover range\n\n    def multi_strategy_mutation(self, best, idx):\n        if np.random.rand() < 0.5:\n            # DE/rand/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n        else:\n            # DE/best/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            best_indices = np.argsort(self.scores)[:5]  # Select top 5 as potential best\n            a, b = np.random.choice(best_indices, 2, replace=False)\n            c, d = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[c] + self.population[b] - self.population[d])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.multi_strategy_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm AdaptiveMultiStrategyDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.32.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:03:39.269025", "content": "# Description: Hybrid Differential Evolution with Adaptive Lévy Adjustments and Enhanced Selection for Improved Convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass HybridDEWithLevyAdjustments:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 40  # Increased for greater diversity\n        self.population_size = self.initial_population_size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.6  # Moderate mutation factor to balance exploration and exploitation\n        self.CR = 0.8  # Balanced crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.5 + 0.5 * np.random.rand()  # Greater variation in mutation factor\n        self.CR = 0.6 + 0.4 * np.random.rand()  # Wider crossover range\n\n    def select_best_candidates(self):\n        top_indices = np.argsort(self.scores)[:int(0.2 * self.population_size)]\n        return top_indices\n\n    def multi_strategy_mutation(self, best, idx):\n        if np.random.rand() < 0.5:\n            # DE/rand/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n        else:\n            # DE/best/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            best_indices = self.select_best_candidates()\n            a, b = np.random.choice(best_indices, 2, replace=False)\n            c, d = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[c] + self.population[b] - self.population[d])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.multi_strategy_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + 0.5 * levy_step  # Adjust step size\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n                elif np.random.rand() < 0.1:  # Small chance to replace worse solutions\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 17:03:39.272149", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveMultiStrategyDE: Adaptive Differential Evolution with Multi-Strategy Mutation and Dynamic Subpopulation for Accelerated Convergence. (Score: 0.41193693925860125)\n\nThe selected solution to update is:\nAdaptive Differential Evolution with Multi-Strategy Mutation and Dynamic Subpopulation for Accelerated Convergence.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveMultiStrategyDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30  # Increased initial population for diversity\n        self.population_size = int(self.initial_population_size * 1.2)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Adjusted mutation factor for more stability\n        self.CR = 0.9  # Higher crossover probability to encourage exploration\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        beta = 1.7\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.4 + 0.4 * np.random.rand()  # Wider variation in mutation factor\n        self.CR = 0.7 + 0.3 * np.random.rand()  # Adjusted crossover range\n\n    def multi_strategy_mutation(self, best, idx):\n        if np.random.rand() < 0.5:\n            # DE/rand/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n        else:\n            # DE/best/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            best_indices = np.argsort(self.scores)[:5]  # Select top 5 as potential best\n            a, b = np.random.choice(best_indices, 2, replace=False)\n            c, d = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[c] + self.population[b] - self.population[d])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.multi_strategy_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm AdaptiveMultiStrategyDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.32.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:03:59.073212", "content": "# Description: Enhanced Adaptive Differential Evolution with Dynamic Strategy Selection and Quantum-inspired Search for Accelerated Convergence.\n# Code: \n```python\nimport numpy as np\n\nclass QuantumAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Increased population size for better exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Base mutation factor\n        self.CR = 0.9  # Base crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        beta = 1.5  # Adjusted to explore different step sizes\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def quantum_search(self, current, best):\n        return current + 0.01 * np.random.randn(self.dim) * (best - current)  # Quantum-inspired local search\n\n    def adapt_parameters(self):\n        if self.func_evals < self.budget * 0.5:\n            self.F = 0.5 + 0.3 * np.random.rand()  # Higher variation in early phase\n            self.CR = 0.8 + 0.2 * np.random.rand()  # Adjusted for early exploration\n        else:\n            self.F = 0.3 + 0.2 * np.random.rand()  # Tighter range in later phase\n            self.CR = 0.9  # Focus on exploitation\n\n    def dynamic_strategy_mutation(self, best, idx):\n        if np.random.rand() < 0.5:\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n        else:\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            best_indices = np.argsort(self.scores)[:3]  # Focus on top 3 solutions\n            a, b = np.random.choice(best_indices, 2, replace=False)\n            c, d = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[c] + self.population[b] - self.population[d])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.dynamic_strategy_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Quantum-inspired search addition\n                quantum_trial = self.quantum_search(trial, best)\n                trial = np.clip(quantum_trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n```"}
{"role": "LLaMEA", "time": "2024-11-09 17:07:21.271639", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveMultiStrategyDE: Adaptive Differential Evolution with Multi-Strategy Mutation and Dynamic Subpopulation for Accelerated Convergence. (Score: 0.41193693925860125)\n\nThe selected solution to update is:\nAdaptive Differential Evolution with Multi-Strategy Mutation and Dynamic Subpopulation for Accelerated Convergence.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveMultiStrategyDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30  # Increased initial population for diversity\n        self.population_size = int(self.initial_population_size * 1.2)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Adjusted mutation factor for more stability\n        self.CR = 0.9  # Higher crossover probability to encourage exploration\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        beta = 1.7\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.4 + 0.4 * np.random.rand()  # Wider variation in mutation factor\n        self.CR = 0.7 + 0.3 * np.random.rand()  # Adjusted crossover range\n\n    def multi_strategy_mutation(self, best, idx):\n        if np.random.rand() < 0.5:\n            # DE/rand/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n        else:\n            # DE/best/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            best_indices = np.argsort(self.scores)[:5]  # Select top 5 as potential best\n            a, b = np.random.choice(best_indices, 2, replace=False)\n            c, d = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[c] + self.population[b] - self.population[d])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.multi_strategy_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm AdaptiveMultiStrategyDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.32.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:07:30.639591", "content": "# Description: Enhanced Adaptive Differential Evolution with Novel Quantum-inspired Mutation and Adaptive Levy Strategy for Accelerated Convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 36  # Increased and adaptive population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.45  # Fine-tuned mutation factor\n        self.CR = 0.85  # Slightly reduced crossover probability for better balance\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def adaptive_levy_flight(self):\n        beta = 1.5 + 0.2 * np.random.rand()  # Adaptive beta value\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def quantum_mutation(self, best, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b = np.random.choice(indices, 2, replace=False)\n        q = np.random.normal(0, 1, self.dim)  # Quantum-inspired component\n        return self.population[a] + self.F * q * (self.population[b] - self.population[idx])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < 0.5:\n                    mutant = self.quantum_mutation(best, i)\n                else:\n                    mutant = self.population[i] + self.F * (best - self.population[i])\n\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                levy_step = self.adaptive_levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 17:07:30.642400", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveMultiStrategyDE: Adaptive Differential Evolution with Multi-Strategy Mutation and Dynamic Subpopulation for Accelerated Convergence. (Score: 0.41193693925860125)\n\nThe selected solution to update is:\nAdaptive Differential Evolution with Multi-Strategy Mutation and Dynamic Subpopulation for Accelerated Convergence.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveMultiStrategyDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30  # Increased initial population for diversity\n        self.population_size = int(self.initial_population_size * 1.2)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Adjusted mutation factor for more stability\n        self.CR = 0.9  # Higher crossover probability to encourage exploration\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        beta = 1.7\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.4 + 0.4 * np.random.rand()  # Wider variation in mutation factor\n        self.CR = 0.7 + 0.3 * np.random.rand()  # Adjusted crossover range\n\n    def multi_strategy_mutation(self, best, idx):\n        if np.random.rand() < 0.5:\n            # DE/rand/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n        else:\n            # DE/best/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            best_indices = np.argsort(self.scores)[:5]  # Select top 5 as potential best\n            a, b = np.random.choice(best_indices, 2, replace=False)\n            c, d = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[c] + self.population[b] - self.population[d])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.multi_strategy_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm AdaptiveMultiStrategyDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.32.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:07:43.854770", "content": "Certainly! Here's a 40.0% transformed version of the original code with enhancements to improve convergence speed, incorporating new strategies and adaptations to the algorithm:\n\n# Description: Hybrid Adaptive Differential Evolution with Memory-Based Strategies and Chaotic Local Search for Enhanced Convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 40  # Larger initial population for exploration\n        self.population_size = int(self.initial_population_size * 1.1)  # Adjusted size for balance\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_memory = [0.5] * self.population_size  # Memory for mutation factors\n        self.CR_memory = [0.9] * self.population_size  # Memory for crossover rates\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def chaotic_local_search(self, individual):\n        chaotic_factor = 0.9 * np.random.rand() + 0.1\n        return individual + chaotic_factor * (np.random.rand(self.dim) - 0.5)\n\n    def memory_adaptation(self, idx):\n        self.F_memory[idx] = 0.3 + 0.5 * np.random.rand()\n        self.CR_memory[idx] = 0.6 + 0.4 * np.random.rand()\n\n    def hybrid_mutation(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() < 0.7:\n            mutant = self.population[a] + self.F_memory[idx] * (self.population[b] - self.population[c])\n        else:\n            best = self.population[np.argmin(self.scores)]\n            d, e = np.random.choice(indices, 2, replace=False)\n            mutant = best + self.F_memory[idx] * (self.population[a] - self.population[d] + self.population[b] - self.population[e])\n        return mutant\n\n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.scores[i] = func(self.population[i])\n            self.func_evals += 1\n            if self.scores[i] < self.global_best_score:\n                self.global_best_score = self.scores[i]\n                self.global_best = self.population[i].copy()\n\n        while self.func_evals < self.budget:\n            for i in range(self.population_size):\n                self.memory_adaptation(i)\n                mutant = self.hybrid_mutation(i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR_memory[i]\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Chaotic local search\n                if np.random.rand() < 0.2:\n                    trial = self.chaotic_local_search(trial)\n\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best = trial.copy()\n\n        return self.global_best, self.global_best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 17:07:43.857239", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveMultiStrategyDE: Adaptive Differential Evolution with Multi-Strategy Mutation and Dynamic Subpopulation for Accelerated Convergence. (Score: 0.41193693925860125)\n\nThe selected solution to update is:\nAdaptive Differential Evolution with Multi-Strategy Mutation and Dynamic Subpopulation for Accelerated Convergence.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveMultiStrategyDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30  # Increased initial population for diversity\n        self.population_size = int(self.initial_population_size * 1.2)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Adjusted mutation factor for more stability\n        self.CR = 0.9  # Higher crossover probability to encourage exploration\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        beta = 1.7\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.4 + 0.4 * np.random.rand()  # Wider variation in mutation factor\n        self.CR = 0.7 + 0.3 * np.random.rand()  # Adjusted crossover range\n\n    def multi_strategy_mutation(self, best, idx):\n        if np.random.rand() < 0.5:\n            # DE/rand/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n        else:\n            # DE/best/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            best_indices = np.argsort(self.scores)[:5]  # Select top 5 as potential best\n            a, b = np.random.choice(best_indices, 2, replace=False)\n            c, d = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[c] + self.population[b] - self.population[d])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.multi_strategy_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm AdaptiveMultiStrategyDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.32.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:07:56.212034", "content": "# Description: Hybridized Adaptive Differential Evolution with Novel Levy-based Exploitation and Dynamic Population Resizing.\n# Code: \n# ```python\nimport numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 40  # Further increased initial population for more diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.func_evals = 0\n        self.dynamic_population_size = self.initial_population_size\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, L):\n        beta = 1.5  # Adjusted for exploration-exploitation balance\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step * np.random.normal(0, 1, self.dim)\n\n    def adapt_parameters(self):\n        self.F = 0.3 + 0.5 * np.random.rand()  # Further variation for adaptive mutation\n        self.CR = 0.6 + 0.4 * np.random.rand()  # Increased range for crossover\n\n    def multi_strategy_mutation(self, best_idx):\n        indices = list(range(self.dynamic_population_size))\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() < 0.6:  # Favor DE/rand/1\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[best_idx] + self.F * (self.population[a] - self.population[b])  # DE/best/1\n\n    def dynamic_population_resize(self):\n        # Gradually reduce population size for focused search\n        self.dynamic_population_size = max(4, int(self.initial_population_size * (1 - 0.5 * (self.func_evals / self.budget))))\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n\n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.initial_population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            self.dynamic_population_resize()\n            for i in range(self.dynamic_population_size):\n                best_idx = np.argmin(self.scores[:self.dynamic_population_size])\n                mutant = self.multi_strategy_mutation(best_idx)\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                levy_step = self.levy_flight(1.5)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n```"}
{"role": "LLaMEA", "time": "2024-11-09 17:11:19.322075", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveMultiStrategyDE: Adaptive Differential Evolution with Multi-Strategy Mutation and Dynamic Subpopulation for Accelerated Convergence. (Score: 0.41193693925860125)\n\nThe selected solution to update is:\nAdaptive Differential Evolution with Multi-Strategy Mutation and Dynamic Subpopulation for Accelerated Convergence.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveMultiStrategyDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30  # Increased initial population for diversity\n        self.population_size = int(self.initial_population_size * 1.2)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Adjusted mutation factor for more stability\n        self.CR = 0.9  # Higher crossover probability to encourage exploration\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        beta = 1.7\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.4 + 0.4 * np.random.rand()  # Wider variation in mutation factor\n        self.CR = 0.7 + 0.3 * np.random.rand()  # Adjusted crossover range\n\n    def multi_strategy_mutation(self, best, idx):\n        if np.random.rand() < 0.5:\n            # DE/rand/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n        else:\n            # DE/best/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            best_indices = np.argsort(self.scores)[:5]  # Select top 5 as potential best\n            a, b = np.random.choice(best_indices, 2, replace=False)\n            c, d = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[c] + self.population[b] - self.population[d])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.multi_strategy_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm AdaptiveMultiStrategyDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.32.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:11:36.080266", "content": "# Description: Adaptive Differential Evolution with Fitness-based Adaptive Parameters and Gaussian Mutation for Enhanced Convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveMultiStrategyDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 40  # Increased initial population for better exploration\n        self.population_size = int(self.initial_population_size * 1.1)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Default mutation factor\n        self.CR = 0.9  # Default crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def gaussian_mutation(self, individual):\n        # Gaussian mutation with small standard deviation for local search\n        mutation_strength = 0.1  # Reduced mutation strength\n        return individual + np.random.normal(0, mutation_strength, self.dim)\n\n    def update_parameters(self, best_score, worst_score):\n        # Adapt parameters based on fitness scores\n        fitness_range = worst_score - best_score\n        self.F = 0.5 + 0.2 * (1 - (best_score / fitness_range))\n        self.CR = 0.8 + 0.1 * (best_score / fitness_range)\n\n    def multi_strategy_mutation(self, best, idx):\n        if np.random.rand() < 0.5:\n            # DE/rand/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n        else:\n            # DE/best/2 mutation including Gaussian mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            best_indices = np.argsort(self.scores)[:5]  # Select top 5 as potential best\n            a, b = np.random.choice(best_indices, 2, replace=False)\n            c, d = np.random.choice(indices, 2, replace=False)\n            mutant = best + self.F * (self.population[a] - self.population[c] + self.population[b] - self.population[d])\n            return self.gaussian_mutation(mutant)\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        worst_score = -np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score, worst_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                if score > worst_score:\n                    worst_score = score\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.update_parameters(best_score, worst_score)\n            for i in range(self.population_size):\n                mutant = self.multi_strategy_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Ensure bounds\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 17:11:36.083575", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveMultiStrategyDE: Adaptive Differential Evolution with Multi-Strategy Mutation and Dynamic Subpopulation for Accelerated Convergence. (Score: 0.41193693925860125)\n\nThe selected solution to update is:\nAdaptive Differential Evolution with Multi-Strategy Mutation and Dynamic Subpopulation for Accelerated Convergence.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveMultiStrategyDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30  # Increased initial population for diversity\n        self.population_size = int(self.initial_population_size * 1.2)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Adjusted mutation factor for more stability\n        self.CR = 0.9  # Higher crossover probability to encourage exploration\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        beta = 1.7\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.4 + 0.4 * np.random.rand()  # Wider variation in mutation factor\n        self.CR = 0.7 + 0.3 * np.random.rand()  # Adjusted crossover range\n\n    def multi_strategy_mutation(self, best, idx):\n        if np.random.rand() < 0.5:\n            # DE/rand/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n        else:\n            # DE/best/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            best_indices = np.argsort(self.scores)[:5]  # Select top 5 as potential best\n            a, b = np.random.choice(best_indices, 2, replace=False)\n            c, d = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[c] + self.population[b] - self.population[d])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.multi_strategy_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm AdaptiveMultiStrategyDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.32.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:11:48.162435", "content": "# Description: Hybrid Adaptive Differential Evolution with Competitive Selection and Mutation Strategy for Enhanced Convergence.\n# Code: \n# ```python\nimport numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 40  # Increased population for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.6  # Adjusted mutation factor for balanced exploration\n        self.CR = 0.8  # Balanced crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.5 + 0.3 * np.random.rand()  # Slightly narrower mutation factor range\n        self.CR = 0.6 + 0.4 * np.random.rand()  # Increased crossover range\n\n    def competitive_selection(self, trial_score, current_score):\n        return trial_score < current_score\n\n    def multi_strategy_mutation(self, best, idx):\n        if np.random.rand() < 0.4:\n            # DE/rand/1 mutation\n            indices = list(range(self.initial_population_size))\n            indices.remove(idx)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n        else:\n            # DE/best/1 with competitive mutation\n            indices = list(range(self.initial_population_size))\n            indices.remove(idx)\n            best_indices = np.argsort(self.scores)[:5]  # Select top 5 as potential best\n            a = np.random.choice(best_indices)\n            c, d = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[c] + self.population[b] - self.population[d])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.initial_population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.initial_population_size):\n                mutant = self.multi_strategy_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Lévy flight step for global exploration\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection with competitive selection strategy\n                trial_score = evaluate(trial)\n                if trial_score is not None and self.competitive_selection(trial_score, self.scores[i]):\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n```"}
{"role": "LLaMEA", "time": "2024-11-09 17:11:48.169995", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveMultiStrategyDE: Adaptive Differential Evolution with Multi-Strategy Mutation and Dynamic Subpopulation for Accelerated Convergence. (Score: 0.41193693925860125)\n\nThe selected solution to update is:\nAdaptive Differential Evolution with Multi-Strategy Mutation and Dynamic Subpopulation for Accelerated Convergence.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveMultiStrategyDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30  # Increased initial population for diversity\n        self.population_size = int(self.initial_population_size * 1.2)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Adjusted mutation factor for more stability\n        self.CR = 0.9  # Higher crossover probability to encourage exploration\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        beta = 1.7\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.4 + 0.4 * np.random.rand()  # Wider variation in mutation factor\n        self.CR = 0.7 + 0.3 * np.random.rand()  # Adjusted crossover range\n\n    def multi_strategy_mutation(self, best, idx):\n        if np.random.rand() < 0.5:\n            # DE/rand/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n        else:\n            # DE/best/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            best_indices = np.argsort(self.scores)[:5]  # Select top 5 as potential best\n            a, b = np.random.choice(best_indices, 2, replace=False)\n            c, d = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[c] + self.population[b] - self.population[d])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.multi_strategy_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm AdaptiveMultiStrategyDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.32.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:11:58.939798", "content": "# Description: Adaptive Swarm-Inspired Differential Evolution with Dynamic Subpopulation and Enhanced Exploration through Gaussian Mutation.\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveSwarmDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 40  # Higher initial population size for more diversity\n        self.population_size = int(self.initial_population_size * 1.1)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.6  # Adjusted mutation factor for balanced exploration\n        self.CR = 0.8  # Moderate crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def gaussian_mutation(self, individual, scale=0.1):\n        mutation = np.random.normal(0, scale, self.dim)\n        return np.clip(individual + mutation, self.lower_bound, self.upper_bound)\n\n    def adapt_parameters(self):\n        self.F = 0.5 + 0.3 * np.random.rand()  # Slightly reduced variation in mutation factor\n        self.CR = 0.6 + 0.4 * np.random.rand()  # Higher variation in crossover range\n\n    def multi_strategy_mutation(self, best, idx):\n        if np.random.rand() < 0.7:\n            # DE/rand/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n        else:\n            # DE/best/1 mutation with Gaussian\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            best_indices = np.argsort(self.scores)[:5]  # Select top 5 as potential best\n            a = np.random.choice(best_indices, 1, replace=False)\n            c = np.random.choice(indices, 1, replace=False)\n            return best + self.F * (self.population[a] - self.population[c]) + self.gaussian_mutation(best)\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.multi_strategy_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 17:11:58.943188", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveMultiStrategyDE: Adaptive Differential Evolution with Multi-Strategy Mutation and Dynamic Subpopulation for Accelerated Convergence. (Score: 0.41193693925860125)\n\nThe selected solution to update is:\nAdaptive Differential Evolution with Multi-Strategy Mutation and Dynamic Subpopulation for Accelerated Convergence.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveMultiStrategyDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30  # Increased initial population for diversity\n        self.population_size = int(self.initial_population_size * 1.2)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Adjusted mutation factor for more stability\n        self.CR = 0.9  # Higher crossover probability to encourage exploration\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, L):\n        beta = 1.7\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.4 + 0.4 * np.random.rand()  # Wider variation in mutation factor\n        self.CR = 0.7 + 0.3 * np.random.rand()  # Adjusted crossover range\n\n    def multi_strategy_mutation(self, best, idx):\n        if np.random.rand() < 0.5:\n            # DE/rand/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n        else:\n            # DE/best/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            best_indices = np.argsort(self.scores)[:5]  # Select top 5 as potential best\n            a, b = np.random.choice(best_indices, 2, replace=False)\n            c, d = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[c] + self.population[b] - self.population[d])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.multi_strategy_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight(1.5) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm AdaptiveMultiStrategyDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.32.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:12:12.766814", "content": "# Description: Hybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence.\n# Code: \n```python\nimport numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 40  # Increased initial population for greater diversity\n        self.population_size = int(self.initial_population_size * 1.25)  # Slightly larger population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.6  # Adjusted mutation factor for improved convergence\n        self.CR = 0.8  # Balanced crossover probability for exploration and exploitation\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.5 + 0.5 * np.random.rand()  # Dynamic mutation factor for varied search behavior\n        self.CR = 0.6 + 0.4 * np.random.rand()  # Flexible crossover range for adaptability\n\n    def enhanced_mutation(self, best, idx):\n        if np.random.rand() < 0.6:\n            # DE/rand/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c, d, e = np.random.choice(indices, 5, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c] + self.population[d] - self.population[e])\n        else:\n            # DE/best/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[b])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n```"}
{"role": "LLaMEA", "time": "2024-11-09 17:15:32.640038", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridAdaptiveDE: Hybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence. (Score: 0.43077864873777105)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence.\n\nWith code:\nimport numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 40  # Increased initial population for greater diversity\n        self.population_size = int(self.initial_population_size * 1.25)  # Slightly larger population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.6  # Adjusted mutation factor for improved convergence\n        self.CR = 0.8  # Balanced crossover probability for exploration and exploitation\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.5 + 0.5 * np.random.rand()  # Dynamic mutation factor for varied search behavior\n        self.CR = 0.6 + 0.4 * np.random.rand()  # Flexible crossover range for adaptability\n\n    def enhanced_mutation(self, best, idx):\n        if np.random.rand() < 0.6:\n            # DE/rand/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c, d, e = np.random.choice(indices, 5, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c] + self.population[d] - self.population[e])\n        else:\n            # DE/best/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[b])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.30.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:15:54.456765", "content": "# Description: Hybrid Differential Evolution with Adaptive Learning and Dual-Levy Exploration for Enhanced Convergence.\n# Code:\n```python\nimport numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50  # Increased initial population for enhanced exploration\n        self.population_size = int(self.initial_population_size * 1.2)  # Slightly adjusted population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.7  # Increased mutation factor for broader search\n        self.CR = 0.7  # Adjusted crossover probability for balance\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def dual_levy_flight(self):\n        beta1, beta2 = 1.5, 3.0\n        sigma_u1 = (np.math.gamma(1 + beta1) * np.sin(np.pi * beta1 / 2) /\n                   (np.math.gamma((1 + beta1) / 2) * beta1 * 2 ** ((beta1 - 1) / 2))) ** (1 / beta1)\n        sigma_u2 = (np.math.gamma(1 + beta2) * np.sin(np.pi * beta2 / 2) /\n                   (np.math.gamma((1 + beta2) / 2) * beta2 * 2 ** ((beta2 - 1) / 2))) ** (1 / beta2)\n        u1, u2 = np.random.normal(0, sigma_u1), np.random.normal(0, sigma_u2)\n        v = np.random.normal(0, 1)\n        step1 = u1 / (abs(v) ** (1 / beta1))\n        step2 = u2 / (abs(v) ** (1 / beta2))\n        return step1, step2\n\n    def adapt_parameters(self):\n        self.F = 0.4 + 0.6 * np.random.rand()  # Dynamic mutation factor for varied search behavior\n        self.CR = 0.5 + 0.5 * np.random.rand()  # Flexible crossover range for adaptability\n\n    def enhanced_mutation(self, best, idx):\n        if np.random.rand() < 0.7:\n            # DE/rand/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c, d, e = np.random.choice(indices, 5, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c] + self.population[d] - self.population[e])\n        else:\n            # DE/best/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[b])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Dual Lévy flight step\n                levy_step1, levy_step2 = self.dual_levy_flight()\n                trial = trial + levy_step1 * (trial - best) + levy_step2 * np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n```"}
{"role": "LLaMEA", "time": "2024-11-09 17:18:39.072819", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridAdaptiveDE: Hybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence. (Score: 0.43077864873777105)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence.\n\nWith code:\nimport numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 40  # Increased initial population for greater diversity\n        self.population_size = int(self.initial_population_size * 1.25)  # Slightly larger population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.6  # Adjusted mutation factor for improved convergence\n        self.CR = 0.8  # Balanced crossover probability for exploration and exploitation\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.5 + 0.5 * np.random.rand()  # Dynamic mutation factor for varied search behavior\n        self.CR = 0.6 + 0.4 * np.random.rand()  # Flexible crossover range for adaptability\n\n    def enhanced_mutation(self, best, idx):\n        if np.random.rand() < 0.6:\n            # DE/rand/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c, d, e = np.random.choice(indices, 5, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c] + self.population[d] - self.population[e])\n        else:\n            # DE/best/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[b])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.30.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:18:58.843120", "content": "# Description: Enhanced Adaptive Differential Evolution with Quantum-Inspired Sampling and Gradient-Based Local Search for Accelerated Convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedQuantumGradientDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30  # Adjusted initial population for better balance\n        self.population_size = int(self.initial_population_size * 1.5)  # Increased population size for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.7  # Increased mutation factor for greater exploration\n        self.CR = 0.9  # Higher crossover probability to maintain diversity\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.4 + 0.6 * np.random.rand()  # Enhanced dynamic mutation for diverse search\n        self.CR = 0.5 + 0.5 * np.random.rand()  # Adaptive crossover for improved balance\n\n    def quantum_sampling(self, best, idx):\n        sigma = 0.1  # Small variance for localized search around the best\n        return best + sigma * np.random.randn(self.dim)\n\n    def gradient_local_search(self, individual):\n        # Apply a simple gradient descent step for local refinement\n        learning_rate = 0.01\n        epsilon = 1e-8\n        gradient = (func(individual + epsilon) - func(individual - epsilon)) / (2 * epsilon)\n        return np.clip(individual - learning_rate * gradient, self.lower_bound, self.upper_bound)\n\n    def enhanced_mutation(self, best, idx):\n        if np.random.rand() < 0.7:\n            # DE/rand/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n        else:\n            # Quantum-inspired sampling\n            return self.quantum_sampling(best, idx)\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection and local search\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = self.gradient_local_search(trial)\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 17:18:58.846546", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridAdaptiveDE: Hybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence. (Score: 0.43077864873777105)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence.\n\nWith code:\nimport numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 40  # Increased initial population for greater diversity\n        self.population_size = int(self.initial_population_size * 1.25)  # Slightly larger population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.6  # Adjusted mutation factor for improved convergence\n        self.CR = 0.8  # Balanced crossover probability for exploration and exploitation\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.5 + 0.5 * np.random.rand()  # Dynamic mutation factor for varied search behavior\n        self.CR = 0.6 + 0.4 * np.random.rand()  # Flexible crossover range for adaptability\n\n    def enhanced_mutation(self, best, idx):\n        if np.random.rand() < 0.6:\n            # DE/rand/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c, d, e = np.random.choice(indices, 5, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c] + self.population[d] - self.population[e])\n        else:\n            # DE/best/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[b])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.30.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:19:21.408258", "content": "# Description: Enhanced Hybrid Differential Evolution with Dynamic Population Adjustments and Stochastic Ranking for Faster Convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50  # Further increased initial population for greater diversity\n        self.population_size = int(self.initial_population_size * 1.1)  # Slightly adjusted population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.7  # Further adjusted mutation factor for enhanced search\n        self.CR = 0.9  # Higher crossover probability for better exploration\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.4 + 0.6 * np.random.rand()  # More dynamic mutation factor for varied search behavior\n        self.CR = 0.5 + 0.5 * np.random.rand()  # More flexible crossover range for adaptability\n\n    def enhanced_mutation(self, best, idx):\n        if np.random.rand() < 0.5:\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c, d, e = np.random.choice(indices, 5, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c] + self.population[d] - self.population[e])\n        else:\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[b])\n\n    def stochastic_ranking(self, scores):\n        ranks = np.argsort(scores)\n        return ranks[:self.population_size // 2]  # Select top half based on ranking\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n            selected_indices = self.stochastic_ranking(self.scores)\n            self.population = self.population[selected_indices]\n            self.scores = self.scores[selected_indices]\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 17:19:21.411449", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridAdaptiveDE: Hybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence. (Score: 0.43077864873777105)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence.\n\nWith code:\nimport numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 40  # Increased initial population for greater diversity\n        self.population_size = int(self.initial_population_size * 1.25)  # Slightly larger population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.6  # Adjusted mutation factor for improved convergence\n        self.CR = 0.8  # Balanced crossover probability for exploration and exploitation\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.5 + 0.5 * np.random.rand()  # Dynamic mutation factor for varied search behavior\n        self.CR = 0.6 + 0.4 * np.random.rand()  # Flexible crossover range for adaptability\n\n    def enhanced_mutation(self, best, idx):\n        if np.random.rand() < 0.6:\n            # DE/rand/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c, d, e = np.random.choice(indices, 5, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c] + self.population[d] - self.population[e])\n        else:\n            # DE/best/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[b])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.30.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:19:34.608481", "content": "# Description: Improved Differential Evolution with Adaptive Lévy Step Size and Dynamic Population Control for Enhanced Convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50  # Increased initial population for better exploration\n        self.population_size = self.initial_population_size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.7  # Increased mutation factor for more aggressive search\n        self.CR = 0.9  # Higher crossover probability for increased recombination\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def adaptive_levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step * (0.5 + 0.5 * np.random.rand())  # Adaptive step size\n\n    def dynamic_population_control(self):\n        if self.func_evals > self.budget * 0.5:\n            self.population_size = int(self.initial_population_size * 0.75)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def enhanced_mutation(self, best, idx):\n        if np.random.rand() < 0.5:\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n        else:\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c, d = np.random.choice(indices, 4, replace=False)\n            return best + self.F * (self.population[a] - self.population[b] + self.population[c] - self.population[d])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n\n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.dynamic_population_control()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n                levy_step = self.adaptive_levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 17:19:34.611683", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridAdaptiveDE: Hybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence. (Score: 0.43077864873777105)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence.\n\nWith code:\nimport numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 40  # Increased initial population for greater diversity\n        self.population_size = int(self.initial_population_size * 1.25)  # Slightly larger population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.6  # Adjusted mutation factor for improved convergence\n        self.CR = 0.8  # Balanced crossover probability for exploration and exploitation\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.5 + 0.5 * np.random.rand()  # Dynamic mutation factor for varied search behavior\n        self.CR = 0.6 + 0.4 * np.random.rand()  # Flexible crossover range for adaptability\n\n    def enhanced_mutation(self, best, idx):\n        if np.random.rand() < 0.6:\n            # DE/rand/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c, d, e = np.random.choice(indices, 5, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c] + self.population[d] - self.population[e])\n        else:\n            # DE/best/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[b])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.30.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:19:49.203144", "content": "# Description: Enhanced Hybrid Differential Evolution with Dynamic Archive-based Search and Multi-Strategy Adaptation for Improved Convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedHybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Adjusted for increased diversity\n        self.archive_size = 20  # Introduced an archive to store elite solutions\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.5  # Base mutation factor for stability\n        self.CR_base = 0.9  # Base crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.archive = np.zeros((self.archive_size, dim))  # Archive for elite solutions\n        self.archive_scores = np.full(self.archive_size, np.inf)\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self, success_rate):\n        if success_rate > 0.2:\n            self.F = self.F_base * (1.0 + np.random.rand() * 0.5)  # Adaptive based on success rate\n            self.CR = self.CR_base * (1.0 + np.random.rand() * 0.1)\n        else:\n            self.F = self.F_base * (0.5 + np.random.rand() * 0.5)\n            self.CR = self.CR_base * (0.5 + np.random.rand() * 0.4)\n\n    def enhanced_mutation(self, best, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        if np.random.rand() < 0.7:\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n        else:\n            a, = np.random.choice(self.archive_size, 1)\n            b, = np.random.choice(indices, 1)\n            return self.archive[a] + self.F * (best - self.population[b])\n\n    def update_archive(self, candidate, score):\n        worst_idx = np.argmax(self.archive_scores)\n        if score < self.archive_scores[worst_idx]:\n            self.archive[worst_idx] = candidate\n            self.archive_scores[worst_idx] = score\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        success_count = 0\n\n        def evaluate(ind):\n            nonlocal best, best_score, success_count\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                    success_count += 1\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        self.archive[:self.population_size] = self.population\n        self.archive_scores[:self.population_size] = self.scores\n\n        while self.func_evals < self.budget:\n            success_rate = success_count / self.population_size\n            self.adapt_parameters(success_rate)\n            success_count = 0\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n                    self.update_archive(trial, trial_score)\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 17:19:49.206123", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridAdaptiveDE: Hybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence. (Score: 0.43077864873777105)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence.\n\nWith code:\nimport numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 40  # Increased initial population for greater diversity\n        self.population_size = int(self.initial_population_size * 1.25)  # Slightly larger population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.6  # Adjusted mutation factor for improved convergence\n        self.CR = 0.8  # Balanced crossover probability for exploration and exploitation\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.5 + 0.5 * np.random.rand()  # Dynamic mutation factor for varied search behavior\n        self.CR = 0.6 + 0.4 * np.random.rand()  # Flexible crossover range for adaptability\n\n    def enhanced_mutation(self, best, idx):\n        if np.random.rand() < 0.6:\n            # DE/rand/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c, d, e = np.random.choice(indices, 5, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c] + self.population[d] - self.population[e])\n        else:\n            # DE/best/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[b])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.30.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:20:04.942256", "content": "# Description: Enhanced Hybrid Adaptive Differential Evolution utilizing chaotic initialization, adaptive parameter scaling, and strategic population updates for improved convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedHybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 60  # Increased initial population for greater diversity\n        self.population_size = int(self.initial_population_size * 1.1)  # Adjusted population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.7  # Adjusted mutation factor\n        self.CR = 0.9  # Increased crossover probability\n        self.population = self.chaotic_initialization()\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def chaotic_initialization(self):\n        # Use chaotic logistic map for initialization\n        x = 0.5  # initial condition\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            x = 4 * x * (1 - x)  # logistic map\n            population[i] = self.lower_bound + (self.upper_bound - self.lower_bound) * x\n        return population\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.4 + 0.6 * np.random.rand()  # Dynamic mutation factor focused on exploration\n        self.CR = 0.5 + 0.5 * np.random.rand()  # Crossover rate with more randomness\n\n    def enhanced_mutation(self, best, idx):\n        if np.random.rand() < 0.7:\n            # DE/rand/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c, d, e = np.random.choice(indices, 5, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c] + self.population[d] - self.population[e])\n        else:\n            # DE/best/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[b])\n\n    def update_population(self):\n        self.population = self.population[np.argsort(self.scores)]\n        self.population = self.population[:self.population_size//2]\n        new_individuals = self.chaotic_initialization()[:self.population_size//2]\n        self.population = np.vstack((self.population, new_individuals))\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n            self.update_population()\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 17:20:04.945544", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridAdaptiveDE: Hybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence. (Score: 0.43077864873777105)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence.\n\nWith code:\nimport numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 40  # Increased initial population for greater diversity\n        self.population_size = int(self.initial_population_size * 1.25)  # Slightly larger population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.6  # Adjusted mutation factor for improved convergence\n        self.CR = 0.8  # Balanced crossover probability for exploration and exploitation\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.5 + 0.5 * np.random.rand()  # Dynamic mutation factor for varied search behavior\n        self.CR = 0.6 + 0.4 * np.random.rand()  # Flexible crossover range for adaptability\n\n    def enhanced_mutation(self, best, idx):\n        if np.random.rand() < 0.6:\n            # DE/rand/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c, d, e = np.random.choice(indices, 5, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c] + self.population[d] - self.population[e])\n        else:\n            # DE/best/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[b])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.30.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:20:15.544870", "content": "# Description: Hybrid Algorithm with Enhanced Exploration and Opposition-Based Learning for Accelerated Convergence.\n# Code: \n# ```python\nimport numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50  # Further increased initial population for exploration\n        self.population_size = int(self.initial_population_size * 1.5)  # Larger population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.7  # Increased mutation factor for exploration\n        self.CR = 0.9  # Higher crossover probability for diverse combinations\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.5 + 0.3 * np.random.rand()  # Modified dynamic mutation\n        self.CR = 0.7 + 0.2 * np.random.rand()  # Slightly reduced range for crossover\n\n    def enhanced_mutation(self, best, idx):\n        if np.random.rand() < 0.5:\n            # DE/rand/2 mutation with added diversity\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c, d, e = np.random.choice(indices, 5, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c] + self.population[d] - self.population[e])\n        else:\n            # DE/best/1 mutation with opposition-based learning\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b = np.random.choice(indices, 2, replace=False)\n            opposite = self.lower_bound + self.upper_bound - self.population[a]\n            return best + self.F * (opposite - self.population[b])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                # Crossover with opposition-based strategy\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Lévy flight step integrated with mutation\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n```"}
{"role": "LLaMEA", "time": "2024-11-09 17:23:32.130377", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridAdaptiveDE: Hybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence. (Score: 0.43077864873777105)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence.\n\nWith code:\nimport numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 40  # Increased initial population for greater diversity\n        self.population_size = int(self.initial_population_size * 1.25)  # Slightly larger population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.6  # Adjusted mutation factor for improved convergence\n        self.CR = 0.8  # Balanced crossover probability for exploration and exploitation\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.5 + 0.5 * np.random.rand()  # Dynamic mutation factor for varied search behavior\n        self.CR = 0.6 + 0.4 * np.random.rand()  # Flexible crossover range for adaptability\n\n    def enhanced_mutation(self, best, idx):\n        if np.random.rand() < 0.6:\n            # DE/rand/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c, d, e = np.random.choice(indices, 5, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c] + self.population[d] - self.population[e])\n        else:\n            # DE/best/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[b])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.30.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:23:50.722098", "content": "# Description: Enhanced Adaptive Differential Evolution with Self-Adaptive Strategies and Gradient-Inspired Variational Steps for Accelerated Convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50  # Larger initial population for broader exploration\n        self.population_size = int(self.initial_population_size * 1.1)  # Slightly compacted size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5 + 0.3 * np.random.rand()  # Self-adaptive mutation factor\n        self.CR = 0.9  # Increased crossover probability for better exploitation\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adaptive_parameters(self):\n        self.F = np.clip(self.F + 0.1 * np.random.randn(), 0.4, 0.9)\n        self.CR = np.clip(self.CR + 0.1 * np.random.randn(), 0.7, 1.0)\n\n    def gradient_inspired_mutation(self, best, idx):\n        if np.random.rand() < 0.7:\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            gradient_step = np.random.rand() * (best - self.population[idx])\n            return self.population[a] + self.F * (self.population[b] - self.population[c]) + gradient_step\n        else:\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[b])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adaptive_parameters()\n            for i in range(self.population_size):\n                mutant = self.gradient_inspired_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 17:23:50.725022", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridAdaptiveDE: Hybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence. (Score: 0.43077864873777105)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence.\n\nWith code:\nimport numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 40  # Increased initial population for greater diversity\n        self.population_size = int(self.initial_population_size * 1.25)  # Slightly larger population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.6  # Adjusted mutation factor for improved convergence\n        self.CR = 0.8  # Balanced crossover probability for exploration and exploitation\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.5 + 0.5 * np.random.rand()  # Dynamic mutation factor for varied search behavior\n        self.CR = 0.6 + 0.4 * np.random.rand()  # Flexible crossover range for adaptability\n\n    def enhanced_mutation(self, best, idx):\n        if np.random.rand() < 0.6:\n            # DE/rand/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c, d, e = np.random.choice(indices, 5, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c] + self.population[d] - self.population[e])\n        else:\n            # DE/best/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[b])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.30.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:24:05.313385", "content": "# Description: Enhanced Hybrid Differential Evolution with Dynamic Population Resizing and Adaptive Learning Rate for Improved Convergence Speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50  # Increased initial population for enhanced exploration\n        self.population_size = self.initial_population_size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Adjusted mutation factor for more balanced exploration-exploitation\n        self.CR = 0.9  # Higher crossover probability to ensure diversity\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, scale=0.1):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = scale * u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.4 + 0.6 * np.random.rand()  # More dynamic mutation factor range for diversity\n        self.CR = 0.5 + 0.5 * np.random.rand()  # Wide crossover probability range\n\n    def enhanced_mutation(self, best, idx):\n        # Introducing DE/best/2 mutation\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c, d = np.random.choice(indices, 4, replace=False)\n        return best + self.F * (self.population[a] - self.population[b] + self.population[c] - self.population[d])\n\n    def dynamic_population_resizing(self):\n        # Reduce population size to focus search as evaluations increase\n        if self.func_evals > self.budget / 2 and self.population_size > self.initial_population_size / 2:\n            self.population_size = int(self.population_size * 0.9)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            self.dynamic_population_resizing()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```\n\n"}
{"role": "LLaMEA", "time": "2024-11-09 17:24:05.316603", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridAdaptiveDE: Hybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence. (Score: 0.43077864873777105)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence.\n\nWith code:\nimport numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 40  # Increased initial population for greater diversity\n        self.population_size = int(self.initial_population_size * 1.25)  # Slightly larger population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.6  # Adjusted mutation factor for improved convergence\n        self.CR = 0.8  # Balanced crossover probability for exploration and exploitation\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.5 + 0.5 * np.random.rand()  # Dynamic mutation factor for varied search behavior\n        self.CR = 0.6 + 0.4 * np.random.rand()  # Flexible crossover range for adaptability\n\n    def enhanced_mutation(self, best, idx):\n        if np.random.rand() < 0.6:\n            # DE/rand/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c, d, e = np.random.choice(indices, 5, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c] + self.population[d] - self.population[e])\n        else:\n            # DE/best/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[b])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.30.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:24:32.739165", "content": "# Description: Enhanced Differential Evolution with Dynamic Population Resizing and Adaptive Selection for Improved Convergence.\n# Code:\n```python\nimport numpy as np\n\nclass EnhancedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 50\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.func_evals = 0\n        self.F = 0.7\n        self.CR = 0.9\n\n    def levy_flight(self, scale=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return scale * step\n\n    def adapt_parameters(self):\n        self.F = np.random.uniform(0.5, 0.9)\n        self.CR = np.random.uniform(0.7, 0.95)\n\n    def resized_population(self):\n        proportion = min(1, max(0.5, (self.budget - self.func_evals) / self.budget))\n        new_size = int(self.initial_population_size * proportion)\n        if new_size < len(self.population):\n            indices = np.argsort(self.scores)[:new_size]\n            self.population = self.population[indices]\n            self.scores = self.scores[indices]\n\n    def enhanced_mutation(self, best, idx):\n        indices = np.random.choice(np.delete(np.arange(len(self.population)), idx), 5, replace=False)\n        if np.random.rand() < 0.7:\n            return self.population[indices[0]] + self.F * (self.population[indices[1]] - self.population[indices[2]] + self.population[indices[3]] - self.population[indices[4]])\n        else:\n            return best + self.F * (self.population[indices[0]] - self.population[indices[1]])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n\n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(len(self.population)):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            self.resized_population()\n            for i in range(len(self.population)):\n                mutant = self.enhanced_mutation(best, i)\n\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n```"}
{"role": "LLaMEA", "time": "2024-11-09 17:28:08.005804", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridAdaptiveDE: Hybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence. (Score: 0.43077864873777105)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence.\n\nWith code:\nimport numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 40  # Increased initial population for greater diversity\n        self.population_size = int(self.initial_population_size * 1.25)  # Slightly larger population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.6  # Adjusted mutation factor for improved convergence\n        self.CR = 0.8  # Balanced crossover probability for exploration and exploitation\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.5 + 0.5 * np.random.rand()  # Dynamic mutation factor for varied search behavior\n        self.CR = 0.6 + 0.4 * np.random.rand()  # Flexible crossover range for adaptability\n\n    def enhanced_mutation(self, best, idx):\n        if np.random.rand() < 0.6:\n            # DE/rand/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c, d, e = np.random.choice(indices, 5, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c] + self.population[d] - self.population[e])\n        else:\n            # DE/best/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[b])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.30.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:28:18.427966", "content": "# Description: Enhanced Differential Evolution with Hybrid Crossover, Elite Retention, and Adaptive Scaling for Improved Convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50  # Increased population size for diversity\n        self.population_size = int(self.initial_population_size * 1.1)  # Adjusted population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Moderated mutation factor for stability\n        self.CR = 0.9  # Higher crossover probability for enhanced blending\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def cauchy_flight(self):\n        step = np.random.standard_cauchy(self.dim)\n        return np.clip(step, -1, 1)\n\n    def adapt_parameters(self):\n        self.F = 0.4 + 0.6 * np.random.rand()  # Adapted mutation factor for exploration\n        self.CR = 0.7 + 0.3 * np.random.rand()  # Narrower range for consistent crossover\n\n    def hybrid_mutation(self, best, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        if np.random.rand() < 0.7:\n            # Combined DE/rand/1 and DE/best/1 mutation\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            return self.population[a] + self.F * (best - self.population[idx] + self.population[b] - self.population[c])\n        else:\n            # Elite retention with enhanced mutation\n            elite = np.median(self.population, axis=0)\n            a, b = np.random.choice(indices, 2, replace=False)\n            return elite + self.F * (self.population[a] - self.population[b])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.hybrid_mutation(best, i)\n\n                # Hybrid Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Cauchy flight step\n                cauchy_step = self.cauchy_flight() * (trial - best)\n                trial = trial + cauchy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 17:28:18.431185", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridAdaptiveDE: Hybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence. (Score: 0.43077864873777105)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence.\n\nWith code:\nimport numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 40  # Increased initial population for greater diversity\n        self.population_size = int(self.initial_population_size * 1.25)  # Slightly larger population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.6  # Adjusted mutation factor for improved convergence\n        self.CR = 0.8  # Balanced crossover probability for exploration and exploitation\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.5 + 0.5 * np.random.rand()  # Dynamic mutation factor for varied search behavior\n        self.CR = 0.6 + 0.4 * np.random.rand()  # Flexible crossover range for adaptability\n\n    def enhanced_mutation(self, best, idx):\n        if np.random.rand() < 0.6:\n            # DE/rand/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c, d, e = np.random.choice(indices, 5, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c] + self.population[d] - self.population[e])\n        else:\n            # DE/best/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[b])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.30.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:28:34.219614", "content": "# Description: Enhanced Hybrid Differential Evolution with Self-Adaptive Strategies and Dynamic Local Search for Accelerated Convergence.\n# Code:\n```python\nimport numpy as np\n\nclass EnhancedHybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Slightly larger population for better exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Adjusted mutation factor for balance\n        self.CR = 0.9  # Increased crossover probability for exploration\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        return u / (np.abs(v) ** (1 / beta))\n\n    def adapt_parameters(self):\n        self.F = 0.4 + 0.6 * np.random.rand()  # Wider range for mutation factor\n        self.CR = 0.7 + 0.3 * np.random.rand()  # Narrower range for crossover\n\n    def enhanced_mutation(self, best, idx):\n        indices = np.arange(self.population_size)\n        indices = indices[indices != idx]\n        if np.random.rand() < 0.3:\n            # DE/best/2 mutation\n            a, b, c, d = np.random.choice(indices, 4, replace=False)\n            return best + self.F * (self.population[a] - self.population[b] + self.population[c] - self.population[d])\n        else:\n            # DE/rand/1 mutation\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def dynamic_local_search(self, candidate, best):\n        scale = np.random.uniform(0.1, 0.3, self.dim)  # Small local search step\n        return candidate + scale * (best - candidate)\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                if np.random.rand() < 0.2:\n                    # Apply dynamic local search with a certain probability\n                    trial = self.dynamic_local_search(trial, best)\n\n                # Lévy flight step\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n```"}
{"role": "LLaMEA", "time": "2024-11-09 17:31:59.508619", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridAdaptiveDE: Hybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence. (Score: 0.43077864873777105)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence.\n\nWith code:\nimport numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 40  # Increased initial population for greater diversity\n        self.population_size = int(self.initial_population_size * 1.25)  # Slightly larger population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.6  # Adjusted mutation factor for improved convergence\n        self.CR = 0.8  # Balanced crossover probability for exploration and exploitation\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.5 + 0.5 * np.random.rand()  # Dynamic mutation factor for varied search behavior\n        self.CR = 0.6 + 0.4 * np.random.rand()  # Flexible crossover range for adaptability\n\n    def enhanced_mutation(self, best, idx):\n        if np.random.rand() < 0.6:\n            # DE/rand/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c, d, e = np.random.choice(indices, 5, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c] + self.population[d] - self.population[e])\n        else:\n            # DE/best/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[b])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.30.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:32:10.833858", "content": "# Description: Enhanced Differential Evolution with Adaptive Learning Strategies and Dynamic Population Control for Accelerated Convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50  # Further increased initial population for initial exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Lowered mutation factor for stability\n        self.CR = 0.9  # Increased crossover probability to exploit solutions\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.func_evals = 0\n        self.dynamic_population_control = True  # Enable dynamic population control\n\n    def adaptive_learning(self):\n        self.F = 0.4 + 0.6 * np.random.rand()  # Wider range for mutation factor for more adaptable search\n        self.CR = 0.7 + 0.3 * np.random.rand()  # Narrower crossover range for consistent improvement\n\n    def enhanced_mutation(self, best, idx):\n        if np.random.rand() < 0.5:\n            # DE/best/2 mutation\n            indices = list(range(self.initial_population_size))\n            indices.remove(idx)\n            a, b, c, d = np.random.choice(indices, 4, replace=False)\n            return best + self.F * (self.population[a] - self.population[b] + self.population[c] - self.population[d])\n        else:\n            # DE/current-to-best/1 mutation\n            indices = list(range(self.initial_population_size))\n            indices.remove(idx)\n            a, b = np.random.choice(indices, 2, replace=False)\n            return self.population[idx] + self.F * (best - self.population[idx]) + self.F * (self.population[a] - self.population[b])\n\n    def levy_flight(self, scale=0.01):\n        u = np.random.normal(0, 1)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / 3))\n        return scale * step\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n\n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.initial_population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            if self.dynamic_population_control and self.func_evals > self.budget // 2:\n                # Reduce population gradually to focus search\n                self.initial_population_size = max(20, self.initial_population_size - 1)\n            self.adaptive_learning()\n            for i in range(self.initial_population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```\n"}
{"role": "LLaMEA", "time": "2024-11-09 17:32:10.836242", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridAdaptiveDE: Hybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence. (Score: 0.43077864873777105)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence.\n\nWith code:\nimport numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 40  # Increased initial population for greater diversity\n        self.population_size = int(self.initial_population_size * 1.25)  # Slightly larger population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.6  # Adjusted mutation factor for improved convergence\n        self.CR = 0.8  # Balanced crossover probability for exploration and exploitation\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.5 + 0.5 * np.random.rand()  # Dynamic mutation factor for varied search behavior\n        self.CR = 0.6 + 0.4 * np.random.rand()  # Flexible crossover range for adaptability\n\n    def enhanced_mutation(self, best, idx):\n        if np.random.rand() < 0.6:\n            # DE/rand/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c, d, e = np.random.choice(indices, 5, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c] + self.population[d] - self.population[e])\n        else:\n            # DE/best/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[b])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.30.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:32:25.406297", "content": "# Description: Enhanced Hybrid Differential Evolution with Self-Adaptive Strategies for Dynamic Exploration and Efficient Convergence.\n# Code: \n```python\nimport numpy as np\n\nclass EnhancedHybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50  # Increased initial population for greater diversity\n        self.population_size = int(self.initial_population_size * 1.1)  # Slightly larger population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_min, self.F_max = 0.4, 0.9  # Range for mutation factor\n        self.CR_min, self.CR_max = 0.5, 0.9  # Range for crossover probability\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = self.F_min + (self.F_max - self.F_min) * np.random.rand()  # Adaptive mutation factor for varied search behavior\n        self.CR = self.CR_min + (self.CR_max - self.CR_min) * np.random.rand()  # Adaptive crossover range for adaptability\n\n    def enhanced_mutation(self, best, idx):\n        if np.random.rand() < 0.7:\n            # DE/rand/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c, d, e = np.random.choice(indices, 5, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c] + self.population[d] - self.population[e])\n        else:\n            # DE/current-to-best/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a = np.random.choice(indices)\n            return self.population[idx] + self.F * (best - self.population[idx]) + self.F * (self.population[a] - self.population[b])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n```"}
{"role": "LLaMEA", "time": "2024-11-09 17:32:25.412510", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridAdaptiveDE: Hybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence. (Score: 0.43077864873777105)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence.\n\nWith code:\nimport numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 40  # Increased initial population for greater diversity\n        self.population_size = int(self.initial_population_size * 1.25)  # Slightly larger population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.6  # Adjusted mutation factor for improved convergence\n        self.CR = 0.8  # Balanced crossover probability for exploration and exploitation\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.5 + 0.5 * np.random.rand()  # Dynamic mutation factor for varied search behavior\n        self.CR = 0.6 + 0.4 * np.random.rand()  # Flexible crossover range for adaptability\n\n    def enhanced_mutation(self, best, idx):\n        if np.random.rand() < 0.6:\n            # DE/rand/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c, d, e = np.random.choice(indices, 5, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c] + self.population[d] - self.population[e])\n        else:\n            # DE/best/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[b])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.30.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:32:35.698107", "content": "# Description: Hybrid Differential Evolution with Adaptive Anisotropic Mutation and Dynamic Population Adjustment for Enhanced Convergence Speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 40\n        self.population_size = int(self.initial_population_size * 1.5)  # Larger initial population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.7  # Increased mutation factor for more aggressive search\n        self.CR = 0.7  # Balanced crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n        self.dynamic_population = True  # Enable dynamic population adjustment\n\n    def adapt_parameters(self):\n        self.F = 0.4 + 0.4 * np.random.rand()  # Adjusted dynamic mutation factor\n        self.CR = 0.5 + 0.5 * np.random.rand()  # Wider crossover range\n\n    def enhanced_mutation(self, best, idx):\n        if np.random.rand() < 0.6:\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            # Anisotropic mutation\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n        else:\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[b])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n            if self.dynamic_population and self.func_evals > self.budget // 2:\n                # Shrink the population size dynamically\n                sorted_indices = np.argsort(self.scores)\n                self.population = self.population[sorted_indices][:self.initial_population_size]\n                self.scores = self.scores[sorted_indices][:self.initial_population_size]\n                self.population_size = self.initial_population_size\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 17:32:35.701282", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridAdaptiveDE: Hybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence. (Score: 0.43077864873777105)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence.\n\nWith code:\nimport numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 40  # Increased initial population for greater diversity\n        self.population_size = int(self.initial_population_size * 1.25)  # Slightly larger population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.6  # Adjusted mutation factor for improved convergence\n        self.CR = 0.8  # Balanced crossover probability for exploration and exploitation\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.5 + 0.5 * np.random.rand()  # Dynamic mutation factor for varied search behavior\n        self.CR = 0.6 + 0.4 * np.random.rand()  # Flexible crossover range for adaptability\n\n    def enhanced_mutation(self, best, idx):\n        if np.random.rand() < 0.6:\n            # DE/rand/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c, d, e = np.random.choice(indices, 5, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c] + self.population[d] - self.population[e])\n        else:\n            # DE/best/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[b])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.30.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:32:45.336729", "content": "# Description: Modified Hybrid Adaptive DE with Dynamic Levy Flight and Opposition-Based Learning for Accelerated Convergence.\n# Code:\n```python\nimport numpy as np\n\nclass EnhancedHybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50  # Slightly larger population for better diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Mutation factor fine-tuned for stability\n        self.CR = 0.9  # Higher crossover probability for greater exploration\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def dynamic_levy_flight(self, step_size):\n        beta = 1.3\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta)) * step_size\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.4 + 0.6 * np.random.rand()  # Balanced mutation factor\n        self.CR = 0.7 + 0.3 * np.random.rand()  # Adaptive crossover range\n\n    def enhanced_mutation(self, best, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def opposition_based_learning(self, solution):\n        opposite = self.lower_bound + self.upper_bound - solution\n        return opposite\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n\n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                levy_step = self.dynamic_levy_flight(1.0) * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                opposite = self.opposition_based_learning(trial)\n                opposite_score = evaluate(opposite)\n\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n                elif opposite_score is not None and opposite_score < self.scores[i]:\n                    self.population[i] = opposite\n                    self.scores[i] = opposite_score\n\n        return best, best_score\n```"}
{"role": "LLaMEA", "time": "2024-11-09 17:34:48.456020", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridAdaptiveDE: Hybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence. (Score: 0.43077864873777105)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence.\n\nWith code:\nimport numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 40  # Increased initial population for greater diversity\n        self.population_size = int(self.initial_population_size * 1.25)  # Slightly larger population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.6  # Adjusted mutation factor for improved convergence\n        self.CR = 0.8  # Balanced crossover probability for exploration and exploitation\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.5 + 0.5 * np.random.rand()  # Dynamic mutation factor for varied search behavior\n        self.CR = 0.6 + 0.4 * np.random.rand()  # Flexible crossover range for adaptability\n\n    def enhanced_mutation(self, best, idx):\n        if np.random.rand() < 0.6:\n            # DE/rand/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c, d, e = np.random.choice(indices, 5, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c] + self.population[d] - self.population[e])\n        else:\n            # DE/best/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[b])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.30.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:35:02.197265", "content": "# Description: Novel Adaptive Hybrid Evolutionary Algorithm with Improved Diversity Management and Dynamic Population Resizing for Enhanced Convergence Speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass NovelAdaptiveHEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50  # Increased initial population size\n        self.population_size = int(self.initial_population_size * 1.15)  # Slight adjustment for dynamic resizing\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Reduced mutation factor for precision\n        self.CR = 0.9  # Increased crossover probability for exploration\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma_u = np.power(np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                           (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2)), 1 / beta)\n        u = np.random.normal(0, sigma_u, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.4 + 0.6 * np.random.rand()  # Wider mutation factor range\n        self.CR = 0.5 + 0.5 * np.random.rand()  # Broader crossover range\n\n    def enhanced_mutation(self, best, idx):\n        if np.random.rand() < 0.5:\n            # DE/rand/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n        else:\n            # DE/best/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c, d = np.random.choice(indices, 4, replace=False)\n            return best + self.F * (self.population[a] - self.population[b] + self.population[c] - self.population[d])\n\n    def diverse_resizing(self):\n        if self.func_evals > self.budget / 2 and np.random.rand() < 0.1:\n            self.population_size = min(self.initial_population_size, self.population_size + 5)\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (5, self.dim))\n            self.population = np.vstack((self.population, new_individuals))\n            self.scores = np.append(self.scores, np.full(5, np.inf))\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                # Crossover with improved scheme\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight() * trial\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n            self.diverse_resizing()\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 17:35:02.200571", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridAdaptiveDE: Hybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence. (Score: 0.43077864873777105)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence.\n\nWith code:\nimport numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 40  # Increased initial population for greater diversity\n        self.population_size = int(self.initial_population_size * 1.25)  # Slightly larger population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.6  # Adjusted mutation factor for improved convergence\n        self.CR = 0.8  # Balanced crossover probability for exploration and exploitation\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.5 + 0.5 * np.random.rand()  # Dynamic mutation factor for varied search behavior\n        self.CR = 0.6 + 0.4 * np.random.rand()  # Flexible crossover range for adaptability\n\n    def enhanced_mutation(self, best, idx):\n        if np.random.rand() < 0.6:\n            # DE/rand/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c, d, e = np.random.choice(indices, 5, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c] + self.population[d] - self.population[e])\n        else:\n            # DE/best/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[b])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.30.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:35:16.022155", "content": "# Description: Enhanced Hybrid Differential Evolution with Adaptive Local Search and Opposite Learning for Faster and Robust Convergence.\n# Code: \n```python\nimport numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30  # Reduced initial population for faster adaptation\n        self.population_size = int(self.initial_population_size * 1.5)  # Adjusted population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # More balanced mutation factor\n        self.CR = 0.9  # Higher crossover probability to encourage diversity\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.3  # Adjusted Levy flight parameter for different step size\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.4 + 0.6 * np.random.rand()  # Wider range for mutation factor\n        self.CR = 0.7 + 0.3 * np.random.rand()  # Adjusted crossover range\n\n    def enhanced_mutation(self, best, idx):\n        if np.random.rand() < 0.5:\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            return best + self.F * (self.population[a] - self.population[b] + self.population[c] - self.population[idx])\n        else:\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b = np.random.choice(indices, 2, replace=False)\n            return self.population[a] + self.F * (best - self.population[b])\n\n    def opposite_learning(self, indiv):\n        return self.lower_bound + self.upper_bound - indiv\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Opposite Learning Strategy\n                opposite = self.opposite_learning(trial)\n                opposite_score = evaluate(opposite)\n                if opposite_score is not None and opposite_score < self.scores[i]:\n                    trial = opposite\n                    trial_score = opposite_score\n                else:\n                    trial_score = evaluate(trial)\n                \n                # Possible Lévy flight step\n                if trial_score is not None and trial_score < self.scores[i]:\n                    levy_step = self.levy_flight() * (trial - best)\n                    trial = trial + levy_step\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n```"}
{"role": "LLaMEA", "time": "2024-11-09 17:36:57.848889", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridAdaptiveDE: Hybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence. (Score: 0.43077864873777105)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence.\n\nWith code:\nimport numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 40  # Increased initial population for greater diversity\n        self.population_size = int(self.initial_population_size * 1.25)  # Slightly larger population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.6  # Adjusted mutation factor for improved convergence\n        self.CR = 0.8  # Balanced crossover probability for exploration and exploitation\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.5 + 0.5 * np.random.rand()  # Dynamic mutation factor for varied search behavior\n        self.CR = 0.6 + 0.4 * np.random.rand()  # Flexible crossover range for adaptability\n\n    def enhanced_mutation(self, best, idx):\n        if np.random.rand() < 0.6:\n            # DE/rand/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c, d, e = np.random.choice(indices, 5, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c] + self.population[d] - self.population[e])\n        else:\n            # DE/best/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[b])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.30.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:37:10.616519", "content": "# Description: Enhanced Hybrid Differential Evolution with Adaptive Adaptive Parameters and Early Exploitation for Improved Convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedHybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50  # Increased initial population for more diversity\n        self.population_size = int(self.initial_population_size * 1.1)  # Balanced population size for exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_min, self.F_max = 0.3, 0.9  # Dynamic mutation factor range for exploration-exploitation balance\n        self.CR_min, self.CR_max = 0.5, 0.9  # Dynamic crossover probabilities\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self, scale=0.1):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = scale * u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        progress = self.func_evals / self.budget\n        self.F = self.F_min + (self.F_max - self.F_min) * np.random.rand()\n        self.CR = self.CR_min + (self.CR_max - self.CR_min) * (1 - progress)\n\n    def enhanced_mutation(self, best, idx):\n        # DE/best/2 mutation for early exploitation\n        indices = np.random.choice(\n            [i for i in range(self.population_size) if i != idx], 5, replace=False)\n        a, b, c, d, e = indices\n        return best + self.F * (self.population[a] - self.population[b] + self.population[c] - self.population[d] + self.population[e] - self.population[idx])\n    \n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
{"role": "LLaMEA", "time": "2024-11-09 17:37:10.619433", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nHybridAdaptiveDE: Hybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence. (Score: 0.43077864873777105)\n\nThe selected solution to update is:\nHybrid Differential Evolution with Adaptive Parameter Control and Enhanced Mutation Strategies for Faster Convergence.\n\nWith code:\nimport numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 40  # Increased initial population for greater diversity\n        self.population_size = int(self.initial_population_size * 1.25)  # Slightly larger population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.6  # Adjusted mutation factor for improved convergence\n        self.CR = 0.8  # Balanced crossover probability for exploration and exploitation\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = 0.5 + 0.5 * np.random.rand()  # Dynamic mutation factor for varied search behavior\n        self.CR = 0.6 + 0.4 * np.random.rand()  # Flexible crossover range for adaptability\n\n    def enhanced_mutation(self, best, idx):\n        if np.random.rand() < 0.6:\n            # DE/rand/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c, d, e = np.random.choice(indices, 5, replace=False)\n            return self.population[a] + self.F * (self.population[b] - self.population[c] + self.population[d] - self.population[e])\n        else:\n            # DE/best/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b = np.random.choice(indices, 2, replace=False)\n            return best + self.F * (self.population[a] - self.population[b])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n\nThe algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.30.\n\n\nPlease transform this optimization algorithm code by exactly 40.0% in a \nway that enhances convergence speed. Keep the code difference precisely at \n40.0%, and focus solely on achieving performance improvements through \nalgorithmic adjustments across various elements of the code. Avoid focusing on \ncode efficiency; instead, prioritize exploration of diverse approaches within \nthe allowed modification percentage.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-09 17:37:26.762839", "content": "# Description: Enhanced Hybrid Differential Evolution with Self-Adaptive Learning and Context-Driven Mutation Strategies for Accelerated Convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedHybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50  # Larger initial population for increased diversity\n        self.population_size = int(self.initial_population_size * 1.2)  # Adaptive population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_min = 0.4  # Minimum mutation factor\n        self.F_max = 0.9  # Maximum mutation factor for wider search\n        self.CR_min = 0.3  # More adaptive crossover range\n        self.CR_max = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.scores = np.full(self.population_size, np.inf)\n        self.func_evals = 0\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                   (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u)\n        v = np.random.normal(0, 1)\n        step = u / (abs(v) ** (1 / beta))\n        return step\n\n    def adapt_parameters(self):\n        self.F = self.F_min + (self.F_max - self.F_min) * np.random.rand()  # Self-adaptive mutation factor\n        self.CR = self.CR_min + (self.CR_max - self.CR_min) * np.random.rand()  # Flexible crossover\n\n    def enhanced_mutation(self, best, idx):\n        context_factor = 0.5 + 0.5 * np.random.rand()  # New context-based factor\n        if np.random.rand() < 0.5:\n            # DE/rand-to-best/1 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c, d = np.random.choice(indices, 4, replace=False)\n            return (self.population[a] + context_factor * (best - self.population[a]) +\n                    self.F * (self.population[b] - self.population[c]) +\n                    self.F * (self.population[d] - self.population[idx]))\n        else:\n            # DE/best/2 mutation\n            indices = list(range(self.population_size))\n            indices.remove(idx)\n            a, b, c, d = np.random.choice(indices, 4, replace=False)\n            return best + self.F * (self.population[a] - self.population[b] +\n                                    self.population[c] - self.population[d])\n\n    def __call__(self, func):\n        best = None\n        best_score = np.inf\n        \n        def evaluate(ind):\n            nonlocal best, best_score\n            if self.func_evals < self.budget:\n                score = func(ind)\n                self.func_evals += 1\n                if score < best_score:\n                    best_score = score\n                    best = ind.copy()\n                return score\n            else:\n                return None\n\n        for i in range(self.population_size):\n            self.scores[i] = evaluate(self.population[i])\n\n        while self.func_evals < self.budget:\n            self.adapt_parameters()\n            for i in range(self.population_size):\n                mutant = self.enhanced_mutation(best, i)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, self.population[i])\n\n                # Possible Lévy flight step\n                levy_step = self.levy_flight() * (trial - best)\n                trial = trial + levy_step\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_score = evaluate(trial)\n                if trial_score is not None and trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n        return best, best_score\n# ```"}
