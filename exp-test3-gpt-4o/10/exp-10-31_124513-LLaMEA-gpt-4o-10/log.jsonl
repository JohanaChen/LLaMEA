{"id": "40787ef0-c554-46a0-aa18-ba3df1833598", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w = 0.7  # inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + self.c1 * r1 * (pbest[i] - pos[i]) \n                          + self.c2 * r2 * (gbest - pos[i]))\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # DE mutation and crossover\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + self.F * (pos[b] - pos[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "A hybridized particle swarm optimization with differential evolution crossover strategy to balance exploration and exploitation.", "configspace": "", "generation": 0, "fitness": 0.1989883672374024, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.20.", "error": "", "parent_id": null, "metadata": {"aucs": [0.4016901880192427, 0.39861263029075744, 0.37489310759591177, 0.4639303723285868, 0.39106495160734334, 0.4111416833146192, 0.4136907172994685, 0.44149734465156854, 0.3979330681351334, 0.0820091194562963, 0.10146929687387563, 0.05621694784836995, 0.09715260374990953, 0.09223935167245123, 0.03897532693278005, 0.08542396640096928, 0.08978032197604568, 0.028691809679121993, 0.08108260718214555, 0.08609383069810117, 0.09667013837118665, 0.0727879385749518, 0.08416145029423128, 0.08447213724015623, 0.08065880272855885, 0.11175094721289147, 0.08449255272883205, 0.07829574333313316, 0.07189293090766058, 0.09077394118776227, 0.07305263130553463, 0.06683531126059006, 0.08718533140289508, 0.0692067301006507, 0.07055123330669577, 0.08929577359888974, 0.9864495891144499, 0.9867051892400349, 0.9863039438342529, 0.9823051558756085, 0.9905545244797849, 0.9864709250922414, 0.9856484962487134, 0.9865748960204279, 0.9914888143408442, 0.22092939496741149, 0.23024488489852324, 0.21278523473173994, 0.20159859782536838, 0.20882453159954306, 0.15882088173481812, 0.20735110737162044, 0.21991482703216247, 0.2038689806635975, 0.265226758158266, 0.34723517107538937, 0.24738694487470414, 0.38364987800333383, 0.25526630249255566, 0.2481589747366203, 0.23861857972020328, 0.27291691766135606, 0.2707433990348962, 0.12965738932164217, 0.126221757357446, 0.06938026259380325, 0.10139340634518268, 0.12476512536012829, 0.12162957015120823, 0.11882643238322421, 0.11342992601042223, 0.1128961047779854, 0.1105498502129838, 0.16080058846572975, 0.09855458633866332, 0.14695430481117988, 0.12284044820252293, 0.12582491987476918, 0.1309969516519317, 0.10020333942499293, 0.11655652062562116, 9.999999999998899e-05, 0.006791742317502791, 9.999999999998899e-05, 0.014497811565455598, 9.999999999998899e-05, 0.0002806965107825521, 9.999999999998899e-05, 0.027881967602052415, 0.0005161802280335692, 0.06526720096877503, 0.032312071918699226, 0.03228398828993362, 0.11161999220776742, 0.06198907904244644, 0.08423839724740323, 0.0491024198608766, 0.06354483558167356, 0.08085872010440087, 9.999999999998899e-05, 0.003789587646211623, 9.999999999998899e-05, 0.011128240582080395, 0.016724490437171502, 0.00293114123140803, 9.999999999998899e-05, 0.014751340209712693, 9.999999999998899e-05, 0.06468732702685143, 0.07956882951484623, 0.11630244574613391, 0.04790848461663466, 0.030253994672392204, 0.09920156641324451, 0.04611745833373093, 0.11459333675917094, 0.0728897433074378, 0.369592596514536, 0.3802792505018644, 0.35187875060068896, 0.3574227468962077, 0.3908355673243158, 0.3399827972123419, 0.3790825560357848, 0.39462282505293167, 0.3687874397281262, 0.09952048884663323, 0.10390377935639139, 0.0856813242045642, 0.08050011334598262, 0.10720967627117339, 0.09138551966447317, 0.0702710802869575, 0.09675714368162502, 0.07216004205763582, 0.16648188131793484, 0.2155649536599643, 0.24286954946965367, 0.28436709771842383, 0.1953175891489507, 0.1863538079467567, 0.19336552285109443, 0.1647866319183584, 0.21754060845620316, 0.2479060012384663, 0.2526983360995312, 0.23989818513257277, 0.2507620959375547, 0.2527536007740818, 0.23801569921643873, 0.29247095564648706, 0.26596823639968536, 0.26160978355896036, 0.17375213455053995, 0.18566475025256435, 0.19230324009442434, 0.19647705108324176, 0.16806653467223365, 0.181827203295311, 0.22091793498991363, 0.19109630170399972, 0.20279815847901783, 0.17468906333778067, 0.19272762605954108, 0.18153438378282605, 0.18935032320738654, 0.1826661386420324, 0.1876762153189222, 0.18196516745695168, 0.19083349472954414, 0.16735102014256242, 0.1697527914496939, 0.17943587464308708, 0.17430903747909565, 0.1722035696085451, 0.1857929586119348, 0.1797279675235579, 0.16908567491477478, 0.16919814669456723, 0.16479889707439488, 0.5119796498014018, 0.20497346769408964, 0.13986993312292162, 0.1930415886336262, 0.1901875812650221, 0.19324636433502362, 0.41525878464791, 0.5297217473654741, 0.1849982490803017, 0.40623889373948285, 0.16390851267215933, 0.36556655179044506, 0.32787115725968097, 0.12653073801503267, 0.14739669038991488, 0.20658575072337093, 0.206993046043763, 0.2069744350928736, 0.184778924682921, 0.18533485612567047, 0.21164328740491622, 0.186168269817792, 0.18143475158215328, 0.1799776739383564, 0.2001493346758061, 0.22895143157774722, 0.18769953310776955, 0.07182818762668208, 0.07757295901491923, 0.07016452003080487, 0.0716855464609143, 0.06963308948155478, 0.07514815441407263, 0.08740027922490512, 0.06921667932281306, 0.0807204952967775]}, "mutation_prompt": null}
{"id": "cece00f5-0945-4291-87ab-d7826ef8c086", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w = 0.7  # inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + self.c1 * r1 * (pbest[i] - pos[i]) \n                          + self.c2 * r2 * (gbest - pos[i]))\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # DE mutation and crossover\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + self.F * (pos[b] - pos[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "A hybridized particle swarm optimization with differential evolution crossover strategy to balance exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "40787ef0-c554-46a0-aa18-ba3df1833598", "metadata": {"aucs": [0.4016901880192427, 0.39861263029075744, 0.37489310759591177, 0.4639303723285868, 0.39106495160734334, 0.4111416833146192, 0.4136907172994685, 0.44149734465156854, 0.3979330681351334, 0.0820091194562963, 0.10146929687387563, 0.05621694784836995, 0.09715260374990953, 0.09223935167245123, 0.03897532693278005, 0.08542396640096928, 0.08978032197604568, 0.028691809679121993, 0.08108260718214555, 0.08609383069810117, 0.09667013837118665, 0.0727879385749518, 0.08416145029423128, 0.08447213724015623, 0.08065880272855885, 0.11175094721289147, 0.08449255272883205, 0.07829574333313316, 0.07189293090766058, 0.09077394118776227, 0.07305263130553463, 0.06683531126059006, 0.08718533140289508, 0.0692067301006507, 0.07055123330669577, 0.08929577359888974, 0.9864495891144499, 0.9867051892400349, 0.9863039438342529, 0.9823051558756085, 0.9905545244797849, 0.9864709250922414, 0.9856484962487134, 0.9865748960204279, 0.9914888143408442, 0.22092939496741149, 0.23024488489852324, 0.21278523473173994, 0.20159859782536838, 0.20882453159954306, 0.15882088173481812, 0.20735110737162044, 0.21991482703216247, 0.2038689806635975, 0.265226758158266, 0.34723517107538937, 0.24738694487470414, 0.38364987800333383, 0.25526630249255566, 0.2481589747366203, 0.23861857972020328, 0.27291691766135606, 0.2707433990348962, 0.12965738932164217, 0.126221757357446, 0.06938026259380325, 0.10139340634518268, 0.12476512536012829, 0.12162957015120823, 0.11882643238322421, 0.11342992601042223, 0.1128961047779854, 0.1105498502129838, 0.16080058846572975, 0.09855458633866332, 0.14695430481117988, 0.12284044820252293, 0.12582491987476918, 0.1309969516519317, 0.10020333942499293, 0.11655652062562116, 9.999999999998899e-05, 0.006791742317502791, 9.999999999998899e-05, 0.014497811565455598, 9.999999999998899e-05, 0.0002806965107825521, 9.999999999998899e-05, 0.027881967602052415, 0.0005161802280335692, 0.06526720096877503, 0.032312071918699226, 0.03228398828993362, 0.11161999220776742, 0.06198907904244644, 0.08423839724740323, 0.0491024198608766, 0.06354483558167356, 0.08085872010440087, 9.999999999998899e-05, 0.003789587646211623, 9.999999999998899e-05, 0.011128240582080395, 0.016724490437171502, 0.00293114123140803, 9.999999999998899e-05, 0.014751340209712693, 9.999999999998899e-05, 0.06468732702685143, 0.07956882951484623, 0.11630244574613391, 0.04790848461663466, 0.030253994672392204, 0.09920156641324451, 0.04611745833373093, 0.11459333675917094, 0.0728897433074378, 0.369592596514536, 0.3802792505018644, 0.35187875060068896, 0.3574227468962077, 0.3908355673243158, 0.3399827972123419, 0.3790825560357848, 0.39462282505293167, 0.3687874397281262, 0.09952048884663323, 0.10390377935639139, 0.0856813242045642, 0.08050011334598262, 0.10720967627117339, 0.09138551966447317, 0.0702710802869575, 0.09675714368162502, 0.07216004205763582, 0.16648188131793484, 0.2155649536599643, 0.24286954946965367, 0.28436709771842383, 0.1953175891489507, 0.1863538079467567, 0.19336552285109443, 0.1647866319183584, 0.21754060845620316, 0.2479060012384663, 0.2526983360995312, 0.23989818513257277, 0.2507620959375547, 0.2527536007740818, 0.23801569921643873, 0.29247095564648706, 0.26596823639968536, 0.26160978355896036, 0.17375213455053995, 0.18566475025256435, 0.19230324009442434, 0.19647705108324176, 0.16806653467223365, 0.181827203295311, 0.22091793498991363, 0.19109630170399972, 0.20279815847901783, 0.17468906333778067, 0.19272762605954108, 0.18153438378282605, 0.18935032320738654, 0.1826661386420324, 0.1876762153189222, 0.18196516745695168, 0.19083349472954414, 0.16735102014256242, 0.1697527914496939, 0.17943587464308708, 0.17430903747909565, 0.1722035696085451, 0.1857929586119348, 0.1797279675235579, 0.16908567491477478, 0.16919814669456723, 0.16479889707439488, 0.5119796498014018, 0.20497346769408964, 0.13986993312292162, 0.1930415886336262, 0.1901875812650221, 0.19324636433502362, 0.41525878464791, 0.5297217473654741, 0.1849982490803017, 0.40623889373948285, 0.16390851267215933, 0.36556655179044506, 0.32787115725968097, 0.12653073801503267, 0.14739669038991488, 0.20658575072337093, 0.206993046043763, 0.2069744350928736, 0.184778924682921, 0.18533485612567047, 0.21164328740491622, 0.186168269817792, 0.18143475158215328, 0.1799776739383564, 0.2001493346758061, 0.22895143157774722, 0.18769953310776955, 0.07182818762668208, 0.07757295901491923, 0.07016452003080487, 0.0716855464609143, 0.06963308948155478, 0.07514815441407263, 0.08740027922490512, 0.06921667932281306, 0.0807204952967775]}, "mutation_prompt": null}
{"id": "8fd8fc64-36b0-42bf-b778-66bb4ff9a7f6", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w = 0.7  # inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + self.c1 * r1 * (pbest[i] - pos[i]) \n                          + self.c2 * r2 * (gbest - pos[i]))\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # DE mutation and crossover\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + self.F * (pos[b] - pos[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "A hybridized particle swarm optimization with differential evolution crossover strategy to balance exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "40787ef0-c554-46a0-aa18-ba3df1833598", "metadata": {"aucs": [0.4016901880192427, 0.39861263029075744, 0.37489310759591177, 0.4639303723285868, 0.39106495160734334, 0.4111416833146192, 0.4136907172994685, 0.44149734465156854, 0.3979330681351334, 0.0820091194562963, 0.10146929687387563, 0.05621694784836995, 0.09715260374990953, 0.09223935167245123, 0.03897532693278005, 0.08542396640096928, 0.08978032197604568, 0.028691809679121993, 0.08108260718214555, 0.08609383069810117, 0.09667013837118665, 0.0727879385749518, 0.08416145029423128, 0.08447213724015623, 0.08065880272855885, 0.11175094721289147, 0.08449255272883205, 0.07829574333313316, 0.07189293090766058, 0.09077394118776227, 0.07305263130553463, 0.06683531126059006, 0.08718533140289508, 0.0692067301006507, 0.07055123330669577, 0.08929577359888974, 0.9864495891144499, 0.9867051892400349, 0.9863039438342529, 0.9823051558756085, 0.9905545244797849, 0.9864709250922414, 0.9856484962487134, 0.9865748960204279, 0.9914888143408442, 0.22092939496741149, 0.23024488489852324, 0.21278523473173994, 0.20159859782536838, 0.20882453159954306, 0.15882088173481812, 0.20735110737162044, 0.21991482703216247, 0.2038689806635975, 0.265226758158266, 0.34723517107538937, 0.24738694487470414, 0.38364987800333383, 0.25526630249255566, 0.2481589747366203, 0.23861857972020328, 0.27291691766135606, 0.2707433990348962, 0.12965738932164217, 0.126221757357446, 0.06938026259380325, 0.10139340634518268, 0.12476512536012829, 0.12162957015120823, 0.11882643238322421, 0.11342992601042223, 0.1128961047779854, 0.1105498502129838, 0.16080058846572975, 0.09855458633866332, 0.14695430481117988, 0.12284044820252293, 0.12582491987476918, 0.1309969516519317, 0.10020333942499293, 0.11655652062562116, 9.999999999998899e-05, 0.006791742317502791, 9.999999999998899e-05, 0.014497811565455598, 9.999999999998899e-05, 0.0002806965107825521, 9.999999999998899e-05, 0.027881967602052415, 0.0005161802280335692, 0.06526720096877503, 0.032312071918699226, 0.03228398828993362, 0.11161999220776742, 0.06198907904244644, 0.08423839724740323, 0.0491024198608766, 0.06354483558167356, 0.08085872010440087, 9.999999999998899e-05, 0.003789587646211623, 9.999999999998899e-05, 0.011128240582080395, 0.016724490437171502, 0.00293114123140803, 9.999999999998899e-05, 0.014751340209712693, 9.999999999998899e-05, 0.06468732702685143, 0.07956882951484623, 0.11630244574613391, 0.04790848461663466, 0.030253994672392204, 0.09920156641324451, 0.04611745833373093, 0.11459333675917094, 0.0728897433074378, 0.369592596514536, 0.3802792505018644, 0.35187875060068896, 0.3574227468962077, 0.3908355673243158, 0.3399827972123419, 0.3790825560357848, 0.39462282505293167, 0.3687874397281262, 0.09952048884663323, 0.10390377935639139, 0.0856813242045642, 0.08050011334598262, 0.10720967627117339, 0.09138551966447317, 0.0702710802869575, 0.09675714368162502, 0.07216004205763582, 0.16648188131793484, 0.2155649536599643, 0.24286954946965367, 0.28436709771842383, 0.1953175891489507, 0.1863538079467567, 0.19336552285109443, 0.1647866319183584, 0.21754060845620316, 0.2479060012384663, 0.2526983360995312, 0.23989818513257277, 0.2507620959375547, 0.2527536007740818, 0.23801569921643873, 0.29247095564648706, 0.26596823639968536, 0.26160978355896036, 0.17375213455053995, 0.18566475025256435, 0.19230324009442434, 0.19647705108324176, 0.16806653467223365, 0.181827203295311, 0.22091793498991363, 0.19109630170399972, 0.20279815847901783, 0.17468906333778067, 0.19272762605954108, 0.18153438378282605, 0.18935032320738654, 0.1826661386420324, 0.1876762153189222, 0.18196516745695168, 0.19083349472954414, 0.16735102014256242, 0.1697527914496939, 0.17943587464308708, 0.17430903747909565, 0.1722035696085451, 0.1857929586119348, 0.1797279675235579, 0.16908567491477478, 0.16919814669456723, 0.16479889707439488, 0.5119796498014018, 0.20497346769408964, 0.13986993312292162, 0.1930415886336262, 0.1901875812650221, 0.19324636433502362, 0.41525878464791, 0.5297217473654741, 0.1849982490803017, 0.40623889373948285, 0.16390851267215933, 0.36556655179044506, 0.32787115725968097, 0.12653073801503267, 0.14739669038991488, 0.20658575072337093, 0.206993046043763, 0.2069744350928736, 0.184778924682921, 0.18533485612567047, 0.21164328740491622, 0.186168269817792, 0.18143475158215328, 0.1799776739383564, 0.2001493346758061, 0.22895143157774722, 0.18769953310776955, 0.07182818762668208, 0.07757295901491923, 0.07016452003080487, 0.0716855464609143, 0.06963308948155478, 0.07514815441407263, 0.08740027922490512, 0.06921667932281306, 0.0807204952967775]}, "mutation_prompt": null}
{"id": "cc6959c7-b223-4425-a42d-7a2be80f6bd3", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w = 0.7  # inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Update velocities and positions\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + self.c1 * r1 * (pbest[i] - pos[i]) \n                          + self.c2 * r2 * (gbest - pos[i]))\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # DE mutation and crossover\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + self.F * (pos[b] - pos[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "A hybridized particle swarm optimization with differential evolution crossover strategy to balance exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "40787ef0-c554-46a0-aa18-ba3df1833598", "metadata": {"aucs": [0.4016901880192427, 0.39861263029075744, 0.37489310759591177, 0.4639303723285868, 0.39106495160734334, 0.4111416833146192, 0.4136907172994685, 0.44149734465156854, 0.3979330681351334, 0.0820091194562963, 0.10146929687387563, 0.05621694784836995, 0.09715260374990953, 0.09223935167245123, 0.03897532693278005, 0.08542396640096928, 0.08978032197604568, 0.028691809679121993, 0.08108260718214555, 0.08609383069810117, 0.09667013837118665, 0.0727879385749518, 0.08416145029423128, 0.08447213724015623, 0.08065880272855885, 0.11175094721289147, 0.08449255272883205, 0.07829574333313316, 0.07189293090766058, 0.09077394118776227, 0.07305263130553463, 0.06683531126059006, 0.08718533140289508, 0.0692067301006507, 0.07055123330669577, 0.08929577359888974, 0.9864495891144499, 0.9867051892400349, 0.9863039438342529, 0.9823051558756085, 0.9905545244797849, 0.9864709250922414, 0.9856484962487134, 0.9865748960204279, 0.9914888143408442, 0.22092939496741149, 0.23024488489852324, 0.21278523473173994, 0.20159859782536838, 0.20882453159954306, 0.15882088173481812, 0.20735110737162044, 0.21991482703216247, 0.2038689806635975, 0.265226758158266, 0.34723517107538937, 0.24738694487470414, 0.38364987800333383, 0.25526630249255566, 0.2481589747366203, 0.23861857972020328, 0.27291691766135606, 0.2707433990348962, 0.12965738932164217, 0.126221757357446, 0.06938026259380325, 0.10139340634518268, 0.12476512536012829, 0.12162957015120823, 0.11882643238322421, 0.11342992601042223, 0.1128961047779854, 0.1105498502129838, 0.16080058846572975, 0.09855458633866332, 0.14695430481117988, 0.12284044820252293, 0.12582491987476918, 0.1309969516519317, 0.10020333942499293, 0.11655652062562116, 9.999999999998899e-05, 0.006791742317502791, 9.999999999998899e-05, 0.014497811565455598, 9.999999999998899e-05, 0.0002806965107825521, 9.999999999998899e-05, 0.027881967602052415, 0.0005161802280335692, 0.06526720096877503, 0.032312071918699226, 0.03228398828993362, 0.11161999220776742, 0.06198907904244644, 0.08423839724740323, 0.0491024198608766, 0.06354483558167356, 0.08085872010440087, 9.999999999998899e-05, 0.003789587646211623, 9.999999999998899e-05, 0.011128240582080395, 0.016724490437171502, 0.00293114123140803, 9.999999999998899e-05, 0.014751340209712693, 9.999999999998899e-05, 0.06468732702685143, 0.07956882951484623, 0.11630244574613391, 0.04790848461663466, 0.030253994672392204, 0.09920156641324451, 0.04611745833373093, 0.11459333675917094, 0.0728897433074378, 0.369592596514536, 0.3802792505018644, 0.35187875060068896, 0.3574227468962077, 0.3908355673243158, 0.3399827972123419, 0.3790825560357848, 0.39462282505293167, 0.3687874397281262, 0.09952048884663323, 0.10390377935639139, 0.0856813242045642, 0.08050011334598262, 0.10720967627117339, 0.09138551966447317, 0.0702710802869575, 0.09675714368162502, 0.07216004205763582, 0.16648188131793484, 0.2155649536599643, 0.24286954946965367, 0.28436709771842383, 0.1953175891489507, 0.1863538079467567, 0.19336552285109443, 0.1647866319183584, 0.21754060845620316, 0.2479060012384663, 0.2526983360995312, 0.23989818513257277, 0.2507620959375547, 0.2527536007740818, 0.23801569921643873, 0.29247095564648706, 0.26596823639968536, 0.26160978355896036, 0.17375213455053995, 0.18566475025256435, 0.19230324009442434, 0.19647705108324176, 0.16806653467223365, 0.181827203295311, 0.22091793498991363, 0.19109630170399972, 0.20279815847901783, 0.17468906333778067, 0.19272762605954108, 0.18153438378282605, 0.18935032320738654, 0.1826661386420324, 0.1876762153189222, 0.18196516745695168, 0.19083349472954414, 0.16735102014256242, 0.1697527914496939, 0.17943587464308708, 0.17430903747909565, 0.1722035696085451, 0.1857929586119348, 0.1797279675235579, 0.16908567491477478, 0.16919814669456723, 0.16479889707439488, 0.5119796498014018, 0.20497346769408964, 0.13986993312292162, 0.1930415886336262, 0.1901875812650221, 0.19324636433502362, 0.41525878464791, 0.5297217473654741, 0.1849982490803017, 0.40623889373948285, 0.16390851267215933, 0.36556655179044506, 0.32787115725968097, 0.12653073801503267, 0.14739669038991488, 0.20658575072337093, 0.206993046043763, 0.2069744350928736, 0.184778924682921, 0.18533485612567047, 0.21164328740491622, 0.186168269817792, 0.18143475158215328, 0.1799776739383564, 0.2001493346758061, 0.22895143157774722, 0.18769953310776955, 0.07182818762668208, 0.07757295901491923, 0.07016452003080487, 0.0716855464609143, 0.06963308948155478, 0.07514815441407263, 0.08740027922490512, 0.06921667932281306, 0.0807204952967775]}, "mutation_prompt": null}
{"id": "297d5893-69af-4579-b7f4-ab23cdcf326d", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight\n            self.w = self.w_max - (self.w_max - self.w_min) * (eval_count / self.budget)\n            for i in range(self.population_size):\n                # Update velocities and positions\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + self.c1 * r1 * (pbest[i] - pos[i]) \n                          + self.c2 * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # DE mutation and crossover\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + self.F * (pos[b] - pos[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Enhance exploration by introducing adaptive inertia weight and velocity clamping to improve convergence.", "configspace": "", "generation": 4, "fitness": 0.26772267052578613, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "40787ef0-c554-46a0-aa18-ba3df1833598", "metadata": {"aucs": [0.5681525150308431, 0.5674859453410299, 0.5556895280806051, 0.5860349541753436, 0.5861447242344113, 0.5356564963750614, 0.5883136746977414, 0.5764716406691559, 0.5565786528803953, 0.19281256780954836, 0.17220579888650533, 0.18071192923526636, 0.17930932398506905, 0.1907346032267686, 0.1616523250617422, 0.1395309541055032, 0.17055437683694274, 0.13384236537702765, 0.12596177304538902, 0.12416771994091336, 0.07397471412394074, 0.12359550592172452, 0.15182107587066473, 0.12902824424747195, 0.082683927880434, 0.16655120224658948, 0.13981708516175273, 0.11075124032817985, 0.09867151692188514, 0.1085426257115294, 0.10435030996124406, 0.10270226751997635, 0.10829478779631552, 0.10009042710269311, 0.10027830285877448, 0.1051096337258356, 0.8993148251725356, 0.8647333522842482, 0.9026665152674854, 0.9054715609589608, 0.8984083672229268, 0.8929916251252897, 0.9047861304738796, 0.8877251907090807, 0.904751784524147, 0.4159741448487372, 0.3997403938877967, 0.36711857724800145, 0.3842789399620511, 0.3838948413075265, 0.34867710121073736, 0.36810156720873144, 0.3890617594929504, 0.37630397925558057, 0.6301261740067292, 0.6495652052635696, 0.2260072391649417, 0.21123152690431757, 0.7085778548513907, 0.271909986310938, 0.23226857810320634, 0.2326583205994036, 0.6774189287395341, 0.2763513846655643, 0.26471030660668704, 0.2381583574462146, 0.22224341276196025, 0.23552236220488476, 0.24568874848553413, 0.25653821810538324, 0.29657056441689544, 0.2407249532719038, 0.22664469916011865, 0.2113209275541057, 0.22956752892542232, 0.2607422671250854, 0.2353143528518129, 0.2751278881495701, 0.1311609254750663, 0.24246302132349962, 0.22234451353578444, 0.030724306732595297, 0.09873377534463124, 0.024312124574506377, 0.03908558129543349, 0.06254761894806615, 0.020188020708931664, 0.0933166699174377, 0.0771813255561341, 0.04950615580533779, 0.13060444563472196, 0.11090820485617114, 0.09604114866142122, 0.14257693440028651, 0.0943872664660228, 0.09306313928768084, 0.10587530578763094, 0.07868881904702829, 0.12241137754979681, 0.021756082531717236, 0.04250679349850739, 0.0635268174506064, 0.03266088625587804, 0.035106275666285325, 0.030279689870337467, 0.08283028609088161, 0.0746008990820306, 0.0615333333135657, 0.14148336937267836, 0.16108167258045847, 0.11743046803755419, 0.15472026425398744, 0.1651110871995255, 0.1623058150356872, 0.1621797125582769, 0.1758348078983687, 0.18727030975764836, 0.5101054521391373, 0.5016603723439985, 0.4791329009391798, 0.4998648653804859, 0.5068389857943727, 0.4760653462650073, 0.48876974490980496, 0.49068329484561235, 0.4658150154304399, 0.09128689048857719, 0.11824183119278697, 0.08360164809479975, 0.127178285012014, 0.1545130225854513, 0.1335335645620147, 0.1438876627520531, 0.13083688818004102, 0.10370907769272086, 0.35966454805141423, 0.33143391885797, 0.191438197384884, 0.31625282032133695, 0.3940812497133034, 0.3379285074969144, 0.34428223911168887, 0.2519339776674544, 0.3202725097730238, 0.3364425102676837, 0.3258980486895636, 0.33566748834465654, 0.36897268207308065, 0.32414443119888137, 0.36076264991451656, 0.3438517263566422, 0.34631844246633925, 0.23541843580026722, 0.29768501174884077, 0.28194465693133974, 0.26627215352304634, 0.29302944517442275, 0.2550165526468754, 0.23972336470525302, 0.19929870286694118, 0.23980527609061475, 0.21668801055699616, 0.2298708466227929, 0.2212036901972726, 0.23207721123877634, 0.2339522174459825, 0.25709220325598503, 0.2250806630708183, 0.21585803471352394, 0.25458731863639994, 0.22584678861584262, 0.19151854275519442, 0.22882719114963146, 0.18084023728610743, 0.19834153905722451, 0.21613566937196016, 0.1997878477246504, 0.19301071293961503, 0.3740946374333841, 0.19942848060360885, 0.18560425302337458, 0.7900051120479457, 0.18496219155619786, 0.7963109962394816, 0.19748088671656405, 0.17062602517531655, 0.1412876102386268, 0.121411374060864, 0.15215958398748886, 0.7479694807908168, 0.20786081964095326, 0.7199048161293442, 0.2065642941940814, 0.20855025997883603, 0.20680655914989, 0.10388235210792995, 0.16757027046076056, 0.650404276817163, 0.19022701464774583, 0.18448307639837114, 0.1819957669442358, 0.18005330134235686, 0.17738136663915904, 0.18562362316174108, 0.18348530352153725, 0.17880519212712664, 0.18625816196577338, 0.09463618542191743, 0.10414851644705136, 0.08902902561883363, 0.09841461314407662, 0.08479797499851116, 0.11754544597296424, 0.0740620236605749, 0.08496549450798319, 0.08971291670069437]}, "mutation_prompt": null}
{"id": "3290e04e-680c-4420-ba2b-6ba8f9eec991", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            self.w = self.w_max - (self.w_max - self.w_min) * chaos_val\n            \n            for i in range(self.population_size):\n                # Update velocities and positions\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + self.c1 * r1 * (pbest[i] - pos[i]) \n                          + self.c2 * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # DE mutation and crossover\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + self.F * (pos[b] - pos[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce chaotic mapping in inertia weight calculation to enhance global search and convergence.", "configspace": "", "generation": 5, "fitness": 0.28699893191882536, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "297d5893-69af-4579-b7f4-ab23cdcf326d", "metadata": {"aucs": [0.6846087568521031, 0.6436699431977724, 0.6134694336286847, 0.6451773920111952, 0.6438642044020029, 0.6257531173418573, 0.6272498350516693, 0.686099450402636, 0.6104245871165315, 0.2491109327297546, 0.2515430379412852, 0.2471001386188989, 0.21383548772591998, 0.2921792294429152, 0.227495405137209, 0.19345043059173606, 0.2881858466150562, 0.12468938606882862, 0.0938822097103219, 0.151721180674111, 0.0932534455121189, 0.10418557341743018, 0.10602260195285129, 0.13570171428298472, 0.10980129028912489, 0.1760527069765654, 0.13228376534892194, 0.11094546765084545, 0.12997090821328405, 0.09853291883073922, 0.1313157135850399, 0.12620035112486616, 0.1466411229591157, 0.08625687795709458, 0.10661108466370572, 0.11545353952810544, 0.8916265099027475, 0.8699065839758444, 0.9061671384267374, 0.8942829574850848, 0.8841595845628574, 0.8925702689174875, 0.8941772118874928, 0.8722843685568964, 0.9126265509754522, 0.42154372246803273, 0.3959317419351359, 0.3691691975608662, 0.3976925159975435, 0.3967096134452287, 0.40096591465742026, 0.4115437292223053, 0.42636505626720744, 0.3978753556178566, 0.7535514376419337, 0.7624632063955591, 0.22599501160714663, 0.7000122709863396, 0.8025468824690336, 0.2659640516622771, 0.23270773169418546, 0.22825833632600667, 0.7505542911581309, 0.2881786139107655, 0.2880941631531123, 0.24932810112984105, 0.12661417939857944, 0.22130146296933018, 0.29692047907118135, 0.26162916991832086, 0.27626747186248324, 0.24785176373158124, 0.313698468267945, 0.2655163336483869, 0.3082199050937723, 0.27193291849191203, 0.30668201856572697, 0.27083620331060376, 0.24654423682054538, 0.24344150628108596, 0.23467837881732923, 0.12361959092753583, 0.0649669596409127, 0.11099677918261819, 0.04210682526447507, 0.08245643795120416, 0.03668197416615149, 0.07711432900203341, 0.05166384257848455, 0.084933262530836, 0.18566301335903967, 0.14251749617931164, 0.20585453821040123, 0.08598254268317973, 0.08688496835705573, 0.10152181801054228, 0.08323410777668827, 0.1294105543461883, 0.11685066736982697, 0.09119376450996775, 0.07025926181749309, 0.08699569762062453, 0.06204707088659489, 0.06491654383734291, 0.027475701874821623, 0.06739121389753433, 0.108798943186317, 0.07983501783609959, 0.13706168692080412, 0.12934855817116309, 0.1890146751858478, 0.1828397246857053, 0.20440528462259722, 0.17776086108903733, 0.19508864993192399, 0.17030582652323534, 0.14043238533979474, 0.5357010080558748, 0.5495937117993104, 0.5218243105709774, 0.4915893372113356, 0.5494701454502029, 0.5155752726348417, 0.5452269544425781, 0.5497520529488382, 0.5180385415326704, 0.1171719973750247, 0.14923732440546478, 0.08653727105794318, 0.148481890869672, 0.12914552893269482, 0.08590529436923167, 0.16063102503554905, 0.10953083269606345, 0.1310758914652641, 0.3687759704656396, 0.3158665399641596, 0.33272053786853195, 0.400128716598241, 0.3105873509259365, 0.31319384122735594, 0.32526218003191165, 0.3520577679519511, 0.3225493645604286, 0.25959466408633036, 0.3541998332289782, 0.3614660262668714, 0.3549622090813469, 0.37484601227276626, 0.34645395133418744, 0.273878493867583, 0.34668879943503084, 0.21851661582162385, 0.2538209123806707, 0.30500488372055656, 0.2496680035385872, 0.2980743584983353, 0.28976404650214227, 0.2990776401103141, 0.21466124431242328, 0.2751843407408566, 0.2924606930655488, 0.20001022661501244, 0.20099963591284742, 0.19624210886461313, 0.2655528197149146, 0.23180061507892535, 0.22453161598161941, 0.23707496591757504, 0.21618566950095042, 0.2312690859179768, 0.19246134235159484, 0.19074746977299506, 0.17428163490375626, 0.19249007316078437, 0.21853703937632307, 0.20354734130157826, 0.18866328840666124, 0.2033271288548142, 0.17482418021426205, 0.18472312722540618, 0.18572019528894446, 0.18538968500288877, 0.8784756239021146, 0.19822804657911608, 0.19754188812250062, 0.14153635677031506, 0.16671317157306842, 0.15243322102045387, 0.8355175147261321, 0.20895999727696823, 0.792027749855286, 0.20703480264309593, 0.16569668591016995, 0.20685164050168925, 0.7148945673070849, 0.16797279352280547, 0.7439885731777431, 0.2022916905436104, 0.18409432111616364, 0.19483467340853577, 0.18512409697222865, 0.178924872896845, 0.17885903625506383, 0.18089949382887505, 0.18255878372349488, 0.18837350519161145, 0.08852758277163941, 0.088468572552448, 0.09966402475011416, 0.09697428155625143, 0.09794631330544612, 0.0874519106562397, 0.08957605728689666, 0.09845404947420555, 0.0927844779397965]}, "mutation_prompt": null}
{"id": "63cf6da0-11eb-48f0-bf98-eca757614732", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            self.w = self.w_max - (self.w_max - self.w_min) * chaos_val\n            \n            for i in range(self.population_size):\n                # Update velocities and positions\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + self.c1 * r1 * (pbest[i] - pos[i]) \n                          + self.c2 * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # DE mutation and crossover\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + self.F * (pos[b] - pos[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce chaotic mapping in inertia weight calculation to enhance global search and convergence.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3290e04e-680c-4420-ba2b-6ba8f9eec991", "metadata": {"aucs": [0.6846087568521031, 0.6436699431977724, 0.6134694336286847, 0.6451773920111952, 0.6438642044020029, 0.6257531173418573, 0.6272498350516693, 0.686099450402636, 0.6104245871165315, 0.2491109327297546, 0.2515430379412852, 0.2471001386188989, 0.21383548772591998, 0.2921792294429152, 0.227495405137209, 0.19345043059173606, 0.2881858466150562, 0.12468938606882862, 0.0938822097103219, 0.151721180674111, 0.0932534455121189, 0.10418557341743018, 0.10602260195285129, 0.13570171428298472, 0.10980129028912489, 0.1760527069765654, 0.13228376534892194, 0.11094546765084545, 0.12997090821328405, 0.09853291883073922, 0.1313157135850399, 0.12620035112486616, 0.1466411229591157, 0.08625687795709458, 0.10661108466370572, 0.11545353952810544, 0.8916265099027475, 0.8699065839758444, 0.9061671384267374, 0.8942829574850848, 0.8841595845628574, 0.8925702689174875, 0.8941772118874928, 0.8722843685568964, 0.9126265509754522, 0.42154372246803273, 0.3959317419351359, 0.3691691975608662, 0.3976925159975435, 0.3967096134452287, 0.40096591465742026, 0.4115437292223053, 0.42636505626720744, 0.3978753556178566, 0.7535514376419337, 0.7624632063955591, 0.22599501160714663, 0.7000122709863396, 0.8025468824690336, 0.2659640516622771, 0.23270773169418546, 0.22825833632600667, 0.7505542911581309, 0.2881786139107655, 0.2880941631531123, 0.24932810112984105, 0.12661417939857944, 0.22130146296933018, 0.29692047907118135, 0.26162916991832086, 0.27626747186248324, 0.24785176373158124, 0.313698468267945, 0.2655163336483869, 0.3082199050937723, 0.27193291849191203, 0.30668201856572697, 0.27083620331060376, 0.24654423682054538, 0.24344150628108596, 0.23467837881732923, 0.12361959092753583, 0.0649669596409127, 0.11099677918261819, 0.04210682526447507, 0.08245643795120416, 0.03668197416615149, 0.07711432900203341, 0.05166384257848455, 0.084933262530836, 0.18566301335903967, 0.14251749617931164, 0.20585453821040123, 0.08598254268317973, 0.08688496835705573, 0.10152181801054228, 0.08323410777668827, 0.1294105543461883, 0.11685066736982697, 0.09119376450996775, 0.07025926181749309, 0.08699569762062453, 0.06204707088659489, 0.06491654383734291, 0.027475701874821623, 0.06739121389753433, 0.108798943186317, 0.07983501783609959, 0.13706168692080412, 0.12934855817116309, 0.1890146751858478, 0.1828397246857053, 0.20440528462259722, 0.17776086108903733, 0.19508864993192399, 0.17030582652323534, 0.14043238533979474, 0.5357010080558748, 0.5495937117993104, 0.5218243105709774, 0.4915893372113356, 0.5494701454502029, 0.5155752726348417, 0.5452269544425781, 0.5497520529488382, 0.5180385415326704, 0.1171719973750247, 0.14923732440546478, 0.08653727105794318, 0.148481890869672, 0.12914552893269482, 0.08590529436923167, 0.16063102503554905, 0.10953083269606345, 0.1310758914652641, 0.3687759704656396, 0.3158665399641596, 0.33272053786853195, 0.400128716598241, 0.3105873509259365, 0.31319384122735594, 0.32526218003191165, 0.3520577679519511, 0.3225493645604286, 0.25959466408633036, 0.3541998332289782, 0.3614660262668714, 0.3549622090813469, 0.37484601227276626, 0.34645395133418744, 0.273878493867583, 0.34668879943503084, 0.21851661582162385, 0.2538209123806707, 0.30500488372055656, 0.2496680035385872, 0.2980743584983353, 0.28976404650214227, 0.2990776401103141, 0.21466124431242328, 0.2751843407408566, 0.2924606930655488, 0.20001022661501244, 0.20099963591284742, 0.19624210886461313, 0.2655528197149146, 0.23180061507892535, 0.22453161598161941, 0.23707496591757504, 0.21618566950095042, 0.2312690859179768, 0.19246134235159484, 0.19074746977299506, 0.17428163490375626, 0.19249007316078437, 0.21853703937632307, 0.20354734130157826, 0.18866328840666124, 0.2033271288548142, 0.17482418021426205, 0.18472312722540618, 0.18572019528894446, 0.18538968500288877, 0.8784756239021146, 0.19822804657911608, 0.19754188812250062, 0.14153635677031506, 0.16671317157306842, 0.15243322102045387, 0.8355175147261321, 0.20895999727696823, 0.792027749855286, 0.20703480264309593, 0.16569668591016995, 0.20685164050168925, 0.7148945673070849, 0.16797279352280547, 0.7439885731777431, 0.2022916905436104, 0.18409432111616364, 0.19483467340853577, 0.18512409697222865, 0.178924872896845, 0.17885903625506383, 0.18089949382887505, 0.18255878372349488, 0.18837350519161145, 0.08852758277163941, 0.088468572552448, 0.09966402475011416, 0.09697428155625143, 0.09794631330544612, 0.0874519106562397, 0.08957605728689666, 0.09845404947420555, 0.0927844779397965]}, "mutation_prompt": null}
{"id": "d659bc0f-dcb3-4acc-b2dd-01ee1a0cec2d", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            self.w = self.w_max - (self.w_max - self.w_min) * chaos_val\n            \n            for i in range(self.population_size):\n                # Update velocities and positions\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + self.c1 * r1 * (pbest[i] - pos[i]) \n                          + self.c2 * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Adaptive DE scaling factor\n                F_adaptive = 0.4 + 0.3 * chaos_val\n\n                # DE mutation and crossover\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Incorporate adaptive scaling factor in DE to enhance exploration and convergence balance.", "configspace": "", "generation": 7, "fitness": 0.28894433822230176, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "3290e04e-680c-4420-ba2b-6ba8f9eec991", "metadata": {"aucs": [0.5984744940404858, 0.6370668776695227, 0.5826330102922057, 0.6147318207981471, 0.6358649223917981, 0.5857586376511414, 0.6172104619233268, 0.6504134434305066, 0.5945026114286812, 0.22602732580473883, 0.2966121091931233, 0.20235935616262613, 0.19776686129452747, 0.2569790048685662, 0.18840757729187407, 0.16669619246316347, 0.25211950389287785, 0.17460563199594548, 0.1327521198095286, 0.1177168237213071, 0.10785199868930506, 0.14552947417614726, 0.11201559884331491, 0.10796781999340399, 0.08683244721643935, 0.27229966959189045, 0.14681427766740274, 0.10395732111973188, 0.1292639780405791, 0.12657067181284853, 0.14181289738947167, 0.10005051326707104, 0.08782763011867156, 0.10429794728379216, 0.1399661206577808, 0.09888206150865375, 0.8865696277156228, 0.894749246199666, 0.8860539228958085, 0.9032338723709582, 0.8879810450594945, 0.8746409747219267, 0.8992279884790408, 0.8980332779516158, 0.9116446548071898, 0.38548080149879604, 0.37546060072877885, 0.37955687091570445, 0.3718312162167843, 0.3808967723297877, 0.3944870723109558, 0.3745248335306557, 0.37447271215142086, 0.37430610766183425, 0.7165316212771009, 0.6746010487195369, 0.17083224210278425, 0.2717178509078466, 0.7664151325892877, 0.8603139881529437, 0.8124714598182626, 0.43067936802567297, 0.7768305198668922, 0.31824581477451286, 0.12674783089794806, 0.2275554327632845, 0.21081054220669593, 0.23347054525824318, 0.2883074430664022, 0.23720101320927311, 0.25331224613525427, 0.23568564323917174, 0.23519473176855432, 0.25446059288002554, 0.2173011089122835, 0.26353641916936543, 0.30090696918068394, 0.2602889066130337, 0.22035850848688943, 0.2510564433877809, 0.20181013330324526, 0.054206205609575786, 0.14373778039096885, 0.014175241816428374, 0.06919869509131149, 0.049238080425123565, 0.10387909848318688, 0.0947101579076387, 0.06597588224701234, 0.007123948564750182, 0.16867158727421105, 0.11548715798181697, 0.1676341259139228, 0.12950409226483517, 0.10821163885297014, 0.09105182742378604, 0.12565013106592182, 0.10309537940004687, 0.08288890546618477, 0.0625935825271472, 0.07023822254721945, 0.0940404434964468, 0.0498337745322448, 0.07515817363731225, 0.03434929911470119, 0.08270297799559467, 0.1136239454344673, 0.07138931359480216, 0.15725941794249265, 0.1375737579041304, 0.17448995578111992, 0.173274606947746, 0.17142232418303704, 0.18621327871148774, 0.192799520574633, 0.16562650925087385, 0.1152257692613734, 0.509535094820117, 0.5080832447223277, 0.5248152397906032, 0.5227198426148892, 0.5517925446137837, 0.49752332696029, 0.5275656497447183, 0.5237050093148466, 0.5209526347511808, 0.11734541459484937, 0.11836712937540528, 0.10763700213847005, 0.13568507502355676, 0.12095953803474024, 0.08959230089725756, 0.15922943157418012, 0.13745685538613728, 0.10721847510150617, 0.1958110534807591, 0.22137349919018, 0.25924099316868965, 0.3877614972575212, 0.28512611556858547, 0.17374778285754533, 0.3304440343585293, 0.28587152873239263, 0.2559245983945819, 0.35191380559227414, 0.36470057644395837, 0.3455540425583612, 0.3369712046390023, 0.35990229468769586, 0.35634727123824284, 0.29506555639257837, 0.3385246986156436, 0.2342074397810302, 0.20647983704055173, 0.30176007841183516, 0.29137906649406153, 0.32220789040799747, 0.2950117350995416, 0.24714356173772012, 0.2100247245970669, 0.23778904268797518, 0.22598145116632584, 0.25054065351626886, 0.2342087990304803, 0.24726272085745737, 0.23752212463802114, 0.2310723807613032, 0.23489048846769744, 0.2508687886773222, 0.25663379025305966, 0.2547999043417122, 0.17803952714285076, 0.21664474950610357, 0.1808754407757095, 0.19846319419103098, 0.22292143458240588, 0.18570071395999466, 0.18467970862184124, 0.209297578607331, 0.19578706464462647, 0.18653117233031813, 0.18540342577653324, 0.18554036845303445, 0.8514727373714317, 0.19775216888367564, 0.8400341396742567, 0.1616190677029654, 0.8248035661926145, 0.15238945648624191, 0.8329130324162727, 0.20831480989996243, 0.767563121446653, 0.20815598778700362, 0.2083109708911084, 0.16508560913226933, 0.7353605231707435, 0.1673899909898644, 0.7291223234014765, 0.18088336856790532, 0.18024733503327806, 0.18167240821465025, 0.18151796934095243, 0.18586313519631903, 0.18692082938213106, 0.19048196187408872, 0.18013411730850237, 0.1944589036921156, 0.08556022295376187, 0.09573768232987623, 0.09539147352009403, 0.10259420369064864, 0.09627083924594682, 0.09218380843985574, 0.08486934912628186, 0.0917991498471431, 0.09828039623634177]}, "mutation_prompt": null}
{"id": "ee83871d-174f-402a-85b0-a6af98897207", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            self.w = self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)\n\n            for i in range(self.population_size):\n                # Update velocities and positions\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + self.c1 * r1 * (pbest[i] - pos[i]) \n                          + self.c2 * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Adaptive DE scaling factor\n                F_adaptive = 0.4 + 0.3 * chaos_val\n\n                # DE mutation and crossover\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Integrate a sinusoidal component into the inertia weight for improved convergence by oscillating exploration and exploitation phases.", "configspace": "", "generation": 8, "fitness": 0.3088984097308043, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "d659bc0f-dcb3-4acc-b2dd-01ee1a0cec2d", "metadata": {"aucs": [0.706642263183064, 0.7210631096783329, 0.7264734301939825, 0.6929065348915034, 0.7104852695568591, 0.6760460189794372, 0.7171592899331366, 0.7007241594475915, 0.6720431124562274, 0.3320770294164811, 0.3005300813005629, 0.310278846244638, 0.2920394125828407, 0.3326841890202159, 0.2616962746253969, 0.27849110417671796, 0.313544703744871, 0.23459242579931827, 0.12164369189703339, 0.11167009520292104, 0.11051701249378343, 0.15067175315729164, 0.10735506848230836, 0.0856802855656491, 0.1354071569662446, 0.16390289903877797, 0.15070651375841992, 0.10847470781874358, 0.10561089527882339, 0.10519449032486716, 0.09292920376376823, 0.13348479423494775, 0.10003093465193069, 0.08187409645261812, 0.1489096709537816, 0.09850731309850469, 0.8931379488740544, 0.8809326230151904, 0.8822706652773289, 0.8999444309642404, 0.8862326747743638, 0.8796709590502864, 0.889362042405408, 0.8964463905644933, 0.9064592722781093, 0.4414404578981548, 0.42769312834638684, 0.39565620988064065, 0.4327204624321562, 0.4294318630563301, 0.4355028163553817, 0.41431040980605016, 0.39080609256908916, 0.4180365994990666, 0.8456754880292967, 0.2253157731410782, 0.8112554669621719, 0.6839183828468206, 0.8714020803618567, 0.7846177118430004, 0.23249475862780156, 0.8007044072320106, 0.24452148451294575, 0.3844072664635828, 0.12957113884602744, 0.28287983757015067, 0.12557837482854173, 0.2606525217200255, 0.25915327129100363, 0.28492336836623344, 0.3600423914583343, 0.23596858680075383, 0.25673772854831756, 0.23236761096401715, 0.2794619156551452, 0.35985471231053057, 0.24652192283144847, 0.3342673798565645, 0.26978939423169823, 0.31736487007948777, 0.23594801458030557, 0.010649960582242768, 0.07578936650844748, 0.00907013378796595, 0.06204124599851579, 0.06264676589400642, 0.14848683077148184, 0.07676399255078248, 0.028047264588632603, 0.006754531126919705, 0.16297564925189267, 0.12502833755261367, 0.20531479928400964, 0.12366982714841379, 0.11137993098293586, 0.09385448565317, 0.14927249416716515, 0.0773720639450064, 0.1649864358085108, 0.10946560430191965, 0.0969643368667088, 0.11998129589770778, 0.1007516107814348, 0.14122496818867836, 0.16747525459786883, 0.08032518594852955, 0.11263683185234075, 0.12714605436791537, 0.1478386031035106, 0.14849360684839485, 0.2148186507406834, 0.19167709238038022, 0.2313269263080091, 0.22346626894055055, 0.2012124750167591, 0.2301370944198049, 0.12998163962853249, 0.6066136136944507, 0.6176377487226767, 0.5403268177075533, 0.5590384079530877, 0.5661573199218848, 0.5544303684769054, 0.5613081502021705, 0.609185487437722, 0.5841192450217281, 0.08891713236478249, 0.13528662293924643, 0.0866102472267245, 0.10282332508131753, 0.14906067440925652, 0.11251808443440148, 0.15434123806742317, 0.14756735147442812, 0.1144364799742601, 0.40065129630895346, 0.18328793025027457, 0.22892780680122826, 0.2548036763473659, 0.36239088085605387, 0.3757223210003885, 0.3722442628557473, 0.27131417364684285, 0.283226002026597, 0.37552087980938054, 0.3725848998147586, 0.2948407567080229, 0.37897095396492375, 0.37900285623021013, 0.36998716042613766, 0.33370843849980036, 0.391997856606056, 0.23667884963065533, 0.3279017427876195, 0.3294339646861272, 0.3414758470794712, 0.30605784231871325, 0.23177531863403844, 0.29170787069421034, 0.20325815512667988, 0.33983712044365133, 0.24085141328851145, 0.25261564758171995, 0.22757298656735236, 0.2229895405437855, 0.27496818651821353, 0.21174729684132632, 0.22322697375725498, 0.25586587864223986, 0.22737423375812382, 0.26367537256248075, 0.1891134818217578, 0.1903459340634821, 0.1997329472387206, 0.18997383153036718, 0.2042142541622176, 0.18561886258974813, 0.19432668738487213, 0.17906211278879836, 0.1850203166814257, 0.18661767399022067, 0.1857350191680318, 0.18547190062547303, 0.8846725479452784, 0.1976292998004443, 0.8602109931797846, 0.16170986454501268, 0.8507631671510515, 0.15241841240573217, 0.8403655043475593, 0.20828619587125274, 0.8193946192918005, 0.2081696448614455, 0.20816591987451505, 0.15286364866960844, 0.7708018566550814, 0.1672518531317786, 0.803576568714427, 0.1859170465941149, 0.1747838531646042, 0.16891230765807197, 0.1832445797223451, 0.17340415932167053, 0.19482826967086397, 0.19176074435296941, 0.193957516414072, 0.1898050014097039, 0.09655991780422524, 0.09405020981003964, 0.0943306267217533, 0.11873235507220437, 0.07906399107833328, 0.09554566988036894, 0.08823410189289083, 0.10148148467265705, 0.09083047822809809]}, "mutation_prompt": null}
{"id": "62d6e350-3d17-4fb0-ad1f-b800570d55f4", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            self.w = self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Adaptive DE scaling factor\n                F_adaptive = 0.4 + 0.3 * chaos_val\n\n                # DE mutation and crossover\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce an adaptive chaotic mapping to dynamically adjust cognitive and social components, enhancing convergence.", "configspace": "", "generation": 9, "fitness": 0.3436386823058417, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.25.", "error": "", "parent_id": "ee83871d-174f-402a-85b0-a6af98897207", "metadata": {"aucs": [0.8178721779963758, 0.8231729094368125, 0.8183158323165045, 0.8210727426398698, 0.8087228533134365, 0.8075774712083701, 0.8354117718574745, 0.8244262159984265, 0.8084600018415455, 0.47295458767525056, 0.45274079937832634, 0.45408638073711594, 0.3200486902557189, 0.48325515706431355, 0.38002701966128183, 0.40233034948000634, 0.4319410424422264, 0.4137031639919757, 0.11328173084046289, 0.15277679155768986, 0.10675584321705422, 0.11987177682392536, 0.1774037462061575, 0.11249022783207241, 0.1140133117695068, 0.1474117220189617, 0.11200773515796936, 0.10863491065192799, 0.1432289394152424, 0.1180625231180289, 0.13723909175245208, 0.09970609930659302, 0.12573006881410476, 0.10931399686045007, 0.11956408568933274, 0.09590323153221925, 0.8881604282783372, 0.8572146657596182, 0.8937769882993802, 0.9019128848839646, 0.8805015966377604, 0.8881627164100284, 0.8746588461758402, 0.9031080491262975, 0.9067989180749284, 0.5427925039035152, 0.5663954401938064, 0.5217395982028248, 0.5480351278645117, 0.5821747253588871, 0.5328389383537094, 0.5200442858867391, 0.5182025479644747, 0.5387408277690278, 0.8544020516201067, 0.2272320894189599, 0.8362760516237495, 0.27607009297346363, 0.8743784963696848, 0.270310462614172, 0.8411879054698538, 0.22947488740556732, 0.7840583367584579, 0.5321804673397632, 0.5329636789836563, 0.32001028156258604, 0.12813175201623417, 0.4832003373626311, 0.3589242907407122, 0.3692248486974916, 0.4211485554766117, 0.1325538790679346, 0.43972368304260967, 0.3333190114198751, 0.3561831325893068, 0.36732660267113926, 0.40085831428313845, 0.34486029072034086, 0.4607769939705739, 0.4041527735873608, 0.31378159684728857, 0.07797928682541311, 0.02557177704074931, 0.26585524264407556, 0.0781443450588657, 0.03564876166642772, 0.20762078490772917, 0.2415105821657173, 0.2110037818011622, 0.0817037452729753, 0.13571933219118004, 0.13433013137972427, 0.17817203460598863, 0.1663935085898498, 0.053411669558918184, 0.08449366977778794, 0.12288235251575919, 0.1617983312537914, 0.19959996736827235, 0.07989819625102446, 0.3251718629275058, 0.14661380694390025, 0.11739453795245969, 0.12194534785553002, 0.2211670453210587, 0.13270930856384022, 0.11378115045451964, 0.16539946341729683, 0.2567720262220531, 0.17221177887548433, 0.21706966986367537, 0.24032460097708574, 0.26072524266797525, 0.25844427587471697, 0.25198347744740335, 0.25501879338878, 0.25847455254125673, 0.6726291854346227, 0.6983367076455875, 0.715476429906784, 0.6947549903909906, 0.7117149410075196, 0.6602945499105044, 0.6466845444971814, 0.7452841957149375, 0.7221776080133249, 0.09666289109916948, 0.14340775382535453, 0.10585303069103191, 0.15521165334730935, 0.14651783598013013, 0.4668957509076932, 0.10241108803049992, 0.1545825418580784, 0.1125280196151005, 0.473201125943709, 0.2742119399512093, 0.19549038966151266, 0.3261132098334505, 0.40719463064236483, 0.28919119555889206, 0.2689743858167324, 0.39107754851312393, 0.45515314190568124, 0.38733856075525164, 0.4784133567907751, 0.45074462318591235, 0.4727700673414611, 0.4455983488670886, 0.44358819268677785, 0.23510524370864472, 0.4646396490563769, 0.2483990533870687, 0.18686462114986113, 0.3898539580598226, 0.33252519272720815, 0.33665523205021763, 0.2753093270107576, 0.368818903286834, 0.2326697591312361, 0.38360775214280596, 0.24810769606332062, 0.22614414673881, 0.2091669847955121, 0.2376287293575159, 0.23134328004177174, 0.21566839909595292, 0.21518105339628268, 0.2468646587017459, 0.28077974239466696, 0.21852573532843844, 0.18127819922523392, 0.21974487410818977, 0.19139057584296204, 0.17668046735626086, 0.19370711877615654, 0.19436086303426192, 0.18888753716285034, 0.17820709656737277, 0.18953716760119432, 0.1869375568067173, 0.1846633130287595, 0.1514706945196782, 0.9000162162837987, 0.19833647838674828, 0.8800301228567629, 0.16035939735093796, 0.16698506073718522, 0.1528820546605173, 0.9081320376148151, 0.15375626208907267, 0.8496144350606849, 0.20722407690781097, 0.20709615577929064, 0.16820143055393288, 0.10367078805728158, 0.16679660664140006, 0.8313893902607168, 0.17230449008406867, 0.1806264156438514, 0.18052141509791253, 0.18186533986198405, 0.17834406883031695, 0.1937009333004419, 0.174219336665853, 0.17800988108516413, 0.18034660974093608, 0.09004868622501183, 0.08586539797211268, 0.08833434338492496, 0.0982191958703128, 0.09166675972328608, 0.0858561635070395, 0.09019394331367003, 0.08559010719499971, 0.10011336452866648]}, "mutation_prompt": null}
{"id": "bc97bbc8-d23b-4f05-9b3e-42294ce5c67f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            self.w = self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                acceleration_factor = 0.5 + 0.5 * np.tanh((gbest_val - pbest_val[i]) / (np.abs(gbest_val) + 1e-10))\n                vel[i] = (self.w * vel[i] \n                          + acceleration_factor * (c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i])))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Adaptive DE scaling factor\n                F_adaptive = 0.4 + 0.3 * chaos_val\n\n                # DE mutation and crossover\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Incorporate a self-adaptive acceleration factor to balance exploration and exploitation, enhancing convergence reliability.", "configspace": "", "generation": 10, "fitness": 0.3238543957340856, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.29.", "error": "", "parent_id": "62d6e350-3d17-4fb0-ad1f-b800570d55f4", "metadata": {"aucs": [0.8863027845579603, 0.8782412546452292, 0.885338956455568, 0.877401215265131, 0.869841170217192, 0.8745343167171151, 0.874191564510959, 0.8733379698637377, 0.8725758676103536, 0.01851640103445662, 9.999999999998899e-05, 9.999999999998899e-05, 0.01153901765704446, 9.999999999998899e-05, 0.008031023722594566, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11461278017566112, 0.15377884403754905, 0.06857695591304613, 0.13478459380257113, 0.11935062950781228, 0.1548332318235882, 0.09028152016350355, 0.1389840802956943, 0.179501443410777, 0.10648430455962166, 0.10674700642716162, 0.07955870189099479, 0.12821985369949818, 0.09630739186809878, 0.08731109854299124, 0.11098804228517911, 0.10839502609858975, 0.12554934690414465, 0.8888077200370168, 0.7945426861697675, 0.8053719559180836, 0.8945337984548037, 0.878206195081306, 0.8431309787891164, 0.8960335328938035, 0.8542865289601674, 0.8968222546527914, 0.7306867132539352, 0.7340586506198192, 0.6851798061552803, 0.7460718700126849, 0.7314073809545287, 0.753651204512363, 0.6913576607502658, 0.6829598078180106, 0.6367088039728472, 0.2139378861902821, 0.2273770417398473, 0.22456711793766093, 0.20505515898246207, 0.34487440327443597, 0.26978917032997385, 0.216174974126372, 0.21834548737595916, 0.21495772123832457, 0.4336250792246833, 0.21189561715802352, 0.36369694554355847, 0.5390447917829116, 0.26764689814433873, 0.11157837280929894, 0.25918619877894356, 0.45070032175390085, 0.29813576275232967, 0.2569660449019405, 0.38679385553707324, 0.31829094735783536, 0.28585942781341367, 0.2898980467039477, 0.11353662923939556, 0.31775816823657144, 0.39083924622575783, 0.29648230993004776, 9.999999999998899e-05, 0.0003066675956578946, 9.999999999998899e-05, 0.0001450304653175527, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.022611017873486516, 9.999999999998899e-05, 0.08987535418436787, 0.11370574036941272, 0.09549728400653601, 0.05103584290989205, 0.02933791961936494, 0.03395412203993675, 0.06771094373569453, 0.04090806902735, 0.03978613411491716, 9.999999999998899e-05, 0.0005188690899420312, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.38748588472281176, 0.27800843603706915, 0.5034000376060026, 0.14050561411165363, 0.32789727921513145, 0.18800350584037706, 0.3278051123410848, 0.3100770791139419, 0.3867568310487398, 0.8309439931338549, 0.8453099303171416, 0.8614633315801662, 0.8203809904183011, 0.8378514377245053, 0.8219475240729673, 0.8374934975605254, 0.8513014548425175, 0.8507027822580722, 0.10504349678660785, 0.09652142845625988, 0.08801438080788027, 0.10859452888946453, 0.11955138577697488, 0.15314801048458426, 0.09865125761909055, 0.12973216995235393, 0.129742132532782, 0.2642238449108918, 0.3204041463978293, 0.5472144543009645, 0.33824359436263496, 0.21929110045040756, 0.4114705221609606, 0.483845305300992, 0.6807601444151532, 0.7770364782083872, 0.651886566701233, 0.6029976622157772, 0.4680068358309508, 0.5991505845151169, 0.6909165863996047, 0.6430277342500875, 0.4913912402310553, 0.7093609787298623, 0.6786023535969985, 0.26019367792333037, 0.44659534630649556, 0.2831706995349478, 0.556875346263839, 0.4326551534076313, 0.5191467414009971, 0.24133991519646836, 0.2982484545661911, 0.2551660431456372, 0.2597105163919524, 0.22383689476190838, 0.22963882377337064, 0.21898019502779076, 0.20938663613029895, 0.22914770942997242, 0.2184994719490334, 0.2264176366632087, 0.2196807935275089, 0.18062443280586282, 0.16980986279134136, 0.18963851728608516, 0.17280071180754608, 0.17692054174290284, 0.21621136843874966, 0.17984287840168578, 0.1847013165395197, 0.1772715833164692, 0.18627738605899846, 0.18604394209859443, 0.185590943163772, 0.7803018308115024, 0.1697894993653929, 0.4644746045265129, 0.14155848857988762, 0.11702918373805515, 0.884018173361123, 0.9094408484323284, 0.20972657981241805, 0.8922181039805976, 0.207971579912147, 0.20863071200416072, 0.16693128769331111, 0.16601864617777806, 0.8096054625410343, 0.21047877174342888, 0.20021880978013396, 0.19060328307801366, 0.18559012099537409, 0.18578623483640744, 0.20653580263203908, 0.18266804945213644, 0.18265914185199716, 0.17739546619473967, 0.18757011352359998, 0.08515288193185222, 0.10087246483866164, 0.09372158510149697, 0.10197286873676836, 0.0950996462687137, 0.11614375741794225, 0.08288949272515855, 0.0924219314626078, 0.10612630618170737]}, "mutation_prompt": null}
{"id": "090c7e6e-42c1-438c-a7be-81c16fcb2bab", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Nonlinear time-varying inertia weight\n            self.w = self.w_max - (self.w_max - self.w_min) * ((eval_count / self.budget) ** 2)\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Adaptive DE scaling factor\n                F_adaptive = 0.5 + 0.2 * chaos_val\n\n                # DE mutation and crossover\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce nonlinear time-varying inertia weights and adaptive scaling in differential evolution to enhance convergence speed and solution quality.", "configspace": "", "generation": 11, "fitness": 0.26577296537736844, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "62d6e350-3d17-4fb0-ad1f-b800570d55f4", "metadata": {"aucs": [0.5057041444093563, 0.5162565707766018, 0.5253178055908045, 0.5177331036005195, 0.5105965393741279, 0.5057592565648262, 0.5260634500087609, 0.5186440530732221, 0.49847754371912767, 0.1497519478318764, 0.11791379609878028, 0.1302988028069001, 0.10089199606863253, 0.14490259706202835, 0.08919023917578939, 0.11703642910146139, 0.1421544149953926, 0.07189967403102726, 0.1310109610363125, 0.12053243536750802, 0.12337941694670518, 0.11825700053668209, 0.13930015403184948, 0.11087213058937506, 0.09688877495139259, 0.1361239699928556, 0.18586692301592922, 0.09663834316796438, 0.09519193916245039, 0.11484018186703471, 0.1256071507651796, 0.09915650823007816, 0.11391243046734201, 0.1165153855981711, 0.09922544220867946, 0.101050674618958, 0.8969257459350245, 0.8902371272905086, 0.8967564526359317, 0.9086835434636182, 0.8999469975571395, 0.9044729396313991, 0.9010254827943214, 0.8965345447240414, 0.9186272228465582, 0.3383331697621281, 0.33553939183455894, 0.32926626589207864, 0.3163802008681752, 0.334480373674526, 0.33122716203905433, 0.3328167268033503, 0.3208530476123873, 0.33308880770465943, 0.5820218476757033, 0.5147914904854851, 0.6072851968630804, 0.5634012400898849, 0.5495704570624658, 0.47050149922596096, 0.6473160462118106, 0.44687988662256817, 0.6016625273639153, 0.20813171162026278, 0.20862841765677465, 0.21706907026113276, 0.2430660012579623, 0.23753342662669752, 0.20964373799983804, 0.2284711050714362, 0.2075394902315223, 0.22263268069513997, 0.2774587267198382, 0.20638920132485084, 0.20248483214258772, 0.21841491220879794, 0.2188781940822806, 0.2534071993853577, 0.20700385419514733, 0.2603261104865163, 0.1291995591062396, 0.04113649674315234, 0.06300671143304337, 0.03959000764828091, 0.020373287961779396, 0.01612582055256495, 0.07651094303850114, 0.08502415858547141, 0.04239780822421946, 0.041122342730612216, 0.14641223276916493, 0.14799618369831247, 0.1167775914718231, 0.09736363924058244, 0.10901215366841299, 0.11681678184281663, 0.15599273406467495, 0.13694940071038197, 0.1413569153085349, 0.023630368014108893, 0.03660779975504336, 0.015965014345367345, 0.021237737183082972, 0.025225946759689033, 0.042630735251285246, 0.03005701737854416, 0.030126537230535044, 0.05678452441949955, 0.11804683388272375, 0.11128682101585696, 0.13433096674642042, 0.13209109205435066, 0.14113078003716184, 0.13637432404522865, 0.1340429321394282, 0.14718113628749852, 0.13919552100154364, 0.448758259684371, 0.44838244753069423, 0.45835985372475807, 0.4570458059507524, 0.45954259121657104, 0.4585919665682414, 0.46365911909234125, 0.450722978631818, 0.4558076652657783, 0.09786551989258785, 0.10329219097341469, 0.1026985593359695, 0.11118409368328797, 0.12959384642325456, 0.123241224501627, 0.10815025461007166, 0.10928895835284269, 0.124014929638389, 0.25810357798534744, 0.2848062915062114, 0.2673136597969328, 0.2700483653376863, 0.30033241284445256, 0.2733347230905361, 0.27986101745263836, 0.2719780983357024, 0.21956503620751333, 0.31865540445530394, 0.3292470216377815, 0.3030483549665677, 0.31569157805758596, 0.3131246595213356, 0.32029305207209946, 0.2920741925802428, 0.3177347063095418, 0.2205437523523447, 0.19680227701665698, 0.26001149444291216, 0.2595179841761338, 0.25656385387068226, 0.23982677220236492, 0.2595694794514739, 0.20550871061905118, 0.24825517068018177, 0.20494089882765598, 0.2301149352433185, 0.22255644520090379, 0.21878679639111387, 0.22848831912360013, 0.2457679911293137, 0.2291383596755815, 0.22765210034394645, 0.23585526828612824, 0.22952848763765377, 0.1889727359054647, 0.2011927674017281, 0.19181522227907222, 0.20981058553489962, 0.3274849357098617, 0.2018164511492344, 0.20873391503602612, 0.19466579561875896, 0.1881454367360864, 0.18170378028885958, 0.6718027708533896, 0.15055524374492357, 0.743041448782828, 0.7029127656781398, 0.15190320271859348, 0.14106608907902496, 0.14043153391261354, 0.7036398366527645, 0.6620148827871688, 0.20809049905844346, 0.6686093952953627, 0.6549639691227259, 0.20607911732205064, 0.16549609792476627, 0.5853360172310752, 0.16531580484103303, 0.6350008014317728, 0.18491612649533262, 0.17694635224638644, 0.18113709195433936, 0.1933727046451168, 0.18188718253733993, 0.18824930140378004, 0.22041906848949155, 0.20697655286882943, 0.1958977395761452, 0.08917584627633368, 0.09402265626227913, 0.11159177253245, 0.09159833519182758, 0.08772251313266588, 0.10161229418483231, 0.08590187657785087, 0.09418337522892484, 0.09813000607959854]}, "mutation_prompt": null}
{"id": "f5d1aa22-f459-48f7-b899-40d240b7ef30", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n    \n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / abs(v) ** (1 / beta)\n        return 0.01 * step * (L - self.lb)\n\n    def __call__(self, func):\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7\n        while eval_count < self.budget:\n            chaos_val = 4 * chaos_val * (1 - chaos_val)\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            self.w = self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)\n\n            for i in range(self.population_size):\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)\n                pos[i] = pos[i] + vel[i]\n\n                if np.random.rand() < 0.1:\n                    pos[i] += self.levy_flight(pos[i])  # Applying Lévy flight\n\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                F_adaptive = 0.4 + 0.3 * chaos_val\n\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Enhance PSO-DE by incorporating Lévy flights for sudden large jumps, improving exploration and convergence.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "62d6e350-3d17-4fb0-ad1f-b800570d55f4", "metadata": {}, "mutation_prompt": null}
{"id": "fed45814-87bf-4f01-b33d-6f4c75f375cb", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            self.w = self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Adaptive DE scaling factor\n                F_adaptive = 0.4 + 0.3 * chaos_val\n\n                # DE mutation and crossover\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce an adaptive chaotic mapping to dynamically adjust cognitive and social components, enhancing convergence.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62d6e350-3d17-4fb0-ad1f-b800570d55f4", "metadata": {"aucs": [0.8178721779963758, 0.8231729094368125, 0.8183158323165045, 0.8210727426398698, 0.8087228533134365, 0.8075774712083701, 0.8354117718574745, 0.8244262159984265, 0.8084600018415455, 0.47295458767525056, 0.45274079937832634, 0.45408638073711594, 0.3200486902557189, 0.48325515706431355, 0.38002701966128183, 0.40233034948000634, 0.4319410424422264, 0.4137031639919757, 0.11328173084046289, 0.15277679155768986, 0.10675584321705422, 0.11987177682392536, 0.1774037462061575, 0.11249022783207241, 0.1140133117695068, 0.1474117220189617, 0.11200773515796936, 0.10863491065192799, 0.1432289394152424, 0.1180625231180289, 0.13723909175245208, 0.09970609930659302, 0.12573006881410476, 0.10931399686045007, 0.11956408568933274, 0.09590323153221925, 0.8881604282783372, 0.8572146657596182, 0.8937769882993802, 0.9019128848839646, 0.8805015966377604, 0.8881627164100284, 0.8746588461758402, 0.9031080491262975, 0.9067989180749284, 0.5427925039035152, 0.5663954401938064, 0.5217395982028248, 0.5480351278645117, 0.5821747253588871, 0.5328389383537094, 0.5200442858867391, 0.5182025479644747, 0.5387408277690278, 0.8544020516201067, 0.2272320894189599, 0.8362760516237495, 0.27607009297346363, 0.8743784963696848, 0.270310462614172, 0.8411879054698538, 0.22947488740556732, 0.7840583367584579, 0.5321804673397632, 0.5329636789836563, 0.32001028156258604, 0.12813175201623417, 0.4832003373626311, 0.3589242907407122, 0.3692248486974916, 0.4211485554766117, 0.1325538790679346, 0.43972368304260967, 0.3333190114198751, 0.3561831325893068, 0.36732660267113926, 0.40085831428313845, 0.34486029072034086, 0.4607769939705739, 0.4041527735873608, 0.31378159684728857, 0.07797928682541311, 0.02557177704074931, 0.26585524264407556, 0.0781443450588657, 0.03564876166642772, 0.20762078490772917, 0.2415105821657173, 0.2110037818011622, 0.0817037452729753, 0.13571933219118004, 0.13433013137972427, 0.17817203460598863, 0.1663935085898498, 0.053411669558918184, 0.08449366977778794, 0.12288235251575919, 0.1617983312537914, 0.19959996736827235, 0.07989819625102446, 0.3251718629275058, 0.14661380694390025, 0.11739453795245969, 0.12194534785553002, 0.2211670453210587, 0.13270930856384022, 0.11378115045451964, 0.16539946341729683, 0.2567720262220531, 0.17221177887548433, 0.21706966986367537, 0.24032460097708574, 0.26072524266797525, 0.25844427587471697, 0.25198347744740335, 0.25501879338878, 0.25847455254125673, 0.6726291854346227, 0.6983367076455875, 0.715476429906784, 0.6947549903909906, 0.7117149410075196, 0.6602945499105044, 0.6466845444971814, 0.7452841957149375, 0.7221776080133249, 0.09666289109916948, 0.14340775382535453, 0.10585303069103191, 0.15521165334730935, 0.14651783598013013, 0.4668957509076932, 0.10241108803049992, 0.1545825418580784, 0.1125280196151005, 0.473201125943709, 0.2742119399512093, 0.19549038966151266, 0.3261132098334505, 0.40719463064236483, 0.28919119555889206, 0.2689743858167324, 0.39107754851312393, 0.45515314190568124, 0.38733856075525164, 0.4784133567907751, 0.45074462318591235, 0.4727700673414611, 0.4455983488670886, 0.44358819268677785, 0.23510524370864472, 0.4646396490563769, 0.2483990533870687, 0.18686462114986113, 0.3898539580598226, 0.33252519272720815, 0.33665523205021763, 0.2753093270107576, 0.368818903286834, 0.2326697591312361, 0.38360775214280596, 0.24810769606332062, 0.22614414673881, 0.2091669847955121, 0.2376287293575159, 0.23134328004177174, 0.21566839909595292, 0.21518105339628268, 0.2468646587017459, 0.28077974239466696, 0.21852573532843844, 0.18127819922523392, 0.21974487410818977, 0.19139057584296204, 0.17668046735626086, 0.19370711877615654, 0.19436086303426192, 0.18888753716285034, 0.17820709656737277, 0.18953716760119432, 0.1869375568067173, 0.1846633130287595, 0.1514706945196782, 0.9000162162837987, 0.19833647838674828, 0.8800301228567629, 0.16035939735093796, 0.16698506073718522, 0.1528820546605173, 0.9081320376148151, 0.15375626208907267, 0.8496144350606849, 0.20722407690781097, 0.20709615577929064, 0.16820143055393288, 0.10367078805728158, 0.16679660664140006, 0.8313893902607168, 0.17230449008406867, 0.1806264156438514, 0.18052141509791253, 0.18186533986198405, 0.17834406883031695, 0.1937009333004419, 0.174219336665853, 0.17800988108516413, 0.18034660974093608, 0.09004868622501183, 0.08586539797211268, 0.08833434338492496, 0.0982191958703128, 0.09166675972328608, 0.0858561635070395, 0.09019394331367003, 0.08559010719499971, 0.10011336452866648]}, "mutation_prompt": null}
{"id": "3f5e8b35-b179-451c-b6fb-cd33efe90d05", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Adaptive DE scaling factor\n                F_adaptive = 0.4 + 0.3 * chaos_val\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Incorporate a nonlinear dynamic inertia weight adjustment and update the mutation strategy to enhance exploration-exploitation balance.", "configspace": "", "generation": 14, "fitness": 0.42653014288245744, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.28.", "error": "", "parent_id": "62d6e350-3d17-4fb0-ad1f-b800570d55f4", "metadata": {"aucs": [0.8517368264292838, 0.8440154154098912, 0.8474883862563437, 0.8373621568047663, 0.8360285740035917, 0.8392398819357105, 0.836183988137144, 0.8387134339288369, 0.8397882616114564, 0.6330358519258701, 0.6747496042264727, 0.6698216143906625, 0.6201289944129105, 0.6036605572132089, 0.6402521760010234, 0.6183127453080877, 0.6680717602506595, 0.6438335001761446, 0.18008567281419563, 0.1403211588941229, 0.1174877815367894, 0.15671050683942467, 0.11174540898089669, 0.155339780875985, 0.12026898622652482, 0.14093860912586764, 0.10660400343048004, 0.10845670648318051, 0.10187935809835558, 0.1127689136302168, 0.09099921560634228, 0.11159617309056125, 0.1433524302066026, 0.10738184542744655, 0.10537289587161247, 0.10658288496423196, 0.8853795238243296, 0.8606350898299412, 0.9035694186937957, 0.881607253062107, 0.8615500254797696, 0.890273746823584, 0.9090172517116246, 0.9038966449052206, 0.9098036928193001, 0.7069477975654654, 0.6491766070742186, 0.6795187917390704, 0.671316847826434, 0.7123153120663306, 0.6754754153971947, 0.6701312146858467, 0.663071749363886, 0.6363385110019733, 0.22737878406996692, 0.3361989514532274, 0.8770606967745141, 0.8691700577808427, 0.8532068154101339, 0.6984794439723652, 0.17602358980011978, 0.858900063156843, 0.8833484621438547, 0.5547947273567432, 0.6128043833301737, 0.6586771508576905, 0.6063028818711709, 0.6222101371980381, 0.6545390256379238, 0.13124617527142401, 0.6408248427440222, 0.6139749162291149, 0.5432734410408083, 0.6155129866549609, 0.1327774756660458, 0.5523708683038863, 0.6329350295008676, 0.572950525764518, 0.6151922637273328, 0.6163716203505435, 0.5983466721246025, 0.48110768512258406, 0.12705318084520145, 0.49051202907328284, 0.4326239133509805, 0.12490747807168723, 0.03357813309988922, 0.288225199671, 0.2867675598047157, 0.2347294954699053, 0.2336385854619698, 0.18444748692256785, 0.15122917599664576, 0.1738179749194365, 0.13903154858626954, 0.11857123055469687, 0.2168915914295244, 0.1428666294655273, 0.31232479747307373, 0.3201809640749036, 0.4086693498449133, 0.22637060679312315, 0.13112430514849982, 0.27418023280219816, 0.1542784119742917, 0.17112869752249005, 0.22073871672642786, 0.25120327586615776, 0.400125389414309, 0.3221349597519465, 0.4631256359432123, 0.4294450368796874, 0.4418004247999031, 0.43130437564171753, 0.3478053513163728, 0.4164596041686137, 0.46196105931716946, 0.811070908524176, 0.7871892289092195, 0.7955100707533456, 0.7755094034160814, 0.776261738692035, 0.767159525482, 0.8009338093818044, 0.8068705786448291, 0.7950457226489664, 0.10424898763654888, 0.1538508778963451, 0.09168045128067859, 0.12857867395925382, 0.1210351105797588, 0.14135375554911367, 0.11973907978066745, 0.09494527795226493, 0.13757257786603727, 0.6182512026485152, 0.6265754348028383, 0.669628992558194, 0.21703619498729576, 0.4826073248488939, 0.6920654560969146, 0.6759631690667456, 0.6190672513329638, 0.49977443697212, 0.3902879448940998, 0.5067308363550707, 0.5910877074652061, 0.5597752904377634, 0.49505027491146225, 0.600264873921144, 0.26378111590344466, 0.5617078519261773, 0.3024444311100738, 0.24314764825719992, 0.26163071742710076, 0.3453102643214283, 0.5162995092757194, 0.4346594216997115, 0.4920691367628729, 0.24641176769623574, 0.475528593990057, 0.21310360487285562, 0.26569597314652904, 0.23324150657335263, 0.24569731212706614, 0.23120051486789017, 0.23345880742546132, 0.2828657701045394, 0.2349042981496393, 0.23810618535051364, 0.22189772596040636, 0.7319466065396086, 0.21707693777013637, 0.18201893222081067, 0.22140414922511165, 0.19343658809543074, 0.18706552278543176, 0.1790353001605035, 0.19506930012731738, 0.17454139462514773, 0.1857529903324231, 0.17733697141638327, 0.8754217425183921, 0.8959143469079552, 0.19867465811870544, 0.19895829998398395, 0.8904412026359839, 0.1402140119134192, 0.17523757272327822, 0.8942336862530464, 0.20978679180988247, 0.8682273141468111, 0.8597345483706282, 0.20982387013912496, 0.15300759340630843, 0.16540877544568522, 0.8264382300944568, 0.8430814838796858, 0.19614318927134267, 0.2053002093218974, 0.1954725724666615, 0.18438763722646445, 0.2123415558720656, 0.18872024941377663, 0.18411876919591663, 0.18490192189611376, 0.18281234977845962, 0.10239782072112535, 0.11002115412801106, 0.10498476749929975, 0.10893260110637293, 0.10603250030310862, 0.1009411282382483, 0.0898570724313913, 0.11045533563524246, 0.08794384336740224]}, "mutation_prompt": null}
{"id": "d75c6757-cfb1-4d62-a48d-8c868499ce9a", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Reflective boundary handling\n                pos[i] = np.where(pos[i] > self.ub, self.ub - (pos[i] - self.ub), pos[i])\n                pos[i] = np.where(pos[i] < self.lb, self.lb + (self.lb - pos[i]), pos[i])\n\n                # Adaptive DE scaling factor using sinusoidal function\n                F_adaptive = 0.4 + 0.3 * np.sin(np.pi * eval_count / self.budget)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce a nonlinear adaptive scaling factor for DE using a sinusoidal function and enhance boundary handling by reflecting particles.", "configspace": "", "generation": 15, "fitness": 0.42595367034452986, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.27.", "error": "", "parent_id": "3f5e8b35-b179-451c-b6fb-cd33efe90d05", "metadata": {"aucs": [0.8546582314765112, 0.8456800145543303, 0.8465907219679935, 0.8333920644504678, 0.8232959711378176, 0.8271999338306908, 0.8322071234890391, 0.8390722067058493, 0.8261606209919445, 0.6982845905581172, 0.6382436293334643, 0.6521050815425105, 0.6630251634655223, 0.5986443270811415, 0.57504057901048, 0.5704883290540754, 0.6469592963088843, 0.634647492958201, 0.11117298438772139, 0.1410508789094116, 0.15421415203011735, 0.13246719509421856, 0.13104108818448235, 0.1207672615727593, 0.114252076230967, 0.7048590482499408, 0.10528589166892621, 0.10906342946166137, 0.06595255807871236, 0.09612502346354324, 0.10799914284312695, 0.10081587324812558, 0.0889504767889473, 0.15520089348360233, 0.11708191099658449, 0.10594438175433407, 0.8062287626924228, 0.7585563039059775, 0.7568793639121778, 0.7520904876878374, 0.7955624810015436, 0.7371080318885878, 0.8211519430084673, 0.8465718088652288, 0.8116438652084104, 0.6843426878403001, 0.6859571939038012, 0.6669447823729054, 0.6795504741345003, 0.6764938917881973, 0.6737078098001417, 0.6603536710985463, 0.6583338190095751, 0.6402657676551253, 0.853969574946452, 0.2261091967502019, 0.22666639171255865, 0.8580002547565047, 0.2743594999446618, 0.2170912123716231, 0.23332457938593432, 0.8338047275011132, 0.8606617550447919, 0.5612060400559323, 0.6637585411934672, 0.5886511286937984, 0.588473149583848, 0.6529959251436962, 0.6376102130894303, 0.6558498964551549, 0.6068294063148949, 0.5957046738344806, 0.7010925319137198, 0.5381237991483958, 0.5432914913034456, 0.643774282499376, 0.6086956719785801, 0.13251058405369476, 0.6449320131562721, 0.7356034264889268, 0.5939913616737466, 0.08190875737600367, 0.3973212769562261, 0.34746130658119057, 0.3455091868314798, 0.16643867753574437, 0.04930223924468191, 0.22593380528583218, 0.20204348701877028, 0.2376613445489193, 0.500245712520125, 0.2145661272758026, 0.17228629146430263, 0.20187635381378055, 0.059667969590771475, 0.14198156441448828, 0.12050017946000446, 0.3112394765771642, 0.1759725511833934, 0.17842349838884253, 0.2710504945574961, 0.17605970307609609, 0.15906648925255362, 0.41670202598755013, 0.44190289797242566, 0.10607124702522053, 0.1322633393094651, 0.19427404247817814, 0.394816787747705, 0.4260218104744695, 0.4026859124783104, 0.39854289822533917, 0.4203636364745065, 0.4152945291561848, 0.4223188103547948, 0.4560633018034932, 0.42934709867044996, 0.7916222202241221, 0.796406673327361, 0.7815238773336872, 0.7966539707679283, 0.7833956499746956, 0.7777865055676988, 0.7916683696734141, 0.7874796397212265, 0.80054290148194, 0.062190595993367404, 0.10540590561116736, 0.07318851200098775, 0.7024517489242081, 0.1302654604497293, 0.10842082431432898, 0.1230462724913477, 0.17906429919206912, 0.17041168196692358, 0.49850531851657265, 0.5584696569581287, 0.6542808218352872, 0.5998073327927134, 0.666629946433609, 0.6357085727372724, 0.26939024820755375, 0.5852295748003656, 0.641643653260098, 0.5260533953979666, 0.49648234789838563, 0.30608421985909573, 0.5954756550713514, 0.5286910231918657, 0.571782362877644, 0.2655674753281253, 0.5962122973419725, 0.26405315269481455, 0.25472810057979056, 0.4682496367194793, 0.2610346184708734, 0.48324516772812875, 0.26310921435139023, 0.3203731139775676, 0.20462000713268458, 0.28165099701393925, 0.2058245343415115, 0.2394671595145117, 0.25010318343324045, 0.22790402263167342, 0.27303645442594393, 0.23331401603267854, 0.20693349719413823, 0.23814689562432112, 0.21378155723150216, 0.2601653773815632, 0.1994522309132073, 0.19876279047278544, 0.20450548711420413, 0.693067877584614, 0.18747740563656345, 0.1945047442635761, 0.1835173844148742, 0.1810954151224231, 0.18985817733617927, 0.897230399774939, 0.18578044204241873, 0.1857061741557433, 0.8933347503006006, 0.1994878812132308, 0.9002357501890829, 0.8964185084170918, 0.15782531240350983, 0.8855400061745674, 0.8822448103128704, 0.2107987202922943, 0.8932309871972747, 0.20954618461257646, 0.8519290955581647, 0.16477766890272338, 0.8060173368958626, 0.8153905094470228, 0.16792505150462256, 0.18019725016879673, 0.18262305652764488, 0.18434649434732486, 0.17802192891155733, 0.20256375496088563, 0.18418150006198464, 0.22655824854824558, 0.20391170793644364, 0.1826827339559297, 0.08852694331447841, 0.09231850190306035, 0.09786961060399679, 0.09716134513907926, 0.10506199059912102, 0.07680134849013609, 0.12154728678146443, 0.10639109517069212, 0.10233822649619084]}, "mutation_prompt": null}
{"id": "5668a8fc-c186-4759-a3b9-6b8ddbc4b35b", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Adaptive DE scaling factor\n                F_adaptive = 0.4 + 0.3 * chaos_val\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Incorporate a nonlinear dynamic inertia weight adjustment and update the mutation strategy to enhance exploration-exploitation balance.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3f5e8b35-b179-451c-b6fb-cd33efe90d05", "metadata": {"aucs": [0.8517368264292838, 0.8440154154098912, 0.8474883862563437, 0.8373621568047663, 0.8360285740035917, 0.8392398819357105, 0.836183988137144, 0.8387134339288369, 0.8397882616114564, 0.6330358519258701, 0.6747496042264727, 0.6698216143906625, 0.6201289944129105, 0.6036605572132089, 0.6402521760010234, 0.6183127453080877, 0.6680717602506595, 0.6438335001761446, 0.18008567281419563, 0.1403211588941229, 0.1174877815367894, 0.15671050683942467, 0.11174540898089669, 0.155339780875985, 0.12026898622652482, 0.14093860912586764, 0.10660400343048004, 0.10845670648318051, 0.10187935809835558, 0.1127689136302168, 0.09099921560634228, 0.11159617309056125, 0.1433524302066026, 0.10738184542744655, 0.10537289587161247, 0.10658288496423196, 0.8853795238243296, 0.8606350898299412, 0.9035694186937957, 0.881607253062107, 0.8615500254797696, 0.890273746823584, 0.9090172517116246, 0.9038966449052206, 0.9098036928193001, 0.7069477975654654, 0.6491766070742186, 0.6795187917390704, 0.671316847826434, 0.7123153120663306, 0.6754754153971947, 0.6701312146858467, 0.663071749363886, 0.6363385110019733, 0.22737878406996692, 0.3361989514532274, 0.8770606967745141, 0.8691700577808427, 0.8532068154101339, 0.6984794439723652, 0.17602358980011978, 0.858900063156843, 0.8833484621438547, 0.5547947273567432, 0.6128043833301737, 0.6586771508576905, 0.6063028818711709, 0.6222101371980381, 0.6545390256379238, 0.13124617527142401, 0.6408248427440222, 0.6139749162291149, 0.5432734410408083, 0.6155129866549609, 0.1327774756660458, 0.5523708683038863, 0.6329350295008676, 0.572950525764518, 0.6151922637273328, 0.6163716203505435, 0.5983466721246025, 0.48110768512258406, 0.12705318084520145, 0.49051202907328284, 0.4326239133509805, 0.12490747807168723, 0.03357813309988922, 0.288225199671, 0.2867675598047157, 0.2347294954699053, 0.2336385854619698, 0.18444748692256785, 0.15122917599664576, 0.1738179749194365, 0.13903154858626954, 0.11857123055469687, 0.2168915914295244, 0.1428666294655273, 0.31232479747307373, 0.3201809640749036, 0.4086693498449133, 0.22637060679312315, 0.13112430514849982, 0.27418023280219816, 0.1542784119742917, 0.17112869752249005, 0.22073871672642786, 0.25120327586615776, 0.400125389414309, 0.3221349597519465, 0.4631256359432123, 0.4294450368796874, 0.4418004247999031, 0.43130437564171753, 0.3478053513163728, 0.4164596041686137, 0.46196105931716946, 0.811070908524176, 0.7871892289092195, 0.7955100707533456, 0.7755094034160814, 0.776261738692035, 0.767159525482, 0.8009338093818044, 0.8068705786448291, 0.7950457226489664, 0.10424898763654888, 0.1538508778963451, 0.09168045128067859, 0.12857867395925382, 0.1210351105797588, 0.14135375554911367, 0.11973907978066745, 0.09494527795226493, 0.13757257786603727, 0.6182512026485152, 0.6265754348028383, 0.669628992558194, 0.21703619498729576, 0.4826073248488939, 0.6920654560969146, 0.6759631690667456, 0.6190672513329638, 0.49977443697212, 0.3902879448940998, 0.5067308363550707, 0.5910877074652061, 0.5597752904377634, 0.49505027491146225, 0.600264873921144, 0.26378111590344466, 0.5617078519261773, 0.3024444311100738, 0.24314764825719992, 0.26163071742710076, 0.3453102643214283, 0.5162995092757194, 0.4346594216997115, 0.4920691367628729, 0.24641176769623574, 0.475528593990057, 0.21310360487285562, 0.26569597314652904, 0.23324150657335263, 0.24569731212706614, 0.23120051486789017, 0.23345880742546132, 0.2828657701045394, 0.2349042981496393, 0.23810618535051364, 0.22189772596040636, 0.7319466065396086, 0.21707693777013637, 0.18201893222081067, 0.22140414922511165, 0.19343658809543074, 0.18706552278543176, 0.1790353001605035, 0.19506930012731738, 0.17454139462514773, 0.1857529903324231, 0.17733697141638327, 0.8754217425183921, 0.8959143469079552, 0.19867465811870544, 0.19895829998398395, 0.8904412026359839, 0.1402140119134192, 0.17523757272327822, 0.8942336862530464, 0.20978679180988247, 0.8682273141468111, 0.8597345483706282, 0.20982387013912496, 0.15300759340630843, 0.16540877544568522, 0.8264382300944568, 0.8430814838796858, 0.19614318927134267, 0.2053002093218974, 0.1954725724666615, 0.18438763722646445, 0.2123415558720656, 0.18872024941377663, 0.18411876919591663, 0.18490192189611376, 0.18281234977845962, 0.10239782072112535, 0.11002115412801106, 0.10498476749929975, 0.10893260110637293, 0.10603250030310862, 0.1009411282382483, 0.0898570724313913, 0.11045533563524246, 0.08794384336740224]}, "mutation_prompt": null}
{"id": "4bdd8d27-9b15-4a08-8106-f99576267995", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce a random inertia weight perturbation and enhance mutation diversity for improved exploration.", "configspace": "", "generation": 17, "fitness": 0.4345036479166311, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.28.", "error": "", "parent_id": "3f5e8b35-b179-451c-b6fb-cd33efe90d05", "metadata": {"aucs": [0.8556421664289277, 0.8549696233133078, 0.8634204327586672, 0.8426241311396068, 0.8482992190584626, 0.8484945207451412, 0.8547857952763884, 0.8373418122836526, 0.8474807981274585, 0.6390210998587784, 0.6578765634234136, 0.6868178463251026, 0.6394448801041607, 0.6530236934125673, 0.6535716106592343, 0.5936924096470445, 0.62122690964524, 0.6075099482023336, 0.1803047279589316, 0.11419409618735155, 0.12709806376185884, 0.09855831090373335, 0.11042725545880006, 0.157034214083573, 0.11987477247266853, 0.15511043842505223, 0.12838740150573136, 0.15348945105730638, 0.08979167300101054, 0.13658703517496085, 0.09046859141015562, 0.1272093651706968, 0.09674997453411183, 0.08577503883698223, 0.11389552848562234, 0.10298811419713716, 0.9100570304288091, 0.8650780290797997, 0.859668076182671, 0.8869482702546851, 0.8560157490564119, 0.9216017685268375, 0.8998517016594284, 0.8689651335635249, 0.9184957130762181, 0.7015123297646813, 0.7102520226804928, 0.7019690706771227, 0.6959991168778101, 0.6670009962363415, 0.6748492909516519, 0.6957280108552255, 0.7051935150872982, 0.7084847304754787, 0.8523276954525127, 0.2249897385791051, 0.8640597986698355, 0.8546970458306095, 0.8706331677415797, 0.27446629127234023, 0.22981844986601785, 0.1767628142095493, 0.875659564198044, 0.6532794832355238, 0.5890132379432269, 0.6103490042583999, 0.6229708796533135, 0.6062325329119036, 0.5830294469304365, 0.5819496606839758, 0.6456221963765538, 0.6408789121834596, 0.598486398667587, 0.608737664907662, 0.5687180337889879, 0.6082418351639789, 0.6193443146601543, 0.6209346730437049, 0.6697623037777276, 0.5883201343850697, 0.6146670123502568, 0.4399864505009201, 0.3213942660449899, 0.39745477726829526, 0.5001172207533572, 0.2153150369545922, 0.15806405941090174, 0.3176256392465654, 0.22487253390818518, 0.3836166748547586, 0.26101345477283955, 0.1219888466400707, 0.16995504656780636, 0.10884477754811106, 0.051193274793515764, 0.1112319021784528, 0.2850646011675836, 0.44398266788438134, 0.187669860523898, 0.1614052940070324, 0.37318299614568884, 0.417072981866754, 0.5399274812268832, 0.11876772697975013, 0.2083989132383215, 0.2904755521103848, 0.36891048558132045, 0.3028851022425578, 0.44096389284984305, 0.41692446444650244, 0.42448800232347017, 0.47104334815310034, 0.47235326106551634, 0.5002085056490002, 0.44906946758707034, 0.30570750682710435, 0.41038121612032097, 0.7840473980293685, 0.7857511982756386, 0.7876382087357032, 0.7606829631699021, 0.77511087737276, 0.7945974949487931, 0.789733102959478, 0.8080458553341119, 0.804834879532619, 0.10354881661913551, 0.13639325826454585, 0.0931115047122093, 0.13962388312210938, 0.11034480841676886, 0.11436606958398154, 0.18284953988686659, 0.12848462802147076, 0.13550067036175895, 0.6808889758927935, 0.24345750247562048, 0.5846898304834421, 0.6454254857159989, 0.7194602582201914, 0.3424082799478514, 0.2155899546886595, 0.6034184010723077, 0.26531175589251443, 0.2847950820782069, 0.3119889672070576, 0.3256062861201995, 0.6232391443521406, 0.49131110469289174, 0.5111212902292157, 0.2671121910109736, 0.616133248734159, 0.4745249667350706, 0.2590178122042467, 0.44215597590515077, 0.25514169701419087, 0.29883631865866, 0.26387444887930966, 0.5424242662579319, 0.23634593413609728, 0.2812445215938817, 0.23800257934440483, 0.24531482490407208, 0.23138612326542152, 0.23417861052952116, 0.2369095192559253, 0.2866938865537544, 0.4567732478809784, 0.23893716335337867, 0.22683782597917912, 0.20825906744652556, 0.24506247284617944, 0.24621517817882044, 0.19502007631675378, 0.22068438731187312, 0.20452010790780684, 0.18207786424341676, 0.18581896691824973, 0.21856740580742196, 0.21892772457121568, 0.18568205741171284, 0.8758225289783393, 0.172390277072891, 0.9142488139987004, 0.19840431960568483, 0.17196230973311466, 0.8739299140684031, 0.8825240759023424, 0.8988261954376928, 0.9010022689352849, 0.2117261380892308, 0.8685287413667282, 0.20823257141203066, 0.8556886513600507, 0.8509778298948193, 0.16642324356799654, 0.16751122733955492, 0.8288515447623506, 0.18721954111235117, 0.17790166944720387, 0.20913667823948645, 0.1793451789083016, 0.1843910010926516, 0.17852385042389873, 0.25013628782133734, 0.1782781930598054, 0.18609137356672922, 0.08237200957526092, 0.1022574680259446, 0.10731727300130334, 0.09110304046588136, 0.09531046691456102, 0.10586189613624297, 0.08947837586969076, 0.1083695756899955, 0.10021782289284542]}, "mutation_prompt": null}
{"id": "e5f159d0-55ee-43e4-9092-c82234595b00", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[c]) * np.random.rand()  # Random scaling\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce adaptive chaotic components and stochastic scaling to enhance exploration and exploitation balance.", "configspace": "", "generation": 18, "fitness": 0.4278619443496069, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.28.", "error": "", "parent_id": "4bdd8d27-9b15-4a08-8106-f99576267995", "metadata": {"aucs": [0.8821523770985219, 0.8657222263505473, 0.8743171130276821, 0.8559493386012024, 0.8546027355310104, 0.8640274315741541, 0.8735990523523588, 0.8658673806149144, 0.8567387031107548, 0.7205103601072673, 0.6735511084863233, 0.7020231262506791, 0.7042897791993321, 0.6566178292894097, 0.6543684918962206, 0.6533703894662497, 0.6439458712852213, 0.6522150117945458, 0.07652673248429542, 0.14264962552063498, 0.10381331019299234, 0.12326117724960006, 0.09135435093946087, 0.1578875946076871, 0.1313945869046378, 0.1572143209627529, 0.11480447883032685, 0.07718478315909416, 0.08353006661314899, 0.06295766524085189, 0.11724328770066261, 0.15635294134982247, 0.0760511429474946, 0.09947227024618677, 0.1224322557756855, 0.10853590836491889, 0.8862078012903251, 0.8857401364736247, 0.8833563568864644, 0.8919596629294, 0.8713695327213558, 0.880935361526112, 0.8612177466667905, 0.8629394393818628, 0.8854393195474843, 0.7714954075026932, 0.7466257014924299, 0.7386660216339336, 0.7720768639106788, 0.7390496900121203, 0.736927628671942, 0.7608183838914614, 0.7126280413728372, 0.742457765738456, 0.38102166849979713, 0.22568980565489372, 0.2258727673955261, 0.2780642271926318, 0.9005777427331567, 0.895624261196272, 0.14959330775396484, 0.17516175319028315, 0.6018640024819124, 0.6892621964946473, 0.6392885141464202, 0.603220611194196, 0.6904009345189366, 0.630322847214408, 0.7135988954602177, 0.6539169330358878, 0.6500917294899078, 0.6343783959990421, 0.6207043274068497, 0.6201135428786531, 0.7181998328414233, 0.6333989291090407, 0.659974845522459, 0.13442454823193217, 0.7268923576021276, 0.6244379955074583, 0.670307690019829, 0.4248413060979316, 0.18339740784553338, 0.5136633126054352, 0.22054717352480802, 0.49649985733586977, 0.36058841589117474, 0.11761461231036541, 0.36560391544184134, 0.17355646532355695, 0.14257537256804387, 0.15623156321760412, 0.4216758568743587, 0.18055396481062524, 0.16588631611540006, 0.08879305369624035, 0.7163626559928227, 0.38157865051328077, 0.11328459971131943, 0.25119701536641414, 0.43683915701843024, 0.4042133947003095, 0.16525659903252798, 0.3070882173450066, 0.38212697715782684, 0.3440142781982475, 0.37192466511968536, 0.20211251746073977, 0.5026205658753231, 0.4194827380167665, 0.5471349086071695, 0.39449954420116284, 0.4760350059373111, 0.5128027564364194, 0.4758557266424781, 0.42645421312790366, 0.48924566984794937, 0.8391827759135755, 0.8011141999013307, 0.8193652590328788, 0.8114528850738381, 0.7870525407961382, 0.8039458680723054, 0.8246349414372143, 0.8320823475674682, 0.8271522199743525, 0.06939830447371464, 0.08249732387715447, 0.06863178429430605, 0.15713027581150296, 0.0947138483126686, 0.08418899524111656, 0.15395366177512426, 0.18456948740707246, 0.12255172437102702, 0.1882121009534018, 0.22001942002282826, 0.2850364356438555, 0.554383129000648, 0.22463724996613077, 0.7783607531709811, 0.7239625381631327, 0.6221368108040092, 0.19465701848083428, 0.2273017203649037, 0.353029066744622, 0.2985020315657424, 0.4945811494941519, 0.4900156042607311, 0.5541023916332777, 0.2576525654293619, 0.47313785775100636, 0.26499825194670634, 0.23635074478641316, 0.41623592964108236, 0.21729417449979793, 0.25425994044317746, 0.2520051534726435, 0.2662847008045426, 0.2506248925010768, 0.4285700662218289, 0.24602164318220543, 0.2646305739684758, 0.2629138311379232, 0.23797439024785016, 0.2807311739147407, 0.23950385879375957, 0.23816689447610828, 0.25428416489222827, 0.26906078053410976, 0.2983830840975856, 0.17302708744845163, 0.17204978648490576, 0.19792840969390046, 0.22439528671504527, 0.19138297519415048, 0.17653446981805243, 0.18167245036358248, 0.1958728286856002, 0.17522259390546624, 0.18693787682141083, 0.1854649998222111, 0.18775748416122873, 0.9194477670793755, 0.19981791258681092, 0.9093618014027637, 0.8764236349627647, 0.9031457158464355, 0.17653491736512683, 0.862744701624812, 0.21119593811258242, 0.1111986724047831, 0.8999678304352737, 0.7759372844647074, 0.15384157717740932, 0.8603977355153866, 0.16706989170636366, 0.8524191969235284, 0.1920458667880015, 0.1993920115505069, 0.23216474774489593, 0.1837639841668045, 0.21548177432223237, 0.24263004514905506, 0.18313927118683582, 0.20151703404427146, 0.2668185738115588, 0.10235348848772596, 0.08815792833802971, 0.08976112122175273, 0.1020186869856754, 0.10049845165205662, 0.13730131394488598, 0.08155267645391928, 0.12040538189904804, 0.10477745918465575]}, "mutation_prompt": null}
{"id": "1a618e37-5236-4a69-8a43-6f1845dddae7", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce a random inertia weight perturbation and enhance mutation diversity for improved exploration.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4bdd8d27-9b15-4a08-8106-f99576267995", "metadata": {"aucs": [0.8556421664289277, 0.8549696233133078, 0.8634204327586672, 0.8426241311396068, 0.8482992190584626, 0.8484945207451412, 0.8547857952763884, 0.8373418122836526, 0.8474807981274585, 0.6390210998587784, 0.6578765634234136, 0.6868178463251026, 0.6394448801041607, 0.6530236934125673, 0.6535716106592343, 0.5936924096470445, 0.62122690964524, 0.6075099482023336, 0.1803047279589316, 0.11419409618735155, 0.12709806376185884, 0.09855831090373335, 0.11042725545880006, 0.157034214083573, 0.11987477247266853, 0.15511043842505223, 0.12838740150573136, 0.15348945105730638, 0.08979167300101054, 0.13658703517496085, 0.09046859141015562, 0.1272093651706968, 0.09674997453411183, 0.08577503883698223, 0.11389552848562234, 0.10298811419713716, 0.9100570304288091, 0.8650780290797997, 0.859668076182671, 0.8869482702546851, 0.8560157490564119, 0.9216017685268375, 0.8998517016594284, 0.8689651335635249, 0.9184957130762181, 0.7015123297646813, 0.7102520226804928, 0.7019690706771227, 0.6959991168778101, 0.6670009962363415, 0.6748492909516519, 0.6957280108552255, 0.7051935150872982, 0.7084847304754787, 0.8523276954525127, 0.2249897385791051, 0.8640597986698355, 0.8546970458306095, 0.8706331677415797, 0.27446629127234023, 0.22981844986601785, 0.1767628142095493, 0.875659564198044, 0.6532794832355238, 0.5890132379432269, 0.6103490042583999, 0.6229708796533135, 0.6062325329119036, 0.5830294469304365, 0.5819496606839758, 0.6456221963765538, 0.6408789121834596, 0.598486398667587, 0.608737664907662, 0.5687180337889879, 0.6082418351639789, 0.6193443146601543, 0.6209346730437049, 0.6697623037777276, 0.5883201343850697, 0.6146670123502568, 0.4399864505009201, 0.3213942660449899, 0.39745477726829526, 0.5001172207533572, 0.2153150369545922, 0.15806405941090174, 0.3176256392465654, 0.22487253390818518, 0.3836166748547586, 0.26101345477283955, 0.1219888466400707, 0.16995504656780636, 0.10884477754811106, 0.051193274793515764, 0.1112319021784528, 0.2850646011675836, 0.44398266788438134, 0.187669860523898, 0.1614052940070324, 0.37318299614568884, 0.417072981866754, 0.5399274812268832, 0.11876772697975013, 0.2083989132383215, 0.2904755521103848, 0.36891048558132045, 0.3028851022425578, 0.44096389284984305, 0.41692446444650244, 0.42448800232347017, 0.47104334815310034, 0.47235326106551634, 0.5002085056490002, 0.44906946758707034, 0.30570750682710435, 0.41038121612032097, 0.7840473980293685, 0.7857511982756386, 0.7876382087357032, 0.7606829631699021, 0.77511087737276, 0.7945974949487931, 0.789733102959478, 0.8080458553341119, 0.804834879532619, 0.10354881661913551, 0.13639325826454585, 0.0931115047122093, 0.13962388312210938, 0.11034480841676886, 0.11436606958398154, 0.18284953988686659, 0.12848462802147076, 0.13550067036175895, 0.6808889758927935, 0.24345750247562048, 0.5846898304834421, 0.6454254857159989, 0.7194602582201914, 0.3424082799478514, 0.2155899546886595, 0.6034184010723077, 0.26531175589251443, 0.2847950820782069, 0.3119889672070576, 0.3256062861201995, 0.6232391443521406, 0.49131110469289174, 0.5111212902292157, 0.2671121910109736, 0.616133248734159, 0.4745249667350706, 0.2590178122042467, 0.44215597590515077, 0.25514169701419087, 0.29883631865866, 0.26387444887930966, 0.5424242662579319, 0.23634593413609728, 0.2812445215938817, 0.23800257934440483, 0.24531482490407208, 0.23138612326542152, 0.23417861052952116, 0.2369095192559253, 0.2866938865537544, 0.4567732478809784, 0.23893716335337867, 0.22683782597917912, 0.20825906744652556, 0.24506247284617944, 0.24621517817882044, 0.19502007631675378, 0.22068438731187312, 0.20452010790780684, 0.18207786424341676, 0.18581896691824973, 0.21856740580742196, 0.21892772457121568, 0.18568205741171284, 0.8758225289783393, 0.172390277072891, 0.9142488139987004, 0.19840431960568483, 0.17196230973311466, 0.8739299140684031, 0.8825240759023424, 0.8988261954376928, 0.9010022689352849, 0.2117261380892308, 0.8685287413667282, 0.20823257141203066, 0.8556886513600507, 0.8509778298948193, 0.16642324356799654, 0.16751122733955492, 0.8288515447623506, 0.18721954111235117, 0.17790166944720387, 0.20913667823948645, 0.1793451789083016, 0.1843910010926516, 0.17852385042389873, 0.25013628782133734, 0.1782781930598054, 0.18609137356672922, 0.08237200957526092, 0.1022574680259446, 0.10731727300130334, 0.09110304046588136, 0.09531046691456102, 0.10586189613624297, 0.08947837586969076, 0.1083695756899955, 0.10021782289284542]}, "mutation_prompt": null}
{"id": "b140ba0f-365e-4ead-a2e5-1f45c0ab36e5", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            vel_clamp_factor = 0.1 + 0.4 * chaos_val  # Adaptive velocity clamping\n            \n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max * vel_clamp_factor, self.vel_max * vel_clamp_factor)  # New adaptive clamping\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)]) + 0.1 * (pos[i] - gbest)  # Enhanced mutation\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce adaptive velocity clamping and enhanced chaotic mutation for improved search efficiency.", "configspace": "", "generation": 20, "fitness": 0.3505161056295751, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.25.", "error": "", "parent_id": "4bdd8d27-9b15-4a08-8106-f99576267995", "metadata": {"aucs": [0.8009991624624239, 0.7931158970843273, 0.8184452982045227, 0.7732746101856887, 0.7615051414571441, 0.7786735933597912, 0.7861105745023661, 0.7786160669722185, 0.7770769547347137, 0.5837024642399284, 0.5404398140865885, 0.5933864723483208, 0.5680219347114263, 0.5089483513276074, 0.5378494656375049, 0.49564013223631387, 0.5014112433782427, 0.36800387677729407, 0.10680611819951957, 0.1228418860213375, 0.11087012471635027, 0.1319683486360358, 0.1642620338927585, 0.12258942195883571, 0.11549690102243526, 0.13152898066400154, 0.15026022927055804, 0.0886235320516916, 0.10617218904262349, 0.0856396849993869, 0.10369384361564538, 0.08300623508896465, 0.08885380484537653, 0.08982580733058187, 0.10579817690922066, 0.1148363996465217, 0.6906819816502279, 0.627326373869103, 0.5722995791781071, 0.6204005244909544, 0.6441575464114739, 0.7995058871250733, 0.6761573220829395, 0.5466213539329584, 0.6626367264439427, 0.6098413068197109, 0.5511204366651443, 0.5796340405800948, 0.6158490984178131, 0.6133959194633702, 0.5774626939079285, 0.586727265773606, 0.601261630172554, 0.6433081110673404, 0.22023566507483605, 0.8099462720253691, 0.2217127440001806, 0.20954509897480889, 0.8202624321461446, 0.19995616747585754, 0.16912709534660442, 0.773534520919134, 0.220278656966295, 0.6313243801915978, 0.12153914700226176, 0.4621385492400829, 0.4425804022696529, 0.507334550203808, 0.5193259335850899, 0.4111020939728768, 0.5022584581885552, 0.5251029532779522, 0.4530410492896719, 0.6068034955194259, 0.12468148958663383, 0.38454977860364126, 0.5355337494226171, 0.12477072867246064, 0.43209156965347484, 0.39421633693684166, 0.3983782161374677, 0.021842500046638125, 0.05307794945099831, 0.0545381033557405, 0.20668437307371668, 0.08656240621847022, 0.026513261042673153, 0.10023889016814969, 0.07455732401255022, 0.1071521417846305, 0.10448789138284376, 0.0876134864457585, 0.1334806213153995, 0.09162180484324378, 0.0688731730465193, 0.10485527049005816, 0.13901376337582683, 0.1633424480834652, 0.16391994001702825, 0.12628371641812208, 0.098666010438489, 0.309719699312323, 0.09840206703104559, 0.10529552832484879, 0.08305874049311601, 0.20655586020007166, 0.2654016971560128, 0.13804707000727756, 0.16113616867260094, 0.17515113702409202, 0.369930711362113, 0.29160283577701873, 0.2562957290434992, 0.38207997834466856, 0.23468875469151107, 0.2266998420672769, 0.2113898606630109, 0.733525788871905, 0.7305242143814334, 0.7195203598602562, 0.7065139989104898, 0.71342667651162, 0.720372097741409, 0.7524825402598659, 0.7406965329015365, 0.7609644365099997, 0.07772401127376505, 0.10239613153685845, 0.07963961800889197, 0.13299648707950562, 0.09986971420283608, 0.14099923145895987, 0.12962815988862764, 0.10180183536248966, 0.12085022176400073, 0.3776928605856248, 0.3090913588547485, 0.14652973232606403, 0.17957131792577152, 0.23683759222847423, 0.2556193816113751, 0.1947567939879048, 0.2313123536970374, 0.47136547689477015, 0.24951195371989265, 0.5781891692780474, 0.5586240672159863, 0.5527616598673676, 0.6185497030074663, 0.5834847806157197, 0.2560146291838753, 0.5307338656028189, 0.27432053224805053, 0.28547019540770124, 0.20957781432917377, 0.23289693942066247, 0.3347836756966037, 0.3525385021126983, 0.44072735826689335, 0.2027676545778878, 0.2209350150650895, 0.23326744062111537, 0.2251286985050116, 0.2535122649141329, 0.23747587609259646, 0.21097427546082725, 0.22927091440365666, 0.22234165592544286, 0.21880251922504146, 0.22874817431742056, 0.21721304254130813, 0.16428562832502158, 0.165758514853658, 0.1817803315605706, 0.185025122432513, 0.18231069708949432, 0.2117954590609037, 0.1908498415881088, 0.18157572974530145, 0.18247864547525505, 0.18335845519076555, 0.795128896875027, 0.1829321413923346, 0.8648334703980689, 0.8082761537914014, 0.8413056429440123, 0.8136996481319988, 0.7841067432017721, 0.8178595543122242, 0.8227914382411686, 0.20466908385038818, 0.8267260278212285, 0.7644630941183128, 0.19918874415458077, 0.6616717969165267, 0.1636945088764895, 0.6671337823144611, 0.6753372838859024, 0.17865925853420517, 0.1865053783633548, 0.21459618395339952, 0.18061940552773925, 0.18745831038143557, 0.18378567458941064, 0.17713073767394782, 0.18967430627969173, 0.17937532417019209, 0.09196710264779251, 0.08279175949471884, 0.0802202885403358, 0.09289735936226085, 0.09627901588736443, 0.0957513660451701, 0.11356190424002177, 0.08214346020109808, 0.09285938175511343]}, "mutation_prompt": null}
{"id": "b021231f-34c6-4098-bbf1-58b44792d91c", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.cos(2 * np.pi * eval_count / self.budget)  # Modified to use cosine\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                \n                # Improved clamping of velocity\n                vel[i] = np.clip(vel[i], -self.vel_max / (1 + chaos_val), self.vel_max / (1 + chaos_val))\n                \n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Integrate a cosine adaptive factor and velocity clamping to improve convergence stability.", "configspace": "", "generation": 21, "fitness": 0.38880625435630534, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.27.", "error": "", "parent_id": "4bdd8d27-9b15-4a08-8106-f99576267995", "metadata": {"aucs": [0.8428784724252812, 0.8211360729105406, 0.8445977044355657, 0.814888734341105, 0.8187719759241036, 0.8455075969743178, 0.8303913973615789, 0.8362237268171608, 0.8394692450767944, 0.6159700395321666, 0.6163470714642064, 0.6603613096054506, 0.6021527143548305, 0.6328751078327373, 0.6008374833843005, 0.5584920867101378, 0.5413604214503138, 0.5722457350199619, 0.13996999516092623, 0.15633130033771392, 0.11300409069320672, 0.11968677271272588, 0.11418474990191185, 0.13823774938033495, 0.11246919675614186, 0.14012176201362514, 0.12103827577999837, 0.09368581601619586, 0.11126301315599207, 0.0724124021878444, 0.11293828138910522, 0.0826682042426844, 0.12920356496557306, 0.12786156679351657, 0.10651973859843744, 0.11239246197509456, 0.8552640102993351, 0.8421011165985779, 0.8231697281718042, 0.8403532021891805, 0.7961791651584721, 0.8672864740771239, 0.8631419989484546, 0.8591526462504258, 0.8417827148437786, 0.6469237473576461, 0.640198326999309, 0.6039529262974479, 0.6745961769579263, 0.638310680131928, 0.6708060398689282, 0.693606938684627, 0.6257810915914488, 0.6701522290695235, 0.8741434583653312, 0.1392600579075446, 0.8372932817093721, 0.2112120755568777, 0.8777476637025491, 0.8537450576705622, 0.17340964426714023, 0.808041183673064, 0.23118791725135823, 0.49806594296590123, 0.12805963043925317, 0.4995354819507435, 0.5687320685993964, 0.628646746698627, 0.12937573391672763, 0.5263001932317475, 0.5552605524145595, 0.5693505337754384, 0.5543008644771734, 0.47754881854212794, 0.1325541030603894, 0.571128004050703, 0.5592374848982214, 0.5365791326743998, 0.5513155691414614, 0.5207695476612213, 0.5134357620210496, 0.11091298436480834, 0.059787160161561714, 0.1712309411900489, 0.3146394296547409, 0.1305318084396142, 0.08607964257573475, 0.21961521197436595, 0.17987773043293742, 0.421443899198355, 0.14797426790345303, 0.08784788833372914, 0.2237103140217962, 0.09052541742430764, 0.0863309456226391, 0.2641299072084333, 0.19837018600124845, 0.17991876836544962, 0.1384721969683551, 0.3308683676915828, 0.269000624591629, 0.2681264504721925, 0.09101587076434792, 0.17271196752655582, 0.28318164996590567, 0.2936061482713681, 0.20602908500699046, 0.24971841292977526, 0.22968790685518248, 0.356963026082858, 0.3542742194002185, 0.42857691880565085, 0.3914220609435817, 0.43386753741709483, 0.3373048761842441, 0.38657835041673694, 0.38502441212974414, 0.7706887810832377, 0.7418664876853289, 0.7760683423879053, 0.7508805836573471, 0.7644815764918335, 0.7523057355163566, 0.7564370790088044, 0.7713660369048072, 0.7796841224392931, 0.08955863699722288, 0.1133278845847211, 0.08384664616737625, 0.14065958372880782, 0.13956815727786254, 0.09097794947321014, 0.1271900314765929, 0.11345418815385822, 0.11414198537112408, 0.2115899810477213, 0.22881940271358403, 0.35729415027044187, 0.2605158520954689, 0.6311787847981463, 0.2767774213708498, 0.5524411335682093, 0.26629177202006316, 0.41460943182483556, 0.2403233270922175, 0.4502806625517425, 0.5462626373671231, 0.560954787623397, 0.583349005026567, 0.5566773580261932, 0.24310568973626656, 0.5264250580653744, 0.580099106086611, 0.2571741177510518, 0.28951576873331064, 0.2580994810536421, 0.4741757938783471, 0.4963294118738292, 0.47289215000622564, 0.2656343281996585, 0.2522006384089327, 0.23501949097103625, 0.20768751030229549, 0.24461295624178025, 0.19947826594411122, 0.22591945750044495, 0.20908133761871672, 0.2539098370557804, 0.2121905210713828, 0.21353988682707803, 0.23017782779154972, 0.1802380132526087, 0.19383640017195625, 0.18866776807344787, 0.1930014526736954, 0.18891669427381896, 0.20595917296234745, 0.17789014007113368, 0.221110472048754, 0.17574796641371926, 0.18648885617915112, 0.1762300195765465, 0.18367832424199715, 0.904729100722991, 0.19836445530902724, 0.8826515214306866, 0.9025455815537821, 0.160914852979698, 0.9012519957226458, 0.870382465575092, 0.20862650795666027, 0.8629442649994745, 0.20837978296686266, 0.12511006926601131, 0.2048190702880831, 0.825368939101785, 0.16692661518719454, 0.7941510584733181, 0.18917640169002314, 0.18569036496380054, 0.19339065009158163, 0.17691400944184366, 0.17771231880868577, 0.18620467640109606, 0.2075850621207832, 0.18533444872401306, 0.1742918495259691, 0.10593289529619432, 0.0863614760049457, 0.09314789681814906, 0.08885567158320795, 0.0992872710401349, 0.08118800884410249, 0.14714164368931137, 0.09923559705958851, 0.09778283936867738]}, "mutation_prompt": null}
{"id": "38f181dc-2b90-49f2-bb64-73484e3521ba", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2)))**(1/beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / abs(v)**(1/beta)\n        L_step = L * step\n        return L_step\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] += self.levy_flight(0.01)  # Levy flight random walk\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce Levy flight-based random walk to enhance global exploration capability.", "configspace": "", "generation": 22, "fitness": 0.2932417262737746, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "4bdd8d27-9b15-4a08-8106-f99576267995", "metadata": {"aucs": [0.578802249828489, 0.5679918986572907, 0.5457876131443622, 0.5461734996613645, 0.5587476703981373, 0.5655366927123997, 0.5799136206465743, 0.5615527060303389, 0.5475385283876638, 0.10987875983163153, 0.14353747353823798, 0.07934928360866511, 0.13294523927580193, 0.11155862416234819, 0.07731041658108029, 0.10912112594186385, 0.16896778958524306, 0.06637991402565369, 0.10809974132332845, 0.13307868898308317, 0.11444094443221964, 0.13954086871942473, 0.11248215831445685, 0.14549936217730064, 0.12600241468261142, 0.11969966127459464, 0.1592219894543614, 0.09559239223799554, 0.09767954365989939, 0.1173741494011934, 0.1341835644931958, 0.11133438270633667, 0.0970866858249374, 0.11288427861165395, 0.14961501276320355, 0.12253794424722309, 0.9098692535423358, 0.9069934954893369, 0.8832068530506942, 0.8865325191265244, 0.8688855655800553, 0.9010409012083426, 0.8715944465222576, 0.8739845566435638, 0.9217919324723919, 0.430491051751968, 0.376885175969652, 0.3745053045523776, 0.4031184553000936, 0.37328748034720594, 0.3852326680545026, 0.39084717340952135, 0.38548396259421736, 0.3810852945894774, 0.8631066575390517, 0.1390016729421759, 0.8432164692475589, 0.21086405644488582, 0.8707364260195903, 0.21165806839194812, 0.5059620199927273, 0.23193586976412595, 0.8395542058558868, 0.2518826316266666, 0.22049019672745995, 0.2168663786357694, 0.24204133448276732, 0.2172059097527761, 0.28478998906308517, 0.22542335973859295, 0.21956014441960137, 0.2555086756693218, 0.2201841863179358, 0.23212871168832228, 0.24749313049621158, 0.22306724865222205, 0.24430364740989685, 0.265320851231837, 0.2691381168005966, 0.26270468962351057, 0.23553679287490625, 0.08800269021283802, 0.08362716109152701, 0.0394425551300468, 0.1067138420709649, 0.10334880081120923, 0.04291128651968534, 0.10120808708280582, 0.108862771135249, 0.12548335338544492, 0.2304683504458911, 0.1992506271848744, 0.19584631120438656, 0.10439597749194196, 0.0852682164665639, 0.06681845539869591, 0.1388928160256201, 0.13262282405605497, 0.17247752331322697, 0.03566603713658678, 0.020703335815514756, 0.038677796251618934, 0.024659717606550058, 0.03385328963475909, 0.029058524891015236, 0.0784712275914402, 0.06078876231448904, 0.06277379075944678, 0.15130173664832924, 0.0937593930950581, 0.15509494842220883, 0.16849559527683156, 0.1599817435543991, 0.16673274954564798, 0.15014387040560795, 0.16694808363891256, 0.1173552633081566, 0.47861855679475507, 0.4966423224539803, 0.48224939161856206, 0.48874764745871513, 0.47166380701979616, 0.4827645697646813, 0.5157959581980351, 0.5134976079412235, 0.4888874381601904, 0.09611157456583752, 0.09304067837901808, 0.09861399557775907, 0.11635019041172912, 0.12440190242041349, 0.08589450050352587, 0.10895511244881328, 0.11410645202215908, 0.15216063578725791, 0.34205608512010377, 0.332899684283386, 0.3206302145341767, 0.21793818556795497, 0.3643621455746705, 0.24015916032519213, 0.3029067821448099, 0.3369278546989577, 0.34343640789961905, 0.23923353611300202, 0.34341099599996183, 0.34413204342340287, 0.3437113706377667, 0.3461055467295846, 0.35494919274654024, 0.35324977485779896, 0.3373893372996285, 0.352023970897165, 0.2299289134590463, 0.22710834757720666, 0.23693703806159372, 0.2879643803387385, 0.2731993142152248, 0.25284253252594935, 0.21569397745991814, 0.2413595205978839, 0.23760299134531038, 0.24778584308254048, 0.24125758907993022, 0.22125671323841212, 0.2347606034302555, 0.23287547793003605, 0.22508276994838539, 0.24880838091426039, 0.2089300695519315, 0.2478175745953014, 0.18617718845277276, 0.19772978139894404, 0.19886357883379246, 0.2435618437641801, 0.20644604643446196, 0.19918291956622158, 0.18735388120657737, 0.17906933539348624, 0.18149420206595956, 0.15680107320849224, 0.17566245171981731, 0.1844077828684798, 0.8819407826562868, 0.19833645424761792, 0.8613865640926551, 0.9013139207528043, 0.8437601141312253, 0.8620778430640934, 0.8135579972996378, 0.20387013907155171, 0.8353487298776827, 0.7835492252844554, 0.8056325896039811, 0.77697542930337, 0.6893415184744761, 0.15290269138788792, 0.7551117957494073, 0.19550330211137346, 0.18287192935372765, 0.1810759577267439, 0.18551800408887142, 0.17795246388140407, 0.1775075048083563, 0.18431872932999072, 0.18802982618375408, 0.19265121844719812, 0.08566506717804745, 0.08549803593587935, 0.0951850798138405, 0.08986282325964057, 0.09999713231425866, 0.08546995552273218, 0.08912658965779574, 0.08994144654210323, 0.09487332547545013]}, "mutation_prompt": null}
{"id": "067ff359-39a6-4d05-a10a-5c67a5022887", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                # Adaptive velocity clamping\n                vel_max_dynamic = self.vel_max * (0.5 + 0.5 * (gbest_val - pbest_val[i]) / gbest_val)\n                vel[i] = np.clip(vel[i], -vel_max_dynamic, vel_max_dynamic)\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce adaptive velocity clamping and allow dynamic exploration using nonlinear component decay for improved convergence.", "configspace": "", "generation": 23, "fitness": 0.29406782318311453, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.28.", "error": "", "parent_id": "4bdd8d27-9b15-4a08-8106-f99576267995", "metadata": {"aucs": [0.8314119917639005, 0.8249134704846359, 0.8281196100282502, 0.8181828390513958, 0.8228491688105368, 0.8153059021980943, 0.8255507777433354, 0.8382620873225616, 0.8239910065145732, 0.03467929365427391, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011028189779197617, 0.000235099784816728, 9.999999999998899e-05, 0.0169800159508815, 0.11911377523464994, 0.14018025182313454, 0.10963821049861378, 0.10474496719831294, 0.12948064098327627, 0.10333767076123035, 0.0849798665806033, 0.16844295953053, 0.11592676545001701, 0.09582303501750788, 0.07519512505656689, 0.09431643067311013, 0.10286519140227501, 0.10653441928522966, 0.11610902859893979, 0.10095672124700172, 0.07035798378825164, 0.12198754764297626, 0.7844022260605988, 0.5658155567409715, 0.7091696847551197, 0.7778603619143125, 0.7890194122627646, 0.8503264275774812, 0.7460039613179565, 0.7561522851550618, 0.7638166923832563, 0.40270528724745935, 0.3041465571009072, 0.2506375554995398, 0.4916589137124028, 0.45653068271317365, 0.5643487259800432, 0.6468368887187473, 0.6724519924407616, 0.6914964792277281, 0.21531855431798708, 0.21289768997228065, 0.2047529589744992, 0.22166609328017084, 0.23863996630613582, 0.14637854689545893, 0.1149213475073051, 0.14265701892545402, 0.143359440851075, 0.30389705122041444, 0.062269338605541846, 0.28859764698775114, 0.6077662876360126, 0.4058990042983116, 0.11341469880087174, 0.07560363223012823, 0.07497936072697575, 0.06421059551176223, 0.16225051574982174, 0.1967194212847989, 0.23096257446783297, 0.4001285497492578, 0.20616963895737317, 0.20274446786416078, 0.2615124636861841, 0.1812759682761067, 0.2085838377724334, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0693235934067048, 0.04486367271146485, 0.06545630554931181, 0.039450702723099695, 0.005377286982745866, 0.008342104859827115, 0.004962640513332506, 0.021276237749049298, 0.014699493605312086, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09873339325214625, 0.06273076602927286, 0.05365392603090369, 0.013028140682501133, 9.999999999998899e-05, 0.07014758625840134, 0.4320067731411401, 0.11626041480786009, 0.3984738412991816, 0.810059378337725, 0.8033800984878668, 0.7814462234105165, 0.764930752204723, 0.7643328352682172, 0.7789097914654476, 0.7946701627034074, 0.7642437788220607, 0.7865724885466584, 0.0883294302118578, 0.12307367463935204, 0.09473468238065252, 0.09853433205183537, 0.14015201241899578, 0.1314427621276072, 0.12218839808986126, 0.0835030375775726, 0.11606967675518409, 0.6230020585181519, 0.19070179667778442, 0.1853578158035929, 0.6075245235270247, 0.17707161814376393, 0.6296462106555009, 0.43312089805389886, 0.5857790275551845, 0.49294363771935834, 0.597355951657488, 0.6173493207119429, 0.6220351637252834, 0.6035435964594165, 0.5822921792419329, 0.4674774442573063, 0.25163822149768433, 0.5619695622123821, 0.26972712606358373, 0.27083394464914534, 0.12687333353413766, 0.07455347194124229, 0.24166533291865888, 0.40440633611931853, 0.24609674677797222, 0.2391707220688729, 0.2407418890459695, 0.24179836847702085, 0.2507025831589704, 0.2381704590040965, 0.2435746541591508, 0.2470304362243887, 0.2435728367723159, 0.20506612921979284, 0.22304585735427918, 0.22767155690477658, 0.2025472615559316, 0.20733406795385867, 0.1762516115359778, 0.1724350214681719, 0.17991348588520528, 0.18561157179897014, 0.19576444169596974, 0.1593481459014805, 0.1588095313700595, 0.1900922557640895, 0.7937537512579765, 0.18118216688717315, 0.1797429840713286, 0.35047177555656295, 0.1699418701860813, 0.1585048250116382, 0.8699817203266091, 0.8817775990222656, 0.8781711387701974, 0.872968865644466, 0.8326855529675239, 0.8386571278089234, 0.8446057535228519, 0.20442333908613142, 0.8073154819242245, 0.16578723363667924, 0.8019160118648593, 0.8330042156720091, 0.19511790571169063, 0.17404062957445365, 0.20582000880228313, 0.19122053598854505, 0.21556495893824512, 0.19968985020204744, 0.19360457209253334, 0.20521152545617782, 0.19862561495605913, 0.08159970131438188, 0.08711730262573236, 0.09237084166553033, 0.09255977337041332, 0.0932626079843607, 0.154598469362487, 0.08088960776568965, 0.0762016250461911, 0.09442785711243684]}, "mutation_prompt": null}
{"id": "65b54745-0aed-4654-b3e8-c382a5cbbd8a", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7\n        while eval_count < self.budget:\n            chaos_val = 4 * chaos_val * (1 - chaos_val)\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) ** 0.5 / self.budget ** 0.5  # Cooling schedule\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(self.population_size):\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)\n                pos[i] = pos[i] + vel[i]\n\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce a cooling schedule for dynamic parameters and enhance selection pressure in mutation.", "configspace": "", "generation": 24, "fitness": 0.410317714447432, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.28.", "error": "", "parent_id": "4bdd8d27-9b15-4a08-8106-f99576267995", "metadata": {"aucs": [0.8522961773853951, 0.8489712556566859, 0.8399997978525723, 0.8380644890049447, 0.8454289694490691, 0.8438457509162304, 0.8333225339592694, 0.8276924104960459, 0.841781934611114, 0.6267048877711083, 0.6345469958455031, 0.6642218178943313, 0.6344699462067689, 0.6167741813002017, 0.60099676930647, 0.5909549970669874, 0.649365706883932, 0.5921969833079318, 0.13640175092518525, 0.11449424481466519, 0.12952319364051523, 0.11321328327498248, 0.120697647521946, 0.15600324631215157, 0.12137163234571857, 0.13814428614171703, 0.10125523768294786, 0.13057287554231622, 0.10266131926797428, 0.12027307424873523, 0.0943273706751856, 0.10612930989705349, 0.11284379949598677, 0.09298447104036511, 0.09483846667832418, 0.11441101319748337, 0.9006081596336415, 0.8621359066530004, 0.8716742161019511, 0.8818804817364074, 0.8613746357700298, 0.9156324912495819, 0.8985155531369874, 0.8763814531132259, 0.9185335188917563, 0.6539204704208741, 0.6746506485253044, 0.6512539613960349, 0.6690236909489283, 0.6419858793843318, 0.6643448158039675, 0.6651248264113521, 0.7135205752581226, 0.6942072670941626, 0.8965709838351528, 0.22413246169977896, 0.8542948976837087, 0.8688041647493844, 0.2757759858834459, 0.2738397473596198, 0.8420045952683952, 0.1767628142095493, 0.8990271647795711, 0.6927022052408198, 0.5622631181332582, 0.5713042054710258, 0.5809231224721734, 0.5757950762806807, 0.6232201460602208, 0.5022342641110982, 0.13090973765980274, 0.5961383651890608, 0.5497029808626561, 0.5672920102311794, 0.552043984763853, 0.5901206735120075, 0.5628234616356849, 0.6443155492778936, 0.6325247364600438, 0.5810406433114028, 0.6001825127672282, 0.3125433412205546, 0.2805280578986197, 0.03546899118016045, 0.3707532406397167, 0.09599284356515514, 0.0791806397449738, 0.16949729832573535, 0.11070431547136139, 0.3398213978208956, 0.18321400271821053, 0.08673322547447748, 0.15757827684514325, 0.11776704951216088, 0.05499389891703743, 0.11437122842335301, 0.2581198161646733, 0.3188600312287365, 0.14672070428233241, 0.1703440562546179, 0.22885943486478988, 0.39529138086123905, 0.3813842070191342, 0.10959309035640341, 0.15437539288841495, 0.41518308170328055, 0.23646917968493608, 0.31543033665857845, 0.3407850452216138, 0.3689956156524681, 0.43028703337258045, 0.43576529267249453, 0.450371830365597, 0.4373313657668896, 0.42956088464774633, 0.3810631833098439, 0.2893460069915622, 0.7776527917278401, 0.7849004775846181, 0.7646344006356612, 0.7726533255511048, 0.7735869851512958, 0.7843166948573325, 0.7980849514460105, 0.7709142848616446, 0.7929151157597292, 0.1309419273454876, 0.14071383493156575, 0.09623525750593875, 0.1312431640145062, 0.0824086195512449, 0.15533497295574128, 0.15470558193400952, 0.11921634629355526, 0.1387073495887613, 0.6514210357047739, 0.684792026665179, 0.20834979097872175, 0.19532808985905525, 0.67878574839936, 0.16972663512760988, 0.602887623380245, 0.4339476544250661, 0.2831064432991802, 0.29085385922387064, 0.4646443086739097, 0.2366533727992992, 0.5717111276890051, 0.29653930301415143, 0.5924006362618928, 0.2890463552244191, 0.5885750576944265, 0.5887935277130761, 0.26081532333656643, 0.242258084955413, 0.2415377961894043, 0.45953419636403436, 0.4603605199182266, 0.3459055178816124, 0.23483847185254358, 0.24510148103436413, 0.24477304588383975, 0.21545575008710638, 0.22387947143505205, 0.2658810030856381, 0.28788885707262724, 0.2179127308083768, 0.26231593654699525, 0.25596981253314677, 0.20680180152846106, 0.20363253452730234, 0.2219965352434664, 0.22091714812806929, 0.18309005183620453, 0.2112421658373863, 0.20888203410277784, 0.18237695100054963, 0.18054931717612777, 0.21986543285351312, 0.17812454883328044, 0.18569232074644093, 0.18525065235671323, 0.12483398314039373, 0.9144981878684096, 0.19852955659694138, 0.17191775464926906, 0.8760483265848715, 0.8841587585173211, 0.8975618423022762, 0.8897577377333126, 0.21157796599126855, 0.8823371651932201, 0.20823622413701137, 0.8479498033842795, 0.8392967804457345, 0.16648189584274764, 0.16750906090971363, 0.7902450376996563, 0.18945315810438035, 0.18772907948467843, 0.1787033141408778, 0.196077478737257, 0.22363417489953086, 0.19126709822003019, 0.185402827228494, 0.1817248383023784, 0.19082966141893198, 0.08579110395824774, 0.10186177975557709, 0.10398683510952456, 0.09438224938124362, 0.09862792524177932, 0.08797871928459078, 0.09501472030039892, 0.09250159313213002, 0.09655674618263987]}, "mutation_prompt": null}
{"id": "5b57d984-857f-4ec9-a992-4e2f93eadf3a", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * (chaos_val ** 2) + np.random.uniform(-0.1, 0.1)  # Nonlinear adaptation\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Incorporate a nonlinear dynamic adaptation of the differential evolution scaling factor to enhance exploration and exploitation balance.", "configspace": "", "generation": 25, "fitness": 0.4124405852921183, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.27.", "error": "", "parent_id": "4bdd8d27-9b15-4a08-8106-f99576267995", "metadata": {"aucs": [0.8631704815884542, 0.8617830507254605, 0.8564328383870101, 0.8449079017462617, 0.8441344238846302, 0.8463258169633714, 0.8528851045639636, 0.8416053914110145, 0.8564718832168086, 0.6545834568185251, 0.6559292922937097, 0.7174764685792745, 0.6889287689945096, 0.6355896081728684, 0.6315339042048181, 0.6228297132656284, 0.671971478753462, 0.6735167157607969, 0.11628444152259965, 0.15762944105702914, 0.12068873105564071, 0.11530350712681936, 0.1047282388294356, 0.1554822679796387, 0.10967108795660119, 0.08770891889920529, 0.1537311791224384, 0.10598774868385097, 0.0680780260821855, 0.10671053098537109, 0.12139577241845745, 0.07859060490162395, 0.10245808759767006, 0.07758666691506855, 0.10695386620911973, 0.09750069225355473, 0.8987665145586591, 0.8662815326229084, 0.8727564822717297, 0.8856328129421549, 0.8741272702803682, 0.912803797271979, 0.8991520001021371, 0.8668891423406071, 0.9052305213077649, 0.7236042165232015, 0.6875607668559793, 0.7066999795266858, 0.7046284751242312, 0.6991014002171768, 0.7167438938688646, 0.6926593505332759, 0.6768829163102179, 0.7083825170184332, 0.22811394647831373, 0.2256804327473514, 0.3870103519173398, 0.2764970035626768, 0.277466533771645, 0.19214694660440768, 0.23346044278096412, 0.1501549055466137, 0.23338565596497984, 0.6142248081852026, 0.5374623231217566, 0.5885658501366934, 0.6614748939520612, 0.6827593646603402, 0.6106772908627306, 0.6989728850131636, 0.6351651158372186, 0.5953516398537781, 0.5375483322393717, 0.6142808134937352, 0.5732117152136356, 0.622652843555402, 0.5131041458801715, 0.5401313036526916, 0.6421674162932486, 0.709128734472583, 0.1327812542026302, 0.10182428004098054, 0.26985363344598456, 0.3848883657877278, 0.5004080052714954, 0.11352556965379368, 0.09754896795015244, 0.5538173852368176, 0.006542942253420225, 0.4201597184631841, 0.34737145838539485, 0.24886481551206185, 0.1917492432380029, 0.19216324050777778, 0.16096517299039947, 0.13124038058541065, 0.46253496911095304, 0.32210139334260546, 0.28388057994431015, 0.4057409115940678, 0.23696289634950518, 0.3529128323445453, 0.2297024755812317, 0.24547425329988137, 0.4074565304611085, 0.3338699049720514, 0.3697439730237143, 0.37018906419763775, 0.42033382770927596, 0.43140994000440647, 0.3854726791636848, 0.41695070524271094, 0.48362087720066693, 0.5051403066730644, 0.4421723290833707, 0.514480619270845, 0.424924809582645, 0.8118552471519134, 0.793353988547739, 0.8018683249058128, 0.7713210731856622, 0.7965825364642132, 0.8002225931433656, 0.8026233254599634, 0.7943490424116709, 0.8114374098151883, 0.09868041032210861, 0.1300810372193868, 0.08888872547366322, 0.10297780709608328, 0.10489981439036, 0.13070448226160114, 0.10936523256026809, 0.15726656754564106, 0.13021717643674346, 0.22389771372536538, 0.6876375571532267, 0.7065646048194331, 0.22050185330219818, 0.6911705543905713, 0.6350193574712368, 0.28279243527944653, 0.6340587445832153, 0.2716225826566836, 0.4686707105375627, 0.600768002606267, 0.5084558741901823, 0.6519110602181454, 0.6224310647255336, 0.6001621945036253, 0.2950937027232421, 0.5553527159203264, 0.2648705778853452, 0.23575761718988597, 0.2550640307425055, 0.21644387712614144, 0.37512539365928776, 0.4380308642029085, 0.5166810460112612, 0.26286555179228765, 0.2577988336286501, 0.25616649548514026, 0.23051719244477187, 0.20977538180902178, 0.2064552905890772, 0.26121068641034073, 0.24766026722457446, 0.25907825802729634, 0.23891153688576938, 0.3078182940161346, 0.2627700547029901, 0.17287676794397466, 0.18442636542886104, 0.2500424631246757, 0.24709005603090395, 0.1997158727834546, 0.20778832704751615, 0.19465563100886207, 0.19413801683011755, 0.20088730458518533, 0.1859341681001394, 0.1857860712082493, 0.18606866025659197, 0.9145265289351443, 0.1996751644150403, 0.17211871453448313, 0.14111393718193443, 0.18441664163581195, 0.8910667538340169, 0.8800635739824387, 0.1549016251963501, 0.8581758202879659, 0.8636675351083355, 0.16596554332325808, 0.20897498975124695, 0.8544125584816903, 0.16757929375498337, 0.8605402133578094, 0.1797064404815819, 0.2002650634911587, 0.19024866228317083, 0.1854719413723983, 0.1921100869997615, 0.1912519158012287, 0.17580135911445882, 0.24592657899746595, 0.18788619339842483, 0.08462289467468254, 0.10520080133251108, 0.08180437259606865, 0.0997978373797328, 0.1081367320013158, 0.09335925685456514, 0.07823332101778602, 0.09361640321962472, 0.08726548484270114]}, "mutation_prompt": null}
{"id": "7541d642-6863-49d2-a658-f5afd70b438a", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max_factor = 0.1  # adaptive velocity factor\n\n    def __call__(self, func):\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7\n        while eval_count < self.budget:\n            chaos_val = 4 * chaos_val * (1 - chaos_val)\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(self.population_size):\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                \n                vel_max = self.vel_max_factor * (self.ub - self.lb)\n                vel[i] = np.clip(vel[i], -vel_max, vel_max)  # Adaptive velocity clamping\n\n                pos[i] = pos[i] + vel[i]\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Gaussian mutation\n                if np.random.rand() < 0.1:\n                    pos[i] += np.random.normal(0, 0.1, self.dim)\n\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce adaptive velocity clamping and incorporate Gaussian mutation for enhanced exploration.", "configspace": "", "generation": 26, "fitness": 0.31093706643741403, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "4bdd8d27-9b15-4a08-8106-f99576267995", "metadata": {"aucs": [0.6480584167684144, 0.7156212274907887, 0.6832161957552638, 0.6374325786206045, 0.6561844108427526, 0.6591781987373537, 0.6413856646235911, 0.6564666410422637, 0.687596661097374, 0.20644494546442116, 0.1810997127291758, 0.24201674679505947, 0.12332695585081999, 0.2250350129453086, 0.18226883937223604, 0.11837682161031449, 0.22360418182899788, 0.15883683423386286, 0.16011432871828124, 0.17619314735497627, 0.14961524805596182, 0.12586132822065743, 0.15099490751474876, 0.1489391480342196, 0.15284528405958486, 0.11251539578794312, 0.10398047547984912, 0.10537206120663645, 0.13375778555269702, 0.11207832495365533, 0.11938318352974597, 0.1103744468252087, 0.1061456649329301, 0.10852931653988107, 0.11724783342175304, 0.0861693635634585, 0.9441921142240364, 0.9428245886225339, 0.9311079311620704, 0.9456487864445999, 0.9294499074328945, 0.9448031111076595, 0.9354828621784994, 0.914537157823015, 0.9420195236229925, 0.4415869163131867, 0.4361974489162469, 0.424651306426446, 0.42391919855991245, 0.46285206550587077, 0.43633595189044094, 0.41505647169021254, 0.4409445918839018, 0.4285595257821938, 0.7954977912090893, 0.4543560931230429, 0.8802947919431349, 0.27930870996420354, 0.8405727630372888, 0.2727702356076137, 0.8293366717686733, 0.869962577868974, 0.8090482366086085, 0.27105329409970624, 0.3121265372065596, 0.26941909725514823, 0.24586679344312157, 0.27597312355308623, 0.2620435628852166, 0.2644073943484361, 0.2604064216525752, 0.2921111619198058, 0.13345984200729633, 0.2813508994386289, 0.2764335299164148, 0.25663474448970824, 0.1322728938898372, 0.2814456003914355, 0.2478680190638154, 0.2496404435250229, 0.31384780264949763, 0.1445524964781547, 0.1132375941969267, 0.1285759987876558, 0.16358406951380655, 0.07940247999722183, 0.12691106952933584, 0.06895085950686863, 0.05510532346854358, 0.19621430552872277, 0.21077419745351356, 0.06661920137796207, 0.191973251076492, 0.09286911205512771, 0.11328492933987089, 0.049319269250901576, 0.204145830473221, 0.14725301126913093, 0.10120792804737833, 0.07812363390260813, 0.09551047719928296, 0.04518346079665703, 0.09612943811284536, 0.08941357506692893, 0.11053904488053645, 0.16099487483697106, 0.08931337844330478, 0.10057730089078254, 0.1134001729890588, 0.12165149568848632, 0.19938889888451194, 0.18361940837666668, 0.21550789446835994, 0.22229228211826613, 0.14698852000401708, 0.2048204254953917, 0.10098621364285609, 0.5610836309667749, 0.5352574658629079, 0.5603675372349939, 0.5295120564268638, 0.5643296488281291, 0.5003105621605171, 0.5290094498929965, 0.5473504174211086, 0.5359248467667034, 0.12082450367106534, 0.13476584473289366, 0.10938007965625274, 0.10670654034014837, 0.3073389381351854, 0.12627749462927007, 0.14200653655706663, 0.1402387645282659, 0.14505039001333753, 0.27597275556558165, 0.39068823255363594, 0.21060680392932152, 0.37075405621806934, 0.45575849452981, 0.34051489358935083, 0.34913035178586604, 0.16410450258640707, 0.28752284037652354, 0.37115744236693016, 0.3766993694872005, 0.40227492637480644, 0.3828995676612065, 0.38043331769976796, 0.3818760525424266, 0.39043363285736443, 0.37814508560803684, 0.3968168934067752, 0.30234068125177604, 0.24695451046005923, 0.29750573373736033, 0.30541488109230375, 0.3146905750044583, 0.3097381788319934, 0.30794116466272725, 0.31665890719098344, 0.2572019191886996, 0.21872212894913956, 0.2580485877056232, 0.19761493796130347, 0.26390434658640727, 0.24492495750995957, 0.2642567375171867, 0.24380834127276907, 0.25757024859274513, 0.20723773094387465, 0.23158106306797976, 0.20995849287340462, 0.19048270184369287, 0.20482699471540633, 0.1999529578479543, 0.18192555397630283, 0.22099136453423285, 0.21768575903549114, 0.18216203911234885, 0.18704522743015717, 0.18673167900840526, 0.14702601482588618, 0.881293420213568, 0.20021863979913546, 0.1998814034189118, 0.14184820028570322, 0.16924383635703055, 0.8903512602397357, 0.8195936689684835, 0.21152330816979104, 0.8658210352213813, 0.2098188111626852, 0.8119453906357137, 0.16703561462634275, 0.16563103229283993, 0.8347778756706279, 0.830488080763473, 0.1839054149025331, 0.19226571712648466, 0.1883167376045518, 0.17743554299801656, 0.17194728209474475, 0.17475192130137507, 0.21786603564174434, 0.17860954732673306, 0.17553046894227242, 0.09274238387241218, 0.0903487013766795, 0.10249442232342154, 0.09644491990250281, 0.08790817470952828, 0.09754653865074925, 0.12192513488194745, 0.08562639332121857, 0.09847388682309666]}, "mutation_prompt": null}
{"id": "535c9397-38a7-46f2-9e7c-98017319ca9f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce a random inertia weight perturbation and enhance mutation diversity for improved exploration.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4bdd8d27-9b15-4a08-8106-f99576267995", "metadata": {"aucs": [0.8556421664289277, 0.8549696233133078, 0.8634204327586672, 0.8426241311396068, 0.8482992190584626, 0.8484945207451412, 0.8547857952763884, 0.8373418122836526, 0.8474807981274585, 0.6390210998587784, 0.6578765634234136, 0.6868178463251026, 0.6394448801041607, 0.6530236934125673, 0.6535716106592343, 0.5936924096470445, 0.62122690964524, 0.6075099482023336, 0.1803047279589316, 0.11419409618735155, 0.12709806376185884, 0.09855831090373335, 0.11042725545880006, 0.157034214083573, 0.11987477247266853, 0.15511043842505223, 0.12838740150573136, 0.15348945105730638, 0.08979167300101054, 0.13658703517496085, 0.09046859141015562, 0.1272093651706968, 0.09674997453411183, 0.08577503883698223, 0.11389552848562234, 0.10298811419713716, 0.9100570304288091, 0.8650780290797997, 0.859668076182671, 0.8869482702546851, 0.8560157490564119, 0.9216017685268375, 0.8998517016594284, 0.8689651335635249, 0.9184957130762181, 0.7015123297646813, 0.7102520226804928, 0.7019690706771227, 0.6959991168778101, 0.6670009962363415, 0.6748492909516519, 0.6957280108552255, 0.7051935150872982, 0.7084847304754787, 0.8523276954525127, 0.2249897385791051, 0.8640597986698355, 0.8546970458306095, 0.8706331677415797, 0.27446629127234023, 0.22981844986601785, 0.1767628142095493, 0.875659564198044, 0.6532794832355238, 0.5890132379432269, 0.6103490042583999, 0.6229708796533135, 0.6062325329119036, 0.5830294469304365, 0.5819496606839758, 0.6456221963765538, 0.6408789121834596, 0.598486398667587, 0.608737664907662, 0.5687180337889879, 0.6082418351639789, 0.6193443146601543, 0.6209346730437049, 0.6697623037777276, 0.5883201343850697, 0.6146670123502568, 0.4399864505009201, 0.3213942660449899, 0.39745477726829526, 0.5001172207533572, 0.2153150369545922, 0.15806405941090174, 0.3176256392465654, 0.22487253390818518, 0.3836166748547586, 0.26101345477283955, 0.1219888466400707, 0.16995504656780636, 0.10884477754811106, 0.051193274793515764, 0.1112319021784528, 0.2850646011675836, 0.44398266788438134, 0.187669860523898, 0.1614052940070324, 0.37318299614568884, 0.417072981866754, 0.5399274812268832, 0.11876772697975013, 0.2083989132383215, 0.2904755521103848, 0.36891048558132045, 0.3028851022425578, 0.44096389284984305, 0.41692446444650244, 0.42448800232347017, 0.47104334815310034, 0.47235326106551634, 0.5002085056490002, 0.44906946758707034, 0.30570750682710435, 0.41038121612032097, 0.7840473980293685, 0.7857511982756386, 0.7876382087357032, 0.7606829631699021, 0.77511087737276, 0.7945974949487931, 0.789733102959478, 0.8080458553341119, 0.804834879532619, 0.10354881661913551, 0.13639325826454585, 0.0931115047122093, 0.13962388312210938, 0.11034480841676886, 0.11436606958398154, 0.18284953988686659, 0.12848462802147076, 0.13550067036175895, 0.6808889758927935, 0.24345750247562048, 0.5846898304834421, 0.6454254857159989, 0.7194602582201914, 0.3424082799478514, 0.2155899546886595, 0.6034184010723077, 0.26531175589251443, 0.2847950820782069, 0.3119889672070576, 0.3256062861201995, 0.6232391443521406, 0.49131110469289174, 0.5111212902292157, 0.2671121910109736, 0.616133248734159, 0.4745249667350706, 0.2590178122042467, 0.44215597590515077, 0.25514169701419087, 0.29883631865866, 0.26387444887930966, 0.5424242662579319, 0.23634593413609728, 0.2812445215938817, 0.23800257934440483, 0.24531482490407208, 0.23138612326542152, 0.23417861052952116, 0.2369095192559253, 0.2866938865537544, 0.4567732478809784, 0.23893716335337867, 0.22683782597917912, 0.20825906744652556, 0.24506247284617944, 0.24621517817882044, 0.19502007631675378, 0.22068438731187312, 0.20452010790780684, 0.18207786424341676, 0.18581896691824973, 0.21856740580742196, 0.21892772457121568, 0.18568205741171284, 0.8758225289783393, 0.172390277072891, 0.9142488139987004, 0.19840431960568483, 0.17196230973311466, 0.8739299140684031, 0.8825240759023424, 0.8988261954376928, 0.9010022689352849, 0.2117261380892308, 0.8685287413667282, 0.20823257141203066, 0.8556886513600507, 0.8509778298948193, 0.16642324356799654, 0.16751122733955492, 0.8288515447623506, 0.18721954111235117, 0.17790166944720387, 0.20913667823948645, 0.1793451789083016, 0.1843910010926516, 0.17852385042389873, 0.25013628782133734, 0.1782781930598054, 0.18609137356672922, 0.08237200957526092, 0.1022574680259446, 0.10731727300130334, 0.09110304046588136, 0.09531046691456102, 0.10586189613624297, 0.08947837586969076, 0.1083695756899955, 0.10021782289284542]}, "mutation_prompt": null}
{"id": "62ccb9fa-e51f-4fad-82c8-c55aa38d50d1", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce a random inertia weight perturbation and enhance mutation diversity for improved exploration.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4bdd8d27-9b15-4a08-8106-f99576267995", "metadata": {"aucs": [0.8556421664289277, 0.8549696233133078, 0.8634204327586672, 0.8426241311396068, 0.8482992190584626, 0.8484945207451412, 0.8547857952763884, 0.8373418122836526, 0.8474807981274585, 0.6390210998587784, 0.6578765634234136, 0.6868178463251026, 0.6394448801041607, 0.6530236934125673, 0.6535716106592343, 0.5936924096470445, 0.62122690964524, 0.6075099482023336, 0.1803047279589316, 0.11419409618735155, 0.12709806376185884, 0.09855831090373335, 0.11042725545880006, 0.157034214083573, 0.11987477247266853, 0.15511043842505223, 0.12838740150573136, 0.15348945105730638, 0.08979167300101054, 0.13658703517496085, 0.09046859141015562, 0.1272093651706968, 0.09674997453411183, 0.08577503883698223, 0.11389552848562234, 0.10298811419713716, 0.9100570304288091, 0.8650780290797997, 0.859668076182671, 0.8869482702546851, 0.8560157490564119, 0.9216017685268375, 0.8998517016594284, 0.8689651335635249, 0.9184957130762181, 0.7015123297646813, 0.7102520226804928, 0.7019690706771227, 0.6959991168778101, 0.6670009962363415, 0.6748492909516519, 0.6957280108552255, 0.7051935150872982, 0.7084847304754787, 0.8523276954525127, 0.2249897385791051, 0.8640597986698355, 0.8546970458306095, 0.8706331677415797, 0.27446629127234023, 0.22981844986601785, 0.1767628142095493, 0.875659564198044, 0.6532794832355238, 0.5890132379432269, 0.6103490042583999, 0.6229708796533135, 0.6062325329119036, 0.5830294469304365, 0.5819496606839758, 0.6456221963765538, 0.6408789121834596, 0.598486398667587, 0.608737664907662, 0.5687180337889879, 0.6082418351639789, 0.6193443146601543, 0.6209346730437049, 0.6697623037777276, 0.5883201343850697, 0.6146670123502568, 0.4399864505009201, 0.3213942660449899, 0.39745477726829526, 0.5001172207533572, 0.2153150369545922, 0.15806405941090174, 0.3176256392465654, 0.22487253390818518, 0.3836166748547586, 0.26101345477283955, 0.1219888466400707, 0.16995504656780636, 0.10884477754811106, 0.051193274793515764, 0.1112319021784528, 0.2850646011675836, 0.44398266788438134, 0.187669860523898, 0.1614052940070324, 0.37318299614568884, 0.417072981866754, 0.5399274812268832, 0.11876772697975013, 0.2083989132383215, 0.2904755521103848, 0.36891048558132045, 0.3028851022425578, 0.44096389284984305, 0.41692446444650244, 0.42448800232347017, 0.47104334815310034, 0.47235326106551634, 0.5002085056490002, 0.44906946758707034, 0.30570750682710435, 0.41038121612032097, 0.7840473980293685, 0.7857511982756386, 0.7876382087357032, 0.7606829631699021, 0.77511087737276, 0.7945974949487931, 0.789733102959478, 0.8080458553341119, 0.804834879532619, 0.10354881661913551, 0.13639325826454585, 0.0931115047122093, 0.13962388312210938, 0.11034480841676886, 0.11436606958398154, 0.18284953988686659, 0.12848462802147076, 0.13550067036175895, 0.6808889758927935, 0.24345750247562048, 0.5846898304834421, 0.6454254857159989, 0.7194602582201914, 0.3424082799478514, 0.2155899546886595, 0.6034184010723077, 0.26531175589251443, 0.2847950820782069, 0.3119889672070576, 0.3256062861201995, 0.6232391443521406, 0.49131110469289174, 0.5111212902292157, 0.2671121910109736, 0.616133248734159, 0.4745249667350706, 0.2590178122042467, 0.44215597590515077, 0.25514169701419087, 0.29883631865866, 0.26387444887930966, 0.5424242662579319, 0.23634593413609728, 0.2812445215938817, 0.23800257934440483, 0.24531482490407208, 0.23138612326542152, 0.23417861052952116, 0.2369095192559253, 0.2866938865537544, 0.4567732478809784, 0.23893716335337867, 0.22683782597917912, 0.20825906744652556, 0.24506247284617944, 0.24621517817882044, 0.19502007631675378, 0.22068438731187312, 0.20452010790780684, 0.18207786424341676, 0.18581896691824973, 0.21856740580742196, 0.21892772457121568, 0.18568205741171284, 0.8758225289783393, 0.172390277072891, 0.9142488139987004, 0.19840431960568483, 0.17196230973311466, 0.8739299140684031, 0.8825240759023424, 0.8988261954376928, 0.9010022689352849, 0.2117261380892308, 0.8685287413667282, 0.20823257141203066, 0.8556886513600507, 0.8509778298948193, 0.16642324356799654, 0.16751122733955492, 0.8288515447623506, 0.18721954111235117, 0.17790166944720387, 0.20913667823948645, 0.1793451789083016, 0.1843910010926516, 0.17852385042389873, 0.25013628782133734, 0.1782781930598054, 0.18609137356672922, 0.08237200957526092, 0.1022574680259446, 0.10731727300130334, 0.09110304046588136, 0.09531046691456102, 0.10586189613624297, 0.08947837586969076, 0.1083695756899955, 0.10021782289284542]}, "mutation_prompt": null}
{"id": "8bbc998a-54af-4e36-ad8f-027912aa1df8", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        dynamic_pop_size = self.population_size\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(dynamic_pop_size):  # Dynamic population size\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel_variance = (np.mean(np.var(vel, axis=0)) + 0.01) * dynamic_factor  # Velocity variance\n                vel[i] = np.clip(vel[i], -vel_variance, vel_variance)\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(dynamic_pop_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "An enhanced hybrid PSO-DE algorithm that introduces a dynamic population size and velocity variance to improve convergence speed and solution accuracy.", "configspace": "", "generation": 29, "fitness": 0.2470889231525484, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.23.", "error": "", "parent_id": "4bdd8d27-9b15-4a08-8106-f99576267995", "metadata": {"aucs": [0.7692011842177505, 0.7174771976462483, 0.7740544004214528, 0.7519705821502856, 0.7562575020826461, 0.7441652385976739, 0.7599406360633899, 0.7356091261135838, 0.319839555465934, 0.023044823428754135, 0.1652834743717927, 0.12069998736424059, 0.25557489854355375, 0.27063179876736954, 9.999999999998899e-05, 9.999999999998899e-05, 0.08571792553538049, 9.999999999998899e-05, 0.14263037113996635, 0.1676719853892702, 0.1469732808396389, 0.10992234477772889, 0.1292438906294927, 0.14524389714635033, 0.1210904281077001, 0.1061848658336556, 0.15424199602589161, 0.09946371522390074, 0.09065866873208128, 0.10543409834188366, 0.12430599903711792, 0.1086018043936332, 0.08332778546909936, 0.10265792528841133, 0.10783870643306781, 0.10787396798320426, 0.9767847135368982, 0.9769264982293606, 0.9785298735622437, 0.979973023942479, 0.9801980136550495, 0.9803815223703499, 0.9833853988446161, 0.9801222570149365, 0.9808165703923141, 0.2165216823140962, 0.17873436372942997, 0.2008223675315024, 0.189178310788094, 0.14925778112449983, 0.20751029823506395, 0.16553181906127612, 0.14138173858384184, 0.11534960344815992, 0.2248022837159499, 0.3400429253330579, 0.7066687558851557, 0.2707032614657007, 0.20915595075001636, 0.15660601075344494, 0.3293742506542665, 0.1794782994822326, 0.34038158344864844, 0.14146129800390372, 0.12374193891788088, 0.1210083137330823, 0.12538758763683766, 0.1717193964723268, 0.03572232858771163, 0.14712819842596947, 0.1440614053562438, 0.15677835203971224, 0.15603650684543302, 0.20779132533272293, 0.11748456642225535, 0.1264613819875342, 0.10248260652191421, 0.1309837253398809, 0.12449141430181754, 0.10673954820320686, 0.1414025676496129, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0157741333282031, 0.03495374296421083, 9.999999999998899e-05, 0.023986603795517092, 9.999999999998899e-05, 9.999999999998899e-05, 0.1457637601724242, 0.05372825168266682, 0.10237947698734295, 0.05473665312878906, 0.061347144777259555, 0.03166964039070741, 0.16440462444690274, 0.11197537390860779, 0.08630404174490847, 0.028717891256139216, 0.08611667497275044, 0.11323888514218483, 0.09909318625978414, 0.20508823282811295, 0.1515981299906476, 0.16433995580887928, 0.2401576747119465, 0.05730583478572082, 0.14010193243164704, 0.0681232696418067, 0.08905449515696129, 0.08420455190630105, 0.17413817411535493, 0.05325284469191505, 0.12253664159755595, 0.19578258901955714, 0.12930381751215791, 0.5334136186920975, 0.5185835626409633, 0.5516533336247353, 0.4947480778424127, 0.5341364652436406, 0.5707855313738706, 0.5254218842639289, 0.44257172244665066, 0.5848243107750215, 0.12253194859363215, 0.14436920258727293, 0.0833284712915493, 0.1328062930108428, 0.13902195268799755, 0.14282409382569017, 0.14067742137650874, 0.12837507017917305, 0.11609488179213401, 0.2195076647824291, 0.1688571871351201, 0.16737012000232498, 0.13671205535288555, 0.2462934781356535, 0.16076220450153322, 0.12992346460730386, 0.1968294949178785, 0.1580106569950971, 0.30150241431450053, 0.28721092865846576, 0.3319460643577158, 0.31464404739749285, 0.28059331043991687, 0.36797808300065404, 0.29658129617843787, 0.4644563677710881, 0.31620125593752635, 0.1900043542256421, 0.2902149000510117, 0.21771204380232245, 0.30336394859362115, 0.24486808836239826, 0.19728768799458685, 0.22246643374114372, 0.2268524807413429, 0.25275728687802146, 0.23185041235026516, 0.20312644131046909, 0.19628182432541885, 0.23335969768644194, 0.2049731300266835, 0.21427010531927515, 0.25159764196956025, 0.22181942622276096, 0.2128308320331196, 0.16313153741370712, 0.18980728607857367, 0.17550494697221275, 0.16604516338249065, 0.18399339394562997, 0.1863673887247591, 0.1904329469989373, 0.1731956743433859, 0.16906642350329582, 0.18284695959905672, 0.1931403753576939, 0.1532488923528137, 0.19774003350824843, 0.19593428166145532, 0.16587686879646657, 0.8128998642342208, 0.8448332615350823, 0.7814115356491069, 0.6858510710440087, 0.20958429881465857, 0.5543734551854681, 0.18641527129859425, 0.6055465981391512, 0.18763736982709445, 0.20948585365260064, 0.31740038372531143, 0.2072918898370183, 0.18723846458968685, 0.18719400325123836, 0.18167577804004453, 0.2004029305274233, 0.1764276333488105, 0.20666717805135026, 0.17358706970208604, 0.185771210063441, 0.1898328861667915, 0.09375485351084312, 0.10282845059974477, 0.09453745020363913, 0.0913699079313437, 0.08170388410402907, 0.09304358853720984, 0.08686290073409453, 0.08229135741470395, 0.08735624587485002]}, "mutation_prompt": null}
{"id": "14d8468b-54ed-4e25-b366-b20e2301f597", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enhanced boundary handling\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n                if np.any(pos[i] == self.lb) or np.any(pos[i] == self.ub):\n                    pos[i] += np.random.uniform(-0.1, 0.1, self.dim)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce adaptive learning rates and enhanced boundary handling to improve exploration and convergence.", "configspace": "", "generation": 30, "fitness": 0.4285197018792008, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.28.", "error": "", "parent_id": "4bdd8d27-9b15-4a08-8106-f99576267995", "metadata": {"aucs": [0.8556421664289277, 0.8549696233133078, 0.8634204327586672, 0.8379122356575164, 0.8400113769174322, 0.8472025585111596, 0.8372538568550687, 0.8323280091310213, 0.8474807981274585, 0.6390210998587784, 0.6578765634234136, 0.6868178463251026, 0.6856647695247917, 0.6160907088844041, 0.6271324404550536, 0.5936924096470445, 0.6671386842965378, 0.5871810028248337, 0.10939982915784563, 0.11419409618735155, 0.12709806376185884, 0.09855831090373335, 0.11042725545880006, 0.157034214083573, 0.11987477247266853, 0.14132093768775844, 0.12838740150573136, 0.15348945105730638, 0.09400322090982449, 0.13658703517496085, 0.12856345245447354, 0.1272093651706968, 0.09674997453411183, 0.08577503883698223, 0.11392790814176823, 0.10298811419713716, 0.864480891983065, 0.8808148245413534, 0.8766505751384402, 0.8862479506700571, 0.8583643649669424, 0.8835998383766135, 0.873354113076792, 0.8385647589627918, 0.8622654331151228, 0.7015123297646813, 0.6713119986323764, 0.6740818874009024, 0.674469377631047, 0.696675026277972, 0.6823239116835427, 0.7026340468333796, 0.706504486407577, 0.7084847304754787, 0.87461120314244, 0.2249897385791051, 0.8640597986698355, 0.21212119551535924, 0.27114962458044933, 0.2095867429523922, 0.2309582522943069, 0.8331743170600974, 0.18386719303592036, 0.6532794832355238, 0.5890132379432269, 0.6103490042583999, 0.5794873909496545, 0.61329096092763, 0.5830294469304365, 0.63448833501992, 0.6456221963765538, 0.6408789121834596, 0.598486398667587, 0.608737664907662, 0.13035705179734047, 0.6082418351639789, 0.6193443146601543, 0.5966015750888372, 0.6697623037777276, 0.5883201343850697, 0.6146670123502568, 0.569255326893397, 0.5187146030777374, 0.18333708637386614, 0.34238105520841877, 0.3050714988961135, 0.12556156155841325, 0.3176256392465654, 0.10104245148038316, 0.3836166748547586, 0.29313732843483686, 0.17884871283332504, 0.13965748147505497, 0.10884477754811106, 0.08787348039704834, 0.0895844694111605, 0.1467378495741245, 0.13397535042471553, 0.12409312976273867, 0.2095199067318546, 0.37318299614568884, 0.3943553153363851, 0.1634715105097555, 0.16956190395975523, 0.2083989132383215, 0.37703152761369096, 0.15764283866790374, 0.32654466912971225, 0.44096389284984305, 0.3015208963874536, 0.42448800232347017, 0.456984448453859, 0.4675156992406323, 0.5002085056490002, 0.48849801982093355, 0.4279453182918109, 0.38356797236941464, 0.7926187650228675, 0.7857511982756386, 0.7876382087357032, 0.784140991557876, 0.77511087737276, 0.797496133583499, 0.789733102959478, 0.8080458553341119, 0.804834879532619, 0.1410778635850085, 0.11150259019182629, 0.08210363464601744, 0.15457509198245423, 0.11034480841676886, 0.11436606958398154, 0.13981527018286033, 0.10773211854937104, 0.13550067036175895, 0.2157403961115959, 0.693163715482384, 0.5846898304834421, 0.44296764933904087, 0.6662033705138284, 0.6907346366456701, 0.6432508853928053, 0.7048764542137447, 0.23903392465170037, 0.21524241156604396, 0.3119889672070576, 0.3256062861201995, 0.6440159960716322, 0.49131110469289174, 0.5111212902292157, 0.2671121910109736, 0.5824629402269315, 0.4745249667350706, 0.4967786011228491, 0.44215597590515077, 0.25514169701419087, 0.4964261851768692, 0.26387444887930966, 0.5424242662579319, 0.23634593413609728, 0.2812445215938817, 0.23787566298941898, 0.24531482490407208, 0.23138612326542152, 0.2356806405230848, 0.2369095192559253, 0.2866938865537544, 0.4567732478809784, 0.23893716335337867, 0.257159986607987, 0.23185252547554258, 0.24506247284617944, 0.24621517817882044, 0.19502007631675378, 0.22068438731187312, 0.20857201404270476, 0.18207786424341676, 0.18581896691824973, 0.21856740580742196, 0.21892772457121568, 0.18568205741171284, 0.8758225289783393, 0.172390277072891, 0.9142488139987004, 0.19840431960568483, 0.17196230973311466, 0.9085254791175329, 0.8877951768518008, 0.8988261954376928, 0.9010022689352849, 0.8747215146981158, 0.8904164477541349, 0.20823257141203066, 0.819347410229849, 0.8509778298948193, 0.16678004535822166, 0.16751122733955492, 0.8457873651171559, 0.19236775200960277, 0.1851259248153554, 0.18141161741050493, 0.1649972923242764, 0.25831446954139337, 0.17852385042389873, 0.25674920106972754, 0.1725542583486931, 0.17482118292800075, 0.08237200957526092, 0.1022574680259446, 0.09627110894663471, 0.09110304046588136, 0.09531046691456102, 0.10586189613624297, 0.08947837586969076, 0.1083695756899955, 0.09157411956495065]}, "mutation_prompt": null}
{"id": "84cb29f4-73ef-48ce-aaf3-a6693faa9ee0", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max * dynamic_factor)  # Dynamic velocity clamping\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                cr_dynamic = self.CR * (0.5 + dynamic_factor)  # Adaptive crossover probability\n                trial = np.where(np.random.rand(self.dim) < cr_dynamic, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Incorporate a dynamic velocity boundary and adaptive crossover rate to improve exploration and convergence.", "configspace": "", "generation": 31, "fitness": 0.40824182435697964, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.28.", "error": "", "parent_id": "4bdd8d27-9b15-4a08-8106-f99576267995", "metadata": {"aucs": [0.8544140698189141, 0.8613626942640566, 0.8515414070018014, 0.8371650884592603, 0.8346336320070213, 0.8467121152960644, 0.8528286916752523, 0.8324480024867724, 0.8384489040205089, 0.6461123211522246, 0.6071809687270748, 0.659586249381924, 0.5883906421869877, 0.6502198194603246, 0.6806708436786348, 0.5548319823855772, 0.615535571550264, 0.5303260251257766, 0.13088897597550442, 0.11944201125828025, 0.16861099254011935, 0.13121905420994096, 0.12186804022855813, 0.10858901193407022, 0.11470778958851824, 0.14036116393200715, 0.14053962258371844, 0.09757857458387753, 0.1061052066088436, 0.09802024478986893, 0.10871581043678125, 0.10509237144190775, 0.12419411245940704, 0.09074864367234059, 0.10564426562031748, 0.09456728499051859, 0.8776427573997716, 0.8530181613289817, 0.8627024063728483, 0.8656482309413579, 0.8556939031409345, 0.8732572576887351, 0.9019683677123507, 0.8497962596975581, 0.9180796682402191, 0.6795932149375166, 0.7070975009407057, 0.6902908619514638, 0.698414238558403, 0.701397596788643, 0.6378420925502376, 0.6857352047373764, 0.6560382161943699, 0.6925324753059154, 0.2279549856899572, 0.22528745914046255, 0.22636500475258092, 0.3230232289145478, 0.8357489935974642, 0.7331548625920009, 0.14973823393502395, 0.8697993534366525, 0.23246450065397528, 0.626897261662735, 0.1316757421148994, 0.598677891916175, 0.626455543324578, 0.12725384303285792, 0.5323656092656073, 0.5960719806310169, 0.5918963770481777, 0.648527565451197, 0.1335091356925, 0.6127262150431609, 0.1342277372960361, 0.6579899629859624, 0.6986771810794566, 0.6264591181018049, 0.5979785760014469, 0.646136761048633, 0.13164072260985937, 0.14669696773604934, 0.0681356869293559, 0.2747449487742124, 0.29067184581663974, 0.11580641719658957, 0.03555596636963432, 0.13860141323281772, 0.5446903213059868, 0.41609250808324627, 0.15984627716674404, 0.13637473847487158, 0.13103588418289414, 0.1168324196218351, 0.08243513036642458, 0.052652780454279124, 0.19116056406730286, 0.16255767156412226, 0.18206889345638988, 0.13147053195878267, 0.20912602260361945, 0.4099292510595417, 0.11429861685942255, 0.11742650954900324, 0.32329009284874977, 0.3848159854864487, 0.2431488468199272, 0.10752942363411655, 0.3944822782956151, 0.42520063893410565, 0.41761281951685947, 0.39942447761563893, 0.4868958395471823, 0.46330128613612265, 0.44813777117067266, 0.45457007925870485, 0.26598577054384975, 0.8051673955875528, 0.8086257679103307, 0.7973923699282583, 0.8088413961527013, 0.7929837514360644, 0.8050293092615959, 0.8166010831230355, 0.797264312523679, 0.8209409895593544, 0.10283561253440987, 0.17914644042059646, 0.09005317476836827, 0.11423075897929846, 0.13492472508271347, 0.15500104938159276, 0.08698369223464164, 0.11903101689215967, 0.11658423750987679, 0.19845429497646694, 0.21092972654062614, 0.2161632917715396, 0.16904484689133592, 0.6898590735859711, 0.7029275937555868, 0.2578313458355027, 0.2640463696211208, 0.7074540387063603, 0.4347621051755396, 0.6247271990144636, 0.4569809280826409, 0.5125194660365537, 0.43457011972169546, 0.6067119643606005, 0.25618672494377737, 0.4199056066157969, 0.284335804578266, 0.56452814335977, 0.4898434606053581, 0.24365987754362972, 0.43515243299508366, 0.4820225020472946, 0.38082524275554874, 0.22988815496961823, 0.25675738074515875, 0.276583562635651, 0.232855451001037, 0.2662229050474295, 0.22971111379013653, 0.23946919286790014, 0.23880715808327535, 0.20944400520718565, 0.21758642086910718, 0.2707456172792523, 0.22081436950311906, 0.190706537968509, 0.19800386959875993, 0.19445723228383394, 0.20615769442392395, 0.19552288857099598, 0.17964698870862228, 0.19492472280470752, 0.18370792662270674, 0.1698650995340737, 0.8963874075290689, 0.18544688990659286, 0.1852655045021009, 0.8869763085159272, 0.19882591003846095, 0.19772165714704804, 0.9077550848762032, 0.17525011345387242, 0.9013178115797805, 0.8967722370536048, 0.2096778241780377, 0.8853044822852051, 0.889486517555793, 0.853834859478944, 0.8643814234992719, 0.8773115271391897, 0.8278829309152821, 0.8653078457561738, 0.20262456037840915, 0.17649038763070024, 0.19187335075572587, 0.23398018114204, 0.19426215793348944, 0.18762376355485355, 0.20118082399433979, 0.18732775058988183, 0.2128781992722315, 0.08013390453921054, 0.09453926757585229, 0.08839406553826046, 0.08505832165788685, 0.10368356423278458, 0.11151494499292325, 0.09571031324672497, 0.08714911153882099, 0.10258437812421417]}, "mutation_prompt": null}
{"id": "70fa9761-faf0-4a0c-af8a-6c1785810ef2", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.6 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Enhance global exploration with adaptive chaotic perturbation and improved DE mutation scaling. ", "configspace": "", "generation": 32, "fitness": 0.4186964182590937, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.27.", "error": "", "parent_id": "4bdd8d27-9b15-4a08-8106-f99576267995", "metadata": {"aucs": [0.8310124546062956, 0.8368639537245066, 0.838931580121669, 0.8260105927270116, 0.8202632957577303, 0.835625923761856, 0.8195816671009906, 0.8205768389773738, 0.8249565394717492, 0.6670587138696796, 0.6467512027510124, 0.6709602470199238, 0.6428070074545893, 0.6316409804632737, 0.662380602859503, 0.5844869677728185, 0.5536422920115434, 0.6213492318911319, 0.14295859343981498, 0.11273748325387423, 0.1772314557057747, 0.11290236594977121, 0.10648186962151263, 0.1535481464441798, 0.13763457939160695, 0.1545862924414272, 0.12607649405520294, 0.09960288080360857, 0.1033072082702522, 0.12837605138671482, 0.10668346101118353, 0.1105991389832881, 0.10308112910262912, 0.12688464677693334, 0.09338123244453778, 0.10303239256478647, 0.9036452454688729, 0.8820260153430587, 0.8820135663327899, 0.9100540103894732, 0.8819290529684269, 0.9356170545892861, 0.8977152611046373, 0.9063290903385279, 0.9433565987730389, 0.6384789814343284, 0.6291015103679054, 0.6359723481707555, 0.6341896776832874, 0.6627588117291878, 0.656801207464009, 0.6441865920324108, 0.644426734637761, 0.61686217074626, 0.8574852738439183, 0.8386336909869134, 0.8379757878413824, 0.27174171622109455, 0.8607170615439566, 0.21051134987964482, 0.811548675909181, 0.7875702278792579, 0.7977440134500736, 0.5988958914957199, 0.5396770713659159, 0.5417226298260794, 0.5292909181965957, 0.12728759556200564, 0.49742129135700175, 0.5311613072226766, 0.537290459602729, 0.560168946852178, 0.5623173741202196, 0.5529699144692297, 0.5508774947959202, 0.5525501177720517, 0.5673555394364647, 0.5514907206479136, 0.5577496817994756, 0.5437020455559232, 0.5919610566921504, 0.11398649255166693, 0.31680721244261745, 0.08906099723691863, 0.1893557445523446, 0.21701739669597442, 0.43607568085821813, 0.09586466586681763, 0.21672274607166986, 0.2319425891047464, 0.23422583801580654, 0.09248727360546904, 0.19285747057636737, 0.08017781350201769, 0.07463638880204049, 0.07893687446583153, 0.40153269524014223, 0.14989282712000362, 0.18428775457940405, 0.2962792924881107, 0.25621781332961446, 0.19300050914133904, 0.14783836303869335, 0.12414395173781101, 0.13093954547011066, 0.2399635798753006, 0.39503526272197964, 0.22520283425790077, 0.3335387810665734, 0.3790206152332891, 0.4323160610555168, 0.42351313629006393, 0.39839232386225654, 0.443427825002804, 0.3745595305996323, 0.377035660684628, 0.3922708223179038, 0.7598848870171939, 0.7749902990416734, 0.7566943408864584, 0.738092109798056, 0.7355373790999538, 0.7318184948177986, 0.7630785991065617, 0.7704741757619723, 0.7636946647914288, 0.13550728160176806, 0.09726366597417002, 0.12549575732695661, 0.12838859444356387, 0.11178675671874339, 0.11386424777325188, 0.17160536047641106, 0.09408424319808617, 0.10725316400339868, 0.5148694633132933, 0.5569059608434166, 0.5417096775802648, 0.5729861361384649, 0.6314573652315787, 0.36612953866656106, 0.5565784857863881, 0.24577850836590065, 0.5721237230169558, 0.533267523469731, 0.5607575654650132, 0.5671387450754661, 0.5428272283720763, 0.5464318895951896, 0.5837685798552958, 0.4903855959932817, 0.5041223962930492, 0.5055307581861177, 0.4389147447058971, 0.42578837817637716, 0.46122396279442157, 0.2757148814466053, 0.304658200167766, 0.38372601548977703, 0.2472332169418927, 0.45426571346777067, 0.2531568299177762, 0.2449184151383268, 0.2574713473778022, 0.2729918565744248, 0.20110707467011768, 0.23191176476133035, 0.2814171696760527, 0.23502845810046025, 0.23726737240201334, 0.2107146214175981, 0.21543684357537585, 0.18612545063021102, 0.18688090995558615, 0.2088695994401244, 0.20152274538922366, 0.2196628730421719, 0.1784404107396358, 0.23793828390589422, 0.20906693684939837, 0.8876193307185203, 0.18570912681567364, 0.18761646528001175, 0.8892315691127517, 0.19856812152321335, 0.8806627322036304, 0.8652297787317056, 0.13517685222094555, 0.17549252162027373, 0.8808403860559426, 0.20982539426982472, 0.8793548480174769, 0.20923599818953675, 0.8487588809150812, 0.10370567991028856, 0.16333707564627875, 0.8458835997927757, 0.8006302825807783, 0.1935266070145949, 0.17894888830702327, 0.194441785361945, 0.2180446483257269, 0.18867494273496854, 0.17321791372687345, 0.17971956319919646, 0.1889247818608073, 0.19202004596274902, 0.09671030889151211, 0.08718940310115975, 0.11852425262734467, 0.08355829787902203, 0.08866827039388758, 0.12771269067419633, 0.08544780626043935, 0.09336850793433493, 0.10326007891318456]}, "mutation_prompt": null}
{"id": "775bca81-c45a-4e22-a975-b3de4441d4e4", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce a random inertia weight perturbation and enhance mutation diversity for improved exploration.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4bdd8d27-9b15-4a08-8106-f99576267995", "metadata": {"aucs": [0.8556421664289277, 0.8549696233133078, 0.8634204327586672, 0.8426241311396068, 0.8482992190584626, 0.8484945207451412, 0.8547857952763884, 0.8373418122836526, 0.8474807981274585, 0.6390210998587784, 0.6578765634234136, 0.6868178463251026, 0.6394448801041607, 0.6530236934125673, 0.6535716106592343, 0.5936924096470445, 0.62122690964524, 0.6075099482023336, 0.1803047279589316, 0.11419409618735155, 0.12709806376185884, 0.09855831090373335, 0.11042725545880006, 0.157034214083573, 0.11987477247266853, 0.15511043842505223, 0.12838740150573136, 0.15348945105730638, 0.08979167300101054, 0.13658703517496085, 0.09046859141015562, 0.1272093651706968, 0.09674997453411183, 0.08577503883698223, 0.11389552848562234, 0.10298811419713716, 0.9100570304288091, 0.8650780290797997, 0.859668076182671, 0.8869482702546851, 0.8560157490564119, 0.9216017685268375, 0.8998517016594284, 0.8689651335635249, 0.9184957130762181, 0.7015123297646813, 0.7102520226804928, 0.7019690706771227, 0.6959991168778101, 0.6670009962363415, 0.6748492909516519, 0.6957280108552255, 0.7051935150872982, 0.7084847304754787, 0.8523276954525127, 0.2249897385791051, 0.8640597986698355, 0.8546970458306095, 0.8706331677415797, 0.27446629127234023, 0.22981844986601785, 0.1767628142095493, 0.875659564198044, 0.6532794832355238, 0.5890132379432269, 0.6103490042583999, 0.6229708796533135, 0.6062325329119036, 0.5830294469304365, 0.5819496606839758, 0.6456221963765538, 0.6408789121834596, 0.598486398667587, 0.608737664907662, 0.5687180337889879, 0.6082418351639789, 0.6193443146601543, 0.6209346730437049, 0.6697623037777276, 0.5883201343850697, 0.6146670123502568, 0.4399864505009201, 0.3213942660449899, 0.39745477726829526, 0.5001172207533572, 0.2153150369545922, 0.15806405941090174, 0.3176256392465654, 0.22487253390818518, 0.3836166748547586, 0.26101345477283955, 0.1219888466400707, 0.16995504656780636, 0.10884477754811106, 0.051193274793515764, 0.1112319021784528, 0.2850646011675836, 0.44398266788438134, 0.187669860523898, 0.1614052940070324, 0.37318299614568884, 0.417072981866754, 0.5399274812268832, 0.11876772697975013, 0.2083989132383215, 0.2904755521103848, 0.36891048558132045, 0.3028851022425578, 0.44096389284984305, 0.41692446444650244, 0.42448800232347017, 0.47104334815310034, 0.47235326106551634, 0.5002085056490002, 0.44906946758707034, 0.30570750682710435, 0.41038121612032097, 0.7840473980293685, 0.7857511982756386, 0.7876382087357032, 0.7606829631699021, 0.77511087737276, 0.7945974949487931, 0.789733102959478, 0.8080458553341119, 0.804834879532619, 0.10354881661913551, 0.13639325826454585, 0.0931115047122093, 0.13962388312210938, 0.11034480841676886, 0.11436606958398154, 0.18284953988686659, 0.12848462802147076, 0.13550067036175895, 0.6808889758927935, 0.24345750247562048, 0.5846898304834421, 0.6454254857159989, 0.7194602582201914, 0.3424082799478514, 0.2155899546886595, 0.6034184010723077, 0.26531175589251443, 0.2847950820782069, 0.3119889672070576, 0.3256062861201995, 0.6232391443521406, 0.49131110469289174, 0.5111212902292157, 0.2671121910109736, 0.616133248734159, 0.4745249667350706, 0.2590178122042467, 0.44215597590515077, 0.25514169701419087, 0.29883631865866, 0.26387444887930966, 0.5424242662579319, 0.23634593413609728, 0.2812445215938817, 0.23800257934440483, 0.24531482490407208, 0.23138612326542152, 0.23417861052952116, 0.2369095192559253, 0.2866938865537544, 0.4567732478809784, 0.23893716335337867, 0.22683782597917912, 0.20825906744652556, 0.24506247284617944, 0.24621517817882044, 0.19502007631675378, 0.22068438731187312, 0.20452010790780684, 0.18207786424341676, 0.18581896691824973, 0.21856740580742196, 0.21892772457121568, 0.18568205741171284, 0.8758225289783393, 0.172390277072891, 0.9142488139987004, 0.19840431960568483, 0.17196230973311466, 0.8739299140684031, 0.8825240759023424, 0.8988261954376928, 0.9010022689352849, 0.2117261380892308, 0.8685287413667282, 0.20823257141203066, 0.8556886513600507, 0.8509778298948193, 0.16642324356799654, 0.16751122733955492, 0.8288515447623506, 0.18721954111235117, 0.17790166944720387, 0.20913667823948645, 0.1793451789083016, 0.1843910010926516, 0.17852385042389873, 0.25013628782133734, 0.1782781930598054, 0.18609137356672922, 0.08237200957526092, 0.1022574680259446, 0.10731727300130334, 0.09110304046588136, 0.09531046691456102, 0.10586189613624297, 0.08947837586969076, 0.1083695756899955, 0.10021782289284542]}, "mutation_prompt": null}
{"id": "aae8c0f4-0189-4269-aa20-59202f344aa8", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            # Adaptive population size\n            current_pop_size = int(self.population_size * dynamic_factor) + 10\n            pos = pos[:current_pop_size]\n            vel = vel[:current_pop_size]\n            pbest = pbest[:current_pop_size]\n            pbest_val = pbest_val[:current_pop_size]\n\n            for i in range(current_pop_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(current_pop_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover strategy\n                CR_dynamic = self.CR - 0.5 * chaos_val\n                trial = np.where(np.random.rand(self.dim) < CR_dynamic, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Enhance exploration by incorporating an adaptive population size and dynamic crossover strategy.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 40 is out of bounds for axis 0 with size 40').", "error": "IndexError('index 40 is out of bounds for axis 0 with size 40')", "parent_id": "4bdd8d27-9b15-4a08-8106-f99576267995", "metadata": {}, "mutation_prompt": null}
{"id": "ed98eef8-05f9-4f72-b904-07201f8c178e", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.03, 0.03)  # Reduced perturbation range\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.7 + 0.3 * chaos_val  # Adjusted adaptation range\n                c2_adaptive = 1.7 + 0.3 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.5 + 0.2 * chaos_val + np.random.uniform(-0.05, 0.05)  # Adjusted F_adaptive\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Enhance chaos-driven exploration by refining dynamic parameters and introducing a self-adaptive velocity adjustment.", "configspace": "", "generation": 35, "fitness": 0.3958384956483571, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.27.", "error": "", "parent_id": "4bdd8d27-9b15-4a08-8106-f99576267995", "metadata": {"aucs": [0.8101979271740705, 0.8308594688915412, 0.8343676669975508, 0.8223649905075113, 0.8069617618960553, 0.8406847306550476, 0.8250697366611011, 0.8190228625835551, 0.8250951523276934, 0.5981336156492305, 0.6023453751936175, 0.6322620627029336, 0.6267224732277991, 0.5989601304826222, 0.5775888638555479, 0.5888466890879119, 0.6505050468426328, 0.5762038400641889, 0.08760919186416571, 0.1400035025937948, 0.13832029088710585, 0.13678796297718177, 0.11186504117807339, 0.15641850841326177, 0.14015932367482198, 0.17984150220311002, 0.11859086899648807, 0.10517852717611165, 0.09544527555187199, 0.09480828943084163, 0.11170258248302634, 0.10844628760801112, 0.09352573775206163, 0.10816250247171755, 0.10091563265961145, 0.11123276683565586, 0.8978200009360877, 0.8527898571072061, 0.8612498484907983, 0.8921282282183998, 0.8725912204437171, 0.9207771411523011, 0.9029048519152594, 0.8721627927917268, 0.9242690761099527, 0.6479271355677716, 0.6161318749104899, 0.6434777525877601, 0.6642968586643521, 0.6156252116538561, 0.6066746104721923, 0.6097825102968163, 0.6229026257906662, 0.6366359473652334, 0.8721868413672749, 0.22702828711045353, 0.8383231549677367, 0.21205896051107165, 0.855696509010595, 0.21773389555511202, 0.551002416631116, 0.23060850633832675, 0.8490925326270308, 0.516713082859785, 0.13003700857293476, 0.5558388674974498, 0.6094641281168598, 0.6294815140924814, 0.5578302397112713, 0.5121768236740025, 0.6278780436578353, 0.48041312316414364, 0.4692593527532586, 0.5927597304269852, 0.4792491399649511, 0.6157416509318083, 0.603403726906459, 0.4988837385178716, 0.49591244904699894, 0.5211813039777328, 0.5798566652833473, 0.061093770137412906, 0.12149674234227148, 0.07922562619348772, 0.05988270410130203, 0.14258926825946727, 0.11128853703956687, 0.3638228870760497, 0.16264630826912585, 0.3037360718724156, 0.24939363662419356, 0.2532432388381176, 0.16475926416289766, 0.07335366861773651, 0.08262466703876958, 0.09773756354921659, 0.29883441725494786, 0.1270924709349016, 0.14102335150650802, 0.2437830119973835, 0.2888542536769887, 0.19864146112876524, 0.11620203882183344, 0.12515442271740362, 0.17607710398580945, 0.1799423207979982, 0.10213070334032182, 0.23295897574782842, 0.3268158207551003, 0.3379506229252288, 0.3101859449032629, 0.4168204187361614, 0.42457501056933944, 0.3970180176686533, 0.37347275869828844, 0.32273514473700593, 0.3734940941995445, 0.7652769508439947, 0.7731138090174668, 0.7649288142750771, 0.7679337017888496, 0.7647288567760138, 0.751337732619768, 0.7634760270758197, 0.7727739172659436, 0.7719658989075389, 0.12401092016606219, 0.08268146694693479, 0.11791603863986166, 0.11901333659707203, 0.10565952632688314, 0.13699326452623373, 0.11600750043791375, 0.12508929997182971, 0.12913862782233243, 0.5830400355242065, 0.563781922208594, 0.5751713855199404, 0.593398128084889, 0.6063508238291844, 0.553233493329029, 0.5905446962923576, 0.5346421322625732, 0.290203158232203, 0.29439490855464956, 0.5620072286605678, 0.5094942719716735, 0.5026980917216002, 0.5265829237442935, 0.48869841945434445, 0.5023349584644325, 0.5449730289078728, 0.524433669813516, 0.24517198096753257, 0.24990187986237555, 0.25538374807016584, 0.46399472060222047, 0.42760390398023373, 0.4664594306087848, 0.22584742400633018, 0.47693002864570877, 0.24824078009560746, 0.20450189844119004, 0.20112871501453244, 0.2183408527997205, 0.2276151946813375, 0.22436043943741713, 0.2205282247362973, 0.22647781583388138, 0.25577073631977587, 0.227291771100688, 0.1771031669327343, 0.20919298392047836, 0.17360876411938675, 0.20741800090064588, 0.20616039634852545, 0.18604305557981937, 0.20796209801094778, 0.1975394508479985, 0.18566097586141828, 0.1853726590985687, 0.18635213079113955, 0.18459327793730496, 0.8908240737638564, 0.19852564173202514, 0.17116976003629147, 0.17454867488150594, 0.16017214716253025, 0.8909829889959259, 0.8804671263201956, 0.21073466849418432, 0.8710279196137731, 0.2089154956933289, 0.20788715705026783, 0.8169069813167327, 0.81944458852073, 0.16704182176488447, 0.786057994962186, 0.18856965465810904, 0.18917164632557926, 0.17593934781133358, 0.18719915254188424, 0.1823924255862065, 0.20609195296210792, 0.18720833619892052, 0.1907983998445637, 0.1885426988532819, 0.08802871185005878, 0.1061494938083879, 0.08904700150992573, 0.09910034688645153, 0.09256483676434035, 0.09306751309383599, 0.08289428017929401, 0.10005635982683558, 0.09317864236900719]}, "mutation_prompt": null}
{"id": "7838d69d-59eb-41cc-be99-e683627d880c", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(self.population_size):\n                # Dynamic scaling of cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * np.cos(chaos_val * np.pi)\n                c2_adaptive = 1.5 + 0.5 * np.sin(chaos_val * np.pi)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # Adaptive crossover probability\n                adaptive_CR = self.CR - 0.1 * np.sin(chaos_val * np.pi)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < adaptive_CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce dynamic scaling of cognitive and social components, and enhance the diversity of trial vectors using adaptive crossover probability.", "configspace": "", "generation": 36, "fitness": 0.422400222942931, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.29.", "error": "", "parent_id": "4bdd8d27-9b15-4a08-8106-f99576267995", "metadata": {"aucs": [0.8746693075800115, 0.8726775005635887, 0.8756867925648864, 0.8645958375605486, 0.8644566065753844, 0.8707735691927521, 0.8643139900388979, 0.8612912443587836, 0.8674212518539587, 0.7338215466825028, 0.7351817996930581, 0.7377237542327821, 0.741233639678, 0.7276403634717609, 0.7310180389815917, 0.6958450815280784, 0.7178082293706104, 0.7052833916554921, 0.09358574037851086, 0.18200976167881855, 0.09405078560847802, 0.15671078623383305, 0.11406217562001786, 0.1545105655319552, 0.12155394618998527, 0.15533226605769124, 0.13115192676128373, 0.10753554316079661, 0.10220716406827413, 0.08993118447310722, 0.09799362505705211, 0.0627915255286482, 0.10578014575520212, 0.140268853814417, 0.08032059349721965, 0.1311641458578281, 0.9164034815408066, 0.8600324460127894, 0.8922470074912175, 0.8633059442273368, 0.8697922205811914, 0.9115542878877834, 0.8880051438683062, 0.8920695353758052, 0.9220599966265881, 0.7683017426792546, 0.7533371384127494, 0.7577581099757141, 0.7653608390460798, 0.7563047561774046, 0.7293972447964217, 0.7594799634458045, 0.7647470176078563, 0.7483806627802976, 0.8754227369160865, 0.2243106029968187, 0.2274144308589804, 0.21944069487984585, 0.8991006276014775, 0.21038681394721048, 0.17666364853019878, 0.17583902545696706, 0.17615057237909948, 0.6435800036833348, 0.13124221351678445, 0.6387074919115727, 0.649400903782411, 0.7004467560871628, 0.6772529353683391, 0.7115350871568251, 0.6778256385427508, 0.6802286969971085, 0.5834755552030098, 0.6456730051846604, 0.6187959738824274, 0.6542925228612515, 0.6556749465942122, 0.6618296776369159, 0.685084878773097, 0.6701343258763919, 0.6079880084825875, 0.279394312339563, 0.11148136327620795, 0.4780285737781851, 0.556874515083958, 0.31400634414316975, 0.11405392280238025, 0.43868261502942774, 0.16637546077994525, 0.53918592245469, 0.14491098620748366, 0.16513332460431907, 0.5388795092443478, 0.10132647550262974, 0.12279337846829419, 0.08255648408678229, 0.20289219172703943, 0.4279096224104598, 0.24679716854399025, 0.2216070597308364, 0.30181415488053753, 0.28666796481919554, 0.13832961552441758, 0.17723079640746087, 0.390056778405668, 0.33064967428321557, 0.23574150899116786, 0.2763397200805189, 0.4439744070971037, 0.3955708229835657, 0.498647848540702, 0.4550167564686337, 0.4682798617162369, 0.5030099327114604, 0.48634118694584416, 0.5528916400052638, 0.3194280913496671, 0.8242991015393131, 0.8161247236049968, 0.8240382969695497, 0.8067974316697597, 0.8229982112348139, 0.8301751747118095, 0.8196453702140022, 0.7892834964480353, 0.8039631167378487, 0.10193419304991491, 0.14170012056538306, 0.06728826597555693, 0.12341881622650985, 0.11416510174683658, 0.07799214423832423, 0.11510327945256671, 0.11925544464666948, 0.104722882542725, 0.19572323736273978, 0.27916290827612933, 0.664041655852508, 0.31636146810044585, 0.7504982704982298, 0.2205987984235539, 0.23392628892688638, 0.7150686525883605, 0.2539711070324647, 0.23631070866081005, 0.41565884664258756, 0.5214477541694134, 0.40724458008580167, 0.32451823125936785, 0.35342770747373786, 0.26644178591929346, 0.5185543679145459, 0.25721025253534535, 0.23880976364453577, 0.4272626232423381, 0.2734472063361081, 0.5310707802466335, 0.5412417796218429, 0.6268662258524293, 0.23296687062150034, 0.27631147398702216, 0.21167522200575173, 0.22864565359975209, 0.23844871169034687, 0.25630135368101625, 0.24848146799846493, 0.3075855455640659, 0.2531309059879352, 0.22404400946695857, 0.21841651568493803, 0.22703805498608476, 0.1976074390946746, 0.24708970971169042, 0.1783727551080332, 0.18934836052104298, 0.1833386361092204, 0.18624994964619912, 0.17814879909893444, 0.18668855301673293, 0.17253166727151925, 0.8989895376161369, 0.9031740707572056, 0.17276676996583706, 0.9172341923725027, 0.9122073482031107, 0.17189580419964567, 0.14158476202856762, 0.16670740116249927, 0.1568882060908645, 0.8974964339494067, 0.2112739435768386, 0.8741554626012105, 0.20929478267551138, 0.1112989771568571, 0.8552376648421975, 0.1674272266571517, 0.16715747389716484, 0.8341800640273918, 0.1935091605559599, 0.20463206855976956, 0.18014483295198946, 0.17757092833831645, 0.18113351487753315, 0.19711545332318192, 0.18929959782896266, 0.25773572835593594, 0.20446004635309634, 0.09593396561876855, 0.09717774199121865, 0.1008595751855883, 0.1018883400921351, 0.10544332910862486, 0.09978220764199575, 0.10195100447137795, 0.08211075764819875, 0.11281996797663285]}, "mutation_prompt": null}
{"id": "c45a36bd-2a2d-41f6-a08c-0939aa87938f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce a random inertia weight perturbation and enhance mutation diversity for improved exploration.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4bdd8d27-9b15-4a08-8106-f99576267995", "metadata": {"aucs": [0.8556421664289277, 0.8549696233133078, 0.8634204327586672, 0.8426241311396068, 0.8482992190584626, 0.8484945207451412, 0.8547857952763884, 0.8373418122836526, 0.8474807981274585, 0.6390210998587784, 0.6578765634234136, 0.6868178463251026, 0.6394448801041607, 0.6530236934125673, 0.6535716106592343, 0.5936924096470445, 0.62122690964524, 0.6075099482023336, 0.1803047279589316, 0.11419409618735155, 0.12709806376185884, 0.09855831090373335, 0.11042725545880006, 0.157034214083573, 0.11987477247266853, 0.15511043842505223, 0.12838740150573136, 0.15348945105730638, 0.08979167300101054, 0.13658703517496085, 0.09046859141015562, 0.1272093651706968, 0.09674997453411183, 0.08577503883698223, 0.11389552848562234, 0.10298811419713716, 0.9100570304288091, 0.8650780290797997, 0.859668076182671, 0.8869482702546851, 0.8560157490564119, 0.9216017685268375, 0.8998517016594284, 0.8689651335635249, 0.9184957130762181, 0.7015123297646813, 0.7102520226804928, 0.7019690706771227, 0.6959991168778101, 0.6670009962363415, 0.6748492909516519, 0.6957280108552255, 0.7051935150872982, 0.7084847304754787, 0.8523276954525127, 0.2249897385791051, 0.8640597986698355, 0.8546970458306095, 0.8706331677415797, 0.27446629127234023, 0.22981844986601785, 0.1767628142095493, 0.875659564198044, 0.6532794832355238, 0.5890132379432269, 0.6103490042583999, 0.6229708796533135, 0.6062325329119036, 0.5830294469304365, 0.5819496606839758, 0.6456221963765538, 0.6408789121834596, 0.598486398667587, 0.608737664907662, 0.5687180337889879, 0.6082418351639789, 0.6193443146601543, 0.6209346730437049, 0.6697623037777276, 0.5883201343850697, 0.6146670123502568, 0.4399864505009201, 0.3213942660449899, 0.39745477726829526, 0.5001172207533572, 0.2153150369545922, 0.15806405941090174, 0.3176256392465654, 0.22487253390818518, 0.3836166748547586, 0.26101345477283955, 0.1219888466400707, 0.16995504656780636, 0.10884477754811106, 0.051193274793515764, 0.1112319021784528, 0.2850646011675836, 0.44398266788438134, 0.187669860523898, 0.1614052940070324, 0.37318299614568884, 0.417072981866754, 0.5399274812268832, 0.11876772697975013, 0.2083989132383215, 0.2904755521103848, 0.36891048558132045, 0.3028851022425578, 0.44096389284984305, 0.41692446444650244, 0.42448800232347017, 0.47104334815310034, 0.47235326106551634, 0.5002085056490002, 0.44906946758707034, 0.30570750682710435, 0.41038121612032097, 0.7840473980293685, 0.7857511982756386, 0.7876382087357032, 0.7606829631699021, 0.77511087737276, 0.7945974949487931, 0.789733102959478, 0.8080458553341119, 0.804834879532619, 0.10354881661913551, 0.13639325826454585, 0.0931115047122093, 0.13962388312210938, 0.11034480841676886, 0.11436606958398154, 0.18284953988686659, 0.12848462802147076, 0.13550067036175895, 0.6808889758927935, 0.24345750247562048, 0.5846898304834421, 0.6454254857159989, 0.7194602582201914, 0.3424082799478514, 0.2155899546886595, 0.6034184010723077, 0.26531175589251443, 0.2847950820782069, 0.3119889672070576, 0.3256062861201995, 0.6232391443521406, 0.49131110469289174, 0.5111212902292157, 0.2671121910109736, 0.616133248734159, 0.4745249667350706, 0.2590178122042467, 0.44215597590515077, 0.25514169701419087, 0.29883631865866, 0.26387444887930966, 0.5424242662579319, 0.23634593413609728, 0.2812445215938817, 0.23800257934440483, 0.24531482490407208, 0.23138612326542152, 0.23417861052952116, 0.2369095192559253, 0.2866938865537544, 0.4567732478809784, 0.23893716335337867, 0.22683782597917912, 0.20825906744652556, 0.24506247284617944, 0.24621517817882044, 0.19502007631675378, 0.22068438731187312, 0.20452010790780684, 0.18207786424341676, 0.18581896691824973, 0.21856740580742196, 0.21892772457121568, 0.18568205741171284, 0.8758225289783393, 0.172390277072891, 0.9142488139987004, 0.19840431960568483, 0.17196230973311466, 0.8739299140684031, 0.8825240759023424, 0.8988261954376928, 0.9010022689352849, 0.2117261380892308, 0.8685287413667282, 0.20823257141203066, 0.8556886513600507, 0.8509778298948193, 0.16642324356799654, 0.16751122733955492, 0.8288515447623506, 0.18721954111235117, 0.17790166944720387, 0.20913667823948645, 0.1793451789083016, 0.1843910010926516, 0.17852385042389873, 0.25013628782133734, 0.1782781930598054, 0.18609137356672922, 0.08237200957526092, 0.1022574680259446, 0.10731727300130334, 0.09110304046588136, 0.09531046691456102, 0.10586189613624297, 0.08947837586969076, 0.1083695756899955, 0.10021782289284542]}, "mutation_prompt": null}
{"id": "53df653b-3b20-44d4-981f-1c17871d9171", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7\n        while eval_count < self.budget:\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(self.population_size):\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel_max_adaptive = self.vel_max * (1.0 + 0.5 * chaos_val)  # Adaptive velocity clamping\n                vel[i] = np.clip(vel[i], -vel_max_adaptive, vel_max_adaptive)\n                pos[i] = pos[i] + vel[i]\n\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce adaptive velocity clamping and enhanced chaotic factor to balance exploration and exploitation more effectively.", "configspace": "", "generation": 38, "fitness": 0.43443379524627945, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.28.", "error": "", "parent_id": "4bdd8d27-9b15-4a08-8106-f99576267995", "metadata": {"aucs": [0.8433732951659264, 0.8490001944873433, 0.8617628860604889, 0.8342118054914841, 0.8519472869221478, 0.8438843818907454, 0.8356860816861114, 0.8396084968809883, 0.8519646853420981, 0.6828437200789049, 0.6285790758330391, 0.6781885052685251, 0.6398722877228605, 0.6323119058374276, 0.6577121379263602, 0.6471345096757221, 0.637147900718557, 0.6376503106590758, 0.09978419112517767, 0.13837408359528158, 0.10631796917071756, 0.15638469102848462, 0.11286662393803781, 0.10835334136265007, 0.11202676954111634, 0.13986715930081395, 0.10959767212837301, 0.10707854089110391, 0.11186758441161637, 0.0887535303691046, 0.13952978157873508, 0.12873801466890877, 0.09016582816507013, 0.09221638624122575, 0.12741749016425752, 0.1076905792764079, 0.91201683860336, 0.8852825509890448, 0.8894021668539461, 0.90142327494794, 0.8873854331943842, 0.9288823877800593, 0.9082075269927118, 0.9072971781304551, 0.9235473333246444, 0.7049540829943747, 0.6896711544667136, 0.6745468351268091, 0.7010822032677695, 0.6930358611385967, 0.685984985135392, 0.7003493313928961, 0.672578355601178, 0.6864316230167383, 0.22907232655076837, 0.8646672332656422, 0.22648433065992724, 0.8407532002174554, 0.8903607232240194, 0.21097200408498873, 0.23113450608198582, 0.23258106056891426, 0.8778380818115372, 0.13240383635322128, 0.6568141043874391, 0.6595877052933306, 0.6769843145280827, 0.6891321561107082, 0.5718072946267653, 0.6549507227544105, 0.6270576808898053, 0.6116183914885336, 0.5418962122357641, 0.5626700160900949, 0.6225622136043397, 0.5926004571192105, 0.5972653737439807, 0.5307618924742492, 0.6456282491641276, 0.5572512337839808, 0.6564971374041033, 0.4758073303151892, 0.32234579632807703, 0.12551542137145189, 0.06758897199201697, 0.38376980393324134, 0.2490452137033663, 0.559048259557704, 0.2970238128238154, 0.4897049016816313, 0.18783418359471626, 0.24694250972942577, 0.3919139350153238, 0.17642517158152893, 0.05801782457559601, 0.10278024867026603, 0.2560919514097233, 0.5370351389182644, 0.2585089639107737, 0.27614491422079246, 0.44422245844297237, 0.386112900102464, 0.16339407136361295, 0.12675404024505532, 0.26192605007995906, 0.37941788965816203, 0.19666392216103945, 0.19979125174442713, 0.42329958907110743, 0.45517114909449186, 0.43050132603437097, 0.48532064014335574, 0.4881079552116607, 0.47728890639423904, 0.46808782960980355, 0.4324050512355211, 0.3174364406663365, 0.7822918431856911, 0.7836921178402104, 0.8008010432623918, 0.8168952094918419, 0.768338955064537, 0.8064747299139031, 0.8081527924229702, 0.7771272224703359, 0.8075256426816702, 0.09339548393140396, 0.11548615043049049, 0.07609316667700727, 0.1795995757094606, 0.12595040583492123, 0.11357326968180692, 0.1118140522368194, 0.17674956393267915, 0.11274029626073279, 0.622390508099356, 0.66210310480107, 0.6967870384893153, 0.6945019791031395, 0.2136063373221535, 0.6614002159364136, 0.660271784422418, 0.6082654880432965, 0.2238501217487412, 0.47185485832678575, 0.5957034879329499, 0.5330522039432457, 0.39900830085112116, 0.6039165380549858, 0.5297292477563773, 0.26496407381912046, 0.6194923680455796, 0.27384197432624735, 0.23561035294287758, 0.253317081442065, 0.23673400587066307, 0.2736418197379371, 0.39862652626793893, 0.41032939793830125, 0.23849894109511882, 0.5187775672542012, 0.2777530036043815, 0.23297155388489155, 0.21964650599337332, 0.2968326796146389, 0.2339025284694196, 0.24432033208341286, 0.213344282265576, 0.21926828914735919, 0.19758809461113336, 0.22870549769703752, 0.17919102483186455, 0.20724702973623765, 0.18571044847025941, 0.20524994716517053, 0.19877612492704388, 0.18045665050723514, 0.182856945156453, 0.20505718598890266, 0.2178847864297856, 0.8895468477995354, 0.1866644890343403, 0.18516237315814732, 0.8987406708355292, 0.19922784848604314, 0.8534737108489294, 0.8867751889695911, 0.18593940317981195, 0.906885832316303, 0.8968918923645793, 0.8884402213982843, 0.8902705956579563, 0.20980177346211348, 0.20918640292946422, 0.2099639694538381, 0.16669684315646482, 0.8000908877184612, 0.8714370444316661, 0.19698196313669247, 0.19301226002441707, 0.18768681675247811, 0.1789525302123124, 0.19351961423136987, 0.19095401000284662, 0.18725574180604654, 0.1836710631091787, 0.18629164734328374, 0.09568501657670836, 0.11012180844433639, 0.08608917581866249, 0.0867933398977686, 0.09588099051174581, 0.08759088144562044, 0.09711683910140423, 0.08933498255377181, 0.10103823117142752]}, "mutation_prompt": null}
{"id": "687bbf22-02f8-4157-8c92-b88674d7a7ca", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce a random inertia weight perturbation and enhance mutation diversity for improved exploration.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4bdd8d27-9b15-4a08-8106-f99576267995", "metadata": {"aucs": [0.8556421664289277, 0.8549696233133078, 0.8634204327586672, 0.8426241311396068, 0.8482992190584626, 0.8484945207451412, 0.8547857952763884, 0.8373418122836526, 0.8474807981274585, 0.6390210998587784, 0.6578765634234136, 0.6868178463251026, 0.6394448801041607, 0.6530236934125673, 0.6535716106592343, 0.5936924096470445, 0.62122690964524, 0.6075099482023336, 0.1803047279589316, 0.11419409618735155, 0.12709806376185884, 0.09855831090373335, 0.11042725545880006, 0.157034214083573, 0.11987477247266853, 0.15511043842505223, 0.12838740150573136, 0.15348945105730638, 0.08979167300101054, 0.13658703517496085, 0.09046859141015562, 0.1272093651706968, 0.09674997453411183, 0.08577503883698223, 0.11389552848562234, 0.10298811419713716, 0.9100570304288091, 0.8650780290797997, 0.859668076182671, 0.8869482702546851, 0.8560157490564119, 0.9216017685268375, 0.8998517016594284, 0.8689651335635249, 0.9184957130762181, 0.7015123297646813, 0.7102520226804928, 0.7019690706771227, 0.6959991168778101, 0.6670009962363415, 0.6748492909516519, 0.6957280108552255, 0.7051935150872982, 0.7084847304754787, 0.8523276954525127, 0.2249897385791051, 0.8640597986698355, 0.8546970458306095, 0.8706331677415797, 0.27446629127234023, 0.22981844986601785, 0.1767628142095493, 0.875659564198044, 0.6532794832355238, 0.5890132379432269, 0.6103490042583999, 0.6229708796533135, 0.6062325329119036, 0.5830294469304365, 0.5819496606839758, 0.6456221963765538, 0.6408789121834596, 0.598486398667587, 0.608737664907662, 0.5687180337889879, 0.6082418351639789, 0.6193443146601543, 0.6209346730437049, 0.6697623037777276, 0.5883201343850697, 0.6146670123502568, 0.4399864505009201, 0.3213942660449899, 0.39745477726829526, 0.5001172207533572, 0.2153150369545922, 0.15806405941090174, 0.3176256392465654, 0.22487253390818518, 0.3836166748547586, 0.26101345477283955, 0.1219888466400707, 0.16995504656780636, 0.10884477754811106, 0.051193274793515764, 0.1112319021784528, 0.2850646011675836, 0.44398266788438134, 0.187669860523898, 0.1614052940070324, 0.37318299614568884, 0.417072981866754, 0.5399274812268832, 0.11876772697975013, 0.2083989132383215, 0.2904755521103848, 0.36891048558132045, 0.3028851022425578, 0.44096389284984305, 0.41692446444650244, 0.42448800232347017, 0.47104334815310034, 0.47235326106551634, 0.5002085056490002, 0.44906946758707034, 0.30570750682710435, 0.41038121612032097, 0.7840473980293685, 0.7857511982756386, 0.7876382087357032, 0.7606829631699021, 0.77511087737276, 0.7945974949487931, 0.789733102959478, 0.8080458553341119, 0.804834879532619, 0.10354881661913551, 0.13639325826454585, 0.0931115047122093, 0.13962388312210938, 0.11034480841676886, 0.11436606958398154, 0.18284953988686659, 0.12848462802147076, 0.13550067036175895, 0.6808889758927935, 0.24345750247562048, 0.5846898304834421, 0.6454254857159989, 0.7194602582201914, 0.3424082799478514, 0.2155899546886595, 0.6034184010723077, 0.26531175589251443, 0.2847950820782069, 0.3119889672070576, 0.3256062861201995, 0.6232391443521406, 0.49131110469289174, 0.5111212902292157, 0.2671121910109736, 0.616133248734159, 0.4745249667350706, 0.2590178122042467, 0.44215597590515077, 0.25514169701419087, 0.29883631865866, 0.26387444887930966, 0.5424242662579319, 0.23634593413609728, 0.2812445215938817, 0.23800257934440483, 0.24531482490407208, 0.23138612326542152, 0.23417861052952116, 0.2369095192559253, 0.2866938865537544, 0.4567732478809784, 0.23893716335337867, 0.22683782597917912, 0.20825906744652556, 0.24506247284617944, 0.24621517817882044, 0.19502007631675378, 0.22068438731187312, 0.20452010790780684, 0.18207786424341676, 0.18581896691824973, 0.21856740580742196, 0.21892772457121568, 0.18568205741171284, 0.8758225289783393, 0.172390277072891, 0.9142488139987004, 0.19840431960568483, 0.17196230973311466, 0.8739299140684031, 0.8825240759023424, 0.8988261954376928, 0.9010022689352849, 0.2117261380892308, 0.8685287413667282, 0.20823257141203066, 0.8556886513600507, 0.8509778298948193, 0.16642324356799654, 0.16751122733955492, 0.8288515447623506, 0.18721954111235117, 0.17790166944720387, 0.20913667823948645, 0.1793451789083016, 0.1843910010926516, 0.17852385042389873, 0.25013628782133734, 0.1782781930598054, 0.18609137356672922, 0.08237200957526092, 0.1022574680259446, 0.10731727300130334, 0.09110304046588136, 0.09531046691456102, 0.10586189613624297, 0.08947837586969076, 0.1083695756899955, 0.10021782289284542]}, "mutation_prompt": null}
{"id": "f5aef8eb-a0be-4598-8a42-3c83f2ef8259", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce a random inertia weight perturbation and enhance mutation diversity for improved exploration.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4bdd8d27-9b15-4a08-8106-f99576267995", "metadata": {"aucs": [0.8556421664289277, 0.8549696233133078, 0.8634204327586672, 0.8426241311396068, 0.8482992190584626, 0.8484945207451412, 0.8547857952763884, 0.8373418122836526, 0.8474807981274585, 0.6390210998587784, 0.6578765634234136, 0.6868178463251026, 0.6394448801041607, 0.6530236934125673, 0.6535716106592343, 0.5936924096470445, 0.62122690964524, 0.6075099482023336, 0.1803047279589316, 0.11419409618735155, 0.12709806376185884, 0.09855831090373335, 0.11042725545880006, 0.157034214083573, 0.11987477247266853, 0.15511043842505223, 0.12838740150573136, 0.15348945105730638, 0.08979167300101054, 0.13658703517496085, 0.09046859141015562, 0.1272093651706968, 0.09674997453411183, 0.08577503883698223, 0.11389552848562234, 0.10298811419713716, 0.9100570304288091, 0.8650780290797997, 0.859668076182671, 0.8869482702546851, 0.8560157490564119, 0.9216017685268375, 0.8998517016594284, 0.8689651335635249, 0.9184957130762181, 0.7015123297646813, 0.7102520226804928, 0.7019690706771227, 0.6959991168778101, 0.6670009962363415, 0.6748492909516519, 0.6957280108552255, 0.7051935150872982, 0.7084847304754787, 0.8523276954525127, 0.2249897385791051, 0.8640597986698355, 0.8546970458306095, 0.8706331677415797, 0.27446629127234023, 0.22981844986601785, 0.1767628142095493, 0.875659564198044, 0.6532794832355238, 0.5890132379432269, 0.6103490042583999, 0.6229708796533135, 0.6062325329119036, 0.5830294469304365, 0.5819496606839758, 0.6456221963765538, 0.6408789121834596, 0.598486398667587, 0.608737664907662, 0.5687180337889879, 0.6082418351639789, 0.6193443146601543, 0.6209346730437049, 0.6697623037777276, 0.5883201343850697, 0.6146670123502568, 0.4399864505009201, 0.3213942660449899, 0.39745477726829526, 0.5001172207533572, 0.2153150369545922, 0.15806405941090174, 0.3176256392465654, 0.22487253390818518, 0.3836166748547586, 0.26101345477283955, 0.1219888466400707, 0.16995504656780636, 0.10884477754811106, 0.051193274793515764, 0.1112319021784528, 0.2850646011675836, 0.44398266788438134, 0.187669860523898, 0.1614052940070324, 0.37318299614568884, 0.417072981866754, 0.5399274812268832, 0.11876772697975013, 0.2083989132383215, 0.2904755521103848, 0.36891048558132045, 0.3028851022425578, 0.44096389284984305, 0.41692446444650244, 0.42448800232347017, 0.47104334815310034, 0.47235326106551634, 0.5002085056490002, 0.44906946758707034, 0.30570750682710435, 0.41038121612032097, 0.7840473980293685, 0.7857511982756386, 0.7876382087357032, 0.7606829631699021, 0.77511087737276, 0.7945974949487931, 0.789733102959478, 0.8080458553341119, 0.804834879532619, 0.10354881661913551, 0.13639325826454585, 0.0931115047122093, 0.13962388312210938, 0.11034480841676886, 0.11436606958398154, 0.18284953988686659, 0.12848462802147076, 0.13550067036175895, 0.6808889758927935, 0.24345750247562048, 0.5846898304834421, 0.6454254857159989, 0.7194602582201914, 0.3424082799478514, 0.2155899546886595, 0.6034184010723077, 0.26531175589251443, 0.2847950820782069, 0.3119889672070576, 0.3256062861201995, 0.6232391443521406, 0.49131110469289174, 0.5111212902292157, 0.2671121910109736, 0.616133248734159, 0.4745249667350706, 0.2590178122042467, 0.44215597590515077, 0.25514169701419087, 0.29883631865866, 0.26387444887930966, 0.5424242662579319, 0.23634593413609728, 0.2812445215938817, 0.23800257934440483, 0.24531482490407208, 0.23138612326542152, 0.23417861052952116, 0.2369095192559253, 0.2866938865537544, 0.4567732478809784, 0.23893716335337867, 0.22683782597917912, 0.20825906744652556, 0.24506247284617944, 0.24621517817882044, 0.19502007631675378, 0.22068438731187312, 0.20452010790780684, 0.18207786424341676, 0.18581896691824973, 0.21856740580742196, 0.21892772457121568, 0.18568205741171284, 0.8758225289783393, 0.172390277072891, 0.9142488139987004, 0.19840431960568483, 0.17196230973311466, 0.8739299140684031, 0.8825240759023424, 0.8988261954376928, 0.9010022689352849, 0.2117261380892308, 0.8685287413667282, 0.20823257141203066, 0.8556886513600507, 0.8509778298948193, 0.16642324356799654, 0.16751122733955492, 0.8288515447623506, 0.18721954111235117, 0.17790166944720387, 0.20913667823948645, 0.1793451789083016, 0.1843910010926516, 0.17852385042389873, 0.25013628782133734, 0.1782781930598054, 0.18609137356672922, 0.08237200957526092, 0.1022574680259446, 0.10731727300130334, 0.09110304046588136, 0.09531046691456102, 0.10586189613624297, 0.08947837586969076, 0.1083695756899955, 0.10021782289284542]}, "mutation_prompt": null}
{"id": "78f30c48-89ce-4438-b5e3-42fe12ad806b", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce a random inertia weight perturbation and enhance mutation diversity for improved exploration.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4bdd8d27-9b15-4a08-8106-f99576267995", "metadata": {"aucs": [0.8556421664289277, 0.8549696233133078, 0.8634204327586672, 0.8426241311396068, 0.8482992190584626, 0.8484945207451412, 0.8547857952763884, 0.8373418122836526, 0.8474807981274585, 0.6390210998587784, 0.6578765634234136, 0.6868178463251026, 0.6394448801041607, 0.6530236934125673, 0.6535716106592343, 0.5936924096470445, 0.62122690964524, 0.6075099482023336, 0.1803047279589316, 0.11419409618735155, 0.12709806376185884, 0.09855831090373335, 0.11042725545880006, 0.157034214083573, 0.11987477247266853, 0.15511043842505223, 0.12838740150573136, 0.15348945105730638, 0.08979167300101054, 0.13658703517496085, 0.09046859141015562, 0.1272093651706968, 0.09674997453411183, 0.08577503883698223, 0.11389552848562234, 0.10298811419713716, 0.9100570304288091, 0.8650780290797997, 0.859668076182671, 0.8869482702546851, 0.8560157490564119, 0.9216017685268375, 0.8998517016594284, 0.8689651335635249, 0.9184957130762181, 0.7015123297646813, 0.7102520226804928, 0.7019690706771227, 0.6959991168778101, 0.6670009962363415, 0.6748492909516519, 0.6957280108552255, 0.7051935150872982, 0.7084847304754787, 0.8523276954525127, 0.2249897385791051, 0.8640597986698355, 0.8546970458306095, 0.8706331677415797, 0.27446629127234023, 0.22981844986601785, 0.1767628142095493, 0.875659564198044, 0.6532794832355238, 0.5890132379432269, 0.6103490042583999, 0.6229708796533135, 0.6062325329119036, 0.5830294469304365, 0.5819496606839758, 0.6456221963765538, 0.6408789121834596, 0.598486398667587, 0.608737664907662, 0.5687180337889879, 0.6082418351639789, 0.6193443146601543, 0.6209346730437049, 0.6697623037777276, 0.5883201343850697, 0.6146670123502568, 0.4399864505009201, 0.3213942660449899, 0.39745477726829526, 0.5001172207533572, 0.2153150369545922, 0.15806405941090174, 0.3176256392465654, 0.22487253390818518, 0.3836166748547586, 0.26101345477283955, 0.1219888466400707, 0.16995504656780636, 0.10884477754811106, 0.051193274793515764, 0.1112319021784528, 0.2850646011675836, 0.44398266788438134, 0.187669860523898, 0.1614052940070324, 0.37318299614568884, 0.417072981866754, 0.5399274812268832, 0.11876772697975013, 0.2083989132383215, 0.2904755521103848, 0.36891048558132045, 0.3028851022425578, 0.44096389284984305, 0.41692446444650244, 0.42448800232347017, 0.47104334815310034, 0.47235326106551634, 0.5002085056490002, 0.44906946758707034, 0.30570750682710435, 0.41038121612032097, 0.7840473980293685, 0.7857511982756386, 0.7876382087357032, 0.7606829631699021, 0.77511087737276, 0.7945974949487931, 0.789733102959478, 0.8080458553341119, 0.804834879532619, 0.10354881661913551, 0.13639325826454585, 0.0931115047122093, 0.13962388312210938, 0.11034480841676886, 0.11436606958398154, 0.18284953988686659, 0.12848462802147076, 0.13550067036175895, 0.6808889758927935, 0.24345750247562048, 0.5846898304834421, 0.6454254857159989, 0.7194602582201914, 0.3424082799478514, 0.2155899546886595, 0.6034184010723077, 0.26531175589251443, 0.2847950820782069, 0.3119889672070576, 0.3256062861201995, 0.6232391443521406, 0.49131110469289174, 0.5111212902292157, 0.2671121910109736, 0.616133248734159, 0.4745249667350706, 0.2590178122042467, 0.44215597590515077, 0.25514169701419087, 0.29883631865866, 0.26387444887930966, 0.5424242662579319, 0.23634593413609728, 0.2812445215938817, 0.23800257934440483, 0.24531482490407208, 0.23138612326542152, 0.23417861052952116, 0.2369095192559253, 0.2866938865537544, 0.4567732478809784, 0.23893716335337867, 0.22683782597917912, 0.20825906744652556, 0.24506247284617944, 0.24621517817882044, 0.19502007631675378, 0.22068438731187312, 0.20452010790780684, 0.18207786424341676, 0.18581896691824973, 0.21856740580742196, 0.21892772457121568, 0.18568205741171284, 0.8758225289783393, 0.172390277072891, 0.9142488139987004, 0.19840431960568483, 0.17196230973311466, 0.8739299140684031, 0.8825240759023424, 0.8988261954376928, 0.9010022689352849, 0.2117261380892308, 0.8685287413667282, 0.20823257141203066, 0.8556886513600507, 0.8509778298948193, 0.16642324356799654, 0.16751122733955492, 0.8288515447623506, 0.18721954111235117, 0.17790166944720387, 0.20913667823948645, 0.1793451789083016, 0.1843910010926516, 0.17852385042389873, 0.25013628782133734, 0.1782781930598054, 0.18609137356672922, 0.08237200957526092, 0.1022574680259446, 0.10731727300130334, 0.09110304046588136, 0.09531046691456102, 0.10586189613624297, 0.08947837586969076, 0.1083695756899955, 0.10021782289284542]}, "mutation_prompt": null}
{"id": "7dd89cf5-faab-4e0c-9cf9-e4a237ba3b80", "solution": "import numpy as np\n\nclass HybridPSO_DE_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce dynamic boundary constraints\n                adaptive_lb = self.lb + 0.1 * eval_count / self.budget\n                adaptive_ub = self.ub - 0.1 * eval_count / self.budget\n                pos[i] = np.clip(pos[i], adaptive_lb, adaptive_ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, adaptive_lb, adaptive_ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE_Improved", "description": "Integrate adaptive inertia weight oscillations and dynamic constraints for enhanced search capabilities.", "configspace": "", "generation": 42, "fitness": 0.4019096998256348, "feedback": "The algorithm HybridPSO_DE_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.26.", "error": "", "parent_id": "4bdd8d27-9b15-4a08-8106-f99576267995", "metadata": {"aucs": [0.8573745323835958, 0.8534196933094317, 0.8633990463289284, 0.845539701968264, 0.8456018817989742, 0.8595856979296548, 0.8385367153469908, 0.8418187195572757, 0.8426110740093391, 0.6396472135545435, 0.6811171537564193, 0.687064626617176, 0.6653187219901564, 0.6410511465130204, 0.6563716008928945, 0.6178814020765793, 0.5991650678482352, 0.6283328993865915, 0.18030443948014652, 0.11411631041012826, 0.13678276260357414, 0.09499493838122541, 0.1104365775345526, 0.1570297439887749, 0.11386710555152624, 0.1474963159831103, 0.12069427688670553, 0.15338516155288284, 0.09241698225975348, 0.136587051412015, 0.09459224488368423, 0.13809886667374427, 0.0967527804592837, 0.09000009269203146, 0.11392797433808233, 0.10298808821680738, 0.2455823105515298, 0.23061376630431107, 0.23053581953375601, 0.23643602760225702, 0.22829579399938116, 0.253704290310775, 0.2438218604731024, 0.2299295571262161, 0.2562736386772011, 0.6954402741376128, 0.6823019513131805, 0.6840028490930563, 0.7184255720744459, 0.6978098339695622, 0.6725874949903954, 0.7100319113994146, 0.6851647369438538, 0.6871527804067541, 0.8763105122809522, 0.2249897385791051, 0.8499050523216258, 0.861671834741381, 0.8831928359166874, 0.21753558913992388, 0.17624608692319765, 0.1767628142095493, 0.8839658019970378, 0.5865545842961732, 0.6175128738739448, 0.6122003761058821, 0.6438156347292978, 0.6442365493763504, 0.5842012176018977, 0.6186230309447331, 0.6347603384801096, 0.651194022521296, 0.598486398667587, 0.6226123400085681, 0.5088328801730144, 0.6132241461173187, 0.631145234224123, 0.6431927578038181, 0.6697623037777276, 0.5862701454819876, 0.5836762823955837, 0.20777113906162525, 0.3785196496620332, 0.43613338682120506, 0.36934238325012003, 0.3745653120852196, 0.15939985667994605, 0.2627429541515547, 0.25750170751161006, 0.42248240443235974, 0.2506641318097709, 0.1007564167188073, 0.1625072549839247, 0.17945486115445364, 0.06818917677614444, 0.1119747593642243, 0.3287890116523341, 0.29693372452363276, 0.24644836866875752, 0.18068461957594462, 0.2842432076135416, 0.3420607778811414, 0.4350481939575165, 0.0730638978461291, 0.24646738992154849, 0.31971826618770993, 0.3172185372180977, 0.24764826831403164, 0.43902682280702043, 0.4426604278100216, 0.40869789189017813, 0.4602776671079897, 0.4800178227938888, 0.5206785222011048, 0.4710068704136253, 0.33091843571065627, 0.36923135025826326, 0.7904671676678054, 0.7924861097105381, 0.7822537417968864, 0.7786364466055794, 0.7741765896216808, 0.7732795203349329, 0.8017557674729029, 0.7993196575552799, 0.8174741536093618, 0.11714777837450807, 0.15291509649279456, 0.09189419998887738, 0.13959237301447136, 0.11033666934346142, 0.15432296696652015, 0.15605548445291884, 0.1284234083198741, 0.13543752495328332, 0.5797743147226139, 0.27025369065596005, 0.6469587187152191, 0.7049172970833317, 0.704126104440912, 0.16929088054233998, 0.2504402710057626, 0.43817240537342983, 0.2585988936600415, 0.2826370690845531, 0.2962877884967997, 0.5013300827826599, 0.5999149227051237, 0.3194630931235517, 0.5111212902292157, 0.267151029588646, 0.537094983989169, 0.2724565334231188, 0.2338213119999003, 0.30989454951233153, 0.2448787409998906, 0.29936706733655183, 0.26387444887930966, 0.35468724539574525, 0.22179092904251652, 0.27644520115776905, 0.24704591053055425, 0.2535192895817133, 0.5363963798614515, 0.2520488999467284, 0.23996816644813102, 0.23158397711828527, 0.24263312108283275, 0.2727128459677318, 0.23705422603832205, 0.22669305346580804, 0.24448744285069524, 0.24621246575248046, 0.19501887788762362, 0.22068438785984712, 0.20452402316179386, 0.18207786424341676, 0.18581591311075674, 0.2193303089580977, 0.21876251034664496, 0.1856822076771536, 0.8814991326980808, 0.17239051745152734, 0.9150807801513619, 0.1984011905023898, 0.17196209742046997, 0.8787255285934512, 0.8819389906973761, 0.9026517127181237, 0.9103164191305602, 0.21170743015644766, 0.8691219655595454, 0.20820875881038503, 0.849058289827069, 0.8490802465015257, 0.16642142030934426, 0.16751112127957635, 0.8141232736146508, 0.1780751524569687, 0.19452368932067776, 0.20774017564370506, 0.1819315521112208, 0.17826236997695144, 0.18784463517691674, 0.18477039641781456, 0.1938522520214807, 0.19087463076950972, 0.09938786593544502, 0.0931663662738349, 0.13573946348709176, 0.08558635125548919, 0.09035258932094403, 0.08783415500111624, 0.08688113581904566, 0.10807949344256429, 0.09627269137833205]}, "mutation_prompt": null}
{"id": "4b028355-01ba-4f5b-a488-b169fd5c9bfa", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.05, 0.05)  # Adaptive scaling\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n                \n                opposite = self.lb + self.ub - pos[i]  # Opposition-based learning\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, opposite)\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce adaptive scaling factor in mutation and use opposition-based learning to enhance diversity and convergence.", "configspace": "", "generation": 43, "fitness": 0.415250716238083, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.27.", "error": "", "parent_id": "4bdd8d27-9b15-4a08-8106-f99576267995", "metadata": {"aucs": [0.826791822423212, 0.8221797922384297, 0.8317443619768381, 0.7937840822976422, 0.7901391646363581, 0.7998378604014691, 0.8020483055311441, 0.8037752333264911, 0.823372971800269, 0.5987239746883732, 0.6369089575638236, 0.6115093794326671, 0.6243317774968609, 0.6215628402271802, 0.595375875453952, 0.6187897273093118, 0.5709902319302146, 0.641396054544717, 0.11023938838901925, 0.12915765090690945, 0.08622517794327833, 0.1093630316492552, 0.1188239675801055, 0.11036257295037866, 0.18045390489608015, 0.12343403395526598, 0.11844745578698834, 0.10585935653024425, 0.10514752500859481, 0.07986993205010406, 0.10528125710435776, 0.10362688765254391, 0.10450570913367119, 0.14858283492105384, 0.11169288417404766, 0.10576681471929805, 0.8701042882793902, 0.8851784046077841, 0.8239763064492402, 0.8378136611364942, 0.827782125625191, 0.8412096888084327, 0.8769457376540403, 0.8646190602779016, 0.8861410604851061, 0.6356219670854654, 0.6128417144502551, 0.5998098572676451, 0.6454350205991897, 0.6392062051773078, 0.6187076199447525, 0.618876556805148, 0.6280291392741733, 0.5980769222425153, 0.8935737208146503, 0.8573030979857639, 0.22656776482903307, 0.8451986362323459, 0.868045542748028, 0.27467693119270886, 0.17764638662771026, 0.2300969931870609, 0.23163446930012777, 0.657670609486948, 0.6897714864640627, 0.46578415610378265, 0.12722725122450684, 0.6872254405294492, 0.3789856647402693, 0.6310459520036138, 0.6233391205858985, 0.5834662255878907, 0.6272506820883481, 0.13215097092118144, 0.4913531186694883, 0.5396777421771777, 0.5627498880273363, 0.5857901683230168, 0.5826529646821219, 0.597628687979797, 0.5208892751383875, 0.25196613301451276, 0.28493142034490315, 0.25565706601095073, 0.38339429413361314, 0.15887431185232292, 0.11520832647720403, 0.18024773522111315, 0.1443593544198869, 0.37204135685678885, 0.1820700699470853, 0.11136253562940124, 0.10341201351942997, 0.0998370539047071, 0.09186492006914193, 0.19483613788064036, 0.20317963262760308, 0.29345328935773884, 0.16622429458599486, 0.36088128841334977, 0.2657583430616448, 0.2773038906388311, 0.3447044905958073, 0.1310554195231829, 0.316918138223764, 0.31477516796772964, 0.27949159757718867, 0.09592132956590627, 0.45745210206302267, 0.29553179908821425, 0.32685949568336814, 0.3531039123928985, 0.43858591497999255, 0.3826414584270147, 0.3680067774915379, 0.4425501835838046, 0.46691937525019456, 0.7709373627630028, 0.7731421333163693, 0.7707482572627146, 0.7705864343242569, 0.7542464766751591, 0.7509500859911529, 0.7813174475364796, 0.7702406536944187, 0.7675045536245988, 0.06500217561441513, 0.1521565060052863, 0.10282220465611758, 0.13364024072628222, 0.11278891118755108, 0.5886189820638876, 0.15538774766397379, 0.11390711480577431, 0.14608265122310682, 0.5737135915579992, 0.3514606181328934, 0.5794469400059574, 0.47466913262943067, 0.5807675163955994, 0.17713954861569292, 0.192600459448374, 0.5207820343170726, 0.6080153859515063, 0.45591990113505176, 0.4400547931210852, 0.4066224794077611, 0.4972569514767624, 0.43930639438105346, 0.5263550748216256, 0.27059416689206994, 0.5097799427769258, 0.5334345717950528, 0.271172160085449, 0.2586737332809532, 0.23843660211183837, 0.3157922812336452, 0.322242351860457, 0.4102084686399513, 0.2418396970186638, 0.3236657096688548, 0.2736299395709191, 0.23358353114358554, 0.2809605057840724, 0.2624049788783692, 0.25833172612563715, 0.27126881600078834, 0.23813801279428115, 0.2565906603888891, 0.24733883453263317, 0.2510401510396244, 0.17774922099423074, 0.18880324151531647, 0.17766000669141646, 0.17856802028932728, 0.21908723755386905, 0.18148678553236064, 0.18554418235877368, 0.18999576616614267, 0.19263546980661972, 0.18645142497306022, 0.18552313135115284, 0.1863539186954032, 0.875125141129774, 0.19878081886688936, 0.8739663198743707, 0.8302107764884452, 0.878572563720043, 0.881203037299877, 0.8693028413775743, 0.8704984014239245, 0.8679498917164081, 0.8171787314154005, 0.857060766473061, 0.16295980038502988, 0.8427620820621347, 0.7771220996004877, 0.7840008473276686, 0.19175907353083854, 0.21178496922930345, 0.18445150212707306, 0.2369380746989821, 0.1867905696659069, 0.23648775744479078, 0.19758748176659258, 0.18013860251846292, 0.18630132268667743, 0.09861456925792755, 0.09733643134666059, 0.09280798610826824, 0.08065704223049164, 0.09367845371023342, 0.1273517681789461, 0.08355323135969406, 0.08754270206221704, 0.12924132942764588]}, "mutation_prompt": null}
{"id": "649a7e32-7b76-4299-be97-3bf68d6e5a97", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n            \n            # Add cosine modulation for adaptive inertia\n            self.w *= abs(np.cos(np.pi * eval_count / (2 * self.budget)))\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n                \n                # Introduce cosine modulation for mutation rate\n                F_adaptive *= abs(np.cos(np.pi * eval_count / (2 * self.budget)))\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Enhance exploration and exploitation balance by introducing adaptive inertia and mutation rates with cosine modulation.", "configspace": "", "generation": 44, "fitness": 0.4343020282482769, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.28.", "error": "", "parent_id": "4bdd8d27-9b15-4a08-8106-f99576267995", "metadata": {"aucs": [0.8578609719830302, 0.8572907243512288, 0.863618077579244, 0.8358057286540717, 0.846124314266864, 0.8510674249660679, 0.8472311945053117, 0.8477166421122306, 0.8589422368075343, 0.682290272955458, 0.6682990583697968, 0.6716682031407454, 0.6179524618815724, 0.6707310714877819, 0.6785000569130225, 0.6605459304806967, 0.6668432193442373, 0.5979059124761508, 0.12918542897349083, 0.1275797794553002, 0.15351611956626987, 0.10758814792468196, 0.18148044764665294, 0.15670668617476913, 0.11506468908202572, 0.11384759438812253, 0.12083566886506436, 0.14020552487218518, 0.10080618379572859, 0.12986315060122633, 0.09906104994826659, 0.1131689846941395, 0.1188420001082553, 0.08968899568099786, 0.15296135273729505, 0.10267831169354613, 0.9098363520462626, 0.8676768736462226, 0.8765013281568351, 0.8847531542030159, 0.876545392587948, 0.9158350892339178, 0.8983177993944974, 0.8890324159159434, 0.9184810562825836, 0.6782826272757922, 0.7152107926130364, 0.6678310394944045, 0.7278921487550828, 0.7206473868674406, 0.6931018250840693, 0.714406799057243, 0.7017326422782872, 0.7199826222998126, 0.9054881407295698, 0.16992463995277962, 0.2260365234775672, 0.7366394952210278, 0.8907780414341335, 0.21752163592956053, 0.8475619157179031, 0.1767628142095493, 0.8899555718604386, 0.7119666847887384, 0.5784416543368928, 0.6247095201126109, 0.669835370542843, 0.6144969166006151, 0.6730978823208553, 0.6137915050220838, 0.13174364339896216, 0.5647696721470072, 0.6288801904330349, 0.6339547484274661, 0.5804656245010189, 0.5983593465053577, 0.6576981457902307, 0.6500802618063827, 0.6502888631389682, 0.6441575852676805, 0.6264569607221563, 0.456366401120211, 0.2739480436260263, 0.15531643998058675, 0.48999071501976166, 0.20467547867683333, 0.1818170249565898, 0.31539096562102253, 0.39581781143681993, 0.40688850823945044, 0.3033202251275905, 0.09530747035498421, 0.20516020693997505, 0.10701358695752239, 0.07071081326956541, 0.10770497971325366, 0.20083267714849162, 0.16884863519591387, 0.10132416064618721, 0.25023950956644536, 0.3703381312046916, 0.459609897823112, 0.5434509316184402, 0.1210810865243449, 0.32252126050341745, 0.3292683080470288, 0.3039426055044838, 0.3525674419597099, 0.4141268572851782, 0.494137306701652, 0.4429204054796291, 0.42318899737412774, 0.5532359324716987, 0.526066276124983, 0.5008900497375623, 0.4080669933138341, 0.3790022623002093, 0.8003449291815167, 0.7936892919058387, 0.7938217696664992, 0.7853710232383381, 0.7907737408416586, 0.813871351762787, 0.7693558301396671, 0.7946273484494859, 0.7991930237882957, 0.12620183527964568, 0.1227984500604854, 0.08945020239942825, 0.12829258067735172, 0.13143407274592955, 0.14349419511840478, 0.7018967220730503, 0.12061893228694076, 0.11421034915031869, 0.6593879376978968, 0.6779317292774699, 0.5945445532399742, 0.2871143346178222, 0.7494662824523461, 0.16678281545168516, 0.2032295644294052, 0.6623798423019662, 0.3330983158906772, 0.5625838114753687, 0.639605711698255, 0.21968891745532515, 0.5711075543176714, 0.4898350469803726, 0.5602067926536167, 0.2658419876375476, 0.6769734147857894, 0.5930475048619144, 0.2480127033277919, 0.2660022857581291, 0.27280152761233434, 0.28072794537616075, 0.2552145784554164, 0.4563032861214539, 0.23331076288814723, 0.2561225550673387, 0.24722060932347345, 0.25326386179608706, 0.2245134517209333, 0.21331941559667011, 0.22148178015980424, 0.24057200010162838, 0.21804161079033224, 0.26227693287701526, 0.2414510647257171, 0.22035297596738068, 0.2063973720782576, 0.22454137797130902, 0.17195577754382307, 0.2069053719727706, 0.17716306036400542, 0.1700202778599923, 0.17920894879760274, 0.2043510661692468, 0.21889213672333319, 0.18582019025573804, 0.18591659012262707, 0.179943904563991, 0.9159496603533115, 0.19840035253280897, 0.17201569383130122, 0.8691974522591972, 0.8869331705817176, 0.8986489994034013, 0.9065596084611294, 0.21162307263567182, 0.8786256213460599, 0.20908286181514046, 0.8638517541149473, 0.8623451216345622, 0.1664042679653781, 0.1675032313958218, 0.8199491178786402, 0.18970196347581814, 0.1888778546252894, 0.19922728942680845, 0.18012357908577648, 0.17368332929055796, 0.18306038316410955, 0.18714156247299074, 0.20199642578720733, 0.18696183382181375, 0.0915234801503344, 0.09408992072319511, 0.13319347037807983, 0.09326083437647881, 0.09812349311315649, 0.08446123942649408, 0.09721556608495718, 0.08214555239561283, 0.10449043389855817]}, "mutation_prompt": null}
{"id": "97907f5a-c30f-440f-bed1-86c1fdc77cb0", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Simulated Annealing-like acceptance\n                if trial_value < pbest_val[i] or np.random.rand() < np.exp((pbest_val[i] - trial_value) / (1 + eval_count/self.budget)): \n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Enhance local optimization by integrating Simulated Annealing-like acceptance criteria for diversity.", "configspace": "", "generation": 45, "fitness": 0.28080270959773196, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.18.", "error": "", "parent_id": "4bdd8d27-9b15-4a08-8106-f99576267995", "metadata": {"aucs": [0.42166513951875173, 0.43060942347980335, 0.4181355429059771, 0.42850435007156207, 0.4261173805491215, 0.4250751305695676, 0.4392734830161218, 0.4309565979242759, 0.4109129025698446, 0.32393164160531807, 0.27161538277823316, 0.3277675919732883, 0.33004355632726323, 0.3033412548236363, 0.2938442933066082, 0.28096259057927586, 0.30025773914205833, 0.3028681805294038, 0.1812048502942395, 0.15707093168969355, 0.09879321109734629, 0.10960444853495244, 0.10416706227475647, 0.10317785749839004, 0.14124654812813264, 0.14248908224474022, 0.10758696676510149, 0.10268868566327749, 0.09138472020746047, 0.11544678541306419, 0.10313162684169674, 0.07291191789283369, 0.12772705124426686, 0.1227757664702378, 0.07435043377159578, 0.11431468197645533, 0.8933929053284029, 0.9206603420697747, 0.9214290790654455, 0.8680946050292463, 0.8641257359904109, 0.8367145107989908, 0.8856490245819683, 0.8617279936902502, 0.9069298059207342, 0.36644130571342737, 0.3495421115848796, 0.3679238870876106, 0.36810930485189564, 0.378912121089921, 0.37395548471515727, 0.3837753464606287, 0.34409404387994247, 0.4133831138424352, 0.3488877284916856, 0.8152022578300002, 0.37229470556827504, 0.21805043254834078, 0.443285884942471, 0.273645675237408, 0.17669844698664583, 0.23469355466068598, 0.23272575334743995, 0.28294983909894944, 0.2738048070564486, 0.2770100498874781, 0.37250432569784553, 0.29050046572076205, 0.33191132764586784, 0.26231963725652496, 0.27953580895647145, 0.2938152960275202, 0.26974103666728777, 0.26161310793785864, 0.2675831363126817, 0.2854860900511661, 0.23668522139945436, 0.31472882323194495, 0.2969071351125955, 0.2698213325838196, 0.28282160860595285, 0.23076585798554494, 0.16168495969212093, 0.2410028655108205, 0.20482701320266528, 0.2541025616089376, 0.04452758647905597, 0.215142559338234, 0.14932341095324342, 0.23869343697869372, 0.2126779698206216, 0.12542359886840315, 0.13965707977396946, 0.0495103571708394, 0.13328552603748745, 0.03104756143021259, 0.1959535578406405, 0.312088482151505, 0.21016390924170658, 0.22247569490318153, 0.25620754877990803, 0.21193448974121787, 0.272782902216122, 0.2043563899862858, 0.16919741964279256, 0.15598270945673798, 0.20307411619833415, 0.25232294842043335, 0.21755656177025506, 0.15055594198442834, 0.2358292490325199, 0.23099141703492132, 0.22781461362730526, 0.21064869443603207, 0.23752431342074376, 0.2351631263802596, 0.23764684728227226, 0.37858742776007726, 0.40606410228324874, 0.41509079903162305, 0.3771339790692241, 0.37188457333576186, 0.3929630335263746, 0.40055588050800883, 0.39379188060952786, 0.40751700476681896, 0.08876880079434757, 0.10672329588945939, 0.093244042955821, 0.09045574713285554, 0.08268748613024035, 0.1288049034149069, 0.1372323973920686, 0.15384769262496467, 0.10676094191985286, 0.3556684840466976, 0.22314869509336932, 0.2848079736967766, 0.33345866812937097, 0.32159897770408474, 0.33745030429308864, 0.23382209206946347, 0.21158143123339213, 0.31943958386699867, 0.25757667214098523, 0.2948240286212088, 0.2964917902960962, 0.2900742874766413, 0.2878991140140055, 0.297240557407918, 0.25266421492107893, 0.2888998908829514, 0.2565583385852257, 0.22487507321048883, 0.25922119267405885, 0.21957200383466946, 0.24948817274009694, 0.2583187273247539, 0.19586426530076217, 0.2105126665070991, 0.21749243612179792, 0.2800371939794819, 0.23119058775420287, 0.21722491855051163, 0.27521545312094187, 0.25228392283668755, 0.22224131584518114, 0.20031656010620225, 0.23296832083107588, 0.27731156294418746, 0.25194096808017097, 0.1787339183821628, 0.18014554259903326, 0.21707999511102394, 0.19624752725534167, 0.21400174261131277, 0.19148028258800032, 0.19676967215093244, 0.18166305590496468, 0.1838216732963226, 0.1860330079074889, 0.18451759160595949, 0.18427465668621867, 0.6741562382394426, 0.19851410732625463, 0.6411819559357796, 0.19512621039136402, 0.6675198653630405, 0.598777972370823, 0.6132274398434268, 0.2094143092531059, 0.1523978048415613, 0.5752388899598648, 0.20917732562489155, 0.6006642818235262, 0.1662636460797805, 0.5464995363425494, 0.5478140598087637, 0.1866843157922674, 0.1856894304133463, 0.1868628233113725, 0.1795546863878541, 0.1679815183474419, 0.18675496122675883, 0.19303785681509633, 0.19229044041626653, 0.2048711924683776, 0.10375638124624242, 0.10257995377718143, 0.09550926304958252, 0.09475180090546687, 0.0795715053586522, 0.08376831936609197, 0.09318461478735096, 0.09369815728404629, 0.09271900882535955]}, "mutation_prompt": null}
{"id": "76d3487a-cd84-4969-ac75-aa7503ff20b6", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max * dynamic_factor)  # Adjusted clamping\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Dynamic crossover rate\n                dynamic_CR = 0.8 + 0.2 * chaos_val \n                trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce a dynamic crossover rate and velocity clamping for better convergence efficiency.", "configspace": "", "generation": 46, "fitness": 0.4108716134578348, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.", "error": "", "parent_id": "4bdd8d27-9b15-4a08-8106-f99576267995", "metadata": {"aucs": [0.8486133942512099, 0.8574764786622404, 0.85557589710982, 0.8404827491550925, 0.8416837908640491, 0.8420354299902563, 0.835015124253766, 0.8343977404679725, 0.8413295766379454, 0.6717651089380706, 0.6007149469206099, 0.691092667380184, 0.6292650201268263, 0.6396354932929689, 0.6291881140743082, 0.6037313585575241, 0.6191524502869434, 0.6112495181974026, 0.12872185183615037, 0.12345961976968178, 0.07073455755254332, 0.12151587648697826, 0.10926795870089079, 0.1035648084910421, 0.1306303044641942, 0.12858672628175682, 0.14309791600429123, 0.09053245606648075, 0.10893437616982937, 0.11181542797201982, 0.10863745277671444, 0.07788141463439424, 0.10742871950430488, 0.08889550916988842, 0.10211820678259587, 0.10142351248143955, 0.888532274777645, 0.8307690582919796, 0.8566605268149303, 0.8595062508765318, 0.8637543849489043, 0.8997928388401105, 0.8934582011321541, 0.8676323148385903, 0.8778082556096807, 0.7052663899775975, 0.6798200578177155, 0.6721847201318114, 0.6897964059570325, 0.70443917053157, 0.7058945190554848, 0.7155503727015424, 0.7198041478281216, 0.7095714336013551, 0.8688517109882897, 0.8768976284329967, 0.22604244816977637, 0.2767052175753052, 0.8734948046528828, 0.27073410637401285, 0.14912399290940848, 0.8652006958355504, 0.23339677754370847, 0.672537515305148, 0.5863655041349549, 0.5061022767825958, 0.5994735461827823, 0.12785444306594163, 0.5246696623530451, 0.6324464613375044, 0.5776621492562144, 0.5906236119501675, 0.611479418018215, 0.6546208006292278, 0.1339070391251136, 0.13295728308978227, 0.5764468928656274, 0.5611989081108812, 0.6031896277362938, 0.5619054866449658, 0.6117456572189262, 0.025992929119248998, 0.13207590271773828, 0.0063170168557724615, 0.48127467939328494, 0.12413884173859246, 0.02041919055037522, 0.11039032553117323, 0.062018166703584954, 0.5783670304484546, 0.323645182674243, 0.10049027790269849, 0.17711558494441948, 0.10084422915433766, 0.07023930771821141, 0.08816223983364269, 0.21686553533027209, 0.10206065652640173, 0.1469960617445768, 0.2620547292714679, 0.3392747635414506, 0.3553336138846074, 0.14387759578962955, 0.1119237103195092, 0.0836322961579663, 0.4448986879673703, 0.19390345117352847, 0.2925442512755443, 0.38471344438370525, 0.35999409755754175, 0.36999688980747225, 0.45786056713491197, 0.4879249385832568, 0.47285796702097016, 0.4461546905772509, 0.4449057811125624, 0.3964159881805247, 0.7926051763723388, 0.7822630169215987, 0.791750206875653, 0.7768056577900941, 0.7949038914420063, 0.7884232283893106, 0.7904562753538124, 0.7849248390904279, 0.8080589501209381, 0.1078267011907672, 0.10031424535781786, 0.09808939876008405, 0.11439320205019976, 0.10625683644344297, 0.14058724678722279, 0.15380558770671504, 0.1536294410794231, 0.12093520745478725, 0.690531218447108, 0.3034660363843724, 0.65592105936725, 0.6088283413497422, 0.6448037541179327, 0.43449412909595486, 0.621942151790493, 0.26978688848054844, 0.2661008020698532, 0.24309747079279176, 0.5436187749572872, 0.5383849380287713, 0.5864870375220228, 0.4627319654928006, 0.5956441722377083, 0.2495824484609549, 0.6071092544732215, 0.2574832110734334, 0.2885572024514712, 0.3042183864526997, 0.23665336895537525, 0.4208783591651152, 0.24963787353857847, 0.3941599893814306, 0.20593376094192795, 0.26733789200674674, 0.26430858218942954, 0.2514819823716582, 0.26731174762695076, 0.24109529065205648, 0.2133140964305289, 0.20113289842925064, 0.2301750615670417, 0.2162066773650505, 0.25200255778486547, 0.22453282109120432, 0.19575404156480203, 0.18140511571889428, 0.18667248559142657, 0.1961311156076183, 0.188389772918367, 0.19406075263605704, 0.19543255074754762, 0.18932906995494647, 0.19206498035445474, 0.8906839606842789, 0.8998139858535464, 0.1851962711114038, 0.9096490877850071, 0.19863423456119655, 0.1721531269896157, 0.1755368187727272, 0.1664799446103149, 0.9127597726846415, 0.8863783654437759, 0.8709995723167047, 0.8556004918601652, 0.8697771802668779, 0.8349996450229731, 0.8183343569331841, 0.1037189085766782, 0.16558923735531772, 0.8111863817320389, 0.1817837339055265, 0.21338277250069926, 0.17402722187844522, 0.18931198011154082, 0.17987131869092554, 0.1870773821113083, 0.17930166864311559, 0.19455915413918456, 0.18991539334849417, 0.08730913604998691, 0.09642770108302778, 0.08926418598974428, 0.08441685085751505, 0.10839684771431479, 0.11482328662149344, 0.10388084856797208, 0.10299245789686906, 0.0986068604365622]}, "mutation_prompt": null}
{"id": "b356829e-9360-47c9-a2c1-3450d1d43410", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce a random inertia weight perturbation and enhance mutation diversity for improved exploration.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4bdd8d27-9b15-4a08-8106-f99576267995", "metadata": {"aucs": [0.8556421664289277, 0.8549696233133078, 0.8634204327586672, 0.8426241311396068, 0.8482992190584626, 0.8484945207451412, 0.8547857952763884, 0.8373418122836526, 0.8474807981274585, 0.6390210998587784, 0.6578765634234136, 0.6868178463251026, 0.6394448801041607, 0.6530236934125673, 0.6535716106592343, 0.5936924096470445, 0.62122690964524, 0.6075099482023336, 0.1803047279589316, 0.11419409618735155, 0.12709806376185884, 0.09855831090373335, 0.11042725545880006, 0.157034214083573, 0.11987477247266853, 0.15511043842505223, 0.12838740150573136, 0.15348945105730638, 0.08979167300101054, 0.13658703517496085, 0.09046859141015562, 0.1272093651706968, 0.09674997453411183, 0.08577503883698223, 0.11389552848562234, 0.10298811419713716, 0.9100570304288091, 0.8650780290797997, 0.859668076182671, 0.8869482702546851, 0.8560157490564119, 0.9216017685268375, 0.8998517016594284, 0.8689651335635249, 0.9184957130762181, 0.7015123297646813, 0.7102520226804928, 0.7019690706771227, 0.6959991168778101, 0.6670009962363415, 0.6748492909516519, 0.6957280108552255, 0.7051935150872982, 0.7084847304754787, 0.8523276954525127, 0.2249897385791051, 0.8640597986698355, 0.8546970458306095, 0.8706331677415797, 0.27446629127234023, 0.22981844986601785, 0.1767628142095493, 0.875659564198044, 0.6532794832355238, 0.5890132379432269, 0.6103490042583999, 0.6229708796533135, 0.6062325329119036, 0.5830294469304365, 0.5819496606839758, 0.6456221963765538, 0.6408789121834596, 0.598486398667587, 0.608737664907662, 0.5687180337889879, 0.6082418351639789, 0.6193443146601543, 0.6209346730437049, 0.6697623037777276, 0.5883201343850697, 0.6146670123502568, 0.4399864505009201, 0.3213942660449899, 0.39745477726829526, 0.5001172207533572, 0.2153150369545922, 0.15806405941090174, 0.3176256392465654, 0.22487253390818518, 0.3836166748547586, 0.26101345477283955, 0.1219888466400707, 0.16995504656780636, 0.10884477754811106, 0.051193274793515764, 0.1112319021784528, 0.2850646011675836, 0.44398266788438134, 0.187669860523898, 0.1614052940070324, 0.37318299614568884, 0.417072981866754, 0.5399274812268832, 0.11876772697975013, 0.2083989132383215, 0.2904755521103848, 0.36891048558132045, 0.3028851022425578, 0.44096389284984305, 0.41692446444650244, 0.42448800232347017, 0.47104334815310034, 0.47235326106551634, 0.5002085056490002, 0.44906946758707034, 0.30570750682710435, 0.41038121612032097, 0.7840473980293685, 0.7857511982756386, 0.7876382087357032, 0.7606829631699021, 0.77511087737276, 0.7945974949487931, 0.789733102959478, 0.8080458553341119, 0.804834879532619, 0.10354881661913551, 0.13639325826454585, 0.0931115047122093, 0.13962388312210938, 0.11034480841676886, 0.11436606958398154, 0.18284953988686659, 0.12848462802147076, 0.13550067036175895, 0.6808889758927935, 0.24345750247562048, 0.5846898304834421, 0.6454254857159989, 0.7194602582201914, 0.3424082799478514, 0.2155899546886595, 0.6034184010723077, 0.26531175589251443, 0.2847950820782069, 0.3119889672070576, 0.3256062861201995, 0.6232391443521406, 0.49131110469289174, 0.5111212902292157, 0.2671121910109736, 0.616133248734159, 0.4745249667350706, 0.2590178122042467, 0.44215597590515077, 0.25514169701419087, 0.29883631865866, 0.26387444887930966, 0.5424242662579319, 0.23634593413609728, 0.2812445215938817, 0.23800257934440483, 0.24531482490407208, 0.23138612326542152, 0.23417861052952116, 0.2369095192559253, 0.2866938865537544, 0.4567732478809784, 0.23893716335337867, 0.22683782597917912, 0.20825906744652556, 0.24506247284617944, 0.24621517817882044, 0.19502007631675378, 0.22068438731187312, 0.20452010790780684, 0.18207786424341676, 0.18581896691824973, 0.21856740580742196, 0.21892772457121568, 0.18568205741171284, 0.8758225289783393, 0.172390277072891, 0.9142488139987004, 0.19840431960568483, 0.17196230973311466, 0.8739299140684031, 0.8825240759023424, 0.8988261954376928, 0.9010022689352849, 0.2117261380892308, 0.8685287413667282, 0.20823257141203066, 0.8556886513600507, 0.8509778298948193, 0.16642324356799654, 0.16751122733955492, 0.8288515447623506, 0.18721954111235117, 0.17790166944720387, 0.20913667823948645, 0.1793451789083016, 0.1843910010926516, 0.17852385042389873, 0.25013628782133734, 0.1782781930598054, 0.18609137356672922, 0.08237200957526092, 0.1022574680259446, 0.10731727300130334, 0.09110304046588136, 0.09531046691456102, 0.10586189613624297, 0.08947837586969076, 0.1083695756899955, 0.10021782289284542]}, "mutation_prompt": null}
{"id": "345ed4bf-4067-4b9a-a9c3-08025a365380", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with adaptive CR based on chaos\n                self.CR = 0.7 + 0.2 * chaos_val\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Integrate chaotic PSO tuning with adaptive DE crossover for sharper convergence.", "configspace": "", "generation": 48, "fitness": 0.39751479626983366, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.27.", "error": "", "parent_id": "4bdd8d27-9b15-4a08-8106-f99576267995", "metadata": {"aucs": [0.8521180940105679, 0.8494097905691484, 0.8708944052638573, 0.8406132553882697, 0.834446070902279, 0.8518571709693658, 0.8513542790638341, 0.8535526809674974, 0.8482950542769518, 0.6649397045767885, 0.6818480288091471, 0.6873644605682842, 0.6717447961491576, 0.6921994254338932, 0.6894633190208606, 0.6651737792563883, 0.6329908514004781, 0.6517151530919207, 0.12474982459584316, 0.14012076340170299, 0.13869287750569748, 0.1406089683275874, 0.7151960436970111, 0.18255989510353166, 0.15338485806067947, 0.15595901919682742, 0.1789031119682437, 0.12166246522397939, 0.07807735052666631, 0.12664934836610886, 0.09409691395912412, 0.12726466636684652, 0.10787120719945598, 0.09373901606181279, 0.12676461565866992, 0.11455339575426804, 0.9213744223757826, 0.8552852280641297, 0.875579876975069, 0.8798308179252253, 0.8960723026749142, 0.9124909520584297, 0.8841962726071501, 0.9029719382090848, 0.8852568086885197, 0.674823303421383, 0.686514804804407, 0.7043448658369955, 0.7023656741184365, 0.6908401663236889, 0.7155686118486865, 0.6934000095313056, 0.6943859415209049, 0.6842190552106244, 0.8397188500914676, 0.22584926286821283, 0.22744415375811233, 0.21211222571441535, 0.8822662091130224, 0.27478047933025285, 0.23299080972356656, 0.23125048633152323, 0.2325851085898244, 0.5492989555982377, 0.6565280422617912, 0.5701447058308711, 0.5656088686826913, 0.5147823122670991, 0.6302636161127122, 0.563531123115028, 0.5607135079239063, 0.583562557494114, 0.5002460098393748, 0.5490079503854277, 0.6541839006712981, 0.5139468995863437, 0.5868898234567725, 0.670862062352702, 0.6225350084430337, 0.5095506200551021, 0.6014737357900324, 9.999999999998899e-05, 0.10450109319186973, 0.07422740077958678, 0.13698296650277864, 0.10519054581465803, 0.08118490218320473, 0.13706897200499912, 0.2281935026592612, 0.4467799778327023, 0.25990795714832293, 0.10413095450982635, 0.1681265250179993, 0.1156130894153008, 0.07442460756494707, 0.08968382766294691, 0.11934263927244315, 0.10650564109241245, 0.34564051031976484, 0.3738053731493104, 0.307763983122995, 0.18444717012920997, 0.24271437410895313, 0.12136129900315684, 0.33546179850846625, 0.26527970561821546, 0.38296847006391643, 0.23599887537770403, 0.2627875542727989, 0.3704317305428766, 0.3569499729702955, 0.38982074513531406, 0.43172963080953874, 0.45389118319397503, 0.336251234477446, 0.3149690791614983, 0.3127161876583261, 0.7734080117515492, 0.7834336785032585, 0.7799107536293743, 0.7726534873922118, 0.753895493358915, 0.7314801946300509, 0.771321987292642, 0.7780461592529075, 0.7894890196275843, 0.11315013355451231, 0.11244341954399129, 0.06781577072781819, 0.1583159299865985, 0.11161099028122301, 0.1581812610773824, 0.13589055464897337, 0.15149223158142955, 0.13045405351415063, 0.6382986826212231, 0.7038223915790719, 0.2248913612816854, 0.3173863400250555, 0.533472743794803, 0.641795219458108, 0.5645619888745058, 0.6224763588564468, 0.2707059683766825, 0.25646192216372254, 0.5417260376757326, 0.48014665486279984, 0.2877577260231826, 0.5209615879437356, 0.5198614544251519, 0.27439913617591083, 0.6278652641674564, 0.2562074401780071, 0.3065056707524628, 0.4754967736462913, 0.22467577483165513, 0.32738096967684505, 0.3449340640932451, 0.27965996949698246, 0.2203959781526349, 0.2642385556801925, 0.25297690926973526, 0.2266469203298188, 0.27060241139250873, 0.20244623005733797, 0.21838314964322225, 0.2606171657005266, 0.26535139840588096, 0.26629636468196816, 0.2229890147100294, 0.24151094668499973, 0.19191156875361526, 0.18524410290319981, 0.20878091889520178, 0.174438628626014, 0.18752177285808758, 0.205028065883068, 0.19134655450838944, 0.17929573466353654, 0.16768308956885325, 0.18615174497089715, 0.1865230581399313, 0.18280134973798867, 0.9104713861623102, 0.19914236151072817, 0.19925546288884566, 0.17426846073640212, 0.15825915961043624, 0.15595255176905265, 0.8964581697816992, 0.21185650750857088, 0.8786074147139623, 0.825397228755459, 0.11172183268209479, 0.20911931654920968, 0.1673992832070582, 0.8446975495692699, 0.7887765749123505, 0.21235615101699135, 0.1838912112489811, 0.2044640921293932, 0.1875412877380268, 0.1965331627663527, 0.18573942066994786, 0.20302129023153548, 0.19794317467602152, 0.17137174045344417, 0.08925659444105694, 0.11451981903397024, 0.12450465059412619, 0.09753548845392401, 0.09827324097539969, 0.10340363527368024, 0.09197515821268121, 0.09036700347256332, 0.09605286843411409]}, "mutation_prompt": null}
{"id": "ad1abe95-35cd-4c6b-b9a1-ebe5f8c33802", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce a random inertia weight perturbation and enhance mutation diversity for improved exploration.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4bdd8d27-9b15-4a08-8106-f99576267995", "metadata": {"aucs": [0.8556421664289277, 0.8549696233133078, 0.8634204327586672, 0.8426241311396068, 0.8482992190584626, 0.8484945207451412, 0.8547857952763884, 0.8373418122836526, 0.8474807981274585, 0.6390210998587784, 0.6578765634234136, 0.6868178463251026, 0.6394448801041607, 0.6530236934125673, 0.6535716106592343, 0.5936924096470445, 0.62122690964524, 0.6075099482023336, 0.1803047279589316, 0.11419409618735155, 0.12709806376185884, 0.09855831090373335, 0.11042725545880006, 0.157034214083573, 0.11987477247266853, 0.15511043842505223, 0.12838740150573136, 0.15348945105730638, 0.08979167300101054, 0.13658703517496085, 0.09046859141015562, 0.1272093651706968, 0.09674997453411183, 0.08577503883698223, 0.11389552848562234, 0.10298811419713716, 0.9100570304288091, 0.8650780290797997, 0.859668076182671, 0.8869482702546851, 0.8560157490564119, 0.9216017685268375, 0.8998517016594284, 0.8689651335635249, 0.9184957130762181, 0.7015123297646813, 0.7102520226804928, 0.7019690706771227, 0.6959991168778101, 0.6670009962363415, 0.6748492909516519, 0.6957280108552255, 0.7051935150872982, 0.7084847304754787, 0.8523276954525127, 0.2249897385791051, 0.8640597986698355, 0.8546970458306095, 0.8706331677415797, 0.27446629127234023, 0.22981844986601785, 0.1767628142095493, 0.875659564198044, 0.6532794832355238, 0.5890132379432269, 0.6103490042583999, 0.6229708796533135, 0.6062325329119036, 0.5830294469304365, 0.5819496606839758, 0.6456221963765538, 0.6408789121834596, 0.598486398667587, 0.608737664907662, 0.5687180337889879, 0.6082418351639789, 0.6193443146601543, 0.6209346730437049, 0.6697623037777276, 0.5883201343850697, 0.6146670123502568, 0.4399864505009201, 0.3213942660449899, 0.39745477726829526, 0.5001172207533572, 0.2153150369545922, 0.15806405941090174, 0.3176256392465654, 0.22487253390818518, 0.3836166748547586, 0.26101345477283955, 0.1219888466400707, 0.16995504656780636, 0.10884477754811106, 0.051193274793515764, 0.1112319021784528, 0.2850646011675836, 0.44398266788438134, 0.187669860523898, 0.1614052940070324, 0.37318299614568884, 0.417072981866754, 0.5399274812268832, 0.11876772697975013, 0.2083989132383215, 0.2904755521103848, 0.36891048558132045, 0.3028851022425578, 0.44096389284984305, 0.41692446444650244, 0.42448800232347017, 0.47104334815310034, 0.47235326106551634, 0.5002085056490002, 0.44906946758707034, 0.30570750682710435, 0.41038121612032097, 0.7840473980293685, 0.7857511982756386, 0.7876382087357032, 0.7606829631699021, 0.77511087737276, 0.7945974949487931, 0.789733102959478, 0.8080458553341119, 0.804834879532619, 0.10354881661913551, 0.13639325826454585, 0.0931115047122093, 0.13962388312210938, 0.11034480841676886, 0.11436606958398154, 0.18284953988686659, 0.12848462802147076, 0.13550067036175895, 0.6808889758927935, 0.24345750247562048, 0.5846898304834421, 0.6454254857159989, 0.7194602582201914, 0.3424082799478514, 0.2155899546886595, 0.6034184010723077, 0.26531175589251443, 0.2847950820782069, 0.3119889672070576, 0.3256062861201995, 0.6232391443521406, 0.49131110469289174, 0.5111212902292157, 0.2671121910109736, 0.616133248734159, 0.4745249667350706, 0.2590178122042467, 0.44215597590515077, 0.25514169701419087, 0.29883631865866, 0.26387444887930966, 0.5424242662579319, 0.23634593413609728, 0.2812445215938817, 0.23800257934440483, 0.24531482490407208, 0.23138612326542152, 0.23417861052952116, 0.2369095192559253, 0.2866938865537544, 0.4567732478809784, 0.23893716335337867, 0.22683782597917912, 0.20825906744652556, 0.24506247284617944, 0.24621517817882044, 0.19502007631675378, 0.22068438731187312, 0.20452010790780684, 0.18207786424341676, 0.18581896691824973, 0.21856740580742196, 0.21892772457121568, 0.18568205741171284, 0.8758225289783393, 0.172390277072891, 0.9142488139987004, 0.19840431960568483, 0.17196230973311466, 0.8739299140684031, 0.8825240759023424, 0.8988261954376928, 0.9010022689352849, 0.2117261380892308, 0.8685287413667282, 0.20823257141203066, 0.8556886513600507, 0.8509778298948193, 0.16642324356799654, 0.16751122733955492, 0.8288515447623506, 0.18721954111235117, 0.17790166944720387, 0.20913667823948645, 0.1793451789083016, 0.1843910010926516, 0.17852385042389873, 0.25013628782133734, 0.1782781930598054, 0.18609137356672922, 0.08237200957526092, 0.1022574680259446, 0.10731727300130334, 0.09110304046588136, 0.09531046691456102, 0.10586189613624297, 0.08947837586969076, 0.1083695756899955, 0.10021782289284542]}, "mutation_prompt": null}
{"id": "614d2834-98ba-4570-9b47-d9ffb918fec3", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = np.tanh(self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce hyperbolic tangent velocity adjustment for adaptive exploration and exploitation balance.", "configspace": "", "generation": 50, "fitness": 0.408625456849153, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.28.", "error": "", "parent_id": "4bdd8d27-9b15-4a08-8106-f99576267995", "metadata": {"aucs": [0.8599488099185799, 0.8570507559181197, 0.8656398597785151, 0.8410589945963279, 0.8446568870780845, 0.8415405735332215, 0.8486426977508064, 0.8391298316424788, 0.858905691546766, 0.6530433745961877, 0.6793693535110084, 0.6889609504233122, 0.6224908970958455, 0.6711712807240595, 0.6601497714407566, 0.5995401500937971, 0.6548228404632387, 0.6476017067719779, 0.15691759999447563, 0.13936945832111236, 0.1200456633644219, 0.11543716408923688, 0.11459284529990221, 0.1564761393977404, 0.11479991597808525, 0.1382383668483148, 0.10673163181041678, 0.09068980550094763, 0.08080090434878673, 0.10168280221095394, 0.09530889333193482, 0.10307509230352274, 0.10765067322140098, 0.10784564035336752, 0.10623736365950442, 0.10840080880034797, 0.8927886709733093, 0.8724666969497404, 0.8636220133290071, 0.8717218793695198, 0.8611609351889971, 0.9120620817200578, 0.8957765346303908, 0.8641100947822935, 0.9117100998261635, 0.7006019196098718, 0.6901555457232716, 0.6668651488686881, 0.7086464035379928, 0.6827156748983025, 0.693671456817598, 0.7057525396040516, 0.7222444630727802, 0.7169940475727928, 0.8760670813229323, 0.1699769327513424, 0.2254769923515001, 0.8893802823650111, 0.27386656777096663, 0.26869664776404856, 0.17622245915188817, 0.17666581793202474, 0.8728916121128871, 0.6486959555226541, 0.7110323533012293, 0.6820440391619018, 0.6313479031718623, 0.5820970214993346, 0.6227889560160673, 0.5895945166346005, 0.5425555029414224, 0.6136191040374963, 0.5633058233094284, 0.5930945017825215, 0.6544678478028632, 0.6209138004556107, 0.6125494286384132, 0.13436281718314402, 0.627171427833854, 0.6684853958424524, 0.6315381318620799, 0.3456592341870419, 0.37359941098080673, 0.0728257436799864, 0.33501945527620314, 0.24741074835108023, 0.12026539942760195, 0.34777882266798943, 0.3266396173179583, 0.07963891643778664, 0.2174092866514069, 0.09067508562534199, 0.15268745886588764, 0.20629536596191, 0.055067801377335135, 0.11374010206205398, 0.21352808794137224, 0.11437729940201591, 0.21270554529548613, 0.24348323097429492, 0.19175764725794742, 0.44238440686482494, 0.4626316307153141, 0.17049622391928387, 0.13551935230091183, 0.24977237501391325, 0.27137028319122114, 0.12442198271433025, 0.38643864895966873, 0.35888794160289794, 0.3624795717877427, 0.466170506351573, 0.512856905174459, 0.5085619240249943, 0.4493817792270287, 0.3832916770188144, 0.49203997804986255, 0.7993376120514921, 0.79117452981628, 0.7930963004316689, 0.8028708552663955, 0.8021520322620348, 0.7922216575543405, 0.7837706681237583, 0.776981199347168, 0.8047546026610357, 0.1555548618196233, 0.1518071867864328, 0.09531063556306596, 0.17160613676668524, 0.10503491306796964, 0.10847345187223234, 0.17893947415687017, 0.15002822510779645, 0.10946651989563938, 0.6883316316786048, 0.27750331091968006, 0.211734471775765, 0.2663293416332032, 0.6289122093182288, 0.7053963254998143, 0.24710094913656022, 0.25358037248763143, 0.271278472002093, 0.2436171138366947, 0.5162528490591529, 0.2434914245647244, 0.4442724684443746, 0.6102421105131344, 0.6639735953421146, 0.27542109173032747, 0.41685770370323383, 0.47641259066008, 0.4969074888217806, 0.25097785976707976, 0.25734871620823274, 0.44026854929146697, 0.31032335479109774, 0.33235342942731083, 0.18346933647991714, 0.41903700071523753, 0.24604377609514838, 0.20329828052030807, 0.23280733049382207, 0.2101906544081248, 0.22304144615324784, 0.20362015417345625, 0.25816694663609674, 0.22500023553914672, 0.21746564757812026, 0.2678572183120096, 0.19712493354190141, 0.24476686147536797, 0.2050589480940962, 0.18584295084212465, 0.19668145561938577, 0.1862370136918583, 0.19739814683353463, 0.18700780117218263, 0.194866216820627, 0.1855289130055855, 0.1859970029754252, 0.17092787271614684, 0.9139956752114973, 0.19855964411264526, 0.17221026011994167, 0.8756147634003747, 0.8877886508912679, 0.17009350252088806, 0.8950105146278483, 0.21157979721397846, 0.8357648545075593, 0.20890201752684556, 0.8375339358937768, 0.8420422331582273, 0.1660479512710954, 0.16723890524263774, 0.8275669535244279, 0.18920180384095586, 0.18946753844008524, 0.2024761150847283, 0.2098161782942254, 0.23195970076129113, 0.19555510518012165, 0.18163950451422128, 0.19440664864801271, 0.17855052381593728, 0.09682626956271345, 0.08924704334319122, 0.09484071739208288, 0.0917873853067318, 0.09915886160874421, 0.09821488345568141, 0.092602653667885, 0.0795501441553017, 0.08167373669612987]}, "mutation_prompt": null}
{"id": "e311cca3-7bd0-48c2-9cb0-50d9e3b13b58", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Generate chaotic initialization for particles\n        chaos_seq = np.random.rand(self.population_size, self.dim)\n        for _ in range(10):  # Logistic map iteration for chaos\n            chaos_seq = 4 * chaos_seq * (1 - chaos_seq)\n        pos = self.lb + (self.ub - self.lb) * chaos_seq\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n        chaos_val = 0.7  # Initial value for chaotic mapping\n\n        while eval_count < self.budget:\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(self.population_size):\n                c1_adaptive = 1.5 + 0.5 * chaos_val\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Adaptive DE mutation scaling\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1) * dynamic_factor\n\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce chaotic sequence for population initialization and adaptive scaling to enhance global and local search balance.", "configspace": "", "generation": 51, "fitness": 0.4261624243048919, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.28.", "error": "", "parent_id": "4bdd8d27-9b15-4a08-8106-f99576267995", "metadata": {"aucs": [0.8305782971000181, 0.8425344538617758, 0.8704005633448995, 0.8266490884586959, 0.8458566200668753, 0.8535523379201005, 0.8382610906769794, 0.8385942236419439, 0.8583726509415719, 0.6806646970173847, 0.6709897004795318, 0.694646925310817, 0.6541398838780621, 0.6604492468987588, 0.6670070844397524, 0.6383971188591963, 0.6130884861842991, 0.615165879156675, 0.6719135675925869, 0.11318361571560942, 0.14908189957050144, 0.10359285925035966, 0.10644508208922521, 0.11376028542344352, 0.13865373748641907, 0.18154445068894598, 0.1365355062676048, 0.10644224779554678, 0.10170716929134505, 0.08906534268186328, 0.11192743056276833, 0.11231527353995063, 0.10119241014762737, 0.1280774693229696, 0.11380777568107425, 0.12901184751243167, 0.8468004120464135, 0.8588045495620249, 0.8371483847099805, 0.8717887668441906, 0.8815338212166304, 0.9251961948242983, 0.8626795451622881, 0.9088206031474029, 0.9007827613924586, 0.6670984363325791, 0.6765012872098826, 0.6887113161002951, 0.6647485935716444, 0.7086547276441607, 0.6795719204604374, 0.6793028818207707, 0.6869147353073345, 0.695045149238533, 0.859573094506515, 0.2258727645841765, 0.22462988561038633, 0.8699539595587595, 0.8653179905932703, 0.3709651685878026, 0.23378667232980044, 0.8701941961379609, 0.8714957784417632, 0.1287117035924864, 0.5863724804977204, 0.6229005653588555, 0.6315491924198602, 0.5716340751449387, 0.6215818996284386, 0.7168047565868728, 0.6340206304495949, 0.6071719041073556, 0.5820525769286253, 0.5867123728953154, 0.13132926562183456, 0.6202179906574175, 0.5859441208717843, 0.6356228797097437, 0.6141733809148162, 0.553568962990996, 0.6205764765184191, 0.08524669107802041, 0.18239131773291262, 0.18194450412100827, 0.5273077868212204, 0.0988158861768419, 0.4162153036961058, 0.13775815751842058, 0.566464871394535, 0.4008097237820445, 0.10392152353119932, 0.1254265544453883, 0.14175473256463444, 0.1516243414009587, 0.13759565814853136, 0.10602226992943375, 0.21551608907985098, 0.20090944600000538, 0.2817497275923885, 0.3592880963520769, 0.32119503428006446, 0.1891443220904524, 0.24644366461341238, 0.4601057938094777, 0.27405659784143166, 0.10293279878581818, 0.13059794025502947, 0.4028571020634596, 0.376790174680415, 0.4188702935188843, 0.395514748541236, 0.480314326326276, 0.4572003978933217, 0.47858870578035073, 0.44790080071182314, 0.3953033309084094, 0.39788221483414876, 0.7834995318094278, 0.8010378647468692, 0.8043956798069949, 0.7832332923590981, 0.7699722693196446, 0.7598383322795934, 0.7749724491495377, 0.7973180510830522, 0.8092084301044111, 0.11984026096038591, 0.11159749892631665, 0.14182878235927843, 0.15571463003660702, 0.12762388486260845, 0.13982969670736745, 0.11057502270198094, 0.15359459166560374, 0.12006992091051161, 0.2703594260290054, 0.20827976113693214, 0.6073818816394776, 0.610089749753839, 0.605049425030784, 0.17725633459300427, 0.6084330171861405, 0.5872523750210963, 0.19147691938621803, 0.6023017181297359, 0.23252613759722585, 0.5505001676154176, 0.6017301840898001, 0.5450825875496805, 0.5720596623177696, 0.6072055287579207, 0.41448417454262276, 0.5350228733568614, 0.47667083923232445, 0.4911255800086386, 0.39569503929844163, 0.5205554746063905, 0.49032252098057094, 0.2846975693926793, 0.2562925808679961, 0.21848303595231777, 0.21295335581871844, 0.23973917276578005, 0.24223255232155783, 0.23764004577485986, 0.2361053618262985, 0.2875951370593638, 0.19584781975207055, 0.24253346062323455, 0.27089848365143154, 0.22726033845849325, 0.1937986263728536, 0.20442697961307954, 0.18981344804861366, 0.19111440243699873, 0.1825676809313529, 0.20691679678583608, 0.7124567911417712, 0.18881726423550715, 0.19239663432752152, 0.185517015709449, 0.12900172307557756, 0.16894757031118002, 0.19547959435358941, 0.1698583157251986, 0.19594938329554124, 0.15145364558760188, 0.8916999737017137, 0.8984350947273179, 0.20489733813561517, 0.8741483712274954, 0.8906940655134181, 0.15280459265843094, 0.7735758143199023, 0.20901177117582692, 0.8518314275689041, 0.8854481757103392, 0.8763125912712286, 0.20194642351931213, 0.1846829182261127, 0.20331935791349154, 0.18389571022020312, 0.19483042548711382, 0.1930015469293348, 0.1843837470943095, 0.18586763701326647, 0.1922977150636347, 0.09883330673050894, 0.10487090801571175, 0.0959666144505914, 0.10258609830407517, 0.1327591145516812, 0.13913572417277154, 0.09213916303917902, 0.09478918197592645, 0.09420640827954174]}, "mutation_prompt": null}
{"id": "3eaa7135-d779-4244-a5d0-df50ea1edaf1", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Enhance adaptability by introducing dynamic scaling for the cognitive and social components along with a temporary learning factor.", "configspace": "", "generation": 52, "fitness": 0.4371224910432304, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.28.", "error": "", "parent_id": "4bdd8d27-9b15-4a08-8106-f99576267995", "metadata": {"aucs": [0.8554214317820894, 0.8645638794899033, 0.8680207848636206, 0.8551736787412569, 0.8495624361274682, 0.8556311458888262, 0.856565820438986, 0.8502427358623549, 0.8484294176277175, 0.6811546308213443, 0.6932119789081492, 0.6965979157221354, 0.6663375332408201, 0.6930409424235826, 0.6757804646498398, 0.6328013652068173, 0.6103899314703503, 0.6264991821501602, 0.10848727384886203, 0.1143486705978638, 0.12195757810787833, 0.15158446441715, 0.13235469979716485, 0.15840213776415335, 0.1134271643158854, 0.14018956223627066, 0.12021172017780535, 0.11343598445907777, 0.10253154826590183, 0.1203444776911734, 0.1095319186030379, 0.10611851347075629, 0.10526664661896412, 0.11466368211988776, 0.09703910059413046, 0.10671053383405305, 0.902199098560707, 0.8689267016266328, 0.8618694669909304, 0.8863097481177263, 0.872616004906019, 0.921598423035086, 0.8994933343871419, 0.865041314281011, 0.9134836638828535, 0.7069252442258719, 0.7175145514136105, 0.704121173449162, 0.7279243281088591, 0.6983280291430893, 0.7150232743415939, 0.6970354410193391, 0.7269519851737859, 0.7211752737216142, 0.8891852064751143, 0.22587905933674424, 0.22630654086277135, 0.2771665062841956, 0.8914929102228125, 0.8593457910743474, 0.17628883007981988, 0.1767613290963771, 0.8736646106943994, 0.6133880169001398, 0.6586373655249331, 0.689545830543234, 0.6683993841710988, 0.7103894751060921, 0.5924825901576329, 0.5827313562896661, 0.13042121931941364, 0.6353162154062839, 0.6616346561045188, 0.6098965533484841, 0.6360531256560302, 0.6726928991656795, 0.7142206142465538, 0.6639522527839941, 0.6493568150210114, 0.5827529403118005, 0.6607575118243765, 0.3495617439903038, 0.5436935091579413, 0.43161329515699964, 0.3739183654792948, 0.025281184045176097, 0.22170390638595394, 0.39126626450352153, 0.45229412910092204, 0.4790498592020491, 0.4881013048690299, 0.09688647431711539, 0.17654037114042442, 0.12492488004076963, 0.0739261685829179, 0.14870499514914626, 0.3998316911165102, 0.4281420820276238, 0.1793046525937252, 0.32510635189524506, 0.4399280677764372, 0.4596692127005221, 0.4818981165777525, 0.1855645946605935, 0.32356273670421554, 0.37354496489401723, 0.27119723866325074, 0.26110280558950194, 0.48741801634570014, 0.4519143891039774, 0.4717695782151279, 0.4805161645493341, 0.5470827608461506, 0.5374421043335755, 0.5246169273285788, 0.45441321431208104, 0.3737589520489133, 0.8109327974171068, 0.8031324301963862, 0.7877840911972297, 0.7930226641685806, 0.8024834054220931, 0.8078516962350463, 0.8081555465997753, 0.816431402906808, 0.8125784913392904, 0.09348047926819014, 0.12782142266604601, 0.07399759536804706, 0.14149351971140134, 0.09323346363893181, 0.1813949511643942, 0.181543469723346, 0.11895544465878882, 0.1261889733917393, 0.6136498254735325, 0.6075469345068445, 0.20030672009720063, 0.7036904485754456, 0.7259372844086482, 0.33139564897484175, 0.2637287956267603, 0.25547984244924704, 0.2691516916841876, 0.4807861944885464, 0.2886982305632274, 0.22689317191117975, 0.5202967478174033, 0.29775351376109327, 0.6459212509475671, 0.2649965538062694, 0.4221949914705151, 0.564646150328135, 0.26107815243263466, 0.3716271614828579, 0.24546236470518457, 0.3018483914004291, 0.2649395576793654, 0.43387456726282503, 0.24358716852827322, 0.2933824874718428, 0.2513594125208767, 0.237695522729383, 0.3133193190081627, 0.23302433138684975, 0.2090700581304118, 0.2580526450587578, 0.26742167423338126, 0.2598134231990019, 0.24353934709477598, 0.20943491490010013, 0.2061630138877938, 0.24642112012151052, 0.1905329835759746, 0.19919938442079255, 0.18575851684005562, 0.18003763757755875, 0.18988294672066186, 0.18129413685748108, 0.20593039182520734, 0.18574110551536083, 0.8734553127302179, 0.17173275231442642, 0.9156946322496907, 0.19839347427784282, 0.17194497526802022, 0.8726753089042263, 0.889326165374468, 0.9030062591556629, 0.9040348080886559, 0.2117178168211723, 0.875547338141549, 0.20872259343368382, 0.8505477669616635, 0.8306117968740664, 0.16643814072541896, 0.16752353415993726, 0.8196040222034424, 0.17427533651898852, 0.19819962774445188, 0.18499665827294864, 0.18799483253135618, 0.22234605876669944, 0.25322415901179396, 0.1795369737001693, 0.18645990297465298, 0.22668043226293288, 0.08852918747315375, 0.09435538023587065, 0.0948666228655185, 0.09814047167597695, 0.09853251665257268, 0.09127416119156928, 0.10280038521158097, 0.09026125424415965, 0.09542113965547983]}, "mutation_prompt": null}
{"id": "0c90175e-3580-40ae-829b-9d7f3687b819", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n            learning_rate = 0.01 + 0.1 * chaos_val  # Dynamic learning rate\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + learning_rate * vel[i]  # Apply learning rate\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce a dynamic learning rate and chaotic perturbation to enhance exploration and exploitation balance in HybridPSO_DE.", "configspace": "", "generation": 53, "fitness": 0.14771665354068245, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.10.", "error": "", "parent_id": "3eaa7135-d779-4244-a5d0-df50ea1edaf1", "metadata": {"aucs": [0.486210220675817, 0.34169304109866394, 0.40033075513789185, 0.2676315890440133, 0.25801362161728747, 0.2839227312588435, 0.2944618274490989, 0.36442220572868045, 0.2853621409009576, 0.02026326655930022, 0.035331342444588354, 0.037339928704595904, 9.999999999998899e-05, 0.0945567986186534, 0.05674984633311775, 9.999999999998899e-05, 0.07844003874870087, 0.04240421457859633, 0.08431225063905534, 0.09479266339603021, 0.08500119394532102, 0.09212604559686444, 0.08296432336497528, 0.08540251712363223, 0.07750682062990766, 0.07673939229305105, 0.08006413007036639, 0.07325475666845482, 0.06730400003457271, 0.06590301689134848, 0.07169662932098364, 0.06565227360096249, 0.08639296786911088, 0.08036987441550225, 0.07131110229298232, 0.06342701275244378, 0.22899836054623635, 0.351973822031141, 0.10762117090307965, 0.13054739908526203, 0.11447045484298501, 0.15021671983720608, 0.1467002534858881, 0.10877652862254095, 0.17063514891824305, 0.1518156252653109, 0.12750380809416895, 0.12347083590640995, 0.16435100425155924, 0.1420897210503297, 0.13199818101926153, 0.13743430896379927, 0.1081665303221867, 0.13798746354071845, 0.24393977623118823, 0.23798168813179132, 0.2271499854157727, 0.21554677821882007, 0.22850386264721845, 0.17419557792962437, 0.1752453993139046, 0.1710806887535622, 0.22210137990674816, 0.10037268643506159, 0.0808400650546024, 0.06728003246855008, 0.09464866276276229, 0.0860168844518967, 0.07843341273396054, 0.10177989086391204, 0.0960597324216167, 0.09180931115290714, 0.08563585351964287, 0.09655545977483948, 0.10650670736152223, 0.08485210910549357, 0.0950933382398409, 0.09252549157465018, 0.125246444294548, 0.09857061313424764, 0.10780610475186947, 0.00434480847734009, 9.999999999998899e-05, 0.0019182734174705285, 0.01728262794594615, 0.012874341968023284, 9.999999999998899e-05, 0.016035385302619942, 0.005776766464041239, 0.034484791277588744, 0.08703680732294361, 0.12334945268043407, 0.14166389531902646, 0.04498162797904093, 0.06544588167616772, 0.07012621583867495, 0.13940852530886638, 0.07779942410999408, 0.06422008741754959, 0.017410445548563858, 0.009208655758659146, 0.00024866230538700407, 0.01097124170124375, 9.999999999998899e-05, 0.01152949618717558, 0.00040215356358241916, 0.0035021406181358072, 0.005419674248765105, 0.03187253208290253, 0.03526801048765005, 0.0475564666713435, 0.03432925325262148, 0.030413354936222325, 0.05158262969181815, 0.03746591149537104, 0.032139671589082486, 0.05066262277543443, 0.32339489103382, 0.3490252570165312, 0.351435255214543, 0.3326406430172245, 0.2824545125718657, 0.2995979952873684, 0.3462945937901337, 0.34383990167596745, 0.3199213222935191, 0.0646226197674532, 0.060513016247667806, 0.0681742721062355, 0.10684349121461545, 0.0736827292644322, 0.099612761352178, 0.0836962186783261, 0.07791200517081465, 0.09940457045698314, 0.14337156925548789, 0.13350204438832136, 0.1485744719384502, 0.1547665357538377, 0.14815128114237996, 0.16236429687021614, 0.1547254027550865, 0.13450864401526175, 0.14199016342247306, 0.20835507279707743, 0.20745286760549675, 0.2189937319061911, 0.2581187493076239, 0.23258084312852256, 0.2456043759684835, 0.19790981779896488, 0.2396599123497315, 0.19408619621345302, 0.15005982860477507, 0.14419507183526326, 0.15356952149890601, 0.16401791431475832, 0.18373238428314298, 0.2029601454235892, 0.14655590407664565, 0.16975996956575878, 0.15103790175791543, 0.20703746003993173, 0.19854287199619525, 0.2185645345518431, 0.21234411217110105, 0.1971548707141626, 0.20914155922785294, 0.21507575247024024, 0.21001204279640961, 0.20545701088774804, 0.15446833661264303, 0.16594828251816396, 0.1598437993265115, 0.19028136720995248, 0.17217143478159103, 0.16877255718597806, 0.1746841672118964, 0.1651149727082255, 0.16605389197420795, 0.2187567383594773, 0.16569529531216576, 0.20963613038390816, 0.44407357417841264, 0.3474928924403422, 0.1790184669528515, 0.43462293144566566, 0.2981253339294393, 0.39838072337457664, 0.4100984866901163, 0.3000603421230059, 0.2784330682316233, 0.3081384148628816, 0.17312232349093937, 0.4104124069123648, 0.27216024195695365, 0.2206042719610135, 0.2191971832862457, 0.17400314986307863, 0.18840771731385264, 0.18296531509082592, 0.18235603366232778, 0.1906962883614829, 0.18943860530079315, 0.19468390338750186, 0.18163795317508125, 0.19062429053177943, 0.07523278770835751, 0.08012846985627498, 0.0760422649798389, 0.07374634929692547, 0.07600106443726129, 0.09040560334462155, 0.07667940879041435, 0.06921809403301027, 0.07303969267891042]}, "mutation_prompt": null}
{"id": "b7596654-0d29-4526-b040-184a910e77f8", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Initialize particles\n        pos = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(self.population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(self.population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(self.population_size):\n                # Adaptive cognitive and social components \n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i])\n                          + 0.2 * (np.mean(pos, axis=0) - pos[i]))  # New term for enhanced exploration\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Enhance convergence by introducing an adaptive learning strategy and chaos-driven velocity dampening to the HybridPSO_DE.", "configspace": "", "generation": 54, "fitness": 0.4161893074387788, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.28.", "error": "", "parent_id": "3eaa7135-d779-4244-a5d0-df50ea1edaf1", "metadata": {"aucs": [0.8541246452320708, 0.8380081384403619, 0.8525716741968017, 0.8408387712285619, 0.8438538454105321, 0.845100539389603, 0.8576261079196417, 0.8477648739977318, 0.8431941211530285, 0.6393494766306493, 0.6829105357127757, 0.6872235939671987, 0.6557228178299204, 0.6252750741974165, 0.6513311277096533, 0.640516461889127, 0.6754575210961176, 0.5970929507571892, 0.0870203973673922, 0.14204829737463498, 0.07681388890751373, 0.13795932928333, 0.1324614558041003, 0.1136660682131202, 0.11458340694672575, 0.14155605288351836, 0.15724365190113532, 0.12119139807909285, 0.1110729721803998, 0.07710286828390067, 0.12981877263765695, 0.10891593452579795, 0.08440329419024362, 0.10704709197827267, 0.09768680104202865, 0.09049888799860495, 0.8897800984482453, 0.8745138198825979, 0.8604796655434821, 0.8743766040687198, 0.8546201783114757, 0.8925699410755046, 0.8795750040516267, 0.8765285344786369, 0.8802369487858498, 0.6967193595892902, 0.6910551178334512, 0.691039648861827, 0.7309359312386188, 0.699975311928378, 0.6885688405199859, 0.7065226567275553, 0.6754736801140969, 0.7067116336399889, 0.2277330644045359, 0.170134666594302, 0.2276918098586812, 0.2773861284884154, 0.2755376443379459, 0.20957906797755965, 0.17621347104623541, 0.23317902280299718, 0.23601196217214104, 0.6775950990319054, 0.12795287254798715, 0.5366054836058534, 0.6857549027336961, 0.6894099263248172, 0.6521838915599287, 0.6326005818855449, 0.6634683178464499, 0.6491931622078515, 0.5740464612229406, 0.5890795841102399, 0.6296483710794909, 0.6559210554503436, 0.6057207004803866, 0.6478398286935685, 0.6121460977785613, 0.6314212221439874, 0.5609864644529554, 0.20656583393453742, 0.22489450135262878, 0.2714233314406418, 0.5960162034624892, 0.5129210629366941, 0.13074352122611255, 0.3532166981272672, 0.34914092007989916, 0.4876024058774686, 0.29883498537868447, 0.2293332408637455, 0.1529958423522596, 0.07308410390727782, 0.06257114995364388, 0.05718792758900604, 0.12097860460914966, 0.1891867893358069, 0.1576006235819617, 0.35977419895339546, 0.3088026378658225, 0.5719801682060845, 0.10997035408406519, 0.36610237709647653, 0.266077435834832, 0.1826114539191147, 0.16849524801771187, 0.39811951184293226, 0.3935683987630988, 0.45259283819893603, 0.42287537971340117, 0.45327652775894467, 0.5103652856162655, 0.4935203781900406, 0.3503361100429586, 0.4121847873687152, 0.3641745999406736, 0.7971195528594432, 0.7779685000831882, 0.8104375599514819, 0.770673023057809, 0.7867944316308653, 0.8061674555713606, 0.8011200052107956, 0.7938595474768061, 0.8040236157522409, 0.1384254822172657, 0.10778417367240545, 0.07871150138202343, 0.15547064754044548, 0.11346064195968542, 0.10387923626893958, 0.1402092944087584, 0.13471592726316106, 0.0915850395667579, 0.6928103133396101, 0.650553074671908, 0.6269403077124788, 0.6931916286370505, 0.6905804599993092, 0.6979820256417264, 0.6760007546542939, 0.6914208473449921, 0.668690440008262, 0.2813010900382874, 0.5741106502564193, 0.4820673080913028, 0.5335257186172291, 0.41814009890798154, 0.4386463395109258, 0.24545715402690216, 0.27229440131442173, 0.26676336591924066, 0.2732198945535661, 0.4038950239792144, 0.26234431313247386, 0.3254880478147941, 0.38356249829741096, 0.45646719896371346, 0.23003447882189076, 0.26612767877604593, 0.2656413412504638, 0.2666268240863584, 0.23040629132145163, 0.2138051680046208, 0.21694959665786073, 0.2410807446526888, 0.2378557212713217, 0.215037885589196, 0.22448549364597326, 0.26998188447302396, 0.1847116259804047, 0.17966553286617526, 0.18724684750929688, 0.1896799472257591, 0.18766081800083179, 0.18715078890439218, 0.17575063300585803, 0.1840372764292717, 0.17117359672609722, 0.9027486327426157, 0.18654380266827253, 0.1747627431079971, 0.9012483448000312, 0.1988875450541755, 0.1725702209356763, 0.175130277268433, 0.9001378052153944, 0.1517673431194526, 0.8831563932860474, 0.8271446314850796, 0.8520032374407388, 0.21012554996625155, 0.8462852146691733, 0.8391215103120513, 0.16697822823424846, 0.8297078346811948, 0.16634455468795528, 0.19096245100366993, 0.177047257338378, 0.18306346902187465, 0.1828670804751128, 0.1737979544074003, 0.18108487172695675, 0.20645263288433546, 0.18655015435775635, 0.1742075823687348, 0.0945964161083348, 0.0923536024966699, 0.08635597417874308, 0.09402814097227019, 0.09836803432745678, 0.0986575234080328, 0.0807471944044248, 0.08848090640784845, 0.08673440499025564]}, "mutation_prompt": null}
{"id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Adaptive swarm size\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce adaptive swarm size for enhanced exploration and exploitation balance in high-dimensional spaces.", "configspace": "", "generation": 55, "fitness": 0.4806201462788973, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.30.", "error": "", "parent_id": "3eaa7135-d779-4244-a5d0-df50ea1edaf1", "metadata": {"aucs": [0.8980982671425689, 0.8903620049616174, 0.8988530611711405, 0.8932545471037056, 0.8879154653212531, 0.8890776578998386, 0.9042764617925443, 0.8948881339175825, 0.8926399277431314, 0.7908067798577216, 0.7963171525200662, 0.7691463443415147, 0.7861521281885755, 0.7384137833213005, 0.7650494658557858, 0.7466613163384963, 0.8042553946121596, 0.7401977461471319, 0.09686491762940641, 0.145015521164934, 0.13954667723027014, 0.08883147126247481, 0.12158071203809828, 0.14246759369462292, 0.08543604575781005, 0.11651216537128928, 0.1162232479695906, 0.10534666367404988, 0.1086401808715809, 0.12403561892945958, 0.1227838869170047, 0.08498647002862958, 0.12356918866601574, 0.11000272194217109, 0.09543067418859152, 0.10413182813264699, 0.8958457553630623, 0.9246980758595659, 0.9323430571211943, 0.927032995465498, 0.9357906118174969, 0.9219894036722209, 0.9257246401286136, 0.9238429026721982, 0.9158375560873677, 0.8099376705121574, 0.7859071482188211, 0.7918956257504677, 0.7988631115655729, 0.7660517694318512, 0.7997006651978558, 0.8038183917965578, 0.7797472939535286, 0.8205850281208377, 0.38807573057643796, 0.17149815958416603, 0.9105896054967318, 0.27820565968291533, 0.27906288564467063, 0.2135173465459378, 0.17567178859102317, 0.23475900167451713, 0.23639384099425564, 0.6891818550484219, 0.7413015948242958, 0.7375993174483211, 0.6921773842727268, 0.7851112254472163, 0.8121672872946074, 0.7335859109949809, 0.691808571318207, 0.7438793313686154, 0.705381006632888, 0.6886452689873384, 0.6742593630228897, 0.7691078317494832, 0.7354137983733264, 0.716902588099091, 0.7246718764776938, 0.8182057555730377, 0.6973296071471353, 0.524893278044298, 0.4296464440984693, 0.5493206255078452, 0.6230360912480866, 0.6847390247958334, 0.5104569876012623, 0.35558761012610474, 0.05774367894119936, 0.6149010330788307, 0.4836028770289629, 0.1388648764035899, 0.25062484185558664, 0.09340076878800885, 0.1494128162296724, 0.18668711084426837, 0.6545725008506056, 0.4982670797334592, 0.5937474246296442, 0.653771929586086, 0.5439759084240299, 0.45045689671437106, 0.4063654786256097, 0.38795635816597174, 0.32685456056179707, 0.1725896044098516, 0.25776338338783733, 0.2080706296499335, 0.5485038800943953, 0.5709549654799707, 0.6339652926559953, 0.6283242778850056, 0.6302775999301897, 0.5094604233391413, 0.6604543331652382, 0.6183887924627371, 0.6634161129421416, 0.8591162780685626, 0.8505580464302733, 0.8394734888313469, 0.8622647211860525, 0.8390210774642543, 0.8752653826045191, 0.8507340190038861, 0.8617439993919205, 0.8616848052623161, 0.11452668487522444, 0.08228366196261327, 0.09726637485734013, 0.18664310345540502, 0.10972184044380551, 0.12373335059792623, 0.13179927379653944, 0.16048668281489276, 0.09687209892983262, 0.7873333939552076, 0.7843569123740535, 0.5856973986138074, 0.815023028448911, 0.2761734433558286, 0.28614424771092883, 0.4092221860622195, 0.30768046306464614, 0.6135558264340026, 0.2130167059980066, 0.40232050913594075, 0.40551795513375866, 0.6511583344603477, 0.6369067104320095, 0.6129057971117586, 0.268607726949018, 0.5469124533101808, 0.2703053765794261, 0.19427000405457895, 0.6913011763681616, 0.3472487640823215, 0.4338078050637949, 0.18869346325186942, 0.334133580159647, 0.23807541446036917, 0.27394981901033266, 0.2804557103015498, 0.23814228457314124, 0.28805358365635503, 0.20806208085382683, 0.28191557864204553, 0.2875265961561123, 0.23246959346219032, 0.21567681290459673, 0.21630425114797203, 0.27832859324631964, 0.1990356445113528, 0.19024722065370958, 0.18835444382472055, 0.1996563884567848, 0.17782043899333622, 0.19293191137465648, 0.20830239769180137, 0.19119739874781738, 0.19971124404113327, 0.18733477652643205, 0.18751372198126215, 0.18802518346360553, 0.9358614324669595, 0.9151489283521499, 0.9221329925234291, 0.12219346890577631, 0.16849441433361156, 0.9258514390751847, 0.8943999291853538, 0.15605264424403797, 0.8732948373149961, 0.9011077453515852, 0.20976578610640595, 0.8817999887606904, 0.8894531210946778, 0.9097457428995559, 0.8655539921416153, 0.2182757247435193, 0.3931197577417541, 0.20661701820504463, 0.2094791961050969, 0.19407375695983076, 0.22219575385724, 0.1917059374736374, 0.49110901131392015, 0.18237599994301013, 0.08269495088094825, 0.11202492921654816, 0.09128963233290566, 0.0955950188635255, 0.09517469951281565, 0.10703495486968928, 0.08873425526346068, 0.09697454066689548, 0.15709873817077824]}, "mutation_prompt": null}
{"id": "2e1c0854-0f88-46e9-a593-c60f2824be3e", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Adaptive swarm size\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] *= (0.5 + 0.5 * np.abs(np.sin(0.1 * eval_count)))  # Adaptive velocity scaling\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce adaptive velocity scaling and chaotic inertia with mutation boost for better convergence.", "configspace": "", "generation": 56, "fitness": 0.456997136182101, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.31.", "error": "", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.9217830179635517, 0.9145710490299016, 0.9228058033991877, 0.9111894074742064, 0.9163829843617489, 0.913093670213496, 0.9171257504889259, 0.9168889058169929, 0.9172038416775429, 0.8325360423044659, 0.8189282709033913, 0.7914824934643301, 0.8167238655319975, 0.787500475578683, 0.8140982144428721, 0.8226243109970007, 0.8139070956726344, 0.8171008719558306, 0.09630717719884074, 0.1629933002874644, 0.09293243852942978, 0.10162267865668195, 0.11168702232599403, 0.12487821706030411, 0.08613386461470163, 0.09656872166659136, 0.11737264325043273, 0.09230548094692859, 0.07480230311227365, 0.13342056159461713, 0.09650629989408466, 0.13235761588753014, 0.09664685791151884, 0.10117436884304554, 0.10156806910259553, 0.0826390494713769, 0.9005652497853176, 0.9007788740838539, 0.9247566917064232, 0.9199464363008973, 0.9262594559901163, 0.9204711351164495, 0.9116128711284954, 0.9013073456437279, 0.9051183182031004, 0.8345757395152922, 0.8487444029284621, 0.8446753423161177, 0.8396982620894632, 0.8133090629423934, 0.838243678457729, 0.8458636714997965, 0.8202730101390416, 0.8287162607672729, 0.3937801227025227, 0.2297431898754171, 0.22883849536176504, 0.28060644562813764, 0.21239553200813266, 0.21341999525956212, 0.15090507251676755, 0.17739384135007552, 0.23646485064923994, 0.811231159498514, 0.8278002652046176, 0.13461898886534873, 0.13289120832708068, 0.8399701622219566, 0.8441067387640506, 0.8532062346274092, 0.7480834215406056, 0.7979614463146987, 0.7956163472629395, 0.7580564817388464, 0.7185060147855389, 0.7847477896592971, 0.7802111100930301, 0.7669897556991948, 0.7374584088529357, 0.8319103332397406, 0.785575918188801, 0.2318474443160108, 0.5494527289145883, 0.3424665720013974, 0.2700192310814533, 0.3671853893128265, 0.310090339541777, 0.13299190827207563, 0.3769377763909936, 0.2558695863401186, 0.16003196228132144, 0.17250995857777052, 0.7098963464476522, 0.2569801428016443, 0.2262417722950525, 0.14050420083869108, 0.7376457134198002, 0.3889553446114762, 0.16437713889791683, 0.3570446642215951, 0.28640935080741925, 0.4539060123125477, 0.42236484174188305, 0.5223414630962016, 0.38828241872184466, 0.2283404609152273, 0.3191844252318461, 0.2676963962970944, 0.4759085644569283, 0.6589516712007948, 0.40464738774337383, 0.48946612990055627, 0.6694373677664167, 0.6212694537737522, 0.6005888746498238, 0.6179786893015498, 0.3972336193560009, 0.897658887064136, 0.8491485700874274, 0.814951265724531, 0.8454747675975353, 0.8655151792547345, 0.7751312107013073, 0.8883911332030995, 0.879699925168612, 0.8364352979292762, 0.11139025752150522, 0.09304011572713045, 0.028447742439953294, 0.12559484628170126, 0.12231729902870048, 0.13180956400635246, 0.11573887003970063, 0.09354945236365453, 0.1102396139734203, 0.3953324943201254, 0.7747766753259724, 0.27009541205702603, 0.23299452625953532, 0.8311728901473425, 0.27807212663348435, 0.8251724663530245, 0.22292834616538504, 0.2934094073642731, 0.27573992587702145, 0.40934069516023197, 0.5582440191065519, 0.3807371777705205, 0.2765229450987945, 0.5637545893453613, 0.2623117267586047, 0.5707733061764706, 0.26859429793805756, 0.14441388880445227, 0.15508601608935657, 0.31037519315748163, 0.5843457487086601, 0.2452716915380534, 0.4518491072285913, 0.24121719303881395, 0.30929039991451723, 0.24619718202755325, 0.2974669076881806, 0.2305771990375628, 0.255658146077849, 0.26200862675016845, 0.2871960233439349, 0.26291531755464304, 0.25468140101575854, 0.2475453937234372, 0.19606829958830763, 0.19559969253995546, 0.1794101382568133, 0.21711236113949217, 0.2268142593489827, 0.8789147794729835, 0.1790688003751273, 0.18299216939544538, 0.1919430150797542, 0.19047345817749484, 0.1770558875923871, 0.1876836770118001, 0.18805289625159582, 0.9407184270472592, 0.9249868269545606, 0.9337342769642047, 0.1365614562021512, 0.16623190042803893, 0.17822046360000732, 0.9221317947999789, 0.1564324652035386, 0.9228890369663212, 0.21008171059588998, 0.9162043096469537, 0.9086866654681316, 0.10466777367447433, 0.9287136786389665, 0.8569203595224524, 0.18344833425701768, 0.22465733339277416, 0.19724647676913398, 0.23530501759323041, 0.1749980006499936, 0.22128724684339018, 0.4527753453116766, 0.20349940708418013, 0.23926450953883704, 0.10049034386539824, 0.1055930378545894, 0.10045463850574665, 0.09815146132721242, 0.08912332164194958, 0.09273303340166272, 0.09670697059623512, 0.11156625228289563, 0.08478441448647878]}, "mutation_prompt": null}
{"id": "c5b6b040-8155-4530-9fdc-4c4b5085b03a", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Adaptive swarm size\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[c])  # Fixed index bug\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR * (1 - chaos_val), mutant, pos[i])  # Adjusted CR\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce adaptive learning factors and a novel chaos-based control parameter to enhance exploration-exploitation trade-off.", "configspace": "", "generation": 57, "fitness": 0.4156637211501714, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.32.", "error": "", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.9292078026384742, 0.9239342911710529, 0.9247281929768182, 0.9207331399325225, 0.9104542243710637, 0.9239100806361378, 0.9235517177714941, 0.9188409796002058, 0.9205345281655857, 0.8364431904798252, 0.8504994121999753, 0.8435203931171427, 0.8526448622524098, 0.8117994794522976, 0.8356619065199687, 0.8238406521473456, 0.8381687427339152, 0.8037524153491129, 0.08914286730881726, 0.11750855327509102, 0.09687790632743531, 0.11759190747970916, 0.11814265687406533, 0.11206854823157231, 0.13167316869106815, 0.18879527610905034, 0.12515690086510278, 0.10109934206452131, 0.13155036179257062, 0.06433976507540917, 0.08646717330386022, 0.1003569830775295, 0.10056734566132997, 0.0889647919495663, 0.0922845140757621, 0.09634261274144651, 0.9274758140986272, 0.9424011347503534, 0.9350931330255075, 0.9266380043125262, 0.931723411032183, 0.9378648585383247, 0.9250038321991803, 0.9348204021852016, 0.9319943620915953, 0.8509209740992915, 0.8575042215454165, 0.8434953944841661, 0.833867038053773, 0.8467083004389704, 0.8123640576612702, 0.8588506138015256, 0.7822999785837059, 0.8664175451828657, 0.4009900661339728, 0.22962977174359533, 0.2294579272536731, 0.2788927444084539, 0.2793774880220775, 0.3834889918724047, 0.17784616615945792, 0.17747398444671325, 0.2958697271727009, 0.7501993773439312, 0.7515425492124445, 0.7684333702268487, 0.7503874607377822, 0.7121850243378118, 0.8199541078223791, 0.7642189921292846, 0.13355046254678637, 0.8267144954519442, 0.6790222378705888, 0.7171152076207363, 0.7714030974791556, 0.7602042177084134, 0.7565769193522849, 0.7213771121866185, 0.7420093986544316, 0.7401250983083358, 0.7136495907881915, 0.15315597744988296, 0.08437819325318774, 0.09988332424758706, 0.12430347791049023, 0.09994648969016451, 0.09934977755306496, 0.11343298995112805, 0.48662582713200486, 0.1725462426519334, 0.20069098420369325, 0.09915967301474415, 0.21332413038060793, 0.08048615104614787, 0.056620649536986645, 0.05937698520300039, 0.19253730872981456, 0.1733829766889159, 0.18534950089752034, 0.3641901959854027, 0.17077547367134593, 0.28681637691566353, 0.08195920416859792, 0.33396396688644236, 0.22547776722204382, 0.2650117084660687, 0.21767506402818604, 0.13761358146151725, 0.2623724243987756, 0.29200147653088104, 0.2999406739452064, 0.21331397101007, 0.37450009695199404, 0.30635228320461994, 0.27295989357166217, 0.18750334099012844, 0.17701646650095104, 0.826137268430122, 0.6434551495131927, 0.6782629630617623, 0.7578141683674822, 0.6396315864181825, 0.6760237990497489, 0.71923462740287, 0.7827020066542415, 0.7324122175428487, 0.09678367311436109, 0.07185611369249367, 0.04947455601493145, 0.13375201655199576, 0.09676323262104014, 0.08090487784021572, 0.1593341531518241, 0.13278010647929628, 0.09707529636796575, 0.26391028460239896, 0.3888663599712242, 0.19157184629584179, 0.2684177392018896, 0.3706039641231227, 0.19864497550041926, 0.2598493541122847, 0.29036819610546694, 0.2956225403925118, 0.4297286530311103, 0.18852468511647025, 0.48475730537452744, 0.25314003077936853, 0.2707613783889884, 0.29893549473494163, 0.22817247452416012, 0.5405622149291872, 0.480200773215659, 0.13306872746107368, 0.33847615621398897, 0.24485722903101959, 0.23087157811549874, 0.22052082157300146, 0.24899651535446377, 0.19761964436255686, 0.47222612528655794, 0.21942121323466968, 0.329638822693782, 0.2818473982630195, 0.2882387253055436, 0.2588366684083394, 0.23823797239191558, 0.2171654375633736, 0.30992328241856026, 0.2636006662832462, 0.30475940812097113, 0.17825411325730034, 0.1930607447734174, 0.18632905544466483, 0.2130791250904278, 0.16281166544175052, 0.17793796501149572, 0.18998946785146387, 0.18290686671904588, 0.18526215228200804, 0.1261540033342795, 0.18755491240941569, 0.1532709397550165, 0.9528885008643532, 0.20091591239367979, 0.9472550026706146, 0.12213173077031458, 0.9497537445710621, 0.9437464807497637, 0.9461677740745092, 0.9017452453862347, 0.9073313022034392, 0.9100106083806037, 0.8737999610005964, 0.911089184103254, 0.10499571213005932, 0.16754347987021634, 0.8910302712456177, 0.1946632568891279, 0.2100473215982952, 0.2175292096560707, 0.2105236028752855, 0.23266929752650878, 0.1961942607535755, 0.24319536147698106, 0.2073785073967579, 0.23846611966251308, 0.09016352729309696, 0.12472736051232092, 0.0815930012231223, 0.09610876318989048, 0.10342933682073596, 0.07945544244653646, 0.10177672015863737, 0.11182607957900215, 0.10896822789305038]}, "mutation_prompt": null}
{"id": "35457987-5d5d-45a0-af8c-7f6c02dac89c", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Adaptive swarm size\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce adaptive swarm size for enhanced exploration and exploitation balance in high-dimensional spaces.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.8980982671425689, 0.8903620049616174, 0.8988530611711405, 0.8932545471037056, 0.8879154653212531, 0.8890776578998386, 0.9042764617925443, 0.8948881339175825, 0.8926399277431314, 0.7908067798577216, 0.7963171525200662, 0.7691463443415147, 0.7861521281885755, 0.7384137833213005, 0.7650494658557858, 0.7466613163384963, 0.8042553946121596, 0.7401977461471319, 0.09686491762940641, 0.145015521164934, 0.13954667723027014, 0.08883147126247481, 0.12158071203809828, 0.14246759369462292, 0.08543604575781005, 0.11651216537128928, 0.1162232479695906, 0.10534666367404988, 0.1086401808715809, 0.12403561892945958, 0.1227838869170047, 0.08498647002862958, 0.12356918866601574, 0.11000272194217109, 0.09543067418859152, 0.10413182813264699, 0.8958457553630623, 0.9246980758595659, 0.9323430571211943, 0.927032995465498, 0.9357906118174969, 0.9219894036722209, 0.9257246401286136, 0.9238429026721982, 0.9158375560873677, 0.8099376705121574, 0.7859071482188211, 0.7918956257504677, 0.7988631115655729, 0.7660517694318512, 0.7997006651978558, 0.8038183917965578, 0.7797472939535286, 0.8205850281208377, 0.38807573057643796, 0.17149815958416603, 0.9105896054967318, 0.27820565968291533, 0.27906288564467063, 0.2135173465459378, 0.17567178859102317, 0.23475900167451713, 0.23639384099425564, 0.6891818550484219, 0.7413015948242958, 0.7375993174483211, 0.6921773842727268, 0.7851112254472163, 0.8121672872946074, 0.7335859109949809, 0.691808571318207, 0.7438793313686154, 0.705381006632888, 0.6886452689873384, 0.6742593630228897, 0.7691078317494832, 0.7354137983733264, 0.716902588099091, 0.7246718764776938, 0.8182057555730377, 0.6973296071471353, 0.524893278044298, 0.4296464440984693, 0.5493206255078452, 0.6230360912480866, 0.6847390247958334, 0.5104569876012623, 0.35558761012610474, 0.05774367894119936, 0.6149010330788307, 0.4836028770289629, 0.1388648764035899, 0.25062484185558664, 0.09340076878800885, 0.1494128162296724, 0.18668711084426837, 0.6545725008506056, 0.4982670797334592, 0.5937474246296442, 0.653771929586086, 0.5439759084240299, 0.45045689671437106, 0.4063654786256097, 0.38795635816597174, 0.32685456056179707, 0.1725896044098516, 0.25776338338783733, 0.2080706296499335, 0.5485038800943953, 0.5709549654799707, 0.6339652926559953, 0.6283242778850056, 0.6302775999301897, 0.5094604233391413, 0.6604543331652382, 0.6183887924627371, 0.6634161129421416, 0.8591162780685626, 0.8505580464302733, 0.8394734888313469, 0.8622647211860525, 0.8390210774642543, 0.8752653826045191, 0.8507340190038861, 0.8617439993919205, 0.8616848052623161, 0.11452668487522444, 0.08228366196261327, 0.09726637485734013, 0.18664310345540502, 0.10972184044380551, 0.12373335059792623, 0.13179927379653944, 0.16048668281489276, 0.09687209892983262, 0.7873333939552076, 0.7843569123740535, 0.5856973986138074, 0.815023028448911, 0.2761734433558286, 0.28614424771092883, 0.4092221860622195, 0.30768046306464614, 0.6135558264340026, 0.2130167059980066, 0.40232050913594075, 0.40551795513375866, 0.6511583344603477, 0.6369067104320095, 0.6129057971117586, 0.268607726949018, 0.5469124533101808, 0.2703053765794261, 0.19427000405457895, 0.6913011763681616, 0.3472487640823215, 0.4338078050637949, 0.18869346325186942, 0.334133580159647, 0.23807541446036917, 0.27394981901033266, 0.2804557103015498, 0.23814228457314124, 0.28805358365635503, 0.20806208085382683, 0.28191557864204553, 0.2875265961561123, 0.23246959346219032, 0.21567681290459673, 0.21630425114797203, 0.27832859324631964, 0.1990356445113528, 0.19024722065370958, 0.18835444382472055, 0.1996563884567848, 0.17782043899333622, 0.19293191137465648, 0.20830239769180137, 0.19119739874781738, 0.19971124404113327, 0.18733477652643205, 0.18751372198126215, 0.18802518346360553, 0.9358614324669595, 0.9151489283521499, 0.9221329925234291, 0.12219346890577631, 0.16849441433361156, 0.9258514390751847, 0.8943999291853538, 0.15605264424403797, 0.8732948373149961, 0.9011077453515852, 0.20976578610640595, 0.8817999887606904, 0.8894531210946778, 0.9097457428995559, 0.8655539921416153, 0.2182757247435193, 0.3931197577417541, 0.20661701820504463, 0.2094791961050969, 0.19407375695983076, 0.22219575385724, 0.1917059374736374, 0.49110901131392015, 0.18237599994301013, 0.08269495088094825, 0.11202492921654816, 0.09128963233290566, 0.0955950188635255, 0.09517469951281565, 0.10703495486968928, 0.08873425526346068, 0.09697454066689548, 0.15709873817077824]}, "mutation_prompt": null}
{"id": "a0714d7f-d092-4a0e-b04c-3bea51985254", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Adaptive swarm size\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce adaptive swarm size for enhanced exploration and exploitation balance in high-dimensional spaces.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.8980982671425689, 0.8903620049616174, 0.8988530611711405, 0.8932545471037056, 0.8879154653212531, 0.8890776578998386, 0.9042764617925443, 0.8948881339175825, 0.8926399277431314, 0.7908067798577216, 0.7963171525200662, 0.7691463443415147, 0.7861521281885755, 0.7384137833213005, 0.7650494658557858, 0.7466613163384963, 0.8042553946121596, 0.7401977461471319, 0.09686491762940641, 0.145015521164934, 0.13954667723027014, 0.08883147126247481, 0.12158071203809828, 0.14246759369462292, 0.08543604575781005, 0.11651216537128928, 0.1162232479695906, 0.10534666367404988, 0.1086401808715809, 0.12403561892945958, 0.1227838869170047, 0.08498647002862958, 0.12356918866601574, 0.11000272194217109, 0.09543067418859152, 0.10413182813264699, 0.8958457553630623, 0.9246980758595659, 0.9323430571211943, 0.927032995465498, 0.9357906118174969, 0.9219894036722209, 0.9257246401286136, 0.9238429026721982, 0.9158375560873677, 0.8099376705121574, 0.7859071482188211, 0.7918956257504677, 0.7988631115655729, 0.7660517694318512, 0.7997006651978558, 0.8038183917965578, 0.7797472939535286, 0.8205850281208377, 0.38807573057643796, 0.17149815958416603, 0.9105896054967318, 0.27820565968291533, 0.27906288564467063, 0.2135173465459378, 0.17567178859102317, 0.23475900167451713, 0.23639384099425564, 0.6891818550484219, 0.7413015948242958, 0.7375993174483211, 0.6921773842727268, 0.7851112254472163, 0.8121672872946074, 0.7335859109949809, 0.691808571318207, 0.7438793313686154, 0.705381006632888, 0.6886452689873384, 0.6742593630228897, 0.7691078317494832, 0.7354137983733264, 0.716902588099091, 0.7246718764776938, 0.8182057555730377, 0.6973296071471353, 0.524893278044298, 0.4296464440984693, 0.5493206255078452, 0.6230360912480866, 0.6847390247958334, 0.5104569876012623, 0.35558761012610474, 0.05774367894119936, 0.6149010330788307, 0.4836028770289629, 0.1388648764035899, 0.25062484185558664, 0.09340076878800885, 0.1494128162296724, 0.18668711084426837, 0.6545725008506056, 0.4982670797334592, 0.5937474246296442, 0.653771929586086, 0.5439759084240299, 0.45045689671437106, 0.4063654786256097, 0.38795635816597174, 0.32685456056179707, 0.1725896044098516, 0.25776338338783733, 0.2080706296499335, 0.5485038800943953, 0.5709549654799707, 0.6339652926559953, 0.6283242778850056, 0.6302775999301897, 0.5094604233391413, 0.6604543331652382, 0.6183887924627371, 0.6634161129421416, 0.8591162780685626, 0.8505580464302733, 0.8394734888313469, 0.8622647211860525, 0.8390210774642543, 0.8752653826045191, 0.8507340190038861, 0.8617439993919205, 0.8616848052623161, 0.11452668487522444, 0.08228366196261327, 0.09726637485734013, 0.18664310345540502, 0.10972184044380551, 0.12373335059792623, 0.13179927379653944, 0.16048668281489276, 0.09687209892983262, 0.7873333939552076, 0.7843569123740535, 0.5856973986138074, 0.815023028448911, 0.2761734433558286, 0.28614424771092883, 0.4092221860622195, 0.30768046306464614, 0.6135558264340026, 0.2130167059980066, 0.40232050913594075, 0.40551795513375866, 0.6511583344603477, 0.6369067104320095, 0.6129057971117586, 0.268607726949018, 0.5469124533101808, 0.2703053765794261, 0.19427000405457895, 0.6913011763681616, 0.3472487640823215, 0.4338078050637949, 0.18869346325186942, 0.334133580159647, 0.23807541446036917, 0.27394981901033266, 0.2804557103015498, 0.23814228457314124, 0.28805358365635503, 0.20806208085382683, 0.28191557864204553, 0.2875265961561123, 0.23246959346219032, 0.21567681290459673, 0.21630425114797203, 0.27832859324631964, 0.1990356445113528, 0.19024722065370958, 0.18835444382472055, 0.1996563884567848, 0.17782043899333622, 0.19293191137465648, 0.20830239769180137, 0.19119739874781738, 0.19971124404113327, 0.18733477652643205, 0.18751372198126215, 0.18802518346360553, 0.9358614324669595, 0.9151489283521499, 0.9221329925234291, 0.12219346890577631, 0.16849441433361156, 0.9258514390751847, 0.8943999291853538, 0.15605264424403797, 0.8732948373149961, 0.9011077453515852, 0.20976578610640595, 0.8817999887606904, 0.8894531210946778, 0.9097457428995559, 0.8655539921416153, 0.2182757247435193, 0.3931197577417541, 0.20661701820504463, 0.2094791961050969, 0.19407375695983076, 0.22219575385724, 0.1917059374736374, 0.49110901131392015, 0.18237599994301013, 0.08269495088094825, 0.11202492921654816, 0.09128963233290566, 0.0955950188635255, 0.09517469951281565, 0.10703495486968928, 0.08873425526346068, 0.09697454066689548, 0.15709873817077824]}, "mutation_prompt": null}
{"id": "e18248d3-1536-4150-9f45-b4e0c024d901", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Adaptive swarm size\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n\n                # Introduce Lévy flight for exploration\n                levy_step = 0.01 * np.random.standard_normal(self.dim) * np.power(np.abs(np.random.standard_gamma(1.5)), 1/3)\n                vel[i] += levy_step\n\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Refine adaptive population dynamics and integrate Lévy flight for enhanced exploration.", "configspace": "", "generation": 60, "fitness": 0.29736784892924567, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.5994431315648726, 0.6087899008065613, 0.6289826078811585, 0.5933175566893343, 0.6045174399028823, 0.6238070032227453, 0.6150492221355506, 0.6242752216157819, 0.6068087847377408, 0.1769172373454445, 0.1355194695164682, 0.08502818254028588, 0.15254649198231907, 0.11399382972125893, 0.21001229531709065, 0.09126998866769487, 0.07199624726372533, 0.1736037353338441, 0.10718658734248077, 0.15901887422574912, 0.12872429353394133, 0.15771927888400605, 0.11063608503760947, 0.11686567554763327, 0.1173817982178913, 0.1432729691372806, 0.14277835865125543, 0.1325037023535095, 0.12377502804621165, 0.09107204719475026, 0.11626401848531698, 0.08811847409494422, 0.08066583478784983, 0.10525319568656322, 0.11572635446561397, 0.1423296256053862, 0.9075863749914228, 0.9328340249082258, 0.9138917628663978, 0.914906055605413, 0.9098808784318566, 0.9159528272081389, 0.9170811322104172, 0.9099361042261, 0.9046395764685088, 0.43556578999843143, 0.43446577842955214, 0.43692388689281014, 0.43366393103848655, 0.43374691450413627, 0.4403977075552431, 0.4246924796080691, 0.4565938373386581, 0.43216843531481586, 0.22998170821150565, 0.22749101250039316, 0.22830641159754106, 0.911166625203528, 0.8746714873522555, 0.19383151837725332, 0.23464560646592914, 0.23574319132910082, 0.17841680265249238, 0.25622968153792025, 0.26902807789491634, 0.29811302261998474, 0.29746330760090656, 0.2792898091450242, 0.3358291015569195, 0.30067324091247016, 0.33416949391270634, 0.3103984496013783, 0.27514809918148464, 0.2981529607107566, 0.2973112721807436, 0.23752364471563292, 0.24145329014570804, 0.1348836551838698, 0.27586157644653053, 0.2027229618934845, 0.29868700000480397, 0.10623945663669387, 0.1269366032025142, 0.046445161221593256, 0.11600250812570756, 0.12864510394467366, 0.01783563869740379, 0.07699164287380811, 0.08537035600490706, 0.15036029246951876, 0.160402798392293, 0.09226351137630995, 0.10543723722567666, 0.08962131637831483, 0.11868609871395652, 0.04915707043151163, 0.22608210099883586, 0.23997588859783503, 0.08135193344504532, 0.06594715048845046, 0.053300587152320444, 0.07234179168736232, 0.041241253981162074, 0.06046764739459087, 0.06884122934736348, 0.06641181829522158, 0.07401907590621049, 0.06142559963347616, 0.16036949448771298, 0.15947004657057873, 0.13496483865516928, 0.19507208557518219, 0.1481627631591269, 0.16995840520298477, 0.17887122915144826, 0.14765279138759757, 0.11974009037330835, 0.541154023877733, 0.5087166026335056, 0.5240698611280976, 0.542472833172376, 0.529472373033498, 0.5419601658086657, 0.5459146559963386, 0.5326394291436491, 0.5382855074088674, 0.06951842298440092, 0.06894860625605359, 0.06602672658505493, 0.11784692989512402, 0.08438231132183194, 0.1553527709927015, 0.11741585384303599, 0.14246499883725028, 0.10043091985008556, 0.41246022740273913, 0.41844445689698273, 0.4345213237393136, 0.2131114016187564, 0.40976446861326477, 0.21443455723462412, 0.39598030150082286, 0.4155862501816803, 0.32879191620402604, 0.3705034681613809, 0.38476589347990386, 0.3890424467094701, 0.37552142773128205, 0.3760257954071339, 0.38748116025582924, 0.2602225530921545, 0.37336282338530824, 0.2552944156574677, 0.2471205973221695, 0.2306453668995152, 0.13380833068855158, 0.21342696548836237, 0.2622496784482966, 0.3035562523990778, 0.24705016887076137, 0.2689379463858541, 0.23882935942207928, 0.24099469757026426, 0.25940252164615085, 0.19586819345954642, 0.2497720617668483, 0.24218567273471103, 0.2490367554062194, 0.23537161969815956, 0.2493966442312041, 0.2633925431492836, 0.19241574422516727, 0.19893695488989538, 0.1725035397295296, 0.22330515811493046, 0.17646786199205178, 0.1901261519956582, 0.18958219640291962, 0.1924125435319708, 0.22074324730032802, 0.17805417134724344, 0.18821312784183375, 0.18742777666236587, 0.17306049175384763, 0.19998658039870354, 0.19985522196319094, 0.11669575825277567, 0.8942351026284219, 0.9344281377686532, 0.8880025663688773, 0.15583703421613104, 0.8353644615185107, 0.8778441481375168, 0.8322737528589021, 0.8732894032162946, 0.8499372203454827, 0.8403479096527486, 0.8642413670005742, 0.17759688020189446, 0.1779300509435905, 0.1985172534226054, 0.19234050496930544, 0.20259011637105284, 0.20565833234569408, 0.18270667610498936, 0.18918673474676728, 0.1731995731103232, 0.09453299760988298, 0.10522747224776208, 0.08276097463407728, 0.09247821357326591, 0.10704877779863387, 0.09679169264972387, 0.08669133169885668, 0.13927844936616018, 0.10454477991995059]}, "mutation_prompt": null}
{"id": "af038597-3ee3-41ef-9893-49480ee4ff7f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Adaptive swarm size\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n                if np.random.rand() < 0.1:  # Chaotic local search\n                    chaos_search = gbest + 0.05 * (np.random.rand(self.dim) - 0.5)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce chaotic local search near the best solution and adaptive mutation in DE for enhanced convergence.", "configspace": "", "generation": 61, "fitness": 0.4740144380398054, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.30.", "error": "", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.8913558053631354, 0.8949604263419723, 0.8990102392769264, 0.8886393486118102, 0.8866555022496362, 0.8974349916391922, 0.8883744971537295, 0.8909890654083578, 0.8932063557665011, 0.7785041279136596, 0.7697480174012159, 0.7200725775433379, 0.7710219628326493, 0.7724130205876291, 0.7586703537697014, 0.768394334588447, 0.771663238592103, 0.7608141792648592, 0.16197495024199215, 0.16037850151667354, 0.0957583242319271, 0.11713967752503396, 0.15842648453101305, 0.10124175878185737, 0.11620185482628198, 0.11774078209671368, 0.1594875849525471, 0.12071226426319737, 0.10963086306054759, 0.12374693583536933, 0.10447426607508037, 0.10470201766502996, 0.1224379751147815, 0.07901114651862429, 0.06903807723688149, 0.1594664876259454, 0.9207602426688913, 0.9182372122225172, 0.9087633194017468, 0.898356975070127, 0.9131151241696254, 0.9142763167325996, 0.9291432964143752, 0.8809176388975167, 0.8988404890508094, 0.7699168735824509, 0.7927147367401571, 0.7995149504469357, 0.8015807416836367, 0.8080472942359269, 0.8207064613378422, 0.7777799059979298, 0.7869472656900506, 0.7846029650295874, 0.9208503050203277, 0.8873823023403873, 0.8438599583098574, 0.2809133557633091, 0.28037442107378474, 0.9104267064181792, 0.15178258749187223, 0.2339879086769413, 0.23341359406249462, 0.7653112103799448, 0.7684093134349718, 0.7184907905106135, 0.7020886024958656, 0.7319265306734315, 0.7151598764012531, 0.7007613159016142, 0.7049094529144855, 0.7279020826705647, 0.7877660078379568, 0.6523402920758421, 0.7994517322174723, 0.7658421065047679, 0.6847461260364796, 0.1361529477424105, 0.7034920878497788, 0.6983972334284478, 0.7482924281980649, 0.6054893500486864, 0.5819923319771187, 0.5545396764291997, 0.5256838545311202, 0.5660537937038699, 0.23717752361341593, 0.4156122017326922, 0.37720328779839807, 0.5649903452552938, 0.1390753184870166, 0.36702205145431466, 0.4951953932883316, 0.2889787939451617, 0.166767759694197, 0.087161018912421, 0.28634715258429777, 0.5723972105028262, 0.5206555533465758, 0.5001302141576028, 0.4867313264362003, 0.23261109006937564, 0.37252221188842927, 0.42682060560998636, 0.5378697884284283, 0.4534917941041866, 0.3205504014182454, 0.2794752258017815, 0.5561026571635588, 0.5275506028800905, 0.6181158499605193, 0.628034576645842, 0.6392767084570874, 0.6581786187833412, 0.5069943791988045, 0.4662171365483567, 0.5792547717913864, 0.857766439319229, 0.8554435072836126, 0.8490407974554126, 0.8473453325982832, 0.8474740656186431, 0.8463731837917917, 0.8582267900850105, 0.860988598462193, 0.8596402036786521, 0.09184206933988825, 0.11480825385339377, 0.07376111134792407, 0.14410233559751473, 0.14075657366465655, 0.1169804760379558, 0.14336881304240268, 0.14495212996630125, 0.1108508475720198, 0.3493923027455861, 0.3315702144526874, 0.2774598387538668, 0.7021502031564548, 0.28066945947324773, 0.23570889048091948, 0.2609177894077649, 0.7601331515783776, 0.604321791958603, 0.45281102716540556, 0.5711377072870936, 0.22247645542479932, 0.7390479806160082, 0.5976969182973116, 0.5831079784439139, 0.24133230699183927, 0.529747751481187, 0.2697795284355522, 0.318151518747289, 0.4364942568854384, 0.23193053406690123, 0.5288609992238366, 0.2710080014364974, 0.4630226347755232, 0.24008863411051606, 0.5016642276594053, 0.20477033101873598, 0.311553085391872, 0.2592864339354446, 0.23367727259323323, 0.25064101933775385, 0.32491135376985003, 0.2232099363900134, 0.21878883206707556, 0.6439488831598288, 0.22544424830483245, 0.20044224145505185, 0.1904502791049918, 0.1765652424961065, 0.20734226908476683, 0.1986280749257885, 0.19308472500545681, 0.1895437365955709, 0.19385088508803938, 0.1822959437066639, 0.923529301098585, 0.18770434236834466, 0.1528495422750581, 0.17216904610724448, 0.19987157211651418, 0.20126306687874185, 0.121808387872409, 0.1692732101798079, 0.9347672115824649, 0.8900976506780609, 0.15610941465951633, 0.9222753924915353, 0.21106509836739218, 0.16681040685298743, 0.9194518434581395, 0.9236796724579501, 0.869035553448026, 0.8646941550055658, 0.20637007775098004, 0.3063299723029458, 0.21657466979480366, 0.25435844175639355, 0.2462599577606175, 0.20800442373237982, 0.4273965755839062, 0.21715604901984198, 0.19754041607933837, 0.08934549328892949, 0.09321657496282898, 0.10394778152464645, 0.10513510077272281, 0.09970015384764008, 0.10136798575503125, 0.1018691106759474, 0.10438169345553017, 0.12444918657678228]}, "mutation_prompt": null}
{"id": "369441c4-588a-4f18-83cb-8691450edf3c", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Adaptive swarm size\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce adaptive swarm size for enhanced exploration and exploitation balance in high-dimensional spaces.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.8980982671425689, 0.8903620049616174, 0.8988530611711405, 0.8932545471037056, 0.8879154653212531, 0.8890776578998386, 0.9042764617925443, 0.8948881339175825, 0.8926399277431314, 0.7908067798577216, 0.7963171525200662, 0.7691463443415147, 0.7861521281885755, 0.7384137833213005, 0.7650494658557858, 0.7466613163384963, 0.8042553946121596, 0.7401977461471319, 0.09686491762940641, 0.145015521164934, 0.13954667723027014, 0.08883147126247481, 0.12158071203809828, 0.14246759369462292, 0.08543604575781005, 0.11651216537128928, 0.1162232479695906, 0.10534666367404988, 0.1086401808715809, 0.12403561892945958, 0.1227838869170047, 0.08498647002862958, 0.12356918866601574, 0.11000272194217109, 0.09543067418859152, 0.10413182813264699, 0.8958457553630623, 0.9246980758595659, 0.9323430571211943, 0.927032995465498, 0.9357906118174969, 0.9219894036722209, 0.9257246401286136, 0.9238429026721982, 0.9158375560873677, 0.8099376705121574, 0.7859071482188211, 0.7918956257504677, 0.7988631115655729, 0.7660517694318512, 0.7997006651978558, 0.8038183917965578, 0.7797472939535286, 0.8205850281208377, 0.38807573057643796, 0.17149815958416603, 0.9105896054967318, 0.27820565968291533, 0.27906288564467063, 0.2135173465459378, 0.17567178859102317, 0.23475900167451713, 0.23639384099425564, 0.6891818550484219, 0.7413015948242958, 0.7375993174483211, 0.6921773842727268, 0.7851112254472163, 0.8121672872946074, 0.7335859109949809, 0.691808571318207, 0.7438793313686154, 0.705381006632888, 0.6886452689873384, 0.6742593630228897, 0.7691078317494832, 0.7354137983733264, 0.716902588099091, 0.7246718764776938, 0.8182057555730377, 0.6973296071471353, 0.524893278044298, 0.4296464440984693, 0.5493206255078452, 0.6230360912480866, 0.6847390247958334, 0.5104569876012623, 0.35558761012610474, 0.05774367894119936, 0.6149010330788307, 0.4836028770289629, 0.1388648764035899, 0.25062484185558664, 0.09340076878800885, 0.1494128162296724, 0.18668711084426837, 0.6545725008506056, 0.4982670797334592, 0.5937474246296442, 0.653771929586086, 0.5439759084240299, 0.45045689671437106, 0.4063654786256097, 0.38795635816597174, 0.32685456056179707, 0.1725896044098516, 0.25776338338783733, 0.2080706296499335, 0.5485038800943953, 0.5709549654799707, 0.6339652926559953, 0.6283242778850056, 0.6302775999301897, 0.5094604233391413, 0.6604543331652382, 0.6183887924627371, 0.6634161129421416, 0.8591162780685626, 0.8505580464302733, 0.8394734888313469, 0.8622647211860525, 0.8390210774642543, 0.8752653826045191, 0.8507340190038861, 0.8617439993919205, 0.8616848052623161, 0.11452668487522444, 0.08228366196261327, 0.09726637485734013, 0.18664310345540502, 0.10972184044380551, 0.12373335059792623, 0.13179927379653944, 0.16048668281489276, 0.09687209892983262, 0.7873333939552076, 0.7843569123740535, 0.5856973986138074, 0.815023028448911, 0.2761734433558286, 0.28614424771092883, 0.4092221860622195, 0.30768046306464614, 0.6135558264340026, 0.2130167059980066, 0.40232050913594075, 0.40551795513375866, 0.6511583344603477, 0.6369067104320095, 0.6129057971117586, 0.268607726949018, 0.5469124533101808, 0.2703053765794261, 0.19427000405457895, 0.6913011763681616, 0.3472487640823215, 0.4338078050637949, 0.18869346325186942, 0.334133580159647, 0.23807541446036917, 0.27394981901033266, 0.2804557103015498, 0.23814228457314124, 0.28805358365635503, 0.20806208085382683, 0.28191557864204553, 0.2875265961561123, 0.23246959346219032, 0.21567681290459673, 0.21630425114797203, 0.27832859324631964, 0.1990356445113528, 0.19024722065370958, 0.18835444382472055, 0.1996563884567848, 0.17782043899333622, 0.19293191137465648, 0.20830239769180137, 0.19119739874781738, 0.19971124404113327, 0.18733477652643205, 0.18751372198126215, 0.18802518346360553, 0.9358614324669595, 0.9151489283521499, 0.9221329925234291, 0.12219346890577631, 0.16849441433361156, 0.9258514390751847, 0.8943999291853538, 0.15605264424403797, 0.8732948373149961, 0.9011077453515852, 0.20976578610640595, 0.8817999887606904, 0.8894531210946778, 0.9097457428995559, 0.8655539921416153, 0.2182757247435193, 0.3931197577417541, 0.20661701820504463, 0.2094791961050969, 0.19407375695983076, 0.22219575385724, 0.1917059374736374, 0.49110901131392015, 0.18237599994301013, 0.08269495088094825, 0.11202492921654816, 0.09128963233290566, 0.0955950188635255, 0.09517469951281565, 0.10703495486968928, 0.08873425526346068, 0.09697454066689548, 0.15709873817077824]}, "mutation_prompt": null}
{"id": "afa2d47f-422f-4095-89a2-6ab92830d0fd", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            rank = np.argsort(pbest_val)  # Rank-based velocity adjustment\n            for i in range(initial_population_size):\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] += 0.1 * (1.0 - rank[i] / initial_population_size)  # Add rank influence\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)\n                pos[i] = pos[i] + vel[i]\n\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce stochastic rank-based velocity adjustment for improved convergence in dynamic landscapes.", "configspace": "", "generation": 63, "fitness": 0.2925467451790635, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.6579409384865285, 0.675230545843946, 0.6527460774143574, 0.6510998318194879, 0.6129752540945159, 0.7080623966870743, 0.6793974583771665, 0.6319708170527323, 0.659965926372647, 0.2000910382635499, 0.08527627575859931, 0.16213329567580936, 0.10720272905180295, 0.04951485927675581, 0.17300209039694547, 0.05791801147239639, 0.12237098608873842, 0.05727290059106671, 0.11538738592412245, 0.1582093621973245, 0.07671399034510884, 0.1440992912046415, 0.11715405601897033, 0.11921490146995073, 0.10085452068382073, 0.14288609308941103, 0.11752251904742028, 0.09587686452474065, 0.09505751256215167, 0.09661951117667122, 0.10035181321712738, 0.09378665906187234, 0.09910899631315517, 0.10414455675225676, 0.08517968150615829, 0.1297493457209592, 0.9153576807017044, 0.9296234506312364, 0.9360861737611449, 0.9189763246695797, 0.9405799803934919, 0.9192992981502515, 0.9045492564473574, 0.9126071305420262, 0.9172106458300715, 0.43621514763099445, 0.47817586780293586, 0.43102118391899535, 0.3920901733143217, 0.4326721044907206, 0.42684689494478634, 0.41668128772863333, 0.3976309572576511, 0.399594918658541, 0.8102709294534259, 0.7935572685192032, 0.17042549209275892, 0.28229519240246514, 0.37690791062996665, 0.27875139446763697, 0.23560120231596893, 0.17742532454894666, 0.22411438929166194, 0.30587055975383626, 0.302003146511707, 0.33313598274206035, 0.28623402138969933, 0.2430820924613517, 0.3509685636106097, 0.30479163481680116, 0.3474860897160933, 0.38717195728214415, 0.2857507192095132, 0.2558746878946413, 0.131840779188926, 0.21041338294371348, 0.27249133195111885, 0.23002337577763288, 0.2265851247303059, 0.20092763560149984, 0.22126220680627717, 0.1095621492764074, 0.0703774460950195, 0.09147932184895957, 0.08045677909819171, 0.013583336150023384, 0.0864540260472304, 0.02908717181988596, 0.08516685337857832, 0.09526001796573491, 0.24554445185114104, 0.26038065212157313, 0.11494668033433464, 0.1369801746076682, 0.0679381854328136, 0.06480265932819496, 0.2419837212576439, 0.14366118908014502, 0.19864620753870676, 0.12388462900602171, 0.1212838844630596, 0.1062485269631177, 0.0649466396695163, 0.10355290304727638, 0.06211244406920691, 0.08612298608616076, 0.08962421529182141, 0.07048792327481168, 0.09263630215543839, 0.1278483974911453, 0.1791567636840844, 0.1852780393410849, 0.22361044746091296, 0.17766802770135182, 0.19563538794056567, 0.14436012610239157, 0.17899373147271636, 0.5121810895015101, 0.5338677895263756, 0.49539157083173, 0.5307812681545376, 0.5215038840957342, 0.47569955683220966, 0.5319844796726338, 0.4742774216460437, 0.5195313819984712, 0.09149420158874533, 0.15728999106224528, 0.08351869308936644, 0.14212562165616605, 0.08153865143265071, 0.16053710835339985, 0.15695173399889284, 0.11330454189034922, 0.10368126751540507, 0.30366171296083033, 0.3453052806777336, 0.36691981787220806, 0.2466037183543358, 0.33451109463924644, 0.3632810820656246, 0.3626367653226493, 0.3509159618029788, 0.25262037089806877, 0.3909854049624588, 0.37774276990973854, 0.39689143825346385, 0.37586180149750414, 0.4188333057830148, 0.3744604127209331, 0.38033721156416245, 0.3959536156567962, 0.24081234946039554, 0.24063310245427172, 0.27513792723477437, 0.2571948966584773, 0.33627488021467855, 0.3162058450815607, 0.33102829810283796, 0.2139710885269832, 0.27581235023470396, 0.23528983616210386, 0.23641766514733686, 0.25192166902467805, 0.2420910354529695, 0.2051482483943997, 0.2010742970471885, 0.21282184377502344, 0.22327824916230654, 0.248648711890476, 0.22849255920201472, 0.1874584658705134, 0.22327645256396633, 0.17865290234186326, 0.19874982587655143, 0.19112421984831207, 0.16587897972202859, 0.19178653527656475, 0.17502626601373628, 0.20744778421722032, 0.18746410369514577, 0.18780447690292668, 0.18796467942137174, 0.9246751307273303, 0.9126692277716224, 0.9170172660371914, 0.13625904817459067, 0.16834607871311413, 0.9088895457801442, 0.11168541856631364, 0.15572891734884575, 0.7154230058217441, 0.20988562638587172, 0.21015176009028147, 0.8708661765000427, 0.16598838365124535, 0.8838372985296472, 0.8319904904687614, 0.1958516365695243, 0.18671857010332227, 0.1793277106612191, 0.20924474686459504, 0.20298972803501936, 0.18174872869721026, 0.17268613139405675, 0.17998090818317158, 0.19425169374944307, 0.08747244466749504, 0.10040740544445848, 0.0944023705941539, 0.10596642192019512, 0.10357819570052451, 0.08398285744178136, 0.07803498192009539, 0.09399317471689972, 0.08164254970486995]}, "mutation_prompt": null}
{"id": "11f1644c-7339-4560-9e82-f7a3faea6d8d", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Adaptive swarm size\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce adaptive swarm size for enhanced exploration and exploitation balance in high-dimensional spaces.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.8980982671425689, 0.8903620049616174, 0.8988530611711405, 0.8932545471037056, 0.8879154653212531, 0.8890776578998386, 0.9042764617925443, 0.8948881339175825, 0.8926399277431314, 0.7908067798577216, 0.7963171525200662, 0.7691463443415147, 0.7861521281885755, 0.7384137833213005, 0.7650494658557858, 0.7466613163384963, 0.8042553946121596, 0.7401977461471319, 0.09686491762940641, 0.145015521164934, 0.13954667723027014, 0.08883147126247481, 0.12158071203809828, 0.14246759369462292, 0.08543604575781005, 0.11651216537128928, 0.1162232479695906, 0.10534666367404988, 0.1086401808715809, 0.12403561892945958, 0.1227838869170047, 0.08498647002862958, 0.12356918866601574, 0.11000272194217109, 0.09543067418859152, 0.10413182813264699, 0.8958457553630623, 0.9246980758595659, 0.9323430571211943, 0.927032995465498, 0.9357906118174969, 0.9219894036722209, 0.9257246401286136, 0.9238429026721982, 0.9158375560873677, 0.8099376705121574, 0.7859071482188211, 0.7918956257504677, 0.7988631115655729, 0.7660517694318512, 0.7997006651978558, 0.8038183917965578, 0.7797472939535286, 0.8205850281208377, 0.38807573057643796, 0.17149815958416603, 0.9105896054967318, 0.27820565968291533, 0.27906288564467063, 0.2135173465459378, 0.17567178859102317, 0.23475900167451713, 0.23639384099425564, 0.6891818550484219, 0.7413015948242958, 0.7375993174483211, 0.6921773842727268, 0.7851112254472163, 0.8121672872946074, 0.7335859109949809, 0.691808571318207, 0.7438793313686154, 0.705381006632888, 0.6886452689873384, 0.6742593630228897, 0.7691078317494832, 0.7354137983733264, 0.716902588099091, 0.7246718764776938, 0.8182057555730377, 0.6973296071471353, 0.524893278044298, 0.4296464440984693, 0.5493206255078452, 0.6230360912480866, 0.6847390247958334, 0.5104569876012623, 0.35558761012610474, 0.05774367894119936, 0.6149010330788307, 0.4836028770289629, 0.1388648764035899, 0.25062484185558664, 0.09340076878800885, 0.1494128162296724, 0.18668711084426837, 0.6545725008506056, 0.4982670797334592, 0.5937474246296442, 0.653771929586086, 0.5439759084240299, 0.45045689671437106, 0.4063654786256097, 0.38795635816597174, 0.32685456056179707, 0.1725896044098516, 0.25776338338783733, 0.2080706296499335, 0.5485038800943953, 0.5709549654799707, 0.6339652926559953, 0.6283242778850056, 0.6302775999301897, 0.5094604233391413, 0.6604543331652382, 0.6183887924627371, 0.6634161129421416, 0.8591162780685626, 0.8505580464302733, 0.8394734888313469, 0.8622647211860525, 0.8390210774642543, 0.8752653826045191, 0.8507340190038861, 0.8617439993919205, 0.8616848052623161, 0.11452668487522444, 0.08228366196261327, 0.09726637485734013, 0.18664310345540502, 0.10972184044380551, 0.12373335059792623, 0.13179927379653944, 0.16048668281489276, 0.09687209892983262, 0.7873333939552076, 0.7843569123740535, 0.5856973986138074, 0.815023028448911, 0.2761734433558286, 0.28614424771092883, 0.4092221860622195, 0.30768046306464614, 0.6135558264340026, 0.2130167059980066, 0.40232050913594075, 0.40551795513375866, 0.6511583344603477, 0.6369067104320095, 0.6129057971117586, 0.268607726949018, 0.5469124533101808, 0.2703053765794261, 0.19427000405457895, 0.6913011763681616, 0.3472487640823215, 0.4338078050637949, 0.18869346325186942, 0.334133580159647, 0.23807541446036917, 0.27394981901033266, 0.2804557103015498, 0.23814228457314124, 0.28805358365635503, 0.20806208085382683, 0.28191557864204553, 0.2875265961561123, 0.23246959346219032, 0.21567681290459673, 0.21630425114797203, 0.27832859324631964, 0.1990356445113528, 0.19024722065370958, 0.18835444382472055, 0.1996563884567848, 0.17782043899333622, 0.19293191137465648, 0.20830239769180137, 0.19119739874781738, 0.19971124404113327, 0.18733477652643205, 0.18751372198126215, 0.18802518346360553, 0.9358614324669595, 0.9151489283521499, 0.9221329925234291, 0.12219346890577631, 0.16849441433361156, 0.9258514390751847, 0.8943999291853538, 0.15605264424403797, 0.8732948373149961, 0.9011077453515852, 0.20976578610640595, 0.8817999887606904, 0.8894531210946778, 0.9097457428995559, 0.8655539921416153, 0.2182757247435193, 0.3931197577417541, 0.20661701820504463, 0.2094791961050969, 0.19407375695983076, 0.22219575385724, 0.1917059374736374, 0.49110901131392015, 0.18237599994301013, 0.08269495088094825, 0.11202492921654816, 0.09128963233290566, 0.0955950188635255, 0.09517469951281565, 0.10703495486968928, 0.08873425526346068, 0.09697454066689548, 0.15709873817077824]}, "mutation_prompt": null}
{"id": "3d5e1ed7-f734-486d-908a-fb9f1e4a99e1", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Adaptive swarm size\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Integrate adaptive strategy to refine particle interactions and enhance convergence through progressive swarm diversity.", "configspace": "", "generation": 65, "fitness": 0.4806201462788973, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.30.", "error": "", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.8980982671425689, 0.8903620049616174, 0.8988530611711405, 0.8932545471037056, 0.8879154653212531, 0.8890776578998386, 0.9042764617925443, 0.8948881339175825, 0.8926399277431314, 0.7908067798577216, 0.7963171525200662, 0.7691463443415147, 0.7861521281885755, 0.7384137833213005, 0.7650494658557858, 0.7466613163384963, 0.8042553946121596, 0.7401977461471319, 0.09686491762940641, 0.145015521164934, 0.13954667723027014, 0.08883147126247481, 0.12158071203809828, 0.14246759369462292, 0.08543604575781005, 0.11651216537128928, 0.1162232479695906, 0.10534666367404988, 0.1086401808715809, 0.12403561892945958, 0.1227838869170047, 0.08498647002862958, 0.12356918866601574, 0.11000272194217109, 0.09543067418859152, 0.10413182813264699, 0.8958457553630623, 0.9246980758595659, 0.9323430571211943, 0.927032995465498, 0.9357906118174969, 0.9219894036722209, 0.9257246401286136, 0.9238429026721982, 0.9158375560873677, 0.8099376705121574, 0.7859071482188211, 0.7918956257504677, 0.7988631115655729, 0.7660517694318512, 0.7997006651978558, 0.8038183917965578, 0.7797472939535286, 0.8205850281208377, 0.38807573057643796, 0.17149815958416603, 0.9105896054967318, 0.27820565968291533, 0.27906288564467063, 0.2135173465459378, 0.17567178859102317, 0.23475900167451713, 0.23639384099425564, 0.6891818550484219, 0.7413015948242958, 0.7375993174483211, 0.6921773842727268, 0.7851112254472163, 0.8121672872946074, 0.7335859109949809, 0.691808571318207, 0.7438793313686154, 0.705381006632888, 0.6886452689873384, 0.6742593630228897, 0.7691078317494832, 0.7354137983733264, 0.716902588099091, 0.7246718764776938, 0.8182057555730377, 0.6973296071471353, 0.524893278044298, 0.4296464440984693, 0.5493206255078452, 0.6230360912480866, 0.6847390247958334, 0.5104569876012623, 0.35558761012610474, 0.05774367894119936, 0.6149010330788307, 0.4836028770289629, 0.1388648764035899, 0.25062484185558664, 0.09340076878800885, 0.1494128162296724, 0.18668711084426837, 0.6545725008506056, 0.4982670797334592, 0.5937474246296442, 0.653771929586086, 0.5439759084240299, 0.45045689671437106, 0.4063654786256097, 0.38795635816597174, 0.32685456056179707, 0.1725896044098516, 0.25776338338783733, 0.2080706296499335, 0.5485038800943953, 0.5709549654799707, 0.6339652926559953, 0.6283242778850056, 0.6302775999301897, 0.5094604233391413, 0.6604543331652382, 0.6183887924627371, 0.6634161129421416, 0.8591162780685626, 0.8505580464302733, 0.8394734888313469, 0.8622647211860525, 0.8390210774642543, 0.8752653826045191, 0.8507340190038861, 0.8617439993919205, 0.8616848052623161, 0.11452668487522444, 0.08228366196261327, 0.09726637485734013, 0.18664310345540502, 0.10972184044380551, 0.12373335059792623, 0.13179927379653944, 0.16048668281489276, 0.09687209892983262, 0.7873333939552076, 0.7843569123740535, 0.5856973986138074, 0.815023028448911, 0.2761734433558286, 0.28614424771092883, 0.4092221860622195, 0.30768046306464614, 0.6135558264340026, 0.2130167059980066, 0.40232050913594075, 0.40551795513375866, 0.6511583344603477, 0.6369067104320095, 0.6129057971117586, 0.268607726949018, 0.5469124533101808, 0.2703053765794261, 0.19427000405457895, 0.6913011763681616, 0.3472487640823215, 0.4338078050637949, 0.18869346325186942, 0.334133580159647, 0.23807541446036917, 0.27394981901033266, 0.2804557103015498, 0.23814228457314124, 0.28805358365635503, 0.20806208085382683, 0.28191557864204553, 0.2875265961561123, 0.23246959346219032, 0.21567681290459673, 0.21630425114797203, 0.27832859324631964, 0.1990356445113528, 0.19024722065370958, 0.18835444382472055, 0.1996563884567848, 0.17782043899333622, 0.19293191137465648, 0.20830239769180137, 0.19119739874781738, 0.19971124404113327, 0.18733477652643205, 0.18751372198126215, 0.18802518346360553, 0.9358614324669595, 0.9151489283521499, 0.9221329925234291, 0.12219346890577631, 0.16849441433361156, 0.9258514390751847, 0.8943999291853538, 0.15605264424403797, 0.8732948373149961, 0.9011077453515852, 0.20976578610640595, 0.8817999887606904, 0.8894531210946778, 0.9097457428995559, 0.8655539921416153, 0.2182757247435193, 0.3931197577417541, 0.20661701820504463, 0.2094791961050969, 0.19407375695983076, 0.22219575385724, 0.1917059374736374, 0.49110901131392015, 0.18237599994301013, 0.08269495088094825, 0.11202492921654816, 0.09128963233290566, 0.0955950188635255, 0.09517469951281565, 0.10703495486968928, 0.08873425526346068, 0.09697454066689548, 0.15709873817077824]}, "mutation_prompt": null}
{"id": "11a1e161-fe34-4568-9fbd-f819ebd0c243", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Adaptive swarm size\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce adaptive swarm size for enhanced exploration and exploitation balance in high-dimensional spaces.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.8980982671425689, 0.8903620049616174, 0.8988530611711405, 0.8932545471037056, 0.8879154653212531, 0.8890776578998386, 0.9042764617925443, 0.8948881339175825, 0.8926399277431314, 0.7908067798577216, 0.7963171525200662, 0.7691463443415147, 0.7861521281885755, 0.7384137833213005, 0.7650494658557858, 0.7466613163384963, 0.8042553946121596, 0.7401977461471319, 0.09686491762940641, 0.145015521164934, 0.13954667723027014, 0.08883147126247481, 0.12158071203809828, 0.14246759369462292, 0.08543604575781005, 0.11651216537128928, 0.1162232479695906, 0.10534666367404988, 0.1086401808715809, 0.12403561892945958, 0.1227838869170047, 0.08498647002862958, 0.12356918866601574, 0.11000272194217109, 0.09543067418859152, 0.10413182813264699, 0.8958457553630623, 0.9246980758595659, 0.9323430571211943, 0.927032995465498, 0.9357906118174969, 0.9219894036722209, 0.9257246401286136, 0.9238429026721982, 0.9158375560873677, 0.8099376705121574, 0.7859071482188211, 0.7918956257504677, 0.7988631115655729, 0.7660517694318512, 0.7997006651978558, 0.8038183917965578, 0.7797472939535286, 0.8205850281208377, 0.38807573057643796, 0.17149815958416603, 0.9105896054967318, 0.27820565968291533, 0.27906288564467063, 0.2135173465459378, 0.17567178859102317, 0.23475900167451713, 0.23639384099425564, 0.6891818550484219, 0.7413015948242958, 0.7375993174483211, 0.6921773842727268, 0.7851112254472163, 0.8121672872946074, 0.7335859109949809, 0.691808571318207, 0.7438793313686154, 0.705381006632888, 0.6886452689873384, 0.6742593630228897, 0.7691078317494832, 0.7354137983733264, 0.716902588099091, 0.7246718764776938, 0.8182057555730377, 0.6973296071471353, 0.524893278044298, 0.4296464440984693, 0.5493206255078452, 0.6230360912480866, 0.6847390247958334, 0.5104569876012623, 0.35558761012610474, 0.05774367894119936, 0.6149010330788307, 0.4836028770289629, 0.1388648764035899, 0.25062484185558664, 0.09340076878800885, 0.1494128162296724, 0.18668711084426837, 0.6545725008506056, 0.4982670797334592, 0.5937474246296442, 0.653771929586086, 0.5439759084240299, 0.45045689671437106, 0.4063654786256097, 0.38795635816597174, 0.32685456056179707, 0.1725896044098516, 0.25776338338783733, 0.2080706296499335, 0.5485038800943953, 0.5709549654799707, 0.6339652926559953, 0.6283242778850056, 0.6302775999301897, 0.5094604233391413, 0.6604543331652382, 0.6183887924627371, 0.6634161129421416, 0.8591162780685626, 0.8505580464302733, 0.8394734888313469, 0.8622647211860525, 0.8390210774642543, 0.8752653826045191, 0.8507340190038861, 0.8617439993919205, 0.8616848052623161, 0.11452668487522444, 0.08228366196261327, 0.09726637485734013, 0.18664310345540502, 0.10972184044380551, 0.12373335059792623, 0.13179927379653944, 0.16048668281489276, 0.09687209892983262, 0.7873333939552076, 0.7843569123740535, 0.5856973986138074, 0.815023028448911, 0.2761734433558286, 0.28614424771092883, 0.4092221860622195, 0.30768046306464614, 0.6135558264340026, 0.2130167059980066, 0.40232050913594075, 0.40551795513375866, 0.6511583344603477, 0.6369067104320095, 0.6129057971117586, 0.268607726949018, 0.5469124533101808, 0.2703053765794261, 0.19427000405457895, 0.6913011763681616, 0.3472487640823215, 0.4338078050637949, 0.18869346325186942, 0.334133580159647, 0.23807541446036917, 0.27394981901033266, 0.2804557103015498, 0.23814228457314124, 0.28805358365635503, 0.20806208085382683, 0.28191557864204553, 0.2875265961561123, 0.23246959346219032, 0.21567681290459673, 0.21630425114797203, 0.27832859324631964, 0.1990356445113528, 0.19024722065370958, 0.18835444382472055, 0.1996563884567848, 0.17782043899333622, 0.19293191137465648, 0.20830239769180137, 0.19119739874781738, 0.19971124404113327, 0.18733477652643205, 0.18751372198126215, 0.18802518346360553, 0.9358614324669595, 0.9151489283521499, 0.9221329925234291, 0.12219346890577631, 0.16849441433361156, 0.9258514390751847, 0.8943999291853538, 0.15605264424403797, 0.8732948373149961, 0.9011077453515852, 0.20976578610640595, 0.8817999887606904, 0.8894531210946778, 0.9097457428995559, 0.8655539921416153, 0.2182757247435193, 0.3931197577417541, 0.20661701820504463, 0.2094791961050969, 0.19407375695983076, 0.22219575385724, 0.1917059374736374, 0.49110901131392015, 0.18237599994301013, 0.08269495088094825, 0.11202492921654816, 0.09128963233290566, 0.0955950188635255, 0.09517469951281565, 0.10703495486968928, 0.08873425526346068, 0.09697454066689548, 0.15709873817077824]}, "mutation_prompt": null}
{"id": "220d6de3-40e3-4338-8588-49555b0df550", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        initial_population_size = min(40, 5 * self.dim)\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7\n        prev_gbest_val = gbest_val\n        while eval_count < self.budget:\n            chaos_val = 4 * chaos_val * (1 - chaos_val)\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            if eval_count % (self.budget // 10) == 0:\n                convergence_rate = abs(prev_gbest_val - gbest_val) / max(abs(prev_gbest_val), 1e-12)\n                prev_gbest_val = gbest_val\n                if convergence_rate < 0.01:\n                    initial_population_size = max(10, initial_population_size // 2)\n                else:\n                    initial_population_size = min(40, initial_population_size * 2)\n\n            for i in range(initial_population_size):\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)\n                pos[i] = pos[i] + vel[i]\n\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce dynamic population size adjustment based on convergence rate to balance exploration and exploitation.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 32 is out of bounds for axis 0 with size 25').", "error": "IndexError('index 32 is out of bounds for axis 0 with size 25')", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {}, "mutation_prompt": null}
{"id": "38b5be0b-11a5-43df-8ef0-c1ec9a066fbe", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        initial_population_size = min(40, 5 * self.dim)\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7\n        while eval_count < self.budget:\n            chaos_val = 4 * chaos_val * (1 - chaos_val)\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)\n                pos[i] = pos[i] + vel[i]\n\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                if eval_count % (self.budget // 10) == 0:  # Random restart mechanism\n                    pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim)) * 0.1 + pos * 0.9\n\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce random restarts with memory to prevent premature convergence and enhance global exploration.", "configspace": "", "generation": 68, "fitness": 0.4351724103519699, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.29.", "error": "", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.8848697110266533, 0.8765146685148659, 0.8769235703851873, 0.8817678467969414, 0.8663704421633204, 0.8716640654364007, 0.8823517674394166, 0.8791839948795755, 0.8763981983250534, 0.6723674889650698, 0.7101575279475034, 0.6605970716554452, 0.6655481818609548, 0.6044670543938206, 0.6860943457139703, 0.6625543934196756, 0.6805848004990086, 0.6481850361925279, 0.0968112160540282, 0.14505085543773744, 0.14117264610083058, 0.08873740988406531, 0.1302885715503591, 0.1313816188558632, 0.08531310629080013, 0.11102061061923318, 0.11622075550819955, 0.10519462896167442, 0.11404900808618845, 0.1433183712084447, 0.11590556589871281, 0.08501368390597908, 0.12350208142348185, 0.10986405677752464, 0.09177668758557611, 0.10412674928955201, 0.8978067862926568, 0.9246980758595659, 0.9323430571211943, 0.927032995465498, 0.9357906118174969, 0.9219894036722209, 0.9257246401286136, 0.9238429026721982, 0.9158375560873677, 0.731535045350465, 0.7251306620122722, 0.743522383223441, 0.7278280734041963, 0.7394971323176776, 0.7907277724364472, 0.7510967885634922, 0.7428004684399543, 0.7524263825561459, 0.877675525843162, 0.17149815958416603, 0.908561204439755, 0.27788228653000846, 0.27905922556730167, 0.21350961167845284, 0.2176759152680937, 0.23475900167451713, 0.23639384099425564, 0.5658550074018585, 0.5940049711652081, 0.6514486578365961, 0.627769280527575, 0.7345992411612678, 0.7631343828220059, 0.7191364235608799, 0.6501973367737695, 0.7005064926964497, 0.6402880203583852, 0.6289317371699608, 0.6440796560472759, 0.6538506511964699, 0.6258274039844994, 0.656307288450248, 0.6511992140436476, 0.7794983317770752, 0.6169605157798211, 0.3941609748799856, 0.35793194859279287, 0.2630151334106725, 0.5156515936288204, 0.557095403562275, 0.26473901032562785, 0.13983137301277326, 0.40678876467893044, 0.37319556801200326, 0.18126572267222874, 0.14186843179656772, 0.2698796257768348, 0.10345605116818046, 0.1496406189775885, 0.15304897871827927, 0.4061643237779754, 0.4734752154423094, 0.2872599677809303, 0.3868489430611539, 0.3410734160706691, 0.44686426321524453, 0.2805333753109821, 0.20155725078639108, 0.28620299000211, 0.13310261275295687, 0.19042760934513647, 0.14084057482453716, 0.32558874469721677, 0.33784471030261976, 0.3053526212112483, 0.4384096370845214, 0.40877082832470046, 0.41661714146462114, 0.37150173855640134, 0.29785476342834794, 0.40344113631354095, 0.7952536412599531, 0.767828408424728, 0.7641716676980962, 0.7864466914052914, 0.6695934782093822, 0.7512210693169376, 0.7596888126175344, 0.7267231851177719, 0.7518789589576851, 0.11408225880788214, 0.09387279744650479, 0.09734192433677291, 0.1864171709238095, 0.10944194894694359, 0.12326811094745849, 0.13121548111485204, 0.15982054879416696, 0.09688159105119143, 0.760072806513768, 0.2800662141217787, 0.7697766285414298, 0.7499146102084209, 0.21597799743761903, 0.28476354446934116, 0.40280385205093894, 0.41539374607486146, 0.5835488288223809, 0.2294934380987217, 0.5311398883973935, 0.4857679821714913, 0.40321185562594897, 0.5240106672453138, 0.5023552179511063, 0.2685772077520284, 0.6125805920892116, 0.2683683171664273, 0.1930945968971275, 0.44393959391769855, 0.34814324597121327, 0.4254773267250116, 0.18676241282206063, 0.33288212034232434, 0.21061837872367628, 0.2708601901520782, 0.2609025492313053, 0.2597918458718804, 0.25083397507567484, 0.22802038219742393, 0.2287338842192428, 0.23327601425309263, 0.2330214517892819, 0.2085140905782349, 0.25406730984431547, 0.2591035327560802, 0.2097799987452874, 0.1902469267060788, 0.19843074858555265, 0.19967789502610644, 0.17780223995741506, 0.1929239461272605, 0.20824298156756493, 0.18480082466062686, 0.1996819786421009, 0.1873329723284709, 0.1875098034258914, 0.1880217846941532, 0.9339993930553057, 0.9147541970754253, 0.9209439107233558, 0.12215876227807099, 0.16849443334614078, 0.9220801309628599, 0.8873417392757642, 0.15604662899262656, 0.8765184330723224, 0.8952168769476715, 0.2097443193401376, 0.8746920303640249, 0.8776423912831351, 0.9002419663543171, 0.8391736308734736, 0.18608944986424003, 0.20562785948987672, 0.2567346957581542, 0.19193332583743006, 0.17704730769303678, 0.18882344629598824, 0.21291038592388667, 0.2056148210917873, 0.2611754654751204, 0.09278436749403973, 0.08977058331466137, 0.08284862824943007, 0.07844441953718051, 0.12591495510688333, 0.10167153107571181, 0.08372110750349515, 0.10397482574406625, 0.1207495009020646]}, "mutation_prompt": null}
{"id": "4251f5c4-2465-43a8-9cfb-88019ba20d5f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Adaptive swarm size\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce adaptive swarm size for enhanced exploration and exploitation balance in high-dimensional spaces.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.8980982671425689, 0.8903620049616174, 0.8988530611711405, 0.8932545471037056, 0.8879154653212531, 0.8890776578998386, 0.9042764617925443, 0.8948881339175825, 0.8926399277431314, 0.7908067798577216, 0.7963171525200662, 0.7691463443415147, 0.7861521281885755, 0.7384137833213005, 0.7650494658557858, 0.7466613163384963, 0.8042553946121596, 0.7401977461471319, 0.09686491762940641, 0.145015521164934, 0.13954667723027014, 0.08883147126247481, 0.12158071203809828, 0.14246759369462292, 0.08543604575781005, 0.11651216537128928, 0.1162232479695906, 0.10534666367404988, 0.1086401808715809, 0.12403561892945958, 0.1227838869170047, 0.08498647002862958, 0.12356918866601574, 0.11000272194217109, 0.09543067418859152, 0.10413182813264699, 0.8958457553630623, 0.9246980758595659, 0.9323430571211943, 0.927032995465498, 0.9357906118174969, 0.9219894036722209, 0.9257246401286136, 0.9238429026721982, 0.9158375560873677, 0.8099376705121574, 0.7859071482188211, 0.7918956257504677, 0.7988631115655729, 0.7660517694318512, 0.7997006651978558, 0.8038183917965578, 0.7797472939535286, 0.8205850281208377, 0.38807573057643796, 0.17149815958416603, 0.9105896054967318, 0.27820565968291533, 0.27906288564467063, 0.2135173465459378, 0.17567178859102317, 0.23475900167451713, 0.23639384099425564, 0.6891818550484219, 0.7413015948242958, 0.7375993174483211, 0.6921773842727268, 0.7851112254472163, 0.8121672872946074, 0.7335859109949809, 0.691808571318207, 0.7438793313686154, 0.705381006632888, 0.6886452689873384, 0.6742593630228897, 0.7691078317494832, 0.7354137983733264, 0.716902588099091, 0.7246718764776938, 0.8182057555730377, 0.6973296071471353, 0.524893278044298, 0.4296464440984693, 0.5493206255078452, 0.6230360912480866, 0.6847390247958334, 0.5104569876012623, 0.35558761012610474, 0.05774367894119936, 0.6149010330788307, 0.4836028770289629, 0.1388648764035899, 0.25062484185558664, 0.09340076878800885, 0.1494128162296724, 0.18668711084426837, 0.6545725008506056, 0.4982670797334592, 0.5937474246296442, 0.653771929586086, 0.5439759084240299, 0.45045689671437106, 0.4063654786256097, 0.38795635816597174, 0.32685456056179707, 0.1725896044098516, 0.25776338338783733, 0.2080706296499335, 0.5485038800943953, 0.5709549654799707, 0.6339652926559953, 0.6283242778850056, 0.6302775999301897, 0.5094604233391413, 0.6604543331652382, 0.6183887924627371, 0.6634161129421416, 0.8591162780685626, 0.8505580464302733, 0.8394734888313469, 0.8622647211860525, 0.8390210774642543, 0.8752653826045191, 0.8507340190038861, 0.8617439993919205, 0.8616848052623161, 0.11452668487522444, 0.08228366196261327, 0.09726637485734013, 0.18664310345540502, 0.10972184044380551, 0.12373335059792623, 0.13179927379653944, 0.16048668281489276, 0.09687209892983262, 0.7873333939552076, 0.7843569123740535, 0.5856973986138074, 0.815023028448911, 0.2761734433558286, 0.28614424771092883, 0.4092221860622195, 0.30768046306464614, 0.6135558264340026, 0.2130167059980066, 0.40232050913594075, 0.40551795513375866, 0.6511583344603477, 0.6369067104320095, 0.6129057971117586, 0.268607726949018, 0.5469124533101808, 0.2703053765794261, 0.19427000405457895, 0.6913011763681616, 0.3472487640823215, 0.4338078050637949, 0.18869346325186942, 0.334133580159647, 0.23807541446036917, 0.27394981901033266, 0.2804557103015498, 0.23814228457314124, 0.28805358365635503, 0.20806208085382683, 0.28191557864204553, 0.2875265961561123, 0.23246959346219032, 0.21567681290459673, 0.21630425114797203, 0.27832859324631964, 0.1990356445113528, 0.19024722065370958, 0.18835444382472055, 0.1996563884567848, 0.17782043899333622, 0.19293191137465648, 0.20830239769180137, 0.19119739874781738, 0.19971124404113327, 0.18733477652643205, 0.18751372198126215, 0.18802518346360553, 0.9358614324669595, 0.9151489283521499, 0.9221329925234291, 0.12219346890577631, 0.16849441433361156, 0.9258514390751847, 0.8943999291853538, 0.15605264424403797, 0.8732948373149961, 0.9011077453515852, 0.20976578610640595, 0.8817999887606904, 0.8894531210946778, 0.9097457428995559, 0.8655539921416153, 0.2182757247435193, 0.3931197577417541, 0.20661701820504463, 0.2094791961050969, 0.19407375695983076, 0.22219575385724, 0.1917059374736374, 0.49110901131392015, 0.18237599994301013, 0.08269495088094825, 0.11202492921654816, 0.09128963233290566, 0.0955950188635255, 0.09517469951281565, 0.10703495486968928, 0.08873425526346068, 0.09697454066689548, 0.15709873817077824]}, "mutation_prompt": null}
{"id": "ab9d9d03-9224-4053-803e-09c7e7216f92", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Adaptive swarm size\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce adaptive swarm size for enhanced exploration and exploitation balance in high-dimensional spaces.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.8980982671425689, 0.8903620049616174, 0.8988530611711405, 0.8932545471037056, 0.8879154653212531, 0.8890776578998386, 0.9042764617925443, 0.8948881339175825, 0.8926399277431314, 0.7908067798577216, 0.7963171525200662, 0.7691463443415147, 0.7861521281885755, 0.7384137833213005, 0.7650494658557858, 0.7466613163384963, 0.8042553946121596, 0.7401977461471319, 0.09686491762940641, 0.145015521164934, 0.13954667723027014, 0.08883147126247481, 0.12158071203809828, 0.14246759369462292, 0.08543604575781005, 0.11651216537128928, 0.1162232479695906, 0.10534666367404988, 0.1086401808715809, 0.12403561892945958, 0.1227838869170047, 0.08498647002862958, 0.12356918866601574, 0.11000272194217109, 0.09543067418859152, 0.10413182813264699, 0.8958457553630623, 0.9246980758595659, 0.9323430571211943, 0.927032995465498, 0.9357906118174969, 0.9219894036722209, 0.9257246401286136, 0.9238429026721982, 0.9158375560873677, 0.8099376705121574, 0.7859071482188211, 0.7918956257504677, 0.7988631115655729, 0.7660517694318512, 0.7997006651978558, 0.8038183917965578, 0.7797472939535286, 0.8205850281208377, 0.38807573057643796, 0.17149815958416603, 0.9105896054967318, 0.27820565968291533, 0.27906288564467063, 0.2135173465459378, 0.17567178859102317, 0.23475900167451713, 0.23639384099425564, 0.6891818550484219, 0.7413015948242958, 0.7375993174483211, 0.6921773842727268, 0.7851112254472163, 0.8121672872946074, 0.7335859109949809, 0.691808571318207, 0.7438793313686154, 0.705381006632888, 0.6886452689873384, 0.6742593630228897, 0.7691078317494832, 0.7354137983733264, 0.716902588099091, 0.7246718764776938, 0.8182057555730377, 0.6973296071471353, 0.524893278044298, 0.4296464440984693, 0.5493206255078452, 0.6230360912480866, 0.6847390247958334, 0.5104569876012623, 0.35558761012610474, 0.05774367894119936, 0.6149010330788307, 0.4836028770289629, 0.1388648764035899, 0.25062484185558664, 0.09340076878800885, 0.1494128162296724, 0.18668711084426837, 0.6545725008506056, 0.4982670797334592, 0.5937474246296442, 0.653771929586086, 0.5439759084240299, 0.45045689671437106, 0.4063654786256097, 0.38795635816597174, 0.32685456056179707, 0.1725896044098516, 0.25776338338783733, 0.2080706296499335, 0.5485038800943953, 0.5709549654799707, 0.6339652926559953, 0.6283242778850056, 0.6302775999301897, 0.5094604233391413, 0.6604543331652382, 0.6183887924627371, 0.6634161129421416, 0.8591162780685626, 0.8505580464302733, 0.8394734888313469, 0.8622647211860525, 0.8390210774642543, 0.8752653826045191, 0.8507340190038861, 0.8617439993919205, 0.8616848052623161, 0.11452668487522444, 0.08228366196261327, 0.09726637485734013, 0.18664310345540502, 0.10972184044380551, 0.12373335059792623, 0.13179927379653944, 0.16048668281489276, 0.09687209892983262, 0.7873333939552076, 0.7843569123740535, 0.5856973986138074, 0.815023028448911, 0.2761734433558286, 0.28614424771092883, 0.4092221860622195, 0.30768046306464614, 0.6135558264340026, 0.2130167059980066, 0.40232050913594075, 0.40551795513375866, 0.6511583344603477, 0.6369067104320095, 0.6129057971117586, 0.268607726949018, 0.5469124533101808, 0.2703053765794261, 0.19427000405457895, 0.6913011763681616, 0.3472487640823215, 0.4338078050637949, 0.18869346325186942, 0.334133580159647, 0.23807541446036917, 0.27394981901033266, 0.2804557103015498, 0.23814228457314124, 0.28805358365635503, 0.20806208085382683, 0.28191557864204553, 0.2875265961561123, 0.23246959346219032, 0.21567681290459673, 0.21630425114797203, 0.27832859324631964, 0.1990356445113528, 0.19024722065370958, 0.18835444382472055, 0.1996563884567848, 0.17782043899333622, 0.19293191137465648, 0.20830239769180137, 0.19119739874781738, 0.19971124404113327, 0.18733477652643205, 0.18751372198126215, 0.18802518346360553, 0.9358614324669595, 0.9151489283521499, 0.9221329925234291, 0.12219346890577631, 0.16849441433361156, 0.9258514390751847, 0.8943999291853538, 0.15605264424403797, 0.8732948373149961, 0.9011077453515852, 0.20976578610640595, 0.8817999887606904, 0.8894531210946778, 0.9097457428995559, 0.8655539921416153, 0.2182757247435193, 0.3931197577417541, 0.20661701820504463, 0.2094791961050969, 0.19407375695983076, 0.22219575385724, 0.1917059374736374, 0.49110901131392015, 0.18237599994301013, 0.08269495088094825, 0.11202492921654816, 0.09128963233290566, 0.0955950188635255, 0.09517469951281565, 0.10703495486968928, 0.08873425526346068, 0.09697454066689548, 0.15709873817077824]}, "mutation_prompt": null}
{"id": "e6d4128e-2926-49d3-8d97-04fca9026ad8", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Adaptive swarm size\n        initial_population_size = min(40, 5 * self.dim)\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population with chaotic initialization\n        eval_count = 0\n        for i in range(initial_population_size):\n            pos[i] = self.lb + (self.ub - self.lb) * np.abs(np.sin(np.random.rand(self.dim)))\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7\n        while eval_count < self.budget:\n            chaos_val = 4 * chaos_val * (1 - chaos_val)\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)\n                pos[i] = pos[i] + vel[i]\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Improved DE selection\n                if trial_value < pbest_val[i] and np.random.rand() < 0.5:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Enhance exploration with chaotic initialization and improved DE selection to balance exploration and exploitation.", "configspace": "", "generation": 71, "fitness": 0.34450098719970296, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.27.", "error": "", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.8199146249590862, 0.8646647481315861, 0.860080558481161, 0.7730776192936643, 0.8647318961816993, 0.8474259510239948, 0.8629492868292281, 0.8693437750153152, 0.8382504512894163, 0.6556199360728592, 0.614683375636724, 0.7267870613462295, 0.6947907913214075, 0.6610069961939935, 0.6946972131883669, 0.6998287427872494, 0.754486249065513, 0.6250546319565129, 0.10026070601271841, 0.0793578307286491, 0.07741807777738652, 0.11708577130748055, 0.09233853210035792, 0.10544627018143926, 0.11391212690999397, 0.08541200994687947, 0.11303616390969895, 0.08840055799306135, 0.044904836502614676, 0.0791531399097597, 0.07512003767668407, 0.09027901496374979, 0.06336826891684011, 0.09129196682198615, 0.10804923115627485, 0.09223489297422638, 0.8782054085313127, 0.8044142083412517, 0.853051126180714, 0.5202374454076442, 0.047974386621450815, 0.8604474089135159, 0.05790806531350312, 0.05214956004958238, 0.8607234222567787, 0.7304300555180774, 0.709811674857153, 0.3177157897228333, 0.720561545915348, 0.7148241701848503, 0.6505334502991218, 0.6695162145602704, 0.7341378460186665, 0.705355209804695, 0.2565777089737522, 0.15165250180505063, 0.21022973357008445, 0.37999801457933136, 0.8515336044184622, 0.3744791652158047, 0.20391880416317343, 0.8421359380372456, 0.17702743720194425, 0.6422095411133766, 0.1303760187683225, 0.5563649626292433, 0.6130976172015454, 0.6665361956409943, 0.2532848147982859, 0.6696543636764613, 0.2212459399207206, 0.4701601441215578, 0.5485111233522042, 0.510724774459813, 0.5994962391438755, 0.61362529230764, 0.5116650964664482, 0.5652870457451323, 0.6261731100787287, 0.49782436523510865, 0.5699266476412364, 0.10055531770363524, 0.04479120653945223, 0.07380476322734952, 0.11068641492401254, 0.09432448740132482, 0.2503721114406179, 0.1688363693510193, 0.2430036082596484, 0.19378040454408396, 0.26208632404588295, 0.20459459037417815, 0.17166030414783795, 0.05630632414462544, 0.05539590515419657, 0.07031479610006441, 0.1478506253566767, 0.11119773253463683, 0.1342516115839706, 0.25342235853630724, 0.32228677680960294, 0.2052403182326754, 0.2410887993980868, 0.08584131273619555, 0.12265127739343407, 0.46534039294281504, 0.36254005049757876, 0.198105916635537, 0.0194035027710463, 0.11310424151268983, 0.2758428676051501, 9.999999999998899e-05, 0.03325027136940317, 0.43271062271320415, 0.2595612114569885, 0.3014891865779983, 0.007531372178305351, 0.6631148320206672, 0.8274948177185956, 0.8029905809266105, 0.7756907127670698, 0.7941992762803392, 0.800836430670321, 0.7940900517711156, 0.8425667579172659, 0.7875085252435738, 0.10975017952406652, 0.10660269586435478, 0.045982367252308864, 0.10897139441347792, 0.12319589211887383, 0.09101635416535514, 0.11397901633654306, 0.08304132583689683, 0.115710923833376, 0.27907232269655136, 0.3359976630515975, 0.29125257812968863, 0.7589092113598194, 0.6942565722692211, 0.20738435580331083, 0.4129485626224515, 0.3672360884989244, 0.27575700760020894, 0.2404632016439151, 0.22506915986243492, 0.4435327815666219, 0.4570745782232132, 0.36691590472852953, 0.4299878342538742, 0.27075918694910317, 0.16303696568774506, 0.1669479614643984, 0.190871979447918, 0.3221532261981772, 0.10051685397452292, 0.26730012932478087, 0.33570404132260223, 0.19708629578825898, 0.22441133672268476, 0.2504373907181714, 0.23179766730480378, 0.1955939173413901, 0.23347104344549463, 0.27751186917180426, 0.21356325142425614, 0.24285467113814352, 0.21770689248717479, 0.19735387506859736, 0.23664703476311866, 0.2548039353990913, 0.19987272194817107, 0.220565387046601, 0.1920270474175284, 0.1728930270837603, 0.1736690792315132, 0.18072873261142008, 0.19829465334939267, 0.17590566492957227, 0.1904583355981776, 0.15389604769031973, 0.18698830829453128, 0.1877032172044829, 0.148148817912387, 0.15264186641309885, 0.8773256494122227, 0.1664823155754679, 0.1742584978348194, 0.16682072557591543, 0.8819815403526259, 0.8824694478420387, 0.8201003552167456, 0.2114339315185444, 0.09027707172916055, 0.1946648954931629, 0.16867959542312128, 0.7879789267484643, 0.12837942996825802, 0.19596279452828358, 0.18925142236191217, 0.1889142091033118, 0.173701626787365, 0.21279652190457254, 0.1857259857651744, 0.2134104351116194, 0.190664504029757, 0.22595557638344776, 0.08946450712867682, 0.06684629900736272, 0.0950988257063975, 0.09723319490266791, 0.07501810782300822, 0.13931298275787596, 0.10329398030330106, 0.08480890065127678, 0.09747867981855707]}, "mutation_prompt": null}
{"id": "ae35dc2a-52e9-4af9-8856-de01c7f52234", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Adaptive swarm size\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Gaussian perturbation for diversity\n                mutant += np.random.normal(0, 0.1, self.dim)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Enhance particle diversity and convergence by introducing a mutation strategy based on Gaussian perturbation.", "configspace": "", "generation": 72, "fitness": 0.2516633234981756, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.4952066433393474, 0.5081392577551603, 0.5108159004778459, 0.49688382577642465, 0.491573344558463, 0.5141925407585766, 0.47984859807171565, 0.5118167600806613, 0.4738731196098225, 0.15376114031843502, 0.10790292967601867, 0.12109584416895725, 0.09080161548984511, 0.12958577777522517, 0.13086355445380327, 0.060453171262621064, 0.07750442058033458, 0.06914927242398283, 0.13638658400937043, 0.12859953599105278, 0.10812077201454517, 0.1115797091349332, 0.10900244622166977, 0.1345914986863418, 0.11920696075261439, 0.14737640096935634, 0.11461397654696326, 0.10306793485566412, 0.10681093336208725, 0.10267735352885798, 0.10745954470740071, 0.09903749701015019, 0.14139895670598923, 0.10624168034666093, 0.0888155770396103, 0.13088912195865854, 0.9084596744759802, 0.9475642575051962, 0.9175620638868429, 0.9247491014305844, 0.9188847948701445, 0.9177205950555338, 0.9145085425165501, 0.9063361043287373, 0.8944147988254617, 0.3390488840505592, 0.34146654975761426, 0.3325767640312455, 0.34925724684247395, 0.3446190148290702, 0.3518148254501964, 0.3305725484604518, 0.33072688978824005, 0.3571489449177594, 0.421729059415369, 0.29458904472353653, 0.40544603514158206, 0.19345309764349883, 0.7386701717630523, 0.2127429983943695, 0.1777617803501862, 0.23534187168209997, 0.33916809553492155, 0.18936714960583467, 0.22744314526246978, 0.20324690593583528, 0.20038862504573485, 0.25453296398443004, 0.17458888583154353, 0.22096923758079567, 0.18725195563974328, 0.2229637328427353, 0.21136104367723596, 0.19844888771989122, 0.17599631605465604, 0.20692133877016772, 0.19601476239897608, 0.18862135092253196, 0.2204679862669009, 0.2043250090797989, 0.1930699157856075, 0.029210144072423283, 0.05823570968746539, 0.09516067225235003, 0.0470410237358303, 0.09355963527274047, 0.006232067447663581, 0.01629019170618229, 0.07879011787261991, 0.040982526708767675, 0.13242081575450082, 0.12037249267522598, 0.1394258569551421, 0.08370172246069485, 0.053461707285163196, 0.04739661425130759, 0.17247777273001097, 0.11410013476319236, 0.08701486476644982, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0018385932109573622, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12572497931034543, 0.1441797342632768, 0.13433107071540817, 0.1494078023726988, 0.1261847715937514, 0.13849636042257207, 0.13443450147017377, 0.14942989449493416, 0.1230749951130723, 0.48127400354069205, 0.46404342679448995, 0.4450988380295722, 0.42746481255162083, 0.46882885170587874, 0.4587919927401841, 0.4707753637556227, 0.43990317590419825, 0.4695743689609613, 0.11971673412783312, 0.11345281961057885, 0.09712156798405502, 0.1164287526348109, 0.10924312533520775, 0.1143188470578409, 0.11299378403851001, 0.12090406404633447, 0.10088972198735013, 0.27269894574825326, 0.17943850600629307, 0.29089167690380535, 0.301191134688347, 0.29329245112873026, 0.3102799392692156, 0.2723923053896089, 0.29247046552008893, 0.28169371788336206, 0.34201741331879465, 0.3312164929211362, 0.31868140245704357, 0.33924598771239156, 0.30747739820606523, 0.3128554031746794, 0.2876239391294232, 0.3236620279208803, 0.21631338009944, 0.23858902507999558, 0.2664937017742779, 0.2581757282607873, 0.26813120618661623, 0.26299829171584765, 0.21269299093650085, 0.2183613358485722, 0.21931316908275866, 0.18886489613435087, 0.2386567439605195, 0.24931893543489136, 0.21969273393040845, 0.2348455923185766, 0.2911399282836542, 0.23771670139886214, 0.2036525710993583, 0.22090499601134417, 0.23907129331969523, 0.19708180446450463, 0.21327586087581862, 0.19506978214446824, 0.1953800380473958, 0.187877920995985, 0.17108416420355532, 0.19605196707312456, 0.33126881420428245, 0.19540630864378195, 0.18717786295027905, 0.18743559063743365, 0.14713036645536592, 0.7154156761202786, 0.19966334115157702, 0.17801924389292456, 0.7127953903493961, 0.1686403202715595, 0.16686041045509825, 0.6621592747909578, 0.1560436419227399, 0.7156310763001303, 0.21039447836701863, 0.1666126400658301, 0.6309257338232889, 0.6446655093184259, 0.6908833718060804, 0.6493899695302694, 0.18302361932272204, 0.1967556885196433, 0.17442845586432554, 0.17570068157029695, 0.17515395327926875, 0.19426013354471083, 0.1745152864272883, 0.18199823653073743, 0.1782908373086417, 0.099884934145547, 0.07167191250929938, 0.08446668266472257, 0.08702504490265361, 0.09097380123266141, 0.09441471841074112, 0.09098960113416343, 0.08327375789442193, 0.09178935056196247]}, "mutation_prompt": null}
{"id": "8d939df2-33e1-49ab-acb3-d37d4fdce8f9", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Adaptive swarm size\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                # Adaptive cognitive and social components\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + self.c1 * r1 * (pbest[i] - pos[i]) \n                          + self.c2 * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce adaptive learning rates using chaotic maps for enhancing exploration and convergence in hybrid PSO-DE.", "configspace": "", "generation": 73, "fitness": 0.4246396711240844, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.28.", "error": "", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.8739048260572071, 0.8434330418748452, 0.8672822330106084, 0.8670714646802591, 0.8416246631991553, 0.8624127220989672, 0.864825533691138, 0.8723007119115994, 0.8546152238552903, 0.6990612400259772, 0.6147121440558238, 0.6981507194519969, 0.6845025939936752, 0.5676352672558143, 0.6856541873153452, 0.6818536772169236, 0.6720541043212327, 0.6255218986412407, 0.07687934741315405, 0.15682243752746816, 0.1615723311023567, 0.12539002899097973, 0.12304421100175256, 0.132805500019057, 0.09179070963934433, 0.12334867996241539, 0.12086378211313986, 0.12192909243775596, 0.08833898819386754, 0.1319035259353426, 0.11126349543539038, 0.0909569487040135, 0.09804295037445832, 0.14065633461725735, 0.08783093258426655, 0.11585097176022119, 0.9111368695475646, 0.9194721386439662, 0.9266203749636551, 0.9085825609157056, 0.9351197372921218, 0.9110567613500653, 0.9254232634374828, 0.911644414357569, 0.9250981894329374, 0.7249015299436861, 0.6958862259360393, 0.6902589271685471, 0.7114584481153947, 0.6950413231275265, 0.7321015528662536, 0.7064960430985902, 0.6914128332456044, 0.7290045395773986, 0.9106943437789584, 0.22907017694209475, 0.22551577320533134, 0.2790873477399657, 0.872669580406508, 0.21743836667812033, 0.17654457299512505, 0.1771905740047658, 0.2369471358719506, 0.7187929229671675, 0.6259277478711688, 0.6810731576244915, 0.5619095220816102, 0.6726410428650241, 0.6567801115559027, 0.676210338453858, 0.5596479364170315, 0.565364786564647, 0.6097335881252859, 0.5359945414641993, 0.6331797264056935, 0.6105818866052581, 0.5819112245577143, 0.5857987770952817, 0.6387984922399912, 0.6775116507569701, 0.6133773801637954, 0.29051703731146494, 0.14472036152774526, 0.21176417094863564, 0.3094894954631231, 0.1327770854111604, 0.13100607749179782, 0.1417770469149109, 0.11076880545420298, 0.12712642826283205, 0.21993236088367984, 0.11926340589657469, 0.16507287978877627, 0.08629901687701491, 0.04400321629616921, 0.12031198837935098, 0.16381135408880343, 0.3756764092610472, 0.2300531044320493, 0.42467277336625353, 0.219929161398141, 0.38306556258867974, 0.1787989682801202, 0.11610689457397516, 0.1324483284325919, 0.15619688470117776, 0.3042335099904153, 0.1377388340752428, 0.3845017638316086, 0.27440157172086477, 0.3231443849681558, 0.4658023420246802, 0.3892276451773634, 0.5109578987934561, 0.4655849896568165, 0.4472952512852242, 0.459400584419861, 0.809541548671032, 0.7955839771505979, 0.7949108958145259, 0.8083272600829104, 0.7674831332199061, 0.8096698068043309, 0.8078857870071344, 0.7716941315213557, 0.8189106530054577, 0.11452184993903958, 0.07724800364283768, 0.08863699105843093, 0.14339812219670167, 0.15842547111062455, 0.13065116907147312, 0.7118166497218562, 0.1307009155655554, 0.13452375945850958, 0.7410613217528921, 0.6560232592078459, 0.21827325882906834, 0.7630312249647839, 0.6720470519562592, 0.2709757621220926, 0.2840226673367111, 0.6832105734064438, 0.2423075716450913, 0.43307221804979623, 0.5506513829727122, 0.546457065377998, 0.6552449555675848, 0.5967580914394984, 0.5282269618322875, 0.5074523213731712, 0.4306178465704008, 0.25879232505283123, 0.35599523690493096, 0.42414233587285977, 0.2451058624551784, 0.33717761119662126, 0.22250103404163502, 0.4338732946257692, 0.250968100352561, 0.30017221011556894, 0.2695076872500869, 0.21664692466721647, 0.2402070135485268, 0.23119237169126294, 0.2526532578698638, 0.2165798013426833, 0.23704046023447167, 0.2867378771776299, 0.6303258114857978, 0.2324855464591037, 0.18864256020548587, 0.18116183511410522, 0.19263779140129378, 0.22645222239634244, 0.22080031285796753, 0.19674896181225632, 0.18310437519788603, 0.22394416740056267, 0.1812806168514033, 0.1877023036772223, 0.1878023285600693, 0.18813104906853062, 0.9144024821254102, 0.19993691294341598, 0.9175273958516094, 0.13647523675889317, 0.1167004122587526, 0.9161710235430364, 0.8992599065023937, 0.15556984795538498, 0.9025755619515181, 0.2100839640054193, 0.2094510912388492, 0.8706213283550276, 0.8262222476622667, 0.9089054639901075, 0.8318044202631222, 0.34289695861521263, 0.18285361709814074, 0.2980731576973866, 0.24920704169983832, 0.21449870456209574, 0.29555518170957706, 0.24553807893814483, 0.19489844400925027, 0.30179275745159173, 0.10803269593157783, 0.09231669485403204, 0.08523638017877344, 0.11405249509134341, 0.0932764203967299, 0.09923812617565642, 0.09499743984221332, 0.10711968837748376, 0.07810828553201155]}, "mutation_prompt": null}
{"id": "8d5b148e-1f19-49e6-9cb7-072726607d6b", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Adaptive swarm size\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity with Lévy flights\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n                levy = np.random.standard_cauchy(self.dim) * 0.01\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)]) + levy\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Incorporate Lévy flights for enhanced exploration and adaptively update mutation strategy for diverse search dynamics.", "configspace": "", "generation": 74, "fitness": 0.3143430825073137, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.6367989945397048, 0.6345562915767551, 0.6347095854725031, 0.6238951083858958, 0.624706527106792, 0.6335371241032499, 0.6295861020764714, 0.6162462612585531, 0.6252492585751959, 0.2619208485927035, 0.18881079487536967, 0.2306681419198613, 0.2722027444338476, 0.2005584376004863, 0.253611995213631, 0.2509692468750917, 0.24361057732142677, 0.27375928690401263, 0.20914676589902614, 0.17523008003243468, 0.1762481949925857, 0.15772073643288242, 0.23418858498949335, 0.1339495896258177, 0.14570911900859662, 0.15856956912618403, 0.14292203405851267, 0.1443183955245828, 0.15376286532107664, 0.12802253311817025, 0.13940612711935774, 0.1383809816890058, 0.1607528438637531, 0.11768257398757109, 0.14523005205502726, 0.13390151818293672, 0.9522055917199198, 0.9353341723696609, 0.9309657024852891, 0.9065970640773494, 0.8967647959652376, 0.9105992263994969, 0.9258833132225415, 0.9172661435069738, 0.9224874364794385, 0.46447745936622953, 0.4395314424322775, 0.4242628621212772, 0.44928713778034157, 0.4480352610832933, 0.43818321769463586, 0.4566106554835213, 0.4623781914759739, 0.44922580450526606, 0.229906389618438, 0.1712082962918433, 0.2291254099538449, 0.19503146101581859, 0.9033337425451675, 0.8951741844133119, 0.233762459313392, 0.8690847487651393, 0.9134345608841412, 0.3540649615510312, 0.2681931774748486, 0.3276718476482231, 0.2704976403078887, 0.22594925676445698, 0.30274242167147913, 0.2888876557865905, 0.3239526609276314, 0.29694504282687906, 0.27345785978800197, 0.2810934990730468, 0.2614256727885843, 0.3168077980867864, 0.27129205191198935, 0.24590412338952572, 0.2960558917105216, 0.31128177127947143, 0.28261380306898076, 0.07627212837250064, 0.06366289820059623, 0.17471506858590524, 0.09077845784241922, 0.13691731010458075, 0.03246836261142361, 0.03521183742817191, 0.1688904491073241, 0.08203774783805329, 0.11912509402554283, 0.12060594786084455, 0.09221532509002095, 0.08872781279978603, 0.21084689193404027, 0.05212067537056264, 0.16165596165441953, 0.2451148808341641, 0.1289705045153009, 0.08147507200614856, 0.11797674617173726, 0.06109206035913417, 0.051368794596656886, 0.05779465775331427, 0.09213942212637216, 0.06869840615978051, 0.06780120570750137, 0.04903749790053624, 0.203230514384806, 0.20919000824340095, 0.1870877609775211, 0.17089952705584133, 0.1429758448066899, 0.19223769688472647, 0.14726487065452842, 0.17188578045687974, 0.15213371422511102, 0.5649690884625546, 0.5273970882741053, 0.5467037675384365, 0.5140562679710898, 0.5322342113936767, 0.5160168689643785, 0.5320005805462247, 0.5387263727943904, 0.5180642022047524, 0.1193514778408995, 0.11445200007160661, 0.12626507388884434, 0.13058002533802848, 0.11558314821617333, 0.13044544184881857, 0.13094861364040067, 0.15102379669938693, 0.10981489097101771, 0.2128981227635337, 0.4096971512315877, 0.40091672935433276, 0.2206427693546893, 0.20927064716934718, 0.38867184008933786, 0.4309427177313533, 0.35374827088404304, 0.25468283895952903, 0.20836230089215046, 0.38994365370932316, 0.28962234958962985, 0.2508269031703906, 0.3860537528891991, 0.39411207107008916, 0.37734674556510506, 0.37030723795905185, 0.2637271899688006, 0.25017316722777094, 0.23347055925473814, 0.3231151429855147, 0.2400566511078267, 0.3011487457919081, 0.31157901899921703, 0.21833275990403977, 0.24895208174806316, 0.23602678059335502, 0.19848322125040163, 0.24236123727338232, 0.22939401986680508, 0.24875124848726804, 0.20498384273109382, 0.46947163077864384, 0.22095885452506114, 0.2833893851964234, 0.2188885847151435, 0.1846141551879673, 0.19138061354397584, 0.22218011330484766, 0.2016440747169449, 0.20883301121589992, 0.20815422303656506, 0.183052627939024, 0.18442353319977778, 0.19986315964805645, 0.9082835731279374, 0.18155750113684088, 0.9043641137284276, 0.17314453605953573, 0.20060637693949224, 0.2004882151198759, 0.12250708774304953, 0.9145002438641517, 0.16712791335986565, 0.8240964452354704, 0.8783046678062661, 0.8208750434888861, 0.2116704891221739, 0.8749958777057522, 0.7747641461810166, 0.8248024062358869, 0.16705728918157525, 0.8738174915078419, 0.20028211161735543, 0.18526816307358818, 0.18475324910387092, 0.19300701669534948, 0.19735037089131946, 0.17472249711970012, 0.18111529266789672, 0.18235819941895126, 0.18648061340021294, 0.08720927772780562, 0.11786110288754648, 0.08282813087926788, 0.0874164537848765, 0.09028100409548767, 0.1504931361587002, 0.09390932508571803, 0.08728337802728914, 0.09427373462411415]}, "mutation_prompt": null}
{"id": "75b215b2-1ce5-47ee-aba9-c34dbdf4a241", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7\n        while eval_count < self.budget:\n            chaos_val = 4 * chaos_val * (1 - chaos_val)\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)\n                pos[i] = pos[i] + vel[i]\n\n                # New stochastic perturbation using gamma distribution\n                gamma_perturb = np.random.gamma(2.0, 0.5, self.dim)\n                pos[i] += gamma_perturb * dynamic_factor\n\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Enhance exploration by introducing gamma distribution-based stochastic perturbations in velocity updates.", "configspace": "", "generation": 75, "fitness": 0.08693819238358146, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.08.", "error": "", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.1649843092728459, 0.16213421028488717, 0.21378024560466502, 0.11701410636055953, 0.16837156761853822, 0.10841002534228716, 0.19722298043560305, 0.14436334438541565, 0.1460517597671176, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003995877882771448, 0.0035402241569799653, 0.00019068529860311045, 9.999999999998899e-05, 0.0007351255900408527, 0.018746162589444837, 0.045579707210480214, 0.036866770127359616, 0.03439559191039865, 0.03800866475393683, 0.046438762870253614, 0.031769138320298373, 0.030310497471604525, 0.031626466977505485, 0.0289812780970804, 0.035116111650199344, 0.04498364692377399, 0.03324456958578825, 0.039140644187106055, 0.01477939845611742, 0.044994616246625485, 0.03623578930001081, 0.019943710886265453, 0.40925963833552337, 0.5036927539580764, 0.37483810647943494, 0.13345334387798125, 0.06505379190370697, 0.07424007256111109, 0.07793536771818221, 0.06068649263322712, 0.06077339125833792, 0.17101325651339716, 0.1473084141151979, 0.11160357540285748, 0.08571223123575689, 0.08186348359062778, 0.09376543605186927, 0.02672641534417275, 0.03813957572499116, 0.02687735090996335, 0.12602432925930385, 0.0804306439192225, 0.1382096629864542, 0.1371919071369535, 0.1458109787895404, 0.09587688302805764, 0.0875901370845017, 0.13515472007003226, 0.11318431450562039, 0.03161580910812023, 0.04239763634986171, 0.04558215624805906, 0.03338798418056266, 0.03290211397897835, 0.028013853034338343, 0.02861397961525003, 0.03676084928858914, 0.03546932239603762, 0.0528718517413419, 0.05002590104303983, 0.0669694393669451, 0.03819007861632184, 0.03460487087002728, 0.03249006920262387, 0.05164049474571708, 0.030928340892383277, 0.03943843379781642, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00011680692486770727, 0.00011791338531896844, 9.999999999998899e-05, 0.004722377715890791, 0.004191727406517409, 0.00876611476977418, 0.005714486552868436, 0.0025397319872386692, 0.015287032360742914, 0.0037623321186011083, 0.00514602834219291, 0.004993829721669729, 9.999999999998899e-05, 9.999999999998899e-05, 0.00015461028006535926, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002184840522037046, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002372772230683995, 0.002155876981353111, 0.0020224302827830387, 0.008838967875818393, 0.019773223796888284, 0.006630346944650811, 0.029502607035626016, 0.015331614648497083, 0.01550990026071708, 0.17501271204141344, 0.20820973551601085, 0.2163311151468561, 0.22028271360532858, 0.15344415224169006, 0.16564892275237708, 0.18130028369550388, 0.19553708444247264, 0.20867449932660231, 0.028461886509816403, 0.03428051736177329, 0.02108077944337783, 0.019773414993927152, 0.04270400739496305, 0.026956134377750685, 0.027537387508508426, 0.015775900610310645, 0.031317557771878834, 0.10982058145427964, 0.12163008198027803, 0.14813859284224795, 0.1393997781403321, 0.15029052778972196, 0.16545719892155009, 0.12352706216460807, 0.10811814792751062, 0.11875779892668448, 0.14944463677342623, 0.18742257556727393, 0.15985233131688525, 0.1654167175791017, 0.13513153545976475, 0.1762073138136604, 0.13802731809921154, 0.19424228176141178, 0.140872772089918, 0.1380568894011227, 0.1207473255610948, 0.11589933551630749, 0.0930796013867119, 0.08453932682155885, 0.117447111335784, 0.10673423505717905, 0.12706236778505786, 0.11258261544047277, 0.1265488425121153, 0.1327922260487423, 0.14414609391020172, 0.14588599034095517, 0.13681314946403123, 0.12405480162596827, 0.15060239649752183, 0.13150321717730895, 0.14460754870843884, 0.07848045199510811, 0.0935210521850115, 0.16037637736745014, 0.0705827630372532, 0.06182764160171861, 0.1450489657602697, 0.06783840702741639, 0.15350512635725244, 0.13381813416128951, 0.12809829116843718, 0.1223781202516111, 0.1402915937629312, 0.12747527099870692, 0.1436436785048123, 0.11774831323781987, 0.09618968605368283, 0.13401151153912705, 0.1251149979210261, 0.1756352527209858, 0.18288940558147726, 0.151322858367558, 0.08821633609150503, 0.10310583649938176, 0.11838668701636712, 0.14991699699686267, 0.09824490471309111, 0.2785195627638015, 0.16945290053285988, 0.17274520012362105, 0.16374290832930205, 0.17212315249496335, 0.17944710097147476, 0.1689974240508696, 0.18911253228741842, 0.172911462825578, 0.2068376091954438, 0.028698260008978682, 0.034735229396844036, 0.039317153758034906, 0.06495836186840698, 0.03492878711932612, 0.040913300856386, 0.03244063092343963, 0.03812828369038124, 0.04973723668965957]}, "mutation_prompt": null}
{"id": "651452a4-3559-4fec-a610-62bc58a27a82", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        initial_population_size = min(40, 5 * self.dim)\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7\n        while eval_count < self.budget:\n            chaos_val = 4 * chaos_val * (1 - chaos_val)\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor\n                r1, r2 = np.random.rand(2)\n                vel_gaussian = np.random.normal(0, 0.1, self.dim)  # Gaussian perturbation\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i])\n                          + vel_gaussian)  # Added Gaussian perturbation\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)\n                pos[i] = pos[i] + vel[i]\n\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Incorporate a dynamic velocity update mechanism using Gaussian perturbations to enhance exploration.", "configspace": "", "generation": 76, "fitness": 0.22495347829486131, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.439369702940794, 0.4472049093166778, 0.4209639431480745, 0.4280170739409642, 0.4372819808801356, 0.45000704117812695, 0.4396990285536764, 0.44853291404595386, 0.4544101098092467, 0.008085197655151255, 0.02646425754245152, 0.07707178159941364, 9.999999999998899e-05, 0.040274562593452745, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0998374131034756, 0.14874415824497378, 0.10300756197033589, 0.11682065623384519, 0.14122940471233836, 0.12551743675042104, 0.0962809298236531, 0.14785294173712504, 0.10235517249503934, 0.11463610045028927, 0.09379111725400835, 0.07742744790941847, 0.12424610076948883, 0.10139268574750226, 0.11768599323527074, 0.09286714207145563, 0.10699990852593377, 0.09087132168525391, 0.9290000345751234, 0.9207864410390625, 0.9291664845202587, 0.8494985150119221, 0.8849744701529675, 0.9166222075390277, 0.8992947577756902, 0.9089062852224752, 0.9263257141733539, 0.2983853870857359, 0.3064525943259375, 0.3130598841895462, 0.31325852198877135, 0.3144950983635043, 0.3082302332727519, 0.31080914901718515, 0.2991606235669877, 0.2994453788238417, 0.242465181499811, 0.2268380720312262, 0.2269259996945966, 0.7674172955773431, 0.6258424439925772, 0.3214075760703289, 0.23433637719069977, 0.2206307637278263, 0.46934257331129214, 0.1880083659766666, 0.17887074636338895, 0.1835090320699656, 0.17644157434150276, 0.17694302380464, 0.17765042552397503, 0.17418026717312896, 0.17729071240750816, 0.1948265706470308, 0.19022621273460605, 0.18845098981680275, 0.17061105301687507, 0.17766208969977926, 0.17659201850768436, 0.16974361510209968, 0.18984898149838314, 0.17827575070980983, 0.16602482370788763, 0.0016959005485085443, 0.04801951295280327, 0.041736894164382976, 0.03421309984427712, 0.003627994937779433, 0.04421732406113921, 0.032398473927830684, 0.0633152393726013, 0.07280942977195759, 0.1128463791844444, 0.09307479541603447, 0.10414672054278706, 0.08518196062887184, 0.09620740501001768, 0.053625074965706676, 0.13819555607028378, 0.10390889303103701, 0.08026261259296985, 9.999999999998899e-05, 9.999999999998899e-05, 0.004898123316160463, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002585744661506295, 0.08814214503273832, 0.10548371164838077, 0.08222586815670241, 0.10028740303807626, 0.10969342376386171, 0.11972240458920513, 0.08282425442154051, 0.11066175990077587, 0.09537453319376543, 0.4016096607236562, 0.4124455276251485, 0.399484393878758, 0.42355482402228795, 0.41071723305782826, 0.43326701221766095, 0.41268289590367135, 0.42986614495380004, 0.40837537339370333, 0.10789073108693414, 0.09606480013436336, 0.07745419222392991, 0.11795934006459152, 0.08499462037953653, 0.11269569006019953, 0.13562884369533545, 0.15519569801282285, 0.13092693292991986, 0.2452070176631319, 0.2516094605889607, 0.2520819484669118, 0.2854074138165036, 0.24784826692548545, 0.23393106897236082, 0.2681634487194535, 0.23286869853553838, 0.25089293433851356, 0.2899511635754438, 0.3017588083872915, 0.30007357459945494, 0.2908393549397189, 0.2959133471937636, 0.3005220423416032, 0.27918956628808633, 0.286230380029593, 0.233798988875753, 0.23369395991615982, 0.23670806777250197, 0.2377825036605974, 0.24256831168689785, 0.20663363410691982, 0.23003407723518055, 0.19553322785389193, 0.207748503713307, 0.19720534682243196, 0.23626458768120395, 0.22695598782399629, 0.229869880906853, 0.2515601599069288, 0.24548966219881763, 0.23261924640202758, 0.27507095212969257, 0.24928455084820522, 0.24494581904321666, 0.18187081959711326, 0.19691783035903954, 0.18612132568993078, 0.19165012493059752, 0.2201556435283034, 0.18570222526787128, 0.1892174306293325, 0.18113792037714727, 0.1901130538345155, 0.1583896633404076, 0.1767703663995278, 0.18646529322839955, 0.6344755942921305, 0.1994980297256138, 0.1525692002501331, 0.12225126417655885, 0.17798992857874996, 0.16661215579945599, 0.5837784534559012, 0.15622894331530535, 0.21072098423355423, 0.20873972937833285, 0.16776747764891986, 0.21133196049755976, 0.10406088670169922, 0.7004635738827474, 0.6089119341806866, 0.17911601146034606, 0.18217400460765532, 0.1805040568087405, 0.17833482348269591, 0.18683022598756893, 0.19388815495141942, 0.1973103046677005, 0.18515065766936, 0.17691027189886976, 0.0891479711574823, 0.09081638430608274, 0.07576336044385368, 0.07704787926333523, 0.08847611287415402, 0.08568996213661972, 0.08971880555460632, 0.08327027714398372, 0.09538457432917125]}, "mutation_prompt": null}
{"id": "85d811cc-51e1-4324-828a-c486e140a967", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Adaptive swarm size\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with Gaussian perturbation\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[c]) + np.random.normal(0, 0.1, self.dim)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Enhance mutation strategy with a self-adaptive mutation rate and introduce Gaussian perturbation for better exploration.", "configspace": "", "generation": 77, "fitness": 0.2590857609987715, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.48896378676346053, 0.5496089591268067, 0.5003358065505458, 0.4909689490095608, 0.48332009206827975, 0.4816521721011999, 0.5097540346026213, 0.532015903876186, 0.4834098108230833, 0.12437540612440912, 0.11472064685890548, 0.12281560566022276, 0.11891563774082259, 0.06508870589890126, 0.0976693405595217, 0.1047590671881462, 0.12444089358284405, 0.0749915478873161, 0.09559373663457993, 0.14248477846677465, 0.09719341432278839, 0.10709525996012614, 0.15021367183970957, 0.12686662281344196, 0.09844582340044761, 0.1304572219223623, 0.10986189017167058, 0.12429499216639395, 0.08280464520461228, 0.10551850694509013, 0.09192711560937661, 0.10721840915275627, 0.11739776591853424, 0.12851362673599376, 0.1119546824242128, 0.1501350871487448, 0.9139358772832473, 0.9401375915083735, 0.9167179110065303, 0.912459619800918, 0.9126903542330036, 0.9263891713927863, 0.9109888010174304, 0.9049776297780832, 0.9058960488605535, 0.3267211387493345, 0.3470149082790318, 0.36573644523969784, 0.3607407445194867, 0.3503420202918942, 0.344450462449545, 0.3649327132888448, 0.32376435371277923, 0.33579812429380707, 0.8450501986585477, 0.17040713400160634, 0.2300759428017588, 0.21397704949495455, 0.21308376321790234, 0.7276945153882957, 0.22883887147713045, 0.8500984092487156, 0.6926829418856377, 0.20183326733449425, 0.17877609616209045, 0.20034999591051306, 0.20380197896024488, 0.19191684498803752, 0.11151031783368781, 0.12931689840989113, 0.19092778886107575, 0.22358208525591394, 0.197531986651847, 0.194544778015029, 0.18816931746112187, 0.20788401882420493, 0.18511697575514807, 0.20965107160609608, 0.21843287748511453, 0.23308506906526105, 0.22189911845441557, 0.0685868291377757, 0.0010088657175792992, 0.09881353970800044, 0.04383251394956822, 0.036481525042031726, 0.0691927954800724, 0.06753354349844631, 0.08050128047025318, 0.0917763220883051, 0.10364286974687598, 0.0626000552644671, 0.14395535460454467, 0.10058756137721014, 0.05984094551817454, 0.04041819321716178, 0.11826766041836712, 0.12540070335363795, 0.09137631458786366, 0.0075752669745629, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010104881561280532, 9.999999999998899e-05, 0.11940046579795749, 0.10926812071565295, 0.13457946401595, 0.136072220168581, 0.13464086547618404, 0.14149426950498833, 0.11452529740683515, 0.14074172709465216, 0.09602914017875519, 0.4665006847406624, 0.4411823939029108, 0.479470457450037, 0.4489217037726412, 0.4438747365628193, 0.4396841355896248, 0.44511435810058464, 0.46848644542279627, 0.46312889401564694, 0.08882001483918756, 0.15308479314640533, 0.10869528670479556, 0.08693199930989337, 0.07674598672993216, 0.11274516317854288, 0.13441852173888014, 0.11433068407460101, 0.11266298011714859, 0.18356186367210925, 0.3031796848396424, 0.2777868525365249, 0.32110738183634036, 0.3012270541890206, 0.3347031575354793, 0.3341507036654968, 0.19529841728652886, 0.33603635889299843, 0.31101589033311616, 0.3200387544881713, 0.31073813695127006, 0.32123793380204024, 0.3067890843618457, 0.32231141883709546, 0.3238773502383361, 0.3231436795136462, 0.239557372902387, 0.2711768607991265, 0.2711332436881382, 0.2188855961317938, 0.22971330243344046, 0.2171486185441116, 0.2629133002628802, 0.20524315129216486, 0.2143610537494628, 0.21756018024318224, 0.2420016530029513, 0.20325152204924735, 0.23933418919258997, 0.21828007204317712, 0.22124737366097458, 0.21803703472739033, 0.2609827442251218, 0.24486236662249672, 0.2157199309302873, 0.19523941610928774, 0.22102811658301902, 0.21031317355736523, 0.24651803804593186, 0.1831985511805322, 0.1945513096660375, 0.20605226861468262, 0.2019318675318792, 0.19000195213444426, 0.18741039294242878, 0.18714128003710306, 0.18715571073274562, 0.7445703409189481, 0.19950477468052163, 0.7573227052256148, 0.726615031564807, 0.7355296904193547, 0.16688328493871218, 0.6738301255685148, 0.15607983053900476, 0.6085088310439308, 0.6344018240969842, 0.7115549908770114, 0.6862408054518386, 0.16731088217910783, 0.10387064574722404, 0.16756064991052722, 0.180109979337573, 0.16944322575510995, 0.19200925114149991, 0.19203577769730618, 0.18407704655166102, 0.19003655858883217, 0.18819551999719553, 0.18016285396447362, 0.18915093501948665, 0.10717756750507346, 0.0871886280026214, 0.09672333060330363, 0.12621565467192408, 0.09405205951937479, 0.12601400575236332, 0.09496621899303159, 0.08440204768097814, 0.08915925752731668]}, "mutation_prompt": null}
{"id": "66491f38-ef41-42ac-99e6-1236a2389100", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Adaptive swarm size\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints with dynamic shrinkage\n                shrink_scale = 0.1 * dynamic_factor\n                lower_bound = self.lb + shrink_scale * np.abs(gbest)\n                upper_bound = self.ub - shrink_scale * np.abs(gbest)\n                pos[i] = np.clip(pos[i], lower_bound, upper_bound)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, lower_bound, upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Integrate adaptive search space shrinkage to enhance convergence in later stages of optimization.", "configspace": "", "generation": 78, "fitness": 0.43945002823363244, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.29.", "error": "", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.8964206944703741, 0.8960278223286653, 0.9045273574548113, 0.8919832422953199, 0.8872922632655282, 0.8857977239099419, 0.8872191220032141, 0.886555094769296, 0.8862689119775718, 0.7591525832599065, 0.7632479567446157, 0.7868665254491491, 0.783308827175808, 0.7668088327151754, 0.7745883246449268, 0.7701635914058801, 0.7517897972190136, 0.7235230365934928, 0.09592263448960525, 0.15863141246762769, 0.1395467041438473, 0.12506856891072293, 0.10745414400434061, 0.7849039391091094, 0.08595388255345948, 0.10064177268181684, 0.09606806603572582, 0.1108192439032264, 0.09457166688363416, 0.1011637494351002, 0.10579554620668497, 0.10032003648376375, 0.13091949277729453, 0.09548048122248198, 0.11057214275949445, 0.1094000250927718, 0.13883900712829378, 0.1385943755613207, 0.1389427828694857, 0.1396087201536318, 0.13972237390822317, 0.1393446895311603, 0.1391221348893228, 0.13874205208174772, 0.1390956247126589, 0.8064681634259238, 0.800347316741438, 0.7970204363026713, 0.7916493504398963, 0.7885035118544196, 0.7923543628464067, 0.7978454466848715, 0.7659113465701886, 0.812382702708114, 0.254018782833049, 0.22762947844659254, 0.2281683503727744, 0.2816455393847265, 0.28046401503566365, 0.2782430015214078, 0.1300706343230018, 0.8857174755199222, 0.2375605080713169, 0.7739814557166229, 0.13423497914291238, 0.7195057108951408, 0.775189319064967, 0.8175577825552502, 0.7649866585351497, 0.7507866714461321, 0.7449420583091557, 0.7332744354814753, 0.7610396859749939, 0.7793951247279525, 0.6742593630228897, 0.7780116170671519, 0.7328124801909137, 0.7354768147142803, 0.7007181569288763, 0.8095245334961361, 0.7087068935237706, 0.5242386853204362, 0.4536944696799191, 0.6072967196155138, 0.48825799357778754, 0.5974946181979078, 0.5883472736824914, 0.17965224057583418, 0.4719521241436885, 0.41764982554480934, 0.5745243537174887, 0.15375299744731297, 0.15015191767228608, 0.29321952666777984, 0.10805878871738894, 0.1435054324690651, 0.17289739480279676, 0.26711805906124897, 0.39632499028948676, 0.49327579623440654, 0.44204660752091596, 0.4483625962379403, 0.4072670476283946, 0.5025294553305921, 0.33836606750600673, 0.2917469693443314, 0.3177216925126426, 0.304436914343157, 0.5786415091166247, 0.5334168967944292, 0.573718518160913, 0.616186197984469, 0.6267392609146148, 0.6738913771192162, 0.6446509648674842, 0.6360123999348503, 0.6116519768512211, 0.8610967917649227, 0.8374583932578876, 0.8722713989150843, 0.8384778091523581, 0.8512336846690741, 0.8209319715054698, 0.8733661935079078, 0.8611724256711744, 0.8527595344624803, 0.08133579599549579, 0.14348246371864537, 0.09726707151162428, 0.12438678996038688, 0.08490975752028496, 0.1587206242781829, 0.1592691301159992, 0.1600860758585101, 0.08477646064471267, 0.23531897960273196, 0.2051506068534168, 0.3093977380889722, 0.7792966493023755, 0.2288145795984653, 0.34609078250324243, 0.49427375140665786, 0.4896768270683055, 0.8231252893832723, 0.207098314749405, 0.5782156208297133, 0.39102703237505165, 0.5717628292680779, 0.5438682203812, 0.5974999145467699, 0.2592762175342196, 0.3153426178850155, 0.27570508655715664, 0.12120178075298371, 0.318179788502158, 0.23439959119603282, 0.5172762313801029, 0.25088836949593796, 0.41379344054080924, 0.25101585880650135, 0.573654079607808, 0.24137501663054794, 0.28229300860372053, 0.2990159646668883, 0.22362648970230015, 0.23705837422953036, 0.23852426329836307, 0.2417442082189275, 0.22223971730894043, 0.24580206169961039, 0.2641979766979188, 0.19465129961228067, 0.1905104449895051, 0.18835444382472055, 0.1816756222179765, 0.20808362450817364, 0.19255990262894906, 0.18878783403917354, 0.1917691190986509, 0.1844752979630161, 0.18737159058693864, 0.1877091363788972, 0.18812599879455372, 0.9378859516886429, 0.9062511892043774, 0.9279719542573863, 0.1664430985051213, 0.1678117993621685, 0.9279515935483823, 0.9221886052163759, 0.15575948653152283, 0.9187188813728043, 0.897765437512055, 0.8887576731615092, 0.8931363121101327, 0.10454698955177211, 0.9089721110380249, 0.870816666647865, 0.2241613083104046, 0.21591209850015847, 0.181983066904442, 0.24909452071735882, 0.21015729465538424, 0.3077178717444369, 0.24810757135372186, 0.46005416170949065, 0.20131144562343894, 0.10041903826541898, 0.10304333053194681, 0.09150933857421428, 0.09641675524231341, 0.10385746064724932, 0.08968890140365715, 0.0842131635135922, 0.08595451653889308, 0.11233173695332721]}, "mutation_prompt": null}
{"id": "f6f95cc0-7fea-4768-acb8-ab4d2b0cce20", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Adaptive swarm size\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce adaptive swarm size for enhanced exploration and exploitation balance in high-dimensional spaces.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.8980982671425689, 0.8903620049616174, 0.8988530611711405, 0.8932545471037056, 0.8879154653212531, 0.8890776578998386, 0.9042764617925443, 0.8948881339175825, 0.8926399277431314, 0.7908067798577216, 0.7963171525200662, 0.7691463443415147, 0.7861521281885755, 0.7384137833213005, 0.7650494658557858, 0.7466613163384963, 0.8042553946121596, 0.7401977461471319, 0.09686491762940641, 0.145015521164934, 0.13954667723027014, 0.08883147126247481, 0.12158071203809828, 0.14246759369462292, 0.08543604575781005, 0.11651216537128928, 0.1162232479695906, 0.10534666367404988, 0.1086401808715809, 0.12403561892945958, 0.1227838869170047, 0.08498647002862958, 0.12356918866601574, 0.11000272194217109, 0.09543067418859152, 0.10413182813264699, 0.8958457553630623, 0.9246980758595659, 0.9323430571211943, 0.927032995465498, 0.9357906118174969, 0.9219894036722209, 0.9257246401286136, 0.9238429026721982, 0.9158375560873677, 0.8099376705121574, 0.7859071482188211, 0.7918956257504677, 0.7988631115655729, 0.7660517694318512, 0.7997006651978558, 0.8038183917965578, 0.7797472939535286, 0.8205850281208377, 0.38807573057643796, 0.17149815958416603, 0.9105896054967318, 0.27820565968291533, 0.27906288564467063, 0.2135173465459378, 0.17567178859102317, 0.23475900167451713, 0.23639384099425564, 0.6891818550484219, 0.7413015948242958, 0.7375993174483211, 0.6921773842727268, 0.7851112254472163, 0.8121672872946074, 0.7335859109949809, 0.691808571318207, 0.7438793313686154, 0.705381006632888, 0.6886452689873384, 0.6742593630228897, 0.7691078317494832, 0.7354137983733264, 0.716902588099091, 0.7246718764776938, 0.8182057555730377, 0.6973296071471353, 0.524893278044298, 0.4296464440984693, 0.5493206255078452, 0.6230360912480866, 0.6847390247958334, 0.5104569876012623, 0.35558761012610474, 0.05774367894119936, 0.6149010330788307, 0.4836028770289629, 0.1388648764035899, 0.25062484185558664, 0.09340076878800885, 0.1494128162296724, 0.18668711084426837, 0.6545725008506056, 0.4982670797334592, 0.5937474246296442, 0.653771929586086, 0.5439759084240299, 0.45045689671437106, 0.4063654786256097, 0.38795635816597174, 0.32685456056179707, 0.1725896044098516, 0.25776338338783733, 0.2080706296499335, 0.5485038800943953, 0.5709549654799707, 0.6339652926559953, 0.6283242778850056, 0.6302775999301897, 0.5094604233391413, 0.6604543331652382, 0.6183887924627371, 0.6634161129421416, 0.8591162780685626, 0.8505580464302733, 0.8394734888313469, 0.8622647211860525, 0.8390210774642543, 0.8752653826045191, 0.8507340190038861, 0.8617439993919205, 0.8616848052623161, 0.11452668487522444, 0.08228366196261327, 0.09726637485734013, 0.18664310345540502, 0.10972184044380551, 0.12373335059792623, 0.13179927379653944, 0.16048668281489276, 0.09687209892983262, 0.7873333939552076, 0.7843569123740535, 0.5856973986138074, 0.815023028448911, 0.2761734433558286, 0.28614424771092883, 0.4092221860622195, 0.30768046306464614, 0.6135558264340026, 0.2130167059980066, 0.40232050913594075, 0.40551795513375866, 0.6511583344603477, 0.6369067104320095, 0.6129057971117586, 0.268607726949018, 0.5469124533101808, 0.2703053765794261, 0.19427000405457895, 0.6913011763681616, 0.3472487640823215, 0.4338078050637949, 0.18869346325186942, 0.334133580159647, 0.23807541446036917, 0.27394981901033266, 0.2804557103015498, 0.23814228457314124, 0.28805358365635503, 0.20806208085382683, 0.28191557864204553, 0.2875265961561123, 0.23246959346219032, 0.21567681290459673, 0.21630425114797203, 0.27832859324631964, 0.1990356445113528, 0.19024722065370958, 0.18835444382472055, 0.1996563884567848, 0.17782043899333622, 0.19293191137465648, 0.20830239769180137, 0.19119739874781738, 0.19971124404113327, 0.18733477652643205, 0.18751372198126215, 0.18802518346360553, 0.9358614324669595, 0.9151489283521499, 0.9221329925234291, 0.12219346890577631, 0.16849441433361156, 0.9258514390751847, 0.8943999291853538, 0.15605264424403797, 0.8732948373149961, 0.9011077453515852, 0.20976578610640595, 0.8817999887606904, 0.8894531210946778, 0.9097457428995559, 0.8655539921416153, 0.2182757247435193, 0.3931197577417541, 0.20661701820504463, 0.2094791961050969, 0.19407375695983076, 0.22219575385724, 0.1917059374736374, 0.49110901131392015, 0.18237599994301013, 0.08269495088094825, 0.11202492921654816, 0.09128963233290566, 0.0955950188635255, 0.09517469951281565, 0.10703495486968928, 0.08873425526346068, 0.09697454066689548, 0.15709873817077824]}, "mutation_prompt": null}
{"id": "059391f8-b51a-4d01-abd2-485c85ec9320", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Adaptive swarm size\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce adaptive swarm size for enhanced exploration and exploitation balance in high-dimensional spaces.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.8980982671425689, 0.8903620049616174, 0.8988530611711405, 0.8932545471037056, 0.8879154653212531, 0.8890776578998386, 0.9042764617925443, 0.8948881339175825, 0.8926399277431314, 0.7908067798577216, 0.7963171525200662, 0.7691463443415147, 0.7861521281885755, 0.7384137833213005, 0.7650494658557858, 0.7466613163384963, 0.8042553946121596, 0.7401977461471319, 0.09686491762940641, 0.145015521164934, 0.13954667723027014, 0.08883147126247481, 0.12158071203809828, 0.14246759369462292, 0.08543604575781005, 0.11651216537128928, 0.1162232479695906, 0.10534666367404988, 0.1086401808715809, 0.12403561892945958, 0.1227838869170047, 0.08498647002862958, 0.12356918866601574, 0.11000272194217109, 0.09543067418859152, 0.10413182813264699, 0.8958457553630623, 0.9246980758595659, 0.9323430571211943, 0.927032995465498, 0.9357906118174969, 0.9219894036722209, 0.9257246401286136, 0.9238429026721982, 0.9158375560873677, 0.8099376705121574, 0.7859071482188211, 0.7918956257504677, 0.7988631115655729, 0.7660517694318512, 0.7997006651978558, 0.8038183917965578, 0.7797472939535286, 0.8205850281208377, 0.38807573057643796, 0.17149815958416603, 0.9105896054967318, 0.27820565968291533, 0.27906288564467063, 0.2135173465459378, 0.17567178859102317, 0.23475900167451713, 0.23639384099425564, 0.6891818550484219, 0.7413015948242958, 0.7375993174483211, 0.6921773842727268, 0.7851112254472163, 0.8121672872946074, 0.7335859109949809, 0.691808571318207, 0.7438793313686154, 0.705381006632888, 0.6886452689873384, 0.6742593630228897, 0.7691078317494832, 0.7354137983733264, 0.716902588099091, 0.7246718764776938, 0.8182057555730377, 0.6973296071471353, 0.524893278044298, 0.4296464440984693, 0.5493206255078452, 0.6230360912480866, 0.6847390247958334, 0.5104569876012623, 0.35558761012610474, 0.05774367894119936, 0.6149010330788307, 0.4836028770289629, 0.1388648764035899, 0.25062484185558664, 0.09340076878800885, 0.1494128162296724, 0.18668711084426837, 0.6545725008506056, 0.4982670797334592, 0.5937474246296442, 0.653771929586086, 0.5439759084240299, 0.45045689671437106, 0.4063654786256097, 0.38795635816597174, 0.32685456056179707, 0.1725896044098516, 0.25776338338783733, 0.2080706296499335, 0.5485038800943953, 0.5709549654799707, 0.6339652926559953, 0.6283242778850056, 0.6302775999301897, 0.5094604233391413, 0.6604543331652382, 0.6183887924627371, 0.6634161129421416, 0.8591162780685626, 0.8505580464302733, 0.8394734888313469, 0.8622647211860525, 0.8390210774642543, 0.8752653826045191, 0.8507340190038861, 0.8617439993919205, 0.8616848052623161, 0.11452668487522444, 0.08228366196261327, 0.09726637485734013, 0.18664310345540502, 0.10972184044380551, 0.12373335059792623, 0.13179927379653944, 0.16048668281489276, 0.09687209892983262, 0.7873333939552076, 0.7843569123740535, 0.5856973986138074, 0.815023028448911, 0.2761734433558286, 0.28614424771092883, 0.4092221860622195, 0.30768046306464614, 0.6135558264340026, 0.2130167059980066, 0.40232050913594075, 0.40551795513375866, 0.6511583344603477, 0.6369067104320095, 0.6129057971117586, 0.268607726949018, 0.5469124533101808, 0.2703053765794261, 0.19427000405457895, 0.6913011763681616, 0.3472487640823215, 0.4338078050637949, 0.18869346325186942, 0.334133580159647, 0.23807541446036917, 0.27394981901033266, 0.2804557103015498, 0.23814228457314124, 0.28805358365635503, 0.20806208085382683, 0.28191557864204553, 0.2875265961561123, 0.23246959346219032, 0.21567681290459673, 0.21630425114797203, 0.27832859324631964, 0.1990356445113528, 0.19024722065370958, 0.18835444382472055, 0.1996563884567848, 0.17782043899333622, 0.19293191137465648, 0.20830239769180137, 0.19119739874781738, 0.19971124404113327, 0.18733477652643205, 0.18751372198126215, 0.18802518346360553, 0.9358614324669595, 0.9151489283521499, 0.9221329925234291, 0.12219346890577631, 0.16849441433361156, 0.9258514390751847, 0.8943999291853538, 0.15605264424403797, 0.8732948373149961, 0.9011077453515852, 0.20976578610640595, 0.8817999887606904, 0.8894531210946778, 0.9097457428995559, 0.8655539921416153, 0.2182757247435193, 0.3931197577417541, 0.20661701820504463, 0.2094791961050969, 0.19407375695983076, 0.22219575385724, 0.1917059374736374, 0.49110901131392015, 0.18237599994301013, 0.08269495088094825, 0.11202492921654816, 0.09128963233290566, 0.0955950188635255, 0.09517469951281565, 0.10703495486968928, 0.08873425526346068, 0.09697454066689548, 0.15709873817077824]}, "mutation_prompt": null}
{"id": "6ef6e8ae-b3f7-4cc7-b4ac-37f3bcd3eed4", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Adaptive swarm size\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce adaptive swarm size for enhanced exploration and exploitation balance in high-dimensional spaces.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.8980982671425689, 0.8903620049616174, 0.8988530611711405, 0.8932545471037056, 0.8879154653212531, 0.8890776578998386, 0.9042764617925443, 0.8948881339175825, 0.8926399277431314, 0.7908067798577216, 0.7963171525200662, 0.7691463443415147, 0.7861521281885755, 0.7384137833213005, 0.7650494658557858, 0.7466613163384963, 0.8042553946121596, 0.7401977461471319, 0.09686491762940641, 0.145015521164934, 0.13954667723027014, 0.08883147126247481, 0.12158071203809828, 0.14246759369462292, 0.08543604575781005, 0.11651216537128928, 0.1162232479695906, 0.10534666367404988, 0.1086401808715809, 0.12403561892945958, 0.1227838869170047, 0.08498647002862958, 0.12356918866601574, 0.11000272194217109, 0.09543067418859152, 0.10413182813264699, 0.8958457553630623, 0.9246980758595659, 0.9323430571211943, 0.927032995465498, 0.9357906118174969, 0.9219894036722209, 0.9257246401286136, 0.9238429026721982, 0.9158375560873677, 0.8099376705121574, 0.7859071482188211, 0.7918956257504677, 0.7988631115655729, 0.7660517694318512, 0.7997006651978558, 0.8038183917965578, 0.7797472939535286, 0.8205850281208377, 0.38807573057643796, 0.17149815958416603, 0.9105896054967318, 0.27820565968291533, 0.27906288564467063, 0.2135173465459378, 0.17567178859102317, 0.23475900167451713, 0.23639384099425564, 0.6891818550484219, 0.7413015948242958, 0.7375993174483211, 0.6921773842727268, 0.7851112254472163, 0.8121672872946074, 0.7335859109949809, 0.691808571318207, 0.7438793313686154, 0.705381006632888, 0.6886452689873384, 0.6742593630228897, 0.7691078317494832, 0.7354137983733264, 0.716902588099091, 0.7246718764776938, 0.8182057555730377, 0.6973296071471353, 0.524893278044298, 0.4296464440984693, 0.5493206255078452, 0.6230360912480866, 0.6847390247958334, 0.5104569876012623, 0.35558761012610474, 0.05774367894119936, 0.6149010330788307, 0.4836028770289629, 0.1388648764035899, 0.25062484185558664, 0.09340076878800885, 0.1494128162296724, 0.18668711084426837, 0.6545725008506056, 0.4982670797334592, 0.5937474246296442, 0.653771929586086, 0.5439759084240299, 0.45045689671437106, 0.4063654786256097, 0.38795635816597174, 0.32685456056179707, 0.1725896044098516, 0.25776338338783733, 0.2080706296499335, 0.5485038800943953, 0.5709549654799707, 0.6339652926559953, 0.6283242778850056, 0.6302775999301897, 0.5094604233391413, 0.6604543331652382, 0.6183887924627371, 0.6634161129421416, 0.8591162780685626, 0.8505580464302733, 0.8394734888313469, 0.8622647211860525, 0.8390210774642543, 0.8752653826045191, 0.8507340190038861, 0.8617439993919205, 0.8616848052623161, 0.11452668487522444, 0.08228366196261327, 0.09726637485734013, 0.18664310345540502, 0.10972184044380551, 0.12373335059792623, 0.13179927379653944, 0.16048668281489276, 0.09687209892983262, 0.7873333939552076, 0.7843569123740535, 0.5856973986138074, 0.815023028448911, 0.2761734433558286, 0.28614424771092883, 0.4092221860622195, 0.30768046306464614, 0.6135558264340026, 0.2130167059980066, 0.40232050913594075, 0.40551795513375866, 0.6511583344603477, 0.6369067104320095, 0.6129057971117586, 0.268607726949018, 0.5469124533101808, 0.2703053765794261, 0.19427000405457895, 0.6913011763681616, 0.3472487640823215, 0.4338078050637949, 0.18869346325186942, 0.334133580159647, 0.23807541446036917, 0.27394981901033266, 0.2804557103015498, 0.23814228457314124, 0.28805358365635503, 0.20806208085382683, 0.28191557864204553, 0.2875265961561123, 0.23246959346219032, 0.21567681290459673, 0.21630425114797203, 0.27832859324631964, 0.1990356445113528, 0.19024722065370958, 0.18835444382472055, 0.1996563884567848, 0.17782043899333622, 0.19293191137465648, 0.20830239769180137, 0.19119739874781738, 0.19971124404113327, 0.18733477652643205, 0.18751372198126215, 0.18802518346360553, 0.9358614324669595, 0.9151489283521499, 0.9221329925234291, 0.12219346890577631, 0.16849441433361156, 0.9258514390751847, 0.8943999291853538, 0.15605264424403797, 0.8732948373149961, 0.9011077453515852, 0.20976578610640595, 0.8817999887606904, 0.8894531210946778, 0.9097457428995559, 0.8655539921416153, 0.2182757247435193, 0.3931197577417541, 0.20661701820504463, 0.2094791961050969, 0.19407375695983076, 0.22219575385724, 0.1917059374736374, 0.49110901131392015, 0.18237599994301013, 0.08269495088094825, 0.11202492921654816, 0.09128963233290566, 0.0955950188635255, 0.09517469951281565, 0.10703495486968928, 0.08873425526346068, 0.09697454066689548, 0.15709873817077824]}, "mutation_prompt": null}
{"id": "d62d7e05-3d87-4cc4-b17a-dd06593f95ff", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Adaptive swarm size\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with tournament selection\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                tournament = np.random.choice([a, b, c], 2, replace=False)\n                a, b = tournament if pbest_val[tournament[0]] < pbest_val[tournament[1]] else tournament[::-1]\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce tournament selection for enhanced diversity and resilience in local optima.", "configspace": "", "generation": 82, "fitness": 0.46796450974931836, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.30.", "error": "", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.9004477552377305, 0.9027207055738538, 0.8964155739585137, 0.8887581453355919, 0.890835503319932, 0.9005647661122663, 0.8909887646908501, 0.8859429769421786, 0.8869170618869638, 0.7732980763408661, 0.7611401541965305, 0.7520705039381173, 0.7665746143725959, 0.7441124992999766, 0.7701677999046646, 0.7465353007391746, 0.7299791764106045, 0.7625469923552998, 0.14539874421779042, 0.16148058712738889, 0.16082888614911373, 0.18262638893677474, 0.14441406261083556, 0.15982726370822964, 0.08912731987511724, 0.1589051681546898, 0.1613461055764145, 0.12082464332605736, 0.0719188469007811, 0.09389156852087621, 0.13137563347225145, 0.1004603895841838, 0.14447421482638256, 0.10940159427486962, 0.09526547294461252, 0.10973872163046983, 0.9420785887876155, 0.9384033820213962, 0.9178902027436884, 0.9186976765973823, 0.915343989142473, 0.9238514835310786, 0.916868181044481, 0.9020347787287458, 0.925660028674393, 0.7918468276744607, 0.8125474505495999, 0.7976965696780235, 0.7826839194781929, 0.7994039623340811, 0.7873804172369863, 0.8073951139066857, 0.7905558434551666, 0.7896890918269548, 0.2297775129158114, 0.17044035832541393, 0.1708031288712969, 0.27916579393944707, 0.894774998847567, 0.9137677301438062, 0.23138196453685, 0.23443282386140718, 0.23491616836069185, 0.1340633307815613, 0.7685302194775742, 0.7617293352192424, 0.7766949221907414, 0.7167623985055372, 0.6470452480981296, 0.6996606402607528, 0.6915966503012148, 0.13467381106732046, 0.7216625176780851, 0.7437074708485027, 0.7088553264521591, 0.6997677503867356, 0.7263622562133454, 0.7160537086976395, 0.7280018201652109, 0.7239480686734401, 0.7811755666353009, 0.5728477189129111, 0.5684010730585356, 0.3847732308052505, 0.5093137565005259, 0.38920402155343525, 0.2936258261247576, 0.5579373006731462, 0.4836464346368654, 0.6426488486913217, 0.6011442328651185, 0.19269086314576533, 0.18812391553094143, 0.24239910244964835, 0.10675560335862033, 0.07601820025615524, 0.4085807480852631, 0.4344820598415241, 0.35711163827952264, 0.30694304938372097, 0.5633067988665866, 0.5273595300738908, 0.37533050204295637, 0.627755401940749, 0.5502333050152849, 0.269840657559415, 0.2875092087476523, 0.15405529338815482, 0.6684585165834498, 0.5496928743340544, 0.5059004985317859, 0.652829793681684, 0.6240180333826026, 0.6472864981861361, 0.6254628526419664, 0.5859828158455834, 0.5486002516026487, 0.8561183903961674, 0.8451238087238788, 0.8583950388911369, 0.8560149387987347, 0.8393050025657722, 0.8489619500552981, 0.8599824228788929, 0.862717370783039, 0.8497458534164968, 0.08755958240504003, 0.10021877877864804, 0.15938288207956008, 0.12396133423032263, 0.13216257874674453, 0.14394242720760664, 0.11700191974793162, 0.15874222477995314, 0.14532740296791802, 0.28262172705641364, 0.22586163879209464, 0.22162770389664588, 0.3624636388183772, 0.7348393815150893, 0.8079677488191197, 0.6558961165476401, 0.20980298385418983, 0.37064103550041716, 0.7080812149635713, 0.5886610929456835, 0.6443136474966125, 0.4356818500690488, 0.4549920068636142, 0.21519779125018035, 0.1939657617243673, 0.7587554815346814, 0.584674168322199, 0.33045694308121687, 0.26112694614552, 0.4321297642532482, 0.42892471682386335, 0.2396822693322943, 0.4736162944163267, 0.24313041606282548, 0.21787508718027226, 0.6392907769842087, 0.23293015647169213, 0.22531990338565033, 0.2996640398248155, 0.2601611921049646, 0.26852537159138457, 0.25327993471496046, 0.2520903469294862, 0.2185458033004114, 0.2200138320109586, 0.19030204268773565, 0.20854894448680372, 0.2532719301289218, 0.1899752542191926, 0.18619130072569678, 0.22508219093170323, 0.1992935193620694, 0.17708503830281208, 0.20826403072005373, 0.18791389560124183, 0.9352727654900441, 0.14828027975014535, 0.18626183734441226, 0.2004182437635872, 0.20017056410395606, 0.12207573285576367, 0.9256493427990655, 0.16763294447014543, 0.9203564399744092, 0.15649841136444775, 0.915636325516427, 0.20903688457147274, 0.1688276589579798, 0.9152967035428736, 0.8822843553255479, 0.8825911942193381, 0.856198862225103, 0.20127610314538547, 0.23010683238990814, 0.17813124900478938, 0.2553810175748257, 0.23101953061393343, 0.21045153353043555, 0.5571879482911197, 0.5448207742862433, 0.21400632281514154, 0.09012841409104477, 0.08819402920279118, 0.08907106608163706, 0.10964486992078204, 0.09190908756807858, 0.09175627020949828, 0.09781341121077125, 0.10136453484201724, 0.11081025769985231]}, "mutation_prompt": null}
{"id": "1525a970-6b67-47d3-a755-5e929a35a74d", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Adaptive swarm size\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1) * dynamic_factor\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce adaptive mutation scaling based on convergence speed to improve exploration and exploitation balance.  ", "configspace": "", "generation": 83, "fitness": 0.4704774923478244, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.30.", "error": "", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.899740692595655, 0.8989320785488939, 0.8889498815199848, 0.8878971842594361, 0.8850830992902157, 0.8895134453434586, 0.8887653764897787, 0.8825054406941686, 0.8887125064413975, 0.7563673248754803, 0.7561728491093335, 0.7866127384899722, 0.7847253856899963, 0.7751613533693842, 0.79024923614805, 0.7151907953033129, 0.7631588996727241, 0.7603307893701956, 0.09605191905120769, 0.11657141048286213, 0.10975217898142275, 0.11121180980499645, 0.11620890185850152, 0.10526312998804466, 0.08287478990891106, 0.11046769562751402, 0.11014321758587087, 0.1237233189120216, 0.12395324449665224, 0.11065135324689113, 0.12328982552374601, 0.09585361713546425, 0.12075858572997544, 0.11036636147378054, 0.1042133970864414, 0.12910785949265013, 0.8973572600115816, 0.9246885436253792, 0.9262045686189003, 0.9239038614549887, 0.9338854868402888, 0.9250661428020549, 0.930156437651245, 0.9107203206396746, 0.9159328049109223, 0.805196528441764, 0.7910846269706169, 0.7998765608054472, 0.8180267596539151, 0.8015378308914146, 0.8066980489772624, 0.8061698303589954, 0.7890952742375839, 0.8078153452677542, 0.9115637177128159, 0.17149815958416603, 0.22660191694710452, 0.2213480971080075, 0.2786215952833009, 0.21340533898561054, 0.15052616075764003, 0.17780846657983473, 0.23652272911838035, 0.7624920944870792, 0.733768112250124, 0.7565723106548512, 0.7122696423177608, 0.7669549601769896, 0.8269969967709853, 0.7520007094001677, 0.7478844458003757, 0.7822373644929552, 0.7096707264084858, 0.7034411521173053, 0.6672591993709893, 0.7529634955905284, 0.6841832072256668, 0.74636939737817, 0.7375524271301444, 0.8078271895479134, 0.6902819381484797, 0.5552002544206109, 0.4678445422723799, 0.5157998913250575, 0.5216065916912052, 0.65576318683637, 0.5803423144472408, 0.525852322645453, 0.6187512381037144, 0.5484786588280226, 0.27600223111469, 0.1414390377982272, 0.4843262285090112, 0.19227958228073416, 0.09706608377742543, 0.17939587020654113, 0.5624790580318593, 0.4669679018302523, 0.5964857447485266, 0.38619345751778933, 0.32083036448900626, 0.490662731979137, 0.4672347213834317, 0.35290796110405276, 0.34119499208423554, 0.17780753014688466, 0.30346859799692516, 0.22824702093220495, 0.6295369442095864, 0.5280917305727981, 0.5666635389873091, 0.6605173050128224, 0.6448132074745876, 0.6642843378476413, 0.6181507193453872, 0.6348732840019744, 0.6286543936555893, 0.8639511701575294, 0.8497278478812935, 0.8573216261601918, 0.8467378307139106, 0.8397726947704476, 0.8563188789611743, 0.8531023984344517, 0.8276559810162287, 0.8675287547139616, 0.11481122478984163, 0.08268802344042414, 0.0864071836081235, 0.14302508015209547, 0.12362204360306384, 0.1438395210066672, 0.1447953865864523, 0.18803077369435617, 0.14156777727789027, 0.3397566225660078, 0.22479933646585137, 0.3787825670907371, 0.5786647784403296, 0.7776840647628884, 0.3893132846239552, 0.4113810119800141, 0.15377542294959623, 0.4300801966691602, 0.41343172451672583, 0.5041331474228078, 0.5996430131326111, 0.5000916764039722, 0.30207062032238485, 0.4290502391404367, 0.26902062051079734, 0.46137118459524196, 0.2705668934146741, 0.2872569232393801, 0.4935102383966844, 0.354339912453722, 0.3315198144975393, 0.21663374584955897, 0.43901297209000933, 0.1950160931388436, 0.2731203931619235, 0.28898822374621114, 0.25465631624131035, 0.23892243256972012, 0.24179909465137994, 0.26006403118688803, 0.27094973575096415, 0.26783827499391544, 0.22509974525171506, 0.22937474226790744, 0.2167609483828623, 0.18674774387057969, 0.19015137677194593, 0.19666711694485117, 0.1992560473692636, 0.17751551576448144, 0.19263825558309478, 0.1962444609220284, 0.18157000604922102, 0.19986143705186077, 0.18742856212753556, 0.18747599725527653, 0.1880182591499271, 0.9337889657617795, 0.9175222782256518, 0.925447410360258, 0.13474102268218302, 0.16847967424539578, 0.9231008275184592, 0.8974550208293726, 0.15603056856343334, 0.8834685655400263, 0.8869558882768827, 0.20976519052646914, 0.15467826234770765, 0.8746882172264295, 0.9125986435405924, 0.845576778801252, 0.4945891618870062, 0.2093054569326277, 0.2027223118008663, 0.19291458453986066, 0.21625193364368356, 0.26016799731570794, 0.19058117083000758, 0.2205674910766624, 0.2069959424027371, 0.1173978243932059, 0.11130685221435577, 0.1161006698953222, 0.11475607005300958, 0.12275528439047212, 0.09112043022632021, 0.1026500391021713, 0.10157621233183323, 0.12333952622872513]}, "mutation_prompt": null}
{"id": "90875271-9e03-458e-85c8-d48c55556660", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Adaptive swarm size\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            # Adjust population size dynamically\n            current_population_size = int(initial_population_size * (0.5 + 0.5 * dynamic_factor))\n            if current_population_size < initial_population_size:\n                pos = pos[:current_population_size]\n                vel = vel[:current_population_size]\n                pbest = pbest[:current_population_size]\n                pbest_val = pbest_val[:current_population_size]\n\n            for i in range(current_population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(current_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Improve convergence by introducing dynamic population size adjustment based on convergence progress.", "configspace": "", "generation": 84, "fitness": 0.45087203827533684, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.30.", "error": "", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.8969028036501963, 0.9021729318465953, 0.9116230601360765, 0.9042139027916952, 0.8934969059885781, 0.8911639128471087, 0.8975356011009333, 0.8910325093009219, 0.8968808357686382, 0.7821951015041522, 0.7946749796042851, 0.7550304488530754, 0.7865793195016278, 0.7479835243751989, 0.7679099092784321, 0.7422932717147144, 0.7649014136166434, 0.7725077557312072, 0.1609365921965875, 0.11592617628254087, 0.11535684841705096, 0.09960510079151175, 0.1247326484238982, 0.1177887009679327, 0.10910828416860041, 0.1247869714016655, 0.09569650567484878, 0.09945611788582287, 0.10885971608023426, 0.09554276534918338, 0.09523900711524635, 0.09296859016006476, 0.08780400018118184, 0.0851451817857265, 0.10539597897566222, 0.05940297204554734, 0.9277501184502537, 0.936246627291204, 0.9081638741209546, 0.914600173572011, 0.9278189561855424, 0.9126382682323109, 0.9345380393026635, 0.9160016330452502, 0.9116309320689439, 0.8069862531068557, 0.8046259365758694, 0.7922964209359835, 0.7967249312142445, 0.8201046087495123, 0.8118379994356029, 0.8001947585416254, 0.7904101826460208, 0.8083793542548234, 0.23077370617605997, 0.2119995147422783, 0.1713683820367805, 0.3766496567247315, 0.9229206962619347, 0.2104973912338387, 0.813897893849317, 0.1514939046286352, 0.23623747570732223, 0.13529159528270607, 0.7148483388642052, 0.6924618014867074, 0.720045796370868, 0.13567863509364875, 0.8039445875535312, 0.803649051575975, 0.7231275757182892, 0.7754649474648221, 0.7587886804372561, 0.7429712276814242, 0.771658475078899, 0.7323939602522902, 0.7515911482835345, 0.13714474106540253, 0.7432410306968649, 0.7320992120807914, 0.7786100387496496, 0.6469881020605619, 0.5719869903169474, 0.24261673870259715, 0.2832596351594078, 0.32677048835586, 0.5404498956139078, 0.5204161051394147, 0.17847659281406414, 0.5986187788096177, 0.1809990000007009, 0.15761532722489935, 0.16071721547658357, 0.16007660413158176, 0.17978106935243054, 0.37012971738977307, 0.20600089725400061, 0.4160384334793723, 0.5424801492361614, 0.21833134739282467, 0.4474250836390026, 0.25681256567495325, 0.49807823710966626, 0.49213393050893606, 0.5623184283622982, 0.1839725111785907, 0.15731039795890978, 0.3156223676227662, 0.4680306061370082, 0.5988011159260884, 0.435950616365139, 0.5515282253562417, 0.67066205192617, 0.6151674943808365, 0.5987713409589419, 0.4985094698022624, 0.3766063252945657, 0.8610555935526656, 0.8538835529083378, 0.8777421810524423, 0.7986254117709893, 0.8425686487408337, 0.8784521509559726, 0.8620617907017418, 0.8693588456003332, 0.8596432179382416, 0.06852300525378685, 0.13049446750427196, 0.10780163863265901, 0.09080092605978751, 0.13091621907957274, 0.16035888493898143, 0.11756322783001683, 0.07979134879716165, 0.09733626569052323, 0.5815908444413174, 0.8140662326315266, 0.18970725067832883, 0.27784259114182885, 0.2877030186767703, 0.21307959246632413, 0.26312135210300525, 0.8176691765977151, 0.47043689092521157, 0.3723761091742217, 0.43516191713892993, 0.4498729335244779, 0.6026057462628738, 0.5610020154525996, 0.6092449247343651, 0.2391916573244166, 0.6174675462376396, 0.2571005206873098, 0.3085895081833604, 0.5046656224019153, 0.33334920569106097, 0.39783599434572503, 0.3574216119646578, 0.465354250042323, 0.20953880202313702, 0.30300159368555757, 0.2026860033980573, 0.23567165771159004, 0.27494664386662204, 0.25444994667340803, 0.26538359801962663, 0.2813751632592455, 0.29826655986920314, 0.24475111868303523, 0.23602114150999298, 0.211353379784622, 0.1933751805194025, 0.21686301816828046, 0.18285562829629232, 0.22632317026729964, 0.19108836618285985, 0.2036664183211122, 0.1936366386531756, 0.19918413455195683, 0.18276133282779317, 0.15778765763159552, 0.18834313941775582, 0.18700643723071608, 0.929597362266702, 0.1995422379130427, 0.1999167052178703, 0.16619118399022825, 0.9285684215959753, 0.9448751070626766, 0.11333271283553126, 0.1561486063054225, 0.8908025291483234, 0.9120667727348076, 0.1549767976243127, 0.9264990943844628, 0.9106139956272257, 0.1667510814913894, 0.8664461508657417, 0.1790924525286135, 0.198641929637131, 0.2397550118174958, 0.2461644109139669, 0.23144143826666208, 0.2291618696004185, 0.19266268900183892, 0.2650904720222358, 0.19835998067844984, 0.0945454773506994, 0.0851739334527074, 0.07942738218688394, 0.09361293590125375, 0.13853877271131865, 0.09424498237985957, 0.08209004808260234, 0.09500156313826169, 0.10315280389618364]}, "mutation_prompt": null}
{"id": "4daf715a-6f12-43e2-8b81-57b295938e33", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            self.w = ((self.w_max - self.w_min) * chaos_val + self.w_min) * (self.budget - eval_count) / self.budget\n            \n            for i in range(initial_population_size):\n                c1_adaptive = 1.5 + 0.5 * chaos_val  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val)  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -chaos_val * self.vel_max, chaos_val * self.vel_max)  # Chaotic velocity clamping\n                pos[i] = pos[i] + vel[i]\n\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce chaotic velocity clamping and adaptive inertia for enhanced exploration and exploitation balance.", "configspace": "", "generation": 85, "fitness": 0.3896272667184493, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.28.", "error": "", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.8601067999329652, 0.8500599608930071, 0.8709875883010704, 0.85586327750659, 0.8444809336670805, 0.856490324668834, 0.8570118806359157, 0.8535362384104731, 0.8551499738796935, 0.7102530021998128, 0.630675234612899, 0.693054319456923, 0.7127305413888774, 0.6792541657579921, 0.7022252314936472, 0.6347884645130826, 0.6585769763005103, 0.6803562628227364, 0.08402568852623749, 0.15896913448974792, 0.14081376789626088, 0.1127336383117803, 0.12146649048910407, 0.13079945518235403, 0.1375218615437923, 0.09858321067781184, 0.15510482758953725, 0.10844753971592713, 0.12036303005117732, 0.0909721535269955, 0.10987738030676142, 0.10641370051700083, 0.11948155837626329, 0.07535254678168679, 0.09285424420175226, 0.09278985340892809, 0.8701280070435122, 0.8906769964449051, 0.893135275710776, 0.8430025638471123, 0.8866071319562628, 0.8676885423382051, 0.8967602004969394, 0.8894974397334816, 0.849506713821749, 0.7443560092142375, 0.7218147125189877, 0.7242227971358917, 0.7405699493421388, 0.7382028793395176, 0.7358278067693717, 0.7396498844208315, 0.7143601170508942, 0.7370266333177697, 0.17102085390410426, 0.16972496911502277, 0.19658623496332006, 0.2769913328875917, 0.37550204831466094, 0.8892314811176552, 0.17531837345622137, 0.20490651813820093, 0.8414053682319057, 0.6414293750227364, 0.5538208963434335, 0.6248386323903233, 0.5793233289382483, 0.12985705397248348, 0.12849309014701815, 0.13202444963702364, 0.12973751319914062, 0.6129382490564693, 0.13335657812678892, 0.5371655733627823, 0.5757457843433114, 0.6159852986974739, 0.5503523930370988, 0.5847506639728653, 0.5302325456239413, 0.49779421417372594, 0.6139727065898406, 0.22203977063252722, 0.23716388273482247, 0.2623640603717745, 0.10629134431945453, 0.035390182553448946, 0.09627110207560052, 0.10265839973523994, 0.07282209880732093, 0.07060420188900607, 0.15413128232556372, 0.1959837611133386, 0.1896705462062066, 0.08797132327946822, 0.08896824988363627, 0.06153776831792823, 0.22364563826184747, 0.23392424261962375, 0.10870217444470032, 0.328205010960105, 0.14235987146116003, 0.2891104437145672, 0.12854924633180276, 0.10950106632800294, 0.13295442137706137, 0.1825150157525025, 0.1719643883545432, 0.1291369428689001, 0.25243994185242513, 0.20810695178717897, 0.21644165321105657, 0.3645900479947859, 0.48029731422083566, 0.40520288906085467, 0.3335113198606986, 0.3230490164937463, 0.40778181326526175, 0.7660789898176313, 0.7734757976491153, 0.7758232462258455, 0.7539847802968633, 0.7066305142170006, 0.7352409516998928, 0.7474545128159786, 0.7763514240245724, 0.7864183736447254, 0.105837276275351, 0.07731522086823095, 0.0651493796538023, 0.1524470092520298, 0.1073989938339378, 0.13002683409432192, 0.1411660540455867, 0.13723905521036273, 0.07926373854162505, 0.26855282969582384, 0.5790585862271262, 0.20003834416680843, 0.664064524298196, 0.37167453768916936, 0.3885322536999751, 0.20079468931966593, 0.4626166579277283, 0.663313093405095, 0.47200228469882777, 0.6671525673915808, 0.6305658541251438, 0.5822294351013285, 0.5217432039996854, 0.6824961411317968, 0.2651353730130578, 0.5228004888739386, 0.2652291202572179, 0.24726235655728224, 0.33254504433197185, 0.233130048601509, 0.3634960975646613, 0.2655605113084152, 0.3821898292036817, 0.2535578343651448, 0.4782416412182259, 0.21878022245993012, 0.23457251389237133, 0.29911560132741155, 0.2879877016872715, 0.26241091844255804, 0.24039687140816368, 0.2538101286471822, 0.2120838445851969, 0.22180677871261945, 0.2523011948482339, 0.17090324930153, 0.1946489871297693, 0.18336432246876777, 0.19900501441619411, 0.19458418808725242, 0.17067846113145702, 0.19071465379080432, 0.20619653348936395, 0.19386516005564658, 0.18708822206430398, 0.18606533466975517, 0.18571884826606233, 0.9128168659559223, 0.1967803790876722, 0.16824601816768558, 0.15208796295935734, 0.89160336971879, 0.16503927591819156, 0.8713192734872458, 0.8548471049758712, 0.8813419188703102, 0.8879277260071855, 0.16757144549242386, 0.8430113411055434, 0.16678854820947053, 0.8785577417082946, 0.8353306909638545, 0.23051120864859154, 0.2100859685974057, 0.23017044900224337, 0.19816424964773338, 0.19611893847742978, 0.199339265476411, 0.21426195944832427, 0.20747577693879782, 0.2353742575923169, 0.0879715406436522, 0.10027696506821282, 0.07783948172587385, 0.0799967625570609, 0.10272422961930439, 0.10814821064865698, 0.10136109835089557, 0.10427902129512256, 0.10116848382922017]}, "mutation_prompt": null}
{"id": "34d1caf6-9d13-4177-bd44-7ae72bc929a5", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        initial_population_size = min(40, 5 * self.dim)\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7\n        while eval_count < self.budget:\n            chaos_val = 4 * chaos_val * (1 - chaos_val)\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)\n                pos[i] = pos[i] + vel[i]\n\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n\n                # Integrate chaotic random search\n                if np.random.rand() < 0.1:\n                    mutant += 0.2 * (np.random.rand(self.dim) - 0.5) * (self.ub - self.lb)\n\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Integrate chaotic random search with adaptive velocity control to enhance convergence speed and exploitation capabilities.", "configspace": "", "generation": 86, "fitness": 0.4721946255221571, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.30.", "error": "", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.8910916539861573, 0.897467275155071, 0.8904816156970791, 0.881952083556603, 0.8823476821511113, 0.8710053476274244, 0.8759475667516838, 0.8960444623277334, 0.881340437237238, 0.7831701171953186, 0.7225476546999225, 0.7429456028401865, 0.725340464648502, 0.7699372940644984, 0.7199636909399698, 0.7390279381402841, 0.7105287160637265, 0.7126946640746223, 0.12264021328620589, 0.12193198643587566, 0.14220906928188903, 0.11133674102201241, 0.1047953608534592, 0.14624762801608782, 0.09235133986391264, 0.1165624524504476, 0.8192698453569563, 0.1152957754887759, 0.10514775810371124, 0.10268404742167747, 0.09209749541823586, 0.08389308589249356, 0.10045929995133063, 0.10717070316917165, 0.09100866557053633, 0.13068674709173045, 0.9208889629638634, 0.9168270645981549, 0.9128857413678803, 0.90793486135513, 0.9176273051842928, 0.9501946174083549, 0.9160482207688656, 0.9053318914182055, 0.9065754222294418, 0.7853729765252713, 0.7896357927193244, 0.7883186989609632, 0.7790374761280592, 0.7939636070303021, 0.7926081618309767, 0.7935057388378262, 0.7751761110050446, 0.7712611667538416, 0.8856698024648079, 0.1712614850438018, 0.22844302585442955, 0.2118093168420473, 0.28114168638833303, 0.8928441513332007, 0.21388968030874222, 0.234474078602964, 0.23733460697490816, 0.13351939119110467, 0.8081646993425176, 0.7444383298576189, 0.6719090624619477, 0.7330107952533902, 0.6938711143122094, 0.7395138306152844, 0.1325295371291475, 0.7646527942161032, 0.7032455594227328, 0.726854953138558, 0.7481995364095015, 0.6833308568362261, 0.6569530536003716, 0.7153969335302031, 0.7072014483017681, 0.6894191708798038, 0.7016952054280813, 0.24313349889302605, 0.6005052278597307, 0.5878431645966076, 0.5838469331646686, 0.5433636844190026, 0.3796500380338266, 0.2515024032720057, 0.5793687595228587, 0.4113659258761406, 0.2201132610419858, 0.16018475396497467, 0.16255448058074362, 0.124217291718556, 0.062126323372427406, 0.08008862926691218, 0.4581792782019284, 0.517353560072247, 0.33310053614653456, 0.45665028981611133, 0.19928004874034022, 0.29396403573781205, 0.31710384657876534, 0.43743884886269524, 0.42222484940675287, 0.15592694451325684, 0.1847676883854037, 0.32995421550537274, 0.420128752733816, 0.5012672467888806, 0.4809663708484726, 0.5919818745807449, 0.5905700371685053, 0.6060863567793908, 0.616965376501083, 0.6359076815880136, 0.5049095801220043, 0.8499998443544349, 0.8418285173336586, 0.8640010657866928, 0.8377017770003713, 0.8627470643370007, 0.828702488681977, 0.8444009250589326, 0.850468949959075, 0.8701054513342874, 0.0817769274483473, 0.06790813579666044, 0.06961731546778305, 0.10979091252463369, 0.1566141465445604, 0.13068614174276516, 0.15890299999233048, 0.15746660017586178, 0.11729477048575065, 0.6862432112120465, 0.2782039139114888, 0.2352754109573426, 0.2723845850275858, 0.612525762617524, 0.2701763147451661, 0.6046079385794014, 0.6345242543384408, 0.7476895754817973, 0.7279175966363975, 0.5879655455784187, 0.6208542241326849, 0.4217045823307466, 0.5788295050202101, 0.6398850574502815, 0.25674706109951906, 0.5932925855641878, 0.28971877896928033, 0.6557208210380622, 0.30833363497598276, 0.2514513552269355, 0.4027425193097064, 0.3634384928405119, 0.5655851659193275, 0.31312548680289154, 0.346695584739084, 0.22461073579829594, 0.2429453359284034, 0.2564522414494782, 0.2809556434016526, 0.2350320393766938, 0.22174308561127754, 0.2721100174066081, 0.2433782137940692, 0.21493827783883113, 0.24807260417309163, 0.19714675531530157, 0.25023118004314215, 0.17510236771943177, 0.17586546977977346, 0.24935782930058425, 0.1967003036360928, 0.18244929581027924, 0.20652153284229902, 0.19331745799544264, 0.18720606713667642, 0.18794054110122305, 0.18831252043541857, 0.9218011851682448, 0.19957135354773292, 0.16877194495080772, 0.922338643433438, 0.9398266065042722, 0.17598840159322626, 0.9285354941797592, 0.8440532150456375, 0.9100134594137275, 0.9162812495732955, 0.9058371207675504, 0.8673860530031512, 0.9175057605517097, 0.8774890700457322, 0.8800480165167754, 0.2854956974804017, 0.19304291817438013, 0.19599830734095047, 0.22858828247347251, 0.2580625815902917, 0.37162182467641225, 0.23436157554310366, 0.19685618224992818, 0.18501094092222414, 0.09479010110592301, 0.10433653627219552, 0.1091840723895311, 0.08804880346815358, 0.09955961262156232, 0.09377254853918071, 0.10034644638641788, 0.0995439248855211, 0.10574646862816572]}, "mutation_prompt": null}
{"id": "b21018e2-0af5-4502-9128-522be2682cfc", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Adaptive swarm size\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave * 0.3)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.3 + 0.4 * chaos_val + np.random.uniform(-0.15, 0.15)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Enhance diversity by incorporating adaptive differential evolution mutation strategies and rebalancing inertia weight dynamics.", "configspace": "", "generation": 87, "fitness": 0.4597620374638304, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.30.", "error": "", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.887786759531603, 0.887339188388109, 0.8927819021503666, 0.8819336986647724, 0.8726462080800645, 0.8851357612685982, 0.8848944997265409, 0.8805283968191117, 0.8868022098062254, 0.7612427006888062, 0.7496605396547598, 0.734753843089746, 0.7152719414845286, 0.7556223475070899, 0.7684799140172559, 0.7250322021615041, 0.7421247646809543, 0.72478192455566, 0.12450693716877592, 0.11713717872910345, 0.08830126407773464, 0.1169199516244045, 0.11152676475479606, 0.12317133739132136, 0.09142359764560282, 0.12447901259823269, 0.12999446166578732, 0.10033108959478487, 0.09250504735256437, 0.09451027645666121, 0.0857377880458089, 0.11488648695940662, 0.09619515990014094, 0.09526843132643337, 0.08231157326035432, 0.09046589935267146, 0.9205725169437017, 0.928180784700415, 0.9219830287299241, 0.9213534614476406, 0.9395622771052325, 0.9192183782658975, 0.9270863926064796, 0.9085240156144453, 0.9190748044027481, 0.7779785967860483, 0.7917576756994668, 0.7694898966788339, 0.8035514225379665, 0.7822361052911306, 0.800741133789655, 0.7670636441166233, 0.7519162647624067, 0.7591397744143946, 0.8853933011127074, 0.22687834769183335, 0.1408399792285412, 0.2140807630372502, 0.28095334434977093, 0.28149649991676684, 0.23379609990977912, 0.1773606122180139, 0.23678934833154786, 0.7466410790965361, 0.1353216236963628, 0.7131022900722455, 0.6911008098293823, 0.7455691044530368, 0.6985598682419208, 0.7842719928255024, 0.7046945384662686, 0.6998055756355734, 0.715730918420178, 0.6580988572068389, 0.682381066046847, 0.72349225456723, 0.7984901201357054, 0.6845386934585035, 0.7936047349166897, 0.7989773281203244, 0.7353774963664648, 0.49751503025469224, 0.41000299693847675, 0.6804542343646514, 0.6414817882752304, 0.42864675246588324, 0.1429046165050204, 0.3212119059404074, 0.072945757343018, 0.5882867533805243, 0.16547254938408518, 0.07947840439926623, 0.4786045743256382, 0.17133371904372308, 0.12888145856346167, 0.15344941235140463, 0.36258982340276125, 0.5586598069517885, 0.5757833866146054, 0.31324239362086026, 0.26013119358055714, 0.48865967766215723, 0.4423782331422059, 0.4896046795758039, 0.36442533692014134, 0.17017277369354555, 0.3466000765601336, 0.2619142806860769, 0.47459914958097194, 0.6404386176704886, 0.5851593168138491, 0.6650484835172239, 0.6400691532653906, 0.6239702111497315, 0.6672722391157977, 0.5547121289641321, 0.6161235765488302, 0.836087933180165, 0.8448972049919212, 0.8447582250702532, 0.8259884517858234, 0.8273783269767153, 0.8348881999886727, 0.8102889801459576, 0.8408034221415515, 0.8572014157635811, 0.12105281718194705, 0.14183546021827986, 0.04900510840037842, 0.14321665593349897, 0.14276871550464965, 0.13181169989151253, 0.14456228472593502, 0.11020269667613247, 0.12124234396358968, 0.7557829023200842, 0.2673461754558484, 0.7434562383396055, 0.44262905711098033, 0.7571418299367267, 0.7924375654898915, 0.8047686381802424, 0.3289017992491611, 0.2316031665407179, 0.4540031234722497, 0.5376154501361532, 0.6098469962611852, 0.3837823426706938, 0.25481264219479893, 0.47481360657428684, 0.25917355032101985, 0.5977462784792165, 0.5646395920807833, 0.2692387671096752, 0.3750637892187939, 0.1734773959019663, 0.36063715000897434, 0.21156181009328734, 0.3693185974009954, 0.273578536829694, 0.5403590362312332, 0.2451748182683373, 0.2910347730836711, 0.28142858938879667, 0.2835813112003488, 0.26094886000934137, 0.2822472389840771, 0.2637726652444229, 0.2746561887805876, 0.22131492263887276, 0.26805304637141725, 0.21273592222556148, 0.180004419246808, 0.18599291110987282, 0.22678063066452858, 0.1962902572727836, 0.18969538771846195, 0.20683196868152542, 0.18837877149827686, 0.1781474067980614, 0.17674475484302565, 0.18811393369363638, 0.15334348385756458, 0.9312744465950796, 0.1998534894520393, 0.9145128986160588, 0.13655920406426336, 0.16880122282879328, 0.9243628573546002, 0.8705976758887702, 0.15585779646382747, 0.9027889022225047, 0.20957903447903392, 0.1682486132579174, 0.891444967729017, 0.10464281749282711, 0.8986125621729106, 0.8485124258613584, 0.5588017599310826, 0.22489172513958977, 0.21998965208378074, 0.22087030278580289, 0.2136034637614509, 0.2669400964828106, 0.20784463579355084, 0.19633249586300205, 0.4750167528010315, 0.09079346278047284, 0.08835441496665686, 0.09183740790427841, 0.10115219248527774, 0.1079720107216563, 0.10501873451421273, 0.10011222665854524, 0.09472260725632242, 0.12620662005238392]}, "mutation_prompt": null}
{"id": "925c8be6-0ae9-47ff-bd50-2d6275d34e33", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Adaptive swarm size\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce adaptive swarm size for enhanced exploration and exploitation balance in high-dimensional spaces.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.8980982671425689, 0.8903620049616174, 0.8988530611711405, 0.8932545471037056, 0.8879154653212531, 0.8890776578998386, 0.9042764617925443, 0.8948881339175825, 0.8926399277431314, 0.7908067798577216, 0.7963171525200662, 0.7691463443415147, 0.7861521281885755, 0.7384137833213005, 0.7650494658557858, 0.7466613163384963, 0.8042553946121596, 0.7401977461471319, 0.09686491762940641, 0.145015521164934, 0.13954667723027014, 0.08883147126247481, 0.12158071203809828, 0.14246759369462292, 0.08543604575781005, 0.11651216537128928, 0.1162232479695906, 0.10534666367404988, 0.1086401808715809, 0.12403561892945958, 0.1227838869170047, 0.08498647002862958, 0.12356918866601574, 0.11000272194217109, 0.09543067418859152, 0.10413182813264699, 0.8958457553630623, 0.9246980758595659, 0.9323430571211943, 0.927032995465498, 0.9357906118174969, 0.9219894036722209, 0.9257246401286136, 0.9238429026721982, 0.9158375560873677, 0.8099376705121574, 0.7859071482188211, 0.7918956257504677, 0.7988631115655729, 0.7660517694318512, 0.7997006651978558, 0.8038183917965578, 0.7797472939535286, 0.8205850281208377, 0.38807573057643796, 0.17149815958416603, 0.9105896054967318, 0.27820565968291533, 0.27906288564467063, 0.2135173465459378, 0.17567178859102317, 0.23475900167451713, 0.23639384099425564, 0.6891818550484219, 0.7413015948242958, 0.7375993174483211, 0.6921773842727268, 0.7851112254472163, 0.8121672872946074, 0.7335859109949809, 0.691808571318207, 0.7438793313686154, 0.705381006632888, 0.6886452689873384, 0.6742593630228897, 0.7691078317494832, 0.7354137983733264, 0.716902588099091, 0.7246718764776938, 0.8182057555730377, 0.6973296071471353, 0.524893278044298, 0.4296464440984693, 0.5493206255078452, 0.6230360912480866, 0.6847390247958334, 0.5104569876012623, 0.35558761012610474, 0.05774367894119936, 0.6149010330788307, 0.4836028770289629, 0.1388648764035899, 0.25062484185558664, 0.09340076878800885, 0.1494128162296724, 0.18668711084426837, 0.6545725008506056, 0.4982670797334592, 0.5937474246296442, 0.653771929586086, 0.5439759084240299, 0.45045689671437106, 0.4063654786256097, 0.38795635816597174, 0.32685456056179707, 0.1725896044098516, 0.25776338338783733, 0.2080706296499335, 0.5485038800943953, 0.5709549654799707, 0.6339652926559953, 0.6283242778850056, 0.6302775999301897, 0.5094604233391413, 0.6604543331652382, 0.6183887924627371, 0.6634161129421416, 0.8591162780685626, 0.8505580464302733, 0.8394734888313469, 0.8622647211860525, 0.8390210774642543, 0.8752653826045191, 0.8507340190038861, 0.8617439993919205, 0.8616848052623161, 0.11452668487522444, 0.08228366196261327, 0.09726637485734013, 0.18664310345540502, 0.10972184044380551, 0.12373335059792623, 0.13179927379653944, 0.16048668281489276, 0.09687209892983262, 0.7873333939552076, 0.7843569123740535, 0.5856973986138074, 0.815023028448911, 0.2761734433558286, 0.28614424771092883, 0.4092221860622195, 0.30768046306464614, 0.6135558264340026, 0.2130167059980066, 0.40232050913594075, 0.40551795513375866, 0.6511583344603477, 0.6369067104320095, 0.6129057971117586, 0.268607726949018, 0.5469124533101808, 0.2703053765794261, 0.19427000405457895, 0.6913011763681616, 0.3472487640823215, 0.4338078050637949, 0.18869346325186942, 0.334133580159647, 0.23807541446036917, 0.27394981901033266, 0.2804557103015498, 0.23814228457314124, 0.28805358365635503, 0.20806208085382683, 0.28191557864204553, 0.2875265961561123, 0.23246959346219032, 0.21567681290459673, 0.21630425114797203, 0.27832859324631964, 0.1990356445113528, 0.19024722065370958, 0.18835444382472055, 0.1996563884567848, 0.17782043899333622, 0.19293191137465648, 0.20830239769180137, 0.19119739874781738, 0.19971124404113327, 0.18733477652643205, 0.18751372198126215, 0.18802518346360553, 0.9358614324669595, 0.9151489283521499, 0.9221329925234291, 0.12219346890577631, 0.16849441433361156, 0.9258514390751847, 0.8943999291853538, 0.15605264424403797, 0.8732948373149961, 0.9011077453515852, 0.20976578610640595, 0.8817999887606904, 0.8894531210946778, 0.9097457428995559, 0.8655539921416153, 0.2182757247435193, 0.3931197577417541, 0.20661701820504463, 0.2094791961050969, 0.19407375695983076, 0.22219575385724, 0.1917059374736374, 0.49110901131392015, 0.18237599994301013, 0.08269495088094825, 0.11202492921654816, 0.09128963233290566, 0.0955950188635255, 0.09517469951281565, 0.10703495486968928, 0.08873425526346068, 0.09697454066689548, 0.15709873817077824]}, "mutation_prompt": null}
{"id": "cb4d7e04-19c4-4802-8c25-137f3cf110c0", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Adaptive swarm size\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        vel_clamp_range = 0.3  # Adaptive velocity clamping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max * vel_clamp_range, self.vel_max * vel_clamp_range)  # Adaptive clamping\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val * np.random.uniform(0.8, 1.2)  # Adaptive scaling\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce adaptive mutation scaling and velocity clamping based on iteration progress for improved convergence.", "configspace": "", "generation": 89, "fitness": 0.4049248092947664, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.", "error": "", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.8822606825138792, 0.8673678699664145, 0.8799216816467352, 0.8634375051574164, 0.8393433418249783, 0.8640991747513604, 0.8547080562281015, 0.8567994095768711, 0.852281380344859, 0.7088468399825495, 0.6940023006966446, 0.7130319240950049, 0.6983953864512644, 0.6271907983680184, 0.7202392422806649, 0.6435447227297442, 0.612874404105501, 0.6492098408569953, 0.08925998979254035, 0.09438028606572857, 0.10226719037047294, 0.11530764414335148, 0.1530874920135744, 0.11465270270820926, 0.11299968486075673, 0.10729363445480833, 0.0940922980916088, 0.1015569136726866, 0.08874896812734145, 0.08963170675106835, 0.08154969165718484, 0.08551571154667126, 0.08365547055809597, 0.10061459351730995, 0.07037559057276144, 0.08536100228416477, 0.8333979436693921, 0.7883879540051952, 0.7203459600983473, 0.7392454525974983, 0.7932764898544288, 0.7685980271035034, 0.764474947186374, 0.7752374918751351, 0.7461599777847441, 0.7786662934361004, 0.7383945458418042, 0.7375921080539385, 0.7737703047495463, 0.7290172281455432, 0.7600822913525014, 0.7550609816432973, 0.7116030063323162, 0.7479401656043179, 0.8910065507700924, 0.16894188127015985, 0.22311107255954554, 0.2736995281074881, 0.26864495426939783, 0.34615903324836395, 0.1525301853990535, 0.1747839985658204, 0.22917890425688736, 0.7034687712314174, 0.6364940063590447, 0.6759808896936688, 0.6650451427465978, 0.662526042064656, 0.46111829714137986, 0.6794104088697579, 0.12944687457071558, 0.6558295835929724, 0.7260220652401201, 0.6450249401562779, 0.7711914613556364, 0.6899959344398887, 0.644695737604951, 0.6288557625062686, 0.6634939909558901, 0.6397479851496781, 0.6900754199186232, 0.024717029494114806, 0.130681162995418, 0.09039080673652256, 0.050985332653483595, 0.18429983649383208, 0.07043374598284624, 0.4766689944790693, 0.2392897471646508, 0.20535089107531934, 0.16711080847834126, 0.12524204120789584, 0.18927951278070554, 0.12468832339703317, 0.10052620133606127, 0.07010057923023993, 0.18830884159382122, 0.13261837026120737, 0.2241099081345257, 0.37847318636391303, 0.4887351450137438, 0.14852758337139316, 0.13157318689361397, 0.20925977706683652, 0.1883423008948717, 0.15131092381835276, 0.1656078514770859, 0.11979359211923979, 0.3918093346997472, 0.3987705271657366, 0.49121692506817327, 0.58522849228124, 0.6180200723968938, 0.4939287939118646, 0.5165473998635292, 0.4279530062736864, 0.2538610764518966, 0.8146949737276403, 0.8112939919132832, 0.8116548722101511, 0.7875441728244349, 0.7925228437683256, 0.7770224164263807, 0.8283863034310806, 0.8254924977081596, 0.8382137888420378, 0.0650872464839245, 0.08113552871939134, 0.0528275897794348, 0.15342508585955605, 0.13892250180136712, 0.07085962959234604, 0.10621505305767365, 0.1383715353407663, 0.0988573732371979, 0.2832512173156465, 0.32947795073087094, 0.7536952342843706, 0.21901111181431487, 0.3131755075895343, 0.19846087641394583, 0.7432050499668985, 0.19104956707595533, 0.27202830626602015, 0.18937200773117746, 0.6669284951878018, 0.29863684573698024, 0.2943499667232261, 0.2857203628442394, 0.629007945136755, 0.27554838684146943, 0.3488906694743903, 0.2527295443218862, 0.13168810698355005, 0.2652199482545712, 0.22526195374489488, 0.4537956409446592, 0.35576006144245953, 0.31585752815144574, 0.20879246820969966, 0.2859880951738403, 0.19636742122066664, 0.33206951575809684, 0.21978939888210658, 0.24759168684962418, 0.23964409103260587, 0.2334654298053187, 0.2708179255274592, 0.25445250521251606, 0.26412638118854526, 0.23670372324860933, 0.2013068982548064, 0.1722414838050148, 0.18295879388903236, 0.197085174469388, 0.17992901295833674, 0.1966056397856828, 0.1885956907100822, 0.16944021275613486, 0.1740780071330681, 0.8527585565982847, 0.18357440554252602, 0.18536231011344984, 0.8910765380340545, 0.1958304589921792, 0.19651360235761417, 0.1343845489402029, 0.8522795975139397, 0.16599741411823565, 0.8594015998270469, 0.8060212409836351, 0.8447558200564393, 0.8810240568134794, 0.7919016745203569, 0.8926838801116344, 0.7883443443900422, 0.833223236319912, 0.7702897149320245, 0.2161140893393585, 0.20713513876723022, 0.21452392915016782, 0.1803799042432782, 0.20851417990105736, 0.18141296483938296, 0.341525419359167, 0.2390989143045268, 0.22992190373927823, 0.10397002788837761, 0.10001403285171451, 0.09047797957017434, 0.10310541383958205, 0.09664223875218303, 0.08562576375024888, 0.10196398434240928, 0.10312351687536936, 0.08869012764954054]}, "mutation_prompt": null}
{"id": "0e88ce53-aff5-4bc1-b1aa-4e53db38288c", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Adaptive swarm size\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce adaptive swarm size for enhanced exploration and exploitation balance in high-dimensional spaces.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.8980982671425689, 0.8903620049616174, 0.8988530611711405, 0.8932545471037056, 0.8879154653212531, 0.8890776578998386, 0.9042764617925443, 0.8948881339175825, 0.8926399277431314, 0.7908067798577216, 0.7963171525200662, 0.7691463443415147, 0.7861521281885755, 0.7384137833213005, 0.7650494658557858, 0.7466613163384963, 0.8042553946121596, 0.7401977461471319, 0.09686491762940641, 0.145015521164934, 0.13954667723027014, 0.08883147126247481, 0.12158071203809828, 0.14246759369462292, 0.08543604575781005, 0.11651216537128928, 0.1162232479695906, 0.10534666367404988, 0.1086401808715809, 0.12403561892945958, 0.1227838869170047, 0.08498647002862958, 0.12356918866601574, 0.11000272194217109, 0.09543067418859152, 0.10413182813264699, 0.8958457553630623, 0.9246980758595659, 0.9323430571211943, 0.927032995465498, 0.9357906118174969, 0.9219894036722209, 0.9257246401286136, 0.9238429026721982, 0.9158375560873677, 0.8099376705121574, 0.7859071482188211, 0.7918956257504677, 0.7988631115655729, 0.7660517694318512, 0.7997006651978558, 0.8038183917965578, 0.7797472939535286, 0.8205850281208377, 0.38807573057643796, 0.17149815958416603, 0.9105896054967318, 0.27820565968291533, 0.27906288564467063, 0.2135173465459378, 0.17567178859102317, 0.23475900167451713, 0.23639384099425564, 0.6891818550484219, 0.7413015948242958, 0.7375993174483211, 0.6921773842727268, 0.7851112254472163, 0.8121672872946074, 0.7335859109949809, 0.691808571318207, 0.7438793313686154, 0.705381006632888, 0.6886452689873384, 0.6742593630228897, 0.7691078317494832, 0.7354137983733264, 0.716902588099091, 0.7246718764776938, 0.8182057555730377, 0.6973296071471353, 0.524893278044298, 0.4296464440984693, 0.5493206255078452, 0.6230360912480866, 0.6847390247958334, 0.5104569876012623, 0.35558761012610474, 0.05774367894119936, 0.6149010330788307, 0.4836028770289629, 0.1388648764035899, 0.25062484185558664, 0.09340076878800885, 0.1494128162296724, 0.18668711084426837, 0.6545725008506056, 0.4982670797334592, 0.5937474246296442, 0.653771929586086, 0.5439759084240299, 0.45045689671437106, 0.4063654786256097, 0.38795635816597174, 0.32685456056179707, 0.1725896044098516, 0.25776338338783733, 0.2080706296499335, 0.5485038800943953, 0.5709549654799707, 0.6339652926559953, 0.6283242778850056, 0.6302775999301897, 0.5094604233391413, 0.6604543331652382, 0.6183887924627371, 0.6634161129421416, 0.8591162780685626, 0.8505580464302733, 0.8394734888313469, 0.8622647211860525, 0.8390210774642543, 0.8752653826045191, 0.8507340190038861, 0.8617439993919205, 0.8616848052623161, 0.11452668487522444, 0.08228366196261327, 0.09726637485734013, 0.18664310345540502, 0.10972184044380551, 0.12373335059792623, 0.13179927379653944, 0.16048668281489276, 0.09687209892983262, 0.7873333939552076, 0.7843569123740535, 0.5856973986138074, 0.815023028448911, 0.2761734433558286, 0.28614424771092883, 0.4092221860622195, 0.30768046306464614, 0.6135558264340026, 0.2130167059980066, 0.40232050913594075, 0.40551795513375866, 0.6511583344603477, 0.6369067104320095, 0.6129057971117586, 0.268607726949018, 0.5469124533101808, 0.2703053765794261, 0.19427000405457895, 0.6913011763681616, 0.3472487640823215, 0.4338078050637949, 0.18869346325186942, 0.334133580159647, 0.23807541446036917, 0.27394981901033266, 0.2804557103015498, 0.23814228457314124, 0.28805358365635503, 0.20806208085382683, 0.28191557864204553, 0.2875265961561123, 0.23246959346219032, 0.21567681290459673, 0.21630425114797203, 0.27832859324631964, 0.1990356445113528, 0.19024722065370958, 0.18835444382472055, 0.1996563884567848, 0.17782043899333622, 0.19293191137465648, 0.20830239769180137, 0.19119739874781738, 0.19971124404113327, 0.18733477652643205, 0.18751372198126215, 0.18802518346360553, 0.9358614324669595, 0.9151489283521499, 0.9221329925234291, 0.12219346890577631, 0.16849441433361156, 0.9258514390751847, 0.8943999291853538, 0.15605264424403797, 0.8732948373149961, 0.9011077453515852, 0.20976578610640595, 0.8817999887606904, 0.8894531210946778, 0.9097457428995559, 0.8655539921416153, 0.2182757247435193, 0.3931197577417541, 0.20661701820504463, 0.2094791961050969, 0.19407375695983076, 0.22219575385724, 0.1917059374736374, 0.49110901131392015, 0.18237599994301013, 0.08269495088094825, 0.11202492921654816, 0.09128963233290566, 0.0955950188635255, 0.09517469951281565, 0.10703495486968928, 0.08873425526346068, 0.09697454066689548, 0.15709873817077824]}, "mutation_prompt": null}
{"id": "11f42651-803e-46e4-bc04-9ea61c92a4d4", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        initial_population_size = min(40, 5 * self.dim)\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7\n        while eval_count < self.budget:\n            chaos_val = 4 * chaos_val * (1 - chaos_val)\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)\n                pos[i] = pos[i] + vel[i]\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                dynamic_CR = self.CR * (0.5 + 0.5 * chaos_val)  # Line 1 change\n                trial = np.where(np.random.rand(self.dim) < dynamic_CR, mutant, pos[i])  # Line 2 change\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Improved the exploration-exploitation balance using a dynamically adjusted crossover rate and enhanced DE mutation diversity.", "configspace": "", "generation": 91, "fitness": 0.42557081135899044, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.31.", "error": "", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.9139632660139515, 0.893487542145042, 0.9032437679006482, 0.8942026179138668, 0.8922955981886284, 0.902715745653811, 0.9024342265668991, 0.904042909746392, 0.904237842892976, 0.8225603353681147, 0.7713182464485724, 0.8161161297271482, 0.804223744591476, 0.7997527979596343, 0.7838065735579819, 0.7828413021948166, 0.7750192074915567, 0.8147382521381616, 0.11111277800113895, 0.1442348755527042, 0.11714713647251296, 0.10130503020591386, 0.805320477181932, 0.1253757353934487, 0.08276169470693606, 0.10525968363332372, 0.12331621958062822, 0.14405503504370865, 0.08285399264287097, 0.12319387183018371, 0.13336518513354734, 0.08862873294688467, 0.11684743864144298, 0.10914803978650667, 0.06996098789299454, 0.08206668069457501, 0.9327609336023333, 0.9332659567060876, 0.9245811152399224, 0.9257301637698333, 0.9249145076793956, 0.9212368890911332, 0.9401621706195467, 0.9264211778469977, 0.9228102449552751, 0.8182530891109019, 0.8183933780206101, 0.7951454432259606, 0.8276012236052396, 0.783579645809366, 0.7845514497451618, 0.7970799424560744, 0.7869722745342305, 0.7913770126399493, 0.9107426875650092, 0.16858289397816495, 0.22831460222101663, 0.38690999658327496, 0.3835745564111559, 0.21202948190168414, 0.2347019367622597, 0.17803034041428856, 0.893827546375317, 0.6897053244215519, 0.7078051042763065, 0.6826346398487861, 0.1358646036950768, 0.7131674983066758, 0.6167058569412389, 0.6720687918592909, 0.6311587457525172, 0.6904054216918689, 0.7097550203117324, 0.593447424268899, 0.6817765991533904, 0.7030729383996315, 0.12725224804266932, 0.6897079342698367, 0.6148556178777944, 0.6884559888981407, 0.6766072948429975, 0.1470252945294116, 0.061699678513563616, 0.23585874226493486, 0.19386664907375029, 0.2736182642224855, 0.15112606525018468, 0.19337183746655295, 0.07360007860108086, 0.29429086176376573, 0.23516172557826953, 0.11548833131231329, 0.1417226995640709, 0.1784074980445175, 0.11487093526179648, 0.05706951546399519, 0.3801867442915835, 0.2259300692193812, 0.2357075747814078, 0.18185370415427737, 0.10825563664620019, 0.2209128735812229, 0.08031009895810837, 0.13542876643399016, 0.15092493697265053, 0.11909656082200548, 0.18065943006834273, 0.1408583055696614, 0.31495271488278875, 0.3391058622994979, 0.3536458474781472, 0.410323719935208, 0.4541718415544779, 0.3280486331730802, 0.30816983135833187, 0.23060742458108663, 0.3453648850496286, 0.7803655453626414, 0.8255266024263912, 0.7654269697624657, 0.841675885527302, 0.6940412144728199, 0.7671201125722144, 0.7873077750614248, 0.8190975563616375, 0.756310798072032, 0.10508096449891746, 0.10904013932234025, 0.11409285613909703, 0.10127549740026531, 0.1033473520562358, 0.14229030364672124, 0.11743697791686392, 0.09341808652797368, 0.13141401947109443, 0.2895168540198423, 0.40809076844208725, 0.20758851133394707, 0.26023213555192315, 0.20050603825105384, 0.7748482087132038, 0.4677344357600266, 0.7830642769196179, 0.7436727237240566, 0.40692700793976133, 0.47460551803456175, 0.3700053053600153, 0.5953799374481332, 0.4559163314358866, 0.5012776730698995, 0.30921308908503264, 0.7531266937883707, 0.26944987276684673, 0.33116366943041997, 0.3052727774128694, 0.3493131696802273, 0.2952642170421165, 0.27338373439945385, 0.32409014975071937, 0.2510060873926768, 0.24258648552974194, 0.25508635540674174, 0.24529446267233757, 0.2522451866054596, 0.2280853304800483, 0.22744438296637703, 0.23928372613868465, 0.23617481609750035, 0.19920646208698456, 0.2507784732750553, 0.23765329959841686, 0.19435254335180807, 0.17122088572939376, 0.21584879396461965, 0.18918898832855324, 0.19264571025953037, 0.19885323027161816, 0.21227253745426633, 0.17450682228062264, 0.18259049229699587, 0.9224492982414246, 0.927246718636746, 0.14762489367886633, 0.9056958498113856, 0.20025709101438682, 0.9382530970499078, 0.13643156549431223, 0.929531071408217, 0.9332000757708185, 0.8837772449114817, 0.15682557972544342, 0.8887085930586326, 0.21127583096955938, 0.16797165442372897, 0.20978497978940136, 0.10462238308287974, 0.9119747470041137, 0.8810809178617564, 0.2657538143822158, 0.1829801583580989, 0.19672847871881116, 0.19874063427993827, 0.1919943273395064, 0.21880943468733183, 0.18778793653685721, 0.25228276898130353, 0.22833176201772887, 0.11039042994961623, 0.08344789510348494, 0.10490745844355787, 0.08902546115442578, 0.10386616726578723, 0.09453624812997974, 0.09566605491479219, 0.10427054073782871, 0.1221822081703654]}, "mutation_prompt": null}
{"id": "3005880a-3cbb-43bf-8ba4-d1935c756944", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Adaptive swarm size\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Improved DE crossover diversity\n                CR_adaptive = 0.8 + 0.2 * np.random.rand() * dynamic_factor\n                trial = np.where(np.random.rand(self.dim) < CR_adaptive, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce dynamic learning rate adaptation and improved DE crossover diversity for enhanced convergence.", "configspace": "", "generation": 92, "fitness": 0.4521334014144483, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.30.", "error": "", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.8946999174297628, 0.8958151874473738, 0.9001997500551026, 0.8965915516889085, 0.8890374934229425, 0.8952101604103897, 0.8982532156270768, 0.8995993493735135, 0.8905682622641646, 0.7887620192212494, 0.7719890257154585, 0.7612421118935138, 0.7847246096421465, 0.7575014581443877, 0.7520617459560597, 0.7246356038193353, 0.765868267355971, 0.7109832350456105, 0.09508165986645267, 0.13296367588430935, 0.13162352259768473, 0.1224314783340118, 0.10140082086960156, 0.1624928763531145, 0.11586015864273125, 0.12440435783400428, 0.15995808442604342, 0.08278552681766593, 0.07376882805087026, 0.07253737948138772, 0.11634085532720095, 0.11722358585963522, 0.09246085191574605, 0.10941869605908483, 0.1041102050759053, 0.10361025347464603, 0.9347529453143799, 0.945715227156927, 0.9103292851111467, 0.9023083461662469, 0.9158913175747725, 0.9373080168226546, 0.901841325697574, 0.9048521079901135, 0.8997460931265515, 0.81015999244749, 0.793678061501868, 0.8084298876900349, 0.808391207313697, 0.7790573549487575, 0.7810638548326673, 0.8033329292577084, 0.7740980209533186, 0.7974246862955036, 0.900770654878266, 0.22792962524581495, 0.22952348357659402, 0.2208356970846388, 0.28225304826072395, 0.2200982529789911, 0.23430489806201793, 0.23443864160331884, 0.9267651658624213, 0.7479313645488233, 0.1337060708440314, 0.7423854108736775, 0.7088015455893124, 0.7478621935079952, 0.7841656448040988, 0.6678784288824027, 0.1337487929528437, 0.7325856842934995, 0.7843738872672846, 0.6543448725262329, 0.7332295312912073, 0.7455613211080572, 0.7132934922725602, 0.728777016881416, 0.773475638927018, 0.7706132198970653, 0.6970589443231694, 0.3278892366452335, 0.5747276407432529, 0.7204740241845096, 0.558515116403828, 0.6662318517788346, 0.415796330120052, 0.3487363248133192, 0.31199278991659396, 0.36869001219539055, 0.11350399496659358, 0.17007628728942326, 0.354068643473218, 0.13698815824125266, 0.13299582886140648, 0.17122552692771242, 0.22394959897251387, 0.18275543641423264, 0.1627007251730903, 0.19307959087040683, 0.2918953212982236, 0.3218779421525164, 0.5479940990552531, 0.19845684042060951, 0.33445451634271706, 0.1946027668762793, 0.4104678202359796, 0.18343511703401383, 0.41924432974881476, 0.40289363425530955, 0.5231187829441388, 0.5170915734871329, 0.49602972692695746, 0.5984920857911342, 0.5109299903760546, 0.5527055805881573, 0.3149587566535109, 0.8479200980766283, 0.8398258591680168, 0.8396446300015115, 0.8558321041147866, 0.8488685576371227, 0.8652727085384595, 0.8472833904298505, 0.8599165052433433, 0.873993217145615, 0.11587943026532233, 0.10530955457436919, 0.053547875283994295, 0.1325714699697932, 0.15826050323645358, 0.18435214921124488, 0.18569918718325096, 0.12466251462873024, 0.10062259566110443, 0.350713077278218, 0.6079664146204251, 0.6168676092993164, 0.4369188194066348, 0.355445406508353, 0.7189656842610521, 0.46046596627253455, 0.597194748682123, 0.6259280867966317, 0.5527009806496813, 0.7700258276065333, 0.6159363651264653, 0.6434076863439293, 0.6474964849822402, 0.5990866167406035, 0.2782592899634919, 0.6377683340937088, 0.2576865107236781, 0.27599715966507954, 0.45137968617587176, 0.2956356485272337, 0.3592696233807232, 0.5173261111947008, 0.43045833831512625, 0.2425822847921898, 0.2843234319680168, 0.25701675466302654, 0.3294745898882513, 0.25065813122112646, 0.25428817411170634, 0.24774198661184277, 0.29431137330265644, 0.2560187817225136, 0.20695443558361004, 0.2504619746709945, 0.23561384494135307, 0.1926146728120839, 0.18284161577167246, 0.2235831253937467, 0.18784794294141072, 0.19078026903947298, 0.18124623800307604, 0.19773555620386452, 0.1842690109380699, 0.21999950404816337, 0.1871341912838459, 0.17774667059085436, 0.15396699539803027, 0.9351496665213989, 0.19995404727830102, 0.9295996590295913, 0.15379541662146767, 0.1765548064704321, 0.1764758248223487, 0.935826179587181, 0.15689007724450543, 0.9008588345219689, 0.21119030631889668, 0.16809124633900063, 0.8921753755071211, 0.9039112776042516, 0.16716076121390855, 0.8149742320717389, 0.212724704828138, 0.19497183046152722, 0.18217935002139418, 0.19131930530148988, 0.19286914083812268, 0.18634073641137494, 0.1931361246317479, 0.44379115687192894, 0.21756448675533713, 0.09782931447667564, 0.08713318482345078, 0.07936702325437672, 0.0964494194784391, 0.09399514166307166, 0.10053280542896859, 0.09838705436155837, 0.10375860009670401, 0.09992825967325647]}, "mutation_prompt": null}
{"id": "413343fe-6fb3-4d9b-ad81-aaabd4d534f4", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                F_adaptive = 0.3 + 0.5 * chaos_val + np.random.uniform(-0.1, 0.1)  # Modified mutation scale\n                self.CR = 0.8 + 0.2 * (1 - chaos_val)  # Dynamic crossover probability\n\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce a dynamic crossover probability and adaptive mutation scale for enhanced exploration and convergence.", "configspace": "", "generation": 93, "fitness": 0.47254656884842056, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.30.", "error": "", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.8986900949163448, 0.8923710022695723, 0.8916354525324808, 0.8887637824702606, 0.8795308452210616, 0.8999871681357204, 0.8944077077192474, 0.8802749788070149, 0.8893459705475726, 0.7620348793964127, 0.7586283110726972, 0.764514040864312, 0.7572176646796172, 0.7512268365145611, 0.7669931241373407, 0.7599546635390508, 0.7788530133833137, 0.7493829159739975, 0.09212349183112334, 0.16014312884616788, 0.15977365846573843, 0.09774504418841734, 0.10086771372641579, 0.11782300880569052, 0.08071611199293549, 0.1447808530171817, 0.1603105917866383, 0.14561103291996624, 0.0796222114318107, 0.10434588864295324, 0.11063358951330049, 0.13925317450996022, 0.09618160962859568, 0.09666183334597278, 0.1172511313868475, 0.12179752372463004, 0.9119182164985629, 0.9130324452066512, 0.9182248835214667, 0.9131871438887585, 0.9326700694623518, 0.9221759001714254, 0.9171748444575072, 0.9320847660872404, 0.9105663273886849, 0.7994347701454401, 0.8156933516975239, 0.8003715198162962, 0.8089580817658292, 0.7920162479015217, 0.808453904061871, 0.7979184799633653, 0.7736305756154958, 0.809261268910796, 0.39872850906261403, 0.17135886020706315, 0.22760253543460496, 0.9148737407697829, 0.8850489789010061, 0.27621840539369624, 0.17601219410219726, 0.17785598202010766, 0.9218072407975177, 0.13272114607850527, 0.6925391142111053, 0.1338789414656918, 0.7340626318490574, 0.6586856807610336, 0.7489229881152466, 0.7397713246551065, 0.7560025045045079, 0.7307821142745698, 0.7308551431808294, 0.6921291061297559, 0.7629983575843868, 0.7475221944328447, 0.7194538782410321, 0.6861014445905325, 0.7292213638381964, 0.7217472516739563, 0.7173930679291913, 0.49319414616167745, 0.6166303461441974, 0.6557695753061017, 0.35229023140120896, 0.16754175196863763, 0.41543609037079166, 0.5909538722469059, 0.5467428370281548, 0.5567677528059816, 0.41835258385171714, 0.15932325999506192, 0.2997841443123288, 0.11237949403494696, 0.08310530169639041, 0.0667062029750759, 0.2570324604298787, 0.5053735256666754, 0.34513235914661655, 0.33127103104526845, 0.304602560707383, 0.582630642819194, 0.4084978658946474, 0.5325985544444067, 0.6565958179206759, 0.32856605452965915, 0.24816876032386104, 0.1821117452260349, 0.6675379486858264, 0.43215391875812825, 0.45861258339123046, 0.6383845012854907, 0.6489783179231885, 0.6047968809197879, 0.47854130630006, 0.575518353095736, 0.5577953528422419, 0.8573678169616277, 0.867890829678752, 0.8644272292258245, 0.8127784339781036, 0.8295035448160432, 0.8742159267283917, 0.8651127132118862, 0.8630528177549222, 0.8462710916598369, 0.11005635529726154, 0.09234202321801754, 0.06355280788776452, 0.1588004653502263, 0.12417152130772724, 0.0799636394828791, 0.16180502679738562, 0.1433229656344378, 0.09343344438451717, 0.21611950670149604, 0.6656475981989927, 0.267599702256312, 0.8298423836985545, 0.7988459309848829, 0.7709114485050744, 0.8128120053693993, 0.7953508965505067, 0.3547262714649726, 0.5679587181608954, 0.4931869659422622, 0.3904854148630382, 0.5694936377522501, 0.5131085890839332, 0.7802252138275325, 0.25046116158765286, 0.4669620256138949, 0.3028707306100069, 0.20682905965459852, 0.33629684095115797, 0.31395157712792054, 0.5007400958426442, 0.32768083839179696, 0.45473116766302046, 0.25128439340705566, 0.3031352188990637, 0.20261772176307868, 0.22601442969731123, 0.26045937555848986, 0.26901468855731236, 0.27359732277091, 0.37691400530973174, 0.25551052074599234, 0.298933745590206, 0.2984287148684497, 0.20657201217770715, 0.21640772106010953, 0.19060856754671918, 0.18230679971479447, 0.19315271612682583, 0.2076516144918663, 0.18918746945981513, 0.19759383229063865, 0.17618064896057417, 0.18929282604039543, 0.18773805743765937, 0.18768087879604167, 0.15303367722272998, 0.935870414421149, 0.19948211297331586, 0.15804077712794695, 0.13629744935444865, 0.16780230355858128, 0.9344424224266479, 0.9255231262705096, 0.9034931278644112, 0.9119800006441082, 0.9161135562049842, 0.1686835337149245, 0.8890202769460391, 0.10440305093222801, 0.8819468670821655, 0.8681355736667931, 0.21191602152432454, 0.18597809013926214, 0.20008510543715918, 0.23369634367708036, 0.20049844646010628, 0.26583934117277264, 0.3338937895221189, 0.2855056926302256, 0.24675136780608575, 0.1004553920408986, 0.1072929902895472, 0.09840138681550448, 0.11186872385180247, 0.09127517961618159, 0.12966745673195745, 0.07662139542758273, 0.08942536910650978, 0.08102911478455577]}, "mutation_prompt": null}
{"id": "8721a6c3-540d-4a05-8361-8b0d695a90e9", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7\n        while eval_count < self.budget:\n            chaos_val = 4 * chaos_val * (1 - chaos_val)\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)\n                pos[i] = pos[i] + vel[i]\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n                mutation_probability = (1 - chaos_val) * dynamic_factor  # Adaptive learning probability\n                if np.random.rand() < mutation_probability:  # Apply mutation based on learning probability\n                    indices = [idx for idx in range(initial_population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                    mutant = np.clip(mutant, self.lb, self.ub)\n                else:\n                    mutant = pos[i]  # No mutation\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                tournament_indices = np.random.choice(initial_population_size, 3, replace=False)\n                tournament_best = np.argmin([pbest_val[idx] for idx in tournament_indices])\n                gbest = pbest[tournament_indices[tournament_best]]  # Use tournament selection for gbest\n\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Integrate an adaptive learning probability and use tournament selection for enhanced convergence.", "configspace": "", "generation": 94, "fitness": 0.42239931247133466, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.30.", "error": "", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.9086577311433416, 0.9089630832603764, 0.9062614827305776, 0.8875251792968988, 0.8907536153844107, 0.8925977519760813, 0.9035851355006183, 0.8898055560196002, 0.8966207536586238, 0.7618087253375635, 0.778377163067933, 0.6862480748806374, 0.7557073220959614, 0.7648016924888805, 0.7783316636014033, 0.7141581175159668, 0.6963498535392494, 0.6716626570354443, 0.11053360082753427, 0.14123605128587546, 0.08832358765628756, 0.10914910308753456, 0.0887655297476524, 0.11653701356536472, 0.13623255292800274, 0.10606055216413857, 0.12213813423885256, 0.09184819544664047, 0.114420718028866, 0.07791120659727624, 0.11501724826155335, 0.10959673371428913, 0.09132798778597628, 0.09034294674459087, 0.10645044123366243, 0.07726351334420556, 0.8994054353020409, 0.8976692554856657, 0.87607035444724, 0.8772613530330826, 0.9047286108672027, 0.8966581657216501, 0.9021575165115056, 0.8880375895819803, 0.8917557035190034, 0.7761204674797848, 0.7911632716827187, 0.7906968655761752, 0.6894408649679094, 0.7655810962995179, 0.7515667461403919, 0.7660948096336888, 0.7350458735418102, 0.7312555604671027, 0.7209871822649097, 0.1708255058333189, 0.17055526334762583, 0.9184417806286043, 0.27827488404285494, 0.2730837950325382, 0.2921098543903594, 0.17576323365571078, 0.23481576862924503, 0.1334533767084427, 0.553252653720939, 0.6254808903817245, 0.5612314095157096, 0.7191587387382086, 0.7396211300010139, 0.7087702686736564, 0.6665777060965352, 0.6820048943317554, 0.7403157614868117, 0.6480055471464861, 0.13530581346187098, 0.5057466421681737, 0.599289051984909, 0.6508187109063505, 0.644056882746576, 0.6675159454046449, 0.6334438407201852, 0.12900574969201062, 0.1044607608554472, 0.32103821739488736, 0.15900574927390476, 0.27858187773024723, 0.6158004960633277, 0.31056513022019006, 0.43949392647265473, 0.33551453941794185, 0.3620879976163962, 0.13291611143394766, 0.14068464610440767, 0.06438835021458056, 0.06640424942792267, 0.04952295936556661, 0.16129560919273533, 0.28045936382137693, 0.1814998361822605, 0.3770990945865301, 0.3423014031823558, 0.37938795841549977, 0.1963604305722514, 0.6339188993545035, 0.31446200913772815, 0.24123534540235447, 0.15498785329245746, 0.12100768962474906, 0.43455763447623696, 0.4418887716057598, 0.3478053628852501, 0.6168616054703023, 0.6080231577268536, 0.7087097432468041, 0.48926673316876823, 0.42766672413165374, 0.48201994728235353, 0.893463694752734, 0.8049187209810953, 0.8659056836148809, 0.8892884507632299, 0.7302718062248603, 0.8269161526741635, 0.8887217893321031, 0.8720514784168002, 0.8548578706719246, 0.08355193084430834, 0.05232209248010955, 0.0787371278851462, 0.11267592067364274, 0.1554802146067059, 0.14381242661126525, 0.17478249076881713, 0.10818834129484001, 0.0915141926099744, 0.8027839245672392, 0.7266623842243369, 0.6027752409387553, 0.1830470323135137, 0.6862212221268573, 0.6819534562814232, 0.23362199272139328, 0.21988269548333828, 0.21687213380887027, 0.3536923759566807, 0.6271740258634111, 0.4556954736983615, 0.43387982308202777, 0.5057920682241123, 0.48069414067579275, 0.2488170730249416, 0.7769426582346103, 0.2642999733810152, 0.20580647864350798, 0.2840116660531403, 0.23858217617998256, 0.4334613825596333, 0.5697851593838754, 0.30340169414110474, 0.24427599513694664, 0.2641516083325921, 0.25158358624394683, 0.2426407711512023, 0.30769297136987817, 0.2061933308595295, 0.23214488006931544, 0.3056666062338571, 0.2175786612261279, 0.2373864165610965, 0.23962903762855725, 0.22706481255804423, 0.17484312711763172, 0.20076779910603526, 0.18291327527549572, 0.17628952732469338, 0.2087714765417651, 0.20641642810596617, 0.17983776843356736, 0.19953853895065177, 0.1875475843358051, 0.18889649894166782, 0.18849954114421708, 0.187036961200171, 0.17322960616584204, 0.18695026347806576, 0.9416283770897668, 0.15154933010403748, 0.10895965705700472, 0.16570569659034495, 0.916642790669375, 0.8986591977597888, 0.8885200455950524, 0.21023842079053057, 0.16708204937362847, 0.15417148918434886, 0.8776644488706014, 0.857095717402184, 0.8604793116308883, 0.21223049186375287, 0.17847974852511306, 0.19937165965615544, 0.20629500021352964, 0.18303864203092857, 0.1821733438052967, 0.18580951315985206, 0.1868448703088469, 0.17491955519871827, 0.10551641441233028, 0.0880129957465795, 0.08183882489543681, 0.0955495905119862, 0.08457395022805725, 0.12648817099465792, 0.0795890332323943, 0.08124877505577333, 0.09173799007242756]}, "mutation_prompt": null}
{"id": "5b5bcf68-637d-4742-bbd5-78477cd723a8", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Adaptive swarm size\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce adaptive swarm size for enhanced exploration and exploitation balance in high-dimensional spaces.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.8980982671425689, 0.8903620049616174, 0.8988530611711405, 0.8932545471037056, 0.8879154653212531, 0.8890776578998386, 0.9042764617925443, 0.8948881339175825, 0.8926399277431314, 0.7908067798577216, 0.7963171525200662, 0.7691463443415147, 0.7861521281885755, 0.7384137833213005, 0.7650494658557858, 0.7466613163384963, 0.8042553946121596, 0.7401977461471319, 0.09686491762940641, 0.145015521164934, 0.13954667723027014, 0.08883147126247481, 0.12158071203809828, 0.14246759369462292, 0.08543604575781005, 0.11651216537128928, 0.1162232479695906, 0.10534666367404988, 0.1086401808715809, 0.12403561892945958, 0.1227838869170047, 0.08498647002862958, 0.12356918866601574, 0.11000272194217109, 0.09543067418859152, 0.10413182813264699, 0.8958457553630623, 0.9246980758595659, 0.9323430571211943, 0.927032995465498, 0.9357906118174969, 0.9219894036722209, 0.9257246401286136, 0.9238429026721982, 0.9158375560873677, 0.8099376705121574, 0.7859071482188211, 0.7918956257504677, 0.7988631115655729, 0.7660517694318512, 0.7997006651978558, 0.8038183917965578, 0.7797472939535286, 0.8205850281208377, 0.38807573057643796, 0.17149815958416603, 0.9105896054967318, 0.27820565968291533, 0.27906288564467063, 0.2135173465459378, 0.17567178859102317, 0.23475900167451713, 0.23639384099425564, 0.6891818550484219, 0.7413015948242958, 0.7375993174483211, 0.6921773842727268, 0.7851112254472163, 0.8121672872946074, 0.7335859109949809, 0.691808571318207, 0.7438793313686154, 0.705381006632888, 0.6886452689873384, 0.6742593630228897, 0.7691078317494832, 0.7354137983733264, 0.716902588099091, 0.7246718764776938, 0.8182057555730377, 0.6973296071471353, 0.524893278044298, 0.4296464440984693, 0.5493206255078452, 0.6230360912480866, 0.6847390247958334, 0.5104569876012623, 0.35558761012610474, 0.05774367894119936, 0.6149010330788307, 0.4836028770289629, 0.1388648764035899, 0.25062484185558664, 0.09340076878800885, 0.1494128162296724, 0.18668711084426837, 0.6545725008506056, 0.4982670797334592, 0.5937474246296442, 0.653771929586086, 0.5439759084240299, 0.45045689671437106, 0.4063654786256097, 0.38795635816597174, 0.32685456056179707, 0.1725896044098516, 0.25776338338783733, 0.2080706296499335, 0.5485038800943953, 0.5709549654799707, 0.6339652926559953, 0.6283242778850056, 0.6302775999301897, 0.5094604233391413, 0.6604543331652382, 0.6183887924627371, 0.6634161129421416, 0.8591162780685626, 0.8505580464302733, 0.8394734888313469, 0.8622647211860525, 0.8390210774642543, 0.8752653826045191, 0.8507340190038861, 0.8617439993919205, 0.8616848052623161, 0.11452668487522444, 0.08228366196261327, 0.09726637485734013, 0.18664310345540502, 0.10972184044380551, 0.12373335059792623, 0.13179927379653944, 0.16048668281489276, 0.09687209892983262, 0.7873333939552076, 0.7843569123740535, 0.5856973986138074, 0.815023028448911, 0.2761734433558286, 0.28614424771092883, 0.4092221860622195, 0.30768046306464614, 0.6135558264340026, 0.2130167059980066, 0.40232050913594075, 0.40551795513375866, 0.6511583344603477, 0.6369067104320095, 0.6129057971117586, 0.268607726949018, 0.5469124533101808, 0.2703053765794261, 0.19427000405457895, 0.6913011763681616, 0.3472487640823215, 0.4338078050637949, 0.18869346325186942, 0.334133580159647, 0.23807541446036917, 0.27394981901033266, 0.2804557103015498, 0.23814228457314124, 0.28805358365635503, 0.20806208085382683, 0.28191557864204553, 0.2875265961561123, 0.23246959346219032, 0.21567681290459673, 0.21630425114797203, 0.27832859324631964, 0.1990356445113528, 0.19024722065370958, 0.18835444382472055, 0.1996563884567848, 0.17782043899333622, 0.19293191137465648, 0.20830239769180137, 0.19119739874781738, 0.19971124404113327, 0.18733477652643205, 0.18751372198126215, 0.18802518346360553, 0.9358614324669595, 0.9151489283521499, 0.9221329925234291, 0.12219346890577631, 0.16849441433361156, 0.9258514390751847, 0.8943999291853538, 0.15605264424403797, 0.8732948373149961, 0.9011077453515852, 0.20976578610640595, 0.8817999887606904, 0.8894531210946778, 0.9097457428995559, 0.8655539921416153, 0.2182757247435193, 0.3931197577417541, 0.20661701820504463, 0.2094791961050969, 0.19407375695983076, 0.22219575385724, 0.1917059374736374, 0.49110901131392015, 0.18237599994301013, 0.08269495088094825, 0.11202492921654816, 0.09128963233290566, 0.0955950188635255, 0.09517469951281565, 0.10703495486968928, 0.08873425526346068, 0.09697454066689548, 0.15709873817077824]}, "mutation_prompt": null}
{"id": "9ea0334b-b587-4dcc-8c4d-4d203e196877", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Adaptive swarm size\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Perturb velocity adaptation\n                if eval_count % 20 == 0:\n                    self.vel_max = 0.3 + 0.2 * np.random.rand()\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce rotational perturbation in differential evolution and dynamic velocity adaptation for improved convergence.", "configspace": "", "generation": 96, "fitness": 0.4513310766227377, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.30.", "error": "", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.8961979346577541, 0.8920398024180992, 0.9004508489335994, 0.8947933138046518, 0.882215566198554, 0.8916576599041216, 0.8977050634104559, 0.8905769541587105, 0.8888375711402656, 0.7838744417349276, 0.7561012927150993, 0.7786886186865156, 0.6889943344720229, 0.7738460815434379, 0.7691172622679681, 0.7228880143560363, 0.7586404348276068, 0.7407453055264598, 0.08871963133833272, 0.09980452196203549, 0.14069523609694168, 0.1162524669385937, 0.11000387535449063, 0.10582946560662332, 0.14244134898351546, 0.11609416653690241, 0.11517182924489278, 0.08237447156081434, 0.09575275292019503, 0.11002932866044868, 0.10462996294678817, 0.09483936701995443, 0.09349121397115379, 0.09140946179874432, 0.11631947005281562, 0.10733382243557876, 0.8848183421014586, 0.9168995668721379, 0.8941802443409037, 0.8936979281450036, 0.8913030079306119, 0.9088484159549137, 0.9011367818294962, 0.9002070315445331, 0.8902828784366195, 0.800660868030443, 0.7944188060578729, 0.8086058885895372, 0.8086699818622978, 0.7870522782444609, 0.7951975751866369, 0.7807356048702893, 0.7858554751038671, 0.8108825116206769, 0.2288698655202045, 0.2285764729986144, 0.22767943937359947, 0.9089863760019388, 0.213430979777955, 0.21293739075456464, 0.1391563037247211, 0.17784784838409817, 0.23619636925514997, 0.7569477892244173, 0.7323727849617931, 0.13287512771708776, 0.7319009855007618, 0.7664226571824551, 0.6713661057128624, 0.695524674115899, 0.7304863280612323, 0.7005614780081746, 0.6982404998426801, 0.6638978198472714, 0.66743730212341, 0.7636061357503443, 0.6814581246301763, 0.725370549872097, 0.729542022425747, 0.7610103722781998, 0.7507023013302477, 0.1557068638894067, 0.17972941866684833, 0.7055385854349965, 0.4595848219538914, 0.25134017809216214, 0.2358052709910351, 0.44173303523125096, 0.5502484384804592, 0.5290469868989987, 0.19125953450554922, 0.11702572143278744, 0.14505311102191754, 0.233345603555266, 0.08684479074113971, 0.1168738307000371, 0.24971990248328224, 0.3535755705475535, 0.5004298622314183, 0.3313747351621358, 0.30479868613087124, 0.29013249893675674, 0.4231885683747101, 0.5008290922201304, 0.36169458092378637, 0.19242793437632688, 0.30189586183229844, 0.14572520383076826, 0.5932542333223005, 0.520658893967319, 0.5622779011333909, 0.6385692871914381, 0.6561762053014057, 0.6369620614396578, 0.5187493432577567, 0.6051960263015066, 0.5274909300902846, 0.836396344730246, 0.8523866859439122, 0.8539831592130845, 0.8648839526101179, 0.8453671851285012, 0.8208958303037964, 0.8516072616975154, 0.8465369217402265, 0.8522228210568463, 0.08744331675454231, 0.076158184106075, 0.04605991279942501, 0.096555856165641, 0.09550795148980085, 0.13111146425271558, 0.16098030817801068, 0.11680186905338263, 0.0799003347195063, 0.2579003524665334, 0.22023424175854933, 0.7353628907288698, 0.6762669988523846, 0.736867957114578, 0.2876594746116541, 0.21854486942538198, 0.7445532636323247, 0.28002430578123894, 0.22817424314891643, 0.7395350642299596, 0.21955560279910058, 0.39514740487664957, 0.30235240896946713, 0.4553396248583266, 0.25933720977452634, 0.6093748466516217, 0.24602033783192379, 0.459447152793626, 0.3248028708301378, 0.25335704689888827, 0.4927519524291949, 0.47012103225497026, 0.4388944075258979, 0.23004657838421294, 0.2833300820003497, 0.2540379832109356, 0.2433007588179532, 0.21085307140486298, 0.23533182391437357, 0.30288921253576984, 0.2232442173214585, 0.25789020684375696, 0.21085325887342343, 0.24171387484013507, 0.2655495992961201, 0.22793843297750038, 0.17152929922592774, 0.19855661462209062, 0.18874470065807825, 0.20276424095310563, 0.18046545805723968, 0.1820897131113155, 0.19972365608301712, 0.17951100266911912, 0.1879444678003952, 0.18752263876759256, 0.14803907356404178, 0.9308606629510557, 0.9090774599727858, 0.9185362150902155, 0.13618928606109548, 0.1676861255605896, 0.158102677036137, 0.9105000904170997, 0.15612230713332553, 0.9160038942309984, 0.9203042917094525, 0.8557975274506882, 0.9084477473835307, 0.16592870348972666, 0.9236470831691104, 0.8478778115796712, 0.27148335288844416, 0.3681007272377219, 0.17291634656989519, 0.43162141143189614, 0.1794034711364264, 0.2047174328036001, 0.20946668938282142, 0.46838835612633833, 0.21528585804342015, 0.09449258526547877, 0.09986385255998664, 0.08701675711022949, 0.08225381744984006, 0.08315835969941876, 0.10208937128936957, 0.08505525367709488, 0.08502804848723411, 0.10211033406238401]}, "mutation_prompt": null}
{"id": "346e9f95-6dcf-4b95-8304-86af533f7dc8", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Adaptive swarm size\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                levy_step = np.random.normal(0, 1, self.dim) * (np.abs(np.random.normal(0, 1, self.dim))**(-1/3))  # Lévy flight step\n                pos[i] = pos[i] + vel[i] + levy_step  # Incorporate Lévy flight\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Refine particle update strategy by incorporating a Lévy flight step to enhance global exploration capability.", "configspace": "", "generation": 97, "fitness": 0.14110063531640243, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.18.", "error": "", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.22059815962947982, 0.2132059715223874, 0.2157618538106898, 0.24873061071259583, 0.23531110240672237, 0.22245326019171496, 0.19775714229279362, 0.25131592214767784, 0.21177115904188282, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.053679087259862035, 0.05995322689085825, 0.05324031280025243, 0.05490882042132639, 0.06542296849023588, 0.061008865734082596, 0.06509432688060601, 0.06029586094875594, 0.0601742184445333, 0.04834911188843671, 0.03476808787023988, 0.05450218696289244, 0.04211533415127178, 0.04986038526722203, 0.03830914333903768, 0.049480846551004265, 0.06908032940928532, 0.04145807056430184, 0.7569828948903621, 0.8718977178670246, 0.9429345045529345, 0.972310586288092, 0.8573465461468823, 0.928433987162448, 0.9100244945902716, 0.9033284150660532, 0.8999823417721012, 0.10989497939352277, 0.13017044376671616, 0.11837830352692613, 0.10446557607784868, 0.11051870178159406, 0.11137936526229464, 0.11025990590663237, 0.09286815006070481, 0.1063028001873676, 0.15655400539025488, 0.16779639966980053, 0.1493124301134101, 0.1656879802493193, 0.15344079959912849, 0.16244566458257237, 0.1589501550849156, 0.15469571196487575, 0.18307123794616886, 0.028759795669409893, 0.04424008164130877, 0.018600021770190156, 0.020345427797978988, 0.03507445193718417, 0.030415824352872156, 0.05536414454601035, 0.01340657833648673, 0.025227317539424088, 0.055354239287867535, 0.01793175714667572, 0.021764045233019225, 0.018992039814665795, 0.002521166727574964, 0.05184235223982525, 0.009799431173479034, 0.02925178358196301, 0.027513611173057728, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06335720169256998, 0.06938432864239608, 0.05108397833975542, 0.13926485286352908, 0.07085144660561904, 0.054766873832691965, 0.045769847642511574, 0.08306341746407475, 0.04501778497715314, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035086729652537008, 0.026999663949711983, 9.999999999998899e-05, 0.02651760499815614, 9.999999999998899e-05, 0.01628758958119192, 0.0005414396095307916, 0.007229211218858667, 0.01703859151581477, 0.23666654769257067, 0.22632515511286788, 0.2229417677408373, 0.23976914207390432, 0.22251311458019896, 0.23328942565871325, 0.24381220931201764, 0.26886797015529873, 0.2279244449338821, 0.06081207387369614, 0.06038782931646769, 0.06772128484405893, 0.046927389885195625, 0.0679506886152138, 0.07412849784806241, 0.06450263329095418, 0.05958809192957437, 0.0618693941003563, 0.13660506247411208, 0.12974945897975854, 0.16322378294331485, 0.14443538300765268, 0.1465675337549337, 0.15344570806213798, 0.12567189011912638, 0.13672367648449213, 0.15521616378322012, 0.20857159275332837, 0.1769238530722268, 0.18860809438976922, 0.17767246497575395, 0.18748985599572054, 0.1808468411555234, 0.2048267481152889, 0.19928295090715142, 0.19970758963885582, 0.12601091721664304, 0.12572907571366942, 0.12625253433237626, 0.13786727932162157, 0.11864089483899898, 0.11880992690926473, 0.12384698697391328, 0.14894886909050242, 0.14293289047665236, 0.16571753971200565, 0.152976145624665, 0.1693842371279879, 0.17755560622607625, 0.16354761864903666, 0.17268254907872838, 0.16892524957892763, 0.1683812094141791, 0.21108104447296572, 0.15267693660947046, 0.16834862283933139, 0.16066751973469673, 0.16600675490802608, 0.1495218404854064, 0.16135176637232873, 0.14933379213699716, 0.15623319401875035, 0.1508545685375131, 0.24574870395679305, 0.18580377543343307, 0.17021558761168976, 0.2138436174421504, 0.20350506447922512, 0.2003277727187539, 0.22307145202304135, 0.18026664726403718, 0.22189378257675418, 0.22069333506601774, 0.20336261913864306, 0.20620366615448338, 0.20437829502223104, 0.17028723697061576, 0.1259551219486541, 0.23421820156480633, 0.23334032019451012, 0.2580945728908377, 0.18270100322492455, 0.17290546834952836, 0.19041381136889557, 0.17963114148583914, 0.20693933976325085, 0.1804506383062553, 0.2028644193683189, 0.17770303162146828, 0.18399106090396933, 0.056636009045057056, 0.06393419369555942, 0.07136835551293208, 0.06273904719228818, 0.049736423151883535, 0.07545757722473478, 0.06282777921993143, 0.0619218085088753, 0.06042742556737846]}, "mutation_prompt": null}
{"id": "edfa1309-c082-4d99-9452-061866038a26", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Adaptive swarm size\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Sinusoidal chaotic inertia weight\n            chaos_val = 4 * chaos_val * (1 - chaos_val)  # Logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                # Adaptive cognitive and social components\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor  # Enhanced adaptability\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor  # Enhanced adaptability\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce adaptive swarm size for enhanced exploration and exploitation balance in high-dimensional spaces.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.8980982671425689, 0.8903620049616174, 0.8988530611711405, 0.8932545471037056, 0.8879154653212531, 0.8890776578998386, 0.9042764617925443, 0.8948881339175825, 0.8926399277431314, 0.7908067798577216, 0.7963171525200662, 0.7691463443415147, 0.7861521281885755, 0.7384137833213005, 0.7650494658557858, 0.7466613163384963, 0.8042553946121596, 0.7401977461471319, 0.09686491762940641, 0.145015521164934, 0.13954667723027014, 0.08883147126247481, 0.12158071203809828, 0.14246759369462292, 0.08543604575781005, 0.11651216537128928, 0.1162232479695906, 0.10534666367404988, 0.1086401808715809, 0.12403561892945958, 0.1227838869170047, 0.08498647002862958, 0.12356918866601574, 0.11000272194217109, 0.09543067418859152, 0.10413182813264699, 0.8958457553630623, 0.9246980758595659, 0.9323430571211943, 0.927032995465498, 0.9357906118174969, 0.9219894036722209, 0.9257246401286136, 0.9238429026721982, 0.9158375560873677, 0.8099376705121574, 0.7859071482188211, 0.7918956257504677, 0.7988631115655729, 0.7660517694318512, 0.7997006651978558, 0.8038183917965578, 0.7797472939535286, 0.8205850281208377, 0.38807573057643796, 0.17149815958416603, 0.9105896054967318, 0.27820565968291533, 0.27906288564467063, 0.2135173465459378, 0.17567178859102317, 0.23475900167451713, 0.23639384099425564, 0.6891818550484219, 0.7413015948242958, 0.7375993174483211, 0.6921773842727268, 0.7851112254472163, 0.8121672872946074, 0.7335859109949809, 0.691808571318207, 0.7438793313686154, 0.705381006632888, 0.6886452689873384, 0.6742593630228897, 0.7691078317494832, 0.7354137983733264, 0.716902588099091, 0.7246718764776938, 0.8182057555730377, 0.6973296071471353, 0.524893278044298, 0.4296464440984693, 0.5493206255078452, 0.6230360912480866, 0.6847390247958334, 0.5104569876012623, 0.35558761012610474, 0.05774367894119936, 0.6149010330788307, 0.4836028770289629, 0.1388648764035899, 0.25062484185558664, 0.09340076878800885, 0.1494128162296724, 0.18668711084426837, 0.6545725008506056, 0.4982670797334592, 0.5937474246296442, 0.653771929586086, 0.5439759084240299, 0.45045689671437106, 0.4063654786256097, 0.38795635816597174, 0.32685456056179707, 0.1725896044098516, 0.25776338338783733, 0.2080706296499335, 0.5485038800943953, 0.5709549654799707, 0.6339652926559953, 0.6283242778850056, 0.6302775999301897, 0.5094604233391413, 0.6604543331652382, 0.6183887924627371, 0.6634161129421416, 0.8591162780685626, 0.8505580464302733, 0.8394734888313469, 0.8622647211860525, 0.8390210774642543, 0.8752653826045191, 0.8507340190038861, 0.8617439993919205, 0.8616848052623161, 0.11452668487522444, 0.08228366196261327, 0.09726637485734013, 0.18664310345540502, 0.10972184044380551, 0.12373335059792623, 0.13179927379653944, 0.16048668281489276, 0.09687209892983262, 0.7873333939552076, 0.7843569123740535, 0.5856973986138074, 0.815023028448911, 0.2761734433558286, 0.28614424771092883, 0.4092221860622195, 0.30768046306464614, 0.6135558264340026, 0.2130167059980066, 0.40232050913594075, 0.40551795513375866, 0.6511583344603477, 0.6369067104320095, 0.6129057971117586, 0.268607726949018, 0.5469124533101808, 0.2703053765794261, 0.19427000405457895, 0.6913011763681616, 0.3472487640823215, 0.4338078050637949, 0.18869346325186942, 0.334133580159647, 0.23807541446036917, 0.27394981901033266, 0.2804557103015498, 0.23814228457314124, 0.28805358365635503, 0.20806208085382683, 0.28191557864204553, 0.2875265961561123, 0.23246959346219032, 0.21567681290459673, 0.21630425114797203, 0.27832859324631964, 0.1990356445113528, 0.19024722065370958, 0.18835444382472055, 0.1996563884567848, 0.17782043899333622, 0.19293191137465648, 0.20830239769180137, 0.19119739874781738, 0.19971124404113327, 0.18733477652643205, 0.18751372198126215, 0.18802518346360553, 0.9358614324669595, 0.9151489283521499, 0.9221329925234291, 0.12219346890577631, 0.16849441433361156, 0.9258514390751847, 0.8943999291853538, 0.15605264424403797, 0.8732948373149961, 0.9011077453515852, 0.20976578610640595, 0.8817999887606904, 0.8894531210946778, 0.9097457428995559, 0.8655539921416153, 0.2182757247435193, 0.3931197577417541, 0.20661701820504463, 0.2094791961050969, 0.19407375695983076, 0.22219575385724, 0.1917059374736374, 0.49110901131392015, 0.18237599994301013, 0.08269495088094825, 0.11202492921654816, 0.09128963233290566, 0.0955950188635255, 0.09517469951281565, 0.10703495486968928, 0.08873425526346068, 0.09697454066689548, 0.15709873817077824]}, "mutation_prompt": null}
{"id": "46c78df6-e33d-4a26-95c7-ff3cfc892cc0", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.F = 0.5  # differential evolution scaling factor\n        self.CR = 0.9  # crossover probability\n        self.lb = -5.0\n        self.ub = 5.0\n        self.vel_max = 0.5  # maximum velocity\n\n    def __call__(self, func):\n        # Adaptive swarm size\n        initial_population_size = min(40, 5 * self.dim)  # Ensure swarm size scalability\n        pos = np.random.uniform(self.lb, self.ub, (initial_population_size, self.dim))\n        vel = np.random.uniform(-1, 1, (initial_population_size, self.dim))\n        pbest = pos.copy()\n        pbest_val = np.full(initial_population_size, np.inf)\n\n        # Evaluate initial population\n        eval_count = 0\n        for i in range(initial_population_size):\n            pbest_val[i] = func(pos[i])\n            eval_count += 1\n\n        # Determine the global best\n        gbest_idx = np.argmin(pbest_val)\n        gbest = pbest[gbest_idx]\n        gbest_val = pbest_val[gbest_idx]\n\n        chaos_val = 0.7  # Initial value for chaotic mapping\n        while eval_count < self.budget:\n            # Modified chaotic inertia weight\n            chaos_val = 3.9 * chaos_val * (1 - chaos_val)  # Improved logistic map\n            wave = 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n            dynamic_factor = (self.budget - eval_count) / self.budget\n            self.w = (self.w_max - (self.w_max - self.w_min) * (chaos_val + wave)) * dynamic_factor\n\n            # Random perturbation in inertia weight\n            self.w += np.random.uniform(-0.05, 0.05)\n\n            for i in range(initial_population_size):\n                # Oscillating cognitive and social components\n                wave_c1 = 0.3 * np.sin(2 * np.pi * eval_count / (0.5 * self.budget))\n                wave_c2 = 0.3 * np.cos(2 * np.pi * eval_count / (0.5 * self.budget))\n                c1_adaptive = 1.5 + 0.5 * chaos_val * dynamic_factor + wave_c1\n                c2_adaptive = 1.5 + 0.5 * (1 - chaos_val) * dynamic_factor + wave_c2\n\n                r1, r2 = np.random.rand(2)\n                vel[i] = (self.w * vel[i] \n                          + c1_adaptive * r1 * (pbest[i] - pos[i]) \n                          + c2_adaptive * r2 * (gbest - pos[i]))\n                vel[i] = np.clip(vel[i], -self.vel_max, self.vel_max)  # Clamping velocity\n                pos[i] = pos[i] + vel[i]\n\n                # Enforce boundary constraints\n                pos[i] = np.clip(pos[i], self.lb, self.ub)\n\n                # Enhanced DE mutation diversity\n                F_adaptive = 0.4 + 0.3 * chaos_val + np.random.uniform(-0.1, 0.1)\n\n                # DE mutation and crossover with rotational permutation\n                indices = [idx for idx in range(initial_population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = pos[a] + F_adaptive * (pos[b] - pos[(c+1)%len(indices)])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pos[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                # Selection between trial and original\n                if trial_value < pbest_val[i]:\n                    pbest[i] = trial\n                    pbest_val[i] = trial_value\n                    if trial_value < gbest_val:\n                        gbest = trial\n                        gbest_val = trial_value\n\n                # Break if the budget is exhausted\n                if eval_count >= self.budget:\n                    break\n\n        return gbest, gbest_val", "name": "HybridPSO_DE", "description": "Introduce oscillating cognitive-social factors and an improved chaotic mapping for dynamic behavior adaptation.", "configspace": "", "generation": 99, "fitness": 0.4640098471389415, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.30.", "error": "", "parent_id": "381d0042-0386-4a85-828a-7d036ecfbdd6", "metadata": {"aucs": [0.885180496255287, 0.8933671802930244, 0.881345055831319, 0.8782651109629034, 0.8793231084268494, 0.8911017456208777, 0.8917950877385195, 0.8840729915623653, 0.8823355793837908, 0.7366929713349895, 0.768643612803373, 0.7542032175863242, 0.7508040568861573, 0.7508366934483403, 0.7782499741867994, 0.7574119275335518, 0.7593819599637329, 0.7806425765849956, 0.06736231188936015, 0.14515374833249994, 0.14355557446805634, 0.09265573161211682, 0.11041901051186864, 0.13243762095899148, 0.09276320556142614, 0.09281108376550362, 0.08782269419929234, 0.11601805373912444, 0.12161834567853258, 0.10446980283919005, 0.1306794265334844, 0.09222155429320844, 0.08231136348646628, 0.10941536172161104, 0.11412510170300905, 0.08722444161981147, 0.9174824945712516, 0.9291265403749087, 0.9363250318913796, 0.9304521716335332, 0.9371213913125254, 0.9251598731515963, 0.9236110155593579, 0.9180880256498624, 0.911240794530214, 0.7840144645838325, 0.7936942716884677, 0.7871302399224148, 0.7977507566817927, 0.7930187133116207, 0.8046575361174808, 0.777791741101447, 0.7722182078349994, 0.7823434606065659, 0.2291767003978482, 0.22813303270835028, 0.21289054517974204, 0.8991604517419853, 0.21326810150376552, 0.8518342533801688, 0.2341795431721594, 0.17719404898378033, 0.17788994003870107, 0.7045075204972395, 0.754986254494509, 0.66703560947902, 0.7801415412306255, 0.7318207899112152, 0.687989926571279, 0.7158858565678092, 0.7406470112489599, 0.7710622786354586, 0.726912081909853, 0.6907522410458146, 0.7027178685618255, 0.7388690981751483, 0.7782702366776377, 0.7074795417241811, 0.6965664422194182, 0.6993095443783197, 0.6827461795951439, 0.18134869338579607, 0.1770080694760553, 0.6030695956122585, 0.5474498451183984, 0.5237340065800942, 0.4900047313068938, 0.13399246621832772, 0.49621883298397884, 0.3123350067333128, 0.37028499277320204, 0.14243232598473843, 0.2033474659641813, 0.12580308728427603, 0.13715425161083494, 0.13669842032402435, 0.43855934717196154, 0.23367684731088367, 0.4149836826039539, 0.42134359131501664, 0.2019873181462758, 0.27065279007409804, 0.3223546247201482, 0.4356776367848457, 0.4834517522438919, 0.12813062164347788, 0.31401595959601913, 0.22035033645697755, 0.5431705932992745, 0.6300176781172492, 0.583613229311762, 0.643702531412696, 0.6235801671673281, 0.6537622534479095, 0.5348269822990405, 0.6730510398224652, 0.573243045336993, 0.8475636988022286, 0.851688774472123, 0.8502098899506049, 0.8359699229864787, 0.8290618228786857, 0.8504115004378675, 0.8230484779449034, 0.8335440992221274, 0.8312433690541849, 0.10952400158973719, 0.11351589684789687, 0.10849238911976133, 0.1101362645923678, 0.13030467372834587, 0.14477556481384402, 0.11215443333771868, 0.14244445832593278, 0.08474229738308892, 0.6377722799103928, 0.802381804125594, 0.1950917054458866, 0.7880934511709863, 0.5591656347957176, 0.7726723891853777, 0.28103858917624935, 0.21845842332877863, 0.8109771621134709, 0.40088994066260764, 0.3687561256642611, 0.5372721840126318, 0.4613756842962371, 0.5900676449897457, 0.6402140551714004, 0.2880418918386177, 0.4838248991872558, 0.27854962396656124, 0.29777989067595323, 0.40534304106054564, 0.2666708293983675, 0.4432135855065762, 0.2246579503850944, 0.7301531851776852, 0.2508429621299808, 0.5772367655117027, 0.18418062736065066, 0.23250511353654757, 0.24502519447134796, 0.24877769228649738, 0.26629544072544964, 0.30639197711205957, 0.22511718527387348, 0.23495281067532747, 0.22308470535167924, 0.2689643936827374, 0.19879647663423383, 0.18321698929802688, 0.19954798220614944, 0.19091661636227808, 0.2120772043963981, 0.1715563869302661, 0.1834272343326705, 0.18490515392906792, 0.1835441508103418, 0.18717466367607727, 0.1876979125753846, 0.18790657258240917, 0.9322858412478957, 0.9066424533487849, 0.9351421760437846, 0.1363682744354865, 0.16816029172306135, 0.1669210934802764, 0.8997076412377801, 0.1563165927914011, 0.887697825870796, 0.913292933351476, 0.16796521698755473, 0.9059538715004094, 0.1658480569851063, 0.9024773178221991, 0.8353534434873612, 0.22186954756113153, 0.22861346226594625, 0.19754811354480717, 0.2143189083002487, 0.20616771816884183, 0.44386613704895606, 0.1892494433008597, 0.2725121121194215, 0.21437464748454682, 0.07763559177295754, 0.1650178202396808, 0.10305355775465963, 0.09106641209970634, 0.09587505197867541, 0.08725499747649124, 0.0999227305678585, 0.19846713249872394, 0.1393398794208246]}, "mutation_prompt": null}
