{"id": "ff4a041e-d248-4725-9260-d5fd2b11f161", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm combining Differential Evolution and Particle Swarm Optimization for efficient exploration and exploitation in high-dimensional spaces.", "configspace": "", "generation": 0, "fitness": 0.26569394215717174, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.25.", "error": "", "parent_id": null, "metadata": {"aucs": [0.7218258274916117, 0.7218258274916117, 0.7218258274916117, 0.7579781323288904, 0.7579781323288904, 0.7579781323288904, 0.7885627214506297, 0.7885627214506297, 0.7885627214506297, 0.034674878731796754, 0.034674878731796754, 0.034674878731796754, 0.039313724879395884, 0.039313724879395884, 0.039313724879395884, 0.4533442313698822, 0.4533442313698822, 0.4533442313698822, 0.10399638499128827, 0.10399638499128827, 0.10399638499128827, 0.0707986777769245, 0.0707986777769245, 0.0707986777769245, 0.1482461092699081, 0.1482461092699081, 0.1482461092699081, 0.12177671080008334, 0.12177671080008334, 0.12177671080008334, 0.1278556695789581, 0.1278556695789581, 0.1278556695789581, 0.11675177795635483, 0.11675177795635483, 0.11675177795635483, 0.9833306587245707, 0.9833306587245707, 0.9833306587245707, 0.987869232393744, 0.987869232393744, 0.987869232393744, 0.9840385517315244, 0.9840385517315244, 0.9840385517315244, 0.49210085037790074, 0.49210085037790074, 0.49210085037790074, 0.3941603020890524, 0.3941603020890524, 0.3941603020890524, 0.46929120368858446, 0.46929120368858446, 0.46929120368858446, 0.29852511351998456, 0.29852511351998456, 0.29852511351998456, 0.7343697114015991, 0.7343697114015991, 0.7343697114015991, 0.2989645028000739, 0.2989645028000739, 0.2989645028000739, 0.17147553693881978, 0.17147553693881978, 0.17147553693881978, 0.12874588722009506, 0.12874588722009506, 0.12874588722009506, 0.18119706048844408, 0.18119706048844408, 0.18119706048844408, 0.22710162312449733, 0.22710162312449733, 0.22710162312449733, 0.12395273493024739, 0.12395273493024739, 0.12395273493024739, 0.1258647374202272, 0.1258647374202272, 0.1258647374202272, 0.007283457883147992, 0.007283457883147992, 0.007283457883147992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09621094266421593, 0.09621094266421593, 0.09621094266421593, 0.05704316542016419, 0.05704316542016419, 0.05704316542016419, 0.040617914189347015, 0.040617914189347015, 0.040617914189347015, 0.05014710459887228, 0.05014710459887228, 0.05014710459887228, 0.10223414160778632, 0.10223414160778632, 0.10223414160778632, 0.05960172908031325, 0.05960172908031325, 0.05960172908031325, 0.040646106779507085, 0.040646106779507085, 0.040646106779507085, 0.03511668205598162, 0.03511668205598162, 0.03511668205598162, 0.04833445322525709, 0.04833445322525709, 0.04833445322525709, 0.46433851518450153, 0.46433851518450153, 0.46433851518450153, 0.4788910984725744, 0.4788910984725744, 0.4788910984725744, 0.5269233663169156, 0.5269233663169156, 0.5269233663169156, 0.1479736530414839, 0.1479736530414839, 0.1479736530414839, 0.09516290348020562, 0.09516290348020562, 0.09516290348020562, 0.14018511122850053, 0.14018511122850053, 0.14018511122850053, 0.23002647093915174, 0.23002647093915174, 0.23002647093915174, 0.23005309953182718, 0.23005309953182718, 0.23005309953182718, 0.14505616713736547, 0.14505616713736547, 0.14505616713736547, 0.39292396807188146, 0.39292396807188146, 0.39292396807188146, 0.34384173651364247, 0.34384173651364247, 0.34384173651364247, 0.19504194218808768, 0.19504194218808768, 0.19504194218808768, 0.25962848811252803, 0.25962848811252803, 0.25962848811252803, 0.21596390956312006, 0.21596390956312006, 0.21596390956312006, 0.13954139357201312, 0.13954139357201312, 0.13954139357201312, 0.21203705292692865, 0.21203705292692865, 0.21203705292692865, 0.25164111555471236, 0.25164111555471236, 0.25164111555471236, 0.19938375123829188, 0.19938375123829188, 0.19938375123829188, 0.5485810870530715, 0.5485810870530715, 0.5485810870530715, 0.2006384255226772, 0.2006384255226772, 0.2006384255226772, 0.21032119866345655, 0.21032119866345655, 0.21032119866345655, 0.8115644349807751, 0.8115644349807751, 0.8115644349807751, 0.1566137471092297, 0.1566137471092297, 0.1566137471092297, 0.18510957913941262, 0.18510957913941262, 0.18510957913941262, 0.159718167011892, 0.159718167011892, 0.159718167011892, 0.5457944774809704, 0.5457944774809704, 0.5457944774809704, 0.16225021171009302, 0.16225021171009302, 0.16225021171009302, 0.19975445507060918, 0.19975445507060918, 0.19975445507060918, 0.19884654490253306, 0.19884654490253306, 0.19884654490253306, 0.19554959683189277, 0.19554959683189277, 0.19554959683189277, 0.08639682586426212, 0.08639682586426212, 0.08639682586426212, 0.08317466479653501, 0.08317466479653501, 0.08317466479653501, 0.09348842512554145, 0.09348842512554145, 0.09348842512554145]}, "mutation_prompt": null}
{"id": "97a438a2-6826-485f-8323-32160a779d04", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.85  # DE scaling factor (slightly increased for better exploration)\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO by adjusting Differential Evolution scaling factor for improved convergence speed.", "configspace": "", "generation": 1, "fitness": 0.25125330041274313, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.24.", "error": "", "parent_id": "ff4a041e-d248-4725-9260-d5fd2b11f161", "metadata": {"aucs": [0.7398311181445294, 0.7398311181445294, 0.7398311181445294, 0.7653660911358291, 0.7653660911358291, 0.7653660911358291, 0.7839212810572503, 0.7839212810572503, 0.7839212810572503, 0.0541801673901644, 0.0541801673901644, 0.0541801673901644, 0.05632720127518276, 0.05632720127518276, 0.05632720127518276, 0.04376832177589618, 0.04376832177589618, 0.04376832177589618, 0.2558127488967038, 0.2558127488967038, 0.2558127488967038, 0.07119935570646863, 0.07119935570646863, 0.07119935570646863, 0.15427057379752274, 0.15427057379752274, 0.15427057379752274, 0.11948075131544755, 0.11948075131544755, 0.11948075131544755, 0.14640172367134585, 0.14640172367134585, 0.14640172367134585, 0.0860258625079634, 0.0860258625079634, 0.0860258625079634, 0.9833105060126387, 0.9833105060126387, 0.9833105060126387, 0.9833723610858665, 0.9833723610858665, 0.9833723610858665, 0.9824486043791558, 0.9824486043791558, 0.9824486043791558, 0.45118635764131476, 0.45118635764131476, 0.45118635764131476, 0.3853760691786027, 0.3853760691786027, 0.3853760691786027, 0.41997288760204143, 0.41997288760204143, 0.41997288760204143, 0.2207228581579781, 0.2207228581579781, 0.2207228581579781, 0.1900607241190193, 0.1900607241190193, 0.1900607241190193, 0.20983180385127143, 0.20983180385127143, 0.20983180385127143, 0.17696895065912543, 0.17696895065912543, 0.17696895065912543, 0.17335437821734234, 0.17335437821734234, 0.17335437821734234, 0.18405973746701143, 0.18405973746701143, 0.18405973746701143, 0.12821403463991488, 0.12821403463991488, 0.12821403463991488, 0.12971019328441658, 0.12971019328441658, 0.12971019328441658, 0.21136411828245483, 0.21136411828245483, 0.21136411828245483, 0.012129661083332244, 0.012129661083332244, 0.012129661083332244, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1018011883612262, 0.1018011883612262, 0.1018011883612262, 0.06770149437386697, 0.06770149437386697, 0.06770149437386697, 0.09772476374276917, 0.09772476374276917, 0.09772476374276917, 0.046025096314940894, 0.046025096314940894, 0.046025096314940894, 0.09129753057589185, 0.09129753057589185, 0.09129753057589185, 0.0958207264636487, 0.0958207264636487, 0.0958207264636487, 0.0342262449011238, 0.0342262449011238, 0.0342262449011238, 0.03689425517954592, 0.03689425517954592, 0.03689425517954592, 0.048868917346365004, 0.048868917346365004, 0.048868917346365004, 0.5026292310259421, 0.5026292310259421, 0.5026292310259421, 0.4816125328568467, 0.4816125328568467, 0.4816125328568467, 0.5023075314624887, 0.5023075314624887, 0.5023075314624887, 0.17428787798579104, 0.17428787798579104, 0.17428787798579104, 0.13555275606115125, 0.13555275606115125, 0.13555275606115125, 0.13682174374276856, 0.13682174374276856, 0.13682174374276856, 0.23629369370446995, 0.23629369370446995, 0.23629369370446995, 0.17171961604892405, 0.17171961604892405, 0.17171961604892405, 0.17253474738160401, 0.17253474738160401, 0.17253474738160401, 0.34506235492040305, 0.34506235492040305, 0.34506235492040305, 0.36848721572012566, 0.36848721572012566, 0.36848721572012566, 0.30409572846339084, 0.30409572846339084, 0.30409572846339084, 0.22456846650316842, 0.22456846650316842, 0.22456846650316842, 0.1849799369535583, 0.1849799369535583, 0.1849799369535583, 0.15100027540924477, 0.15100027540924477, 0.15100027540924477, 0.19474951268118812, 0.19474951268118812, 0.19474951268118812, 0.22487365773329793, 0.22487365773329793, 0.22487365773329793, 0.1783142711656721, 0.1783142711656721, 0.1783142711656721, 0.19489932208126715, 0.19489932208126715, 0.19489932208126715, 0.1938616120441078, 0.1938616120441078, 0.1938616120441078, 0.5294669242796065, 0.5294669242796065, 0.5294669242796065, 0.8274085595102825, 0.8274085595102825, 0.8274085595102825, 0.15747177855965533, 0.15747177855965533, 0.15747177855965533, 0.1851572455206878, 0.1851572455206878, 0.1851572455206878, 0.16124726813592338, 0.16124726813592338, 0.16124726813592338, 0.4571645128776558, 0.4571645128776558, 0.4571645128776558, 0.15356254244275247, 0.15356254244275247, 0.15356254244275247, 0.18821232530318444, 0.18821232530318444, 0.18821232530318444, 0.18186093215110954, 0.18186093215110954, 0.18186093215110954, 0.17879815263488652, 0.17879815263488652, 0.17879815263488652, 0.08677288166325614, 0.08677288166325614, 0.08677288166325614, 0.08506833973351202, 0.08506833973351202, 0.08506833973351202, 0.08016542336441468, 0.08016542336441468, 0.08016542336441468]}, "mutation_prompt": null}
{"id": "31c9192f-5d51-452e-8338-7f4b30a57829", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm combining Differential Evolution and Particle Swarm Optimization for efficient exploration and exploitation in high-dimensional spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ff4a041e-d248-4725-9260-d5fd2b11f161", "metadata": {"aucs": [0.7218258274916117, 0.7218258274916117, 0.7218258274916117, 0.7579781323288904, 0.7579781323288904, 0.7579781323288904, 0.7885627214506297, 0.7885627214506297, 0.7885627214506297, 0.034674878731796754, 0.034674878731796754, 0.034674878731796754, 0.039313724879395884, 0.039313724879395884, 0.039313724879395884, 0.4533442313698822, 0.4533442313698822, 0.4533442313698822, 0.10399638499128827, 0.10399638499128827, 0.10399638499128827, 0.0707986777769245, 0.0707986777769245, 0.0707986777769245, 0.1482461092699081, 0.1482461092699081, 0.1482461092699081, 0.12177671080008334, 0.12177671080008334, 0.12177671080008334, 0.1278556695789581, 0.1278556695789581, 0.1278556695789581, 0.11675177795635483, 0.11675177795635483, 0.11675177795635483, 0.9833306587245707, 0.9833306587245707, 0.9833306587245707, 0.987869232393744, 0.987869232393744, 0.987869232393744, 0.9840385517315244, 0.9840385517315244, 0.9840385517315244, 0.49210085037790074, 0.49210085037790074, 0.49210085037790074, 0.3941603020890524, 0.3941603020890524, 0.3941603020890524, 0.46929120368858446, 0.46929120368858446, 0.46929120368858446, 0.29852511351998456, 0.29852511351998456, 0.29852511351998456, 0.7343697114015991, 0.7343697114015991, 0.7343697114015991, 0.2989645028000739, 0.2989645028000739, 0.2989645028000739, 0.17147553693881978, 0.17147553693881978, 0.17147553693881978, 0.12874588722009506, 0.12874588722009506, 0.12874588722009506, 0.18119706048844408, 0.18119706048844408, 0.18119706048844408, 0.22710162312449733, 0.22710162312449733, 0.22710162312449733, 0.12395273493024739, 0.12395273493024739, 0.12395273493024739, 0.1258647374202272, 0.1258647374202272, 0.1258647374202272, 0.007283457883147992, 0.007283457883147992, 0.007283457883147992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09621094266421593, 0.09621094266421593, 0.09621094266421593, 0.05704316542016419, 0.05704316542016419, 0.05704316542016419, 0.040617914189347015, 0.040617914189347015, 0.040617914189347015, 0.05014710459887228, 0.05014710459887228, 0.05014710459887228, 0.10223414160778632, 0.10223414160778632, 0.10223414160778632, 0.05960172908031325, 0.05960172908031325, 0.05960172908031325, 0.040646106779507085, 0.040646106779507085, 0.040646106779507085, 0.03511668205598162, 0.03511668205598162, 0.03511668205598162, 0.04833445322525709, 0.04833445322525709, 0.04833445322525709, 0.46433851518450153, 0.46433851518450153, 0.46433851518450153, 0.4788910984725744, 0.4788910984725744, 0.4788910984725744, 0.5269233663169156, 0.5269233663169156, 0.5269233663169156, 0.1479736530414839, 0.1479736530414839, 0.1479736530414839, 0.09516290348020562, 0.09516290348020562, 0.09516290348020562, 0.14018511122850053, 0.14018511122850053, 0.14018511122850053, 0.23002647093915174, 0.23002647093915174, 0.23002647093915174, 0.23005309953182718, 0.23005309953182718, 0.23005309953182718, 0.14505616713736547, 0.14505616713736547, 0.14505616713736547, 0.39292396807188146, 0.39292396807188146, 0.39292396807188146, 0.34384173651364247, 0.34384173651364247, 0.34384173651364247, 0.19504194218808768, 0.19504194218808768, 0.19504194218808768, 0.25962848811252803, 0.25962848811252803, 0.25962848811252803, 0.21596390956312006, 0.21596390956312006, 0.21596390956312006, 0.13954139357201312, 0.13954139357201312, 0.13954139357201312, 0.21203705292692865, 0.21203705292692865, 0.21203705292692865, 0.25164111555471236, 0.25164111555471236, 0.25164111555471236, 0.19938375123829188, 0.19938375123829188, 0.19938375123829188, 0.5485810870530715, 0.5485810870530715, 0.5485810870530715, 0.2006384255226772, 0.2006384255226772, 0.2006384255226772, 0.21032119866345655, 0.21032119866345655, 0.21032119866345655, 0.8115644349807751, 0.8115644349807751, 0.8115644349807751, 0.1566137471092297, 0.1566137471092297, 0.1566137471092297, 0.18510957913941262, 0.18510957913941262, 0.18510957913941262, 0.159718167011892, 0.159718167011892, 0.159718167011892, 0.5457944774809704, 0.5457944774809704, 0.5457944774809704, 0.16225021171009302, 0.16225021171009302, 0.16225021171009302, 0.19975445507060918, 0.19975445507060918, 0.19975445507060918, 0.19884654490253306, 0.19884654490253306, 0.19884654490253306, 0.19554959683189277, 0.19554959683189277, 0.19554959683189277, 0.08639682586426212, 0.08639682586426212, 0.08639682586426212, 0.08317466479653501, 0.08317466479653501, 0.08317466479653501, 0.09348842512554145, 0.09348842512554145, 0.09348842512554145]}, "mutation_prompt": null}
{"id": "ca46da10-f73a-432b-aa51-bea267ff517e", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "A hybrid evolutionary algorithm combining Differential Evolution and Particle Swarm Optimization for efficient exploration and exploitation in high-dimensional spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ff4a041e-d248-4725-9260-d5fd2b11f161", "metadata": {"aucs": [0.7218258274916117, 0.7218258274916117, 0.7218258274916117, 0.7579781323288904, 0.7579781323288904, 0.7579781323288904, 0.7885627214506297, 0.7885627214506297, 0.7885627214506297, 0.034674878731796754, 0.034674878731796754, 0.034674878731796754, 0.039313724879395884, 0.039313724879395884, 0.039313724879395884, 0.4533442313698822, 0.4533442313698822, 0.4533442313698822, 0.10399638499128827, 0.10399638499128827, 0.10399638499128827, 0.0707986777769245, 0.0707986777769245, 0.0707986777769245, 0.1482461092699081, 0.1482461092699081, 0.1482461092699081, 0.12177671080008334, 0.12177671080008334, 0.12177671080008334, 0.1278556695789581, 0.1278556695789581, 0.1278556695789581, 0.11675177795635483, 0.11675177795635483, 0.11675177795635483, 0.9833306587245707, 0.9833306587245707, 0.9833306587245707, 0.987869232393744, 0.987869232393744, 0.987869232393744, 0.9840385517315244, 0.9840385517315244, 0.9840385517315244, 0.49210085037790074, 0.49210085037790074, 0.49210085037790074, 0.3941603020890524, 0.3941603020890524, 0.3941603020890524, 0.46929120368858446, 0.46929120368858446, 0.46929120368858446, 0.29852511351998456, 0.29852511351998456, 0.29852511351998456, 0.7343697114015991, 0.7343697114015991, 0.7343697114015991, 0.2989645028000739, 0.2989645028000739, 0.2989645028000739, 0.17147553693881978, 0.17147553693881978, 0.17147553693881978, 0.12874588722009506, 0.12874588722009506, 0.12874588722009506, 0.18119706048844408, 0.18119706048844408, 0.18119706048844408, 0.22710162312449733, 0.22710162312449733, 0.22710162312449733, 0.12395273493024739, 0.12395273493024739, 0.12395273493024739, 0.1258647374202272, 0.1258647374202272, 0.1258647374202272, 0.007283457883147992, 0.007283457883147992, 0.007283457883147992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09621094266421593, 0.09621094266421593, 0.09621094266421593, 0.05704316542016419, 0.05704316542016419, 0.05704316542016419, 0.040617914189347015, 0.040617914189347015, 0.040617914189347015, 0.05014710459887228, 0.05014710459887228, 0.05014710459887228, 0.10223414160778632, 0.10223414160778632, 0.10223414160778632, 0.05960172908031325, 0.05960172908031325, 0.05960172908031325, 0.040646106779507085, 0.040646106779507085, 0.040646106779507085, 0.03511668205598162, 0.03511668205598162, 0.03511668205598162, 0.04833445322525709, 0.04833445322525709, 0.04833445322525709, 0.46433851518450153, 0.46433851518450153, 0.46433851518450153, 0.4788910984725744, 0.4788910984725744, 0.4788910984725744, 0.5269233663169156, 0.5269233663169156, 0.5269233663169156, 0.1479736530414839, 0.1479736530414839, 0.1479736530414839, 0.09516290348020562, 0.09516290348020562, 0.09516290348020562, 0.14018511122850053, 0.14018511122850053, 0.14018511122850053, 0.23002647093915174, 0.23002647093915174, 0.23002647093915174, 0.23005309953182718, 0.23005309953182718, 0.23005309953182718, 0.14505616713736547, 0.14505616713736547, 0.14505616713736547, 0.39292396807188146, 0.39292396807188146, 0.39292396807188146, 0.34384173651364247, 0.34384173651364247, 0.34384173651364247, 0.19504194218808768, 0.19504194218808768, 0.19504194218808768, 0.25962848811252803, 0.25962848811252803, 0.25962848811252803, 0.21596390956312006, 0.21596390956312006, 0.21596390956312006, 0.13954139357201312, 0.13954139357201312, 0.13954139357201312, 0.21203705292692865, 0.21203705292692865, 0.21203705292692865, 0.25164111555471236, 0.25164111555471236, 0.25164111555471236, 0.19938375123829188, 0.19938375123829188, 0.19938375123829188, 0.5485810870530715, 0.5485810870530715, 0.5485810870530715, 0.2006384255226772, 0.2006384255226772, 0.2006384255226772, 0.21032119866345655, 0.21032119866345655, 0.21032119866345655, 0.8115644349807751, 0.8115644349807751, 0.8115644349807751, 0.1566137471092297, 0.1566137471092297, 0.1566137471092297, 0.18510957913941262, 0.18510957913941262, 0.18510957913941262, 0.159718167011892, 0.159718167011892, 0.159718167011892, 0.5457944774809704, 0.5457944774809704, 0.5457944774809704, 0.16225021171009302, 0.16225021171009302, 0.16225021171009302, 0.19975445507060918, 0.19975445507060918, 0.19975445507060918, 0.19884654490253306, 0.19884654490253306, 0.19884654490253306, 0.19554959683189277, 0.19554959683189277, 0.19554959683189277, 0.08639682586426212, 0.08639682586426212, 0.08639682586426212, 0.08317466479653501, 0.08317466479653501, 0.08317466479653501, 0.09348842512554145, 0.09348842512554145, 0.09348842512554145]}, "mutation_prompt": null}
{"id": "f69ab8df-b720-4271-94ee-93cd38c64ac4", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.9  # Adapted inertia weight for faster convergence\n        self.F = 0.8\n        self.CR = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                velocities[i] = np.clip(velocities[i], -2, 2)  # Dimension-wise velocity clamping\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "A modified hybrid algorithm integrating adaptive inertia weight and dimension-wise velocity to boost convergence speed in PSO dynamics.", "configspace": "", "generation": 4, "fitness": 0.20020183570651665, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.20.", "error": "", "parent_id": "ff4a041e-d248-4725-9260-d5fd2b11f161", "metadata": {"aucs": [0.3693223219318267, 0.3693223219318267, 0.3693223219318267, 0.38589047810802135, 0.38589047810802135, 0.38589047810802135, 0.32971986682469, 0.32971986682469, 0.32971986682469, 0.002258516086981799, 0.002258516086981799, 0.002258516086981799, 0.002167533543801947, 0.002167533543801947, 0.002167533543801947, 0.030860954890539638, 0.030860954890539638, 0.030860954890539638, 0.1140576619310597, 0.1140576619310597, 0.1140576619310597, 0.09899710026560349, 0.09899710026560349, 0.09899710026560349, 0.09717272853985504, 0.09717272853985504, 0.09717272853985504, 0.06593684516999443, 0.06593684516999443, 0.06593684516999443, 0.08858370912407754, 0.08858370912407754, 0.08858370912407754, 0.07870585891770698, 0.07870585891770698, 0.07870585891770698, 0.9573221023186999, 0.9573221023186999, 0.9573221023186999, 0.9707192669229198, 0.9707192669229198, 0.9707192669229198, 0.9647699831632139, 0.9647699831632139, 0.9647699831632139, 0.20398774104985473, 0.20398774104985473, 0.20398774104985473, 0.2073970953166333, 0.2073970953166333, 0.2073970953166333, 0.22137032554684088, 0.22137032554684088, 0.22137032554684088, 0.23870967866643733, 0.23870967866643733, 0.23870967866643733, 0.265622058292286, 0.265622058292286, 0.265622058292286, 0.2485926212260945, 0.2485926212260945, 0.2485926212260945, 0.09264182328386328, 0.09264182328386328, 0.09264182328386328, 0.07909050381791771, 0.07909050381791771, 0.07909050381791771, 0.13357104204961812, 0.13357104204961812, 0.13357104204961812, 0.11327550728748337, 0.11327550728748337, 0.11327550728748337, 0.14952965367981175, 0.14952965367981175, 0.14952965367981175, 0.08155927172029698, 0.08155927172029698, 0.08155927172029698, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.15640276108675788, 0.15640276108675788, 0.15640276108675788, 0.09527667860826183, 0.09527667860826183, 0.09527667860826183, 0.08698146549822217, 0.08698146549822217, 0.08698146549822217, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004589869199372876, 0.004589869199372876, 0.004589869199372876, 0.05883311541118186, 0.05883311541118186, 0.05883311541118186, 0.024784787000779573, 0.024784787000779573, 0.024784787000779573, 0.055948969366669155, 0.055948969366669155, 0.055948969366669155, 0.36340074293776636, 0.36340074293776636, 0.36340074293776636, 0.3422147976886919, 0.3422147976886919, 0.3422147976886919, 0.3588731668277828, 0.3588731668277828, 0.3588731668277828, 0.08104057652232421, 0.08104057652232421, 0.08104057652232421, 0.07590605373020776, 0.07590605373020776, 0.07590605373020776, 0.07401866553497127, 0.07401866553497127, 0.07401866553497127, 0.16173805005140307, 0.16173805005140307, 0.16173805005140307, 0.21277897557335212, 0.21277897557335212, 0.21277897557335212, 0.1833115722514963, 0.1833115722514963, 0.1833115722514963, 0.23172914901510344, 0.23172914901510344, 0.23172914901510344, 0.23969730861529037, 0.23969730861529037, 0.23969730861529037, 0.23508367995898694, 0.23508367995898694, 0.23508367995898694, 0.1692165049858626, 0.1692165049858626, 0.1692165049858626, 0.1974917092085109, 0.1974917092085109, 0.1974917092085109, 0.17022034488980842, 0.17022034488980842, 0.17022034488980842, 0.23627704165383034, 0.23627704165383034, 0.23627704165383034, 0.18915106663024017, 0.18915106663024017, 0.18915106663024017, 0.18943373764324856, 0.18943373764324856, 0.18943373764324856, 0.17278327927842907, 0.17278327927842907, 0.17278327927842907, 0.17692359295481042, 0.17692359295481042, 0.17692359295481042, 0.1829881228369229, 0.1829881228369229, 0.1829881228369229, 0.4583675338556319, 0.4583675338556319, 0.4583675338556319, 0.48565304754552807, 0.48565304754552807, 0.48565304754552807, 0.24666131518631762, 0.24666131518631762, 0.24666131518631762, 0.48917181276808186, 0.48917181276808186, 0.48917181276808186, 0.20543380497807984, 0.20543380497807984, 0.20543380497807984, 0.3722501022636746, 0.3722501022636746, 0.3722501022636746, 0.2092758995647438, 0.2092758995647438, 0.2092758995647438, 0.21003572718781138, 0.21003572718781138, 0.21003572718781138, 0.18180672704005096, 0.18180672704005096, 0.18180672704005096, 0.0738071840170027, 0.0738071840170027, 0.0738071840170027, 0.08280686022382255, 0.08280686022382255, 0.08280686022382255, 0.07983412160203929, 0.07983412160203929, 0.07983412160203929]}, "mutation_prompt": null}
{"id": "9460571f-67f6-4a2a-bd3e-6f7c211c2151", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.72  # Inertia weight, slightly increased\n        self.F = 0.85  # DE scaling factor, slightly refined\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Slightly refined mutation strategy and adjusted inertia weight for improved balance between exploration and exploitation.", "configspace": "", "generation": 5, "fitness": 0.25785269985884623, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.24.", "error": "", "parent_id": "ff4a041e-d248-4725-9260-d5fd2b11f161", "metadata": {"aucs": [0.7100002555634883, 0.7100002555634883, 0.7100002555634883, 0.746490103600342, 0.746490103600342, 0.746490103600342, 0.72300303232424, 0.72300303232424, 0.72300303232424, 0.03673262597206628, 0.03673262597206628, 0.03673262597206628, 0.36665011403963144, 0.36665011403963144, 0.36665011403963144, 0.382784072101482, 0.382784072101482, 0.382784072101482, 0.1353139946641475, 0.1353139946641475, 0.1353139946641475, 0.07125720863253737, 0.07125720863253737, 0.07125720863253737, 0.12467404792416237, 0.12467404792416237, 0.12467404792416237, 0.11518417843724127, 0.11518417843724127, 0.11518417843724127, 0.11079259692302834, 0.11079259692302834, 0.11079259692302834, 0.14405983335882644, 0.14405983335882644, 0.14405983335882644, 0.9833073277817901, 0.9833073277817901, 0.9833073277817901, 0.9833583636864385, 0.9833583636864385, 0.9833583636864385, 0.9824290337110103, 0.9824290337110103, 0.9824290337110103, 0.4086203631798674, 0.4086203631798674, 0.4086203631798674, 0.33404236104758545, 0.33404236104758545, 0.33404236104758545, 0.4201486990966755, 0.4201486990966755, 0.4201486990966755, 0.5503108870681438, 0.5503108870681438, 0.5503108870681438, 0.2590988193068997, 0.2590988193068997, 0.2590988193068997, 0.11496238436904693, 0.11496238436904693, 0.11496238436904693, 0.17460965807485063, 0.17460965807485063, 0.17460965807485063, 0.1992748929260587, 0.1992748929260587, 0.1992748929260587, 0.17054484558699168, 0.17054484558699168, 0.17054484558699168, 0.12242804081529579, 0.12242804081529579, 0.12242804081529579, 0.15598640211424375, 0.15598640211424375, 0.15598640211424375, 0.21999963761638053, 0.21999963761638053, 0.21999963761638053, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05441017948973681, 0.05441017948973681, 0.05441017948973681, 0.05253762589107824, 0.05253762589107824, 0.05253762589107824, 0.03162522377128407, 0.03162522377128407, 0.03162522377128407, 0.047346444161745604, 0.047346444161745604, 0.047346444161745604, 0.10651225079823001, 0.10651225079823001, 0.10651225079823001, 0.17145854730636734, 0.17145854730636734, 0.17145854730636734, 0.03300008258631537, 0.03300008258631537, 0.03300008258631537, 0.03609321491229345, 0.03609321491229345, 0.03609321491229345, 0.08042910496316003, 0.08042910496316003, 0.08042910496316003, 0.534459749281055, 0.534459749281055, 0.534459749281055, 0.5067600204563001, 0.5067600204563001, 0.5067600204563001, 0.4929478992425047, 0.4929478992425047, 0.4929478992425047, 0.12084268072280124, 0.12084268072280124, 0.12084268072280124, 0.11094050834166791, 0.11094050834166791, 0.11094050834166791, 0.11066181340757775, 0.11066181340757775, 0.11066181340757775, 0.2711953482644681, 0.2711953482644681, 0.2711953482644681, 0.17214339664583223, 0.17214339664583223, 0.17214339664583223, 0.1871771285321523, 0.1871771285321523, 0.1871771285321523, 0.3983578869571568, 0.3983578869571568, 0.3983578869571568, 0.20653519479780047, 0.20653519479780047, 0.20653519479780047, 0.34643261792558755, 0.34643261792558755, 0.34643261792558755, 0.2724848449149665, 0.2724848449149665, 0.2724848449149665, 0.18374145578810808, 0.18374145578810808, 0.18374145578810808, 0.1477306021049669, 0.1477306021049669, 0.1477306021049669, 0.19646822806722564, 0.19646822806722564, 0.19646822806722564, 0.20766698636943648, 0.20766698636943648, 0.20766698636943648, 0.2159527831444078, 0.2159527831444078, 0.2159527831444078, 0.22314355546582343, 0.22314355546582343, 0.22314355546582343, 0.2381566736029651, 0.2381566736029651, 0.2381566736029651, 0.23522127089259626, 0.23522127089259626, 0.23522127089259626, 0.7764866622617974, 0.7764866622617974, 0.7764866622617974, 0.15633425423785885, 0.15633425423785885, 0.15633425423785885, 0.1852061550304933, 0.1852061550304933, 0.1852061550304933, 0.16128975075589858, 0.16128975075589858, 0.16128975075589858, 0.5848850519151056, 0.5848850519151056, 0.5848850519151056, 0.15443017803587045, 0.15443017803587045, 0.15443017803587045, 0.20120645047770702, 0.20120645047770702, 0.20120645047770702, 0.1833088915407156, 0.1833088915407156, 0.1833088915407156, 0.18079828696858136, 0.18079828696858136, 0.18079828696858136, 0.09201921068357044, 0.09201921068357044, 0.09201921068357044, 0.07563586774510445, 0.07563586774510445, 0.07563586774510445, 0.07499653145614305, 0.07499653145614305, 0.07499653145614305]}, "mutation_prompt": null}
{"id": "10c6565e-1510-46a8-b429-3266f1cef935", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        # Modified line for adaptive inertia weight\n        self.w = 0.9   # Initial inertia weight\n        self.w_end = 0.4  # Final inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            # Modified line for adaptive inertia weight\n            self.w = self.w_end + (0.9 - self.w_end) * (1 - eval_count / self.budget)  # Adaptive inertia\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO with adaptive inertia for improved dynamic balance between exploration and exploitation.", "configspace": "", "generation": 6, "fitness": 0.241202220080545, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.23.", "error": "", "parent_id": "ff4a041e-d248-4725-9260-d5fd2b11f161", "metadata": {"aucs": [0.6397784667094, 0.6397784667094, 0.6397784667094, 0.6583712113412583, 0.6583712113412583, 0.6583712113412583, 0.662089131409699, 0.662089131409699, 0.662089131409699, 0.02965434576325443, 0.02965434576325443, 0.02965434576325443, 0.045182098616387, 0.045182098616387, 0.045182098616387, 0.032258619081916184, 0.032258619081916184, 0.032258619081916184, 0.11415419592324161, 0.11415419592324161, 0.11415419592324161, 0.126958197711888, 0.126958197711888, 0.126958197711888, 0.13206702380931146, 0.13206702380931146, 0.13206702380931146, 0.12409834800962449, 0.12409834800962449, 0.12409834800962449, 0.10807598013542208, 0.10807598013542208, 0.10807598013542208, 0.10561414726655216, 0.10561414726655216, 0.10561414726655216, 0.9833151377553594, 0.9833151377553594, 0.9833151377553594, 0.9878532285034534, 0.9878532285034534, 0.9878532285034534, 0.9824456056517712, 0.9824456056517712, 0.9824456056517712, 0.35204998627948714, 0.35204998627948714, 0.35204998627948714, 0.40597501954252546, 0.40597501954252546, 0.40597501954252546, 0.3832130819337606, 0.3832130819337606, 0.3832130819337606, 0.2811324678582562, 0.2811324678582562, 0.2811324678582562, 0.564605750839604, 0.564605750839604, 0.564605750839604, 0.20423633669456942, 0.20423633669456942, 0.20423633669456942, 0.15427384680117195, 0.15427384680117195, 0.15427384680117195, 0.11386581707793453, 0.11386581707793453, 0.11386581707793453, 0.15397724130401946, 0.15397724130401946, 0.15397724130401946, 0.1665631090272991, 0.1665631090272991, 0.1665631090272991, 0.11517692921747713, 0.11517692921747713, 0.11517692921747713, 0.16458496388059252, 0.16458496388059252, 0.16458496388059252, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07363314724205561, 0.07363314724205561, 0.07363314724205561, 0.05403149642911809, 0.05403149642911809, 0.05403149642911809, 0.0166808060547059, 0.0166808060547059, 0.0166808060547059, 0.04419453310542121, 0.04419453310542121, 0.04419453310542121, 0.0862669155271214, 0.0862669155271214, 0.0862669155271214, 0.07820697920720521, 0.07820697920720521, 0.07820697920720521, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030786054407955676, 0.030786054407955676, 0.030786054407955676, 0.04407130173163254, 0.04407130173163254, 0.04407130173163254, 0.45685507454712193, 0.45685507454712193, 0.45685507454712193, 0.44884523648620944, 0.44884523648620944, 0.44884523648620944, 0.47119711107874407, 0.47119711107874407, 0.47119711107874407, 0.0902067163960808, 0.0902067163960808, 0.0902067163960808, 0.09448284257001871, 0.09448284257001871, 0.09448284257001871, 0.09316054127130668, 0.09316054127130668, 0.09316054127130668, 0.19736632803103016, 0.19736632803103016, 0.19736632803103016, 0.16968836201319704, 0.16968836201319704, 0.16968836201319704, 0.16425198061951374, 0.16425198061951374, 0.16425198061951374, 0.32411145346794257, 0.32411145346794257, 0.32411145346794257, 0.29422241162772045, 0.29422241162772045, 0.29422241162772045, 0.37946625648588395, 0.37946625648588395, 0.37946625648588395, 0.1991412897061725, 0.1991412897061725, 0.1991412897061725, 0.16193782273663293, 0.16193782273663293, 0.16193782273663293, 0.13207450145859911, 0.13207450145859911, 0.13207450145859911, 0.19138134048759992, 0.19138134048759992, 0.19138134048759992, 0.21863697218287925, 0.21863697218287925, 0.21863697218287925, 0.18892166199616411, 0.18892166199616411, 0.18892166199616411, 0.3756460219191884, 0.3756460219191884, 0.3756460219191884, 0.4734076659044496, 0.4734076659044496, 0.4734076659044496, 0.18439890279934312, 0.18439890279934312, 0.18439890279934312, 0.7440479947351076, 0.7440479947351076, 0.7440479947351076, 0.15513075342729277, 0.15513075342729277, 0.15513075342729277, 0.1856004123348972, 0.1856004123348972, 0.1856004123348972, 0.15979811635575736, 0.15979811635575736, 0.15979811635575736, 0.1977766469527421, 0.1977766469527421, 0.1977766469527421, 0.5775332623519168, 0.5775332623519168, 0.5775332623519168, 0.19770580756151945, 0.19770580756151945, 0.19770580756151945, 0.18991500542865913, 0.18991500542865913, 0.18991500542865913, 0.20686552507696887, 0.20686552507696887, 0.20686552507696887, 0.07068661226254935, 0.07068661226254935, 0.07068661226254935, 0.078277508340162, 0.078277508340162, 0.078277508340162, 0.07398018533541562, 0.07398018533541562, 0.07398018533541562]}, "mutation_prompt": null}
{"id": "2c046c9e-e3c4-4898-ab02-306360d335e2", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight: linearly decrease over iterations\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introducing adaptive inertia weight adjustment in the PSO component to enhance exploration and convergence efficiency.", "configspace": "", "generation": 7, "fitness": 0.28458871461356444, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.26.", "error": "", "parent_id": "ff4a041e-d248-4725-9260-d5fd2b11f161", "metadata": {"aucs": [0.7965071640302558, 0.7965071640302558, 0.7965071640302558, 0.7979297189247185, 0.7979297189247185, 0.7979297189247185, 0.79621061797995, 0.79621061797995, 0.79621061797995, 0.5736064597194895, 0.5736064597194895, 0.5736064597194895, 0.5757509605326365, 0.5757509605326365, 0.5757509605326365, 0.5781402352116822, 0.5781402352116822, 0.5781402352116822, 0.15407804810539727, 0.15407804810539727, 0.15407804810539727, 0.07203113441578302, 0.07203113441578302, 0.07203113441578302, 0.16119075273427985, 0.16119075273427985, 0.16119075273427985, 0.10043479463747373, 0.10043479463747373, 0.10043479463747373, 0.10257231284067525, 0.10257231284067525, 0.10257231284067525, 0.12548786011793478, 0.12548786011793478, 0.12548786011793478, 0.9833304516150249, 0.9833304516150249, 0.9833304516150249, 0.987869232393744, 0.987869232393744, 0.987869232393744, 0.9840382515908129, 0.9840382515908129, 0.9840382515908129, 0.589765295428665, 0.589765295428665, 0.589765295428665, 0.5223889023671136, 0.5223889023671136, 0.5223889023671136, 0.6074789043683813, 0.6074789043683813, 0.6074789043683813, 0.644760750134987, 0.644760750134987, 0.644760750134987, 0.20754252667429696, 0.20754252667429696, 0.20754252667429696, 0.11554561040127775, 0.11554561040127775, 0.11554561040127775, 0.12693570763644024, 0.12693570763644024, 0.12693570763644024, 0.1290208981525477, 0.1290208981525477, 0.1290208981525477, 0.20252931388808104, 0.20252931388808104, 0.20252931388808104, 0.2146453812078276, 0.2146453812078276, 0.2146453812078276, 0.12592654390768543, 0.12592654390768543, 0.12592654390768543, 0.23235152564026496, 0.23235152564026496, 0.23235152564026496, 0.006860655077750799, 0.006860655077750799, 0.006860655077750799, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07236146627741147, 0.07236146627741147, 0.07236146627741147, 0.0783196258923583, 0.0783196258923583, 0.0783196258923583, 0.035597265492947505, 0.035597265492947505, 0.035597265492947505, 0.04208670259705416, 0.04208670259705416, 0.04208670259705416, 0.09143217826369932, 0.09143217826369932, 0.09143217826369932, 0.06032970540926286, 0.06032970540926286, 0.06032970540926286, 0.039730359183065556, 0.039730359183065556, 0.039730359183065556, 0.2195111030419984, 0.2195111030419984, 0.2195111030419984, 0.04795114868835337, 0.04795114868835337, 0.04795114868835337, 0.5154983825033604, 0.5154983825033604, 0.5154983825033604, 0.521775072072656, 0.521775072072656, 0.521775072072656, 0.5317016754928425, 0.5317016754928425, 0.5317016754928425, 0.14374226191418926, 0.14374226191418926, 0.14374226191418926, 0.10803163225009227, 0.10803163225009227, 0.10803163225009227, 0.10545107740536519, 0.10545107740536519, 0.10545107740536519, 0.14655263106309613, 0.14655263106309613, 0.14655263106309613, 0.17103921375889786, 0.17103921375889786, 0.17103921375889786, 0.17132507355807336, 0.17132507355807336, 0.17132507355807336, 0.3178642120252143, 0.3178642120252143, 0.3178642120252143, 0.24076940121044954, 0.24076940121044954, 0.24076940121044954, 0.20392591235712454, 0.20392591235712454, 0.20392591235712454, 0.2917933831226235, 0.2917933831226235, 0.2917933831226235, 0.21346075073912762, 0.21346075073912762, 0.21346075073912762, 0.14025549675547533, 0.14025549675547533, 0.14025549675547533, 0.2335196398802657, 0.2335196398802657, 0.2335196398802657, 0.2450840795273116, 0.2450840795273116, 0.2450840795273116, 0.1905092818081927, 0.1905092818081927, 0.1905092818081927, 0.2379120203711904, 0.2379120203711904, 0.2379120203711904, 0.211980831508488, 0.211980831508488, 0.211980831508488, 0.23995880299594163, 0.23995880299594163, 0.23995880299594163, 0.846168031352557, 0.846168031352557, 0.846168031352557, 0.15735889079612586, 0.15735889079612586, 0.15735889079612586, 0.18523406285480326, 0.18523406285480326, 0.18523406285480326, 0.15944522202328903, 0.15944522202328903, 0.15944522202328903, 0.7199460274989729, 0.7199460274989729, 0.7199460274989729, 0.16334338258037073, 0.16334338258037073, 0.16334338258037073, 0.1866512310742181, 0.1866512310742181, 0.1866512310742181, 0.2153887179383137, 0.2153887179383137, 0.2153887179383137, 0.2004937164504632, 0.2004937164504632, 0.2004937164504632, 0.08272680977171154, 0.08272680977171154, 0.08272680977171154, 0.09764426742712617, 0.09764426742712617, 0.09764426742712617, 0.09138669550737888, 0.09138669550737888, 0.09138669550737888]}, "mutation_prompt": null}
{"id": "08d79927-d144-4cc2-a5a0-35b395ae3b32", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a random inertia weight variation around its adaptive value to encourage diverse exploration and prevent premature convergence.", "configspace": "", "generation": 8, "fitness": 0.29858976415759464, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.27.", "error": "", "parent_id": "2c046c9e-e3c4-4898-ab02-306360d335e2", "metadata": {"aucs": [0.7746800969399547, 0.7746800969399547, 0.7746800969399547, 0.7853801286106803, 0.7853801286106803, 0.7853801286106803, 0.8045342136442298, 0.8045342136442298, 0.8045342136442298, 0.5112258617734755, 0.5112258617734755, 0.5112258617734755, 0.5827691753406969, 0.5827691753406969, 0.5827691753406969, 0.0165875754164847, 0.0165875754164847, 0.0165875754164847, 0.13824639610431877, 0.13824639610431877, 0.13824639610431877, 0.12343150815305326, 0.12343150815305326, 0.12343150815305326, 0.14327718676959988, 0.14327718676959988, 0.14327718676959988, 0.10277716308937379, 0.10277716308937379, 0.10277716308937379, 0.09387920086898627, 0.09387920086898627, 0.09387920086898627, 0.15146555854800425, 0.15146555854800425, 0.15146555854800425, 0.9833545195335007, 0.9833545195335007, 0.9833545195335007, 0.9871312113475053, 0.9871312113475053, 0.9871312113475053, 0.9817455104503656, 0.9817455104503656, 0.9817455104503656, 0.5767357099827427, 0.5767357099827427, 0.5767357099827427, 0.5169121442607256, 0.5169121442607256, 0.5169121442607256, 0.6014842608374387, 0.6014842608374387, 0.6014842608374387, 0.7498310772428576, 0.7498310772428576, 0.7498310772428576, 0.16131966356215888, 0.16131966356215888, 0.16131966356215888, 0.22972192522828738, 0.22972192522828738, 0.22972192522828738, 0.20843491632644195, 0.20843491632644195, 0.20843491632644195, 0.127538956888941, 0.127538956888941, 0.127538956888941, 0.20043941549992983, 0.20043941549992983, 0.20043941549992983, 0.20043724790322381, 0.20043724790322381, 0.20043724790322381, 0.1980083372102206, 0.1980083372102206, 0.1980083372102206, 0.25237156504785063, 0.25237156504785063, 0.25237156504785063, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10303185743654597, 0.10303185743654597, 0.10303185743654597, 0.024975329711378835, 0.024975329711378835, 0.024975329711378835, 0.07972047324539488, 0.07972047324539488, 0.07972047324539488, 0.04151606845294609, 0.04151606845294609, 0.04151606845294609, 0.09841399210917312, 0.09841399210917312, 0.09841399210917312, 0.07420626520238216, 0.07420626520238216, 0.07420626520238216, 0.07242114214448025, 0.07242114214448025, 0.07242114214448025, 0.05021356345675154, 0.05021356345675154, 0.05021356345675154, 0.04729625539112947, 0.04729625539112947, 0.04729625539112947, 0.5247403760073024, 0.5247403760073024, 0.5247403760073024, 0.5254732170676452, 0.5254732170676452, 0.5254732170676452, 0.533296283016953, 0.533296283016953, 0.533296283016953, 0.11182999082037737, 0.11182999082037737, 0.11182999082037737, 0.16698479434185887, 0.16698479434185887, 0.16698479434185887, 0.1702438449324729, 0.1702438449324729, 0.1702438449324729, 0.15124317160761425, 0.15124317160761425, 0.15124317160761425, 0.17136281637610795, 0.17136281637610795, 0.17136281637610795, 0.15305409833800154, 0.15305409833800154, 0.15305409833800154, 0.4289292632588073, 0.4289292632588073, 0.4289292632588073, 0.3750164439526886, 0.3750164439526886, 0.3750164439526886, 0.45479519017394565, 0.45479519017394565, 0.45479519017394565, 0.1752721744137603, 0.1752721744137603, 0.1752721744137603, 0.1709440418819106, 0.1709440418819106, 0.1709440418819106, 0.3249144544740491, 0.3249144544740491, 0.3249144544740491, 0.20836914558731834, 0.20836914558731834, 0.20836914558731834, 0.20620797279564684, 0.20620797279564684, 0.20620797279564684, 0.2202405707369386, 0.2202405707369386, 0.2202405707369386, 0.20073942156209978, 0.20073942156209978, 0.20073942156209978, 0.5560900414392491, 0.5560900414392491, 0.5560900414392491, 0.19881251793653076, 0.19881251793653076, 0.19881251793653076, 0.8573798517101334, 0.8573798517101334, 0.8573798517101334, 0.7875819206246645, 0.7875819206246645, 0.7875819206246645, 0.18541178273883496, 0.18541178273883496, 0.18541178273883496, 0.1678552414465876, 0.1678552414465876, 0.1678552414465876, 0.604090578199991, 0.604090578199991, 0.604090578199991, 0.16598417278698818, 0.16598417278698818, 0.16598417278698818, 0.22264407952425702, 0.22264407952425702, 0.22264407952425702, 0.1993759210264019, 0.1993759210264019, 0.1993759210264019, 0.21213396258850215, 0.21213396258850215, 0.21213396258850215, 0.0898788234987602, 0.0898788234987602, 0.0898788234987602, 0.08654610583524047, 0.08654610583524047, 0.08654610583524047, 0.09520527491394148, 0.09520527491394148, 0.09520527491394148]}, "mutation_prompt": null}
{"id": "82122dc6-9950-4a3b-bd32-11e0f8e1c8bc", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # Initial DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            F_decay = self.F * (1 - eval_count / self.budget)  # Introduce decay in DE scaling factor\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + F_decay * (pop[r2] - pop[r3])  # Use decayed F\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a decay factor to the DE scaling factor to balance exploration and exploitation over time.", "configspace": "", "generation": 9, "fitness": 0.2981712089618139, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "08d79927-d144-4cc2-a5a0-35b395ae3b32", "metadata": {"aucs": [0.7971695349437101, 0.7971695349437101, 0.7971695349437101, 0.7984144216253054, 0.7984144216253054, 0.7984144216253054, 0.7973210302201246, 0.7973210302201246, 0.7973210302201246, 0.5641484657535829, 0.5641484657535829, 0.5641484657535829, 0.5800799530356737, 0.5800799530356737, 0.5800799530356737, 0.004336351458596233, 0.004336351458596233, 0.004336351458596233, 0.5148020778469782, 0.5148020778469782, 0.5148020778469782, 0.14205879311570735, 0.14205879311570735, 0.14205879311570735, 0.1251363641805714, 0.1251363641805714, 0.1251363641805714, 0.14082138953360568, 0.14082138953360568, 0.14082138953360568, 0.11866078184592566, 0.11866078184592566, 0.11866078184592566, 0.11868194161412338, 0.11868194161412338, 0.11868194161412338, 0.9833534569578377, 0.9833534569578377, 0.9833534569578377, 0.9871291119866429, 0.9871291119866429, 0.9871291119866429, 0.9817410360951775, 0.9817410360951775, 0.9817410360951775, 0.6145119306582386, 0.6145119306582386, 0.6145119306582386, 0.5506034780303004, 0.5506034780303004, 0.5506034780303004, 0.5898639455901594, 0.5898639455901594, 0.5898639455901594, 0.22199947375547158, 0.22199947375547158, 0.22199947375547158, 0.33774481753907315, 0.33774481753907315, 0.33774481753907315, 0.22369498430724488, 0.22369498430724488, 0.22369498430724488, 0.21151588902622065, 0.21151588902622065, 0.21151588902622065, 0.19406245810431555, 0.19406245810431555, 0.19406245810431555, 0.21652132686358305, 0.21652132686358305, 0.21652132686358305, 0.2389871944587858, 0.2389871944587858, 0.2389871944587858, 0.23818257273293542, 0.23818257273293542, 0.23818257273293542, 0.2783524473134552, 0.2783524473134552, 0.2783524473134552, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10492892022652556, 0.10492892022652556, 0.10492892022652556, 0.006806296582308136, 0.006806296582308136, 0.006806296582308136, 0.06592105039711804, 0.06592105039711804, 0.06592105039711804, 0.04332058115968518, 0.04332058115968518, 0.04332058115968518, 0.11404842190169351, 0.11404842190169351, 0.11404842190169351, 0.09872596873152939, 0.09872596873152939, 0.09872596873152939, 0.19674002370515298, 0.19674002370515298, 0.19674002370515298, 0.044422196190210705, 0.044422196190210705, 0.044422196190210705, 0.04731008660738911, 0.04731008660738911, 0.04731008660738911, 0.5388611336703151, 0.5388611336703151, 0.5388611336703151, 0.571604740285865, 0.571604740285865, 0.571604740285865, 0.5572676237124818, 0.5572676237124818, 0.5572676237124818, 0.0692127884785968, 0.0692127884785968, 0.0692127884785968, 0.1472114648481585, 0.1472114648481585, 0.1472114648481585, 0.10508264087052865, 0.10508264087052865, 0.10508264087052865, 0.22380194503098616, 0.22380194503098616, 0.22380194503098616, 0.17310603942199998, 0.17310603942199998, 0.17310603942199998, 0.18977334687172587, 0.18977334687172587, 0.18977334687172587, 0.34925979361309734, 0.34925979361309734, 0.34925979361309734, 0.2345044400156847, 0.2345044400156847, 0.2345044400156847, 0.20808126964852547, 0.20808126964852547, 0.20808126964852547, 0.23343663465292563, 0.23343663465292563, 0.23343663465292563, 0.24512710919883385, 0.24512710919883385, 0.24512710919883385, 0.13302229450454905, 0.13302229450454905, 0.13302229450454905, 0.20568305058902425, 0.20568305058902425, 0.20568305058902425, 0.23120564500120933, 0.23120564500120933, 0.23120564500120933, 0.1955021028897972, 0.1955021028897972, 0.1955021028897972, 0.22009773043446978, 0.22009773043446978, 0.22009773043446978, 0.5242284580119299, 0.5242284580119299, 0.5242284580119299, 0.20433098238799552, 0.20433098238799552, 0.20433098238799552, 0.8202079329691402, 0.8202079329691402, 0.8202079329691402, 0.8086276018970979, 0.8086276018970979, 0.8086276018970979, 0.18538510291249666, 0.18538510291249666, 0.18538510291249666, 0.1678913605772292, 0.1678913605772292, 0.1678913605772292, 0.5858627564541523, 0.5858627564541523, 0.5858627564541523, 0.16395466977680062, 0.16395466977680062, 0.16395466977680062, 0.19849626066633996, 0.19849626066633996, 0.19849626066633996, 0.19832525670032397, 0.19832525670032397, 0.19832525670032397, 0.20220520998458114, 0.20220520998458114, 0.20220520998458114, 0.09422667978542054, 0.09422667978542054, 0.09422667978542054, 0.1000083695438374, 0.1000083695438374, 0.1000083695438374, 0.09031583574952506, 0.09031583574952506, 0.09031583574952506]}, "mutation_prompt": null}
{"id": "98d63e1a-e87d-467f-ab7c-81d303956b65", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a random inertia weight variation around its adaptive value to encourage diverse exploration and prevent premature convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "08d79927-d144-4cc2-a5a0-35b395ae3b32", "metadata": {"aucs": [0.7746800969399547, 0.7746800969399547, 0.7746800969399547, 0.7853801286106803, 0.7853801286106803, 0.7853801286106803, 0.8045342136442298, 0.8045342136442298, 0.8045342136442298, 0.5112258617734755, 0.5112258617734755, 0.5112258617734755, 0.5827691753406969, 0.5827691753406969, 0.5827691753406969, 0.0165875754164847, 0.0165875754164847, 0.0165875754164847, 0.13824639610431877, 0.13824639610431877, 0.13824639610431877, 0.12343150815305326, 0.12343150815305326, 0.12343150815305326, 0.14327718676959988, 0.14327718676959988, 0.14327718676959988, 0.10277716308937379, 0.10277716308937379, 0.10277716308937379, 0.09387920086898627, 0.09387920086898627, 0.09387920086898627, 0.15146555854800425, 0.15146555854800425, 0.15146555854800425, 0.9833545195335007, 0.9833545195335007, 0.9833545195335007, 0.9871312113475053, 0.9871312113475053, 0.9871312113475053, 0.9817455104503656, 0.9817455104503656, 0.9817455104503656, 0.5767357099827427, 0.5767357099827427, 0.5767357099827427, 0.5169121442607256, 0.5169121442607256, 0.5169121442607256, 0.6014842608374387, 0.6014842608374387, 0.6014842608374387, 0.7498310772428576, 0.7498310772428576, 0.7498310772428576, 0.16131966356215888, 0.16131966356215888, 0.16131966356215888, 0.22972192522828738, 0.22972192522828738, 0.22972192522828738, 0.20843491632644195, 0.20843491632644195, 0.20843491632644195, 0.127538956888941, 0.127538956888941, 0.127538956888941, 0.20043941549992983, 0.20043941549992983, 0.20043941549992983, 0.20043724790322381, 0.20043724790322381, 0.20043724790322381, 0.1980083372102206, 0.1980083372102206, 0.1980083372102206, 0.25237156504785063, 0.25237156504785063, 0.25237156504785063, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10303185743654597, 0.10303185743654597, 0.10303185743654597, 0.024975329711378835, 0.024975329711378835, 0.024975329711378835, 0.07972047324539488, 0.07972047324539488, 0.07972047324539488, 0.04151606845294609, 0.04151606845294609, 0.04151606845294609, 0.09841399210917312, 0.09841399210917312, 0.09841399210917312, 0.07420626520238216, 0.07420626520238216, 0.07420626520238216, 0.07242114214448025, 0.07242114214448025, 0.07242114214448025, 0.05021356345675154, 0.05021356345675154, 0.05021356345675154, 0.04729625539112947, 0.04729625539112947, 0.04729625539112947, 0.5247403760073024, 0.5247403760073024, 0.5247403760073024, 0.5254732170676452, 0.5254732170676452, 0.5254732170676452, 0.533296283016953, 0.533296283016953, 0.533296283016953, 0.11182999082037737, 0.11182999082037737, 0.11182999082037737, 0.16698479434185887, 0.16698479434185887, 0.16698479434185887, 0.1702438449324729, 0.1702438449324729, 0.1702438449324729, 0.15124317160761425, 0.15124317160761425, 0.15124317160761425, 0.17136281637610795, 0.17136281637610795, 0.17136281637610795, 0.15305409833800154, 0.15305409833800154, 0.15305409833800154, 0.4289292632588073, 0.4289292632588073, 0.4289292632588073, 0.3750164439526886, 0.3750164439526886, 0.3750164439526886, 0.45479519017394565, 0.45479519017394565, 0.45479519017394565, 0.1752721744137603, 0.1752721744137603, 0.1752721744137603, 0.1709440418819106, 0.1709440418819106, 0.1709440418819106, 0.3249144544740491, 0.3249144544740491, 0.3249144544740491, 0.20836914558731834, 0.20836914558731834, 0.20836914558731834, 0.20620797279564684, 0.20620797279564684, 0.20620797279564684, 0.2202405707369386, 0.2202405707369386, 0.2202405707369386, 0.20073942156209978, 0.20073942156209978, 0.20073942156209978, 0.5560900414392491, 0.5560900414392491, 0.5560900414392491, 0.19881251793653076, 0.19881251793653076, 0.19881251793653076, 0.8573798517101334, 0.8573798517101334, 0.8573798517101334, 0.7875819206246645, 0.7875819206246645, 0.7875819206246645, 0.18541178273883496, 0.18541178273883496, 0.18541178273883496, 0.1678552414465876, 0.1678552414465876, 0.1678552414465876, 0.604090578199991, 0.604090578199991, 0.604090578199991, 0.16598417278698818, 0.16598417278698818, 0.16598417278698818, 0.22264407952425702, 0.22264407952425702, 0.22264407952425702, 0.1993759210264019, 0.1993759210264019, 0.1993759210264019, 0.21213396258850215, 0.21213396258850215, 0.21213396258850215, 0.0898788234987602, 0.0898788234987602, 0.0898788234987602, 0.08654610583524047, 0.08654610583524047, 0.08654610583524047, 0.09520527491394148, 0.09520527491394148, 0.09520527491394148]}, "mutation_prompt": null}
{"id": "8363e73b-b3d7-4833-8af6-414b861c45d2", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a random inertia weight variation around its adaptive value to encourage diverse exploration and prevent premature convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "08d79927-d144-4cc2-a5a0-35b395ae3b32", "metadata": {"aucs": [0.7746800969399547, 0.7746800969399547, 0.7746800969399547, 0.7853801286106803, 0.7853801286106803, 0.7853801286106803, 0.8045342136442298, 0.8045342136442298, 0.8045342136442298, 0.5112258617734755, 0.5112258617734755, 0.5112258617734755, 0.5827691753406969, 0.5827691753406969, 0.5827691753406969, 0.0165875754164847, 0.0165875754164847, 0.0165875754164847, 0.13824639610431877, 0.13824639610431877, 0.13824639610431877, 0.12343150815305326, 0.12343150815305326, 0.12343150815305326, 0.14327718676959988, 0.14327718676959988, 0.14327718676959988, 0.10277716308937379, 0.10277716308937379, 0.10277716308937379, 0.09387920086898627, 0.09387920086898627, 0.09387920086898627, 0.15146555854800425, 0.15146555854800425, 0.15146555854800425, 0.9833545195335007, 0.9833545195335007, 0.9833545195335007, 0.9871312113475053, 0.9871312113475053, 0.9871312113475053, 0.9817455104503656, 0.9817455104503656, 0.9817455104503656, 0.5767357099827427, 0.5767357099827427, 0.5767357099827427, 0.5169121442607256, 0.5169121442607256, 0.5169121442607256, 0.6014842608374387, 0.6014842608374387, 0.6014842608374387, 0.7498310772428576, 0.7498310772428576, 0.7498310772428576, 0.16131966356215888, 0.16131966356215888, 0.16131966356215888, 0.22972192522828738, 0.22972192522828738, 0.22972192522828738, 0.20843491632644195, 0.20843491632644195, 0.20843491632644195, 0.127538956888941, 0.127538956888941, 0.127538956888941, 0.20043941549992983, 0.20043941549992983, 0.20043941549992983, 0.20043724790322381, 0.20043724790322381, 0.20043724790322381, 0.1980083372102206, 0.1980083372102206, 0.1980083372102206, 0.25237156504785063, 0.25237156504785063, 0.25237156504785063, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10303185743654597, 0.10303185743654597, 0.10303185743654597, 0.024975329711378835, 0.024975329711378835, 0.024975329711378835, 0.07972047324539488, 0.07972047324539488, 0.07972047324539488, 0.04151606845294609, 0.04151606845294609, 0.04151606845294609, 0.09841399210917312, 0.09841399210917312, 0.09841399210917312, 0.07420626520238216, 0.07420626520238216, 0.07420626520238216, 0.07242114214448025, 0.07242114214448025, 0.07242114214448025, 0.05021356345675154, 0.05021356345675154, 0.05021356345675154, 0.04729625539112947, 0.04729625539112947, 0.04729625539112947, 0.5247403760073024, 0.5247403760073024, 0.5247403760073024, 0.5254732170676452, 0.5254732170676452, 0.5254732170676452, 0.533296283016953, 0.533296283016953, 0.533296283016953, 0.11182999082037737, 0.11182999082037737, 0.11182999082037737, 0.16698479434185887, 0.16698479434185887, 0.16698479434185887, 0.1702438449324729, 0.1702438449324729, 0.1702438449324729, 0.15124317160761425, 0.15124317160761425, 0.15124317160761425, 0.17136281637610795, 0.17136281637610795, 0.17136281637610795, 0.15305409833800154, 0.15305409833800154, 0.15305409833800154, 0.4289292632588073, 0.4289292632588073, 0.4289292632588073, 0.3750164439526886, 0.3750164439526886, 0.3750164439526886, 0.45479519017394565, 0.45479519017394565, 0.45479519017394565, 0.1752721744137603, 0.1752721744137603, 0.1752721744137603, 0.1709440418819106, 0.1709440418819106, 0.1709440418819106, 0.3249144544740491, 0.3249144544740491, 0.3249144544740491, 0.20836914558731834, 0.20836914558731834, 0.20836914558731834, 0.20620797279564684, 0.20620797279564684, 0.20620797279564684, 0.2202405707369386, 0.2202405707369386, 0.2202405707369386, 0.20073942156209978, 0.20073942156209978, 0.20073942156209978, 0.5560900414392491, 0.5560900414392491, 0.5560900414392491, 0.19881251793653076, 0.19881251793653076, 0.19881251793653076, 0.8573798517101334, 0.8573798517101334, 0.8573798517101334, 0.7875819206246645, 0.7875819206246645, 0.7875819206246645, 0.18541178273883496, 0.18541178273883496, 0.18541178273883496, 0.1678552414465876, 0.1678552414465876, 0.1678552414465876, 0.604090578199991, 0.604090578199991, 0.604090578199991, 0.16598417278698818, 0.16598417278698818, 0.16598417278698818, 0.22264407952425702, 0.22264407952425702, 0.22264407952425702, 0.1993759210264019, 0.1993759210264019, 0.1993759210264019, 0.21213396258850215, 0.21213396258850215, 0.21213396258850215, 0.0898788234987602, 0.0898788234987602, 0.0898788234987602, 0.08654610583524047, 0.08654610583524047, 0.08654610583524047, 0.09520527491394148, 0.09520527491394148, 0.09520527491394148]}, "mutation_prompt": null}
{"id": "f301b98f-036a-480c-842e-e777d4f738a0", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a random inertia weight variation around its adaptive value to encourage diverse exploration and prevent premature convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "08d79927-d144-4cc2-a5a0-35b395ae3b32", "metadata": {"aucs": [0.7746800969399547, 0.7746800969399547, 0.7746800969399547, 0.7853801286106803, 0.7853801286106803, 0.7853801286106803, 0.8045342136442298, 0.8045342136442298, 0.8045342136442298, 0.5112258617734755, 0.5112258617734755, 0.5112258617734755, 0.5827691753406969, 0.5827691753406969, 0.5827691753406969, 0.0165875754164847, 0.0165875754164847, 0.0165875754164847, 0.13824639610431877, 0.13824639610431877, 0.13824639610431877, 0.12343150815305326, 0.12343150815305326, 0.12343150815305326, 0.14327718676959988, 0.14327718676959988, 0.14327718676959988, 0.10277716308937379, 0.10277716308937379, 0.10277716308937379, 0.09387920086898627, 0.09387920086898627, 0.09387920086898627, 0.15146555854800425, 0.15146555854800425, 0.15146555854800425, 0.9833545195335007, 0.9833545195335007, 0.9833545195335007, 0.9871312113475053, 0.9871312113475053, 0.9871312113475053, 0.9817455104503656, 0.9817455104503656, 0.9817455104503656, 0.5767357099827427, 0.5767357099827427, 0.5767357099827427, 0.5169121442607256, 0.5169121442607256, 0.5169121442607256, 0.6014842608374387, 0.6014842608374387, 0.6014842608374387, 0.7498310772428576, 0.7498310772428576, 0.7498310772428576, 0.16131966356215888, 0.16131966356215888, 0.16131966356215888, 0.22972192522828738, 0.22972192522828738, 0.22972192522828738, 0.20843491632644195, 0.20843491632644195, 0.20843491632644195, 0.127538956888941, 0.127538956888941, 0.127538956888941, 0.20043941549992983, 0.20043941549992983, 0.20043941549992983, 0.20043724790322381, 0.20043724790322381, 0.20043724790322381, 0.1980083372102206, 0.1980083372102206, 0.1980083372102206, 0.25237156504785063, 0.25237156504785063, 0.25237156504785063, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10303185743654597, 0.10303185743654597, 0.10303185743654597, 0.024975329711378835, 0.024975329711378835, 0.024975329711378835, 0.07972047324539488, 0.07972047324539488, 0.07972047324539488, 0.04151606845294609, 0.04151606845294609, 0.04151606845294609, 0.09841399210917312, 0.09841399210917312, 0.09841399210917312, 0.07420626520238216, 0.07420626520238216, 0.07420626520238216, 0.07242114214448025, 0.07242114214448025, 0.07242114214448025, 0.05021356345675154, 0.05021356345675154, 0.05021356345675154, 0.04729625539112947, 0.04729625539112947, 0.04729625539112947, 0.5247403760073024, 0.5247403760073024, 0.5247403760073024, 0.5254732170676452, 0.5254732170676452, 0.5254732170676452, 0.533296283016953, 0.533296283016953, 0.533296283016953, 0.11182999082037737, 0.11182999082037737, 0.11182999082037737, 0.16698479434185887, 0.16698479434185887, 0.16698479434185887, 0.1702438449324729, 0.1702438449324729, 0.1702438449324729, 0.15124317160761425, 0.15124317160761425, 0.15124317160761425, 0.17136281637610795, 0.17136281637610795, 0.17136281637610795, 0.15305409833800154, 0.15305409833800154, 0.15305409833800154, 0.4289292632588073, 0.4289292632588073, 0.4289292632588073, 0.3750164439526886, 0.3750164439526886, 0.3750164439526886, 0.45479519017394565, 0.45479519017394565, 0.45479519017394565, 0.1752721744137603, 0.1752721744137603, 0.1752721744137603, 0.1709440418819106, 0.1709440418819106, 0.1709440418819106, 0.3249144544740491, 0.3249144544740491, 0.3249144544740491, 0.20836914558731834, 0.20836914558731834, 0.20836914558731834, 0.20620797279564684, 0.20620797279564684, 0.20620797279564684, 0.2202405707369386, 0.2202405707369386, 0.2202405707369386, 0.20073942156209978, 0.20073942156209978, 0.20073942156209978, 0.5560900414392491, 0.5560900414392491, 0.5560900414392491, 0.19881251793653076, 0.19881251793653076, 0.19881251793653076, 0.8573798517101334, 0.8573798517101334, 0.8573798517101334, 0.7875819206246645, 0.7875819206246645, 0.7875819206246645, 0.18541178273883496, 0.18541178273883496, 0.18541178273883496, 0.1678552414465876, 0.1678552414465876, 0.1678552414465876, 0.604090578199991, 0.604090578199991, 0.604090578199991, 0.16598417278698818, 0.16598417278698818, 0.16598417278698818, 0.22264407952425702, 0.22264407952425702, 0.22264407952425702, 0.1993759210264019, 0.1993759210264019, 0.1993759210264019, 0.21213396258850215, 0.21213396258850215, 0.21213396258850215, 0.0898788234987602, 0.0898788234987602, 0.0898788234987602, 0.08654610583524047, 0.08654610583524047, 0.08654610583524047, 0.09520527491394148, 0.09520527491394148, 0.09520527491394148]}, "mutation_prompt": null}
{"id": "ecf63b82-baf0-4620-b0d5-e5b3ff2a1071", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a random inertia weight variation around its adaptive value to encourage diverse exploration and prevent premature convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "08d79927-d144-4cc2-a5a0-35b395ae3b32", "metadata": {"aucs": [0.7746800969399547, 0.7746800969399547, 0.7746800969399547, 0.7853801286106803, 0.7853801286106803, 0.7853801286106803, 0.8045342136442298, 0.8045342136442298, 0.8045342136442298, 0.5112258617734755, 0.5112258617734755, 0.5112258617734755, 0.5827691753406969, 0.5827691753406969, 0.5827691753406969, 0.0165875754164847, 0.0165875754164847, 0.0165875754164847, 0.13824639610431877, 0.13824639610431877, 0.13824639610431877, 0.12343150815305326, 0.12343150815305326, 0.12343150815305326, 0.14327718676959988, 0.14327718676959988, 0.14327718676959988, 0.10277716308937379, 0.10277716308937379, 0.10277716308937379, 0.09387920086898627, 0.09387920086898627, 0.09387920086898627, 0.15146555854800425, 0.15146555854800425, 0.15146555854800425, 0.9833545195335007, 0.9833545195335007, 0.9833545195335007, 0.9871312113475053, 0.9871312113475053, 0.9871312113475053, 0.9817455104503656, 0.9817455104503656, 0.9817455104503656, 0.5767357099827427, 0.5767357099827427, 0.5767357099827427, 0.5169121442607256, 0.5169121442607256, 0.5169121442607256, 0.6014842608374387, 0.6014842608374387, 0.6014842608374387, 0.7498310772428576, 0.7498310772428576, 0.7498310772428576, 0.16131966356215888, 0.16131966356215888, 0.16131966356215888, 0.22972192522828738, 0.22972192522828738, 0.22972192522828738, 0.20843491632644195, 0.20843491632644195, 0.20843491632644195, 0.127538956888941, 0.127538956888941, 0.127538956888941, 0.20043941549992983, 0.20043941549992983, 0.20043941549992983, 0.20043724790322381, 0.20043724790322381, 0.20043724790322381, 0.1980083372102206, 0.1980083372102206, 0.1980083372102206, 0.25237156504785063, 0.25237156504785063, 0.25237156504785063, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10303185743654597, 0.10303185743654597, 0.10303185743654597, 0.024975329711378835, 0.024975329711378835, 0.024975329711378835, 0.07972047324539488, 0.07972047324539488, 0.07972047324539488, 0.04151606845294609, 0.04151606845294609, 0.04151606845294609, 0.09841399210917312, 0.09841399210917312, 0.09841399210917312, 0.07420626520238216, 0.07420626520238216, 0.07420626520238216, 0.07242114214448025, 0.07242114214448025, 0.07242114214448025, 0.05021356345675154, 0.05021356345675154, 0.05021356345675154, 0.04729625539112947, 0.04729625539112947, 0.04729625539112947, 0.5247403760073024, 0.5247403760073024, 0.5247403760073024, 0.5254732170676452, 0.5254732170676452, 0.5254732170676452, 0.533296283016953, 0.533296283016953, 0.533296283016953, 0.11182999082037737, 0.11182999082037737, 0.11182999082037737, 0.16698479434185887, 0.16698479434185887, 0.16698479434185887, 0.1702438449324729, 0.1702438449324729, 0.1702438449324729, 0.15124317160761425, 0.15124317160761425, 0.15124317160761425, 0.17136281637610795, 0.17136281637610795, 0.17136281637610795, 0.15305409833800154, 0.15305409833800154, 0.15305409833800154, 0.4289292632588073, 0.4289292632588073, 0.4289292632588073, 0.3750164439526886, 0.3750164439526886, 0.3750164439526886, 0.45479519017394565, 0.45479519017394565, 0.45479519017394565, 0.1752721744137603, 0.1752721744137603, 0.1752721744137603, 0.1709440418819106, 0.1709440418819106, 0.1709440418819106, 0.3249144544740491, 0.3249144544740491, 0.3249144544740491, 0.20836914558731834, 0.20836914558731834, 0.20836914558731834, 0.20620797279564684, 0.20620797279564684, 0.20620797279564684, 0.2202405707369386, 0.2202405707369386, 0.2202405707369386, 0.20073942156209978, 0.20073942156209978, 0.20073942156209978, 0.5560900414392491, 0.5560900414392491, 0.5560900414392491, 0.19881251793653076, 0.19881251793653076, 0.19881251793653076, 0.8573798517101334, 0.8573798517101334, 0.8573798517101334, 0.7875819206246645, 0.7875819206246645, 0.7875819206246645, 0.18541178273883496, 0.18541178273883496, 0.18541178273883496, 0.1678552414465876, 0.1678552414465876, 0.1678552414465876, 0.604090578199991, 0.604090578199991, 0.604090578199991, 0.16598417278698818, 0.16598417278698818, 0.16598417278698818, 0.22264407952425702, 0.22264407952425702, 0.22264407952425702, 0.1993759210264019, 0.1993759210264019, 0.1993759210264019, 0.21213396258850215, 0.21213396258850215, 0.21213396258850215, 0.0898788234987602, 0.0898788234987602, 0.0898788234987602, 0.08654610583524047, 0.08654610583524047, 0.08654610583524047, 0.09520527491394148, 0.09520527491394148, 0.09520527491394148]}, "mutation_prompt": null}
{"id": "c555aa0a-4404-4dfc-989a-518e35d337e3", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a random inertia weight variation around its adaptive value to encourage diverse exploration and prevent premature convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "08d79927-d144-4cc2-a5a0-35b395ae3b32", "metadata": {"aucs": [0.7746800969399547, 0.7746800969399547, 0.7746800969399547, 0.7853801286106803, 0.7853801286106803, 0.7853801286106803, 0.8045342136442298, 0.8045342136442298, 0.8045342136442298, 0.5112258617734755, 0.5112258617734755, 0.5112258617734755, 0.5827691753406969, 0.5827691753406969, 0.5827691753406969, 0.0165875754164847, 0.0165875754164847, 0.0165875754164847, 0.13824639610431877, 0.13824639610431877, 0.13824639610431877, 0.12343150815305326, 0.12343150815305326, 0.12343150815305326, 0.14327718676959988, 0.14327718676959988, 0.14327718676959988, 0.10277716308937379, 0.10277716308937379, 0.10277716308937379, 0.09387920086898627, 0.09387920086898627, 0.09387920086898627, 0.15146555854800425, 0.15146555854800425, 0.15146555854800425, 0.9833545195335007, 0.9833545195335007, 0.9833545195335007, 0.9871312113475053, 0.9871312113475053, 0.9871312113475053, 0.9817455104503656, 0.9817455104503656, 0.9817455104503656, 0.5767357099827427, 0.5767357099827427, 0.5767357099827427, 0.5169121442607256, 0.5169121442607256, 0.5169121442607256, 0.6014842608374387, 0.6014842608374387, 0.6014842608374387, 0.7498310772428576, 0.7498310772428576, 0.7498310772428576, 0.16131966356215888, 0.16131966356215888, 0.16131966356215888, 0.22972192522828738, 0.22972192522828738, 0.22972192522828738, 0.20843491632644195, 0.20843491632644195, 0.20843491632644195, 0.127538956888941, 0.127538956888941, 0.127538956888941, 0.20043941549992983, 0.20043941549992983, 0.20043941549992983, 0.20043724790322381, 0.20043724790322381, 0.20043724790322381, 0.1980083372102206, 0.1980083372102206, 0.1980083372102206, 0.25237156504785063, 0.25237156504785063, 0.25237156504785063, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10303185743654597, 0.10303185743654597, 0.10303185743654597, 0.024975329711378835, 0.024975329711378835, 0.024975329711378835, 0.07972047324539488, 0.07972047324539488, 0.07972047324539488, 0.04151606845294609, 0.04151606845294609, 0.04151606845294609, 0.09841399210917312, 0.09841399210917312, 0.09841399210917312, 0.07420626520238216, 0.07420626520238216, 0.07420626520238216, 0.07242114214448025, 0.07242114214448025, 0.07242114214448025, 0.05021356345675154, 0.05021356345675154, 0.05021356345675154, 0.04729625539112947, 0.04729625539112947, 0.04729625539112947, 0.5247403760073024, 0.5247403760073024, 0.5247403760073024, 0.5254732170676452, 0.5254732170676452, 0.5254732170676452, 0.533296283016953, 0.533296283016953, 0.533296283016953, 0.11182999082037737, 0.11182999082037737, 0.11182999082037737, 0.16698479434185887, 0.16698479434185887, 0.16698479434185887, 0.1702438449324729, 0.1702438449324729, 0.1702438449324729, 0.15124317160761425, 0.15124317160761425, 0.15124317160761425, 0.17136281637610795, 0.17136281637610795, 0.17136281637610795, 0.15305409833800154, 0.15305409833800154, 0.15305409833800154, 0.4289292632588073, 0.4289292632588073, 0.4289292632588073, 0.3750164439526886, 0.3750164439526886, 0.3750164439526886, 0.45479519017394565, 0.45479519017394565, 0.45479519017394565, 0.1752721744137603, 0.1752721744137603, 0.1752721744137603, 0.1709440418819106, 0.1709440418819106, 0.1709440418819106, 0.3249144544740491, 0.3249144544740491, 0.3249144544740491, 0.20836914558731834, 0.20836914558731834, 0.20836914558731834, 0.20620797279564684, 0.20620797279564684, 0.20620797279564684, 0.2202405707369386, 0.2202405707369386, 0.2202405707369386, 0.20073942156209978, 0.20073942156209978, 0.20073942156209978, 0.5560900414392491, 0.5560900414392491, 0.5560900414392491, 0.19881251793653076, 0.19881251793653076, 0.19881251793653076, 0.8573798517101334, 0.8573798517101334, 0.8573798517101334, 0.7875819206246645, 0.7875819206246645, 0.7875819206246645, 0.18541178273883496, 0.18541178273883496, 0.18541178273883496, 0.1678552414465876, 0.1678552414465876, 0.1678552414465876, 0.604090578199991, 0.604090578199991, 0.604090578199991, 0.16598417278698818, 0.16598417278698818, 0.16598417278698818, 0.22264407952425702, 0.22264407952425702, 0.22264407952425702, 0.1993759210264019, 0.1993759210264019, 0.1993759210264019, 0.21213396258850215, 0.21213396258850215, 0.21213396258850215, 0.0898788234987602, 0.0898788234987602, 0.0898788234987602, 0.08654610583524047, 0.08654610583524047, 0.08654610583524047, 0.09520527491394148, 0.09520527491394148, 0.09520527491394148]}, "mutation_prompt": null}
{"id": "da0d324b-75bd-4301-9da8-0beef1d1c097", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a random inertia weight variation around its adaptive value to encourage diverse exploration and prevent premature convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "08d79927-d144-4cc2-a5a0-35b395ae3b32", "metadata": {"aucs": [0.7746800969399547, 0.7746800969399547, 0.7746800969399547, 0.7853801286106803, 0.7853801286106803, 0.7853801286106803, 0.8045342136442298, 0.8045342136442298, 0.8045342136442298, 0.5112258617734755, 0.5112258617734755, 0.5112258617734755, 0.5827691753406969, 0.5827691753406969, 0.5827691753406969, 0.0165875754164847, 0.0165875754164847, 0.0165875754164847, 0.13824639610431877, 0.13824639610431877, 0.13824639610431877, 0.12343150815305326, 0.12343150815305326, 0.12343150815305326, 0.14327718676959988, 0.14327718676959988, 0.14327718676959988, 0.10277716308937379, 0.10277716308937379, 0.10277716308937379, 0.09387920086898627, 0.09387920086898627, 0.09387920086898627, 0.15146555854800425, 0.15146555854800425, 0.15146555854800425, 0.9833545195335007, 0.9833545195335007, 0.9833545195335007, 0.9871312113475053, 0.9871312113475053, 0.9871312113475053, 0.9817455104503656, 0.9817455104503656, 0.9817455104503656, 0.5767357099827427, 0.5767357099827427, 0.5767357099827427, 0.5169121442607256, 0.5169121442607256, 0.5169121442607256, 0.6014842608374387, 0.6014842608374387, 0.6014842608374387, 0.7498310772428576, 0.7498310772428576, 0.7498310772428576, 0.16131966356215888, 0.16131966356215888, 0.16131966356215888, 0.22972192522828738, 0.22972192522828738, 0.22972192522828738, 0.20843491632644195, 0.20843491632644195, 0.20843491632644195, 0.127538956888941, 0.127538956888941, 0.127538956888941, 0.20043941549992983, 0.20043941549992983, 0.20043941549992983, 0.20043724790322381, 0.20043724790322381, 0.20043724790322381, 0.1980083372102206, 0.1980083372102206, 0.1980083372102206, 0.25237156504785063, 0.25237156504785063, 0.25237156504785063, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10303185743654597, 0.10303185743654597, 0.10303185743654597, 0.024975329711378835, 0.024975329711378835, 0.024975329711378835, 0.07972047324539488, 0.07972047324539488, 0.07972047324539488, 0.04151606845294609, 0.04151606845294609, 0.04151606845294609, 0.09841399210917312, 0.09841399210917312, 0.09841399210917312, 0.07420626520238216, 0.07420626520238216, 0.07420626520238216, 0.07242114214448025, 0.07242114214448025, 0.07242114214448025, 0.05021356345675154, 0.05021356345675154, 0.05021356345675154, 0.04729625539112947, 0.04729625539112947, 0.04729625539112947, 0.5247403760073024, 0.5247403760073024, 0.5247403760073024, 0.5254732170676452, 0.5254732170676452, 0.5254732170676452, 0.533296283016953, 0.533296283016953, 0.533296283016953, 0.11182999082037737, 0.11182999082037737, 0.11182999082037737, 0.16698479434185887, 0.16698479434185887, 0.16698479434185887, 0.1702438449324729, 0.1702438449324729, 0.1702438449324729, 0.15124317160761425, 0.15124317160761425, 0.15124317160761425, 0.17136281637610795, 0.17136281637610795, 0.17136281637610795, 0.15305409833800154, 0.15305409833800154, 0.15305409833800154, 0.4289292632588073, 0.4289292632588073, 0.4289292632588073, 0.3750164439526886, 0.3750164439526886, 0.3750164439526886, 0.45479519017394565, 0.45479519017394565, 0.45479519017394565, 0.1752721744137603, 0.1752721744137603, 0.1752721744137603, 0.1709440418819106, 0.1709440418819106, 0.1709440418819106, 0.3249144544740491, 0.3249144544740491, 0.3249144544740491, 0.20836914558731834, 0.20836914558731834, 0.20836914558731834, 0.20620797279564684, 0.20620797279564684, 0.20620797279564684, 0.2202405707369386, 0.2202405707369386, 0.2202405707369386, 0.20073942156209978, 0.20073942156209978, 0.20073942156209978, 0.5560900414392491, 0.5560900414392491, 0.5560900414392491, 0.19881251793653076, 0.19881251793653076, 0.19881251793653076, 0.8573798517101334, 0.8573798517101334, 0.8573798517101334, 0.7875819206246645, 0.7875819206246645, 0.7875819206246645, 0.18541178273883496, 0.18541178273883496, 0.18541178273883496, 0.1678552414465876, 0.1678552414465876, 0.1678552414465876, 0.604090578199991, 0.604090578199991, 0.604090578199991, 0.16598417278698818, 0.16598417278698818, 0.16598417278698818, 0.22264407952425702, 0.22264407952425702, 0.22264407952425702, 0.1993759210264019, 0.1993759210264019, 0.1993759210264019, 0.21213396258850215, 0.21213396258850215, 0.21213396258850215, 0.0898788234987602, 0.0898788234987602, 0.0898788234987602, 0.08654610583524047, 0.08654610583524047, 0.08654610583524047, 0.09520527491394148, 0.09520527491394148, 0.09520527491394148]}, "mutation_prompt": null}
{"id": "2d105ba6-9c20-403c-a41c-f127a41f16f8", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n        self.diversity_factor = 0.1  # New diversity factor for DE mutation\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with reduced random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.03, 0.03)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover with diversity enhancement\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                diversity_addition = self.diversity_factor * np.random.normal(size=self.dim)\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3]) + diversity_addition\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a diversity factor in the DE mutation process to enhance exploration capability without increasing the inertia's randomness.", "configspace": "", "generation": 16, "fitness": 0.2890820166996221, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "08d79927-d144-4cc2-a5a0-35b395ae3b32", "metadata": {"aucs": [0.7907222604577742, 0.7907222604577742, 0.7907222604577742, 0.8113416644283158, 0.8113416644283158, 0.8113416644283158, 0.8221005270013331, 0.8221005270013331, 0.8221005270013331, 0.3683656230997401, 0.3683656230997401, 0.3683656230997401, 0.5716242266300398, 0.5716242266300398, 0.5716242266300398, 0.37989383924054543, 0.37989383924054543, 0.37989383924054543, 0.11651250165042726, 0.11651250165042726, 0.11651250165042726, 0.07301363469103528, 0.07301363469103528, 0.07301363469103528, 0.272750831872412, 0.272750831872412, 0.272750831872412, 0.11825247408413941, 0.11825247408413941, 0.11825247408413941, 0.14534645453707906, 0.14534645453707906, 0.14534645453707906, 0.1310030806296254, 0.1310030806296254, 0.1310030806296254, 0.9769136607552241, 0.9769136607552241, 0.9769136607552241, 0.9868987408271714, 0.9868987408271714, 0.9868987408271714, 0.9888440180344739, 0.9888440180344739, 0.9888440180344739, 0.5152610224782525, 0.5152610224782525, 0.5152610224782525, 0.5994323532841613, 0.5994323532841613, 0.5994323532841613, 0.536813451974387, 0.536813451974387, 0.536813451974387, 0.36258988031782424, 0.36258988031782424, 0.36258988031782424, 0.18838954903220917, 0.18838954903220917, 0.18838954903220917, 0.22766693556204465, 0.22766693556204465, 0.22766693556204465, 0.18707248783173203, 0.18707248783173203, 0.18707248783173203, 0.12100522375583966, 0.12100522375583966, 0.12100522375583966, 0.12668093385584545, 0.12668093385584545, 0.12668093385584545, 0.11141634496946184, 0.11141634496946184, 0.11141634496946184, 0.12298490586851407, 0.12298490586851407, 0.12298490586851407, 0.18200374986626688, 0.18200374986626688, 0.18200374986626688, 0.0009108410026051894, 0.0009108410026051894, 0.0009108410026051894, 0.0016238470161308305, 0.0016238470161308305, 0.0016238470161308305, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.049879455500191794, 0.049879455500191794, 0.049879455500191794, 0.058357607144247425, 0.058357607144247425, 0.058357607144247425, 0.0216191175111502, 0.0216191175111502, 0.0216191175111502, 0.042972699952766424, 0.042972699952766424, 0.042972699952766424, 0.12279879686742456, 0.12279879686742456, 0.12279879686742456, 0.0854049505499217, 0.0854049505499217, 0.0854049505499217, 0.1774027983955453, 0.1774027983955453, 0.1774027983955453, 0.12620456284381476, 0.12620456284381476, 0.12620456284381476, 0.15414336280236074, 0.15414336280236074, 0.15414336280236074, 0.5035050295654024, 0.5035050295654024, 0.5035050295654024, 0.5026344204984925, 0.5026344204984925, 0.5026344204984925, 0.5256076414153226, 0.5256076414153226, 0.5256076414153226, 0.1387654517684398, 0.1387654517684398, 0.1387654517684398, 0.11360636684712533, 0.11360636684712533, 0.11360636684712533, 0.0941371011240737, 0.0941371011240737, 0.0941371011240737, 0.3115730552993161, 0.3115730552993161, 0.3115730552993161, 0.32481598153733104, 0.32481598153733104, 0.32481598153733104, 0.19297630786694442, 0.19297630786694442, 0.19297630786694442, 0.37928818400475517, 0.37928818400475517, 0.37928818400475517, 0.3985002399970453, 0.3985002399970453, 0.3985002399970453, 0.42707239610239245, 0.42707239610239245, 0.42707239610239245, 0.26665325696776243, 0.26665325696776243, 0.26665325696776243, 0.30980197455449665, 0.30980197455449665, 0.30980197455449665, 0.18626310979988836, 0.18626310979988836, 0.18626310979988836, 0.20365765255709378, 0.20365765255709378, 0.20365765255709378, 0.1977234591079846, 0.1977234591079846, 0.1977234591079846, 0.20506301424881135, 0.20506301424881135, 0.20506301424881135, 0.20297067573825556, 0.20297067573825556, 0.20297067573825556, 0.24146211999204648, 0.24146211999204648, 0.24146211999204648, 0.23793545803753624, 0.23793545803753624, 0.23793545803753624, 0.8502196842346064, 0.8502196842346064, 0.8502196842346064, 0.7681947122203481, 0.7681947122203481, 0.7681947122203481, 0.17636273649190515, 0.17636273649190515, 0.17636273649190515, 0.16747991225945302, 0.16747991225945302, 0.16747991225945302, 0.20449417340336162, 0.20449417340336162, 0.20449417340336162, 0.15572193417847124, 0.15572193417847124, 0.15572193417847124, 0.1858911229075748, 0.1858911229075748, 0.1858911229075748, 0.18971071715978505, 0.18971071715978505, 0.18971071715978505, 0.21243042371429488, 0.21243042371429488, 0.21243042371429488, 0.09061809882146332, 0.09061809882146332, 0.09061809882146332, 0.09647285529752703, 0.09647285529752703, 0.09647285529752703, 0.07597751833145028, 0.07597751833145028, 0.07597751833145028]}, "mutation_prompt": null}
{"id": "5aa7904a-9f3e-4a0d-9ad6-ede199bcac02", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n            # Dynamic DE scaling factor\n            self.F = 0.6 + 0.4 * (best_global_value / (best_global_value + 1e-9))\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a dynamic DE scaling factor based on convergence progress to enhance exploration and exploitation balance.", "configspace": "", "generation": 17, "fitness": 0.28258421220147206, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.27.", "error": "", "parent_id": "08d79927-d144-4cc2-a5a0-35b395ae3b32", "metadata": {"aucs": [0.79813946212144, 0.79813946212144, 0.79813946212144, 0.8046466844155287, 0.8046466844155287, 0.8046466844155287, 0.7950657082044816, 0.7950657082044816, 0.7950657082044816, 0.0, 0.0, 0.0, 0.034285005450386596, 0.034285005450386596, 0.034285005450386596, 0.5886575345578994, 0.5886575345578994, 0.5886575345578994, 0.12182976289603253, 0.12182976289603253, 0.12182976289603253, 0.06210937084509116, 0.06210937084509116, 0.06210937084509116, 0.1430042105937671, 0.1430042105937671, 0.1430042105937671, 0.12403434510054501, 0.12403434510054501, 0.12403434510054501, 0.10414207510945495, 0.10414207510945495, 0.10414207510945495, 0.13562409990887647, 0.13562409990887647, 0.13562409990887647, 0.9833244574647613, 0.9833244574647613, 0.9833244574647613, 0.9892048875575908, 0.9892048875575908, 0.9892048875575908, 0.9853541872060392, 0.9853541872060392, 0.9853541872060392, 0.6175572378507258, 0.6175572378507258, 0.6175572378507258, 0.5145197091880319, 0.5145197091880319, 0.5145197091880319, 0.5725438867950274, 0.5725438867950274, 0.5725438867950274, 0.7231815006894311, 0.7231815006894311, 0.7231815006894311, 0.16013811707946257, 0.16013811707946257, 0.16013811707946257, 0.6813477421259024, 0.6813477421259024, 0.6813477421259024, 0.1873308715150872, 0.1873308715150872, 0.1873308715150872, 0.11939754187848628, 0.11939754187848628, 0.11939754187848628, 0.1926645796641283, 0.1926645796641283, 0.1926645796641283, 0.19322508173766317, 0.19322508173766317, 0.19322508173766317, 0.21018585042375493, 0.21018585042375493, 0.21018585042375493, 0.20672931541985873, 0.20672931541985873, 0.20672931541985873, 0.007187050310800025, 0.007187050310800025, 0.007187050310800025, 0.004724623709811748, 0.004724623709811748, 0.004724623709811748, 0.0, 0.0, 0.0, 0.1065915476589695, 0.1065915476589695, 0.1065915476589695, 0.016533626190663342, 0.016533626190663342, 0.016533626190663342, 0.03397478959783762, 0.03397478959783762, 0.03397478959783762, 0.04422238348276808, 0.04422238348276808, 0.04422238348276808, 0.08929782384178486, 0.08929782384178486, 0.08929782384178486, 0.0810376543032788, 0.0810376543032788, 0.0810376543032788, 0.009619482273653723, 0.009619482273653723, 0.009619482273653723, 0.0367089895258057, 0.0367089895258057, 0.0367089895258057, 0.07945341713138221, 0.07945341713138221, 0.07945341713138221, 0.5156493408189491, 0.5156493408189491, 0.5156493408189491, 0.5192477335084624, 0.5192477335084624, 0.5192477335084624, 0.5316702899441652, 0.5316702899441652, 0.5316702899441652, 0.12273227570294709, 0.12273227570294709, 0.12273227570294709, 0.10640278803833281, 0.10640278803833281, 0.10640278803833281, 0.12529469552287187, 0.12529469552287187, 0.12529469552287187, 0.23406106843433938, 0.23406106843433938, 0.23406106843433938, 0.2664327562669492, 0.2664327562669492, 0.2664327562669492, 0.19917698949370322, 0.19917698949370322, 0.19917698949370322, 0.4195520689790887, 0.4195520689790887, 0.4195520689790887, 0.20391042359184175, 0.20391042359184175, 0.20391042359184175, 0.27164646304459517, 0.27164646304459517, 0.27164646304459517, 0.30271600702234214, 0.30271600702234214, 0.30271600702234214, 0.23682781703440303, 0.23682781703440303, 0.23682781703440303, 0.137818414029104, 0.137818414029104, 0.137818414029104, 0.1975791449195532, 0.1975791449195532, 0.1975791449195532, 0.24028096220110862, 0.24028096220110862, 0.24028096220110862, 0.2031900519540798, 0.2031900519540798, 0.2031900519540798, 0.23665498385932038, 0.23665498385932038, 0.23665498385932038, 0.1943329704767024, 0.1943329704767024, 0.1943329704767024, 0.6764165813031393, 0.6764165813031393, 0.6764165813031393, 0.8492304434306642, 0.8492304434306642, 0.8492304434306642, 0.15777676146216402, 0.15777676146216402, 0.15777676146216402, 0.19185999252306396, 0.19185999252306396, 0.19185999252306396, 0.43698616766476317, 0.43698616766476317, 0.43698616766476317, 0.20884598194622217, 0.20884598194622217, 0.20884598194622217, 0.15606318672016772, 0.15606318672016772, 0.15606318672016772, 0.19458964446071692, 0.19458964446071692, 0.19458964446071692, 0.18350166729744766, 0.18350166729744766, 0.18350166729744766, 0.18415181605350284, 0.18415181605350284, 0.18415181605350284, 0.09555979089443722, 0.09555979089443722, 0.09555979089443722, 0.08989139166677174, 0.08989139166677174, 0.08989139166677174, 0.09841799441386101, 0.09841799441386101, 0.09841799441386101]}, "mutation_prompt": null}
{"id": "bca96504-55e9-4c7a-a8f0-913e5e519557", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n            \n            # Time-varying DE scaling factor\n            self.F = 0.6 + (0.9 - 0.6) * (1 - eval_count / self.budget)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a time-varying DE scaling factor for dynamic balance between exploration and exploitation.", "configspace": "", "generation": 18, "fitness": 0.2649598393609916, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.25.", "error": "", "parent_id": "08d79927-d144-4cc2-a5a0-35b395ae3b32", "metadata": {"aucs": [0.7815411050861952, 0.7815411050861952, 0.7815411050861952, 0.7911214401749449, 0.7911214401749449, 0.7911214401749449, 0.8118227933259158, 0.8118227933259158, 0.8118227933259158, 0.4769302379196675, 0.4769302379196675, 0.4769302379196675, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04665140121523548, 0.04665140121523548, 0.04665140121523548, 0.17361476920575003, 0.17361476920575003, 0.17361476920575003, 0.12706269266645454, 0.12706269266645454, 0.12706269266645454, 0.11031386195805648, 0.11031386195805648, 0.11031386195805648, 0.10023469394563966, 0.10023469394563966, 0.10023469394563966, 0.12966931678111537, 0.12966931678111537, 0.12966931678111537, 0.10498582157533654, 0.10498582157533654, 0.10498582157533654, 0.9827370749747207, 0.9827370749747207, 0.9827370749747207, 0.9871398977237344, 0.9871398977237344, 0.9871398977237344, 0.9829296236670146, 0.9829296236670146, 0.9829296236670146, 0.6097936463070097, 0.6097936463070097, 0.6097936463070097, 0.4847660234029355, 0.4847660234029355, 0.4847660234029355, 0.5972201489482157, 0.5972201489482157, 0.5972201489482157, 0.21773181306904243, 0.21773181306904243, 0.21773181306904243, 0.16046869236878625, 0.16046869236878625, 0.16046869236878625, 0.17614414313425275, 0.17614414313425275, 0.17614414313425275, 0.20794652704489514, 0.20794652704489514, 0.20794652704489514, 0.12282322993282013, 0.12282322993282013, 0.12282322993282013, 0.20588507704510073, 0.20588507704510073, 0.20588507704510073, 0.18413631229858352, 0.18413631229858352, 0.18413631229858352, 0.1739813784655766, 0.1739813784655766, 0.1739813784655766, 0.12842059628378788, 0.12842059628378788, 0.12842059628378788, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11285313163438437, 0.11285313163438437, 0.11285313163438437, 0.025042896153623984, 0.025042896153623984, 0.025042896153623984, 0.10214651087695581, 0.10214651087695581, 0.10214651087695581, 0.042710312157376196, 0.042710312157376196, 0.042710312157376196, 0.14996472729750554, 0.14996472729750554, 0.14996472729750554, 0.06317923006677606, 0.06317923006677606, 0.06317923006677606, 0.06625185349649054, 0.06625185349649054, 0.06625185349649054, 0.035968638792920005, 0.035968638792920005, 0.035968638792920005, 0.04726355114382841, 0.04726355114382841, 0.04726355114382841, 0.5287122151642636, 0.5287122151642636, 0.5287122151642636, 0.18164086335796958, 0.18164086335796958, 0.18164086335796958, 0.5147414410092422, 0.5147414410092422, 0.5147414410092422, 0.09886477954200712, 0.09886477954200712, 0.09886477954200712, 0.09602623133847632, 0.09602623133847632, 0.09602623133847632, 0.09012512624298119, 0.09012512624298119, 0.09012512624298119, 0.20585743924163435, 0.20585743924163435, 0.20585743924163435, 0.351743065041367, 0.351743065041367, 0.351743065041367, 0.14545010016700777, 0.14545010016700777, 0.14545010016700777, 0.4348753064900258, 0.4348753064900258, 0.4348753064900258, 0.4449217127472921, 0.4449217127472921, 0.4449217127472921, 0.511497600349168, 0.511497600349168, 0.511497600349168, 0.41672816449773453, 0.41672816449773453, 0.41672816449773453, 0.16211862131078503, 0.16211862131078503, 0.16211862131078503, 0.13079207131838466, 0.13079207131838466, 0.13079207131838466, 0.2141705747688052, 0.2141705747688052, 0.2141705747688052, 0.20112049845056168, 0.20112049845056168, 0.20112049845056168, 0.24736173318859744, 0.24736173318859744, 0.24736173318859744, 0.644792378265741, 0.644792378265741, 0.644792378265741, 0.673269968972203, 0.673269968972203, 0.673269968972203, 0.23274444785116954, 0.23274444785116954, 0.23274444785116954, 0.2556070712414127, 0.2556070712414127, 0.2556070712414127, 0.2059121192685699, 0.2059121192685699, 0.2059121192685699, 0.18528314809634527, 0.18528314809634527, 0.18528314809634527, 0.16916270884478068, 0.16916270884478068, 0.16916270884478068, 0.20658268776859234, 0.20658268776859234, 0.20658268776859234, 0.15531540421048906, 0.15531540421048906, 0.15531540421048906, 0.18193848034368032, 0.18193848034368032, 0.18193848034368032, 0.21255339055623212, 0.21255339055623212, 0.21255339055623212, 0.19196473325060592, 0.19196473325060592, 0.19196473325060592, 0.09909907388694994, 0.09909907388694994, 0.09909907388694994, 0.08660264803495588, 0.08660264803495588, 0.08660264803495588, 0.07767945903271689, 0.07767945903271689, 0.07767945903271689]}, "mutation_prompt": null}
{"id": "f1822e6d-10f6-4d7a-8263-8c90ffb76487", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a random inertia weight variation around its adaptive value to encourage diverse exploration and prevent premature convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "08d79927-d144-4cc2-a5a0-35b395ae3b32", "metadata": {"aucs": [0.7746800969399547, 0.7746800969399547, 0.7746800969399547, 0.7853801286106803, 0.7853801286106803, 0.7853801286106803, 0.8045342136442298, 0.8045342136442298, 0.8045342136442298, 0.5112258617734755, 0.5112258617734755, 0.5112258617734755, 0.5827691753406969, 0.5827691753406969, 0.5827691753406969, 0.0165875754164847, 0.0165875754164847, 0.0165875754164847, 0.13824639610431877, 0.13824639610431877, 0.13824639610431877, 0.12343150815305326, 0.12343150815305326, 0.12343150815305326, 0.14327718676959988, 0.14327718676959988, 0.14327718676959988, 0.10277716308937379, 0.10277716308937379, 0.10277716308937379, 0.09387920086898627, 0.09387920086898627, 0.09387920086898627, 0.15146555854800425, 0.15146555854800425, 0.15146555854800425, 0.9833545195335007, 0.9833545195335007, 0.9833545195335007, 0.9871312113475053, 0.9871312113475053, 0.9871312113475053, 0.9817455104503656, 0.9817455104503656, 0.9817455104503656, 0.5767357099827427, 0.5767357099827427, 0.5767357099827427, 0.5169121442607256, 0.5169121442607256, 0.5169121442607256, 0.6014842608374387, 0.6014842608374387, 0.6014842608374387, 0.7498310772428576, 0.7498310772428576, 0.7498310772428576, 0.16131966356215888, 0.16131966356215888, 0.16131966356215888, 0.22972192522828738, 0.22972192522828738, 0.22972192522828738, 0.20843491632644195, 0.20843491632644195, 0.20843491632644195, 0.127538956888941, 0.127538956888941, 0.127538956888941, 0.20043941549992983, 0.20043941549992983, 0.20043941549992983, 0.20043724790322381, 0.20043724790322381, 0.20043724790322381, 0.1980083372102206, 0.1980083372102206, 0.1980083372102206, 0.25237156504785063, 0.25237156504785063, 0.25237156504785063, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10303185743654597, 0.10303185743654597, 0.10303185743654597, 0.024975329711378835, 0.024975329711378835, 0.024975329711378835, 0.07972047324539488, 0.07972047324539488, 0.07972047324539488, 0.04151606845294609, 0.04151606845294609, 0.04151606845294609, 0.09841399210917312, 0.09841399210917312, 0.09841399210917312, 0.07420626520238216, 0.07420626520238216, 0.07420626520238216, 0.07242114214448025, 0.07242114214448025, 0.07242114214448025, 0.05021356345675154, 0.05021356345675154, 0.05021356345675154, 0.04729625539112947, 0.04729625539112947, 0.04729625539112947, 0.5247403760073024, 0.5247403760073024, 0.5247403760073024, 0.5254732170676452, 0.5254732170676452, 0.5254732170676452, 0.533296283016953, 0.533296283016953, 0.533296283016953, 0.11182999082037737, 0.11182999082037737, 0.11182999082037737, 0.16698479434185887, 0.16698479434185887, 0.16698479434185887, 0.1702438449324729, 0.1702438449324729, 0.1702438449324729, 0.15124317160761425, 0.15124317160761425, 0.15124317160761425, 0.17136281637610795, 0.17136281637610795, 0.17136281637610795, 0.15305409833800154, 0.15305409833800154, 0.15305409833800154, 0.4289292632588073, 0.4289292632588073, 0.4289292632588073, 0.3750164439526886, 0.3750164439526886, 0.3750164439526886, 0.45479519017394565, 0.45479519017394565, 0.45479519017394565, 0.1752721744137603, 0.1752721744137603, 0.1752721744137603, 0.1709440418819106, 0.1709440418819106, 0.1709440418819106, 0.3249144544740491, 0.3249144544740491, 0.3249144544740491, 0.20836914558731834, 0.20836914558731834, 0.20836914558731834, 0.20620797279564684, 0.20620797279564684, 0.20620797279564684, 0.2202405707369386, 0.2202405707369386, 0.2202405707369386, 0.20073942156209978, 0.20073942156209978, 0.20073942156209978, 0.5560900414392491, 0.5560900414392491, 0.5560900414392491, 0.19881251793653076, 0.19881251793653076, 0.19881251793653076, 0.8573798517101334, 0.8573798517101334, 0.8573798517101334, 0.7875819206246645, 0.7875819206246645, 0.7875819206246645, 0.18541178273883496, 0.18541178273883496, 0.18541178273883496, 0.1678552414465876, 0.1678552414465876, 0.1678552414465876, 0.604090578199991, 0.604090578199991, 0.604090578199991, 0.16598417278698818, 0.16598417278698818, 0.16598417278698818, 0.22264407952425702, 0.22264407952425702, 0.22264407952425702, 0.1993759210264019, 0.1993759210264019, 0.1993759210264019, 0.21213396258850215, 0.21213396258850215, 0.21213396258850215, 0.0898788234987602, 0.0898788234987602, 0.0898788234987602, 0.08654610583524047, 0.08654610583524047, 0.08654610583524047, 0.09520527491394148, 0.09520527491394148, 0.09520527491394148]}, "mutation_prompt": null}
{"id": "0f587276-2322-4e69-ba17-dc4e2adba050", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a random inertia weight variation around its adaptive value to encourage diverse exploration and prevent premature convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "08d79927-d144-4cc2-a5a0-35b395ae3b32", "metadata": {"aucs": [0.7746800969399547, 0.7746800969399547, 0.7746800969399547, 0.7853801286106803, 0.7853801286106803, 0.7853801286106803, 0.8045342136442298, 0.8045342136442298, 0.8045342136442298, 0.5112258617734755, 0.5112258617734755, 0.5112258617734755, 0.5827691753406969, 0.5827691753406969, 0.5827691753406969, 0.0165875754164847, 0.0165875754164847, 0.0165875754164847, 0.13824639610431877, 0.13824639610431877, 0.13824639610431877, 0.12343150815305326, 0.12343150815305326, 0.12343150815305326, 0.14327718676959988, 0.14327718676959988, 0.14327718676959988, 0.10277716308937379, 0.10277716308937379, 0.10277716308937379, 0.09387920086898627, 0.09387920086898627, 0.09387920086898627, 0.15146555854800425, 0.15146555854800425, 0.15146555854800425, 0.9833545195335007, 0.9833545195335007, 0.9833545195335007, 0.9871312113475053, 0.9871312113475053, 0.9871312113475053, 0.9817455104503656, 0.9817455104503656, 0.9817455104503656, 0.5767357099827427, 0.5767357099827427, 0.5767357099827427, 0.5169121442607256, 0.5169121442607256, 0.5169121442607256, 0.6014842608374387, 0.6014842608374387, 0.6014842608374387, 0.7498310772428576, 0.7498310772428576, 0.7498310772428576, 0.16131966356215888, 0.16131966356215888, 0.16131966356215888, 0.22972192522828738, 0.22972192522828738, 0.22972192522828738, 0.20843491632644195, 0.20843491632644195, 0.20843491632644195, 0.127538956888941, 0.127538956888941, 0.127538956888941, 0.20043941549992983, 0.20043941549992983, 0.20043941549992983, 0.20043724790322381, 0.20043724790322381, 0.20043724790322381, 0.1980083372102206, 0.1980083372102206, 0.1980083372102206, 0.25237156504785063, 0.25237156504785063, 0.25237156504785063, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10303185743654597, 0.10303185743654597, 0.10303185743654597, 0.024975329711378835, 0.024975329711378835, 0.024975329711378835, 0.07972047324539488, 0.07972047324539488, 0.07972047324539488, 0.04151606845294609, 0.04151606845294609, 0.04151606845294609, 0.09841399210917312, 0.09841399210917312, 0.09841399210917312, 0.07420626520238216, 0.07420626520238216, 0.07420626520238216, 0.07242114214448025, 0.07242114214448025, 0.07242114214448025, 0.05021356345675154, 0.05021356345675154, 0.05021356345675154, 0.04729625539112947, 0.04729625539112947, 0.04729625539112947, 0.5247403760073024, 0.5247403760073024, 0.5247403760073024, 0.5254732170676452, 0.5254732170676452, 0.5254732170676452, 0.533296283016953, 0.533296283016953, 0.533296283016953, 0.11182999082037737, 0.11182999082037737, 0.11182999082037737, 0.16698479434185887, 0.16698479434185887, 0.16698479434185887, 0.1702438449324729, 0.1702438449324729, 0.1702438449324729, 0.15124317160761425, 0.15124317160761425, 0.15124317160761425, 0.17136281637610795, 0.17136281637610795, 0.17136281637610795, 0.15305409833800154, 0.15305409833800154, 0.15305409833800154, 0.4289292632588073, 0.4289292632588073, 0.4289292632588073, 0.3750164439526886, 0.3750164439526886, 0.3750164439526886, 0.45479519017394565, 0.45479519017394565, 0.45479519017394565, 0.1752721744137603, 0.1752721744137603, 0.1752721744137603, 0.1709440418819106, 0.1709440418819106, 0.1709440418819106, 0.3249144544740491, 0.3249144544740491, 0.3249144544740491, 0.20836914558731834, 0.20836914558731834, 0.20836914558731834, 0.20620797279564684, 0.20620797279564684, 0.20620797279564684, 0.2202405707369386, 0.2202405707369386, 0.2202405707369386, 0.20073942156209978, 0.20073942156209978, 0.20073942156209978, 0.5560900414392491, 0.5560900414392491, 0.5560900414392491, 0.19881251793653076, 0.19881251793653076, 0.19881251793653076, 0.8573798517101334, 0.8573798517101334, 0.8573798517101334, 0.7875819206246645, 0.7875819206246645, 0.7875819206246645, 0.18541178273883496, 0.18541178273883496, 0.18541178273883496, 0.1678552414465876, 0.1678552414465876, 0.1678552414465876, 0.604090578199991, 0.604090578199991, 0.604090578199991, 0.16598417278698818, 0.16598417278698818, 0.16598417278698818, 0.22264407952425702, 0.22264407952425702, 0.22264407952425702, 0.1993759210264019, 0.1993759210264019, 0.1993759210264019, 0.21213396258850215, 0.21213396258850215, 0.21213396258850215, 0.0898788234987602, 0.0898788234987602, 0.0898788234987602, 0.08654610583524047, 0.08654610583524047, 0.08654610583524047, 0.09520527491394148, 0.09520527491394148, 0.09520527491394148]}, "mutation_prompt": null}
{"id": "c42ea972-09c2-4a40-af98-e73e2d20d7dd", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n        self.local_search_prob = 0.05\n\n    def local_search(self, candidate, func):\n        perturbation = np.random.normal(0, 0.1, self.dim)\n        new_candidate = np.clip(candidate + perturbation, self.bounds[0], self.bounds[1])\n        return new_candidate, func(new_candidate)\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n            \n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n                if np.random.rand() < self.local_search_prob:\n                    new_candidate, new_value = self.local_search(pop[i], func)\n                    eval_count += 1\n                    if new_value < personal_best_values[i]:\n                        personal_best_values[i] = new_value\n                        personal_best[i] = new_candidate.copy()\n                    \n                    if new_value < best_global_value:\n                        best_global_value = new_value\n                        best_global_position = new_candidate.copy()\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce an adaptive local neighborhood search step to further enhance the exploration capabilities while maintaining the original DE and PSO dynamics.", "configspace": "", "generation": 21, "fitness": 0.2744599685297602, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "08d79927-d144-4cc2-a5a0-35b395ae3b32", "metadata": {"aucs": [0.7971882265876749, 0.7971882265876749, 0.7971882265876749, 0.7159186966839463, 0.7159186966839463, 0.7159186966839463, 0.8047614692078413, 0.8047614692078413, 0.8047614692078413, 0.41245846555439836, 0.41245846555439836, 0.41245846555439836, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.4916004564614266, 0.4916004564614266, 0.4916004564614266, 0.12848161575912764, 0.12848161575912764, 0.12848161575912764, 0.41484901091830584, 0.41484901091830584, 0.41484901091830584, 0.14619320608098674, 0.14619320608098674, 0.14619320608098674, 0.13670235560560562, 0.13670235560560562, 0.13670235560560562, 0.12645222513696974, 0.12645222513696974, 0.12645222513696974, 0.1485599041603629, 0.1485599041603629, 0.1485599041603629, 0.9848290783133251, 0.9848290783133251, 0.9848290783133251, 0.9823731520153878, 0.9823731520153878, 0.9823731520153878, 0.9825567830201033, 0.9825567830201033, 0.9825567830201033, 0.569885333130833, 0.569885333130833, 0.569885333130833, 0.49172482773693305, 0.49172482773693305, 0.49172482773693305, 0.5617280329989458, 0.5617280329989458, 0.5617280329989458, 0.34731724943262066, 0.34731724943262066, 0.34731724943262066, 0.1605907257925674, 0.1605907257925674, 0.1605907257925674, 0.11553242789257512, 0.11553242789257512, 0.11553242789257512, 0.20086629056467709, 0.20086629056467709, 0.20086629056467709, 0.12043996452994399, 0.12043996452994399, 0.12043996452994399, 0.19187507487702393, 0.19187507487702393, 0.19187507487702393, 0.2032815207934302, 0.2032815207934302, 0.2032815207934302, 0.21479952200362928, 0.21479952200362928, 0.21479952200362928, 0.22641534224742232, 0.22641534224742232, 0.22641534224742232, 0.004130589534848461, 0.004130589534848461, 0.004130589534848461, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08415465999107652, 0.08415465999107652, 0.08415465999107652, 0.06659837580206762, 0.06659837580206762, 0.06659837580206762, 0.012928231822130543, 0.012928231822130543, 0.012928231822130543, 0.044381206909976156, 0.044381206909976156, 0.044381206909976156, 0.08428939526652157, 0.08428939526652157, 0.08428939526652157, 0.15154200491647485, 0.15154200491647485, 0.15154200491647485, 0.18514654736495773, 0.18514654736495773, 0.18514654736495773, 0.11888140558071425, 0.11888140558071425, 0.11888140558071425, 0.07517738299110466, 0.07517738299110466, 0.07517738299110466, 0.5075665609122075, 0.5075665609122075, 0.5075665609122075, 0.5810417692715861, 0.5810417692715861, 0.5810417692715861, 0.5399993055219274, 0.5399993055219274, 0.5399993055219274, 0.1572883892744671, 0.1572883892744671, 0.1572883892744671, 0.12543897807108983, 0.12543897807108983, 0.12543897807108983, 0.14610727325741424, 0.14610727325741424, 0.14610727325741424, 0.16287936904204947, 0.16287936904204947, 0.16287936904204947, 0.2162529520228863, 0.2162529520228863, 0.2162529520228863, 0.1654531502183365, 0.1654531502183365, 0.1654531502183365, 0.32800691815698557, 0.32800691815698557, 0.32800691815698557, 0.39784614391628037, 0.39784614391628037, 0.39784614391628037, 0.46786581692465845, 0.46786581692465845, 0.46786581692465845, 0.209964822426137, 0.209964822426137, 0.209964822426137, 0.18411808967371202, 0.18411808967371202, 0.18411808967371202, 0.24073487357572143, 0.24073487357572143, 0.24073487357572143, 0.21958352109655854, 0.21958352109655854, 0.21958352109655854, 0.22164078415794752, 0.22164078415794752, 0.22164078415794752, 0.2399955142355007, 0.2399955142355007, 0.2399955142355007, 0.19511604901257928, 0.19511604901257928, 0.19511604901257928, 0.20388422361196745, 0.20388422361196745, 0.20388422361196745, 0.1934877436416207, 0.1934877436416207, 0.1934877436416207, 0.8660868578935801, 0.8660868578935801, 0.8660868578935801, 0.1568574798244039, 0.1568574798244039, 0.1568574798244039, 0.18718506077756514, 0.18718506077756514, 0.18718506077756514, 0.16715157937080694, 0.16715157937080694, 0.16715157937080694, 0.1659436000765221, 0.1659436000765221, 0.1659436000765221, 0.15517563852939165, 0.15517563852939165, 0.15517563852939165, 0.18826388744813016, 0.18826388744813016, 0.18826388744813016, 0.2061864680356833, 0.2061864680356833, 0.2061864680356833, 0.2052054822539695, 0.2052054822539695, 0.2052054822539695, 0.08103682434652915, 0.08103682434652915, 0.08103682434652915, 0.08629880404055623, 0.08629880404055623, 0.08629880404055623, 0.08654304583802441, 0.08654304583802441, 0.08654304583802441]}, "mutation_prompt": null}
{"id": "52924d90-8e59-4171-9941-16f2a4f9d3f2", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n            adaptive_F = 0.5 + 0.3 * np.sin(0.5 * np.pi * eval_count / self.budget)\n            adaptive_CR = 0.8 + 0.15 * np.cos(0.5 * np.pi * eval_count / self.budget)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover with adaptive parameters\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + adaptive_F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < adaptive_CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introducing adaptive learning rates for DE and PSO components to dynamically balance exploration and exploitation.", "configspace": "", "generation": 22, "fitness": 0.27037666580711467, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.25.", "error": "", "parent_id": "08d79927-d144-4cc2-a5a0-35b395ae3b32", "metadata": {"aucs": [0.7870258236050741, 0.7870258236050741, 0.7870258236050741, 0.778594637357039, 0.778594637357039, 0.778594637357039, 0.8019397698827953, 0.8019397698827953, 0.8019397698827953, 0.566150908815144, 0.566150908815144, 0.566150908815144, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.4881956148435874, 0.4881956148435874, 0.4881956148435874, 0.14998278439143575, 0.14998278439143575, 0.14998278439143575, 0.07187163246773853, 0.07187163246773853, 0.07187163246773853, 0.14353102090741832, 0.14353102090741832, 0.14353102090741832, 0.13837480059747764, 0.13837480059747764, 0.13837480059747764, 0.11666838752110376, 0.11666838752110376, 0.11666838752110376, 0.1355027576231318, 0.1355027576231318, 0.1355027576231318, 0.9831172866491461, 0.9831172866491461, 0.9831172866491461, 0.9832235477409114, 0.9832235477409114, 0.9832235477409114, 0.9822504087688257, 0.9822504087688257, 0.9822504087688257, 0.606881320701155, 0.606881320701155, 0.606881320701155, 0.5567458444583344, 0.5567458444583344, 0.5567458444583344, 0.5806201561776956, 0.5806201561776956, 0.5806201561776956, 0.7000075052722603, 0.7000075052722603, 0.7000075052722603, 0.16068301768476545, 0.16068301768476545, 0.16068301768476545, 0.21998635064344285, 0.21998635064344285, 0.21998635064344285, 0.20987145958248932, 0.20987145958248932, 0.20987145958248932, 0.19991620482356098, 0.19991620482356098, 0.19991620482356098, 0.19962867217939495, 0.19962867217939495, 0.19962867217939495, 0.2880311943310532, 0.2880311943310532, 0.2880311943310532, 0.24678531553735916, 0.24678531553735916, 0.24678531553735916, 0.21925302769245258, 0.21925302769245258, 0.21925302769245258, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.038533584116613784, 0.038533584116613784, 0.038533584116613784, 0.04562104256649413, 0.04562104256649413, 0.04562104256649413, 0.11206615743493653, 0.11206615743493653, 0.11206615743493653, 0.06535521835140878, 0.06535521835140878, 0.06535521835140878, 0.08034857371678827, 0.08034857371678827, 0.08034857371678827, 0.08807917047911229, 0.08807917047911229, 0.08807917047911229, 0.009990334438019666, 0.009990334438019666, 0.009990334438019666, 0.03729563145193149, 0.03729563145193149, 0.03729563145193149, 0.04674090942239184, 0.04674090942239184, 0.04674090942239184, 0.5413261630634925, 0.5413261630634925, 0.5413261630634925, 0.518040681333285, 0.518040681333285, 0.518040681333285, 0.5289233182316881, 0.5289233182316881, 0.5289233182316881, 0.062407475208337226, 0.062407475208337226, 0.062407475208337226, 0.1268030793229704, 0.1268030793229704, 0.1268030793229704, 0.06678708901532793, 0.06678708901532793, 0.06678708901532793, 0.19713026687122404, 0.19713026687122404, 0.19713026687122404, 0.24033502638947724, 0.24033502638947724, 0.24033502638947724, 0.27078137987071305, 0.27078137987071305, 0.27078137987071305, 0.35913764564713946, 0.35913764564713946, 0.35913764564713946, 0.20573776769180918, 0.20573776769180918, 0.20573776769180918, 0.20208328565940714, 0.20208328565940714, 0.20208328565940714, 0.23676080114613474, 0.23676080114613474, 0.23676080114613474, 0.23044198116880743, 0.23044198116880743, 0.23044198116880743, 0.13496107438125815, 0.13496107438125815, 0.13496107438125815, 0.1981695249425357, 0.1981695249425357, 0.1981695249425357, 0.209803740891655, 0.209803740891655, 0.209803740891655, 0.2170951083490429, 0.2170951083490429, 0.2170951083490429, 0.18617404424397022, 0.18617404424397022, 0.18617404424397022, 0.1868691153993347, 0.1868691153993347, 0.1868691153993347, 0.21190939900143646, 0.21190939900143646, 0.21190939900143646, 0.835739218760693, 0.835739218760693, 0.835739218760693, 0.15726991069547003, 0.15726991069547003, 0.15726991069547003, 0.16330089559969097, 0.16330089559969097, 0.16330089559969097, 0.16045454295110828, 0.16045454295110828, 0.16045454295110828, 0.16893416609960732, 0.16893416609960732, 0.16893416609960732, 0.15481337597814981, 0.15481337597814981, 0.15481337597814981, 0.1927144829223727, 0.1927144829223727, 0.1927144829223727, 0.20576519214023514, 0.20576519214023514, 0.20576519214023514, 0.18466234573066287, 0.18466234573066287, 0.18466234573066287, 0.08643726996984769, 0.08643726996984769, 0.08643726996984769, 0.09228830206386907, 0.09228830206386907, 0.09228830206386907, 0.09379219513901804, 0.09379219513901804, 0.09379219513901804]}, "mutation_prompt": null}
{"id": "95fc6823-60f4-406a-870b-38bc843f37cf", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Adaptive DE scaling factor based on convergence\n            convergence_rate = eval_count / self.budget\n            self.F = 0.5 + 0.3 * (1 - convergence_rate)\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce adaptive DE scaling factor variation based on convergence speed for improved exploration-exploitation balance.", "configspace": "", "generation": 23, "fitness": 0.2755074382688568, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.25.", "error": "", "parent_id": "08d79927-d144-4cc2-a5a0-35b395ae3b32", "metadata": {"aucs": [0.7744372800666677, 0.7744372800666677, 0.7744372800666677, 0.7884261988464306, 0.7884261988464306, 0.7884261988464306, 0.7966366320804604, 0.7966366320804604, 0.7966366320804604, 0.4705267080211225, 0.4705267080211225, 0.4705267080211225, 0.5670910856573048, 0.5670910856573048, 0.5670910856573048, 0.01664349669594667, 0.01664349669594667, 0.01664349669594667, 0.15654482236316902, 0.15654482236316902, 0.15654482236316902, 0.1326446086851898, 0.1326446086851898, 0.1326446086851898, 0.15105579997609908, 0.15105579997609908, 0.15105579997609908, 0.12992436236510807, 0.12992436236510807, 0.12992436236510807, 0.1140770226524146, 0.1140770226524146, 0.1140770226524146, 0.10218849135919827, 0.10218849135919827, 0.10218849135919827, 0.9833541204063894, 0.9833541204063894, 0.9833541204063894, 0.9871306837821138, 0.9871306837821138, 0.9871306837821138, 0.9817437932635988, 0.9817437932635988, 0.9817437932635988, 0.5934151133209686, 0.5934151133209686, 0.5934151133209686, 0.611427977673963, 0.611427977673963, 0.611427977673963, 0.5984329451819594, 0.5984329451819594, 0.5984329451819594, 0.3651714073172003, 0.3651714073172003, 0.3651714073172003, 0.16130529872264032, 0.16130529872264032, 0.16130529872264032, 0.22955524649444237, 0.22955524649444237, 0.22955524649444237, 0.20054822609430933, 0.20054822609430933, 0.20054822609430933, 0.18965635834922046, 0.18965635834922046, 0.18965635834922046, 0.1922680850099724, 0.1922680850099724, 0.1922680850099724, 0.12290171728449328, 0.12290171728449328, 0.12290171728449328, 0.19242624672551278, 0.19242624672551278, 0.19242624672551278, 0.23981700733749145, 0.23981700733749145, 0.23981700733749145, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11832266038210981, 0.11832266038210981, 0.11832266038210981, 0.008845237008367035, 0.008845237008367035, 0.008845237008367035, 0.08192273860229127, 0.08192273860229127, 0.08192273860229127, 0.04090928784772874, 0.04090928784772874, 0.04090928784772874, 0.10763150108217756, 0.10763150108217756, 0.10763150108217756, 0.07165169889070244, 0.07165169889070244, 0.07165169889070244, 0.10314191039590181, 0.10314191039590181, 0.10314191039590181, 0.036644568496562946, 0.036644568496562946, 0.036644568496562946, 0.047604106379916855, 0.047604106379916855, 0.047604106379916855, 0.5045517968829846, 0.5045517968829846, 0.5045517968829846, 0.5603437623655827, 0.5603437623655827, 0.5603437623655827, 0.5399650739731374, 0.5399650739731374, 0.5399650739731374, 0.09960282267956222, 0.09960282267956222, 0.09960282267956222, 0.10315405467962702, 0.10315405467962702, 0.10315405467962702, 0.09632194295251595, 0.09632194295251595, 0.09632194295251595, 0.15664563517469543, 0.15664563517469543, 0.15664563517469543, 0.1726584416327016, 0.1726584416327016, 0.1726584416327016, 0.20584072587820323, 0.20584072587820323, 0.20584072587820323, 0.3984306258358652, 0.3984306258358652, 0.3984306258358652, 0.22191757718505356, 0.22191757718505356, 0.22191757718505356, 0.4703550760379036, 0.4703550760379036, 0.4703550760379036, 0.1645642400644307, 0.1645642400644307, 0.1645642400644307, 0.1849398554912034, 0.1849398554912034, 0.1849398554912034, 0.2342185433871823, 0.2342185433871823, 0.2342185433871823, 0.2082259472665181, 0.2082259472665181, 0.2082259472665181, 0.2116462846449073, 0.2116462846449073, 0.2116462846449073, 0.22764025737798876, 0.22764025737798876, 0.22764025737798876, 0.21791045953780208, 0.21791045953780208, 0.21791045953780208, 0.19923228374710789, 0.19923228374710789, 0.19923228374710789, 0.22954506476709158, 0.22954506476709158, 0.22954506476709158, 0.8426612651327052, 0.8426612651327052, 0.8426612651327052, 0.16994149128907898, 0.16994149128907898, 0.16994149128907898, 0.1853560208456383, 0.1853560208456383, 0.1853560208456383, 0.1658775123590942, 0.1658775123590942, 0.1658775123590942, 0.5917502423518358, 0.5917502423518358, 0.5917502423518358, 0.1637656787493006, 0.1637656787493006, 0.1637656787493006, 0.19058998555397322, 0.19058998555397322, 0.19058998555397322, 0.20597390536572557, 0.20597390536572557, 0.20597390536572557, 0.18596574611864414, 0.18596574611864414, 0.18596574611864414, 0.08826872919909146, 0.08826872919909146, 0.08826872919909146, 0.08218347842291829, 0.08218347842291829, 0.08218347842291829, 0.09016658358847451, 0.09016658358847451, 0.09016658358847451]}, "mutation_prompt": null}
{"id": "280c8441-f09b-4230-ad11-d73f5f52d505", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n        self.noise_factor = 0.01  # Noise factor for velocity perturbation\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                noise = self.noise_factor * np.random.uniform(-1, 1, self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]) +\n                                 noise)\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Enhance exploration by introducing a small velocity perturbation influenced by random noise.", "configspace": "", "generation": 24, "fitness": 0.24930109484484256, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.23.", "error": "", "parent_id": "08d79927-d144-4cc2-a5a0-35b395ae3b32", "metadata": {"aucs": [0.5981956550288654, 0.5981956550288654, 0.5981956550288654, 0.5606884773334806, 0.5606884773334806, 0.5606884773334806, 0.6001106779841044, 0.6001106779841044, 0.6001106779841044, 0.03580658969030015, 0.03580658969030015, 0.03580658969030015, 0.18327799610343398, 0.18327799610343398, 0.18327799610343398, 0.03738591826045956, 0.03738591826045956, 0.03738591826045956, 0.12567778490712989, 0.12567778490712989, 0.12567778490712989, 0.15823724528775707, 0.15823724528775707, 0.15823724528775707, 0.15766525976771006, 0.15766525976771006, 0.15766525976771006, 0.12932683144450674, 0.12932683144450674, 0.12932683144450674, 0.10426341025758523, 0.10426341025758523, 0.10426341025758523, 0.13374403582395555, 0.13374403582395555, 0.13374403582395555, 0.9778122126764571, 0.9778122126764571, 0.9778122126764571, 0.9884339980283634, 0.9884339980283634, 0.9884339980283634, 0.9867396290626921, 0.9867396290626921, 0.9867396290626921, 0.4215454804630341, 0.4215454804630341, 0.4215454804630341, 0.35479903301864, 0.35479903301864, 0.35479903301864, 0.40702504686610574, 0.40702504686610574, 0.40702504686610574, 0.3518500361811119, 0.3518500361811119, 0.3518500361811119, 0.1599425243615633, 0.1599425243615633, 0.1599425243615633, 0.17088453275072168, 0.17088453275072168, 0.17088453275072168, 0.19741802667682196, 0.19741802667682196, 0.19741802667682196, 0.19393827885319448, 0.19393827885319448, 0.19393827885319448, 0.20927142668372412, 0.20927142668372412, 0.20927142668372412, 0.12198938259240766, 0.12198938259240766, 0.12198938259240766, 0.2121100499180404, 0.2121100499180404, 0.2121100499180404, 0.21067916206902526, 0.21067916206902526, 0.21067916206902526, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06900958981065652, 0.06900958981065652, 0.06900958981065652, 0.0730068574328081, 0.0730068574328081, 0.0730068574328081, 0.0784841110126574, 0.0784841110126574, 0.0784841110126574, 0.03494192942741725, 0.03494192942741725, 0.03494192942741725, 0.053114875742145906, 0.053114875742145906, 0.053114875742145906, 0.052798662536933105, 0.052798662536933105, 0.052798662536933105, 0.18329287283872453, 0.18329287283872453, 0.18329287283872453, 0.05836066363463144, 0.05836066363463144, 0.05836066363463144, 0.05455573685061932, 0.05455573685061932, 0.05455573685061932, 0.49157671736292397, 0.49157671736292397, 0.49157671736292397, 0.49386441842818074, 0.49386441842818074, 0.49386441842818074, 0.5043954192433227, 0.5043954192433227, 0.5043954192433227, 0.06903280527776601, 0.06903280527776601, 0.06903280527776601, 0.11283784300730892, 0.11283784300730892, 0.11283784300730892, 0.08751406450310883, 0.08751406450310883, 0.08751406450310883, 0.30379433880440243, 0.30379433880440243, 0.30379433880440243, 0.2304504949092705, 0.2304504949092705, 0.2304504949092705, 0.17041973463825688, 0.17041973463825688, 0.17041973463825688, 0.3773725762646547, 0.3773725762646547, 0.3773725762646547, 0.3489374403518126, 0.3489374403518126, 0.3489374403518126, 0.35953663870768027, 0.35953663870768027, 0.35953663870768027, 0.3012032693743165, 0.3012032693743165, 0.3012032693743165, 0.1627430203339313, 0.1627430203339313, 0.1627430203339313, 0.1377430701589154, 0.1377430701589154, 0.1377430701589154, 0.22712892561836628, 0.22712892561836628, 0.22712892561836628, 0.2054393131467367, 0.2054393131467367, 0.2054393131467367, 0.19593222130111643, 0.19593222130111643, 0.19593222130111643, 0.2339829304336727, 0.2339829304336727, 0.2339829304336727, 0.4213119014322786, 0.4213119014322786, 0.4213119014322786, 0.2161053206744058, 0.2161053206744058, 0.2161053206744058, 0.8809909283396327, 0.8809909283396327, 0.8809909283396327, 0.15773673224260087, 0.15773673224260087, 0.15773673224260087, 0.187300605311448, 0.187300605311448, 0.187300605311448, 0.16729531564833866, 0.16729531564833866, 0.16729531564833866, 0.4254700788300273, 0.4254700788300273, 0.4254700788300273, 0.15561663495871125, 0.15561663495871125, 0.15561663495871125, 0.22427233219583764, 0.22427233219583764, 0.22427233219583764, 0.1987784164786942, 0.1987784164786942, 0.1987784164786942, 0.1925189835910749, 0.1925189835910749, 0.1925189835910749, 0.07908456897602756, 0.07908456897602756, 0.07908456897602756, 0.09405633582569028, 0.09405633582569028, 0.09405633582569028, 0.08855143108036667, 0.08855143108036667, 0.08855143108036667]}, "mutation_prompt": null}
{"id": "a79145e9-0dcd-4a1e-8640-cfc5c96ff2af", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a random inertia weight variation around its adaptive value to encourage diverse exploration and prevent premature convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "08d79927-d144-4cc2-a5a0-35b395ae3b32", "metadata": {"aucs": [0.7746800969399547, 0.7746800969399547, 0.7746800969399547, 0.7853801286106803, 0.7853801286106803, 0.7853801286106803, 0.8045342136442298, 0.8045342136442298, 0.8045342136442298, 0.5112258617734755, 0.5112258617734755, 0.5112258617734755, 0.5827691753406969, 0.5827691753406969, 0.5827691753406969, 0.0165875754164847, 0.0165875754164847, 0.0165875754164847, 0.13824639610431877, 0.13824639610431877, 0.13824639610431877, 0.12343150815305326, 0.12343150815305326, 0.12343150815305326, 0.14327718676959988, 0.14327718676959988, 0.14327718676959988, 0.10277716308937379, 0.10277716308937379, 0.10277716308937379, 0.09387920086898627, 0.09387920086898627, 0.09387920086898627, 0.15146555854800425, 0.15146555854800425, 0.15146555854800425, 0.9833545195335007, 0.9833545195335007, 0.9833545195335007, 0.9871312113475053, 0.9871312113475053, 0.9871312113475053, 0.9817455104503656, 0.9817455104503656, 0.9817455104503656, 0.5767357099827427, 0.5767357099827427, 0.5767357099827427, 0.5169121442607256, 0.5169121442607256, 0.5169121442607256, 0.6014842608374387, 0.6014842608374387, 0.6014842608374387, 0.7498310772428576, 0.7498310772428576, 0.7498310772428576, 0.16131966356215888, 0.16131966356215888, 0.16131966356215888, 0.22972192522828738, 0.22972192522828738, 0.22972192522828738, 0.20843491632644195, 0.20843491632644195, 0.20843491632644195, 0.127538956888941, 0.127538956888941, 0.127538956888941, 0.20043941549992983, 0.20043941549992983, 0.20043941549992983, 0.20043724790322381, 0.20043724790322381, 0.20043724790322381, 0.1980083372102206, 0.1980083372102206, 0.1980083372102206, 0.25237156504785063, 0.25237156504785063, 0.25237156504785063, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10303185743654597, 0.10303185743654597, 0.10303185743654597, 0.024975329711378835, 0.024975329711378835, 0.024975329711378835, 0.07972047324539488, 0.07972047324539488, 0.07972047324539488, 0.04151606845294609, 0.04151606845294609, 0.04151606845294609, 0.09841399210917312, 0.09841399210917312, 0.09841399210917312, 0.07420626520238216, 0.07420626520238216, 0.07420626520238216, 0.07242114214448025, 0.07242114214448025, 0.07242114214448025, 0.05021356345675154, 0.05021356345675154, 0.05021356345675154, 0.04729625539112947, 0.04729625539112947, 0.04729625539112947, 0.5247403760073024, 0.5247403760073024, 0.5247403760073024, 0.5254732170676452, 0.5254732170676452, 0.5254732170676452, 0.533296283016953, 0.533296283016953, 0.533296283016953, 0.11182999082037737, 0.11182999082037737, 0.11182999082037737, 0.16698479434185887, 0.16698479434185887, 0.16698479434185887, 0.1702438449324729, 0.1702438449324729, 0.1702438449324729, 0.15124317160761425, 0.15124317160761425, 0.15124317160761425, 0.17136281637610795, 0.17136281637610795, 0.17136281637610795, 0.15305409833800154, 0.15305409833800154, 0.15305409833800154, 0.4289292632588073, 0.4289292632588073, 0.4289292632588073, 0.3750164439526886, 0.3750164439526886, 0.3750164439526886, 0.45479519017394565, 0.45479519017394565, 0.45479519017394565, 0.1752721744137603, 0.1752721744137603, 0.1752721744137603, 0.1709440418819106, 0.1709440418819106, 0.1709440418819106, 0.3249144544740491, 0.3249144544740491, 0.3249144544740491, 0.20836914558731834, 0.20836914558731834, 0.20836914558731834, 0.20620797279564684, 0.20620797279564684, 0.20620797279564684, 0.2202405707369386, 0.2202405707369386, 0.2202405707369386, 0.20073942156209978, 0.20073942156209978, 0.20073942156209978, 0.5560900414392491, 0.5560900414392491, 0.5560900414392491, 0.19881251793653076, 0.19881251793653076, 0.19881251793653076, 0.8573798517101334, 0.8573798517101334, 0.8573798517101334, 0.7875819206246645, 0.7875819206246645, 0.7875819206246645, 0.18541178273883496, 0.18541178273883496, 0.18541178273883496, 0.1678552414465876, 0.1678552414465876, 0.1678552414465876, 0.604090578199991, 0.604090578199991, 0.604090578199991, 0.16598417278698818, 0.16598417278698818, 0.16598417278698818, 0.22264407952425702, 0.22264407952425702, 0.22264407952425702, 0.1993759210264019, 0.1993759210264019, 0.1993759210264019, 0.21213396258850215, 0.21213396258850215, 0.21213396258850215, 0.0898788234987602, 0.0898788234987602, 0.0898788234987602, 0.08654610583524047, 0.08654610583524047, 0.08654610583524047, 0.09520527491394148, 0.09520527491394148, 0.09520527491394148]}, "mutation_prompt": null}
{"id": "40e20e79-46af-476d-89d5-3280be3cc80b", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a random inertia weight variation around its adaptive value to encourage diverse exploration and prevent premature convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "08d79927-d144-4cc2-a5a0-35b395ae3b32", "metadata": {"aucs": [0.7746800969399547, 0.7746800969399547, 0.7746800969399547, 0.7853801286106803, 0.7853801286106803, 0.7853801286106803, 0.8045342136442298, 0.8045342136442298, 0.8045342136442298, 0.5112258617734755, 0.5112258617734755, 0.5112258617734755, 0.5827691753406969, 0.5827691753406969, 0.5827691753406969, 0.0165875754164847, 0.0165875754164847, 0.0165875754164847, 0.13824639610431877, 0.13824639610431877, 0.13824639610431877, 0.12343150815305326, 0.12343150815305326, 0.12343150815305326, 0.14327718676959988, 0.14327718676959988, 0.14327718676959988, 0.10277716308937379, 0.10277716308937379, 0.10277716308937379, 0.09387920086898627, 0.09387920086898627, 0.09387920086898627, 0.15146555854800425, 0.15146555854800425, 0.15146555854800425, 0.9833545195335007, 0.9833545195335007, 0.9833545195335007, 0.9871312113475053, 0.9871312113475053, 0.9871312113475053, 0.9817455104503656, 0.9817455104503656, 0.9817455104503656, 0.5767357099827427, 0.5767357099827427, 0.5767357099827427, 0.5169121442607256, 0.5169121442607256, 0.5169121442607256, 0.6014842608374387, 0.6014842608374387, 0.6014842608374387, 0.7498310772428576, 0.7498310772428576, 0.7498310772428576, 0.16131966356215888, 0.16131966356215888, 0.16131966356215888, 0.22972192522828738, 0.22972192522828738, 0.22972192522828738, 0.20843491632644195, 0.20843491632644195, 0.20843491632644195, 0.127538956888941, 0.127538956888941, 0.127538956888941, 0.20043941549992983, 0.20043941549992983, 0.20043941549992983, 0.20043724790322381, 0.20043724790322381, 0.20043724790322381, 0.1980083372102206, 0.1980083372102206, 0.1980083372102206, 0.25237156504785063, 0.25237156504785063, 0.25237156504785063, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10303185743654597, 0.10303185743654597, 0.10303185743654597, 0.024975329711378835, 0.024975329711378835, 0.024975329711378835, 0.07972047324539488, 0.07972047324539488, 0.07972047324539488, 0.04151606845294609, 0.04151606845294609, 0.04151606845294609, 0.09841399210917312, 0.09841399210917312, 0.09841399210917312, 0.07420626520238216, 0.07420626520238216, 0.07420626520238216, 0.07242114214448025, 0.07242114214448025, 0.07242114214448025, 0.05021356345675154, 0.05021356345675154, 0.05021356345675154, 0.04729625539112947, 0.04729625539112947, 0.04729625539112947, 0.5247403760073024, 0.5247403760073024, 0.5247403760073024, 0.5254732170676452, 0.5254732170676452, 0.5254732170676452, 0.533296283016953, 0.533296283016953, 0.533296283016953, 0.11182999082037737, 0.11182999082037737, 0.11182999082037737, 0.16698479434185887, 0.16698479434185887, 0.16698479434185887, 0.1702438449324729, 0.1702438449324729, 0.1702438449324729, 0.15124317160761425, 0.15124317160761425, 0.15124317160761425, 0.17136281637610795, 0.17136281637610795, 0.17136281637610795, 0.15305409833800154, 0.15305409833800154, 0.15305409833800154, 0.4289292632588073, 0.4289292632588073, 0.4289292632588073, 0.3750164439526886, 0.3750164439526886, 0.3750164439526886, 0.45479519017394565, 0.45479519017394565, 0.45479519017394565, 0.1752721744137603, 0.1752721744137603, 0.1752721744137603, 0.1709440418819106, 0.1709440418819106, 0.1709440418819106, 0.3249144544740491, 0.3249144544740491, 0.3249144544740491, 0.20836914558731834, 0.20836914558731834, 0.20836914558731834, 0.20620797279564684, 0.20620797279564684, 0.20620797279564684, 0.2202405707369386, 0.2202405707369386, 0.2202405707369386, 0.20073942156209978, 0.20073942156209978, 0.20073942156209978, 0.5560900414392491, 0.5560900414392491, 0.5560900414392491, 0.19881251793653076, 0.19881251793653076, 0.19881251793653076, 0.8573798517101334, 0.8573798517101334, 0.8573798517101334, 0.7875819206246645, 0.7875819206246645, 0.7875819206246645, 0.18541178273883496, 0.18541178273883496, 0.18541178273883496, 0.1678552414465876, 0.1678552414465876, 0.1678552414465876, 0.604090578199991, 0.604090578199991, 0.604090578199991, 0.16598417278698818, 0.16598417278698818, 0.16598417278698818, 0.22264407952425702, 0.22264407952425702, 0.22264407952425702, 0.1993759210264019, 0.1993759210264019, 0.1993759210264019, 0.21213396258850215, 0.21213396258850215, 0.21213396258850215, 0.0898788234987602, 0.0898788234987602, 0.0898788234987602, 0.08654610583524047, 0.08654610583524047, 0.08654610583524047, 0.09520527491394148, 0.09520527491394148, 0.09520527491394148]}, "mutation_prompt": null}
{"id": "656109e1-1d3a-46a4-b67a-dbed83f2102a", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n        initial_pressure = 0.4\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with additional pressure mechanism\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n            selection_pressure = initial_pressure + 0.6 * (eval_count / self.budget)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3]) * selection_pressure\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce an adaptive selection pressure mechanism to dynamically adjust the exploration-exploitation balance for improved convergence.", "configspace": "", "generation": 27, "fitness": 0.28675067814562816, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "08d79927-d144-4cc2-a5a0-35b395ae3b32", "metadata": {"aucs": [0.7655333426301418, 0.7655333426301418, 0.7655333426301418, 0.7538666645401404, 0.7538666645401404, 0.7538666645401404, 0.7903787827489113, 0.7903787827489113, 0.7903787827489113, 0.5743138141923974, 0.5743138141923974, 0.5743138141923974, 0.4238494557238266, 0.4238494557238266, 0.4238494557238266, 0.5742237062381442, 0.5742237062381442, 0.5742237062381442, 0.13674189801185255, 0.13674189801185255, 0.13674189801185255, 0.48899776052526267, 0.48899776052526267, 0.48899776052526267, 0.12250362301470885, 0.12250362301470885, 0.12250362301470885, 0.133830869144831, 0.133830869144831, 0.133830869144831, 0.11991971316093308, 0.11991971316093308, 0.11991971316093308, 0.12071454183848984, 0.12071454183848984, 0.12071454183848984, 0.9815235363112123, 0.9815235363112123, 0.9815235363112123, 0.9883935694819953, 0.9883935694819953, 0.9883935694819953, 0.982853417944113, 0.982853417944113, 0.982853417944113, 0.5397752167318328, 0.5397752167318328, 0.5397752167318328, 0.555328234405545, 0.555328234405545, 0.555328234405545, 0.5775789520642916, 0.5775789520642916, 0.5775789520642916, 0.3454841291827978, 0.3454841291827978, 0.3454841291827978, 0.2094514413141222, 0.2094514413141222, 0.2094514413141222, 0.16765021140994707, 0.16765021140994707, 0.16765021140994707, 0.234617163015297, 0.234617163015297, 0.234617163015297, 0.2084213856937146, 0.2084213856937146, 0.2084213856937146, 0.19913789133078286, 0.19913789133078286, 0.19913789133078286, 0.23121283085648936, 0.23121283085648936, 0.23121283085648936, 0.21993288792817123, 0.21993288792817123, 0.21993288792817123, 0.12398187277110406, 0.12398187277110406, 0.12398187277110406, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.050275848135108214, 0.050275848135108214, 0.050275848135108214, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0390841662756356, 0.0390841662756356, 0.0390841662756356, 0.040534722286833524, 0.040534722286833524, 0.040534722286833524, 0.03287354359873351, 0.03287354359873351, 0.03287354359873351, 0.04366883743612904, 0.04366883743612904, 0.04366883743612904, 0.08052545875155426, 0.08052545875155426, 0.08052545875155426, 0.3253972253258225, 0.3253972253258225, 0.3253972253258225, 0.009651237609374808, 0.009651237609374808, 0.009651237609374808, 0.03655921759582359, 0.03655921759582359, 0.03655921759582359, 0.1078691233318334, 0.1078691233318334, 0.1078691233318334, 0.5176452205934488, 0.5176452205934488, 0.5176452205934488, 0.554318138013111, 0.554318138013111, 0.554318138013111, 0.516951063447906, 0.516951063447906, 0.516951063447906, 0.0829198211892257, 0.0829198211892257, 0.0829198211892257, 0.1081936331570379, 0.1081936331570379, 0.1081936331570379, 0.14250320345950496, 0.14250320345950496, 0.14250320345950496, 0.16067559085106098, 0.16067559085106098, 0.16067559085106098, 0.15716674470466807, 0.15716674470466807, 0.15716674470466807, 0.25464613877426323, 0.25464613877426323, 0.25464613877426323, 0.4551049064006849, 0.4551049064006849, 0.4551049064006849, 0.3713539570425297, 0.3713539570425297, 0.3713539570425297, 0.45853425711251317, 0.45853425711251317, 0.45853425711251317, 0.23418146177898957, 0.23418146177898957, 0.23418146177898957, 0.22145857836567462, 0.22145857836567462, 0.22145857836567462, 0.1609232397721242, 0.1609232397721242, 0.1609232397721242, 0.18426504051564585, 0.18426504051564585, 0.18426504051564585, 0.20198941031686912, 0.20198941031686912, 0.20198941031686912, 0.23755773612167164, 0.23755773612167164, 0.23755773612167164, 0.21709019596933166, 0.21709019596933166, 0.21709019596933166, 0.21527279628858564, 0.21527279628858564, 0.21527279628858564, 0.22917562012080683, 0.22917562012080683, 0.22917562012080683, 0.8707617279428111, 0.8707617279428111, 0.8707617279428111, 0.17348130473677226, 0.17348130473677226, 0.17348130473677226, 0.18408914631712303, 0.18408914631712303, 0.18408914631712303, 0.16511505880136446, 0.16511505880136446, 0.16511505880136446, 0.20699245983838355, 0.20699245983838355, 0.20699245983838355, 0.15419148327055776, 0.15419148327055776, 0.15419148327055776, 0.2019654903400182, 0.2019654903400182, 0.2019654903400182, 0.19491708934263874, 0.19491708934263874, 0.19491708934263874, 0.20808333334449847, 0.20808333334449847, 0.20808333334449847, 0.0967884512559205, 0.0967884512559205, 0.0967884512559205, 0.08168028651101888, 0.08168028651101888, 0.08168028651101888, 0.08919994823056476, 0.08919994823056476, 0.08919994823056476]}, "mutation_prompt": null}
{"id": "45ecbb87-86ba-45c6-8865-51b0e1635fb6", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a random inertia weight variation around its adaptive value to encourage diverse exploration and prevent premature convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "08d79927-d144-4cc2-a5a0-35b395ae3b32", "metadata": {"aucs": [0.7746800969399547, 0.7746800969399547, 0.7746800969399547, 0.7853801286106803, 0.7853801286106803, 0.7853801286106803, 0.8045342136442298, 0.8045342136442298, 0.8045342136442298, 0.5112258617734755, 0.5112258617734755, 0.5112258617734755, 0.5827691753406969, 0.5827691753406969, 0.5827691753406969, 0.0165875754164847, 0.0165875754164847, 0.0165875754164847, 0.13824639610431877, 0.13824639610431877, 0.13824639610431877, 0.12343150815305326, 0.12343150815305326, 0.12343150815305326, 0.14327718676959988, 0.14327718676959988, 0.14327718676959988, 0.10277716308937379, 0.10277716308937379, 0.10277716308937379, 0.09387920086898627, 0.09387920086898627, 0.09387920086898627, 0.15146555854800425, 0.15146555854800425, 0.15146555854800425, 0.9833545195335007, 0.9833545195335007, 0.9833545195335007, 0.9871312113475053, 0.9871312113475053, 0.9871312113475053, 0.9817455104503656, 0.9817455104503656, 0.9817455104503656, 0.5767357099827427, 0.5767357099827427, 0.5767357099827427, 0.5169121442607256, 0.5169121442607256, 0.5169121442607256, 0.6014842608374387, 0.6014842608374387, 0.6014842608374387, 0.7498310772428576, 0.7498310772428576, 0.7498310772428576, 0.16131966356215888, 0.16131966356215888, 0.16131966356215888, 0.22972192522828738, 0.22972192522828738, 0.22972192522828738, 0.20843491632644195, 0.20843491632644195, 0.20843491632644195, 0.127538956888941, 0.127538956888941, 0.127538956888941, 0.20043941549992983, 0.20043941549992983, 0.20043941549992983, 0.20043724790322381, 0.20043724790322381, 0.20043724790322381, 0.1980083372102206, 0.1980083372102206, 0.1980083372102206, 0.25237156504785063, 0.25237156504785063, 0.25237156504785063, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10303185743654597, 0.10303185743654597, 0.10303185743654597, 0.024975329711378835, 0.024975329711378835, 0.024975329711378835, 0.07972047324539488, 0.07972047324539488, 0.07972047324539488, 0.04151606845294609, 0.04151606845294609, 0.04151606845294609, 0.09841399210917312, 0.09841399210917312, 0.09841399210917312, 0.07420626520238216, 0.07420626520238216, 0.07420626520238216, 0.07242114214448025, 0.07242114214448025, 0.07242114214448025, 0.05021356345675154, 0.05021356345675154, 0.05021356345675154, 0.04729625539112947, 0.04729625539112947, 0.04729625539112947, 0.5247403760073024, 0.5247403760073024, 0.5247403760073024, 0.5254732170676452, 0.5254732170676452, 0.5254732170676452, 0.533296283016953, 0.533296283016953, 0.533296283016953, 0.11182999082037737, 0.11182999082037737, 0.11182999082037737, 0.16698479434185887, 0.16698479434185887, 0.16698479434185887, 0.1702438449324729, 0.1702438449324729, 0.1702438449324729, 0.15124317160761425, 0.15124317160761425, 0.15124317160761425, 0.17136281637610795, 0.17136281637610795, 0.17136281637610795, 0.15305409833800154, 0.15305409833800154, 0.15305409833800154, 0.4289292632588073, 0.4289292632588073, 0.4289292632588073, 0.3750164439526886, 0.3750164439526886, 0.3750164439526886, 0.45479519017394565, 0.45479519017394565, 0.45479519017394565, 0.1752721744137603, 0.1752721744137603, 0.1752721744137603, 0.1709440418819106, 0.1709440418819106, 0.1709440418819106, 0.3249144544740491, 0.3249144544740491, 0.3249144544740491, 0.20836914558731834, 0.20836914558731834, 0.20836914558731834, 0.20620797279564684, 0.20620797279564684, 0.20620797279564684, 0.2202405707369386, 0.2202405707369386, 0.2202405707369386, 0.20073942156209978, 0.20073942156209978, 0.20073942156209978, 0.5560900414392491, 0.5560900414392491, 0.5560900414392491, 0.19881251793653076, 0.19881251793653076, 0.19881251793653076, 0.8573798517101334, 0.8573798517101334, 0.8573798517101334, 0.7875819206246645, 0.7875819206246645, 0.7875819206246645, 0.18541178273883496, 0.18541178273883496, 0.18541178273883496, 0.1678552414465876, 0.1678552414465876, 0.1678552414465876, 0.604090578199991, 0.604090578199991, 0.604090578199991, 0.16598417278698818, 0.16598417278698818, 0.16598417278698818, 0.22264407952425702, 0.22264407952425702, 0.22264407952425702, 0.1993759210264019, 0.1993759210264019, 0.1993759210264019, 0.21213396258850215, 0.21213396258850215, 0.21213396258850215, 0.0898788234987602, 0.0898788234987602, 0.0898788234987602, 0.08654610583524047, 0.08654610583524047, 0.08654610583524047, 0.09520527491394148, 0.09520527491394148, 0.09520527491394148]}, "mutation_prompt": null}
{"id": "3c45e091-b62f-4551-b367-3b8acaaac480", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a random inertia weight variation around its adaptive value to encourage diverse exploration and prevent premature convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "08d79927-d144-4cc2-a5a0-35b395ae3b32", "metadata": {"aucs": [0.7746800969399547, 0.7746800969399547, 0.7746800969399547, 0.7853801286106803, 0.7853801286106803, 0.7853801286106803, 0.8045342136442298, 0.8045342136442298, 0.8045342136442298, 0.5112258617734755, 0.5112258617734755, 0.5112258617734755, 0.5827691753406969, 0.5827691753406969, 0.5827691753406969, 0.0165875754164847, 0.0165875754164847, 0.0165875754164847, 0.13824639610431877, 0.13824639610431877, 0.13824639610431877, 0.12343150815305326, 0.12343150815305326, 0.12343150815305326, 0.14327718676959988, 0.14327718676959988, 0.14327718676959988, 0.10277716308937379, 0.10277716308937379, 0.10277716308937379, 0.09387920086898627, 0.09387920086898627, 0.09387920086898627, 0.15146555854800425, 0.15146555854800425, 0.15146555854800425, 0.9833545195335007, 0.9833545195335007, 0.9833545195335007, 0.9871312113475053, 0.9871312113475053, 0.9871312113475053, 0.9817455104503656, 0.9817455104503656, 0.9817455104503656, 0.5767357099827427, 0.5767357099827427, 0.5767357099827427, 0.5169121442607256, 0.5169121442607256, 0.5169121442607256, 0.6014842608374387, 0.6014842608374387, 0.6014842608374387, 0.7498310772428576, 0.7498310772428576, 0.7498310772428576, 0.16131966356215888, 0.16131966356215888, 0.16131966356215888, 0.22972192522828738, 0.22972192522828738, 0.22972192522828738, 0.20843491632644195, 0.20843491632644195, 0.20843491632644195, 0.127538956888941, 0.127538956888941, 0.127538956888941, 0.20043941549992983, 0.20043941549992983, 0.20043941549992983, 0.20043724790322381, 0.20043724790322381, 0.20043724790322381, 0.1980083372102206, 0.1980083372102206, 0.1980083372102206, 0.25237156504785063, 0.25237156504785063, 0.25237156504785063, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10303185743654597, 0.10303185743654597, 0.10303185743654597, 0.024975329711378835, 0.024975329711378835, 0.024975329711378835, 0.07972047324539488, 0.07972047324539488, 0.07972047324539488, 0.04151606845294609, 0.04151606845294609, 0.04151606845294609, 0.09841399210917312, 0.09841399210917312, 0.09841399210917312, 0.07420626520238216, 0.07420626520238216, 0.07420626520238216, 0.07242114214448025, 0.07242114214448025, 0.07242114214448025, 0.05021356345675154, 0.05021356345675154, 0.05021356345675154, 0.04729625539112947, 0.04729625539112947, 0.04729625539112947, 0.5247403760073024, 0.5247403760073024, 0.5247403760073024, 0.5254732170676452, 0.5254732170676452, 0.5254732170676452, 0.533296283016953, 0.533296283016953, 0.533296283016953, 0.11182999082037737, 0.11182999082037737, 0.11182999082037737, 0.16698479434185887, 0.16698479434185887, 0.16698479434185887, 0.1702438449324729, 0.1702438449324729, 0.1702438449324729, 0.15124317160761425, 0.15124317160761425, 0.15124317160761425, 0.17136281637610795, 0.17136281637610795, 0.17136281637610795, 0.15305409833800154, 0.15305409833800154, 0.15305409833800154, 0.4289292632588073, 0.4289292632588073, 0.4289292632588073, 0.3750164439526886, 0.3750164439526886, 0.3750164439526886, 0.45479519017394565, 0.45479519017394565, 0.45479519017394565, 0.1752721744137603, 0.1752721744137603, 0.1752721744137603, 0.1709440418819106, 0.1709440418819106, 0.1709440418819106, 0.3249144544740491, 0.3249144544740491, 0.3249144544740491, 0.20836914558731834, 0.20836914558731834, 0.20836914558731834, 0.20620797279564684, 0.20620797279564684, 0.20620797279564684, 0.2202405707369386, 0.2202405707369386, 0.2202405707369386, 0.20073942156209978, 0.20073942156209978, 0.20073942156209978, 0.5560900414392491, 0.5560900414392491, 0.5560900414392491, 0.19881251793653076, 0.19881251793653076, 0.19881251793653076, 0.8573798517101334, 0.8573798517101334, 0.8573798517101334, 0.7875819206246645, 0.7875819206246645, 0.7875819206246645, 0.18541178273883496, 0.18541178273883496, 0.18541178273883496, 0.1678552414465876, 0.1678552414465876, 0.1678552414465876, 0.604090578199991, 0.604090578199991, 0.604090578199991, 0.16598417278698818, 0.16598417278698818, 0.16598417278698818, 0.22264407952425702, 0.22264407952425702, 0.22264407952425702, 0.1993759210264019, 0.1993759210264019, 0.1993759210264019, 0.21213396258850215, 0.21213396258850215, 0.21213396258850215, 0.0898788234987602, 0.0898788234987602, 0.0898788234987602, 0.08654610583524047, 0.08654610583524047, 0.08654610583524047, 0.09520527491394148, 0.09520527491394148, 0.09520527491394148]}, "mutation_prompt": null}
{"id": "8fdadcea-f650-49d4-a61f-f5d7a68f162b", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a random inertia weight variation around its adaptive value to encourage diverse exploration and prevent premature convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "08d79927-d144-4cc2-a5a0-35b395ae3b32", "metadata": {"aucs": [0.7746800969399547, 0.7746800969399547, 0.7746800969399547, 0.7853801286106803, 0.7853801286106803, 0.7853801286106803, 0.8045342136442298, 0.8045342136442298, 0.8045342136442298, 0.5112258617734755, 0.5112258617734755, 0.5112258617734755, 0.5827691753406969, 0.5827691753406969, 0.5827691753406969, 0.0165875754164847, 0.0165875754164847, 0.0165875754164847, 0.13824639610431877, 0.13824639610431877, 0.13824639610431877, 0.12343150815305326, 0.12343150815305326, 0.12343150815305326, 0.14327718676959988, 0.14327718676959988, 0.14327718676959988, 0.10277716308937379, 0.10277716308937379, 0.10277716308937379, 0.09387920086898627, 0.09387920086898627, 0.09387920086898627, 0.15146555854800425, 0.15146555854800425, 0.15146555854800425, 0.9833545195335007, 0.9833545195335007, 0.9833545195335007, 0.9871312113475053, 0.9871312113475053, 0.9871312113475053, 0.9817455104503656, 0.9817455104503656, 0.9817455104503656, 0.5767357099827427, 0.5767357099827427, 0.5767357099827427, 0.5169121442607256, 0.5169121442607256, 0.5169121442607256, 0.6014842608374387, 0.6014842608374387, 0.6014842608374387, 0.7498310772428576, 0.7498310772428576, 0.7498310772428576, 0.16131966356215888, 0.16131966356215888, 0.16131966356215888, 0.22972192522828738, 0.22972192522828738, 0.22972192522828738, 0.20843491632644195, 0.20843491632644195, 0.20843491632644195, 0.127538956888941, 0.127538956888941, 0.127538956888941, 0.20043941549992983, 0.20043941549992983, 0.20043941549992983, 0.20043724790322381, 0.20043724790322381, 0.20043724790322381, 0.1980083372102206, 0.1980083372102206, 0.1980083372102206, 0.25237156504785063, 0.25237156504785063, 0.25237156504785063, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10303185743654597, 0.10303185743654597, 0.10303185743654597, 0.024975329711378835, 0.024975329711378835, 0.024975329711378835, 0.07972047324539488, 0.07972047324539488, 0.07972047324539488, 0.04151606845294609, 0.04151606845294609, 0.04151606845294609, 0.09841399210917312, 0.09841399210917312, 0.09841399210917312, 0.07420626520238216, 0.07420626520238216, 0.07420626520238216, 0.07242114214448025, 0.07242114214448025, 0.07242114214448025, 0.05021356345675154, 0.05021356345675154, 0.05021356345675154, 0.04729625539112947, 0.04729625539112947, 0.04729625539112947, 0.5247403760073024, 0.5247403760073024, 0.5247403760073024, 0.5254732170676452, 0.5254732170676452, 0.5254732170676452, 0.533296283016953, 0.533296283016953, 0.533296283016953, 0.11182999082037737, 0.11182999082037737, 0.11182999082037737, 0.16698479434185887, 0.16698479434185887, 0.16698479434185887, 0.1702438449324729, 0.1702438449324729, 0.1702438449324729, 0.15124317160761425, 0.15124317160761425, 0.15124317160761425, 0.17136281637610795, 0.17136281637610795, 0.17136281637610795, 0.15305409833800154, 0.15305409833800154, 0.15305409833800154, 0.4289292632588073, 0.4289292632588073, 0.4289292632588073, 0.3750164439526886, 0.3750164439526886, 0.3750164439526886, 0.45479519017394565, 0.45479519017394565, 0.45479519017394565, 0.1752721744137603, 0.1752721744137603, 0.1752721744137603, 0.1709440418819106, 0.1709440418819106, 0.1709440418819106, 0.3249144544740491, 0.3249144544740491, 0.3249144544740491, 0.20836914558731834, 0.20836914558731834, 0.20836914558731834, 0.20620797279564684, 0.20620797279564684, 0.20620797279564684, 0.2202405707369386, 0.2202405707369386, 0.2202405707369386, 0.20073942156209978, 0.20073942156209978, 0.20073942156209978, 0.5560900414392491, 0.5560900414392491, 0.5560900414392491, 0.19881251793653076, 0.19881251793653076, 0.19881251793653076, 0.8573798517101334, 0.8573798517101334, 0.8573798517101334, 0.7875819206246645, 0.7875819206246645, 0.7875819206246645, 0.18541178273883496, 0.18541178273883496, 0.18541178273883496, 0.1678552414465876, 0.1678552414465876, 0.1678552414465876, 0.604090578199991, 0.604090578199991, 0.604090578199991, 0.16598417278698818, 0.16598417278698818, 0.16598417278698818, 0.22264407952425702, 0.22264407952425702, 0.22264407952425702, 0.1993759210264019, 0.1993759210264019, 0.1993759210264019, 0.21213396258850215, 0.21213396258850215, 0.21213396258850215, 0.0898788234987602, 0.0898788234987602, 0.0898788234987602, 0.08654610583524047, 0.08654610583524047, 0.08654610583524047, 0.09520527491394148, 0.09520527491394148, 0.09520527491394148]}, "mutation_prompt": null}
{"id": "a8deb005-0dc9-4e96-9550-b94366e56911", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 2.0  # Increased cognitive component for individual influence\n        self.c2 = 2.0  # Increased social component for collective influence\n        self.w = 0.5   # Slightly adjusted initial inertia weight\n        self.F = 0.6   # Reduced DE scaling factor for finer search\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Dynamic inertia weight with random variation\n            self.w = 0.5 + (0.9 - 0.5) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform dynamic DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                F_dynamic = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Dynamic scaling factor\n                mutant = pop[r1] + F_dynamic * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO with enhanced influence\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a dynamic mutation strategy with adaptive parameters to enhance diversity and convergence efficiency in solving optimization problems.", "configspace": "", "generation": 31, "fitness": 0.17519556993912466, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.20.", "error": "", "parent_id": "08d79927-d144-4cc2-a5a0-35b395ae3b32", "metadata": {"aucs": [0.425280365955262, 0.425280365955262, 0.425280365955262, 0.42488987379124254, 0.42488987379124254, 0.42488987379124254, 0.41991231903696713, 0.41991231903696713, 0.41991231903696713, 0.06361727787410487, 0.06361727787410487, 0.06361727787410487, 0.09517030852285957, 0.09517030852285957, 0.09517030852285957, 0.022084076977546663, 0.022084076977546663, 0.022084076977546663, 0.07465816515347612, 0.07465816515347612, 0.07465816515347612, 0.05574574720186187, 0.05574574720186187, 0.05574574720186187, 0.08327436777136321, 0.08327436777136321, 0.08327436777136321, 0.07202788045000075, 0.07202788045000075, 0.07202788045000075, 0.07994254018209213, 0.07994254018209213, 0.07994254018209213, 0.07630807894935443, 0.07630807894935443, 0.07630807894935443, 0.9863984509749955, 0.9863984509749955, 0.9863984509749955, 0.9876990349979153, 0.9876990349979153, 0.9876990349979153, 0.9873393310383834, 0.9873393310383834, 0.9873393310383834, 0.18771884657934623, 0.18771884657934623, 0.18771884657934623, 0.040495492310438364, 0.040495492310438364, 0.040495492310438364, 0.20667060488429523, 0.20667060488429523, 0.20667060488429523, 0.23570734836018514, 0.23570734836018514, 0.23570734836018514, 0.22217423700093042, 0.22217423700093042, 0.22217423700093042, 0.14540767582054737, 0.14540767582054737, 0.14540767582054737, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10078959169172663, 0.10078959169172663, 0.10078959169172663, 0.08273801471841657, 0.08273801471841657, 0.08273801471841657, 0.09576503083470889, 0.09576503083470889, 0.09576503083470889, 0.07907051865798898, 0.07907051865798898, 0.07907051865798898, 0.06962759007876962, 0.06962759007876962, 0.06962759007876962, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08660242398877183, 0.08660242398877183, 0.08660242398877183, 0.0724132091109575, 0.0724132091109575, 0.0724132091109575, 0.037870530229167865, 0.037870530229167865, 0.037870530229167865, 0.01899487952180079, 0.01899487952180079, 0.01899487952180079, 0.03915332669764471, 0.03915332669764471, 0.03915332669764471, 0.014577031363384951, 0.014577031363384951, 0.014577031363384951, 0.05846321240454999, 0.05846321240454999, 0.05846321240454999, 0.024402695233044835, 0.024402695233044835, 0.024402695233044835, 0.04819174768595147, 0.04819174768595147, 0.04819174768595147, 0.3695849944722621, 0.3695849944722621, 0.3695849944722621, 0.17892609313864483, 0.17892609313864483, 0.17892609313864483, 0.35091742875026233, 0.35091742875026233, 0.35091742875026233, 0.0818362613787833, 0.0818362613787833, 0.0818362613787833, 0.08508519223727529, 0.08508519223727529, 0.08508519223727529, 0.08672197064271991, 0.08672197064271991, 0.08672197064271991, 0.14022141691338652, 0.14022141691338652, 0.14022141691338652, 0.1414837503701767, 0.1414837503701767, 0.1414837503701767, 0.16961967368620268, 0.16961967368620268, 0.16961967368620268, 0.18960641253679378, 0.18960641253679378, 0.18960641253679378, 0.17893483924121878, 0.17893483924121878, 0.17893483924121878, 0.24494023114830465, 0.24494023114830465, 0.24494023114830465, 0.1671660104122591, 0.1671660104122591, 0.1671660104122591, 0.17770409278055743, 0.17770409278055743, 0.17770409278055743, 0.12995799394604968, 0.12995799394604968, 0.12995799394604968, 0.17147468055205695, 0.17147468055205695, 0.17147468055205695, 0.17488314381990733, 0.17488314381990733, 0.17488314381990733, 0.1565169367195265, 0.1565169367195265, 0.1565169367195265, 0.17793400128151038, 0.17793400128151038, 0.17793400128151038, 0.18014764606242284, 0.18014764606242284, 0.18014764606242284, 0.1621989842057856, 0.1621989842057856, 0.1621989842057856, 0.5336050654677146, 0.5336050654677146, 0.5336050654677146, 0.149199367637612, 0.149199367637612, 0.149199367637612, 0.19223741211480616, 0.19223741211480616, 0.19223741211480616, 0.17260203198926594, 0.17260203198926594, 0.17260203198926594, 0.19982376175161765, 0.19982376175161765, 0.19982376175161765, 0.14947330264724934, 0.14947330264724934, 0.14947330264724934, 0.18606571603962851, 0.18606571603962851, 0.18606571603962851, 0.1805304746194104, 0.1805304746194104, 0.1805304746194104, 0.19321207438991295, 0.19321207438991295, 0.19321207438991295, 0.06925213302372835, 0.06925213302372835, 0.06925213302372835, 0.0776810570913431, 0.0776810570913431, 0.0776810570913431, 0.0729550584985289, 0.0729550584985289, 0.0729550584985289]}, "mutation_prompt": null}
{"id": "2c9151e8-e9de-484e-b77b-c7e187e11898", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n        self.diversity_coeff = 0.1  # New diversity coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                # Add diversity component\n                stochastic_component = self.diversity_coeff * np.random.randn(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]) +\n                                 stochastic_component)\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Integrate a swarm diversity mechanism to enhance exploration by adding a stochastic component to velocities.", "configspace": "", "generation": 32, "fitness": 0.20550826312340023, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.20.", "error": "", "parent_id": "08d79927-d144-4cc2-a5a0-35b395ae3b32", "metadata": {"aucs": [0.4000619966569995, 0.4000619966569995, 0.4000619966569995, 0.4153612234933185, 0.4153612234933185, 0.4153612234933185, 0.40860008854688756, 0.40860008854688756, 0.40860008854688756, 0.045997302141668306, 0.045997302141668306, 0.045997302141668306, 0.005557658528469456, 0.005557658528469456, 0.005557658528469456, 0.02213112438473197, 0.02213112438473197, 0.02213112438473197, 0.12212083163078369, 0.12212083163078369, 0.12212083163078369, 0.06815179775009905, 0.06815179775009905, 0.06815179775009905, 0.10800370675416049, 0.10800370675416049, 0.10800370675416049, 0.08877340847083925, 0.08877340847083925, 0.08877340847083925, 0.09161276461245615, 0.09161276461245615, 0.09161276461245615, 0.1017637462658687, 0.1017637462658687, 0.1017637462658687, 0.9831835917761856, 0.9831835917761856, 0.9831835917761856, 0.9831264491987584, 0.9831264491987584, 0.9831264491987584, 0.9706469033085454, 0.9706469033085454, 0.9706469033085454, 0.2722395239915463, 0.2722395239915463, 0.2722395239915463, 0.25783594375367536, 0.25783594375367536, 0.25783594375367536, 0.26223923389605075, 0.26223923389605075, 0.26223923389605075, 0.3038971119714503, 0.3038971119714503, 0.3038971119714503, 0.21561425127297773, 0.21561425127297773, 0.21561425127297773, 0.2309714464212389, 0.2309714464212389, 0.2309714464212389, 0.14409164269549513, 0.14409164269549513, 0.14409164269549513, 0.12549518005865434, 0.12549518005865434, 0.12549518005865434, 0.1018428378571109, 0.1018428378571109, 0.1018428378571109, 0.14572528567051546, 0.14572528567051546, 0.14572528567051546, 0.16117066950651426, 0.16117066950651426, 0.16117066950651426, 0.16049911517769977, 0.16049911517769977, 0.16049911517769977, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05992692534424837, 0.05992692534424837, 0.05992692534424837, 0.057691878554381626, 0.057691878554381626, 0.057691878554381626, 0.06411355845799693, 0.06411355845799693, 0.06411355845799693, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06984402556429958, 0.06984402556429958, 0.06984402556429958, 0.0695784426937085, 0.0695784426937085, 0.0695784426937085, 0.04923476354338141, 0.04923476354338141, 0.04923476354338141, 0.408330509040697, 0.408330509040697, 0.408330509040697, 0.3809498830779159, 0.3809498830779159, 0.3809498830779159, 0.37738624430982337, 0.37738624430982337, 0.37738624430982337, 0.11429094422944786, 0.11429094422944786, 0.11429094422944786, 0.1210519273961489, 0.1210519273961489, 0.1210519273961489, 0.09606866755162391, 0.09606866755162391, 0.09606866755162391, 0.21017672240300467, 0.21017672240300467, 0.21017672240300467, 0.22222906424813715, 0.22222906424813715, 0.22222906424813715, 0.2129932854467277, 0.2129932854467277, 0.2129932854467277, 0.2735465592521149, 0.2735465592521149, 0.2735465592521149, 0.2805149410785921, 0.2805149410785921, 0.2805149410785921, 0.28229012010234034, 0.28229012010234034, 0.28229012010234034, 0.2047307409191933, 0.2047307409191933, 0.2047307409191933, 0.17195769595713806, 0.17195769595713806, 0.17195769595713806, 0.1246729579388659, 0.1246729579388659, 0.1246729579388659, 0.22132529730895445, 0.22132529730895445, 0.22132529730895445, 0.20307544689169177, 0.20307544689169177, 0.20307544689169177, 0.19607078151779211, 0.19607078151779211, 0.19607078151779211, 0.21487489978825491, 0.21487489978825491, 0.21487489978825491, 0.19992640154378138, 0.19992640154378138, 0.19992640154378138, 0.22093462033961897, 0.22093462033961897, 0.22093462033961897, 0.5957577904429894, 0.5957577904429894, 0.5957577904429894, 0.14597078548051812, 0.14597078548051812, 0.14597078548051812, 0.18635642642048988, 0.18635642642048988, 0.18635642642048988, 0.16716042240439932, 0.16716042240439932, 0.16716042240439932, 0.1683176918916537, 0.1683176918916537, 0.1683176918916537, 0.4183177504529869, 0.4183177504529869, 0.4183177504529869, 0.18253472640837842, 0.18253472640837842, 0.18253472640837842, 0.1885485953844971, 0.1885485953844971, 0.1885485953844971, 0.19973921109469261, 0.19973921109469261, 0.19973921109469261, 0.0773442417860748, 0.0773442417860748, 0.0773442417860748, 0.08123463002829556, 0.08123463002829556, 0.08123463002829556, 0.08021053279725965, 0.08021053279725965, 0.08021053279725965]}, "mutation_prompt": null}
{"id": "f844bb86-014e-4ad9-a973-5d106962e0ad", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor (original)\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            adaptive_F = self.F + 0.1 * (eval_count / self.budget)  # Adjust F slightly based on iteration progress\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + adaptive_F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a small adaptive component to DE's scaling factor (F) based on the iteration progress to improve convergence.", "configspace": "", "generation": 33, "fitness": 0.29085495429516584, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.26.", "error": "", "parent_id": "08d79927-d144-4cc2-a5a0-35b395ae3b32", "metadata": {"aucs": [0.7823245464421019, 0.7823245464421019, 0.7823245464421019, 0.7822248899260678, 0.7822248899260678, 0.7822248899260678, 0.7930044790265743, 0.7930044790265743, 0.7930044790265743, 0.5700527855060848, 0.5700527855060848, 0.5700527855060848, 0.5622386570287596, 0.5622386570287596, 0.5622386570287596, 0.01667621486022486, 0.01667621486022486, 0.01667621486022486, 0.11267629077149355, 0.11267629077149355, 0.11267629077149355, 0.06867876639931603, 0.06867876639931603, 0.06867876639931603, 0.1315480145395359, 0.1315480145395359, 0.1315480145395359, 0.13877312858099944, 0.13877312858099944, 0.13877312858099944, 0.16394864668180964, 0.16394864668180964, 0.16394864668180964, 0.106983464837763, 0.106983464837763, 0.106983464837763, 0.9833546527525331, 0.9833546527525331, 0.9833546527525331, 0.9871313878785951, 0.9871313878785951, 0.9871313878785951, 0.9817460938216568, 0.9817460938216568, 0.9817460938216568, 0.5820647468399778, 0.5820647468399778, 0.5820647468399778, 0.5446083930761287, 0.5446083930761287, 0.5446083930761287, 0.5735670160387314, 0.5735670160387314, 0.5735670160387314, 0.2197311247121485, 0.2197311247121485, 0.2197311247121485, 0.16132007176289376, 0.16132007176289376, 0.16132007176289376, 0.7078661361365761, 0.7078661361365761, 0.7078661361365761, 0.1996177304793869, 0.1996177304793869, 0.1996177304793869, 0.12780709631056675, 0.12780709631056675, 0.12780709631056675, 0.20555026150760514, 0.20555026150760514, 0.20555026150760514, 0.19918634790123801, 0.19918634790123801, 0.19918634790123801, 0.21048500386138347, 0.21048500386138347, 0.21048500386138347, 0.265579617205571, 0.265579617205571, 0.265579617205571, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09428504371207602, 0.09428504371207602, 0.09428504371207602, 0.01991175618718133, 0.01991175618718133, 0.01991175618718133, 0.06642275106211692, 0.06642275106211692, 0.06642275106211692, 0.04373465400248244, 0.04373465400248244, 0.04373465400248244, 0.09310101598527087, 0.09310101598527087, 0.09310101598527087, 0.07615637129858166, 0.07615637129858166, 0.07615637129858166, 0.07974302301078917, 0.07974302301078917, 0.07974302301078917, 0.050207487838534015, 0.050207487838534015, 0.050207487838534015, 0.04685865342759776, 0.04685865342759776, 0.04685865342759776, 0.5195100270572666, 0.5195100270572666, 0.5195100270572666, 0.5331861591862977, 0.5331861591862977, 0.5331861591862977, 0.5413251420174898, 0.5413251420174898, 0.5413251420174898, 0.11241096298877673, 0.11241096298877673, 0.11241096298877673, 0.10299573395792672, 0.10299573395792672, 0.10299573395792672, 0.40738118887301233, 0.40738118887301233, 0.40738118887301233, 0.16934426381011713, 0.16934426381011713, 0.16934426381011713, 0.17128568515585718, 0.17128568515585718, 0.17128568515585718, 0.13050377128370405, 0.13050377128370405, 0.13050377128370405, 0.3911132631683045, 0.3911132631683045, 0.3911132631683045, 0.19415628518283057, 0.19415628518283057, 0.19415628518283057, 0.515129186931616, 0.515129186931616, 0.515129186931616, 0.2099387671906633, 0.2099387671906633, 0.2099387671906633, 0.20526375682955422, 0.20526375682955422, 0.20526375682955422, 0.20666130072041344, 0.20666130072041344, 0.20666130072041344, 0.209620588536216, 0.209620588536216, 0.209620588536216, 0.1989464359104225, 0.1989464359104225, 0.1989464359104225, 0.2049056851416189, 0.2049056851416189, 0.2049056851416189, 0.19364744868989414, 0.19364744868989414, 0.19364744868989414, 0.23608526345919156, 0.23608526345919156, 0.23608526345919156, 0.1985927714016671, 0.1985927714016671, 0.1985927714016671, 0.8520778690506763, 0.8520778690506763, 0.8520778690506763, 0.7542002080453417, 0.7542002080453417, 0.7542002080453417, 0.18541494385062096, 0.18541494385062096, 0.18541494385062096, 0.1678975634713088, 0.1678975634713088, 0.1678975634713088, 0.5589881235225369, 0.5589881235225369, 0.5589881235225369, 0.1659561657278873, 0.1659561657278873, 0.1659561657278873, 0.19982273744316237, 0.19982273744316237, 0.19982273744316237, 0.20512383099239095, 0.20512383099239095, 0.20512383099239095, 0.19766645338661815, 0.19766645338661815, 0.19766645338661815, 0.08789598392282372, 0.08789598392282372, 0.08789598392282372, 0.07988448659876135, 0.07988448659876135, 0.07988448659876135, 0.08515833433661935, 0.08515833433661935, 0.08515833433661935]}, "mutation_prompt": null}
{"id": "1c87a459-7c5c-4323-9078-49b9da8f0d56", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F_initial = 0.8  # Initial DE scaling factor\n        self.F_final = 0.5  # Final DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Calculate dynamic DE scaling factor\n            self.F = self.F_initial - (self.F_initial - self.F_final) * (eval_count / self.budget)\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a dynamic DE scaling factor that decreases linearly over iterations to balance exploration and exploitation.", "configspace": "", "generation": 34, "fitness": 0.27550743826706775, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.25.", "error": "", "parent_id": "08d79927-d144-4cc2-a5a0-35b395ae3b32", "metadata": {"aucs": [0.7744372800666813, 0.7744372800666813, 0.7744372800666813, 0.7884261988464629, 0.7884261988464629, 0.7884261988464629, 0.7966366320804128, 0.7966366320804128, 0.7966366320804128, 0.4705267080050529, 0.4705267080050529, 0.4705267080050529, 0.5670910856580669, 0.5670910856580669, 0.5670910856580669, 0.01664349669594667, 0.01664349669594667, 0.01664349669594667, 0.15654482236316902, 0.15654482236316902, 0.15654482236316902, 0.1326446086851898, 0.1326446086851898, 0.1326446086851898, 0.15105579997609908, 0.15105579997609908, 0.15105579997609908, 0.12992436236510807, 0.12992436236510807, 0.12992436236510807, 0.1140770226524146, 0.1140770226524146, 0.1140770226524146, 0.10218849135919827, 0.10218849135919827, 0.10218849135919827, 0.9833541204063894, 0.9833541204063894, 0.9833541204063894, 0.9871306837821138, 0.9871306837821138, 0.9871306837821138, 0.9817437932635988, 0.9817437932635988, 0.9817437932635988, 0.5934151133206569, 0.5934151133206569, 0.5934151133206569, 0.611427977673633, 0.611427977673633, 0.611427977673633, 0.5984329451794634, 0.5984329451794634, 0.5984329451794634, 0.3651714073172003, 0.3651714073172003, 0.3651714073172003, 0.16130529872264032, 0.16130529872264032, 0.16130529872264032, 0.22955524649444237, 0.22955524649444237, 0.22955524649444237, 0.20054822609430933, 0.20054822609430933, 0.20054822609430933, 0.1896563583492259, 0.1896563583492259, 0.1896563583492259, 0.1922680850099685, 0.1922680850099685, 0.1922680850099685, 0.12290171728449328, 0.12290171728449328, 0.12290171728449328, 0.19242624672551278, 0.19242624672551278, 0.19242624672551278, 0.23981700733749145, 0.23981700733749145, 0.23981700733749145, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11832266038210981, 0.11832266038210981, 0.11832266038210981, 0.008845237008367035, 0.008845237008367035, 0.008845237008367035, 0.08192273860229127, 0.08192273860229127, 0.08192273860229127, 0.04090928784772874, 0.04090928784772874, 0.04090928784772874, 0.10763150108218544, 0.10763150108218544, 0.10763150108218544, 0.07165169889070255, 0.07165169889070255, 0.07165169889070255, 0.10314191039590803, 0.10314191039590803, 0.10314191039590803, 0.036644568496562946, 0.036644568496562946, 0.036644568496562946, 0.047604106379916855, 0.047604106379916855, 0.047604106379916855, 0.5045517968830303, 0.5045517968830303, 0.5045517968830303, 0.5603437623710612, 0.5603437623710612, 0.5603437623710612, 0.5399650739731499, 0.5399650739731499, 0.5399650739731499, 0.09960282267956222, 0.09960282267956222, 0.09960282267956222, 0.10315405467962702, 0.10315405467962702, 0.10315405467962702, 0.09632194295251595, 0.09632194295251595, 0.09632194295251595, 0.1566456351746941, 0.1566456351746941, 0.1566456351746941, 0.1726584416326692, 0.1726584416326692, 0.1726584416326692, 0.20584072587821978, 0.20584072587821978, 0.20584072587821978, 0.3984306258373004, 0.3984306258373004, 0.3984306258373004, 0.22191757718523275, 0.22191757718523275, 0.22191757718523275, 0.4703550759214131, 0.4703550759214131, 0.4703550759214131, 0.16456424006407178, 0.16456424006407178, 0.16456424006407178, 0.1849398554907402, 0.1849398554907402, 0.1849398554907402, 0.23421854338695636, 0.23421854338695636, 0.23421854338695636, 0.2082259472665181, 0.2082259472665181, 0.2082259472665181, 0.2116462846449072, 0.2116462846449072, 0.2116462846449072, 0.22764025737799598, 0.22764025737799598, 0.22764025737799598, 0.21791045953780208, 0.21791045953780208, 0.21791045953780208, 0.19923228374710789, 0.19923228374710789, 0.19923228374710789, 0.22954506476709158, 0.22954506476709158, 0.22954506476709158, 0.8426612651326975, 0.8426612651326975, 0.8426612651326975, 0.16994149128907898, 0.16994149128907898, 0.16994149128907898, 0.1853560208456383, 0.1853560208456383, 0.1853560208456383, 0.1658775123590942, 0.1658775123590942, 0.1658775123590942, 0.5917502423518358, 0.5917502423518358, 0.5917502423518358, 0.1637656787493006, 0.1637656787493006, 0.1637656787493006, 0.19058998555397322, 0.19058998555397322, 0.19058998555397322, 0.20597390536572557, 0.20597390536572557, 0.20597390536572557, 0.18596574611864414, 0.18596574611864414, 0.18596574611864414, 0.08826872919909146, 0.08826872919909146, 0.08826872919909146, 0.08218347842291829, 0.08218347842291829, 0.08218347842291829, 0.09016658358849639, 0.09016658358849639, 0.09016658358849639]}, "mutation_prompt": null}
{"id": "079f7d2a-609d-44ee-8bb1-0191036c2212", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a dynamic crossover probability adjustment to enhance exploration and convergence adaptively.", "configspace": "", "generation": 35, "fitness": 0.3080118849454403, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "08d79927-d144-4cc2-a5a0-35b395ae3b32", "metadata": {"aucs": [0.7972135001875267, 0.7972135001875267, 0.7972135001875267, 0.7827070990845291, 0.7827070990845291, 0.7827070990845291, 0.8025122245282456, 0.8025122245282456, 0.8025122245282456, 0.5852561590897933, 0.5852561590897933, 0.5852561590897933, 0.5814276675436745, 0.5814276675436745, 0.5814276675436745, 0.5865243103582025, 0.5865243103582025, 0.5865243103582025, 0.14729906130494597, 0.14729906130494597, 0.14729906130494597, 0.4646831752751186, 0.4646831752751186, 0.4646831752751186, 0.16652291108664852, 0.16652291108664852, 0.16652291108664852, 0.10466767754362083, 0.10466767754362083, 0.10466767754362083, 0.09291236323231444, 0.09291236323231444, 0.09291236323231444, 0.10517235882147069, 0.10517235882147069, 0.10517235882147069, 0.9833545195335007, 0.9833545195335007, 0.9833545195335007, 0.9871312113475053, 0.9871312113475053, 0.9871312113475053, 0.9817455104503656, 0.9817455104503656, 0.9817455104503656, 0.5806944519409704, 0.5806944519409704, 0.5806944519409704, 0.14423568085985283, 0.14423568085985283, 0.14423568085985283, 0.5911785299343953, 0.5911785299343953, 0.5911785299343953, 0.7400072527876258, 0.7400072527876258, 0.7400072527876258, 0.26202650903954405, 0.26202650903954405, 0.26202650903954405, 0.21908199948287288, 0.21908199948287288, 0.21908199948287288, 0.20192541633565386, 0.20192541633565386, 0.20192541633565386, 0.19904632776676057, 0.19904632776676057, 0.19904632776676057, 0.22538103130323728, 0.22538103130323728, 0.22538103130323728, 0.1998007651684518, 0.1998007651684518, 0.1998007651684518, 0.1995406537348675, 0.1995406537348675, 0.1995406537348675, 0.24654441451171283, 0.24654441451171283, 0.24654441451171283, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09722994563995213, 0.09722994563995213, 0.09722994563995213, 0.09748822614305641, 0.09748822614305641, 0.09748822614305641, 0.10104045285987595, 0.10104045285987595, 0.10104045285987595, 0.042641874991652395, 0.042641874991652395, 0.042641874991652395, 0.09841498793876513, 0.09841498793876513, 0.09841498793876513, 0.07558965107527604, 0.07558965107527604, 0.07558965107527604, 0.20657030904989082, 0.20657030904989082, 0.20657030904989082, 0.03642382602512517, 0.03642382602512517, 0.03642382602512517, 0.048298767491661954, 0.048298767491661954, 0.048298767491661954, 0.5614216874681467, 0.5614216874681467, 0.5614216874681467, 0.49657700220533374, 0.49657700220533374, 0.49657700220533374, 0.5170455187243754, 0.5170455187243754, 0.5170455187243754, 0.13508326494619027, 0.13508326494619027, 0.13508326494619027, 0.11950025422041399, 0.11950025422041399, 0.11950025422041399, 0.11512622398485983, 0.11512622398485983, 0.11512622398485983, 0.1534042770376467, 0.1534042770376467, 0.1534042770376467, 0.17247856409263362, 0.17247856409263362, 0.17247856409263362, 0.1854014647609713, 0.1854014647609713, 0.1854014647609713, 0.37720084702576306, 0.37720084702576306, 0.37720084702576306, 0.25273891203489507, 0.25273891203489507, 0.25273891203489507, 0.29120254634287, 0.29120254634287, 0.29120254634287, 0.2313683903750654, 0.2313683903750654, 0.2313683903750654, 0.1971470274093733, 0.1971470274093733, 0.1971470274093733, 0.28983987274269485, 0.28983987274269485, 0.28983987274269485, 0.21232565905441736, 0.21232565905441736, 0.21232565905441736, 0.2116917203990608, 0.2116917203990608, 0.2116917203990608, 0.2117417245344626, 0.2117417245344626, 0.2117417245344626, 0.6567070012885114, 0.6567070012885114, 0.6567070012885114, 0.2002749375160504, 0.2002749375160504, 0.2002749375160504, 0.23261418999257366, 0.23261418999257366, 0.23261418999257366, 0.8513823302653051, 0.8513823302653051, 0.8513823302653051, 0.8145276842865627, 0.8145276842865627, 0.8145276842865627, 0.185066515166604, 0.185066515166604, 0.185066515166604, 0.16575140942497746, 0.16575140942497746, 0.16575140942497746, 0.5666900485617927, 0.5666900485617927, 0.5666900485617927, 0.16399352629422792, 0.16399352629422792, 0.16399352629422792, 0.1898442051167626, 0.1898442051167626, 0.1898442051167626, 0.18695400864257494, 0.18695400864257494, 0.18695400864257494, 0.1950965428045024, 0.1950965428045024, 0.1950965428045024, 0.08470179797976873, 0.08470179797976873, 0.08470179797976873, 0.08797544648693856, 0.08797544648693856, 0.08797544648693856, 0.0813902914167105, 0.0813902914167105, 0.0813902914167105]}, "mutation_prompt": null}
{"id": "c42d646b-912f-4c47-be07-62ffcc1cf65b", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a dynamic crossover probability adjustment to enhance exploration and convergence adaptively.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "079f7d2a-609d-44ee-8bb1-0191036c2212", "metadata": {"aucs": [0.7972135001875267, 0.7972135001875267, 0.7972135001875267, 0.7827070990845291, 0.7827070990845291, 0.7827070990845291, 0.8025122245282456, 0.8025122245282456, 0.8025122245282456, 0.5852561590897933, 0.5852561590897933, 0.5852561590897933, 0.5814276675436745, 0.5814276675436745, 0.5814276675436745, 0.5865243103582025, 0.5865243103582025, 0.5865243103582025, 0.14729906130494597, 0.14729906130494597, 0.14729906130494597, 0.4646831752751186, 0.4646831752751186, 0.4646831752751186, 0.16652291108664852, 0.16652291108664852, 0.16652291108664852, 0.10466767754362083, 0.10466767754362083, 0.10466767754362083, 0.09291236323231444, 0.09291236323231444, 0.09291236323231444, 0.10517235882147069, 0.10517235882147069, 0.10517235882147069, 0.9833545195335007, 0.9833545195335007, 0.9833545195335007, 0.9871312113475053, 0.9871312113475053, 0.9871312113475053, 0.9817455104503656, 0.9817455104503656, 0.9817455104503656, 0.5806944519409704, 0.5806944519409704, 0.5806944519409704, 0.14423568085985283, 0.14423568085985283, 0.14423568085985283, 0.5911785299343953, 0.5911785299343953, 0.5911785299343953, 0.7400072527876258, 0.7400072527876258, 0.7400072527876258, 0.26202650903954405, 0.26202650903954405, 0.26202650903954405, 0.21908199948287288, 0.21908199948287288, 0.21908199948287288, 0.20192541633565386, 0.20192541633565386, 0.20192541633565386, 0.19904632776676057, 0.19904632776676057, 0.19904632776676057, 0.22538103130323728, 0.22538103130323728, 0.22538103130323728, 0.1998007651684518, 0.1998007651684518, 0.1998007651684518, 0.1995406537348675, 0.1995406537348675, 0.1995406537348675, 0.24654441451171283, 0.24654441451171283, 0.24654441451171283, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09722994563995213, 0.09722994563995213, 0.09722994563995213, 0.09748822614305641, 0.09748822614305641, 0.09748822614305641, 0.10104045285987595, 0.10104045285987595, 0.10104045285987595, 0.042641874991652395, 0.042641874991652395, 0.042641874991652395, 0.09841498793876513, 0.09841498793876513, 0.09841498793876513, 0.07558965107527604, 0.07558965107527604, 0.07558965107527604, 0.20657030904989082, 0.20657030904989082, 0.20657030904989082, 0.03642382602512517, 0.03642382602512517, 0.03642382602512517, 0.048298767491661954, 0.048298767491661954, 0.048298767491661954, 0.5614216874681467, 0.5614216874681467, 0.5614216874681467, 0.49657700220533374, 0.49657700220533374, 0.49657700220533374, 0.5170455187243754, 0.5170455187243754, 0.5170455187243754, 0.13508326494619027, 0.13508326494619027, 0.13508326494619027, 0.11950025422041399, 0.11950025422041399, 0.11950025422041399, 0.11512622398485983, 0.11512622398485983, 0.11512622398485983, 0.1534042770376467, 0.1534042770376467, 0.1534042770376467, 0.17247856409263362, 0.17247856409263362, 0.17247856409263362, 0.1854014647609713, 0.1854014647609713, 0.1854014647609713, 0.37720084702576306, 0.37720084702576306, 0.37720084702576306, 0.25273891203489507, 0.25273891203489507, 0.25273891203489507, 0.29120254634287, 0.29120254634287, 0.29120254634287, 0.2313683903750654, 0.2313683903750654, 0.2313683903750654, 0.1971470274093733, 0.1971470274093733, 0.1971470274093733, 0.28983987274269485, 0.28983987274269485, 0.28983987274269485, 0.21232565905441736, 0.21232565905441736, 0.21232565905441736, 0.2116917203990608, 0.2116917203990608, 0.2116917203990608, 0.2117417245344626, 0.2117417245344626, 0.2117417245344626, 0.6567070012885114, 0.6567070012885114, 0.6567070012885114, 0.2002749375160504, 0.2002749375160504, 0.2002749375160504, 0.23261418999257366, 0.23261418999257366, 0.23261418999257366, 0.8513823302653051, 0.8513823302653051, 0.8513823302653051, 0.8145276842865627, 0.8145276842865627, 0.8145276842865627, 0.185066515166604, 0.185066515166604, 0.185066515166604, 0.16575140942497746, 0.16575140942497746, 0.16575140942497746, 0.5666900485617927, 0.5666900485617927, 0.5666900485617927, 0.16399352629422792, 0.16399352629422792, 0.16399352629422792, 0.1898442051167626, 0.1898442051167626, 0.1898442051167626, 0.18695400864257494, 0.18695400864257494, 0.18695400864257494, 0.1950965428045024, 0.1950965428045024, 0.1950965428045024, 0.08470179797976873, 0.08470179797976873, 0.08470179797976873, 0.08797544648693856, 0.08797544648693856, 0.08797544648693856, 0.0813902914167105, 0.0813902914167105, 0.0813902914167105]}, "mutation_prompt": null}
{"id": "4f980374-fabd-4ca4-98c4-1730fdb0c6ba", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a dynamic crossover probability adjustment to enhance exploration and convergence adaptively.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "079f7d2a-609d-44ee-8bb1-0191036c2212", "metadata": {"aucs": [0.7972135001875267, 0.7972135001875267, 0.7972135001875267, 0.7827070990845291, 0.7827070990845291, 0.7827070990845291, 0.8025122245282456, 0.8025122245282456, 0.8025122245282456, 0.5852561590897933, 0.5852561590897933, 0.5852561590897933, 0.5814276675436745, 0.5814276675436745, 0.5814276675436745, 0.5865243103582025, 0.5865243103582025, 0.5865243103582025, 0.14729906130494597, 0.14729906130494597, 0.14729906130494597, 0.4646831752751186, 0.4646831752751186, 0.4646831752751186, 0.16652291108664852, 0.16652291108664852, 0.16652291108664852, 0.10466767754362083, 0.10466767754362083, 0.10466767754362083, 0.09291236323231444, 0.09291236323231444, 0.09291236323231444, 0.10517235882147069, 0.10517235882147069, 0.10517235882147069, 0.9833545195335007, 0.9833545195335007, 0.9833545195335007, 0.9871312113475053, 0.9871312113475053, 0.9871312113475053, 0.9817455104503656, 0.9817455104503656, 0.9817455104503656, 0.5806944519409704, 0.5806944519409704, 0.5806944519409704, 0.14423568085985283, 0.14423568085985283, 0.14423568085985283, 0.5911785299343953, 0.5911785299343953, 0.5911785299343953, 0.7400072527876258, 0.7400072527876258, 0.7400072527876258, 0.26202650903954405, 0.26202650903954405, 0.26202650903954405, 0.21908199948287288, 0.21908199948287288, 0.21908199948287288, 0.20192541633565386, 0.20192541633565386, 0.20192541633565386, 0.19904632776676057, 0.19904632776676057, 0.19904632776676057, 0.22538103130323728, 0.22538103130323728, 0.22538103130323728, 0.1998007651684518, 0.1998007651684518, 0.1998007651684518, 0.1995406537348675, 0.1995406537348675, 0.1995406537348675, 0.24654441451171283, 0.24654441451171283, 0.24654441451171283, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09722994563995213, 0.09722994563995213, 0.09722994563995213, 0.09748822614305641, 0.09748822614305641, 0.09748822614305641, 0.10104045285987595, 0.10104045285987595, 0.10104045285987595, 0.042641874991652395, 0.042641874991652395, 0.042641874991652395, 0.09841498793876513, 0.09841498793876513, 0.09841498793876513, 0.07558965107527604, 0.07558965107527604, 0.07558965107527604, 0.20657030904989082, 0.20657030904989082, 0.20657030904989082, 0.03642382602512517, 0.03642382602512517, 0.03642382602512517, 0.048298767491661954, 0.048298767491661954, 0.048298767491661954, 0.5614216874681467, 0.5614216874681467, 0.5614216874681467, 0.49657700220533374, 0.49657700220533374, 0.49657700220533374, 0.5170455187243754, 0.5170455187243754, 0.5170455187243754, 0.13508326494619027, 0.13508326494619027, 0.13508326494619027, 0.11950025422041399, 0.11950025422041399, 0.11950025422041399, 0.11512622398485983, 0.11512622398485983, 0.11512622398485983, 0.1534042770376467, 0.1534042770376467, 0.1534042770376467, 0.17247856409263362, 0.17247856409263362, 0.17247856409263362, 0.1854014647609713, 0.1854014647609713, 0.1854014647609713, 0.37720084702576306, 0.37720084702576306, 0.37720084702576306, 0.25273891203489507, 0.25273891203489507, 0.25273891203489507, 0.29120254634287, 0.29120254634287, 0.29120254634287, 0.2313683903750654, 0.2313683903750654, 0.2313683903750654, 0.1971470274093733, 0.1971470274093733, 0.1971470274093733, 0.28983987274269485, 0.28983987274269485, 0.28983987274269485, 0.21232565905441736, 0.21232565905441736, 0.21232565905441736, 0.2116917203990608, 0.2116917203990608, 0.2116917203990608, 0.2117417245344626, 0.2117417245344626, 0.2117417245344626, 0.6567070012885114, 0.6567070012885114, 0.6567070012885114, 0.2002749375160504, 0.2002749375160504, 0.2002749375160504, 0.23261418999257366, 0.23261418999257366, 0.23261418999257366, 0.8513823302653051, 0.8513823302653051, 0.8513823302653051, 0.8145276842865627, 0.8145276842865627, 0.8145276842865627, 0.185066515166604, 0.185066515166604, 0.185066515166604, 0.16575140942497746, 0.16575140942497746, 0.16575140942497746, 0.5666900485617927, 0.5666900485617927, 0.5666900485617927, 0.16399352629422792, 0.16399352629422792, 0.16399352629422792, 0.1898442051167626, 0.1898442051167626, 0.1898442051167626, 0.18695400864257494, 0.18695400864257494, 0.18695400864257494, 0.1950965428045024, 0.1950965428045024, 0.1950965428045024, 0.08470179797976873, 0.08470179797976873, 0.08470179797976873, 0.08797544648693856, 0.08797544648693856, 0.08797544648693856, 0.0813902914167105, 0.0813902914167105, 0.0813902914167105]}, "mutation_prompt": null}
{"id": "f5d50878-ab3c-45e5-a16d-1a30025285ca", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F_initial = 0.8  # Initial DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n        stagnation_counter = np.zeros(self.population_size)\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n            # Adaptive DE scaling factor\n            self.F = self.F_initial + 0.2 * (eval_count / self.budget)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n                    stagnation_counter[i] = 0  # Reset stagnation counter\n                else:\n                    stagnation_counter[i] += 1\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n                # Random reinitialization if stagnated\n                if stagnation_counter[i] > 10:\n                    pop[i] = np.random.uniform(lower, upper, self.dim)\n                    stagnation_counter[i] = 0\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Enhance convergence speed by introducing adaptive mutation scaling in DE and random reinitialization of stagnated particles.", "configspace": "", "generation": 38, "fitness": 0.26808023022552074, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.25.", "error": "", "parent_id": "079f7d2a-609d-44ee-8bb1-0191036c2212", "metadata": {"aucs": [0.7853255327701699, 0.7853255327701699, 0.7853255327701699, 0.7614126060650096, 0.7614126060650096, 0.7614126060650096, 0.7972888148434338, 0.7972888148434338, 0.7972888148434338, 0.5495421285967341, 0.5495421285967341, 0.5495421285967341, 0.5855926283191286, 0.5855926283191286, 0.5855926283191286, 0.556262614419248, 0.556262614419248, 0.556262614419248, 0.1379729397097088, 0.1379729397097088, 0.1379729397097088, 0.11060898481954318, 0.11060898481954318, 0.11060898481954318, 0.1315356228383482, 0.1315356228383482, 0.1315356228383482, 0.11407908089907126, 0.11407908089907126, 0.11407908089907126, 0.122830557225858, 0.122830557225858, 0.122830557225858, 0.1016944854008276, 0.1016944854008276, 0.1016944854008276, 0.983354554505733, 0.983354554505733, 0.983354554505733, 0.9871315187575651, 0.9871315187575651, 0.9871315187575651, 0.9817468702688955, 0.9817468702688955, 0.9817468702688955, 0.5009762260995979, 0.5009762260995979, 0.5009762260995979, 0.40363189234469343, 0.40363189234469343, 0.40363189234469343, 0.399782021813783, 0.399782021813783, 0.399782021813783, 0.3201762361952758, 0.3201762361952758, 0.3201762361952758, 0.1612991940824492, 0.1612991940824492, 0.1612991940824492, 0.22859888667661754, 0.22859888667661754, 0.22859888667661754, 0.16834196008754532, 0.16834196008754532, 0.16834196008754532, 0.1668003411712582, 0.1668003411712582, 0.1668003411712582, 0.14239358173808503, 0.14239358173808503, 0.14239358173808503, 0.17157712862588415, 0.17157712862588415, 0.17157712862588415, 0.15091740970525203, 0.15091740970525203, 0.15091740970525203, 0.2095267548257268, 0.2095267548257268, 0.2095267548257268, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11232411779582596, 0.11232411779582596, 0.11232411779582596, 0.023959064049874135, 0.023959064049874135, 0.023959064049874135, 0.09057893023323982, 0.09057893023323982, 0.09057893023323982, 0.04191222219088009, 0.04191222219088009, 0.04191222219088009, 0.10807056722443464, 0.10807056722443464, 0.10807056722443464, 0.07503834136857745, 0.07503834136857745, 0.07503834136857745, 0.03337592491865149, 0.03337592491865149, 0.03337592491865149, 0.036234089825937565, 0.036234089825937565, 0.036234089825937565, 0.04863186038645306, 0.04863186038645306, 0.04863186038645306, 0.46252512277842883, 0.46252512277842883, 0.46252512277842883, 0.46760803230181924, 0.46760803230181924, 0.46760803230181924, 0.5137614711477629, 0.5137614711477629, 0.5137614711477629, 0.11291454118182642, 0.11291454118182642, 0.11291454118182642, 0.09037909373826547, 0.09037909373826547, 0.09037909373826547, 0.10944078398181356, 0.10944078398181356, 0.10944078398181356, 0.1616119361947922, 0.1616119361947922, 0.1616119361947922, 0.17270388533784464, 0.17270388533784464, 0.17270388533784464, 0.16543703010297395, 0.16543703010297395, 0.16543703010297395, 0.2960399564850571, 0.2960399564850571, 0.2960399564850571, 0.1919892633657324, 0.1919892633657324, 0.1919892633657324, 0.25912623856023775, 0.25912623856023775, 0.25912623856023775, 0.16566642604309, 0.16566642604309, 0.16566642604309, 0.1771890090151803, 0.1771890090151803, 0.1771890090151803, 0.2763630769820401, 0.2763630769820401, 0.2763630769820401, 0.2064702521201548, 0.2064702521201548, 0.2064702521201548, 0.1945366363649237, 0.1945366363649237, 0.1945366363649237, 0.2255216905763593, 0.2255216905763593, 0.2255216905763593, 0.2094837825687993, 0.2094837825687993, 0.2094837825687993, 0.2030058821198314, 0.2030058821198314, 0.2030058821198314, 0.19957715096615702, 0.19957715096615702, 0.19957715096615702, 0.8498588473652476, 0.8498588473652476, 0.8498588473652476, 0.7619956611678487, 0.7619956611678487, 0.7619956611678487, 0.1851093526553299, 0.1851093526553299, 0.1851093526553299, 0.1657704538878284, 0.1657704538878284, 0.1657704538878284, 0.21919681828663906, 0.21919681828663906, 0.21919681828663906, 0.1644581358249858, 0.1644581358249858, 0.1644581358249858, 0.19003328987824042, 0.19003328987824042, 0.19003328987824042, 0.17507559319253962, 0.17507559319253962, 0.17507559319253962, 0.18779363205212252, 0.18779363205212252, 0.18779363205212252, 0.07750106914549193, 0.07750106914549193, 0.07750106914549193, 0.07497377035648911, 0.07497377035648911, 0.07497377035648911, 0.0878329996923225, 0.0878329996923225, 0.0878329996923225]}, "mutation_prompt": null}
{"id": "ee6c78c7-211d-493d-91af-a4318239c5b5", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F_initial = 0.8  # Initial DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n            # Dynamic mutation scaling\n            self.F = self.F_initial * (1 - eval_count / self.budget)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce dynamic mutation scaling to enhance exploration-exploitation balance and convergence.", "configspace": "", "generation": 39, "fitness": 0.2948027086518936, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.26.", "error": "", "parent_id": "079f7d2a-609d-44ee-8bb1-0191036c2212", "metadata": {"aucs": [0.7729493641918331, 0.7729493641918331, 0.7729493641918331, 0.8013806445831528, 0.8013806445831528, 0.8013806445831528, 0.7975633008296097, 0.7975633008296097, 0.7975633008296097, 0.5673038458854289, 0.5673038458854289, 0.5673038458854289, 0.5600856395483542, 0.5600856395483542, 0.5600856395483542, 0.015301850277443574, 0.015301850277443574, 0.015301850277443574, 0.14467363239789377, 0.14467363239789377, 0.14467363239789377, 0.14275710390349816, 0.14275710390349816, 0.14275710390349816, 0.3829878414195157, 0.3829878414195157, 0.3829878414195157, 0.13196789223388006, 0.13196789223388006, 0.13196789223388006, 0.09031762789082654, 0.09031762789082654, 0.09031762789082654, 0.1070962977073826, 0.1070962977073826, 0.1070962977073826, 0.9833543808881888, 0.9833543808881888, 0.9833543808881888, 0.9871299893434242, 0.9871299893434242, 0.9871299893434242, 0.9817402470424116, 0.9817402470424116, 0.9817402470424116, 0.6205539080021107, 0.6205539080021107, 0.6205539080021107, 0.14452921213359837, 0.14452921213359837, 0.14452921213359837, 0.5780778251309948, 0.5780778251309948, 0.5780778251309948, 0.3630113467292585, 0.3630113467292585, 0.3630113467292585, 0.16098244319036004, 0.16098244319036004, 0.16098244319036004, 0.29995254281259276, 0.29995254281259276, 0.29995254281259276, 0.20056356609801895, 0.20056356609801895, 0.20056356609801895, 0.12449256411283094, 0.12449256411283094, 0.12449256411283094, 0.1880248395251587, 0.1880248395251587, 0.1880248395251587, 0.1880134109826359, 0.1880134109826359, 0.1880134109826359, 0.23816372130911945, 0.23816372130911945, 0.23816372130911945, 0.25151072890465365, 0.25151072890465365, 0.25151072890465365, 0.00044273047738985216, 0.00044273047738985216, 0.00044273047738985216, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.17559515033574657, 0.17559515033574657, 0.17559515033574657, 0.036007050814216957, 0.036007050814216957, 0.036007050814216957, 0.06194758122291255, 0.06194758122291255, 0.06194758122291255, 0.042275126955071185, 0.042275126955071185, 0.042275126955071185, 0.10156763741917474, 0.10156763741917474, 0.10156763741917474, 0.08956570715962786, 0.08956570715962786, 0.08956570715962786, 0.14274002839122713, 0.14274002839122713, 0.14274002839122713, 0.03560083596722563, 0.03560083596722563, 0.03560083596722563, 0.05467443907492364, 0.05467443907492364, 0.05467443907492364, 0.5072343988335288, 0.5072343988335288, 0.5072343988335288, 0.5362763361480885, 0.5362763361480885, 0.5362763361480885, 0.5188981708308379, 0.5188981708308379, 0.5188981708308379, 0.0981897148498263, 0.0981897148498263, 0.0981897148498263, 0.16128648171279836, 0.16128648171279836, 0.16128648171279836, 0.11573978563300369, 0.11573978563300369, 0.11573978563300369, 0.29458828097652623, 0.29458828097652623, 0.29458828097652623, 0.1728889278139486, 0.1728889278139486, 0.1728889278139486, 0.20740211936069963, 0.20740211936069963, 0.20740211936069963, 0.30074524777661404, 0.30074524777661404, 0.30074524777661404, 0.21318562670275765, 0.21318562670275765, 0.21318562670275765, 0.5179530029431278, 0.5179530029431278, 0.5179530029431278, 0.2245736810614931, 0.2245736810614931, 0.2245736810614931, 0.21501072978235047, 0.21501072978235047, 0.21501072978235047, 0.24066903186986244, 0.24066903186986244, 0.24066903186986244, 0.21412099086009073, 0.21412099086009073, 0.21412099086009073, 0.21017183444834286, 0.21017183444834286, 0.21017183444834286, 0.22140099005882963, 0.22140099005882963, 0.22140099005882963, 0.2019312317068518, 0.2019312317068518, 0.2019312317068518, 0.23810766204859846, 0.23810766204859846, 0.23810766204859846, 0.610176967891077, 0.610176967891077, 0.610176967891077, 0.8609294557087512, 0.8609294557087512, 0.8609294557087512, 0.802675486357993, 0.802675486357993, 0.802675486357993, 0.18483267953506433, 0.18483267953506433, 0.18483267953506433, 0.1656691135488798, 0.1656691135488798, 0.1656691135488798, 0.5953410176460476, 0.5953410176460476, 0.5953410176460476, 0.16366716718083485, 0.16366716718083485, 0.16366716718083485, 0.20284642980822343, 0.20284642980822343, 0.20284642980822343, 0.19773923789898207, 0.19773923789898207, 0.19773923789898207, 0.19146099537890393, 0.19146099537890393, 0.19146099537890393, 0.09034694417238642, 0.09034694417238642, 0.09034694417238642, 0.08700150665695405, 0.08700150665695405, 0.08700150665695405, 0.09763172084237426, 0.09763172084237426, 0.09763172084237426]}, "mutation_prompt": null}
{"id": "a56aa591-5932-4a43-a16a-9e9176c940ec", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F_initial = 0.8   # Initial DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n            # Adaptive scaling factor\n            self.F = self.F_initial + 0.2 * (eval_count / self.budget)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Integrate an adaptive F scaling factor to improve global exploration and convergence rate.", "configspace": "", "generation": 40, "fitness": 0.30673397648262885, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.27.", "error": "", "parent_id": "079f7d2a-609d-44ee-8bb1-0191036c2212", "metadata": {"aucs": [0.7781554260061583, 0.7781554260061583, 0.7781554260061583, 0.7845458520825074, 0.7845458520825074, 0.7845458520825074, 0.7960129638057337, 0.7960129638057337, 0.7960129638057337, 0.5795632215188639, 0.5795632215188639, 0.5795632215188639, 0.5699327429098707, 0.5699327429098707, 0.5699327429098707, 0.6066764814873391, 0.6066764814873391, 0.6066764814873391, 0.14201618478223244, 0.14201618478223244, 0.14201618478223244, 0.071419233653505, 0.071419233653505, 0.071419233653505, 0.12881389762951279, 0.12881389762951279, 0.12881389762951279, 0.11124269594700165, 0.11124269594700165, 0.11124269594700165, 0.12744740567455115, 0.12744740567455115, 0.12744740567455115, 0.13086417759882385, 0.13086417759882385, 0.13086417759882385, 0.983354554505733, 0.983354554505733, 0.983354554505733, 0.9871315187575651, 0.9871315187575651, 0.9871315187575651, 0.9817468702688955, 0.9817468702688955, 0.9817468702688955, 0.6122794215832744, 0.6122794215832744, 0.6122794215832744, 0.5532649316092175, 0.5532649316092175, 0.5532649316092175, 0.5756752824580916, 0.5756752824580916, 0.5756752824580916, 0.6165328353296926, 0.6165328353296926, 0.6165328353296926, 0.2524129518133422, 0.2524129518133422, 0.2524129518133422, 0.36119668801193716, 0.36119668801193716, 0.36119668801193716, 0.19772716246340127, 0.19772716246340127, 0.19772716246340127, 0.20095921247364779, 0.20095921247364779, 0.20095921247364779, 0.23205031417484057, 0.23205031417484057, 0.23205031417484057, 0.20353476672331428, 0.20353476672331428, 0.20353476672331428, 0.19048830498408054, 0.19048830498408054, 0.19048830498408054, 0.23912130110484575, 0.23912130110484575, 0.23912130110484575, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12996998270556925, 0.12996998270556925, 0.12996998270556925, 0.05121822319568803, 0.05121822319568803, 0.05121822319568803, 0.06958003448859562, 0.06958003448859562, 0.06958003448859562, 0.043709977461225624, 0.043709977461225624, 0.043709977461225624, 0.09400881826066232, 0.09400881826066232, 0.09400881826066232, 0.0805341024585221, 0.0805341024585221, 0.0805341024585221, 0.07135943404817136, 0.07135943404817136, 0.07135943404817136, 0.03646472701137515, 0.03646472701137515, 0.03646472701137515, 0.04850984045442819, 0.04850984045442819, 0.04850984045442819, 0.5099178794652295, 0.5099178794652295, 0.5099178794652295, 0.5086569860290291, 0.5086569860290291, 0.5086569860290291, 0.5126446980910919, 0.5126446980910919, 0.5126446980910919, 0.11181367805132048, 0.11181367805132048, 0.11181367805132048, 0.0956913552552181, 0.0956913552552181, 0.0956913552552181, 0.10219202504889002, 0.10219202504889002, 0.10219202504889002, 0.16764525457558554, 0.16764525457558554, 0.16764525457558554, 0.17269589139934582, 0.17269589139934582, 0.17269589139934582, 0.1529642416434437, 0.1529642416434437, 0.1529642416434437, 0.4130109296231209, 0.4130109296231209, 0.4130109296231209, 0.21138917198105744, 0.21138917198105744, 0.21138917198105744, 0.5261797360744587, 0.5261797360744587, 0.5261797360744587, 0.16756062298622854, 0.16756062298622854, 0.16756062298622854, 0.13917612830428427, 0.13917612830428427, 0.13917612830428427, 0.30723148224137853, 0.30723148224137853, 0.30723148224137853, 0.22938239413209105, 0.22938239413209105, 0.22938239413209105, 0.23209001342680458, 0.23209001342680458, 0.23209001342680458, 0.21203872667259116, 0.21203872667259116, 0.21203872667259116, 0.6053565708823181, 0.6053565708823181, 0.6053565708823181, 0.23638240034162727, 0.23638240034162727, 0.23638240034162727, 0.21130900402780795, 0.21130900402780795, 0.21130900402780795, 0.8609378969922405, 0.8609378969922405, 0.8609378969922405, 0.7958206797277336, 0.7958206797277336, 0.7958206797277336, 0.1850663843214222, 0.1850663843214222, 0.1850663843214222, 0.16577119333130663, 0.16577119333130663, 0.16577119333130663, 0.5743874723082145, 0.5743874723082145, 0.5743874723082145, 0.16390124174301213, 0.16390124174301213, 0.16390124174301213, 0.21113085055223557, 0.21113085055223557, 0.21113085055223557, 0.2057623286913789, 0.2057623286913789, 0.2057623286913789, 0.20206437671020372, 0.20206437671020372, 0.20206437671020372, 0.0828042200528587, 0.0828042200528587, 0.0828042200528587, 0.0890299597889258, 0.0890299597889258, 0.0890299597889258, 0.0830189728346008, 0.0830189728346008, 0.0830189728346008]}, "mutation_prompt": null}
{"id": "3f3d9f37-1484-41ba-a3f1-e3d7960f9beb", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a dynamic crossover probability adjustment to enhance exploration and convergence adaptively.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "079f7d2a-609d-44ee-8bb1-0191036c2212", "metadata": {"aucs": [0.7972135001875267, 0.7972135001875267, 0.7972135001875267, 0.7827070990845291, 0.7827070990845291, 0.7827070990845291, 0.8025122245282456, 0.8025122245282456, 0.8025122245282456, 0.5852561590897933, 0.5852561590897933, 0.5852561590897933, 0.5814276675436745, 0.5814276675436745, 0.5814276675436745, 0.5865243103582025, 0.5865243103582025, 0.5865243103582025, 0.14729906130494597, 0.14729906130494597, 0.14729906130494597, 0.4646831752751186, 0.4646831752751186, 0.4646831752751186, 0.16652291108664852, 0.16652291108664852, 0.16652291108664852, 0.10466767754362083, 0.10466767754362083, 0.10466767754362083, 0.09291236323231444, 0.09291236323231444, 0.09291236323231444, 0.10517235882147069, 0.10517235882147069, 0.10517235882147069, 0.9833545195335007, 0.9833545195335007, 0.9833545195335007, 0.9871312113475053, 0.9871312113475053, 0.9871312113475053, 0.9817455104503656, 0.9817455104503656, 0.9817455104503656, 0.5806944519409704, 0.5806944519409704, 0.5806944519409704, 0.14423568085985283, 0.14423568085985283, 0.14423568085985283, 0.5911785299343953, 0.5911785299343953, 0.5911785299343953, 0.7400072527876258, 0.7400072527876258, 0.7400072527876258, 0.26202650903954405, 0.26202650903954405, 0.26202650903954405, 0.21908199948287288, 0.21908199948287288, 0.21908199948287288, 0.20192541633565386, 0.20192541633565386, 0.20192541633565386, 0.19904632776676057, 0.19904632776676057, 0.19904632776676057, 0.22538103130323728, 0.22538103130323728, 0.22538103130323728, 0.1998007651684518, 0.1998007651684518, 0.1998007651684518, 0.1995406537348675, 0.1995406537348675, 0.1995406537348675, 0.24654441451171283, 0.24654441451171283, 0.24654441451171283, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09722994563995213, 0.09722994563995213, 0.09722994563995213, 0.09748822614305641, 0.09748822614305641, 0.09748822614305641, 0.10104045285987595, 0.10104045285987595, 0.10104045285987595, 0.042641874991652395, 0.042641874991652395, 0.042641874991652395, 0.09841498793876513, 0.09841498793876513, 0.09841498793876513, 0.07558965107527604, 0.07558965107527604, 0.07558965107527604, 0.20657030904989082, 0.20657030904989082, 0.20657030904989082, 0.03642382602512517, 0.03642382602512517, 0.03642382602512517, 0.048298767491661954, 0.048298767491661954, 0.048298767491661954, 0.5614216874681467, 0.5614216874681467, 0.5614216874681467, 0.49657700220533374, 0.49657700220533374, 0.49657700220533374, 0.5170455187243754, 0.5170455187243754, 0.5170455187243754, 0.13508326494619027, 0.13508326494619027, 0.13508326494619027, 0.11950025422041399, 0.11950025422041399, 0.11950025422041399, 0.11512622398485983, 0.11512622398485983, 0.11512622398485983, 0.1534042770376467, 0.1534042770376467, 0.1534042770376467, 0.17247856409263362, 0.17247856409263362, 0.17247856409263362, 0.1854014647609713, 0.1854014647609713, 0.1854014647609713, 0.37720084702576306, 0.37720084702576306, 0.37720084702576306, 0.25273891203489507, 0.25273891203489507, 0.25273891203489507, 0.29120254634287, 0.29120254634287, 0.29120254634287, 0.2313683903750654, 0.2313683903750654, 0.2313683903750654, 0.1971470274093733, 0.1971470274093733, 0.1971470274093733, 0.28983987274269485, 0.28983987274269485, 0.28983987274269485, 0.21232565905441736, 0.21232565905441736, 0.21232565905441736, 0.2116917203990608, 0.2116917203990608, 0.2116917203990608, 0.2117417245344626, 0.2117417245344626, 0.2117417245344626, 0.6567070012885114, 0.6567070012885114, 0.6567070012885114, 0.2002749375160504, 0.2002749375160504, 0.2002749375160504, 0.23261418999257366, 0.23261418999257366, 0.23261418999257366, 0.8513823302653051, 0.8513823302653051, 0.8513823302653051, 0.8145276842865627, 0.8145276842865627, 0.8145276842865627, 0.185066515166604, 0.185066515166604, 0.185066515166604, 0.16575140942497746, 0.16575140942497746, 0.16575140942497746, 0.5666900485617927, 0.5666900485617927, 0.5666900485617927, 0.16399352629422792, 0.16399352629422792, 0.16399352629422792, 0.1898442051167626, 0.1898442051167626, 0.1898442051167626, 0.18695400864257494, 0.18695400864257494, 0.18695400864257494, 0.1950965428045024, 0.1950965428045024, 0.1950965428045024, 0.08470179797976873, 0.08470179797976873, 0.08470179797976873, 0.08797544648693856, 0.08797544648693856, 0.08797544648693856, 0.0813902914167105, 0.0813902914167105, 0.0813902914167105]}, "mutation_prompt": null}
{"id": "e15d55b2-ce9d-4a47-a734-308faf5e8493", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n        self.local_search_prob = 0.1  # Probability for local search\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                if np.random.rand() < self.local_search_prob:\n                    local_step = np.random.uniform(-0.5, 0.5, self.dim)\n                    candidate = pop[i] + local_step\n                    candidate = np.clip(candidate, lower, upper)\n                    candidate_value = func(candidate)\n                    eval_count += 1\n                    if candidate_value < personal_best_values[i]:\n                        personal_best_values[i] = candidate_value\n                        personal_best[i] = candidate.copy()\n                    if candidate_value < best_global_value:\n                        best_global_value = candidate_value\n                        best_global_position = candidate.copy()\n\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Integrate a stochastic local search mechanism to enhance exploitation within the global search framework.", "configspace": "", "generation": 42, "fitness": 0.2731794896948983, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.25.", "error": "", "parent_id": "079f7d2a-609d-44ee-8bb1-0191036c2212", "metadata": {"aucs": [0.7882181404016724, 0.7882181404016724, 0.7882181404016724, 0.7892334650717363, 0.7892334650717363, 0.7892334650717363, 0.7985566659167582, 0.7985566659167582, 0.7985566659167582, 0.037857711562335083, 0.037857711562335083, 0.037857711562335083, 0.5628194635691568, 0.5628194635691568, 0.5628194635691568, 0.014735858006779345, 0.014735858006779345, 0.014735858006779345, 0.14361582831593356, 0.14361582831593356, 0.14361582831593356, 0.13561248208451726, 0.13561248208451726, 0.13561248208451726, 0.1322696806858541, 0.1322696806858541, 0.1322696806858541, 0.10310679082012497, 0.10310679082012497, 0.10310679082012497, 0.11296896702689518, 0.11296896702689518, 0.11296896702689518, 0.10724730893202084, 0.10724730893202084, 0.10724730893202084, 0.9784115835487623, 0.9784115835487623, 0.9784115835487623, 0.9816969248493157, 0.9816969248493157, 0.9816969248493157, 0.9758685637374485, 0.9758685637374485, 0.9758685637374485, 0.5743735974558206, 0.5743735974558206, 0.5743735974558206, 0.560414997642391, 0.560414997642391, 0.560414997642391, 0.545953995631903, 0.545953995631903, 0.545953995631903, 0.6043189793069608, 0.6043189793069608, 0.6043189793069608, 0.20487049373597188, 0.20487049373597188, 0.20487049373597188, 0.16867193577774775, 0.16867193577774775, 0.16867193577774775, 0.3164502584208566, 0.3164502584208566, 0.3164502584208566, 0.12287834902130201, 0.12287834902130201, 0.12287834902130201, 0.19664230232817992, 0.19664230232817992, 0.19664230232817992, 0.21710702151704953, 0.21710702151704953, 0.21710702151704953, 0.34746883757880986, 0.34746883757880986, 0.34746883757880986, 0.2037639592153413, 0.2037639592153413, 0.2037639592153413, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08414105265681737, 0.08414105265681737, 0.08414105265681737, 0.08968061052452281, 0.08968061052452281, 0.08968061052452281, 0.059222695087968735, 0.059222695087968735, 0.059222695087968735, 0.04318036068204534, 0.04318036068204534, 0.04318036068204534, 0.08186672988473309, 0.08186672988473309, 0.08186672988473309, 0.08002481613331713, 0.08002481613331713, 0.08002481613331713, 0.05296068611978899, 0.05296068611978899, 0.05296068611978899, 0.26425613019779126, 0.26425613019779126, 0.26425613019779126, 0.12506179713189924, 0.12506179713189924, 0.12506179713189924, 0.493021235316785, 0.493021235316785, 0.493021235316785, 0.5375179810813031, 0.5375179810813031, 0.5375179810813031, 0.5120603152019476, 0.5120603152019476, 0.5120603152019476, 0.09368599833463054, 0.09368599833463054, 0.09368599833463054, 0.131294813405742, 0.131294813405742, 0.131294813405742, 0.08216895234245425, 0.08216895234245425, 0.08216895234245425, 0.18976987592104277, 0.18976987592104277, 0.18976987592104277, 0.22643642809610465, 0.22643642809610465, 0.22643642809610465, 0.175570613402936, 0.175570613402936, 0.175570613402936, 0.3143248457402882, 0.3143248457402882, 0.3143248457402882, 0.269270387421397, 0.269270387421397, 0.269270387421397, 0.20797461444880017, 0.20797461444880017, 0.20797461444880017, 0.1916617281414167, 0.1916617281414167, 0.1916617281414167, 0.1834748155441671, 0.1834748155441671, 0.1834748155441671, 0.187447554245328, 0.187447554245328, 0.187447554245328, 0.1966996107383533, 0.1966996107383533, 0.1966996107383533, 0.2089173024456008, 0.2089173024456008, 0.2089173024456008, 0.22489887234472938, 0.22489887234472938, 0.22489887234472938, 0.22948151899291136, 0.22948151899291136, 0.22948151899291136, 0.23804850447841586, 0.23804850447841586, 0.23804850447841586, 0.622190946279269, 0.622190946279269, 0.622190946279269, 0.8691642941670967, 0.8691642941670967, 0.8691642941670967, 0.15702562452788604, 0.15702562452788604, 0.15702562452788604, 0.1861888382866893, 0.1861888382866893, 0.1861888382866893, 0.16694668506183463, 0.16694668506183463, 0.16694668506183463, 0.16769165123209973, 0.16769165123209973, 0.16769165123209973, 0.1557272581045125, 0.1557272581045125, 0.1557272581045125, 0.1929254371835073, 0.1929254371835073, 0.1929254371835073, 0.20135947908303764, 0.20135947908303764, 0.20135947908303764, 0.18578131733474323, 0.18578131733474323, 0.18578131733474323, 0.08506649123774546, 0.08506649123774546, 0.08506649123774546, 0.09130865488786677, 0.09130865488786677, 0.09130865488786677, 0.08799157242150757, 0.08799157242150757, 0.08799157242150757]}, "mutation_prompt": null}
{"id": "0b15ae1c-fff6-4ac9-9e21-6434c706d2e8", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F_initial = 0.8  # Initial DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n            # Dynamic DE scaling factor\n            self.F = self.F_initial + 0.2 * np.sin(np.pi * eval_count / self.budget)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover with opposition-based learning\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                opposition = lower + upper - trial\n                trial_value = func(trial)\n                opposition_value = func(opposition)\n                eval_count += 2\n\n                if trial_value < opposition_value:\n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best[i] = trial.copy()\n                    if trial_value < best_global_value:\n                        best_global_value = trial_value\n                        best_global_position = trial.copy()\n                else:\n                    if opposition_value < personal_best_values[i]:\n                        personal_best_values[i] = opposition_value\n                        personal_best[i] = opposition.copy()\n                    if opposition_value < best_global_value:\n                        best_global_value = opposition_value\n                        best_global_position = opposition.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Integrate adaptive mutation scaling factor adjustment and opposition-based learning to enhance efficiency and convergence.", "configspace": "", "generation": 43, "fitness": 0.24469297156840977, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.23.", "error": "", "parent_id": "079f7d2a-609d-44ee-8bb1-0191036c2212", "metadata": {"aucs": [0.7155831459838434, 0.7155831459838434, 0.7155831459838434, 0.188658622086875, 0.188658622086875, 0.188658622086875, 0.725929840361575, 0.725929840361575, 0.725929840361575, 0.0649561938710167, 0.0649561938710167, 0.0649561938710167, 0.033710136268535695, 0.033710136268535695, 0.033710136268535695, 0.4008916140689426, 0.4008916140689426, 0.4008916140689426, 0.12298405677601021, 0.12298405677601021, 0.12298405677601021, 0.4118124744211801, 0.4118124744211801, 0.4118124744211801, 0.1169730159901341, 0.1169730159901341, 0.1169730159901341, 0.1222369004572651, 0.1222369004572651, 0.1222369004572651, 0.11003695963723892, 0.11003695963723892, 0.11003695963723892, 0.12012318526759136, 0.12012318526759136, 0.12012318526759136, 0.975605498366046, 0.975605498366046, 0.975605498366046, 0.9836006090660179, 0.9836006090660179, 0.9836006090660179, 0.9679298820815234, 0.9679298820815234, 0.9679298820815234, 0.3351027937110438, 0.3351027937110438, 0.3351027937110438, 0.41924328895371044, 0.41924328895371044, 0.41924328895371044, 0.08239538317468542, 0.08239538317468542, 0.08239538317468542, 0.1655875985730494, 0.1655875985730494, 0.1655875985730494, 0.15761370174901201, 0.15761370174901201, 0.15761370174901201, 0.6428868575448036, 0.6428868575448036, 0.6428868575448036, 0.1654043796931628, 0.1654043796931628, 0.1654043796931628, 0.11686797568429497, 0.11686797568429497, 0.11686797568429497, 0.15932902454028697, 0.15932902454028697, 0.15932902454028697, 0.19055389877036444, 0.19055389877036444, 0.19055389877036444, 0.18528176914884809, 0.18528176914884809, 0.18528176914884809, 0.09419885091505276, 0.09419885091505276, 0.09419885091505276, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1001916431074018, 0.1001916431074018, 0.1001916431074018, 0.11495708199244803, 0.11495708199244803, 0.11495708199244803, 0.0716633015811764, 0.0716633015811764, 0.0716633015811764, 0.036981251014921335, 0.036981251014921335, 0.036981251014921335, 0.06109598148839723, 0.06109598148839723, 0.06109598148839723, 0.17597279115984688, 0.17597279115984688, 0.17597279115984688, 0.07004014250952972, 0.07004014250952972, 0.07004014250952972, 0.10080273739176793, 0.10080273739176793, 0.10080273739176793, 0.04610276547832404, 0.04610276547832404, 0.04610276547832404, 0.5100343335491319, 0.5100343335491319, 0.5100343335491319, 0.18154156425044676, 0.18154156425044676, 0.18154156425044676, 0.4825813401574355, 0.4825813401574355, 0.4825813401574355, 0.10347109153255973, 0.10347109153255973, 0.10347109153255973, 0.13848422359072687, 0.13848422359072687, 0.13848422359072687, 0.12265921138148639, 0.12265921138148639, 0.12265921138148639, 0.1558867302182695, 0.1558867302182695, 0.1558867302182695, 0.16961040754856826, 0.16961040754856826, 0.16961040754856826, 0.18548014833371285, 0.18548014833371285, 0.18548014833371285, 0.3682137898859138, 0.3682137898859138, 0.3682137898859138, 0.3114048216539246, 0.3114048216539246, 0.3114048216539246, 0.3810482757365511, 0.3810482757365511, 0.3810482757365511, 0.2100483104658818, 0.2100483104658818, 0.2100483104658818, 0.2791252503334375, 0.2791252503334375, 0.2791252503334375, 0.22491654674967843, 0.22491654674967843, 0.22491654674967843, 0.20949125691171833, 0.20949125691171833, 0.20949125691171833, 0.2106090056112151, 0.2106090056112151, 0.2106090056112151, 0.22156175149195767, 0.22156175149195767, 0.22156175149195767, 0.5273416819235629, 0.5273416819235629, 0.5273416819235629, 0.22800837084816672, 0.22800837084816672, 0.22800837084816672, 0.19344144859845125, 0.19344144859845125, 0.19344144859845125, 0.2572581695046915, 0.2572581695046915, 0.2572581695046915, 0.7503203780230645, 0.7503203780230645, 0.7503203780230645, 0.1827450489817155, 0.1827450489817155, 0.1827450489817155, 0.16395152755242104, 0.16395152755242104, 0.16395152755242104, 0.3287121335623965, 0.3287121335623965, 0.3287121335623965, 0.18524732386472664, 0.18524732386472664, 0.18524732386472664, 0.18822100650840734, 0.18822100650840734, 0.18822100650840734, 0.1828927163470374, 0.1828927163470374, 0.1828927163470374, 0.18025147857432655, 0.18025147857432655, 0.18025147857432655, 0.08152301279963303, 0.08152301279963303, 0.08152301279963303, 0.07219313449535836, 0.07219313449535836, 0.07219313449535836, 0.07601310905300429, 0.07601310905300429, 0.07601310905300429]}, "mutation_prompt": null}
{"id": "4a4501c7-39b8-42ff-9bdc-999930de392b", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n            # Dynamic crossover probability with learning rate impact\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget + 0.1 * (best_global_value / np.mean(personal_best_values))\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover with adaptive learning strategy\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO with adaptive strategy\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Integrate adaptive learning strategies for dynamic parameter tuning in DE and PSO components to improve convergence speed.", "configspace": "", "generation": 44, "fitness": 0.28024853031911323, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.26.", "error": "", "parent_id": "079f7d2a-609d-44ee-8bb1-0191036c2212", "metadata": {"aucs": [0.7932280637115734, 0.7932280637115734, 0.7932280637115734, 0.781344859018459, 0.781344859018459, 0.781344859018459, 0.8211254556120698, 0.8211254556120698, 0.8211254556120698, 0.596596235851141, 0.596596235851141, 0.596596235851141, 0.5556757673484851, 0.5556757673484851, 0.5556757673484851, 0.049275827903156655, 0.049275827903156655, 0.049275827903156655, 0.15083815298745085, 0.15083815298745085, 0.15083815298745085, 0.12987150914099854, 0.12987150914099854, 0.12987150914099854, 0.10775153121051118, 0.10775153121051118, 0.10775153121051118, 0.1330333044784453, 0.1330333044784453, 0.1330333044784453, 0.10549059378323822, 0.10549059378323822, 0.10549059378323822, 0.09104632687623382, 0.09104632687623382, 0.09104632687623382, 0.9781549539340123, 0.9781549539340123, 0.9781549539340123, 0.9819844475934298, 0.9819844475934298, 0.9819844475934298, 0.98255830579995, 0.98255830579995, 0.98255830579995, 0.6137643108495803, 0.6137643108495803, 0.6137643108495803, 0.5693074712137958, 0.5693074712137958, 0.5693074712137958, 0.6318393190710335, 0.6318393190710335, 0.6318393190710335, 0.21756448262006212, 0.21756448262006212, 0.21756448262006212, 0.24796571950599844, 0.24796571950599844, 0.24796571950599844, 0.7555617953697856, 0.7555617953697856, 0.7555617953697856, 0.2003571583461814, 0.2003571583461814, 0.2003571583461814, 0.21128458158719932, 0.21128458158719932, 0.21128458158719932, 0.192039763320921, 0.192039763320921, 0.192039763320921, 0.14924944218306724, 0.14924944218306724, 0.14924944218306724, 0.21904460015925264, 0.21904460015925264, 0.21904460015925264, 0.12074344515916058, 0.12074344515916058, 0.12074344515916058, 0.06920479373241617, 0.06920479373241617, 0.06920479373241617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10671497412055364, 0.10671497412055364, 0.10671497412055364, 0.09532232424311604, 0.09532232424311604, 0.09532232424311604, 0.07212158272661473, 0.07212158272661473, 0.07212158272661473, 0.04236182659742094, 0.04236182659742094, 0.04236182659742094, 0.0801554690163997, 0.0801554690163997, 0.0801554690163997, 0.08341267415420639, 0.08341267415420639, 0.08341267415420639, 0.1504389072286323, 0.1504389072286323, 0.1504389072286323, 0.035516308712682965, 0.035516308712682965, 0.035516308712682965, 0.0771841790516179, 0.0771841790516179, 0.0771841790516179, 0.5084055347718208, 0.5084055347718208, 0.5084055347718208, 0.5071504721746849, 0.5071504721746849, 0.5071504721746849, 0.5389737796673906, 0.5389737796673906, 0.5389737796673906, 0.09373070396406635, 0.09373070396406635, 0.09373070396406635, 0.15420551673412597, 0.15420551673412597, 0.15420551673412597, 0.10328963049306183, 0.10328963049306183, 0.10328963049306183, 0.16084593884429743, 0.16084593884429743, 0.16084593884429743, 0.19653780482637162, 0.19653780482637162, 0.19653780482637162, 0.21223344849930548, 0.21223344849930548, 0.21223344849930548, 0.32545391125610135, 0.32545391125610135, 0.32545391125610135, 0.21865688453246912, 0.21865688453246912, 0.21865688453246912, 0.2123616270105536, 0.2123616270105536, 0.2123616270105536, 0.2624634650412885, 0.2624634650412885, 0.2624634650412885, 0.1837737867289525, 0.1837737867289525, 0.1837737867289525, 0.12572505343297657, 0.12572505343297657, 0.12572505343297657, 0.20746733961198893, 0.20746733961198893, 0.20746733961198893, 0.1952043349137702, 0.1952043349137702, 0.1952043349137702, 0.20424082721854142, 0.20424082721854142, 0.20424082721854142, 0.5852910257087813, 0.5852910257087813, 0.5852910257087813, 0.1852519432361629, 0.1852519432361629, 0.1852519432361629, 0.2303022983439027, 0.2303022983439027, 0.2303022983439027, 0.8751381845303222, 0.8751381845303222, 0.8751381845303222, 0.1575291662547177, 0.1575291662547177, 0.1575291662547177, 0.17370186192203096, 0.17370186192203096, 0.17370186192203096, 0.16472754311031035, 0.16472754311031035, 0.16472754311031035, 0.20642779742164996, 0.20642779742164996, 0.20642779742164996, 0.15589446559837616, 0.15589446559837616, 0.15589446559837616, 0.21254168713282207, 0.21254168713282207, 0.21254168713282207, 0.18234211009952506, 0.18234211009952506, 0.18234211009952506, 0.1834666780818094, 0.1834666780818094, 0.1834666780818094, 0.09635313876681117, 0.09635313876681117, 0.09635313876681117, 0.08186522460593226, 0.08186522460593226, 0.08186522460593226, 0.07701053422237658, 0.07701053422237658, 0.07701053422237658]}, "mutation_prompt": null}
{"id": "20da1313-e945-4428-836f-70fcd7928f38", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a dynamic crossover probability adjustment to enhance exploration and convergence adaptively.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "079f7d2a-609d-44ee-8bb1-0191036c2212", "metadata": {"aucs": [0.7972135001875267, 0.7972135001875267, 0.7972135001875267, 0.7827070990845291, 0.7827070990845291, 0.7827070990845291, 0.8025122245282456, 0.8025122245282456, 0.8025122245282456, 0.5852561590897933, 0.5852561590897933, 0.5852561590897933, 0.5814276675436745, 0.5814276675436745, 0.5814276675436745, 0.5865243103582025, 0.5865243103582025, 0.5865243103582025, 0.14729906130494597, 0.14729906130494597, 0.14729906130494597, 0.4646831752751186, 0.4646831752751186, 0.4646831752751186, 0.16652291108664852, 0.16652291108664852, 0.16652291108664852, 0.10466767754362083, 0.10466767754362083, 0.10466767754362083, 0.09291236323231444, 0.09291236323231444, 0.09291236323231444, 0.10517235882147069, 0.10517235882147069, 0.10517235882147069, 0.9833545195335007, 0.9833545195335007, 0.9833545195335007, 0.9871312113475053, 0.9871312113475053, 0.9871312113475053, 0.9817455104503656, 0.9817455104503656, 0.9817455104503656, 0.5806944519409704, 0.5806944519409704, 0.5806944519409704, 0.14423568085985283, 0.14423568085985283, 0.14423568085985283, 0.5911785299343953, 0.5911785299343953, 0.5911785299343953, 0.7400072527876258, 0.7400072527876258, 0.7400072527876258, 0.26202650903954405, 0.26202650903954405, 0.26202650903954405, 0.21908199948287288, 0.21908199948287288, 0.21908199948287288, 0.20192541633565386, 0.20192541633565386, 0.20192541633565386, 0.19904632776676057, 0.19904632776676057, 0.19904632776676057, 0.22538103130323728, 0.22538103130323728, 0.22538103130323728, 0.1998007651684518, 0.1998007651684518, 0.1998007651684518, 0.1995406537348675, 0.1995406537348675, 0.1995406537348675, 0.24654441451171283, 0.24654441451171283, 0.24654441451171283, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09722994563995213, 0.09722994563995213, 0.09722994563995213, 0.09748822614305641, 0.09748822614305641, 0.09748822614305641, 0.10104045285987595, 0.10104045285987595, 0.10104045285987595, 0.042641874991652395, 0.042641874991652395, 0.042641874991652395, 0.09841498793876513, 0.09841498793876513, 0.09841498793876513, 0.07558965107527604, 0.07558965107527604, 0.07558965107527604, 0.20657030904989082, 0.20657030904989082, 0.20657030904989082, 0.03642382602512517, 0.03642382602512517, 0.03642382602512517, 0.048298767491661954, 0.048298767491661954, 0.048298767491661954, 0.5614216874681467, 0.5614216874681467, 0.5614216874681467, 0.49657700220533374, 0.49657700220533374, 0.49657700220533374, 0.5170455187243754, 0.5170455187243754, 0.5170455187243754, 0.13508326494619027, 0.13508326494619027, 0.13508326494619027, 0.11950025422041399, 0.11950025422041399, 0.11950025422041399, 0.11512622398485983, 0.11512622398485983, 0.11512622398485983, 0.1534042770376467, 0.1534042770376467, 0.1534042770376467, 0.17247856409263362, 0.17247856409263362, 0.17247856409263362, 0.1854014647609713, 0.1854014647609713, 0.1854014647609713, 0.37720084702576306, 0.37720084702576306, 0.37720084702576306, 0.25273891203489507, 0.25273891203489507, 0.25273891203489507, 0.29120254634287, 0.29120254634287, 0.29120254634287, 0.2313683903750654, 0.2313683903750654, 0.2313683903750654, 0.1971470274093733, 0.1971470274093733, 0.1971470274093733, 0.28983987274269485, 0.28983987274269485, 0.28983987274269485, 0.21232565905441736, 0.21232565905441736, 0.21232565905441736, 0.2116917203990608, 0.2116917203990608, 0.2116917203990608, 0.2117417245344626, 0.2117417245344626, 0.2117417245344626, 0.6567070012885114, 0.6567070012885114, 0.6567070012885114, 0.2002749375160504, 0.2002749375160504, 0.2002749375160504, 0.23261418999257366, 0.23261418999257366, 0.23261418999257366, 0.8513823302653051, 0.8513823302653051, 0.8513823302653051, 0.8145276842865627, 0.8145276842865627, 0.8145276842865627, 0.185066515166604, 0.185066515166604, 0.185066515166604, 0.16575140942497746, 0.16575140942497746, 0.16575140942497746, 0.5666900485617927, 0.5666900485617927, 0.5666900485617927, 0.16399352629422792, 0.16399352629422792, 0.16399352629422792, 0.1898442051167626, 0.1898442051167626, 0.1898442051167626, 0.18695400864257494, 0.18695400864257494, 0.18695400864257494, 0.1950965428045024, 0.1950965428045024, 0.1950965428045024, 0.08470179797976873, 0.08470179797976873, 0.08470179797976873, 0.08797544648693856, 0.08797544648693856, 0.08797544648693856, 0.0813902914167105, 0.0813902914167105, 0.0813902914167105]}, "mutation_prompt": null}
{"id": "cec3a4f9-e54d-4255-81d9-abb421b1dead", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F_min = 0.4  # Minimum DE scaling factor\n        self.F_max = 0.9  # Maximum DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Dynamic inertia decay\n            self.w = 0.9 - 0.5 * eval_count / self.budget\n            # Adaptive DE scaling factor\n            self.F = self.F_min + (self.F_max - self.F_min) * (1 - eval_count / self.budget)\n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce adaptive scaling for DE and dynamic inertia decay for improved convergence.", "configspace": "", "generation": 46, "fitness": 0.23455408823140486, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.23.", "error": "", "parent_id": "079f7d2a-609d-44ee-8bb1-0191036c2212", "metadata": {"aucs": [0.6313002284008711, 0.6313002284008711, 0.6313002284008711, 0.632142801683315, 0.632142801683315, 0.632142801683315, 0.6419601780759594, 0.6419601780759594, 0.6419601780759594, 0.3597342967580084, 0.3597342967580084, 0.3597342967580084, 0.36828335442587556, 0.36828335442587556, 0.36828335442587556, 0.056023581073445294, 0.056023581073445294, 0.056023581073445294, 0.3098345188498399, 0.3098345188498399, 0.3098345188498399, 0.13175944915118343, 0.13175944915118343, 0.13175944915118343, 0.11001989422484204, 0.11001989422484204, 0.11001989422484204, 0.1064612961815159, 0.1064612961815159, 0.1064612961815159, 0.10240925833843906, 0.10240925833843906, 0.10240925833843906, 0.10165372859355304, 0.10165372859355304, 0.10165372859355304, 0.9832786439751035, 0.9832786439751035, 0.9832786439751035, 0.9832506484746536, 0.9832506484746536, 0.9832506484746536, 0.9841813333799382, 0.9841813333799382, 0.9841813333799382, 0.3991810049742144, 0.3991810049742144, 0.3991810049742144, 0.42137785101144676, 0.42137785101144676, 0.42137785101144676, 0.4341398997755108, 0.4341398997755108, 0.4341398997755108, 0.5299250505769797, 0.5299250505769797, 0.5299250505769797, 0.15809923218372846, 0.15809923218372846, 0.15809923218372846, 0.2102133617892633, 0.2102133617892633, 0.2102133617892633, 0.18179414990625675, 0.18179414990625675, 0.18179414990625675, 0.16930241640713461, 0.16930241640713461, 0.16930241640713461, 0.14477259570169576, 0.14477259570169576, 0.14477259570169576, 0.1638192701302068, 0.1638192701302068, 0.1638192701302068, 0.1775215431683066, 0.1775215431683066, 0.1775215431683066, 0.15956412939051556, 0.15956412939051556, 0.15956412939051556, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0417585078737045, 0.0417585078737045, 0.0417585078737045, 0.0395414982474831, 0.0395414982474831, 0.0395414982474831, 0.0077345729502503735, 0.0077345729502503735, 0.0077345729502503735, 0.030544229460124583, 0.030544229460124583, 0.030544229460124583, 0.07813542893140968, 0.07813542893140968, 0.07813542893140968, 0.0618812891870526, 0.0618812891870526, 0.0618812891870526, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04219878225987972, 0.04219878225987972, 0.04219878225987972, 0.4358806081643014, 0.4358806081643014, 0.4358806081643014, 0.17960674690382805, 0.17960674690382805, 0.17960674690382805, 0.4662066294396191, 0.4662066294396191, 0.4662066294396191, 0.10621452502891005, 0.10621452502891005, 0.10621452502891005, 0.07411248228477141, 0.07411248228477141, 0.07411248228477141, 0.0929301382721418, 0.0929301382721418, 0.0929301382721418, 0.16971741326119394, 0.16971741326119394, 0.16971741326119394, 0.16959585740445438, 0.16959585740445438, 0.16959585740445438, 0.17213116897072378, 0.17213116897072378, 0.17213116897072378, 0.31077012646399405, 0.31077012646399405, 0.31077012646399405, 0.30839752377461427, 0.30839752377461427, 0.30839752377461427, 0.1913642635885714, 0.1913642635885714, 0.1913642635885714, 0.17359717020182164, 0.17359717020182164, 0.17359717020182164, 0.17632146082414069, 0.17632146082414069, 0.17632146082414069, 0.13800757941920694, 0.13800757941920694, 0.13800757941920694, 0.22393582161279624, 0.22393582161279624, 0.22393582161279624, 0.17080776082213545, 0.17080776082213545, 0.17080776082213545, 0.2085652573591109, 0.2085652573591109, 0.2085652573591109, 0.19798579956502527, 0.19798579956502527, 0.19798579956502527, 0.4191138452549744, 0.4191138452549744, 0.4191138452549744, 0.19171192886872812, 0.19171192886872812, 0.19171192886872812, 0.7582648284621374, 0.7582648284621374, 0.7582648284621374, 0.15518584213291853, 0.15518584213291853, 0.15518584213291853, 0.18440848242386687, 0.18440848242386687, 0.18440848242386687, 0.15906987454918053, 0.15906987454918053, 0.15906987454918053, 0.15527187775675866, 0.15527187775675866, 0.15527187775675866, 0.12886114321522257, 0.12886114321522257, 0.12886114321522257, 0.19762335301773648, 0.19762335301773648, 0.19762335301773648, 0.1906318748619672, 0.1906318748619672, 0.1906318748619672, 0.17947266120712757, 0.17947266120712757, 0.17947266120712757, 0.08191193625900628, 0.08191193625900628, 0.08191193625900628, 0.0814639068105304, 0.0814639068105304, 0.0814639068105304, 0.08445643896792665, 0.08445643896792665, 0.08445643896792665]}, "mutation_prompt": null}
{"id": "a458c4c7-ac69-4e53-8762-2d7f77bfee10", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a dynamic crossover probability adjustment to enhance exploration and convergence adaptively.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "079f7d2a-609d-44ee-8bb1-0191036c2212", "metadata": {"aucs": [0.7972135001875267, 0.7972135001875267, 0.7972135001875267, 0.7827070990845291, 0.7827070990845291, 0.7827070990845291, 0.8025122245282456, 0.8025122245282456, 0.8025122245282456, 0.5852561590897933, 0.5852561590897933, 0.5852561590897933, 0.5814276675436745, 0.5814276675436745, 0.5814276675436745, 0.5865243103582025, 0.5865243103582025, 0.5865243103582025, 0.14729906130494597, 0.14729906130494597, 0.14729906130494597, 0.4646831752751186, 0.4646831752751186, 0.4646831752751186, 0.16652291108664852, 0.16652291108664852, 0.16652291108664852, 0.10466767754362083, 0.10466767754362083, 0.10466767754362083, 0.09291236323231444, 0.09291236323231444, 0.09291236323231444, 0.10517235882147069, 0.10517235882147069, 0.10517235882147069, 0.9833545195335007, 0.9833545195335007, 0.9833545195335007, 0.9871312113475053, 0.9871312113475053, 0.9871312113475053, 0.9817455104503656, 0.9817455104503656, 0.9817455104503656, 0.5806944519409704, 0.5806944519409704, 0.5806944519409704, 0.14423568085985283, 0.14423568085985283, 0.14423568085985283, 0.5911785299343953, 0.5911785299343953, 0.5911785299343953, 0.7400072527876258, 0.7400072527876258, 0.7400072527876258, 0.26202650903954405, 0.26202650903954405, 0.26202650903954405, 0.21908199948287288, 0.21908199948287288, 0.21908199948287288, 0.20192541633565386, 0.20192541633565386, 0.20192541633565386, 0.19904632776676057, 0.19904632776676057, 0.19904632776676057, 0.22538103130323728, 0.22538103130323728, 0.22538103130323728, 0.1998007651684518, 0.1998007651684518, 0.1998007651684518, 0.1995406537348675, 0.1995406537348675, 0.1995406537348675, 0.24654441451171283, 0.24654441451171283, 0.24654441451171283, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09722994563995213, 0.09722994563995213, 0.09722994563995213, 0.09748822614305641, 0.09748822614305641, 0.09748822614305641, 0.10104045285987595, 0.10104045285987595, 0.10104045285987595, 0.042641874991652395, 0.042641874991652395, 0.042641874991652395, 0.09841498793876513, 0.09841498793876513, 0.09841498793876513, 0.07558965107527604, 0.07558965107527604, 0.07558965107527604, 0.20657030904989082, 0.20657030904989082, 0.20657030904989082, 0.03642382602512517, 0.03642382602512517, 0.03642382602512517, 0.048298767491661954, 0.048298767491661954, 0.048298767491661954, 0.5614216874681467, 0.5614216874681467, 0.5614216874681467, 0.49657700220533374, 0.49657700220533374, 0.49657700220533374, 0.5170455187243754, 0.5170455187243754, 0.5170455187243754, 0.13508326494619027, 0.13508326494619027, 0.13508326494619027, 0.11950025422041399, 0.11950025422041399, 0.11950025422041399, 0.11512622398485983, 0.11512622398485983, 0.11512622398485983, 0.1534042770376467, 0.1534042770376467, 0.1534042770376467, 0.17247856409263362, 0.17247856409263362, 0.17247856409263362, 0.1854014647609713, 0.1854014647609713, 0.1854014647609713, 0.37720084702576306, 0.37720084702576306, 0.37720084702576306, 0.25273891203489507, 0.25273891203489507, 0.25273891203489507, 0.29120254634287, 0.29120254634287, 0.29120254634287, 0.2313683903750654, 0.2313683903750654, 0.2313683903750654, 0.1971470274093733, 0.1971470274093733, 0.1971470274093733, 0.28983987274269485, 0.28983987274269485, 0.28983987274269485, 0.21232565905441736, 0.21232565905441736, 0.21232565905441736, 0.2116917203990608, 0.2116917203990608, 0.2116917203990608, 0.2117417245344626, 0.2117417245344626, 0.2117417245344626, 0.6567070012885114, 0.6567070012885114, 0.6567070012885114, 0.2002749375160504, 0.2002749375160504, 0.2002749375160504, 0.23261418999257366, 0.23261418999257366, 0.23261418999257366, 0.8513823302653051, 0.8513823302653051, 0.8513823302653051, 0.8145276842865627, 0.8145276842865627, 0.8145276842865627, 0.185066515166604, 0.185066515166604, 0.185066515166604, 0.16575140942497746, 0.16575140942497746, 0.16575140942497746, 0.5666900485617927, 0.5666900485617927, 0.5666900485617927, 0.16399352629422792, 0.16399352629422792, 0.16399352629422792, 0.1898442051167626, 0.1898442051167626, 0.1898442051167626, 0.18695400864257494, 0.18695400864257494, 0.18695400864257494, 0.1950965428045024, 0.1950965428045024, 0.1950965428045024, 0.08470179797976873, 0.08470179797976873, 0.08470179797976873, 0.08797544648693856, 0.08797544648693856, 0.08797544648693856, 0.0813902914167105, 0.0813902914167105, 0.0813902914167105]}, "mutation_prompt": null}
{"id": "1f0644eb-b693-4ea4-bd10-2858595e3a2c", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                # Boundary reflection strategy\n                pop[i] = np.where(pop[i] < lower, lower + np.random.rand(self.dim) * (upper - lower), pop[i])\n                pop[i] = np.where(pop[i] > upper, upper - np.random.rand(self.dim) * (upper - lower), pop[i])\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Enhance diversity by implementing a strategic boundary reflection mechanism when particles exceed bounds.", "configspace": "", "generation": 48, "fitness": 0.24278506772106667, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.19.", "error": "", "parent_id": "079f7d2a-609d-44ee-8bb1-0191036c2212", "metadata": {"aucs": [0.7511073518907962, 0.7511073518907962, 0.7511073518907962, 0.3714641710189448, 0.3714641710189448, 0.3714641710189448, 0.5969526267265097, 0.5969526267265097, 0.5969526267265097, 0.4422032964911099, 0.4422032964911099, 0.4422032964911099, 0.5814525983435882, 0.5814525983435882, 0.5814525983435882, 0.5739840029020178, 0.5739840029020178, 0.5739840029020178, 0.146435175308139, 0.146435175308139, 0.146435175308139, 0.14205669958514933, 0.14205669958514933, 0.14205669958514933, 0.14150213446934357, 0.14150213446934357, 0.14150213446934357, 0.1595365449609959, 0.1595365449609959, 0.1595365449609959, 0.09701697970551226, 0.09701697970551226, 0.09701697970551226, 0.11344723612339314, 0.11344723612339314, 0.11344723612339314, 0.1315276953899447, 0.1315276953899447, 0.1315276953899447, 0.09158993150299444, 0.09158993150299444, 0.09158993150299444, 0.09974420157488639, 0.09974420157488639, 0.09974420157488639, 0.4744043562323086, 0.4744043562323086, 0.4744043562323086, 0.21856059739466394, 0.21856059739466394, 0.21856059739466394, 0.30302084200484636, 0.30302084200484636, 0.30302084200484636, 0.7178937587815574, 0.7178937587815574, 0.7178937587815574, 0.1637955134356709, 0.1637955134356709, 0.1637955134356709, 0.21079556008673805, 0.21079556008673805, 0.21079556008673805, 0.19582585039749545, 0.19582585039749545, 0.19582585039749545, 0.15250567019313654, 0.15250567019313654, 0.15250567019313654, 0.1913222455379604, 0.1913222455379604, 0.1913222455379604, 0.2165405420592168, 0.2165405420592168, 0.2165405420592168, 0.1275735759895178, 0.1275735759895178, 0.1275735759895178, 0.20428483946133769, 0.20428483946133769, 0.20428483946133769, 0.06587010095982537, 0.06587010095982537, 0.06587010095982537, 0.00029124688130321985, 0.00029124688130321985, 0.00029124688130321985, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13562233204207275, 0.13562233204207275, 0.13562233204207275, 0.04879958636620507, 0.04879958636620507, 0.04879958636620507, 0.11142100905516616, 0.11142100905516616, 0.11142100905516616, 0.003400547520639563, 0.003400547520639563, 0.003400547520639563, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08088829138180353, 0.08088829138180353, 0.08088829138180353, 0.10519540546838002, 0.10519540546838002, 0.10519540546838002, 0.05011974721502388, 0.05011974721502388, 0.05011974721502388, 0.1338588543431124, 0.1338588543431124, 0.1338588543431124, 0.521980161272583, 0.521980161272583, 0.521980161272583, 0.3962330939093558, 0.3962330939093558, 0.3962330939093558, 0.5426232786257363, 0.5426232786257363, 0.5426232786257363, 0.12715153224946085, 0.12715153224946085, 0.12715153224946085, 0.08239707743295088, 0.08239707743295088, 0.08239707743295088, 0.12203706868792052, 0.12203706868792052, 0.12203706868792052, 0.16499512823952645, 0.16499512823952645, 0.16499512823952645, 0.21274446560916893, 0.21274446560916893, 0.21274446560916893, 0.15327326032311028, 0.15327326032311028, 0.15327326032311028, 0.3207039816635191, 0.3207039816635191, 0.3207039816635191, 0.35232620184313557, 0.35232620184313557, 0.35232620184313557, 0.3225788225052577, 0.3225788225052577, 0.3225788225052577, 0.2537656961907695, 0.2537656961907695, 0.2537656961907695, 0.2973094165005623, 0.2973094165005623, 0.2973094165005623, 0.18645660236239292, 0.18645660236239292, 0.18645660236239292, 0.19899476735304156, 0.19899476735304156, 0.19899476735304156, 0.28669463911694903, 0.28669463911694903, 0.28669463911694903, 0.22419661069474883, 0.22419661069474883, 0.22419661069474883, 0.22038748369150363, 0.22038748369150363, 0.22038748369150363, 0.2197113300760496, 0.2197113300760496, 0.2197113300760496, 0.18761616947876036, 0.18761616947876036, 0.18761616947876036, 0.811228740973903, 0.811228740973903, 0.811228740973903, 0.7628659770812771, 0.7628659770812771, 0.7628659770812771, 0.6363928506307195, 0.6363928506307195, 0.6363928506307195, 0.20195253569978644, 0.20195253569978644, 0.20195253569978644, 0.16513033535786215, 0.16513033535786215, 0.16513033535786215, 0.3369777643009184, 0.3369777643009184, 0.3369777643009184, 0.21017871163227697, 0.21017871163227697, 0.21017871163227697, 0.18600961121709259, 0.18600961121709259, 0.18600961121709259, 0.18273743126938424, 0.18273743126938424, 0.18273743126938424, 0.08529769684066146, 0.08529769684066146, 0.08529769684066146, 0.08383891572175639, 0.08383891572175639, 0.08383891572175639, 0.07152639856335063, 0.07152639856335063, 0.07152639856335063]}, "mutation_prompt": null}
{"id": "d18c7017-57fe-40d1-9c66-2767e3450572", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a dynamic crossover probability adjustment to enhance exploration and convergence adaptively.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "079f7d2a-609d-44ee-8bb1-0191036c2212", "metadata": {"aucs": [0.7972135001875267, 0.7972135001875267, 0.7972135001875267, 0.7827070990845291, 0.7827070990845291, 0.7827070990845291, 0.8025122245282456, 0.8025122245282456, 0.8025122245282456, 0.5852561590897933, 0.5852561590897933, 0.5852561590897933, 0.5814276675436745, 0.5814276675436745, 0.5814276675436745, 0.5865243103582025, 0.5865243103582025, 0.5865243103582025, 0.14729906130494597, 0.14729906130494597, 0.14729906130494597, 0.4646831752751186, 0.4646831752751186, 0.4646831752751186, 0.16652291108664852, 0.16652291108664852, 0.16652291108664852, 0.10466767754362083, 0.10466767754362083, 0.10466767754362083, 0.09291236323231444, 0.09291236323231444, 0.09291236323231444, 0.10517235882147069, 0.10517235882147069, 0.10517235882147069, 0.9833545195335007, 0.9833545195335007, 0.9833545195335007, 0.9871312113475053, 0.9871312113475053, 0.9871312113475053, 0.9817455104503656, 0.9817455104503656, 0.9817455104503656, 0.5806944519409704, 0.5806944519409704, 0.5806944519409704, 0.14423568085985283, 0.14423568085985283, 0.14423568085985283, 0.5911785299343953, 0.5911785299343953, 0.5911785299343953, 0.7400072527876258, 0.7400072527876258, 0.7400072527876258, 0.26202650903954405, 0.26202650903954405, 0.26202650903954405, 0.21908199948287288, 0.21908199948287288, 0.21908199948287288, 0.20192541633565386, 0.20192541633565386, 0.20192541633565386, 0.19904632776676057, 0.19904632776676057, 0.19904632776676057, 0.22538103130323728, 0.22538103130323728, 0.22538103130323728, 0.1998007651684518, 0.1998007651684518, 0.1998007651684518, 0.1995406537348675, 0.1995406537348675, 0.1995406537348675, 0.24654441451171283, 0.24654441451171283, 0.24654441451171283, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09722994563995213, 0.09722994563995213, 0.09722994563995213, 0.09748822614305641, 0.09748822614305641, 0.09748822614305641, 0.10104045285987595, 0.10104045285987595, 0.10104045285987595, 0.042641874991652395, 0.042641874991652395, 0.042641874991652395, 0.09841498793876513, 0.09841498793876513, 0.09841498793876513, 0.07558965107527604, 0.07558965107527604, 0.07558965107527604, 0.20657030904989082, 0.20657030904989082, 0.20657030904989082, 0.03642382602512517, 0.03642382602512517, 0.03642382602512517, 0.048298767491661954, 0.048298767491661954, 0.048298767491661954, 0.5614216874681467, 0.5614216874681467, 0.5614216874681467, 0.49657700220533374, 0.49657700220533374, 0.49657700220533374, 0.5170455187243754, 0.5170455187243754, 0.5170455187243754, 0.13508326494619027, 0.13508326494619027, 0.13508326494619027, 0.11950025422041399, 0.11950025422041399, 0.11950025422041399, 0.11512622398485983, 0.11512622398485983, 0.11512622398485983, 0.1534042770376467, 0.1534042770376467, 0.1534042770376467, 0.17247856409263362, 0.17247856409263362, 0.17247856409263362, 0.1854014647609713, 0.1854014647609713, 0.1854014647609713, 0.37720084702576306, 0.37720084702576306, 0.37720084702576306, 0.25273891203489507, 0.25273891203489507, 0.25273891203489507, 0.29120254634287, 0.29120254634287, 0.29120254634287, 0.2313683903750654, 0.2313683903750654, 0.2313683903750654, 0.1971470274093733, 0.1971470274093733, 0.1971470274093733, 0.28983987274269485, 0.28983987274269485, 0.28983987274269485, 0.21232565905441736, 0.21232565905441736, 0.21232565905441736, 0.2116917203990608, 0.2116917203990608, 0.2116917203990608, 0.2117417245344626, 0.2117417245344626, 0.2117417245344626, 0.6567070012885114, 0.6567070012885114, 0.6567070012885114, 0.2002749375160504, 0.2002749375160504, 0.2002749375160504, 0.23261418999257366, 0.23261418999257366, 0.23261418999257366, 0.8513823302653051, 0.8513823302653051, 0.8513823302653051, 0.8145276842865627, 0.8145276842865627, 0.8145276842865627, 0.185066515166604, 0.185066515166604, 0.185066515166604, 0.16575140942497746, 0.16575140942497746, 0.16575140942497746, 0.5666900485617927, 0.5666900485617927, 0.5666900485617927, 0.16399352629422792, 0.16399352629422792, 0.16399352629422792, 0.1898442051167626, 0.1898442051167626, 0.1898442051167626, 0.18695400864257494, 0.18695400864257494, 0.18695400864257494, 0.1950965428045024, 0.1950965428045024, 0.1950965428045024, 0.08470179797976873, 0.08470179797976873, 0.08470179797976873, 0.08797544648693856, 0.08797544648693856, 0.08797544648693856, 0.0813902914167105, 0.0813902914167105, 0.0813902914167105]}, "mutation_prompt": null}
{"id": "9c8d87c7-8da9-400a-931b-b21775c08ab3", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a dynamic crossover probability adjustment to enhance exploration and convergence adaptively.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "079f7d2a-609d-44ee-8bb1-0191036c2212", "metadata": {"aucs": [0.7972135001875267, 0.7972135001875267, 0.7972135001875267, 0.7827070990845291, 0.7827070990845291, 0.7827070990845291, 0.8025122245282456, 0.8025122245282456, 0.8025122245282456, 0.5852561590897933, 0.5852561590897933, 0.5852561590897933, 0.5814276675436745, 0.5814276675436745, 0.5814276675436745, 0.5865243103582025, 0.5865243103582025, 0.5865243103582025, 0.14729906130494597, 0.14729906130494597, 0.14729906130494597, 0.4646831752751186, 0.4646831752751186, 0.4646831752751186, 0.16652291108664852, 0.16652291108664852, 0.16652291108664852, 0.10466767754362083, 0.10466767754362083, 0.10466767754362083, 0.09291236323231444, 0.09291236323231444, 0.09291236323231444, 0.10517235882147069, 0.10517235882147069, 0.10517235882147069, 0.9833545195335007, 0.9833545195335007, 0.9833545195335007, 0.9871312113475053, 0.9871312113475053, 0.9871312113475053, 0.9817455104503656, 0.9817455104503656, 0.9817455104503656, 0.5806944519409704, 0.5806944519409704, 0.5806944519409704, 0.14423568085985283, 0.14423568085985283, 0.14423568085985283, 0.5911785299343953, 0.5911785299343953, 0.5911785299343953, 0.7400072527876258, 0.7400072527876258, 0.7400072527876258, 0.26202650903954405, 0.26202650903954405, 0.26202650903954405, 0.21908199948287288, 0.21908199948287288, 0.21908199948287288, 0.20192541633565386, 0.20192541633565386, 0.20192541633565386, 0.19904632776676057, 0.19904632776676057, 0.19904632776676057, 0.22538103130323728, 0.22538103130323728, 0.22538103130323728, 0.1998007651684518, 0.1998007651684518, 0.1998007651684518, 0.1995406537348675, 0.1995406537348675, 0.1995406537348675, 0.24654441451171283, 0.24654441451171283, 0.24654441451171283, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09722994563995213, 0.09722994563995213, 0.09722994563995213, 0.09748822614305641, 0.09748822614305641, 0.09748822614305641, 0.10104045285987595, 0.10104045285987595, 0.10104045285987595, 0.042641874991652395, 0.042641874991652395, 0.042641874991652395, 0.09841498793876513, 0.09841498793876513, 0.09841498793876513, 0.07558965107527604, 0.07558965107527604, 0.07558965107527604, 0.20657030904989082, 0.20657030904989082, 0.20657030904989082, 0.03642382602512517, 0.03642382602512517, 0.03642382602512517, 0.048298767491661954, 0.048298767491661954, 0.048298767491661954, 0.5614216874681467, 0.5614216874681467, 0.5614216874681467, 0.49657700220533374, 0.49657700220533374, 0.49657700220533374, 0.5170455187243754, 0.5170455187243754, 0.5170455187243754, 0.13508326494619027, 0.13508326494619027, 0.13508326494619027, 0.11950025422041399, 0.11950025422041399, 0.11950025422041399, 0.11512622398485983, 0.11512622398485983, 0.11512622398485983, 0.1534042770376467, 0.1534042770376467, 0.1534042770376467, 0.17247856409263362, 0.17247856409263362, 0.17247856409263362, 0.1854014647609713, 0.1854014647609713, 0.1854014647609713, 0.37720084702576306, 0.37720084702576306, 0.37720084702576306, 0.25273891203489507, 0.25273891203489507, 0.25273891203489507, 0.29120254634287, 0.29120254634287, 0.29120254634287, 0.2313683903750654, 0.2313683903750654, 0.2313683903750654, 0.1971470274093733, 0.1971470274093733, 0.1971470274093733, 0.28983987274269485, 0.28983987274269485, 0.28983987274269485, 0.21232565905441736, 0.21232565905441736, 0.21232565905441736, 0.2116917203990608, 0.2116917203990608, 0.2116917203990608, 0.2117417245344626, 0.2117417245344626, 0.2117417245344626, 0.6567070012885114, 0.6567070012885114, 0.6567070012885114, 0.2002749375160504, 0.2002749375160504, 0.2002749375160504, 0.23261418999257366, 0.23261418999257366, 0.23261418999257366, 0.8513823302653051, 0.8513823302653051, 0.8513823302653051, 0.8145276842865627, 0.8145276842865627, 0.8145276842865627, 0.185066515166604, 0.185066515166604, 0.185066515166604, 0.16575140942497746, 0.16575140942497746, 0.16575140942497746, 0.5666900485617927, 0.5666900485617927, 0.5666900485617927, 0.16399352629422792, 0.16399352629422792, 0.16399352629422792, 0.1898442051167626, 0.1898442051167626, 0.1898442051167626, 0.18695400864257494, 0.18695400864257494, 0.18695400864257494, 0.1950965428045024, 0.1950965428045024, 0.1950965428045024, 0.08470179797976873, 0.08470179797976873, 0.08470179797976873, 0.08797544648693856, 0.08797544648693856, 0.08797544648693856, 0.0813902914167105, 0.0813902914167105, 0.0813902914167105]}, "mutation_prompt": null}
{"id": "2642478f-1903-4f1c-9bd7-2010d3ac2ffc", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Sigmoid-based dynamic scaling factor\n            self.F = 0.8 / (1 + np.exp(-10 * (eval_count / self.budget - 0.5)))\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a sigmoid-based dynamic adjustment for the DE scaling factor (F) to enhance exploration-adaptation balance.", "configspace": "", "generation": 51, "fitness": 0.276567849861461, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.25.", "error": "", "parent_id": "079f7d2a-609d-44ee-8bb1-0191036c2212", "metadata": {"aucs": [0.804265340973143, 0.804265340973143, 0.804265340973143, 0.7938740005015013, 0.7938740005015013, 0.7938740005015013, 0.7866207153339883, 0.7866207153339883, 0.7866207153339883, 0.5253356259327002, 0.5253356259327002, 0.5253356259327002, 0.5525386995877828, 0.5525386995877828, 0.5525386995877828, 0.04096107491688039, 0.04096107491688039, 0.04096107491688039, 0.14485465130099817, 0.14485465130099817, 0.14485465130099817, 0.07085626245842813, 0.07085626245842813, 0.07085626245842813, 0.14303816302084693, 0.14303816302084693, 0.14303816302084693, 0.1097183425668844, 0.1097183425668844, 0.1097183425668844, 0.13932678355656103, 0.13932678355656103, 0.13932678355656103, 0.12364201312730672, 0.12364201312730672, 0.12364201312730672, 0.9814305793575487, 0.9814305793575487, 0.9814305793575487, 0.9885603657938141, 0.9885603657938141, 0.9885603657938141, 0.9812946339252961, 0.9812946339252961, 0.9812946339252961, 0.6282062447311197, 0.6282062447311197, 0.6282062447311197, 0.5809957918504108, 0.5809957918504108, 0.5809957918504108, 0.6136143383968621, 0.6136143383968621, 0.6136143383968621, 0.16270998436308892, 0.16270998436308892, 0.16270998436308892, 0.16093757055743518, 0.16093757055743518, 0.16093757055743518, 0.22422072761499845, 0.22422072761499845, 0.22422072761499845, 0.21144467989274163, 0.21144467989274163, 0.21144467989274163, 0.12670969018428346, 0.12670969018428346, 0.12670969018428346, 0.20715267161883455, 0.20715267161883455, 0.20715267161883455, 0.20898285027924035, 0.20898285027924035, 0.20898285027924035, 0.21256936000655768, 0.21256936000655768, 0.21256936000655768, 0.2278774315834876, 0.2278774315834876, 0.2278774315834876, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.022152512552378156, 0.022152512552378156, 0.022152512552378156, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03606970673651233, 0.03606970673651233, 0.03606970673651233, 0.0628861606881268, 0.0628861606881268, 0.0628861606881268, 0.04351922248241458, 0.04351922248241458, 0.04351922248241458, 0.043182453654884934, 0.043182453654884934, 0.043182453654884934, 0.11676343350773422, 0.11676343350773422, 0.11676343350773422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2024935686738647, 0.2024935686738647, 0.2024935686738647, 0.03522169413835563, 0.03522169413835563, 0.03522169413835563, 0.1055415932484679, 0.1055415932484679, 0.1055415932484679, 0.5087617610035924, 0.5087617610035924, 0.5087617610035924, 0.5096139818942284, 0.5096139818942284, 0.5096139818942284, 0.5844637258465206, 0.5844637258465206, 0.5844637258465206, 0.06558783101081223, 0.06558783101081223, 0.06558783101081223, 0.11130890382606962, 0.11130890382606962, 0.11130890382606962, 0.14660554662504022, 0.14660554662504022, 0.14660554662504022, 0.292677627616566, 0.292677627616566, 0.292677627616566, 0.19532504805144268, 0.19532504805144268, 0.19532504805144268, 0.20492615864469943, 0.20492615864469943, 0.20492615864469943, 0.5327965058723452, 0.5327965058723452, 0.5327965058723452, 0.3281829686451131, 0.3281829686451131, 0.3281829686451131, 0.1648561543420416, 0.1648561543420416, 0.1648561543420416, 0.2891850840015112, 0.2891850840015112, 0.2891850840015112, 0.18220193450076894, 0.18220193450076894, 0.18220193450076894, 0.12094909752472449, 0.12094909752472449, 0.12094909752472449, 0.23134249719335653, 0.23134249719335653, 0.23134249719335653, 0.19602955961730095, 0.19602955961730095, 0.19602955961730095, 0.21996279124709983, 0.21996279124709983, 0.21996279124709983, 0.2136440878124014, 0.2136440878124014, 0.2136440878124014, 0.18870868797886953, 0.18870868797886953, 0.18870868797886953, 0.2473819065761249, 0.2473819065761249, 0.2473819065761249, 0.8575779989355929, 0.8575779989355929, 0.8575779989355929, 0.17166727122708292, 0.17166727122708292, 0.17166727122708292, 0.19491710337223223, 0.19491710337223223, 0.19491710337223223, 0.48954122168368297, 0.48954122168368297, 0.48954122168368297, 0.20813641790763993, 0.20813641790763993, 0.20813641790763993, 0.15448332111423102, 0.15448332111423102, 0.15448332111423102, 0.18530094662984697, 0.18530094662984697, 0.18530094662984697, 0.1801728108324322, 0.1801728108324322, 0.1801728108324322, 0.20657622807509357, 0.20657622807509357, 0.20657622807509357, 0.10126267095405983, 0.10126267095405983, 0.10126267095405983, 0.11639488076414017, 0.11639488076414017, 0.11639488076414017, 0.09247351958305006, 0.09247351958305006, 0.09247351958305006]}, "mutation_prompt": null}
{"id": "6b4cb309-75ad-4f4b-8fc3-59021c790a5d", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a dynamic crossover probability adjustment to enhance exploration and convergence adaptively.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "079f7d2a-609d-44ee-8bb1-0191036c2212", "metadata": {"aucs": [0.7972135001875267, 0.7972135001875267, 0.7972135001875267, 0.7827070990845291, 0.7827070990845291, 0.7827070990845291, 0.8025122245282456, 0.8025122245282456, 0.8025122245282456, 0.5852561590897933, 0.5852561590897933, 0.5852561590897933, 0.5814276675436745, 0.5814276675436745, 0.5814276675436745, 0.5865243103582025, 0.5865243103582025, 0.5865243103582025, 0.14729906130494597, 0.14729906130494597, 0.14729906130494597, 0.4646831752751186, 0.4646831752751186, 0.4646831752751186, 0.16652291108664852, 0.16652291108664852, 0.16652291108664852, 0.10466767754362083, 0.10466767754362083, 0.10466767754362083, 0.09291236323231444, 0.09291236323231444, 0.09291236323231444, 0.10517235882147069, 0.10517235882147069, 0.10517235882147069, 0.9833545195335007, 0.9833545195335007, 0.9833545195335007, 0.9871312113475053, 0.9871312113475053, 0.9871312113475053, 0.9817455104503656, 0.9817455104503656, 0.9817455104503656, 0.5806944519409704, 0.5806944519409704, 0.5806944519409704, 0.14423568085985283, 0.14423568085985283, 0.14423568085985283, 0.5911785299343953, 0.5911785299343953, 0.5911785299343953, 0.7400072527876258, 0.7400072527876258, 0.7400072527876258, 0.26202650903954405, 0.26202650903954405, 0.26202650903954405, 0.21908199948287288, 0.21908199948287288, 0.21908199948287288, 0.20192541633565386, 0.20192541633565386, 0.20192541633565386, 0.19904632776676057, 0.19904632776676057, 0.19904632776676057, 0.22538103130323728, 0.22538103130323728, 0.22538103130323728, 0.1998007651684518, 0.1998007651684518, 0.1998007651684518, 0.1995406537348675, 0.1995406537348675, 0.1995406537348675, 0.24654441451171283, 0.24654441451171283, 0.24654441451171283, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09722994563995213, 0.09722994563995213, 0.09722994563995213, 0.09748822614305641, 0.09748822614305641, 0.09748822614305641, 0.10104045285987595, 0.10104045285987595, 0.10104045285987595, 0.042641874991652395, 0.042641874991652395, 0.042641874991652395, 0.09841498793876513, 0.09841498793876513, 0.09841498793876513, 0.07558965107527604, 0.07558965107527604, 0.07558965107527604, 0.20657030904989082, 0.20657030904989082, 0.20657030904989082, 0.03642382602512517, 0.03642382602512517, 0.03642382602512517, 0.048298767491661954, 0.048298767491661954, 0.048298767491661954, 0.5614216874681467, 0.5614216874681467, 0.5614216874681467, 0.49657700220533374, 0.49657700220533374, 0.49657700220533374, 0.5170455187243754, 0.5170455187243754, 0.5170455187243754, 0.13508326494619027, 0.13508326494619027, 0.13508326494619027, 0.11950025422041399, 0.11950025422041399, 0.11950025422041399, 0.11512622398485983, 0.11512622398485983, 0.11512622398485983, 0.1534042770376467, 0.1534042770376467, 0.1534042770376467, 0.17247856409263362, 0.17247856409263362, 0.17247856409263362, 0.1854014647609713, 0.1854014647609713, 0.1854014647609713, 0.37720084702576306, 0.37720084702576306, 0.37720084702576306, 0.25273891203489507, 0.25273891203489507, 0.25273891203489507, 0.29120254634287, 0.29120254634287, 0.29120254634287, 0.2313683903750654, 0.2313683903750654, 0.2313683903750654, 0.1971470274093733, 0.1971470274093733, 0.1971470274093733, 0.28983987274269485, 0.28983987274269485, 0.28983987274269485, 0.21232565905441736, 0.21232565905441736, 0.21232565905441736, 0.2116917203990608, 0.2116917203990608, 0.2116917203990608, 0.2117417245344626, 0.2117417245344626, 0.2117417245344626, 0.6567070012885114, 0.6567070012885114, 0.6567070012885114, 0.2002749375160504, 0.2002749375160504, 0.2002749375160504, 0.23261418999257366, 0.23261418999257366, 0.23261418999257366, 0.8513823302653051, 0.8513823302653051, 0.8513823302653051, 0.8145276842865627, 0.8145276842865627, 0.8145276842865627, 0.185066515166604, 0.185066515166604, 0.185066515166604, 0.16575140942497746, 0.16575140942497746, 0.16575140942497746, 0.5666900485617927, 0.5666900485617927, 0.5666900485617927, 0.16399352629422792, 0.16399352629422792, 0.16399352629422792, 0.1898442051167626, 0.1898442051167626, 0.1898442051167626, 0.18695400864257494, 0.18695400864257494, 0.18695400864257494, 0.1950965428045024, 0.1950965428045024, 0.1950965428045024, 0.08470179797976873, 0.08470179797976873, 0.08470179797976873, 0.08797544648693856, 0.08797544648693856, 0.08797544648693856, 0.0813902914167105, 0.0813902914167105, 0.0813902914167105]}, "mutation_prompt": null}
{"id": "29db6e2b-96f6-4d25-9a55-a376d0ce93b2", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a dynamic crossover probability adjustment to enhance exploration and convergence adaptively.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "079f7d2a-609d-44ee-8bb1-0191036c2212", "metadata": {"aucs": [0.7972135001875267, 0.7972135001875267, 0.7972135001875267, 0.7827070990845291, 0.7827070990845291, 0.7827070990845291, 0.8025122245282456, 0.8025122245282456, 0.8025122245282456, 0.5852561590897933, 0.5852561590897933, 0.5852561590897933, 0.5814276675436745, 0.5814276675436745, 0.5814276675436745, 0.5865243103582025, 0.5865243103582025, 0.5865243103582025, 0.14729906130494597, 0.14729906130494597, 0.14729906130494597, 0.4646831752751186, 0.4646831752751186, 0.4646831752751186, 0.16652291108664852, 0.16652291108664852, 0.16652291108664852, 0.10466767754362083, 0.10466767754362083, 0.10466767754362083, 0.09291236323231444, 0.09291236323231444, 0.09291236323231444, 0.10517235882147069, 0.10517235882147069, 0.10517235882147069, 0.9833545195335007, 0.9833545195335007, 0.9833545195335007, 0.9871312113475053, 0.9871312113475053, 0.9871312113475053, 0.9817455104503656, 0.9817455104503656, 0.9817455104503656, 0.5806944519409704, 0.5806944519409704, 0.5806944519409704, 0.14423568085985283, 0.14423568085985283, 0.14423568085985283, 0.5911785299343953, 0.5911785299343953, 0.5911785299343953, 0.7400072527876258, 0.7400072527876258, 0.7400072527876258, 0.26202650903954405, 0.26202650903954405, 0.26202650903954405, 0.21908199948287288, 0.21908199948287288, 0.21908199948287288, 0.20192541633565386, 0.20192541633565386, 0.20192541633565386, 0.19904632776676057, 0.19904632776676057, 0.19904632776676057, 0.22538103130323728, 0.22538103130323728, 0.22538103130323728, 0.1998007651684518, 0.1998007651684518, 0.1998007651684518, 0.1995406537348675, 0.1995406537348675, 0.1995406537348675, 0.24654441451171283, 0.24654441451171283, 0.24654441451171283, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09722994563995213, 0.09722994563995213, 0.09722994563995213, 0.09748822614305641, 0.09748822614305641, 0.09748822614305641, 0.10104045285987595, 0.10104045285987595, 0.10104045285987595, 0.042641874991652395, 0.042641874991652395, 0.042641874991652395, 0.09841498793876513, 0.09841498793876513, 0.09841498793876513, 0.07558965107527604, 0.07558965107527604, 0.07558965107527604, 0.20657030904989082, 0.20657030904989082, 0.20657030904989082, 0.03642382602512517, 0.03642382602512517, 0.03642382602512517, 0.048298767491661954, 0.048298767491661954, 0.048298767491661954, 0.5614216874681467, 0.5614216874681467, 0.5614216874681467, 0.49657700220533374, 0.49657700220533374, 0.49657700220533374, 0.5170455187243754, 0.5170455187243754, 0.5170455187243754, 0.13508326494619027, 0.13508326494619027, 0.13508326494619027, 0.11950025422041399, 0.11950025422041399, 0.11950025422041399, 0.11512622398485983, 0.11512622398485983, 0.11512622398485983, 0.1534042770376467, 0.1534042770376467, 0.1534042770376467, 0.17247856409263362, 0.17247856409263362, 0.17247856409263362, 0.1854014647609713, 0.1854014647609713, 0.1854014647609713, 0.37720084702576306, 0.37720084702576306, 0.37720084702576306, 0.25273891203489507, 0.25273891203489507, 0.25273891203489507, 0.29120254634287, 0.29120254634287, 0.29120254634287, 0.2313683903750654, 0.2313683903750654, 0.2313683903750654, 0.1971470274093733, 0.1971470274093733, 0.1971470274093733, 0.28983987274269485, 0.28983987274269485, 0.28983987274269485, 0.21232565905441736, 0.21232565905441736, 0.21232565905441736, 0.2116917203990608, 0.2116917203990608, 0.2116917203990608, 0.2117417245344626, 0.2117417245344626, 0.2117417245344626, 0.6567070012885114, 0.6567070012885114, 0.6567070012885114, 0.2002749375160504, 0.2002749375160504, 0.2002749375160504, 0.23261418999257366, 0.23261418999257366, 0.23261418999257366, 0.8513823302653051, 0.8513823302653051, 0.8513823302653051, 0.8145276842865627, 0.8145276842865627, 0.8145276842865627, 0.185066515166604, 0.185066515166604, 0.185066515166604, 0.16575140942497746, 0.16575140942497746, 0.16575140942497746, 0.5666900485617927, 0.5666900485617927, 0.5666900485617927, 0.16399352629422792, 0.16399352629422792, 0.16399352629422792, 0.1898442051167626, 0.1898442051167626, 0.1898442051167626, 0.18695400864257494, 0.18695400864257494, 0.18695400864257494, 0.1950965428045024, 0.1950965428045024, 0.1950965428045024, 0.08470179797976873, 0.08470179797976873, 0.08470179797976873, 0.08797544648693856, 0.08797544648693856, 0.08797544648693856, 0.0813902914167105, 0.0813902914167105, 0.0813902914167105]}, "mutation_prompt": null}
{"id": "ae4f1835-3a75-490e-90d4-2b76c153672a", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a dynamic crossover probability adjustment to enhance exploration and convergence adaptively.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "079f7d2a-609d-44ee-8bb1-0191036c2212", "metadata": {"aucs": [0.7972135001875267, 0.7972135001875267, 0.7972135001875267, 0.7827070990845291, 0.7827070990845291, 0.7827070990845291, 0.8025122245282456, 0.8025122245282456, 0.8025122245282456, 0.5852561590897933, 0.5852561590897933, 0.5852561590897933, 0.5814276675436745, 0.5814276675436745, 0.5814276675436745, 0.5865243103582025, 0.5865243103582025, 0.5865243103582025, 0.14729906130494597, 0.14729906130494597, 0.14729906130494597, 0.4646831752751186, 0.4646831752751186, 0.4646831752751186, 0.16652291108664852, 0.16652291108664852, 0.16652291108664852, 0.10466767754362083, 0.10466767754362083, 0.10466767754362083, 0.09291236323231444, 0.09291236323231444, 0.09291236323231444, 0.10517235882147069, 0.10517235882147069, 0.10517235882147069, 0.9833545195335007, 0.9833545195335007, 0.9833545195335007, 0.9871312113475053, 0.9871312113475053, 0.9871312113475053, 0.9817455104503656, 0.9817455104503656, 0.9817455104503656, 0.5806944519409704, 0.5806944519409704, 0.5806944519409704, 0.14423568085985283, 0.14423568085985283, 0.14423568085985283, 0.5911785299343953, 0.5911785299343953, 0.5911785299343953, 0.7400072527876258, 0.7400072527876258, 0.7400072527876258, 0.26202650903954405, 0.26202650903954405, 0.26202650903954405, 0.21908199948287288, 0.21908199948287288, 0.21908199948287288, 0.20192541633565386, 0.20192541633565386, 0.20192541633565386, 0.19904632776676057, 0.19904632776676057, 0.19904632776676057, 0.22538103130323728, 0.22538103130323728, 0.22538103130323728, 0.1998007651684518, 0.1998007651684518, 0.1998007651684518, 0.1995406537348675, 0.1995406537348675, 0.1995406537348675, 0.24654441451171283, 0.24654441451171283, 0.24654441451171283, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09722994563995213, 0.09722994563995213, 0.09722994563995213, 0.09748822614305641, 0.09748822614305641, 0.09748822614305641, 0.10104045285987595, 0.10104045285987595, 0.10104045285987595, 0.042641874991652395, 0.042641874991652395, 0.042641874991652395, 0.09841498793876513, 0.09841498793876513, 0.09841498793876513, 0.07558965107527604, 0.07558965107527604, 0.07558965107527604, 0.20657030904989082, 0.20657030904989082, 0.20657030904989082, 0.03642382602512517, 0.03642382602512517, 0.03642382602512517, 0.048298767491661954, 0.048298767491661954, 0.048298767491661954, 0.5614216874681467, 0.5614216874681467, 0.5614216874681467, 0.49657700220533374, 0.49657700220533374, 0.49657700220533374, 0.5170455187243754, 0.5170455187243754, 0.5170455187243754, 0.13508326494619027, 0.13508326494619027, 0.13508326494619027, 0.11950025422041399, 0.11950025422041399, 0.11950025422041399, 0.11512622398485983, 0.11512622398485983, 0.11512622398485983, 0.1534042770376467, 0.1534042770376467, 0.1534042770376467, 0.17247856409263362, 0.17247856409263362, 0.17247856409263362, 0.1854014647609713, 0.1854014647609713, 0.1854014647609713, 0.37720084702576306, 0.37720084702576306, 0.37720084702576306, 0.25273891203489507, 0.25273891203489507, 0.25273891203489507, 0.29120254634287, 0.29120254634287, 0.29120254634287, 0.2313683903750654, 0.2313683903750654, 0.2313683903750654, 0.1971470274093733, 0.1971470274093733, 0.1971470274093733, 0.28983987274269485, 0.28983987274269485, 0.28983987274269485, 0.21232565905441736, 0.21232565905441736, 0.21232565905441736, 0.2116917203990608, 0.2116917203990608, 0.2116917203990608, 0.2117417245344626, 0.2117417245344626, 0.2117417245344626, 0.6567070012885114, 0.6567070012885114, 0.6567070012885114, 0.2002749375160504, 0.2002749375160504, 0.2002749375160504, 0.23261418999257366, 0.23261418999257366, 0.23261418999257366, 0.8513823302653051, 0.8513823302653051, 0.8513823302653051, 0.8145276842865627, 0.8145276842865627, 0.8145276842865627, 0.185066515166604, 0.185066515166604, 0.185066515166604, 0.16575140942497746, 0.16575140942497746, 0.16575140942497746, 0.5666900485617927, 0.5666900485617927, 0.5666900485617927, 0.16399352629422792, 0.16399352629422792, 0.16399352629422792, 0.1898442051167626, 0.1898442051167626, 0.1898442051167626, 0.18695400864257494, 0.18695400864257494, 0.18695400864257494, 0.1950965428045024, 0.1950965428045024, 0.1950965428045024, 0.08470179797976873, 0.08470179797976873, 0.08470179797976873, 0.08797544648693856, 0.08797544648693856, 0.08797544648693856, 0.0813902914167105, 0.0813902914167105, 0.0813902914167105]}, "mutation_prompt": null}
{"id": "b4b27ca5-9dc4-4a3f-8ac9-2f0f77a17429", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a dynamic crossover probability adjustment to enhance exploration and convergence adaptively.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "079f7d2a-609d-44ee-8bb1-0191036c2212", "metadata": {"aucs": [0.7972135001875267, 0.7972135001875267, 0.7972135001875267, 0.7827070990845291, 0.7827070990845291, 0.7827070990845291, 0.8025122245282456, 0.8025122245282456, 0.8025122245282456, 0.5852561590897933, 0.5852561590897933, 0.5852561590897933, 0.5814276675436745, 0.5814276675436745, 0.5814276675436745, 0.5865243103582025, 0.5865243103582025, 0.5865243103582025, 0.14729906130494597, 0.14729906130494597, 0.14729906130494597, 0.4646831752751186, 0.4646831752751186, 0.4646831752751186, 0.16652291108664852, 0.16652291108664852, 0.16652291108664852, 0.10466767754362083, 0.10466767754362083, 0.10466767754362083, 0.09291236323231444, 0.09291236323231444, 0.09291236323231444, 0.10517235882147069, 0.10517235882147069, 0.10517235882147069, 0.9833545195335007, 0.9833545195335007, 0.9833545195335007, 0.9871312113475053, 0.9871312113475053, 0.9871312113475053, 0.9817455104503656, 0.9817455104503656, 0.9817455104503656, 0.5806944519409704, 0.5806944519409704, 0.5806944519409704, 0.14423568085985283, 0.14423568085985283, 0.14423568085985283, 0.5911785299343953, 0.5911785299343953, 0.5911785299343953, 0.7400072527876258, 0.7400072527876258, 0.7400072527876258, 0.26202650903954405, 0.26202650903954405, 0.26202650903954405, 0.21908199948287288, 0.21908199948287288, 0.21908199948287288, 0.20192541633565386, 0.20192541633565386, 0.20192541633565386, 0.19904632776676057, 0.19904632776676057, 0.19904632776676057, 0.22538103130323728, 0.22538103130323728, 0.22538103130323728, 0.1998007651684518, 0.1998007651684518, 0.1998007651684518, 0.1995406537348675, 0.1995406537348675, 0.1995406537348675, 0.24654441451171283, 0.24654441451171283, 0.24654441451171283, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09722994563995213, 0.09722994563995213, 0.09722994563995213, 0.09748822614305641, 0.09748822614305641, 0.09748822614305641, 0.10104045285987595, 0.10104045285987595, 0.10104045285987595, 0.042641874991652395, 0.042641874991652395, 0.042641874991652395, 0.09841498793876513, 0.09841498793876513, 0.09841498793876513, 0.07558965107527604, 0.07558965107527604, 0.07558965107527604, 0.20657030904989082, 0.20657030904989082, 0.20657030904989082, 0.03642382602512517, 0.03642382602512517, 0.03642382602512517, 0.048298767491661954, 0.048298767491661954, 0.048298767491661954, 0.5614216874681467, 0.5614216874681467, 0.5614216874681467, 0.49657700220533374, 0.49657700220533374, 0.49657700220533374, 0.5170455187243754, 0.5170455187243754, 0.5170455187243754, 0.13508326494619027, 0.13508326494619027, 0.13508326494619027, 0.11950025422041399, 0.11950025422041399, 0.11950025422041399, 0.11512622398485983, 0.11512622398485983, 0.11512622398485983, 0.1534042770376467, 0.1534042770376467, 0.1534042770376467, 0.17247856409263362, 0.17247856409263362, 0.17247856409263362, 0.1854014647609713, 0.1854014647609713, 0.1854014647609713, 0.37720084702576306, 0.37720084702576306, 0.37720084702576306, 0.25273891203489507, 0.25273891203489507, 0.25273891203489507, 0.29120254634287, 0.29120254634287, 0.29120254634287, 0.2313683903750654, 0.2313683903750654, 0.2313683903750654, 0.1971470274093733, 0.1971470274093733, 0.1971470274093733, 0.28983987274269485, 0.28983987274269485, 0.28983987274269485, 0.21232565905441736, 0.21232565905441736, 0.21232565905441736, 0.2116917203990608, 0.2116917203990608, 0.2116917203990608, 0.2117417245344626, 0.2117417245344626, 0.2117417245344626, 0.6567070012885114, 0.6567070012885114, 0.6567070012885114, 0.2002749375160504, 0.2002749375160504, 0.2002749375160504, 0.23261418999257366, 0.23261418999257366, 0.23261418999257366, 0.8513823302653051, 0.8513823302653051, 0.8513823302653051, 0.8145276842865627, 0.8145276842865627, 0.8145276842865627, 0.185066515166604, 0.185066515166604, 0.185066515166604, 0.16575140942497746, 0.16575140942497746, 0.16575140942497746, 0.5666900485617927, 0.5666900485617927, 0.5666900485617927, 0.16399352629422792, 0.16399352629422792, 0.16399352629422792, 0.1898442051167626, 0.1898442051167626, 0.1898442051167626, 0.18695400864257494, 0.18695400864257494, 0.18695400864257494, 0.1950965428045024, 0.1950965428045024, 0.1950965428045024, 0.08470179797976873, 0.08470179797976873, 0.08470179797976873, 0.08797544648693856, 0.08797544648693856, 0.08797544648693856, 0.0813902914167105, 0.0813902914167105, 0.0813902914167105]}, "mutation_prompt": null}
{"id": "8f2d709b-2e46-4c11-a0f0-8d389e7786a4", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a dynamic crossover probability adjustment to enhance exploration and convergence adaptively.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "079f7d2a-609d-44ee-8bb1-0191036c2212", "metadata": {"aucs": [0.7972135001875267, 0.7972135001875267, 0.7972135001875267, 0.7827070990845291, 0.7827070990845291, 0.7827070990845291, 0.8025122245282456, 0.8025122245282456, 0.8025122245282456, 0.5852561590897933, 0.5852561590897933, 0.5852561590897933, 0.5814276675436745, 0.5814276675436745, 0.5814276675436745, 0.5865243103582025, 0.5865243103582025, 0.5865243103582025, 0.14729906130494597, 0.14729906130494597, 0.14729906130494597, 0.4646831752751186, 0.4646831752751186, 0.4646831752751186, 0.16652291108664852, 0.16652291108664852, 0.16652291108664852, 0.10466767754362083, 0.10466767754362083, 0.10466767754362083, 0.09291236323231444, 0.09291236323231444, 0.09291236323231444, 0.10517235882147069, 0.10517235882147069, 0.10517235882147069, 0.9833545195335007, 0.9833545195335007, 0.9833545195335007, 0.9871312113475053, 0.9871312113475053, 0.9871312113475053, 0.9817455104503656, 0.9817455104503656, 0.9817455104503656, 0.5806944519409704, 0.5806944519409704, 0.5806944519409704, 0.14423568085985283, 0.14423568085985283, 0.14423568085985283, 0.5911785299343953, 0.5911785299343953, 0.5911785299343953, 0.7400072527876258, 0.7400072527876258, 0.7400072527876258, 0.26202650903954405, 0.26202650903954405, 0.26202650903954405, 0.21908199948287288, 0.21908199948287288, 0.21908199948287288, 0.20192541633565386, 0.20192541633565386, 0.20192541633565386, 0.19904632776676057, 0.19904632776676057, 0.19904632776676057, 0.22538103130323728, 0.22538103130323728, 0.22538103130323728, 0.1998007651684518, 0.1998007651684518, 0.1998007651684518, 0.1995406537348675, 0.1995406537348675, 0.1995406537348675, 0.24654441451171283, 0.24654441451171283, 0.24654441451171283, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09722994563995213, 0.09722994563995213, 0.09722994563995213, 0.09748822614305641, 0.09748822614305641, 0.09748822614305641, 0.10104045285987595, 0.10104045285987595, 0.10104045285987595, 0.042641874991652395, 0.042641874991652395, 0.042641874991652395, 0.09841498793876513, 0.09841498793876513, 0.09841498793876513, 0.07558965107527604, 0.07558965107527604, 0.07558965107527604, 0.20657030904989082, 0.20657030904989082, 0.20657030904989082, 0.03642382602512517, 0.03642382602512517, 0.03642382602512517, 0.048298767491661954, 0.048298767491661954, 0.048298767491661954, 0.5614216874681467, 0.5614216874681467, 0.5614216874681467, 0.49657700220533374, 0.49657700220533374, 0.49657700220533374, 0.5170455187243754, 0.5170455187243754, 0.5170455187243754, 0.13508326494619027, 0.13508326494619027, 0.13508326494619027, 0.11950025422041399, 0.11950025422041399, 0.11950025422041399, 0.11512622398485983, 0.11512622398485983, 0.11512622398485983, 0.1534042770376467, 0.1534042770376467, 0.1534042770376467, 0.17247856409263362, 0.17247856409263362, 0.17247856409263362, 0.1854014647609713, 0.1854014647609713, 0.1854014647609713, 0.37720084702576306, 0.37720084702576306, 0.37720084702576306, 0.25273891203489507, 0.25273891203489507, 0.25273891203489507, 0.29120254634287, 0.29120254634287, 0.29120254634287, 0.2313683903750654, 0.2313683903750654, 0.2313683903750654, 0.1971470274093733, 0.1971470274093733, 0.1971470274093733, 0.28983987274269485, 0.28983987274269485, 0.28983987274269485, 0.21232565905441736, 0.21232565905441736, 0.21232565905441736, 0.2116917203990608, 0.2116917203990608, 0.2116917203990608, 0.2117417245344626, 0.2117417245344626, 0.2117417245344626, 0.6567070012885114, 0.6567070012885114, 0.6567070012885114, 0.2002749375160504, 0.2002749375160504, 0.2002749375160504, 0.23261418999257366, 0.23261418999257366, 0.23261418999257366, 0.8513823302653051, 0.8513823302653051, 0.8513823302653051, 0.8145276842865627, 0.8145276842865627, 0.8145276842865627, 0.185066515166604, 0.185066515166604, 0.185066515166604, 0.16575140942497746, 0.16575140942497746, 0.16575140942497746, 0.5666900485617927, 0.5666900485617927, 0.5666900485617927, 0.16399352629422792, 0.16399352629422792, 0.16399352629422792, 0.1898442051167626, 0.1898442051167626, 0.1898442051167626, 0.18695400864257494, 0.18695400864257494, 0.18695400864257494, 0.1950965428045024, 0.1950965428045024, 0.1950965428045024, 0.08470179797976873, 0.08470179797976873, 0.08470179797976873, 0.08797544648693856, 0.08797544648693856, 0.08797544648693856, 0.0813902914167105, 0.0813902914167105, 0.0813902914167105]}, "mutation_prompt": null}
{"id": "7519a3cf-e448-4fb1-ab53-7c9a69302c61", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F_initial = 0.8  # Initial DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n            # Adaptive scaling factor\n            self.F = self.F_initial + 0.2 * np.sin(np.pi * eval_count / self.budget)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce an adaptive dynamic factor for the scaling parameter F to enhance diversity during mutation.", "configspace": "", "generation": 57, "fitness": 0.29341052345608076, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.26.", "error": "", "parent_id": "079f7d2a-609d-44ee-8bb1-0191036c2212", "metadata": {"aucs": [0.7738765361300723, 0.7738765361300723, 0.7738765361300723, 0.7690018583433664, 0.7690018583433664, 0.7690018583433664, 0.7918729824858982, 0.7918729824858982, 0.7918729824858982, 0.5614880625301945, 0.5614880625301945, 0.5614880625301945, 0.6042806225772519, 0.6042806225772519, 0.6042806225772519, 0.5378004549888187, 0.5378004549888187, 0.5378004549888187, 0.1416327041748906, 0.1416327041748906, 0.1416327041748906, 0.06313573483166002, 0.06313573483166002, 0.06313573483166002, 0.16202912357250931, 0.16202912357250931, 0.16202912357250931, 0.10399698482852726, 0.10399698482852726, 0.10399698482852726, 0.11516679466710045, 0.11516679466710045, 0.11516679466710045, 0.10841949010890217, 0.10841949010890217, 0.10841949010890217, 0.9833546298143669, 0.9833546298143669, 0.9833546298143669, 0.9871321796476177, 0.9871321796476177, 0.9871321796476177, 0.9817498452917998, 0.9817498452917998, 0.9817498452917998, 0.5988843095366254, 0.5988843095366254, 0.5988843095366254, 0.5719926855464477, 0.5719926855464477, 0.5719926855464477, 0.607199617304913, 0.607199617304913, 0.607199617304913, 0.5945957311313224, 0.5945957311313224, 0.5945957311313224, 0.1613237577817237, 0.1613237577817237, 0.1613237577817237, 0.6077880032052996, 0.6077880032052996, 0.6077880032052996, 0.19750873221179233, 0.19750873221179233, 0.19750873221179233, 0.20340722786775323, 0.20340722786775323, 0.20340722786775323, 0.12681420968221735, 0.12681420968221735, 0.12681420968221735, 0.2029790767680414, 0.2029790767680414, 0.2029790767680414, 0.20170069279561165, 0.20170069279561165, 0.20170069279561165, 0.23728066520567515, 0.23728066520567515, 0.23728066520567515, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10224047022479277, 0.10224047022479277, 0.10224047022479277, 0.026950379702466498, 0.026950379702466498, 0.026950379702466498, 0.06794653704215325, 0.06794653704215325, 0.06794653704215325, 0.04460975225984054, 0.04460975225984054, 0.04460975225984054, 0.09206518628665472, 0.09206518628665472, 0.09206518628665472, 0.07044680192634856, 0.07044680192634856, 0.07044680192634856, 0.06800336732010981, 0.06800336732010981, 0.06800336732010981, 0.03521714947241239, 0.03521714947241239, 0.03521714947241239, 0.0489945215498474, 0.0489945215498474, 0.0489945215498474, 0.5114959926203708, 0.5114959926203708, 0.5114959926203708, 0.49922570411814327, 0.49922570411814327, 0.49922570411814327, 0.5311518985638191, 0.5311518985638191, 0.5311518985638191, 0.0787474821233849, 0.0787474821233849, 0.0787474821233849, 0.139194057855348, 0.139194057855348, 0.139194057855348, 0.12619057199158068, 0.12619057199158068, 0.12619057199158068, 0.24088317470035836, 0.24088317470035836, 0.24088317470035836, 0.16560629007461614, 0.16560629007461614, 0.16560629007461614, 0.2814991916734515, 0.2814991916734515, 0.2814991916734515, 0.24778486711222436, 0.24778486711222436, 0.24778486711222436, 0.2101491281616702, 0.2101491281616702, 0.2101491281616702, 0.18996464317616224, 0.18996464317616224, 0.18996464317616224, 0.22934835720431646, 0.22934835720431646, 0.22934835720431646, 0.20608637317419454, 0.20608637317419454, 0.20608637317419454, 0.34069001694267886, 0.34069001694267886, 0.34069001694267886, 0.2194849672222846, 0.2194849672222846, 0.2194849672222846, 0.20419111230848208, 0.20419111230848208, 0.20419111230848208, 0.18598360877049214, 0.18598360877049214, 0.18598360877049214, 0.20938428206658477, 0.20938428206658477, 0.20938428206658477, 0.19916047557195082, 0.19916047557195082, 0.19916047557195082, 0.19688526834071374, 0.19688526834071374, 0.19688526834071374, 0.8275053099104074, 0.8275053099104074, 0.8275053099104074, 0.7481902965527305, 0.7481902965527305, 0.7481902965527305, 0.1844130282832812, 0.1844130282832812, 0.1844130282832812, 0.16577109914856392, 0.16577109914856392, 0.16577109914856392, 0.4202820633898334, 0.4202820633898334, 0.4202820633898334, 0.16412986879772684, 0.16412986879772684, 0.16412986879772684, 0.17923082103700494, 0.17923082103700494, 0.17923082103700494, 0.19630403085210213, 0.19630403085210213, 0.19630403085210213, 0.2010847633592593, 0.2010847633592593, 0.2010847633592593, 0.10183216429920194, 0.10183216429920194, 0.10183216429920194, 0.08797235885146515, 0.08797235885146515, 0.08797235885146515, 0.08254754176838619, 0.08254754176838619, 0.08254754176838619]}, "mutation_prompt": null}
{"id": "efdaa122-27ae-4c52-a5fa-e60f5d4a0d71", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a dynamic crossover probability adjustment to enhance exploration and convergence adaptively.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "079f7d2a-609d-44ee-8bb1-0191036c2212", "metadata": {"aucs": [0.7972135001875267, 0.7972135001875267, 0.7972135001875267, 0.7827070990845291, 0.7827070990845291, 0.7827070990845291, 0.8025122245282456, 0.8025122245282456, 0.8025122245282456, 0.5852561590897933, 0.5852561590897933, 0.5852561590897933, 0.5814276675436745, 0.5814276675436745, 0.5814276675436745, 0.5865243103582025, 0.5865243103582025, 0.5865243103582025, 0.14729906130494597, 0.14729906130494597, 0.14729906130494597, 0.4646831752751186, 0.4646831752751186, 0.4646831752751186, 0.16652291108664852, 0.16652291108664852, 0.16652291108664852, 0.10466767754362083, 0.10466767754362083, 0.10466767754362083, 0.09291236323231444, 0.09291236323231444, 0.09291236323231444, 0.10517235882147069, 0.10517235882147069, 0.10517235882147069, 0.9833545195335007, 0.9833545195335007, 0.9833545195335007, 0.9871312113475053, 0.9871312113475053, 0.9871312113475053, 0.9817455104503656, 0.9817455104503656, 0.9817455104503656, 0.5806944519409704, 0.5806944519409704, 0.5806944519409704, 0.14423568085985283, 0.14423568085985283, 0.14423568085985283, 0.5911785299343953, 0.5911785299343953, 0.5911785299343953, 0.7400072527876258, 0.7400072527876258, 0.7400072527876258, 0.26202650903954405, 0.26202650903954405, 0.26202650903954405, 0.21908199948287288, 0.21908199948287288, 0.21908199948287288, 0.20192541633565386, 0.20192541633565386, 0.20192541633565386, 0.19904632776676057, 0.19904632776676057, 0.19904632776676057, 0.22538103130323728, 0.22538103130323728, 0.22538103130323728, 0.1998007651684518, 0.1998007651684518, 0.1998007651684518, 0.1995406537348675, 0.1995406537348675, 0.1995406537348675, 0.24654441451171283, 0.24654441451171283, 0.24654441451171283, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09722994563995213, 0.09722994563995213, 0.09722994563995213, 0.09748822614305641, 0.09748822614305641, 0.09748822614305641, 0.10104045285987595, 0.10104045285987595, 0.10104045285987595, 0.042641874991652395, 0.042641874991652395, 0.042641874991652395, 0.09841498793876513, 0.09841498793876513, 0.09841498793876513, 0.07558965107527604, 0.07558965107527604, 0.07558965107527604, 0.20657030904989082, 0.20657030904989082, 0.20657030904989082, 0.03642382602512517, 0.03642382602512517, 0.03642382602512517, 0.048298767491661954, 0.048298767491661954, 0.048298767491661954, 0.5614216874681467, 0.5614216874681467, 0.5614216874681467, 0.49657700220533374, 0.49657700220533374, 0.49657700220533374, 0.5170455187243754, 0.5170455187243754, 0.5170455187243754, 0.13508326494619027, 0.13508326494619027, 0.13508326494619027, 0.11950025422041399, 0.11950025422041399, 0.11950025422041399, 0.11512622398485983, 0.11512622398485983, 0.11512622398485983, 0.1534042770376467, 0.1534042770376467, 0.1534042770376467, 0.17247856409263362, 0.17247856409263362, 0.17247856409263362, 0.1854014647609713, 0.1854014647609713, 0.1854014647609713, 0.37720084702576306, 0.37720084702576306, 0.37720084702576306, 0.25273891203489507, 0.25273891203489507, 0.25273891203489507, 0.29120254634287, 0.29120254634287, 0.29120254634287, 0.2313683903750654, 0.2313683903750654, 0.2313683903750654, 0.1971470274093733, 0.1971470274093733, 0.1971470274093733, 0.28983987274269485, 0.28983987274269485, 0.28983987274269485, 0.21232565905441736, 0.21232565905441736, 0.21232565905441736, 0.2116917203990608, 0.2116917203990608, 0.2116917203990608, 0.2117417245344626, 0.2117417245344626, 0.2117417245344626, 0.6567070012885114, 0.6567070012885114, 0.6567070012885114, 0.2002749375160504, 0.2002749375160504, 0.2002749375160504, 0.23261418999257366, 0.23261418999257366, 0.23261418999257366, 0.8513823302653051, 0.8513823302653051, 0.8513823302653051, 0.8145276842865627, 0.8145276842865627, 0.8145276842865627, 0.185066515166604, 0.185066515166604, 0.185066515166604, 0.16575140942497746, 0.16575140942497746, 0.16575140942497746, 0.5666900485617927, 0.5666900485617927, 0.5666900485617927, 0.16399352629422792, 0.16399352629422792, 0.16399352629422792, 0.1898442051167626, 0.1898442051167626, 0.1898442051167626, 0.18695400864257494, 0.18695400864257494, 0.18695400864257494, 0.1950965428045024, 0.1950965428045024, 0.1950965428045024, 0.08470179797976873, 0.08470179797976873, 0.08470179797976873, 0.08797544648693856, 0.08797544648693856, 0.08797544648693856, 0.0813902914167105, 0.0813902914167105, 0.0813902914167105]}, "mutation_prompt": null}
{"id": "3b394b9b-2ec5-4144-927a-3fd0d64f27cf", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F_initial = 0.5  # Initial DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n            # Dynamic mutation factor\n            self.F = self.F_initial + (0.9 - self.F_initial) * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Incorporate a dynamic mutation factor adjustment to improve exploration and balance convergence.", "configspace": "", "generation": 59, "fitness": 0.2724513808227422, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.26.", "error": "", "parent_id": "079f7d2a-609d-44ee-8bb1-0191036c2212", "metadata": {"aucs": [0.8076308764080695, 0.8076308764080695, 0.8076308764080695, 0.7932004447359101, 0.7932004447359101, 0.7932004447359101, 0.7955421429956923, 0.7955421429956923, 0.7955421429956923, 0.06698397639380305, 0.06698397639380305, 0.06698397639380305, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.595462627219629, 0.595462627219629, 0.595462627219629, 0.12008286657621281, 0.12008286657621281, 0.12008286657621281, 0.15141422911576297, 0.15141422911576297, 0.15141422911576297, 0.1368612599604001, 0.1368612599604001, 0.1368612599604001, 0.14543603874093036, 0.14543603874093036, 0.14543603874093036, 0.09333199787091395, 0.09333199787091395, 0.09333199787091395, 0.10685354239310307, 0.10685354239310307, 0.10685354239310307, 0.9827595742099549, 0.9827595742099549, 0.9827595742099549, 0.9865448131714556, 0.9865448131714556, 0.9865448131714556, 0.9826975578118056, 0.9826975578118056, 0.9826975578118056, 0.5893007042961478, 0.5893007042961478, 0.5893007042961478, 0.14577210119279893, 0.14577210119279893, 0.14577210119279893, 0.607737234076356, 0.607737234076356, 0.607737234076356, 0.6169627046711532, 0.6169627046711532, 0.6169627046711532, 0.27117610026635763, 0.27117610026635763, 0.27117610026635763, 0.1639628182062326, 0.1639628182062326, 0.1639628182062326, 0.21279173511340077, 0.21279173511340077, 0.21279173511340077, 0.20276729573107788, 0.20276729573107788, 0.20276729573107788, 0.20683600846082795, 0.20683600846082795, 0.20683600846082795, 0.19393949949413547, 0.19393949949413547, 0.19393949949413547, 0.19721537111135357, 0.19721537111135357, 0.19721537111135357, 0.2174771260453584, 0.2174771260453584, 0.2174771260453584, 0.035361438779528354, 0.035361438779528354, 0.035361438779528354, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.014736041273603395, 0.014736041273603395, 0.014736041273603395, 0.057707000806747066, 0.057707000806747066, 0.057707000806747066, 0.0756437710270026, 0.0756437710270026, 0.0756437710270026, 0.08528675121731466, 0.08528675121731466, 0.08528675121731466, 0.1336369975915097, 0.1336369975915097, 0.1336369975915097, 0.08305508186018196, 0.08305508186018196, 0.08305508186018196, 0.00948524580164467, 0.00948524580164467, 0.00948524580164467, 0.036680272346287346, 0.036680272346287346, 0.036680272346287346, 0.047049652375293904, 0.047049652375293904, 0.047049652375293904, 0.4977013903392532, 0.4977013903392532, 0.4977013903392532, 0.5598560325040522, 0.5598560325040522, 0.5598560325040522, 0.5639159083780021, 0.5639159083780021, 0.5639159083780021, 0.08714011119639731, 0.08714011119639731, 0.08714011119639731, 0.12886705429102363, 0.12886705429102363, 0.12886705429102363, 0.12321999796310634, 0.12321999796310634, 0.12321999796310634, 0.210628928134321, 0.210628928134321, 0.210628928134321, 0.1595632317902761, 0.1595632317902761, 0.1595632317902761, 0.25728521645081015, 0.25728521645081015, 0.25728521645081015, 0.3401845783029691, 0.3401845783029691, 0.3401845783029691, 0.26059760024630063, 0.26059760024630063, 0.26059760024630063, 0.16800546465700805, 0.16800546465700805, 0.16800546465700805, 0.2952195256622292, 0.2952195256622292, 0.2952195256622292, 0.1822634922415315, 0.1822634922415315, 0.1822634922415315, 0.13190345635899847, 0.13190345635899847, 0.13190345635899847, 0.1831588489864241, 0.1831588489864241, 0.1831588489864241, 0.20165112707879684, 0.20165112707879684, 0.20165112707879684, 0.20347756241445047, 0.20347756241445047, 0.20347756241445047, 0.6006523931686474, 0.6006523931686474, 0.6006523931686474, 0.24694348910553, 0.24694348910553, 0.24694348910553, 0.2201522299858134, 0.2201522299858134, 0.2201522299858134, 0.8662239370168219, 0.8662239370168219, 0.8662239370168219, 0.15757614708885903, 0.15757614708885903, 0.15757614708885903, 0.15743098880549244, 0.15743098880549244, 0.15743098880549244, 0.6331606182676266, 0.6331606182676266, 0.6331606182676266, 0.16897567630068644, 0.16897567630068644, 0.16897567630068644, 0.15485240564702907, 0.15485240564702907, 0.15485240564702907, 0.20311801957208997, 0.20311801957208997, 0.20311801957208997, 0.1963357239811082, 0.1963357239811082, 0.1963357239811082, 0.2117366245225223, 0.2117366245225223, 0.2117366245225223, 0.09324155456231498, 0.09324155456231498, 0.09324155456231498, 0.08154417858454677, 0.08154417858454677, 0.08154417858454677, 0.10023300628444065, 0.10023300628444065, 0.10023300628444065]}, "mutation_prompt": null}
{"id": "e49b965b-7041-4e0b-a780-e99259b5e2cf", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.6  # Slightly increased Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a minor increase in social component weight to enhance global exploration.", "configspace": "", "generation": 60, "fitness": 0.27239587391618014, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.26.", "error": "", "parent_id": "079f7d2a-609d-44ee-8bb1-0191036c2212", "metadata": {"aucs": [0.7929013670943545, 0.7929013670943545, 0.7929013670943545, 0.7802045208887931, 0.7802045208887931, 0.7802045208887931, 0.7850696486183236, 0.7850696486183236, 0.7850696486183236, 0.06083069861795121, 0.06083069861795121, 0.06083069861795121, 0.5828522636251496, 0.5828522636251496, 0.5828522636251496, 0.004377968775472474, 0.004377968775472474, 0.004377968775472474, 0.13875158507656993, 0.13875158507656993, 0.13875158507656993, 0.13563723480664192, 0.13563723480664192, 0.13563723480664192, 0.12934698063464023, 0.12934698063464023, 0.12934698063464023, 0.085844101817384, 0.085844101817384, 0.085844101817384, 0.04534695053915605, 0.04534695053915605, 0.04534695053915605, 0.11484994513781333, 0.11484994513781333, 0.11484994513781333, 0.9827534719477455, 0.9827534719477455, 0.9827534719477455, 0.9872302500555139, 0.9872302500555139, 0.9872302500555139, 0.9817840417017509, 0.9817840417017509, 0.9817840417017509, 0.5841619375586288, 0.5841619375586288, 0.5841619375586288, 0.5227094213874148, 0.5227094213874148, 0.5227094213874148, 0.6004664392184086, 0.6004664392184086, 0.6004664392184086, 0.6623655545819866, 0.6623655545819866, 0.6623655545819866, 0.34083313761851364, 0.34083313761851364, 0.34083313761851364, 0.1712548063726297, 0.1712548063726297, 0.1712548063726297, 0.19519237040520743, 0.19519237040520743, 0.19519237040520743, 0.1205837115741566, 0.1205837115741566, 0.1205837115741566, 0.1821232166048239, 0.1821232166048239, 0.1821232166048239, 0.216988263730289, 0.216988263730289, 0.216988263730289, 0.21395981459454239, 0.21395981459454239, 0.21395981459454239, 0.19288909111098473, 0.19288909111098473, 0.19288909111098473, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07221823403917593, 0.07221823403917593, 0.07221823403917593, 0.005192510821167562, 0.005192510821167562, 0.005192510821167562, 0.0260025991931796, 0.0260025991931796, 0.0260025991931796, 0.043570670690590285, 0.043570670690590285, 0.043570670690590285, 0.1626765173139727, 0.1626765173139727, 0.1626765173139727, 0.07840743844439824, 0.07840743844439824, 0.07840743844439824, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06109680107994431, 0.06109680107994431, 0.06109680107994431, 0.04803603903876197, 0.04803603903876197, 0.04803603903876197, 0.4951227640762168, 0.4951227640762168, 0.4951227640762168, 0.4991771815890015, 0.4991771815890015, 0.4991771815890015, 0.5178623332101935, 0.5178623332101935, 0.5178623332101935, 0.0917214501201783, 0.0917214501201783, 0.0917214501201783, 0.10113478815986943, 0.10113478815986943, 0.10113478815986943, 0.13901053446829648, 0.13901053446829648, 0.13901053446829648, 0.2438137552875249, 0.2438137552875249, 0.2438137552875249, 0.2439716927275276, 0.2439716927275276, 0.2439716927275276, 0.24736462853339503, 0.24736462853339503, 0.24736462853339503, 0.30021361376954847, 0.30021361376954847, 0.30021361376954847, 0.22778348601387854, 0.22778348601387854, 0.22778348601387854, 0.4000686965972301, 0.4000686965972301, 0.4000686965972301, 0.2175762510458017, 0.2175762510458017, 0.2175762510458017, 0.18552803525157646, 0.18552803525157646, 0.18552803525157646, 0.21605778663525987, 0.21605778663525987, 0.21605778663525987, 0.24911831133925721, 0.24911831133925721, 0.24911831133925721, 0.20237651201963247, 0.20237651201963247, 0.20237651201963247, 0.2165774363350118, 0.2165774363350118, 0.2165774363350118, 0.21342449754826343, 0.21342449754826343, 0.21342449754826343, 0.23191566748735937, 0.23191566748735937, 0.23191566748735937, 0.6154729098671963, 0.6154729098671963, 0.6154729098671963, 0.8464704862056704, 0.8464704862056704, 0.8464704862056704, 0.21023965305588954, 0.21023965305588954, 0.21023965305588954, 0.18830534455202685, 0.18830534455202685, 0.18830534455202685, 0.16738338978490397, 0.16738338978490397, 0.16738338978490397, 0.21778926880207006, 0.21778926880207006, 0.21778926880207006, 0.1543314262018174, 0.1543314262018174, 0.1543314262018174, 0.18765285909079854, 0.18765285909079854, 0.18765285909079854, 0.19381695183040826, 0.19381695183040826, 0.19381695183040826, 0.22070716847020322, 0.22070716847020322, 0.22070716847020322, 0.09125175292688803, 0.09125175292688803, 0.09125175292688803, 0.08362251292071199, 0.08362251292071199, 0.08362251292071199, 0.08673017132532701, 0.08673017132532701, 0.08673017132532701]}, "mutation_prompt": null}
{"id": "68586df1-2547-4919-92c1-ed30230f8671", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F_initial = 0.8  # DE initial scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n            # Dynamic scaling factor\n            self.F = self.F_initial + 0.2 * np.sin(np.pi * eval_count / self.budget)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a dynamic scaling factor adjustment to enhance exploration and convergence adaptively.", "configspace": "", "generation": 61, "fitness": 0.29341052345608076, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.26.", "error": "", "parent_id": "079f7d2a-609d-44ee-8bb1-0191036c2212", "metadata": {"aucs": [0.7738765361300723, 0.7738765361300723, 0.7738765361300723, 0.7690018583433664, 0.7690018583433664, 0.7690018583433664, 0.7918729824858982, 0.7918729824858982, 0.7918729824858982, 0.5614880625301945, 0.5614880625301945, 0.5614880625301945, 0.6042806225772519, 0.6042806225772519, 0.6042806225772519, 0.5378004549888187, 0.5378004549888187, 0.5378004549888187, 0.1416327041748906, 0.1416327041748906, 0.1416327041748906, 0.06313573483166002, 0.06313573483166002, 0.06313573483166002, 0.16202912357250931, 0.16202912357250931, 0.16202912357250931, 0.10399698482852726, 0.10399698482852726, 0.10399698482852726, 0.11516679466710045, 0.11516679466710045, 0.11516679466710045, 0.10841949010890217, 0.10841949010890217, 0.10841949010890217, 0.9833546298143669, 0.9833546298143669, 0.9833546298143669, 0.9871321796476177, 0.9871321796476177, 0.9871321796476177, 0.9817498452917998, 0.9817498452917998, 0.9817498452917998, 0.5988843095366254, 0.5988843095366254, 0.5988843095366254, 0.5719926855464477, 0.5719926855464477, 0.5719926855464477, 0.607199617304913, 0.607199617304913, 0.607199617304913, 0.5945957311313224, 0.5945957311313224, 0.5945957311313224, 0.1613237577817237, 0.1613237577817237, 0.1613237577817237, 0.6077880032052996, 0.6077880032052996, 0.6077880032052996, 0.19750873221179233, 0.19750873221179233, 0.19750873221179233, 0.20340722786775323, 0.20340722786775323, 0.20340722786775323, 0.12681420968221735, 0.12681420968221735, 0.12681420968221735, 0.2029790767680414, 0.2029790767680414, 0.2029790767680414, 0.20170069279561165, 0.20170069279561165, 0.20170069279561165, 0.23728066520567515, 0.23728066520567515, 0.23728066520567515, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10224047022479277, 0.10224047022479277, 0.10224047022479277, 0.026950379702466498, 0.026950379702466498, 0.026950379702466498, 0.06794653704215325, 0.06794653704215325, 0.06794653704215325, 0.04460975225984054, 0.04460975225984054, 0.04460975225984054, 0.09206518628665472, 0.09206518628665472, 0.09206518628665472, 0.07044680192634856, 0.07044680192634856, 0.07044680192634856, 0.06800336732010981, 0.06800336732010981, 0.06800336732010981, 0.03521714947241239, 0.03521714947241239, 0.03521714947241239, 0.0489945215498474, 0.0489945215498474, 0.0489945215498474, 0.5114959926203708, 0.5114959926203708, 0.5114959926203708, 0.49922570411814327, 0.49922570411814327, 0.49922570411814327, 0.5311518985638191, 0.5311518985638191, 0.5311518985638191, 0.0787474821233849, 0.0787474821233849, 0.0787474821233849, 0.139194057855348, 0.139194057855348, 0.139194057855348, 0.12619057199158068, 0.12619057199158068, 0.12619057199158068, 0.24088317470035836, 0.24088317470035836, 0.24088317470035836, 0.16560629007461614, 0.16560629007461614, 0.16560629007461614, 0.2814991916734515, 0.2814991916734515, 0.2814991916734515, 0.24778486711222436, 0.24778486711222436, 0.24778486711222436, 0.2101491281616702, 0.2101491281616702, 0.2101491281616702, 0.18996464317616224, 0.18996464317616224, 0.18996464317616224, 0.22934835720431646, 0.22934835720431646, 0.22934835720431646, 0.20608637317419454, 0.20608637317419454, 0.20608637317419454, 0.34069001694267886, 0.34069001694267886, 0.34069001694267886, 0.2194849672222846, 0.2194849672222846, 0.2194849672222846, 0.20419111230848208, 0.20419111230848208, 0.20419111230848208, 0.18598360877049214, 0.18598360877049214, 0.18598360877049214, 0.20938428206658477, 0.20938428206658477, 0.20938428206658477, 0.19916047557195082, 0.19916047557195082, 0.19916047557195082, 0.19688526834071374, 0.19688526834071374, 0.19688526834071374, 0.8275053099104074, 0.8275053099104074, 0.8275053099104074, 0.7481902965527305, 0.7481902965527305, 0.7481902965527305, 0.1844130282832812, 0.1844130282832812, 0.1844130282832812, 0.16577109914856392, 0.16577109914856392, 0.16577109914856392, 0.4202820633898334, 0.4202820633898334, 0.4202820633898334, 0.16412986879772684, 0.16412986879772684, 0.16412986879772684, 0.17923082103700494, 0.17923082103700494, 0.17923082103700494, 0.19630403085210213, 0.19630403085210213, 0.19630403085210213, 0.2010847633592593, 0.2010847633592593, 0.2010847633592593, 0.10183216429920194, 0.10183216429920194, 0.10183216429920194, 0.08797235885146515, 0.08797235885146515, 0.08797235885146515, 0.08254754176838619, 0.08254754176838619, 0.08254754176838619]}, "mutation_prompt": null}
{"id": "f84a2947-61a4-4ec6-b9a2-40460ab92722", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive inertia weight with random variation\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget) + np.random.uniform(-0.05, 0.05)\n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Integrate dynamic velocity scaling for enhanced speed adaptability in exploration and exploitation.", "configspace": "", "generation": 62, "fitness": 0.3081804552024759, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.29.", "error": "", "parent_id": "079f7d2a-609d-44ee-8bb1-0191036c2212", "metadata": {"aucs": [0.896610442585393, 0.896610442585393, 0.896610442585393, 0.883745110227551, 0.883745110227551, 0.883745110227551, 0.9076504641069262, 0.9076504641069262, 0.9076504641069262, 0.04085929089881957, 0.04085929089881957, 0.04085929089881957, 0.0647563789355039, 0.0647563789355039, 0.0647563789355039, 0.7949681721454412, 0.7949681721454412, 0.7949681721454412, 0.14632531400558324, 0.14632531400558324, 0.14632531400558324, 0.1793296382595887, 0.1793296382595887, 0.1793296382595887, 0.1412692929605528, 0.1412692929605528, 0.1412692929605528, 0.1072102069079478, 0.1072102069079478, 0.1072102069079478, 0.17723860996672014, 0.17723860996672014, 0.17723860996672014, 0.11136077141298795, 0.11136077141298795, 0.11136077141298795, 0.9833246952566623, 0.9833246952566623, 0.9833246952566623, 0.9875898125157715, 0.9875898125157715, 0.9875898125157715, 0.9800383267602509, 0.9800383267602509, 0.9800383267602509, 0.796359939043406, 0.796359939043406, 0.796359939043406, 0.7116193028236476, 0.7116193028236476, 0.7116193028236476, 0.7441827709625337, 0.7441827709625337, 0.7441827709625337, 0.37506665027839703, 0.37506665027839703, 0.37506665027839703, 0.19339639322931967, 0.19339639322931967, 0.19339639322931967, 0.11633333726173001, 0.11633333726173001, 0.11633333726173001, 0.2322535094096838, 0.2322535094096838, 0.2322535094096838, 0.22168201549582023, 0.22168201549582023, 0.22168201549582023, 0.22902059650621553, 0.22902059650621553, 0.22902059650621553, 0.13069852724734787, 0.13069852724734787, 0.13069852724734787, 0.2535858356506886, 0.2535858356506886, 0.2535858356506886, 0.25451040604769826, 0.25451040604769826, 0.25451040604769826, 0.05467123761540715, 0.05467123761540715, 0.05467123761540715, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05957496968607079, 0.05957496968607079, 0.05957496968607079, 0.06065542969444737, 0.06065542969444737, 0.06065542969444737, 0.0803355186706336, 0.0803355186706336, 0.0803355186706336, 0.14094487043866955, 0.14094487043866955, 0.14094487043866955, 0.1005948121581356, 0.1005948121581356, 0.1005948121581356, 0.08431555938019941, 0.08431555938019941, 0.08431555938019941, 0.14677820078248316, 0.14677820078248316, 0.14677820078248316, 0.03902294430261133, 0.03902294430261133, 0.03902294430261133, 0.05675500439459846, 0.05675500439459846, 0.05675500439459846, 0.6127193965078332, 0.6127193965078332, 0.6127193965078332, 0.5674356334325567, 0.5674356334325567, 0.5674356334325567, 0.6247065635659024, 0.6247065635659024, 0.6247065635659024, 0.09770439401643749, 0.09770439401643749, 0.09770439401643749, 0.11165592017671733, 0.11165592017671733, 0.11165592017671733, 0.12189908183604858, 0.12189908183604858, 0.12189908183604858, 0.19405670558650256, 0.19405670558650256, 0.19405670558650256, 0.17513351230295304, 0.17513351230295304, 0.17513351230295304, 0.15937929045489307, 0.15937929045489307, 0.15937929045489307, 0.38007268327135546, 0.38007268327135546, 0.38007268327135546, 0.2535125009497443, 0.2535125009497443, 0.2535125009497443, 0.2909909544596875, 0.2909909544596875, 0.2909909544596875, 0.35483246337708485, 0.35483246337708485, 0.35483246337708485, 0.20542546399911255, 0.20542546399911255, 0.20542546399911255, 0.18561199658599536, 0.18561199658599536, 0.18561199658599536, 0.260032535418267, 0.260032535418267, 0.260032535418267, 0.21466362269840156, 0.21466362269840156, 0.21466362269840156, 0.23234054563075113, 0.23234054563075113, 0.23234054563075113, 0.2072278931435566, 0.2072278931435566, 0.2072278931435566, 0.8189113342545123, 0.8189113342545123, 0.8189113342545123, 0.2513023004284376, 0.2513023004284376, 0.2513023004284376, 0.9184356278475595, 0.9184356278475595, 0.9184356278475595, 0.8837510588778458, 0.8837510588778458, 0.8837510588778458, 0.18893995077798176, 0.18893995077798176, 0.18893995077798176, 0.1617892116586832, 0.1617892116586832, 0.1617892116586832, 0.16865590945791553, 0.16865590945791553, 0.16865590945791553, 0.15616911236242847, 0.15616911236242847, 0.15616911236242847, 0.19988185817504622, 0.19988185817504622, 0.19988185817504622, 0.19966139149470508, 0.19966139149470508, 0.19966139149470508, 0.22986485357694064, 0.22986485357694064, 0.22986485357694064, 0.10136636525397702, 0.10136636525397702, 0.10136636525397702, 0.0855876718904055, 0.0855876718904055, 0.0855876718904055, 0.09044061308258011, 0.09044061308258011, 0.09044061308258011]}, "mutation_prompt": null}
{"id": "752dd08c-a8a0-437e-a468-27f2d1777563", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Conditional Inertia Weight Decay\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9  # Decay if a valid best solution is found\n            \n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a conditional inertia weight decay based on solution quality to balance exploration and exploitation.", "configspace": "", "generation": 63, "fitness": 0.31347414501980914, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.29.", "error": "", "parent_id": "f84a2947-61a4-4ec6-b9a2-40460ab92722", "metadata": {"aucs": [0.9081787810540243, 0.9081787810540243, 0.9081787810540243, 0.9101954285009074, 0.9101954285009074, 0.9101954285009074, 0.9107841364490106, 0.9107841364490106, 0.9107841364490106, 0.7483156165655127, 0.7483156165655127, 0.7483156165655127, 0.6464815064975709, 0.6464815064975709, 0.6464815064975709, 0.8057354332000595, 0.8057354332000595, 0.8057354332000595, 0.1854605058828822, 0.1854605058828822, 0.1854605058828822, 0.7528346164954676, 0.7528346164954676, 0.7528346164954676, 0.11618409375929628, 0.11618409375929628, 0.11618409375929628, 0.11328750983547686, 0.11328750983547686, 0.11328750983547686, 0.09748030946803321, 0.09748030946803321, 0.09748030946803321, 0.08763212012649457, 0.08763212012649457, 0.08763212012649457, 0.9822702539559259, 0.9822702539559259, 0.9822702539559259, 0.9878512440903272, 0.9878512440903272, 0.9878512440903272, 0.9823039872840109, 0.9823039872840109, 0.9823039872840109, 0.7837329933509061, 0.7837329933509061, 0.7837329933509061, 0.773367818347519, 0.773367818347519, 0.773367818347519, 0.7702476606484692, 0.7702476606484692, 0.7702476606484692, 0.13775432753003392, 0.13775432753003392, 0.13775432753003392, 0.16185252905288394, 0.16185252905288394, 0.16185252905288394, 0.3561666446282913, 0.3561666446282913, 0.3561666446282913, 0.2650441046343073, 0.2650441046343073, 0.2650441046343073, 0.2151683948343659, 0.2151683948343659, 0.2151683948343659, 0.22360049162648332, 0.22360049162648332, 0.22360049162648332, 0.20927190814878438, 0.20927190814878438, 0.20927190814878438, 0.1319635806052354, 0.1319635806052354, 0.1319635806052354, 0.26729225066272544, 0.26729225066272544, 0.26729225066272544, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12535911903603336, 0.12535911903603336, 0.12535911903603336, 0.04679140507916857, 0.04679140507916857, 0.04679140507916857, 0.06291610814836024, 0.06291610814836024, 0.06291610814836024, 0.05165498704204752, 0.05165498704204752, 0.05165498704204752, 0.07924572819360987, 0.07924572819360987, 0.07924572819360987, 0.10223609041920245, 0.10223609041920245, 0.10223609041920245, 0.011208180774248233, 0.011208180774248233, 0.011208180774248233, 0.05924606612892336, 0.05924606612892336, 0.05924606612892336, 0.04893961627237986, 0.04893961627237986, 0.04893961627237986, 0.5663522579219449, 0.5663522579219449, 0.5663522579219449, 0.5677865175606798, 0.5677865175606798, 0.5677865175606798, 0.5818477227805137, 0.5818477227805137, 0.5818477227805137, 0.12131296934582492, 0.12131296934582492, 0.12131296934582492, 0.09254229486638177, 0.09254229486638177, 0.09254229486638177, 0.1267948846921061, 0.1267948846921061, 0.1267948846921061, 0.2260712369338016, 0.2260712369338016, 0.2260712369338016, 0.17528166390727762, 0.17528166390727762, 0.17528166390727762, 0.1563899129342815, 0.1563899129342815, 0.1563899129342815, 0.4107318854645692, 0.4107318854645692, 0.4107318854645692, 0.4074125314300533, 0.4074125314300533, 0.4074125314300533, 0.3540218660266493, 0.3540218660266493, 0.3540218660266493, 0.20688669795363301, 0.20688669795363301, 0.20688669795363301, 0.19655537420618674, 0.19655537420618674, 0.19655537420618674, 0.21353536486091085, 0.21353536486091085, 0.21353536486091085, 0.22573236760843096, 0.22573236760843096, 0.22573236760843096, 0.2466892387496462, 0.2466892387496462, 0.2466892387496462, 0.2154902109555188, 0.2154902109555188, 0.2154902109555188, 0.20700289682426676, 0.20700289682426676, 0.20700289682426676, 0.20732303725656065, 0.20732303725656065, 0.20732303725656065, 0.22795084230993068, 0.22795084230993068, 0.22795084230993068, 0.9368883173438388, 0.9368883173438388, 0.9368883173438388, 0.15911446145811492, 0.15911446145811492, 0.15911446145811492, 0.18603930491011356, 0.18603930491011356, 0.18603930491011356, 0.1686325957866125, 0.1686325957866125, 0.1686325957866125, 0.20931461766796677, 0.20931461766796677, 0.20931461766796677, 0.15638931564339198, 0.15638931564339198, 0.15638931564339198, 0.21345517264865543, 0.21345517264865543, 0.21345517264865543, 0.2002813352445274, 0.2002813352445274, 0.2002813352445274, 0.19398254204571985, 0.19398254204571985, 0.19398254204571985, 0.10278490420029607, 0.10278490420029607, 0.10278490420029607, 0.0985176300044941, 0.0985176300044941, 0.0985176300044941, 0.09267092155437806, 0.09267092155437806, 0.09267092155437806]}, "mutation_prompt": null}
{"id": "43f925c0-9d97-49b7-8824-ecf4a4c7b03d", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n        self.learning_rate = 0.5  # New learning rate factor\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Conditional Inertia Weight Decay\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9  # Decay if a valid best solution is found\n            \n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n                learning_factor = 1 - (eval_count / self.budget) * self.learning_rate\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i])) * learning_factor\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a learning rate factor to dynamically adjust the PSO velocity update based on iteration progress to improve convergence speed.", "configspace": "", "generation": 64, "fitness": 0.2814514595714653, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.29.", "error": "", "parent_id": "752dd08c-a8a0-437e-a468-27f2d1777563", "metadata": {"aucs": [0.9084326505576984, 0.9084326505576984, 0.9084326505576984, 0.9110849799307351, 0.9110849799307351, 0.9110849799307351, 0.9164980073545828, 0.9164980073545828, 0.9164980073545828, 0.041402711293384686, 0.041402711293384686, 0.041402711293384686, 0.06406101138427744, 0.06406101138427744, 0.06406101138427744, 0.8171851252980912, 0.8171851252980912, 0.8171851252980912, 0.12226923898917308, 0.12226923898917308, 0.12226923898917308, 0.10913877392025151, 0.10913877392025151, 0.10913877392025151, 0.14406827458948868, 0.14406827458948868, 0.14406827458948868, 0.11119422774462018, 0.11119422774462018, 0.11119422774462018, 0.07839515848294887, 0.07839515848294887, 0.07839515848294887, 0.05670973810348279, 0.05670973810348279, 0.05670973810348279, 0.9822637531290086, 0.9822637531290086, 0.9822637531290086, 0.9878494238112895, 0.9878494238112895, 0.9878494238112895, 0.9823036620648476, 0.9823036620648476, 0.9823036620648476, 0.817426428373708, 0.817426428373708, 0.817426428373708, 0.7952628667691408, 0.7952628667691408, 0.7952628667691408, 0.7771965296482275, 0.7771965296482275, 0.7771965296482275, 0.13840220967569927, 0.13840220967569927, 0.13840220967569927, 0.21282227563870193, 0.21282227563870193, 0.21282227563870193, 0.21862668906253735, 0.21862668906253735, 0.21862668906253735, 0.16709753779630132, 0.16709753779630132, 0.16709753779630132, 0.13122729280855305, 0.13122729280855305, 0.13122729280855305, 0.20087076250669578, 0.20087076250669578, 0.20087076250669578, 0.13286501971995857, 0.13286501971995857, 0.13286501971995857, 0.20401917990438134, 0.20401917990438134, 0.20401917990438134, 0.19191402052772377, 0.19191402052772377, 0.19191402052772377, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08086245893591115, 0.08086245893591115, 0.08086245893591115, 0.03787353647940794, 0.03787353647940794, 0.03787353647940794, 0.12557249152764383, 0.12557249152764383, 0.12557249152764383, 0.07395890300581764, 0.07395890300581764, 0.07395890300581764, 0.08232876555732493, 0.08232876555732493, 0.08232876555732493, 0.10582049861063458, 0.10582049861063458, 0.10582049861063458, 0.011116437607388452, 0.011116437607388452, 0.011116437607388452, 0.05887866326898017, 0.05887866326898017, 0.05887866326898017, 0.0492708020821756, 0.0492708020821756, 0.0492708020821756, 0.5479645916182961, 0.5479645916182961, 0.5479645916182961, 0.5707896927331091, 0.5707896927331091, 0.5707896927331091, 0.5974255576183845, 0.5974255576183845, 0.5974255576183845, 0.1440817026537521, 0.1440817026537521, 0.1440817026537521, 0.1214455369420322, 0.1214455369420322, 0.1214455369420322, 0.10227360722049905, 0.10227360722049905, 0.10227360722049905, 0.21297174785838902, 0.21297174785838902, 0.21297174785838902, 0.17511994402337883, 0.17511994402337883, 0.17511994402337883, 0.15360405418098022, 0.15360405418098022, 0.15360405418098022, 0.40480682861799855, 0.40480682861799855, 0.40480682861799855, 0.22849408168007534, 0.22849408168007534, 0.22849408168007534, 0.40372610802930586, 0.40372610802930586, 0.40372610802930586, 0.28420011531754186, 0.28420011531754186, 0.28420011531754186, 0.17898101938928535, 0.17898101938928535, 0.17898101938928535, 0.2129702231473285, 0.2129702231473285, 0.2129702231473285, 0.24684665960953112, 0.24684665960953112, 0.24684665960953112, 0.2443181417369924, 0.2443181417369924, 0.2443181417369924, 0.23559143206749822, 0.23559143206749822, 0.23559143206749822, 0.2233892517705589, 0.2233892517705589, 0.2233892517705589, 0.19603143706742698, 0.19603143706742698, 0.19603143706742698, 0.22882875490911514, 0.22882875490911514, 0.22882875490911514, 0.9381913802268003, 0.9381913802268003, 0.9381913802268003, 0.1591200633055616, 0.1591200633055616, 0.1591200633055616, 0.1860450648460985, 0.1860450648460985, 0.1860450648460985, 0.1687367427316936, 0.1687367427316936, 0.1687367427316936, 0.20831730990701924, 0.20831730990701924, 0.20831730990701924, 0.15636620587787697, 0.15636620587787697, 0.15636620587787697, 0.19911099783854136, 0.19911099783854136, 0.19911099783854136, 0.18643616222516035, 0.18643616222516035, 0.18643616222516035, 0.19528994712226921, 0.19528994712226921, 0.19528994712226921, 0.10485433255395582, 0.10485433255395582, 0.10485433255395582, 0.09486813667151728, 0.09486813667151728, 0.09486813667151728, 0.10673815148673271, 0.10673815148673271, 0.10673815148673271]}, "mutation_prompt": null}
{"id": "e1d16bf3-df99-438a-9ed4-86ba5984cab6", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F_initial = 0.8   # Initial DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Conditional Inertia Weight Decay\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9  # Decay if a valid best solution is found\n            \n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Adaptive DE scaling factor based on convergence\n            self.F = self.F_initial * (1 + 0.3 * (1 - best_global_value / np.max(personal_best_values)))\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Add adaptive scaling factor adjustment in DE based on convergence to enhance speed without compromising exploration.", "configspace": "", "generation": 65, "fitness": 0.3028847471363032, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.29.", "error": "", "parent_id": "752dd08c-a8a0-437e-a468-27f2d1777563", "metadata": {"aucs": [0.9112446857746674, 0.9112446857746674, 0.9112446857746674, 0.8976223045923716, 0.8976223045923716, 0.8976223045923716, 0.9068787913871864, 0.9068787913871864, 0.9068787913871864, 0.040360593072897966, 0.040360593072897966, 0.040360593072897966, 0.8091944445373425, 0.8091944445373425, 0.8091944445373425, 0.7764657400799422, 0.7764657400799422, 0.7764657400799422, 0.11213036646614072, 0.11213036646614072, 0.11213036646614072, 0.1550585305956067, 0.1550585305956067, 0.1550585305956067, 0.14311817886100775, 0.14311817886100775, 0.14311817886100775, 0.11034302569230481, 0.11034302569230481, 0.11034302569230481, 0.15640487576351714, 0.15640487576351714, 0.15640487576351714, 0.11573961321177251, 0.11573961321177251, 0.11573961321177251, 0.9841770585089389, 0.9841770585089389, 0.9841770585089389, 0.9897398443434764, 0.9897398443434764, 0.9897398443434764, 0.9809015532211013, 0.9809015532211013, 0.9809015532211013, 0.7705273300044443, 0.7705273300044443, 0.7705273300044443, 0.7502263291711526, 0.7502263291711526, 0.7502263291711526, 0.7560225831586814, 0.7560225831586814, 0.7560225831586814, 0.8828978201613461, 0.8828978201613461, 0.8828978201613461, 0.16230004365822936, 0.16230004365822936, 0.16230004365822936, 0.1378997719309516, 0.1378997719309516, 0.1378997719309516, 0.2351167211801194, 0.2351167211801194, 0.2351167211801194, 0.13446949008104436, 0.13446949008104436, 0.13446949008104436, 0.13218385631208507, 0.13218385631208507, 0.13218385631208507, 0.22121183788569043, 0.22121183788569043, 0.22121183788569043, 0.25367322956400995, 0.25367322956400995, 0.25367322956400995, 0.2536039806998156, 0.2536039806998156, 0.2536039806998156, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.12380310080751766, 0.12380310080751766, 0.12380310080751766, 0.07067294431125026, 0.07067294431125026, 0.07067294431125026, 0.011714435375342336, 0.011714435375342336, 0.011714435375342336, 0.05199160283256188, 0.05199160283256188, 0.05199160283256188, 0.08026664459907884, 0.08026664459907884, 0.08026664459907884, 0.12890908979380256, 0.12890908979380256, 0.12890908979380256, 0.12803018757266527, 0.12803018757266527, 0.12803018757266527, 0.09346375025746256, 0.09346375025746256, 0.09346375025746256, 0.13621196343030428, 0.13621196343030428, 0.13621196343030428, 0.5569137121282179, 0.5569137121282179, 0.5569137121282179, 0.5618061706182181, 0.5618061706182181, 0.5618061706182181, 0.5562930577691014, 0.5562930577691014, 0.5562930577691014, 0.10713797496661914, 0.10713797496661914, 0.10713797496661914, 0.11566104902296681, 0.11566104902296681, 0.11566104902296681, 0.09447324912462896, 0.09447324912462896, 0.09447324912462896, 0.33461166506995155, 0.33461166506995155, 0.33461166506995155, 0.2598474314854843, 0.2598474314854843, 0.2598474314854843, 0.28796207582001765, 0.28796207582001765, 0.28796207582001765, 0.5013730864437568, 0.5013730864437568, 0.5013730864437568, 0.2744017459669331, 0.2744017459669331, 0.2744017459669331, 0.14554209943419372, 0.14554209943419372, 0.14554209943419372, 0.16852849579802243, 0.16852849579802243, 0.16852849579802243, 0.1674008023595337, 0.1674008023595337, 0.1674008023595337, 0.2549595535459215, 0.2549595535459215, 0.2549595535459215, 0.20535203062590457, 0.20535203062590457, 0.20535203062590457, 0.20323711946719658, 0.20323711946719658, 0.20323711946719658, 0.22931343263897408, 0.22931343263897408, 0.22931343263897408, 0.18973211878260332, 0.18973211878260332, 0.18973211878260332, 0.18419955183878367, 0.18419955183878367, 0.18419955183878367, 0.25277071074658974, 0.25277071074658974, 0.25277071074658974, 0.91366050409492, 0.91366050409492, 0.91366050409492, 0.14853119293892336, 0.14853119293892336, 0.14853119293892336, 0.13627654170464099, 0.13627654170464099, 0.13627654170464099, 0.16612325055966126, 0.16612325055966126, 0.16612325055966126, 0.21090073844238155, 0.21090073844238155, 0.21090073844238155, 0.15678649798231692, 0.15678649798231692, 0.15678649798231692, 0.1773998711424981, 0.1773998711424981, 0.1773998711424981, 0.195240947071174, 0.195240947071174, 0.195240947071174, 0.1863537130971481, 0.1863537130971481, 0.1863537130971481, 0.10074234903542978, 0.10074234903542978, 0.10074234903542978, 0.07524814565489035, 0.07524814565489035, 0.07524814565489035, 0.08434458954039492, 0.08434458954039492, 0.08434458954039492]}, "mutation_prompt": null}
{"id": "19391b7e-bd4f-4297-b25e-68b64d2339fb", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.8   # Initial inertia weight, adjusted for better exploration\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Conditional Inertia Weight Decay\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9  # Decay if a valid best solution is found\n            \n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Adjust the inertia weight initial value to enhance exploration early in the optimization process.", "configspace": "", "generation": 66, "fitness": 0.31347414501980914, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.29.", "error": "", "parent_id": "752dd08c-a8a0-437e-a468-27f2d1777563", "metadata": {"aucs": [0.9081787810540243, 0.9081787810540243, 0.9081787810540243, 0.9101954285009074, 0.9101954285009074, 0.9101954285009074, 0.9107841364490106, 0.9107841364490106, 0.9107841364490106, 0.7483156165655127, 0.7483156165655127, 0.7483156165655127, 0.6464815064975709, 0.6464815064975709, 0.6464815064975709, 0.8057354332000595, 0.8057354332000595, 0.8057354332000595, 0.1854605058828822, 0.1854605058828822, 0.1854605058828822, 0.7528346164954676, 0.7528346164954676, 0.7528346164954676, 0.11618409375929628, 0.11618409375929628, 0.11618409375929628, 0.11328750983547686, 0.11328750983547686, 0.11328750983547686, 0.09748030946803321, 0.09748030946803321, 0.09748030946803321, 0.08763212012649457, 0.08763212012649457, 0.08763212012649457, 0.9822702539559259, 0.9822702539559259, 0.9822702539559259, 0.9878512440903272, 0.9878512440903272, 0.9878512440903272, 0.9823039872840109, 0.9823039872840109, 0.9823039872840109, 0.7837329933509061, 0.7837329933509061, 0.7837329933509061, 0.773367818347519, 0.773367818347519, 0.773367818347519, 0.7702476606484692, 0.7702476606484692, 0.7702476606484692, 0.13775432753003392, 0.13775432753003392, 0.13775432753003392, 0.16185252905288394, 0.16185252905288394, 0.16185252905288394, 0.3561666446282913, 0.3561666446282913, 0.3561666446282913, 0.2650441046343073, 0.2650441046343073, 0.2650441046343073, 0.2151683948343659, 0.2151683948343659, 0.2151683948343659, 0.22360049162648332, 0.22360049162648332, 0.22360049162648332, 0.20927190814878438, 0.20927190814878438, 0.20927190814878438, 0.1319635806052354, 0.1319635806052354, 0.1319635806052354, 0.26729225066272544, 0.26729225066272544, 0.26729225066272544, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12535911903603336, 0.12535911903603336, 0.12535911903603336, 0.04679140507916857, 0.04679140507916857, 0.04679140507916857, 0.06291610814836024, 0.06291610814836024, 0.06291610814836024, 0.05165498704204752, 0.05165498704204752, 0.05165498704204752, 0.07924572819360987, 0.07924572819360987, 0.07924572819360987, 0.10223609041920245, 0.10223609041920245, 0.10223609041920245, 0.011208180774248233, 0.011208180774248233, 0.011208180774248233, 0.05924606612892336, 0.05924606612892336, 0.05924606612892336, 0.04893961627237986, 0.04893961627237986, 0.04893961627237986, 0.5663522579219449, 0.5663522579219449, 0.5663522579219449, 0.5677865175606798, 0.5677865175606798, 0.5677865175606798, 0.5818477227805137, 0.5818477227805137, 0.5818477227805137, 0.12131296934582492, 0.12131296934582492, 0.12131296934582492, 0.09254229486638177, 0.09254229486638177, 0.09254229486638177, 0.1267948846921061, 0.1267948846921061, 0.1267948846921061, 0.2260712369338016, 0.2260712369338016, 0.2260712369338016, 0.17528166390727762, 0.17528166390727762, 0.17528166390727762, 0.1563899129342815, 0.1563899129342815, 0.1563899129342815, 0.4107318854645692, 0.4107318854645692, 0.4107318854645692, 0.4074125314300533, 0.4074125314300533, 0.4074125314300533, 0.3540218660266493, 0.3540218660266493, 0.3540218660266493, 0.20688669795363301, 0.20688669795363301, 0.20688669795363301, 0.19655537420618674, 0.19655537420618674, 0.19655537420618674, 0.21353536486091085, 0.21353536486091085, 0.21353536486091085, 0.22573236760843096, 0.22573236760843096, 0.22573236760843096, 0.2466892387496462, 0.2466892387496462, 0.2466892387496462, 0.2154902109555188, 0.2154902109555188, 0.2154902109555188, 0.20700289682426676, 0.20700289682426676, 0.20700289682426676, 0.20732303725656065, 0.20732303725656065, 0.20732303725656065, 0.22795084230993068, 0.22795084230993068, 0.22795084230993068, 0.9368883173438388, 0.9368883173438388, 0.9368883173438388, 0.15911446145811492, 0.15911446145811492, 0.15911446145811492, 0.18603930491011356, 0.18603930491011356, 0.18603930491011356, 0.1686325957866125, 0.1686325957866125, 0.1686325957866125, 0.20931461766796677, 0.20931461766796677, 0.20931461766796677, 0.15638931564339198, 0.15638931564339198, 0.15638931564339198, 0.21345517264865543, 0.21345517264865543, 0.21345517264865543, 0.2002813352445274, 0.2002813352445274, 0.2002813352445274, 0.19398254204571985, 0.19398254204571985, 0.19398254204571985, 0.10278490420029607, 0.10278490420029607, 0.10278490420029607, 0.0985176300044941, 0.0985176300044941, 0.0985176300044941, 0.09267092155437806, 0.09267092155437806, 0.09267092155437806]}, "mutation_prompt": null}
{"id": "e0892f07-d0ea-42ce-89e4-9ed54a1a4e75", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F_initial = 0.8  # Initial DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Conditional Inertia Weight Decay\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9  # Decay if a valid best solution is found\n            \n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Adaptive DE scaling factor\n            self.F = self.F_initial * (1 - eval_count / self.budget)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce adaptive mutation factor scaling to enhance exploration during early stages and fine-tuning as convergence improves.", "configspace": "", "generation": 67, "fitness": 0.3016186132276314, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.29.", "error": "", "parent_id": "752dd08c-a8a0-437e-a468-27f2d1777563", "metadata": {"aucs": [0.8992259472339625, 0.8992259472339625, 0.8992259472339625, 0.9098939066676629, 0.9098939066676629, 0.9098939066676629, 0.9147948675822595, 0.9147948675822595, 0.9147948675822595, 0.7828792582663907, 0.7828792582663907, 0.7828792582663907, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.8164847328376268, 0.8164847328376268, 0.8164847328376268, 0.16013628479961173, 0.16013628479961173, 0.16013628479961173, 0.10395255405462489, 0.10395255405462489, 0.10395255405462489, 0.1208962242120657, 0.1208962242120657, 0.1208962242120657, 0.12030343117486042, 0.12030343117486042, 0.12030343117486042, 0.11418140911612429, 0.11418140911612429, 0.11418140911612429, 0.11454451468051807, 0.11454451468051807, 0.11454451468051807, 0.9822696248149612, 0.9822696248149612, 0.9822696248149612, 0.9878504565559978, 0.9878504565559978, 0.9878504565559978, 0.9823023657469954, 0.9823023657469954, 0.9823023657469954, 0.779030778271715, 0.779030778271715, 0.779030778271715, 0.7785996053204488, 0.7785996053204488, 0.7785996053204488, 0.7645035652489625, 0.7645035652489625, 0.7645035652489625, 0.2193357984266021, 0.2193357984266021, 0.2193357984266021, 0.16179673217470458, 0.16179673217470458, 0.16179673217470458, 0.23500725784708654, 0.23500725784708654, 0.23500725784708654, 0.20307832474940635, 0.20307832474940635, 0.20307832474940635, 0.12890383823781393, 0.12890383823781393, 0.12890383823781393, 0.22424819721563272, 0.22424819721563272, 0.22424819721563272, 0.19196783596617584, 0.19196783596617584, 0.19196783596617584, 0.13198955294922798, 0.13198955294922798, 0.13198955294922798, 0.2699335510199252, 0.2699335510199252, 0.2699335510199252, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04234402278673499, 0.04234402278673499, 0.04234402278673499, 0.05477501830751641, 0.05477501830751641, 0.05477501830751641, 0.0552282226552685, 0.0552282226552685, 0.0552282226552685, 0.05661051651539695, 0.05661051651539695, 0.05661051651539695, 0.08307694247854547, 0.08307694247854547, 0.08307694247854547, 0.12914745039338504, 0.12914745039338504, 0.12914745039338504, 0.011387465087396964, 0.011387465087396964, 0.011387465087396964, 0.0838297880886405, 0.0838297880886405, 0.0838297880886405, 0.04914367960677901, 0.04914367960677901, 0.04914367960677901, 0.5445017293765131, 0.5445017293765131, 0.5445017293765131, 0.6176841122502947, 0.6176841122502947, 0.6176841122502947, 0.5744745900222945, 0.5744745900222945, 0.5744745900222945, 0.10700499879293934, 0.10700499879293934, 0.10700499879293934, 0.12966789201144624, 0.12966789201144624, 0.12966789201144624, 0.17956444859500753, 0.17956444859500753, 0.17956444859500753, 0.21185005267583845, 0.21185005267583845, 0.21185005267583845, 0.2019512791062702, 0.2019512791062702, 0.2019512791062702, 0.18708177331852627, 0.18708177331852627, 0.18708177331852627, 0.2818913998419623, 0.2818913998419623, 0.2818913998419623, 0.3037121882657875, 0.3037121882657875, 0.3037121882657875, 0.38176450053486266, 0.38176450053486266, 0.38176450053486266, 0.2637768606035451, 0.2637768606035451, 0.2637768606035451, 0.2172500450168574, 0.2172500450168574, 0.2172500450168574, 0.2412436749926461, 0.2412436749926461, 0.2412436749926461, 0.22921014415865926, 0.22921014415865926, 0.22921014415865926, 0.2178874408180661, 0.2178874408180661, 0.2178874408180661, 0.22135944311141964, 0.22135944311141964, 0.22135944311141964, 0.7986069147988819, 0.7986069147988819, 0.7986069147988819, 0.18857215717669373, 0.18857215717669373, 0.18857215717669373, 0.24913461316387797, 0.24913461316387797, 0.24913461316387797, 0.9412921261359907, 0.9412921261359907, 0.9412921261359907, 0.1591133914280488, 0.1591133914280488, 0.1591133914280488, 0.18603916245963414, 0.18603916245963414, 0.18603916245963414, 0.1687233913416032, 0.1687233913416032, 0.1687233913416032, 0.20936157384424015, 0.20936157384424015, 0.20936157384424015, 0.15646852693221158, 0.15646852693221158, 0.15646852693221158, 0.19325365906923364, 0.19325365906923364, 0.19325365906923364, 0.1952386986628888, 0.1952386986628888, 0.1952386986628888, 0.207676136406309, 0.207676136406309, 0.207676136406309, 0.10382845777951422, 0.10382845777951422, 0.10382845777951422, 0.10205401241350631, 0.10205401241350631, 0.10205401241350631, 0.08124703619286433, 0.08124703619286433, 0.08124703619286433]}, "mutation_prompt": null}
{"id": "a3d446a1-6551-4329-85c9-a534395f55a2", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Conditional Inertia Weight Decay\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9  # Decay if a valid best solution is found\n            \n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            pop_std = np.std(pop, axis=0)\n            diversity_factor = np.mean(pop_std) / 5.0  # Normalize by search space\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget + diversity_factor\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce adaptive velocity scaling based on diversity to enhance local search capabilities.", "configspace": "", "generation": 68, "fitness": 0.3083359599711136, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.28.", "error": "", "parent_id": "752dd08c-a8a0-437e-a468-27f2d1777563", "metadata": {"aucs": [0.8963459408246147, 0.8963459408246147, 0.8963459408246147, 0.8892626660912529, 0.8892626660912529, 0.8892626660912529, 0.8970337533976405, 0.8970337533976405, 0.8970337533976405, 0.7721075307805835, 0.7721075307805835, 0.7721075307805835, 0.7402424738808924, 0.7402424738808924, 0.7402424738808924, 0.05093500744315971, 0.05093500744315971, 0.05093500744315971, 0.13214295772150597, 0.13214295772150597, 0.13214295772150597, 0.14166519073991113, 0.14166519073991113, 0.14166519073991113, 0.11485786445850699, 0.11485786445850699, 0.11485786445850699, 0.10739820338746253, 0.10739820338746253, 0.10739820338746253, 0.584127230806473, 0.584127230806473, 0.584127230806473, 0.1540985244034404, 0.1540985244034404, 0.1540985244034404, 0.9816748552708202, 0.9816748552708202, 0.9816748552708202, 0.9878635027139766, 0.9878635027139766, 0.9878635027139766, 0.9840245323162731, 0.9840245323162731, 0.9840245323162731, 0.7661630820800471, 0.7661630820800471, 0.7661630820800471, 0.6743845432163666, 0.6743845432163666, 0.6743845432163666, 0.7321592931212138, 0.7321592931212138, 0.7321592931212138, 0.34804110440856584, 0.34804110440856584, 0.34804110440856584, 0.16165673334871755, 0.16165673334871755, 0.16165673334871755, 0.11600142765323784, 0.11600142765323784, 0.11600142765323784, 0.21204758473484986, 0.21204758473484986, 0.21204758473484986, 0.12832233197278942, 0.12832233197278942, 0.12832233197278942, 0.3134602891904875, 0.3134602891904875, 0.3134602891904875, 0.21205914345129406, 0.21205914345129406, 0.21205914345129406, 0.12973803152448238, 0.12973803152448238, 0.12973803152448238, 0.26003306433589546, 0.26003306433589546, 0.26003306433589546, 0.0481218016645274, 0.0481218016645274, 0.0481218016645274, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08577950065871898, 0.08577950065871898, 0.08577950065871898, 0.018761431503510506, 0.018761431503510506, 0.018761431503510506, 0.08956504880108662, 0.08956504880108662, 0.08956504880108662, 0.06587732336036856, 0.06587732336036856, 0.06587732336036856, 0.14089432328906715, 0.14089432328906715, 0.14089432328906715, 0.079735641690302, 0.079735641690302, 0.079735641690302, 0.06867344097678885, 0.06867344097678885, 0.06867344097678885, 0.03882762363941006, 0.03882762363941006, 0.03882762363941006, 0.04971725071006494, 0.04971725071006494, 0.04971725071006494, 0.5544867786745963, 0.5544867786745963, 0.5544867786745963, 0.5414362227855869, 0.5414362227855869, 0.5414362227855869, 0.5661212428696409, 0.5661212428696409, 0.5661212428696409, 0.110762047830544, 0.110762047830544, 0.110762047830544, 0.11180091885657517, 0.11180091885657517, 0.11180091885657517, 0.15288197696693584, 0.15288197696693584, 0.15288197696693584, 0.27240937059712156, 0.27240937059712156, 0.27240937059712156, 0.17248754419067613, 0.17248754419067613, 0.17248754419067613, 0.26824573097603555, 0.26824573097603555, 0.26824573097603555, 0.34816774370166914, 0.34816774370166914, 0.34816774370166914, 0.3110305832252339, 0.3110305832252339, 0.3110305832252339, 0.30536441840154627, 0.30536441840154627, 0.30536441840154627, 0.3511898247064317, 0.3511898247064317, 0.3511898247064317, 0.19246137282123565, 0.19246137282123565, 0.19246137282123565, 0.13868415482937668, 0.13868415482937668, 0.13868415482937668, 0.23957548387491812, 0.23957548387491812, 0.23957548387491812, 0.26405713450420976, 0.26405713450420976, 0.26405713450420976, 0.20141731642383642, 0.20141731642383642, 0.20141731642383642, 0.20438587438945532, 0.20438587438945532, 0.20438587438945532, 0.18418753145415845, 0.18418753145415845, 0.18418753145415845, 0.19488885171726678, 0.19488885171726678, 0.19488885171726678, 0.9176147333538937, 0.9176147333538937, 0.9176147333538937, 0.15704659870785376, 0.15704659870785376, 0.15704659870785376, 0.18512005382868701, 0.18512005382868701, 0.18512005382868701, 0.1613287031839813, 0.1613287031839813, 0.1613287031839813, 0.28467757225846313, 0.28467757225846313, 0.28467757225846313, 0.7587385014257318, 0.7587385014257318, 0.7587385014257318, 0.18751219087276394, 0.18751219087276394, 0.18751219087276394, 0.22114920594388066, 0.22114920594388066, 0.22114920594388066, 0.19032350710883916, 0.19032350710883916, 0.19032350710883916, 0.08776387459100532, 0.08776387459100532, 0.08776387459100532, 0.09650885434869161, 0.09650885434869161, 0.09650885434869161, 0.09236294893103181, 0.09236294893103181, 0.09236294893103181]}, "mutation_prompt": null}
{"id": "838db890-4f94-4dc7-a973-bf4c05e5e1ab", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Conditional Inertia Weight Decay\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9  # Decay if a valid best solution is found\n            \n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a conditional inertia weight decay based on solution quality to balance exploration and exploitation.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "752dd08c-a8a0-437e-a468-27f2d1777563", "metadata": {"aucs": [0.9081787810540243, 0.9081787810540243, 0.9081787810540243, 0.9101954285009074, 0.9101954285009074, 0.9101954285009074, 0.9107841364490106, 0.9107841364490106, 0.9107841364490106, 0.7483156165655127, 0.7483156165655127, 0.7483156165655127, 0.6464815064975709, 0.6464815064975709, 0.6464815064975709, 0.8057354332000595, 0.8057354332000595, 0.8057354332000595, 0.1854605058828822, 0.1854605058828822, 0.1854605058828822, 0.7528346164954676, 0.7528346164954676, 0.7528346164954676, 0.11618409375929628, 0.11618409375929628, 0.11618409375929628, 0.11328750983547686, 0.11328750983547686, 0.11328750983547686, 0.09748030946803321, 0.09748030946803321, 0.09748030946803321, 0.08763212012649457, 0.08763212012649457, 0.08763212012649457, 0.9822702539559259, 0.9822702539559259, 0.9822702539559259, 0.9878512440903272, 0.9878512440903272, 0.9878512440903272, 0.9823039872840109, 0.9823039872840109, 0.9823039872840109, 0.7837329933509061, 0.7837329933509061, 0.7837329933509061, 0.773367818347519, 0.773367818347519, 0.773367818347519, 0.7702476606484692, 0.7702476606484692, 0.7702476606484692, 0.13775432753003392, 0.13775432753003392, 0.13775432753003392, 0.16185252905288394, 0.16185252905288394, 0.16185252905288394, 0.3561666446282913, 0.3561666446282913, 0.3561666446282913, 0.2650441046343073, 0.2650441046343073, 0.2650441046343073, 0.2151683948343659, 0.2151683948343659, 0.2151683948343659, 0.22360049162648332, 0.22360049162648332, 0.22360049162648332, 0.20927190814878438, 0.20927190814878438, 0.20927190814878438, 0.1319635806052354, 0.1319635806052354, 0.1319635806052354, 0.26729225066272544, 0.26729225066272544, 0.26729225066272544, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12535911903603336, 0.12535911903603336, 0.12535911903603336, 0.04679140507916857, 0.04679140507916857, 0.04679140507916857, 0.06291610814836024, 0.06291610814836024, 0.06291610814836024, 0.05165498704204752, 0.05165498704204752, 0.05165498704204752, 0.07924572819360987, 0.07924572819360987, 0.07924572819360987, 0.10223609041920245, 0.10223609041920245, 0.10223609041920245, 0.011208180774248233, 0.011208180774248233, 0.011208180774248233, 0.05924606612892336, 0.05924606612892336, 0.05924606612892336, 0.04893961627237986, 0.04893961627237986, 0.04893961627237986, 0.5663522579219449, 0.5663522579219449, 0.5663522579219449, 0.5677865175606798, 0.5677865175606798, 0.5677865175606798, 0.5818477227805137, 0.5818477227805137, 0.5818477227805137, 0.12131296934582492, 0.12131296934582492, 0.12131296934582492, 0.09254229486638177, 0.09254229486638177, 0.09254229486638177, 0.1267948846921061, 0.1267948846921061, 0.1267948846921061, 0.2260712369338016, 0.2260712369338016, 0.2260712369338016, 0.17528166390727762, 0.17528166390727762, 0.17528166390727762, 0.1563899129342815, 0.1563899129342815, 0.1563899129342815, 0.4107318854645692, 0.4107318854645692, 0.4107318854645692, 0.4074125314300533, 0.4074125314300533, 0.4074125314300533, 0.3540218660266493, 0.3540218660266493, 0.3540218660266493, 0.20688669795363301, 0.20688669795363301, 0.20688669795363301, 0.19655537420618674, 0.19655537420618674, 0.19655537420618674, 0.21353536486091085, 0.21353536486091085, 0.21353536486091085, 0.22573236760843096, 0.22573236760843096, 0.22573236760843096, 0.2466892387496462, 0.2466892387496462, 0.2466892387496462, 0.2154902109555188, 0.2154902109555188, 0.2154902109555188, 0.20700289682426676, 0.20700289682426676, 0.20700289682426676, 0.20732303725656065, 0.20732303725656065, 0.20732303725656065, 0.22795084230993068, 0.22795084230993068, 0.22795084230993068, 0.9368883173438388, 0.9368883173438388, 0.9368883173438388, 0.15911446145811492, 0.15911446145811492, 0.15911446145811492, 0.18603930491011356, 0.18603930491011356, 0.18603930491011356, 0.1686325957866125, 0.1686325957866125, 0.1686325957866125, 0.20931461766796677, 0.20931461766796677, 0.20931461766796677, 0.15638931564339198, 0.15638931564339198, 0.15638931564339198, 0.21345517264865543, 0.21345517264865543, 0.21345517264865543, 0.2002813352445274, 0.2002813352445274, 0.2002813352445274, 0.19398254204571985, 0.19398254204571985, 0.19398254204571985, 0.10278490420029607, 0.10278490420029607, 0.10278490420029607, 0.0985176300044941, 0.0985176300044941, 0.0985176300044941, 0.09267092155437806, 0.09267092155437806, 0.09267092155437806]}, "mutation_prompt": null}
{"id": "4c92140d-412d-411d-8a4a-6342696a81b6", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Conditional Inertia Weight Decay\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9  # Decay if a valid best solution is found\n            \n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a conditional inertia weight decay based on solution quality to balance exploration and exploitation.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "752dd08c-a8a0-437e-a468-27f2d1777563", "metadata": {"aucs": [0.9081787810540243, 0.9081787810540243, 0.9081787810540243, 0.9101954285009074, 0.9101954285009074, 0.9101954285009074, 0.9107841364490106, 0.9107841364490106, 0.9107841364490106, 0.7483156165655127, 0.7483156165655127, 0.7483156165655127, 0.6464815064975709, 0.6464815064975709, 0.6464815064975709, 0.8057354332000595, 0.8057354332000595, 0.8057354332000595, 0.1854605058828822, 0.1854605058828822, 0.1854605058828822, 0.7528346164954676, 0.7528346164954676, 0.7528346164954676, 0.11618409375929628, 0.11618409375929628, 0.11618409375929628, 0.11328750983547686, 0.11328750983547686, 0.11328750983547686, 0.09748030946803321, 0.09748030946803321, 0.09748030946803321, 0.08763212012649457, 0.08763212012649457, 0.08763212012649457, 0.9822702539559259, 0.9822702539559259, 0.9822702539559259, 0.9878512440903272, 0.9878512440903272, 0.9878512440903272, 0.9823039872840109, 0.9823039872840109, 0.9823039872840109, 0.7837329933509061, 0.7837329933509061, 0.7837329933509061, 0.773367818347519, 0.773367818347519, 0.773367818347519, 0.7702476606484692, 0.7702476606484692, 0.7702476606484692, 0.13775432753003392, 0.13775432753003392, 0.13775432753003392, 0.16185252905288394, 0.16185252905288394, 0.16185252905288394, 0.3561666446282913, 0.3561666446282913, 0.3561666446282913, 0.2650441046343073, 0.2650441046343073, 0.2650441046343073, 0.2151683948343659, 0.2151683948343659, 0.2151683948343659, 0.22360049162648332, 0.22360049162648332, 0.22360049162648332, 0.20927190814878438, 0.20927190814878438, 0.20927190814878438, 0.1319635806052354, 0.1319635806052354, 0.1319635806052354, 0.26729225066272544, 0.26729225066272544, 0.26729225066272544, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12535911903603336, 0.12535911903603336, 0.12535911903603336, 0.04679140507916857, 0.04679140507916857, 0.04679140507916857, 0.06291610814836024, 0.06291610814836024, 0.06291610814836024, 0.05165498704204752, 0.05165498704204752, 0.05165498704204752, 0.07924572819360987, 0.07924572819360987, 0.07924572819360987, 0.10223609041920245, 0.10223609041920245, 0.10223609041920245, 0.011208180774248233, 0.011208180774248233, 0.011208180774248233, 0.05924606612892336, 0.05924606612892336, 0.05924606612892336, 0.04893961627237986, 0.04893961627237986, 0.04893961627237986, 0.5663522579219449, 0.5663522579219449, 0.5663522579219449, 0.5677865175606798, 0.5677865175606798, 0.5677865175606798, 0.5818477227805137, 0.5818477227805137, 0.5818477227805137, 0.12131296934582492, 0.12131296934582492, 0.12131296934582492, 0.09254229486638177, 0.09254229486638177, 0.09254229486638177, 0.1267948846921061, 0.1267948846921061, 0.1267948846921061, 0.2260712369338016, 0.2260712369338016, 0.2260712369338016, 0.17528166390727762, 0.17528166390727762, 0.17528166390727762, 0.1563899129342815, 0.1563899129342815, 0.1563899129342815, 0.4107318854645692, 0.4107318854645692, 0.4107318854645692, 0.4074125314300533, 0.4074125314300533, 0.4074125314300533, 0.3540218660266493, 0.3540218660266493, 0.3540218660266493, 0.20688669795363301, 0.20688669795363301, 0.20688669795363301, 0.19655537420618674, 0.19655537420618674, 0.19655537420618674, 0.21353536486091085, 0.21353536486091085, 0.21353536486091085, 0.22573236760843096, 0.22573236760843096, 0.22573236760843096, 0.2466892387496462, 0.2466892387496462, 0.2466892387496462, 0.2154902109555188, 0.2154902109555188, 0.2154902109555188, 0.20700289682426676, 0.20700289682426676, 0.20700289682426676, 0.20732303725656065, 0.20732303725656065, 0.20732303725656065, 0.22795084230993068, 0.22795084230993068, 0.22795084230993068, 0.9368883173438388, 0.9368883173438388, 0.9368883173438388, 0.15911446145811492, 0.15911446145811492, 0.15911446145811492, 0.18603930491011356, 0.18603930491011356, 0.18603930491011356, 0.1686325957866125, 0.1686325957866125, 0.1686325957866125, 0.20931461766796677, 0.20931461766796677, 0.20931461766796677, 0.15638931564339198, 0.15638931564339198, 0.15638931564339198, 0.21345517264865543, 0.21345517264865543, 0.21345517264865543, 0.2002813352445274, 0.2002813352445274, 0.2002813352445274, 0.19398254204571985, 0.19398254204571985, 0.19398254204571985, 0.10278490420029607, 0.10278490420029607, 0.10278490420029607, 0.0985176300044941, 0.0985176300044941, 0.0985176300044941, 0.09267092155437806, 0.09267092155437806, 0.09267092155437806]}, "mutation_prompt": null}
{"id": "54f5ab5a-cb41-4197-8c4e-24b6694cc276", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Conditional Inertia Weight Decay\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9  # Decay if a valid best solution is found\n            \n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a conditional inertia weight decay based on solution quality to balance exploration and exploitation.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "752dd08c-a8a0-437e-a468-27f2d1777563", "metadata": {"aucs": [0.9081787810540243, 0.9081787810540243, 0.9081787810540243, 0.9101954285009074, 0.9101954285009074, 0.9101954285009074, 0.9107841364490106, 0.9107841364490106, 0.9107841364490106, 0.7483156165655127, 0.7483156165655127, 0.7483156165655127, 0.6464815064975709, 0.6464815064975709, 0.6464815064975709, 0.8057354332000595, 0.8057354332000595, 0.8057354332000595, 0.1854605058828822, 0.1854605058828822, 0.1854605058828822, 0.7528346164954676, 0.7528346164954676, 0.7528346164954676, 0.11618409375929628, 0.11618409375929628, 0.11618409375929628, 0.11328750983547686, 0.11328750983547686, 0.11328750983547686, 0.09748030946803321, 0.09748030946803321, 0.09748030946803321, 0.08763212012649457, 0.08763212012649457, 0.08763212012649457, 0.9822702539559259, 0.9822702539559259, 0.9822702539559259, 0.9878512440903272, 0.9878512440903272, 0.9878512440903272, 0.9823039872840109, 0.9823039872840109, 0.9823039872840109, 0.7837329933509061, 0.7837329933509061, 0.7837329933509061, 0.773367818347519, 0.773367818347519, 0.773367818347519, 0.7702476606484692, 0.7702476606484692, 0.7702476606484692, 0.13775432753003392, 0.13775432753003392, 0.13775432753003392, 0.16185252905288394, 0.16185252905288394, 0.16185252905288394, 0.3561666446282913, 0.3561666446282913, 0.3561666446282913, 0.2650441046343073, 0.2650441046343073, 0.2650441046343073, 0.2151683948343659, 0.2151683948343659, 0.2151683948343659, 0.22360049162648332, 0.22360049162648332, 0.22360049162648332, 0.20927190814878438, 0.20927190814878438, 0.20927190814878438, 0.1319635806052354, 0.1319635806052354, 0.1319635806052354, 0.26729225066272544, 0.26729225066272544, 0.26729225066272544, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12535911903603336, 0.12535911903603336, 0.12535911903603336, 0.04679140507916857, 0.04679140507916857, 0.04679140507916857, 0.06291610814836024, 0.06291610814836024, 0.06291610814836024, 0.05165498704204752, 0.05165498704204752, 0.05165498704204752, 0.07924572819360987, 0.07924572819360987, 0.07924572819360987, 0.10223609041920245, 0.10223609041920245, 0.10223609041920245, 0.011208180774248233, 0.011208180774248233, 0.011208180774248233, 0.05924606612892336, 0.05924606612892336, 0.05924606612892336, 0.04893961627237986, 0.04893961627237986, 0.04893961627237986, 0.5663522579219449, 0.5663522579219449, 0.5663522579219449, 0.5677865175606798, 0.5677865175606798, 0.5677865175606798, 0.5818477227805137, 0.5818477227805137, 0.5818477227805137, 0.12131296934582492, 0.12131296934582492, 0.12131296934582492, 0.09254229486638177, 0.09254229486638177, 0.09254229486638177, 0.1267948846921061, 0.1267948846921061, 0.1267948846921061, 0.2260712369338016, 0.2260712369338016, 0.2260712369338016, 0.17528166390727762, 0.17528166390727762, 0.17528166390727762, 0.1563899129342815, 0.1563899129342815, 0.1563899129342815, 0.4107318854645692, 0.4107318854645692, 0.4107318854645692, 0.4074125314300533, 0.4074125314300533, 0.4074125314300533, 0.3540218660266493, 0.3540218660266493, 0.3540218660266493, 0.20688669795363301, 0.20688669795363301, 0.20688669795363301, 0.19655537420618674, 0.19655537420618674, 0.19655537420618674, 0.21353536486091085, 0.21353536486091085, 0.21353536486091085, 0.22573236760843096, 0.22573236760843096, 0.22573236760843096, 0.2466892387496462, 0.2466892387496462, 0.2466892387496462, 0.2154902109555188, 0.2154902109555188, 0.2154902109555188, 0.20700289682426676, 0.20700289682426676, 0.20700289682426676, 0.20732303725656065, 0.20732303725656065, 0.20732303725656065, 0.22795084230993068, 0.22795084230993068, 0.22795084230993068, 0.9368883173438388, 0.9368883173438388, 0.9368883173438388, 0.15911446145811492, 0.15911446145811492, 0.15911446145811492, 0.18603930491011356, 0.18603930491011356, 0.18603930491011356, 0.1686325957866125, 0.1686325957866125, 0.1686325957866125, 0.20931461766796677, 0.20931461766796677, 0.20931461766796677, 0.15638931564339198, 0.15638931564339198, 0.15638931564339198, 0.21345517264865543, 0.21345517264865543, 0.21345517264865543, 0.2002813352445274, 0.2002813352445274, 0.2002813352445274, 0.19398254204571985, 0.19398254204571985, 0.19398254204571985, 0.10278490420029607, 0.10278490420029607, 0.10278490420029607, 0.0985176300044941, 0.0985176300044941, 0.0985176300044941, 0.09267092155437806, 0.09267092155437806, 0.09267092155437806]}, "mutation_prompt": null}
{"id": "ad4e0286-e714-4fc8-ad79-1e3e80b7b00b", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Conditional Inertia Weight Decay\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9  # Decay if a valid best solution is found\n            \n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Adapt mutation factor based on diversity\n            pop_std = np.std(pop, axis=0)\n            diversity = np.mean(pop_std)\n            self.F = 0.6 + 0.2 * (1 - diversity / (upper - lower))\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Enhance global exploration by introducing a mutation scaling factor adaptation based on population diversity.", "configspace": "", "generation": 72, "fitness": 0.31041161571317416, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.29.", "error": "", "parent_id": "752dd08c-a8a0-437e-a468-27f2d1777563", "metadata": {"aucs": [0.9147139345094044, 0.9147139345094044, 0.9147139345094044, 0.9005776121993689, 0.9005776121993689, 0.9005776121993689, 0.9104565771052987, 0.9104565771052987, 0.9104565771052987, 0.7100155902221679, 0.7100155902221679, 0.7100155902221679, 0.7988622239376033, 0.7988622239376033, 0.7988622239376033, 0.8094797174861983, 0.8094797174861983, 0.8094797174861983, 0.1424644825309508, 0.1424644825309508, 0.1424644825309508, 0.15283029456653952, 0.15283029456653952, 0.15283029456653952, 0.18229386477568255, 0.18229386477568255, 0.18229386477568255, 0.1418740021634769, 0.1418740021634769, 0.1418740021634769, 0.10683259116372301, 0.10683259116372301, 0.10683259116372301, 0.10526120032064268, 0.10526120032064268, 0.10526120032064268, 0.9815408223965721, 0.9815408223965721, 0.9815408223965721, 0.9877346095674688, 0.9877346095674688, 0.9877346095674688, 0.9817257471940226, 0.9817257471940226, 0.9817257471940226, 0.7848904641790594, 0.7848904641790594, 0.7848904641790594, 0.15166246926161953, 0.15166246926161953, 0.15166246926161953, 0.7594728004988361, 0.7594728004988361, 0.7594728004988361, 0.22199101520682052, 0.22199101520682052, 0.22199101520682052, 0.16182251070896114, 0.16182251070896114, 0.16182251070896114, 0.6212322715146361, 0.6212322715146361, 0.6212322715146361, 0.2139528635530299, 0.2139528635530299, 0.2139528635530299, 0.13433668235943297, 0.13433668235943297, 0.13433668235943297, 0.2499670058508836, 0.2499670058508836, 0.2499670058508836, 0.2503060334866962, 0.2503060334866962, 0.2503060334866962, 0.2526931722607316, 0.2526931722607316, 0.2526931722607316, 0.2624121489809996, 0.2624121489809996, 0.2624121489809996, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07221987049309242, 0.07221987049309242, 0.07221987049309242, 0.029022325507484514, 0.029022325507484514, 0.029022325507484514, 0.06355699392543634, 0.06355699392543634, 0.06355699392543634, 0.05142397458821635, 0.05142397458821635, 0.05142397458821635, 0.08207737650000613, 0.08207737650000613, 0.08207737650000613, 0.10194892247679677, 0.10194892247679677, 0.10194892247679677, 0.20974105135471977, 0.20974105135471977, 0.20974105135471977, 0.10929190077357975, 0.10929190077357975, 0.10929190077357975, 0.049321550965322425, 0.049321550965322425, 0.049321550965322425, 0.5785173063097874, 0.5785173063097874, 0.5785173063097874, 0.5631019774497416, 0.5631019774497416, 0.5631019774497416, 0.5713960048931275, 0.5713960048931275, 0.5713960048931275, 0.1115407570747764, 0.1115407570747764, 0.1115407570747764, 0.0959161356582805, 0.0959161356582805, 0.0959161356582805, 0.1068965887451182, 0.1068965887451182, 0.1068965887451182, 0.15954407760360667, 0.15954407760360667, 0.15954407760360667, 0.20833263821888026, 0.20833263821888026, 0.20833263821888026, 0.24185527030480758, 0.24185527030480758, 0.24185527030480758, 0.4223234945419133, 0.4223234945419133, 0.4223234945419133, 0.20901924752282164, 0.20901924752282164, 0.20901924752282164, 0.5866821142732197, 0.5866821142732197, 0.5866821142732197, 0.22621783361582004, 0.22621783361582004, 0.22621783361582004, 0.39885757866550575, 0.39885757866550575, 0.39885757866550575, 0.1552752875398803, 0.1552752875398803, 0.1552752875398803, 0.2269137927254843, 0.2269137927254843, 0.2269137927254843, 0.23482334581123399, 0.23482334581123399, 0.23482334581123399, 0.24038103405438938, 0.24038103405438938, 0.24038103405438938, 0.22348032030647214, 0.22348032030647214, 0.22348032030647214, 0.22763897173338654, 0.22763897173338654, 0.22763897173338654, 0.19766303712150757, 0.19766303712150757, 0.19766303712150757, 0.9236667533702972, 0.9236667533702972, 0.9236667533702972, 0.15893667680980073, 0.15893667680980073, 0.15893667680980073, 0.18595148057077615, 0.18595148057077615, 0.18595148057077615, 0.16874877593202198, 0.16874877593202198, 0.16874877593202198, 0.20898836913992858, 0.20898836913992858, 0.20898836913992858, 0.1565311792845383, 0.1565311792845383, 0.1565311792845383, 0.19334178020859594, 0.19334178020859594, 0.19334178020859594, 0.23137878286182423, 0.23137878286182423, 0.23137878286182423, 0.19317278714811237, 0.19317278714811237, 0.19317278714811237, 0.08602505786573078, 0.08602505786573078, 0.08602505786573078, 0.10397969402202323, 0.10397969402202323, 0.10397969402202323, 0.09223150537964919, 0.09223150537964919, 0.09223150537964919]}, "mutation_prompt": null}
{"id": "20a8cb5f-318a-4078-adb3-c1f29ef53c54", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Conditional Inertia Weight Decay\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9  # Decay if a valid best solution is found\n            \n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a conditional inertia weight decay based on solution quality to balance exploration and exploitation.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "752dd08c-a8a0-437e-a468-27f2d1777563", "metadata": {"aucs": [0.9081787810540243, 0.9081787810540243, 0.9081787810540243, 0.9101954285009074, 0.9101954285009074, 0.9101954285009074, 0.9107841364490106, 0.9107841364490106, 0.9107841364490106, 0.7483156165655127, 0.7483156165655127, 0.7483156165655127, 0.6464815064975709, 0.6464815064975709, 0.6464815064975709, 0.8057354332000595, 0.8057354332000595, 0.8057354332000595, 0.1854605058828822, 0.1854605058828822, 0.1854605058828822, 0.7528346164954676, 0.7528346164954676, 0.7528346164954676, 0.11618409375929628, 0.11618409375929628, 0.11618409375929628, 0.11328750983547686, 0.11328750983547686, 0.11328750983547686, 0.09748030946803321, 0.09748030946803321, 0.09748030946803321, 0.08763212012649457, 0.08763212012649457, 0.08763212012649457, 0.9822702539559259, 0.9822702539559259, 0.9822702539559259, 0.9878512440903272, 0.9878512440903272, 0.9878512440903272, 0.9823039872840109, 0.9823039872840109, 0.9823039872840109, 0.7837329933509061, 0.7837329933509061, 0.7837329933509061, 0.773367818347519, 0.773367818347519, 0.773367818347519, 0.7702476606484692, 0.7702476606484692, 0.7702476606484692, 0.13775432753003392, 0.13775432753003392, 0.13775432753003392, 0.16185252905288394, 0.16185252905288394, 0.16185252905288394, 0.3561666446282913, 0.3561666446282913, 0.3561666446282913, 0.2650441046343073, 0.2650441046343073, 0.2650441046343073, 0.2151683948343659, 0.2151683948343659, 0.2151683948343659, 0.22360049162648332, 0.22360049162648332, 0.22360049162648332, 0.20927190814878438, 0.20927190814878438, 0.20927190814878438, 0.1319635806052354, 0.1319635806052354, 0.1319635806052354, 0.26729225066272544, 0.26729225066272544, 0.26729225066272544, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12535911903603336, 0.12535911903603336, 0.12535911903603336, 0.04679140507916857, 0.04679140507916857, 0.04679140507916857, 0.06291610814836024, 0.06291610814836024, 0.06291610814836024, 0.05165498704204752, 0.05165498704204752, 0.05165498704204752, 0.07924572819360987, 0.07924572819360987, 0.07924572819360987, 0.10223609041920245, 0.10223609041920245, 0.10223609041920245, 0.011208180774248233, 0.011208180774248233, 0.011208180774248233, 0.05924606612892336, 0.05924606612892336, 0.05924606612892336, 0.04893961627237986, 0.04893961627237986, 0.04893961627237986, 0.5663522579219449, 0.5663522579219449, 0.5663522579219449, 0.5677865175606798, 0.5677865175606798, 0.5677865175606798, 0.5818477227805137, 0.5818477227805137, 0.5818477227805137, 0.12131296934582492, 0.12131296934582492, 0.12131296934582492, 0.09254229486638177, 0.09254229486638177, 0.09254229486638177, 0.1267948846921061, 0.1267948846921061, 0.1267948846921061, 0.2260712369338016, 0.2260712369338016, 0.2260712369338016, 0.17528166390727762, 0.17528166390727762, 0.17528166390727762, 0.1563899129342815, 0.1563899129342815, 0.1563899129342815, 0.4107318854645692, 0.4107318854645692, 0.4107318854645692, 0.4074125314300533, 0.4074125314300533, 0.4074125314300533, 0.3540218660266493, 0.3540218660266493, 0.3540218660266493, 0.20688669795363301, 0.20688669795363301, 0.20688669795363301, 0.19655537420618674, 0.19655537420618674, 0.19655537420618674, 0.21353536486091085, 0.21353536486091085, 0.21353536486091085, 0.22573236760843096, 0.22573236760843096, 0.22573236760843096, 0.2466892387496462, 0.2466892387496462, 0.2466892387496462, 0.2154902109555188, 0.2154902109555188, 0.2154902109555188, 0.20700289682426676, 0.20700289682426676, 0.20700289682426676, 0.20732303725656065, 0.20732303725656065, 0.20732303725656065, 0.22795084230993068, 0.22795084230993068, 0.22795084230993068, 0.9368883173438388, 0.9368883173438388, 0.9368883173438388, 0.15911446145811492, 0.15911446145811492, 0.15911446145811492, 0.18603930491011356, 0.18603930491011356, 0.18603930491011356, 0.1686325957866125, 0.1686325957866125, 0.1686325957866125, 0.20931461766796677, 0.20931461766796677, 0.20931461766796677, 0.15638931564339198, 0.15638931564339198, 0.15638931564339198, 0.21345517264865543, 0.21345517264865543, 0.21345517264865543, 0.2002813352445274, 0.2002813352445274, 0.2002813352445274, 0.19398254204571985, 0.19398254204571985, 0.19398254204571985, 0.10278490420029607, 0.10278490420029607, 0.10278490420029607, 0.0985176300044941, 0.0985176300044941, 0.0985176300044941, 0.09267092155437806, 0.09267092155437806, 0.09267092155437806]}, "mutation_prompt": null}
{"id": "2bd970e3-1b24-43bd-9777-27938e65b7b6", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Conditional Inertia Weight Decay\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9  # Decay if a valid best solution is found\n            \n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a conditional inertia weight decay based on solution quality to balance exploration and exploitation.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "752dd08c-a8a0-437e-a468-27f2d1777563", "metadata": {"aucs": [0.9081787810540243, 0.9081787810540243, 0.9081787810540243, 0.9101954285009074, 0.9101954285009074, 0.9101954285009074, 0.9107841364490106, 0.9107841364490106, 0.9107841364490106, 0.7483156165655127, 0.7483156165655127, 0.7483156165655127, 0.6464815064975709, 0.6464815064975709, 0.6464815064975709, 0.8057354332000595, 0.8057354332000595, 0.8057354332000595, 0.1854605058828822, 0.1854605058828822, 0.1854605058828822, 0.7528346164954676, 0.7528346164954676, 0.7528346164954676, 0.11618409375929628, 0.11618409375929628, 0.11618409375929628, 0.11328750983547686, 0.11328750983547686, 0.11328750983547686, 0.09748030946803321, 0.09748030946803321, 0.09748030946803321, 0.08763212012649457, 0.08763212012649457, 0.08763212012649457, 0.9822702539559259, 0.9822702539559259, 0.9822702539559259, 0.9878512440903272, 0.9878512440903272, 0.9878512440903272, 0.9823039872840109, 0.9823039872840109, 0.9823039872840109, 0.7837329933509061, 0.7837329933509061, 0.7837329933509061, 0.773367818347519, 0.773367818347519, 0.773367818347519, 0.7702476606484692, 0.7702476606484692, 0.7702476606484692, 0.13775432753003392, 0.13775432753003392, 0.13775432753003392, 0.16185252905288394, 0.16185252905288394, 0.16185252905288394, 0.3561666446282913, 0.3561666446282913, 0.3561666446282913, 0.2650441046343073, 0.2650441046343073, 0.2650441046343073, 0.2151683948343659, 0.2151683948343659, 0.2151683948343659, 0.22360049162648332, 0.22360049162648332, 0.22360049162648332, 0.20927190814878438, 0.20927190814878438, 0.20927190814878438, 0.1319635806052354, 0.1319635806052354, 0.1319635806052354, 0.26729225066272544, 0.26729225066272544, 0.26729225066272544, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12535911903603336, 0.12535911903603336, 0.12535911903603336, 0.04679140507916857, 0.04679140507916857, 0.04679140507916857, 0.06291610814836024, 0.06291610814836024, 0.06291610814836024, 0.05165498704204752, 0.05165498704204752, 0.05165498704204752, 0.07924572819360987, 0.07924572819360987, 0.07924572819360987, 0.10223609041920245, 0.10223609041920245, 0.10223609041920245, 0.011208180774248233, 0.011208180774248233, 0.011208180774248233, 0.05924606612892336, 0.05924606612892336, 0.05924606612892336, 0.04893961627237986, 0.04893961627237986, 0.04893961627237986, 0.5663522579219449, 0.5663522579219449, 0.5663522579219449, 0.5677865175606798, 0.5677865175606798, 0.5677865175606798, 0.5818477227805137, 0.5818477227805137, 0.5818477227805137, 0.12131296934582492, 0.12131296934582492, 0.12131296934582492, 0.09254229486638177, 0.09254229486638177, 0.09254229486638177, 0.1267948846921061, 0.1267948846921061, 0.1267948846921061, 0.2260712369338016, 0.2260712369338016, 0.2260712369338016, 0.17528166390727762, 0.17528166390727762, 0.17528166390727762, 0.1563899129342815, 0.1563899129342815, 0.1563899129342815, 0.4107318854645692, 0.4107318854645692, 0.4107318854645692, 0.4074125314300533, 0.4074125314300533, 0.4074125314300533, 0.3540218660266493, 0.3540218660266493, 0.3540218660266493, 0.20688669795363301, 0.20688669795363301, 0.20688669795363301, 0.19655537420618674, 0.19655537420618674, 0.19655537420618674, 0.21353536486091085, 0.21353536486091085, 0.21353536486091085, 0.22573236760843096, 0.22573236760843096, 0.22573236760843096, 0.2466892387496462, 0.2466892387496462, 0.2466892387496462, 0.2154902109555188, 0.2154902109555188, 0.2154902109555188, 0.20700289682426676, 0.20700289682426676, 0.20700289682426676, 0.20732303725656065, 0.20732303725656065, 0.20732303725656065, 0.22795084230993068, 0.22795084230993068, 0.22795084230993068, 0.9368883173438388, 0.9368883173438388, 0.9368883173438388, 0.15911446145811492, 0.15911446145811492, 0.15911446145811492, 0.18603930491011356, 0.18603930491011356, 0.18603930491011356, 0.1686325957866125, 0.1686325957866125, 0.1686325957866125, 0.20931461766796677, 0.20931461766796677, 0.20931461766796677, 0.15638931564339198, 0.15638931564339198, 0.15638931564339198, 0.21345517264865543, 0.21345517264865543, 0.21345517264865543, 0.2002813352445274, 0.2002813352445274, 0.2002813352445274, 0.19398254204571985, 0.19398254204571985, 0.19398254204571985, 0.10278490420029607, 0.10278490420029607, 0.10278490420029607, 0.0985176300044941, 0.0985176300044941, 0.0985176300044941, 0.09267092155437806, 0.09267092155437806, 0.09267092155437806]}, "mutation_prompt": null}
{"id": "e6ce4358-9972-4990-80d8-c42bb1b652e1", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Conditional Inertia Weight Decay\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9  # Decay if a valid best solution is found\n            \n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a conditional inertia weight decay based on solution quality to balance exploration and exploitation.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "752dd08c-a8a0-437e-a468-27f2d1777563", "metadata": {"aucs": [0.9081787810540243, 0.9081787810540243, 0.9081787810540243, 0.9101954285009074, 0.9101954285009074, 0.9101954285009074, 0.9107841364490106, 0.9107841364490106, 0.9107841364490106, 0.7483156165655127, 0.7483156165655127, 0.7483156165655127, 0.6464815064975709, 0.6464815064975709, 0.6464815064975709, 0.8057354332000595, 0.8057354332000595, 0.8057354332000595, 0.1854605058828822, 0.1854605058828822, 0.1854605058828822, 0.7528346164954676, 0.7528346164954676, 0.7528346164954676, 0.11618409375929628, 0.11618409375929628, 0.11618409375929628, 0.11328750983547686, 0.11328750983547686, 0.11328750983547686, 0.09748030946803321, 0.09748030946803321, 0.09748030946803321, 0.08763212012649457, 0.08763212012649457, 0.08763212012649457, 0.9822702539559259, 0.9822702539559259, 0.9822702539559259, 0.9878512440903272, 0.9878512440903272, 0.9878512440903272, 0.9823039872840109, 0.9823039872840109, 0.9823039872840109, 0.7837329933509061, 0.7837329933509061, 0.7837329933509061, 0.773367818347519, 0.773367818347519, 0.773367818347519, 0.7702476606484692, 0.7702476606484692, 0.7702476606484692, 0.13775432753003392, 0.13775432753003392, 0.13775432753003392, 0.16185252905288394, 0.16185252905288394, 0.16185252905288394, 0.3561666446282913, 0.3561666446282913, 0.3561666446282913, 0.2650441046343073, 0.2650441046343073, 0.2650441046343073, 0.2151683948343659, 0.2151683948343659, 0.2151683948343659, 0.22360049162648332, 0.22360049162648332, 0.22360049162648332, 0.20927190814878438, 0.20927190814878438, 0.20927190814878438, 0.1319635806052354, 0.1319635806052354, 0.1319635806052354, 0.26729225066272544, 0.26729225066272544, 0.26729225066272544, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12535911903603336, 0.12535911903603336, 0.12535911903603336, 0.04679140507916857, 0.04679140507916857, 0.04679140507916857, 0.06291610814836024, 0.06291610814836024, 0.06291610814836024, 0.05165498704204752, 0.05165498704204752, 0.05165498704204752, 0.07924572819360987, 0.07924572819360987, 0.07924572819360987, 0.10223609041920245, 0.10223609041920245, 0.10223609041920245, 0.011208180774248233, 0.011208180774248233, 0.011208180774248233, 0.05924606612892336, 0.05924606612892336, 0.05924606612892336, 0.04893961627237986, 0.04893961627237986, 0.04893961627237986, 0.5663522579219449, 0.5663522579219449, 0.5663522579219449, 0.5677865175606798, 0.5677865175606798, 0.5677865175606798, 0.5818477227805137, 0.5818477227805137, 0.5818477227805137, 0.12131296934582492, 0.12131296934582492, 0.12131296934582492, 0.09254229486638177, 0.09254229486638177, 0.09254229486638177, 0.1267948846921061, 0.1267948846921061, 0.1267948846921061, 0.2260712369338016, 0.2260712369338016, 0.2260712369338016, 0.17528166390727762, 0.17528166390727762, 0.17528166390727762, 0.1563899129342815, 0.1563899129342815, 0.1563899129342815, 0.4107318854645692, 0.4107318854645692, 0.4107318854645692, 0.4074125314300533, 0.4074125314300533, 0.4074125314300533, 0.3540218660266493, 0.3540218660266493, 0.3540218660266493, 0.20688669795363301, 0.20688669795363301, 0.20688669795363301, 0.19655537420618674, 0.19655537420618674, 0.19655537420618674, 0.21353536486091085, 0.21353536486091085, 0.21353536486091085, 0.22573236760843096, 0.22573236760843096, 0.22573236760843096, 0.2466892387496462, 0.2466892387496462, 0.2466892387496462, 0.2154902109555188, 0.2154902109555188, 0.2154902109555188, 0.20700289682426676, 0.20700289682426676, 0.20700289682426676, 0.20732303725656065, 0.20732303725656065, 0.20732303725656065, 0.22795084230993068, 0.22795084230993068, 0.22795084230993068, 0.9368883173438388, 0.9368883173438388, 0.9368883173438388, 0.15911446145811492, 0.15911446145811492, 0.15911446145811492, 0.18603930491011356, 0.18603930491011356, 0.18603930491011356, 0.1686325957866125, 0.1686325957866125, 0.1686325957866125, 0.20931461766796677, 0.20931461766796677, 0.20931461766796677, 0.15638931564339198, 0.15638931564339198, 0.15638931564339198, 0.21345517264865543, 0.21345517264865543, 0.21345517264865543, 0.2002813352445274, 0.2002813352445274, 0.2002813352445274, 0.19398254204571985, 0.19398254204571985, 0.19398254204571985, 0.10278490420029607, 0.10278490420029607, 0.10278490420029607, 0.0985176300044941, 0.0985176300044941, 0.0985176300044941, 0.09267092155437806, 0.09267092155437806, 0.09267092155437806]}, "mutation_prompt": null}
{"id": "157591b9-6dc6-4118-8288-c3e3e50d762f", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9\n\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                # Adjusting DE scaling factor based on evaluations\n                F_dynamic = self.F - 0.2 * eval_count / self.budget\n                mutant = pop[r1] + F_dynamic * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                # Dynamic social component\n                c2_dynamic = self.c2 * (1 + eval_count / self.budget)\n\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 c2_dynamic * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Fine-tune DE mutation factor dynamically and enhance velocity update by incorporating a dynamic social component.", "configspace": "", "generation": 76, "fitness": 0.276296149429701, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.26.", "error": "", "parent_id": "752dd08c-a8a0-437e-a468-27f2d1777563", "metadata": {"aucs": [0.8154051153020265, 0.8154051153020265, 0.8154051153020265, 0.7979934690722366, 0.7979934690722366, 0.7979934690722366, 0.8314128427801415, 0.8314128427801415, 0.8314128427801415, 0.5415095003056596, 0.5415095003056596, 0.5415095003056596, 0.06063999160832878, 0.06063999160832878, 0.06063999160832878, 0.5112372677556991, 0.5112372677556991, 0.5112372677556991, 0.15069439115368588, 0.15069439115368588, 0.15069439115368588, 0.0721240987784324, 0.0721240987784324, 0.0721240987784324, 0.1454598646266153, 0.1454598646266153, 0.1454598646266153, 0.13532836564809914, 0.13532836564809914, 0.13532836564809914, 0.14275554174513405, 0.14275554174513405, 0.14275554174513405, 0.10572903528440691, 0.10572903528440691, 0.10572903528440691, 0.9830897668034274, 0.9830897668034274, 0.9830897668034274, 0.9878716048959346, 0.9878716048959346, 0.9878716048959346, 0.9840285554295156, 0.9840285554295156, 0.9840285554295156, 0.466001041361354, 0.466001041361354, 0.466001041361354, 0.14475258349769649, 0.14475258349769649, 0.14475258349769649, 0.5020938304619996, 0.5020938304619996, 0.5020938304619996, 0.2081127322605365, 0.2081127322605365, 0.2081127322605365, 0.1605845173596988, 0.1605845173596988, 0.1605845173596988, 0.22656978868334254, 0.22656978868334254, 0.22656978868334254, 0.21610173824633216, 0.21610173824633216, 0.21610173824633216, 0.18131552128182205, 0.18131552128182205, 0.18131552128182205, 0.18937711856667983, 0.18937711856667983, 0.18937711856667983, 0.23781200053248608, 0.23781200053248608, 0.23781200053248608, 0.130255262247847, 0.130255262247847, 0.130255262247847, 0.2248675705155987, 0.2248675705155987, 0.2248675705155987, 0.01669812303536433, 0.01669812303536433, 0.01669812303536433, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07430146766203438, 0.07430146766203438, 0.07430146766203438, 0.0699275715465254, 0.0699275715465254, 0.0699275715465254, 0.0303348940782171, 0.0303348940782171, 0.0303348940782171, 0.04498049308079899, 0.04498049308079899, 0.04498049308079899, 0.0719802374007471, 0.0719802374007471, 0.0719802374007471, 0.08680857902745354, 0.08680857902745354, 0.08680857902745354, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.3026101202154602, 0.3026101202154602, 0.3026101202154602, 0.04886915844148554, 0.04886915844148554, 0.04886915844148554, 0.5455830931159831, 0.5455830931159831, 0.5455830931159831, 0.5562210384362594, 0.5562210384362594, 0.5562210384362594, 0.5323566153486132, 0.5323566153486132, 0.5323566153486132, 0.09184083680518451, 0.09184083680518451, 0.09184083680518451, 0.12093418327559591, 0.12093418327559591, 0.12093418327559591, 0.09764146558054365, 0.09764146558054365, 0.09764146558054365, 0.19382154155409348, 0.19382154155409348, 0.19382154155409348, 0.17406348232336954, 0.17406348232336954, 0.17406348232336954, 0.16740946776328325, 0.16740946776328325, 0.16740946776328325, 0.3258165445676605, 0.3258165445676605, 0.3258165445676605, 0.23101710957401544, 0.23101710957401544, 0.23101710957401544, 0.44309439104599924, 0.44309439104599924, 0.44309439104599924, 0.14330733994355305, 0.14330733994355305, 0.14330733994355305, 0.1893915827648538, 0.1893915827648538, 0.1893915827648538, 0.2810697911946931, 0.2810697911946931, 0.2810697911946931, 0.2184954000221785, 0.2184954000221785, 0.2184954000221785, 0.22503740619857937, 0.22503740619857937, 0.22503740619857937, 0.2039622749926977, 0.2039622749926977, 0.2039622749926977, 0.6522879383514764, 0.6522879383514764, 0.6522879383514764, 0.22213019057830552, 0.22213019057830552, 0.22213019057830552, 0.1969598485961913, 0.1969598485961913, 0.1969598485961913, 0.8590833348455362, 0.8590833348455362, 0.8590833348455362, 0.15748042294033582, 0.15748042294033582, 0.15748042294033582, 0.18862695729982193, 0.18862695729982193, 0.18862695729982193, 0.16475945087477395, 0.16475945087477395, 0.16475945087477395, 0.20778565675904814, 0.20778565675904814, 0.20778565675904814, 0.7427067994412857, 0.7427067994412857, 0.7427067994412857, 0.19263463981597295, 0.19263463981597295, 0.19263463981597295, 0.19169140083682334, 0.19169140083682334, 0.19169140083682334, 0.2219098616193177, 0.2219098616193177, 0.2219098616193177, 0.07917340102486048, 0.07917340102486048, 0.07917340102486048, 0.09170941723041892, 0.09170941723041892, 0.09170941723041892, 0.08338611352432412, 0.08338611352432412, 0.08338611352432412]}, "mutation_prompt": null}
{"id": "191438d9-c00e-4866-81b1-dc445bc202c4", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Conditional Inertia Weight Decay\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9  # Decay if a valid best solution is found\n            \n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a conditional inertia weight decay based on solution quality to balance exploration and exploitation.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "752dd08c-a8a0-437e-a468-27f2d1777563", "metadata": {"aucs": [0.9081787810540243, 0.9081787810540243, 0.9081787810540243, 0.9101954285009074, 0.9101954285009074, 0.9101954285009074, 0.9107841364490106, 0.9107841364490106, 0.9107841364490106, 0.7483156165655127, 0.7483156165655127, 0.7483156165655127, 0.6464815064975709, 0.6464815064975709, 0.6464815064975709, 0.8057354332000595, 0.8057354332000595, 0.8057354332000595, 0.1854605058828822, 0.1854605058828822, 0.1854605058828822, 0.7528346164954676, 0.7528346164954676, 0.7528346164954676, 0.11618409375929628, 0.11618409375929628, 0.11618409375929628, 0.11328750983547686, 0.11328750983547686, 0.11328750983547686, 0.09748030946803321, 0.09748030946803321, 0.09748030946803321, 0.08763212012649457, 0.08763212012649457, 0.08763212012649457, 0.9822702539559259, 0.9822702539559259, 0.9822702539559259, 0.9878512440903272, 0.9878512440903272, 0.9878512440903272, 0.9823039872840109, 0.9823039872840109, 0.9823039872840109, 0.7837329933509061, 0.7837329933509061, 0.7837329933509061, 0.773367818347519, 0.773367818347519, 0.773367818347519, 0.7702476606484692, 0.7702476606484692, 0.7702476606484692, 0.13775432753003392, 0.13775432753003392, 0.13775432753003392, 0.16185252905288394, 0.16185252905288394, 0.16185252905288394, 0.3561666446282913, 0.3561666446282913, 0.3561666446282913, 0.2650441046343073, 0.2650441046343073, 0.2650441046343073, 0.2151683948343659, 0.2151683948343659, 0.2151683948343659, 0.22360049162648332, 0.22360049162648332, 0.22360049162648332, 0.20927190814878438, 0.20927190814878438, 0.20927190814878438, 0.1319635806052354, 0.1319635806052354, 0.1319635806052354, 0.26729225066272544, 0.26729225066272544, 0.26729225066272544, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12535911903603336, 0.12535911903603336, 0.12535911903603336, 0.04679140507916857, 0.04679140507916857, 0.04679140507916857, 0.06291610814836024, 0.06291610814836024, 0.06291610814836024, 0.05165498704204752, 0.05165498704204752, 0.05165498704204752, 0.07924572819360987, 0.07924572819360987, 0.07924572819360987, 0.10223609041920245, 0.10223609041920245, 0.10223609041920245, 0.011208180774248233, 0.011208180774248233, 0.011208180774248233, 0.05924606612892336, 0.05924606612892336, 0.05924606612892336, 0.04893961627237986, 0.04893961627237986, 0.04893961627237986, 0.5663522579219449, 0.5663522579219449, 0.5663522579219449, 0.5677865175606798, 0.5677865175606798, 0.5677865175606798, 0.5818477227805137, 0.5818477227805137, 0.5818477227805137, 0.12131296934582492, 0.12131296934582492, 0.12131296934582492, 0.09254229486638177, 0.09254229486638177, 0.09254229486638177, 0.1267948846921061, 0.1267948846921061, 0.1267948846921061, 0.2260712369338016, 0.2260712369338016, 0.2260712369338016, 0.17528166390727762, 0.17528166390727762, 0.17528166390727762, 0.1563899129342815, 0.1563899129342815, 0.1563899129342815, 0.4107318854645692, 0.4107318854645692, 0.4107318854645692, 0.4074125314300533, 0.4074125314300533, 0.4074125314300533, 0.3540218660266493, 0.3540218660266493, 0.3540218660266493, 0.20688669795363301, 0.20688669795363301, 0.20688669795363301, 0.19655537420618674, 0.19655537420618674, 0.19655537420618674, 0.21353536486091085, 0.21353536486091085, 0.21353536486091085, 0.22573236760843096, 0.22573236760843096, 0.22573236760843096, 0.2466892387496462, 0.2466892387496462, 0.2466892387496462, 0.2154902109555188, 0.2154902109555188, 0.2154902109555188, 0.20700289682426676, 0.20700289682426676, 0.20700289682426676, 0.20732303725656065, 0.20732303725656065, 0.20732303725656065, 0.22795084230993068, 0.22795084230993068, 0.22795084230993068, 0.9368883173438388, 0.9368883173438388, 0.9368883173438388, 0.15911446145811492, 0.15911446145811492, 0.15911446145811492, 0.18603930491011356, 0.18603930491011356, 0.18603930491011356, 0.1686325957866125, 0.1686325957866125, 0.1686325957866125, 0.20931461766796677, 0.20931461766796677, 0.20931461766796677, 0.15638931564339198, 0.15638931564339198, 0.15638931564339198, 0.21345517264865543, 0.21345517264865543, 0.21345517264865543, 0.2002813352445274, 0.2002813352445274, 0.2002813352445274, 0.19398254204571985, 0.19398254204571985, 0.19398254204571985, 0.10278490420029607, 0.10278490420029607, 0.10278490420029607, 0.0985176300044941, 0.0985176300044941, 0.0985176300044941, 0.09267092155437806, 0.09267092155437806, 0.09267092155437806]}, "mutation_prompt": null}
{"id": "c5dc5c81-d6fa-4c21-856b-4402ff9157b4", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Conditional Inertia Weight Decay\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9  # Decay if a valid best solution is found\n            \n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a conditional inertia weight decay based on solution quality to balance exploration and exploitation.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "752dd08c-a8a0-437e-a468-27f2d1777563", "metadata": {"aucs": [0.9081787810540243, 0.9081787810540243, 0.9081787810540243, 0.9101954285009074, 0.9101954285009074, 0.9101954285009074, 0.9107841364490106, 0.9107841364490106, 0.9107841364490106, 0.7483156165655127, 0.7483156165655127, 0.7483156165655127, 0.6464815064975709, 0.6464815064975709, 0.6464815064975709, 0.8057354332000595, 0.8057354332000595, 0.8057354332000595, 0.1854605058828822, 0.1854605058828822, 0.1854605058828822, 0.7528346164954676, 0.7528346164954676, 0.7528346164954676, 0.11618409375929628, 0.11618409375929628, 0.11618409375929628, 0.11328750983547686, 0.11328750983547686, 0.11328750983547686, 0.09748030946803321, 0.09748030946803321, 0.09748030946803321, 0.08763212012649457, 0.08763212012649457, 0.08763212012649457, 0.9822702539559259, 0.9822702539559259, 0.9822702539559259, 0.9878512440903272, 0.9878512440903272, 0.9878512440903272, 0.9823039872840109, 0.9823039872840109, 0.9823039872840109, 0.7837329933509061, 0.7837329933509061, 0.7837329933509061, 0.773367818347519, 0.773367818347519, 0.773367818347519, 0.7702476606484692, 0.7702476606484692, 0.7702476606484692, 0.13775432753003392, 0.13775432753003392, 0.13775432753003392, 0.16185252905288394, 0.16185252905288394, 0.16185252905288394, 0.3561666446282913, 0.3561666446282913, 0.3561666446282913, 0.2650441046343073, 0.2650441046343073, 0.2650441046343073, 0.2151683948343659, 0.2151683948343659, 0.2151683948343659, 0.22360049162648332, 0.22360049162648332, 0.22360049162648332, 0.20927190814878438, 0.20927190814878438, 0.20927190814878438, 0.1319635806052354, 0.1319635806052354, 0.1319635806052354, 0.26729225066272544, 0.26729225066272544, 0.26729225066272544, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12535911903603336, 0.12535911903603336, 0.12535911903603336, 0.04679140507916857, 0.04679140507916857, 0.04679140507916857, 0.06291610814836024, 0.06291610814836024, 0.06291610814836024, 0.05165498704204752, 0.05165498704204752, 0.05165498704204752, 0.07924572819360987, 0.07924572819360987, 0.07924572819360987, 0.10223609041920245, 0.10223609041920245, 0.10223609041920245, 0.011208180774248233, 0.011208180774248233, 0.011208180774248233, 0.05924606612892336, 0.05924606612892336, 0.05924606612892336, 0.04893961627237986, 0.04893961627237986, 0.04893961627237986, 0.5663522579219449, 0.5663522579219449, 0.5663522579219449, 0.5677865175606798, 0.5677865175606798, 0.5677865175606798, 0.5818477227805137, 0.5818477227805137, 0.5818477227805137, 0.12131296934582492, 0.12131296934582492, 0.12131296934582492, 0.09254229486638177, 0.09254229486638177, 0.09254229486638177, 0.1267948846921061, 0.1267948846921061, 0.1267948846921061, 0.2260712369338016, 0.2260712369338016, 0.2260712369338016, 0.17528166390727762, 0.17528166390727762, 0.17528166390727762, 0.1563899129342815, 0.1563899129342815, 0.1563899129342815, 0.4107318854645692, 0.4107318854645692, 0.4107318854645692, 0.4074125314300533, 0.4074125314300533, 0.4074125314300533, 0.3540218660266493, 0.3540218660266493, 0.3540218660266493, 0.20688669795363301, 0.20688669795363301, 0.20688669795363301, 0.19655537420618674, 0.19655537420618674, 0.19655537420618674, 0.21353536486091085, 0.21353536486091085, 0.21353536486091085, 0.22573236760843096, 0.22573236760843096, 0.22573236760843096, 0.2466892387496462, 0.2466892387496462, 0.2466892387496462, 0.2154902109555188, 0.2154902109555188, 0.2154902109555188, 0.20700289682426676, 0.20700289682426676, 0.20700289682426676, 0.20732303725656065, 0.20732303725656065, 0.20732303725656065, 0.22795084230993068, 0.22795084230993068, 0.22795084230993068, 0.9368883173438388, 0.9368883173438388, 0.9368883173438388, 0.15911446145811492, 0.15911446145811492, 0.15911446145811492, 0.18603930491011356, 0.18603930491011356, 0.18603930491011356, 0.1686325957866125, 0.1686325957866125, 0.1686325957866125, 0.20931461766796677, 0.20931461766796677, 0.20931461766796677, 0.15638931564339198, 0.15638931564339198, 0.15638931564339198, 0.21345517264865543, 0.21345517264865543, 0.21345517264865543, 0.2002813352445274, 0.2002813352445274, 0.2002813352445274, 0.19398254204571985, 0.19398254204571985, 0.19398254204571985, 0.10278490420029607, 0.10278490420029607, 0.10278490420029607, 0.0985176300044941, 0.0985176300044941, 0.0985176300044941, 0.09267092155437806, 0.09267092155437806, 0.09267092155437806]}, "mutation_prompt": null}
{"id": "f723e49d-5415-45fb-9f54-cdcdf449429c", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.c1_initial = 1.5  # Initial cognitive component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Conditional Inertia Weight Decay\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9  # Decay if a valid best solution is found\n            \n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n\n                # Adjust cognitive component based on population diversity\n                diversity = np.std(pop)\n                self.c1 = self.c1_initial * (1 + 0.5 * (1 - diversity / (upper - lower)))\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Enhance exploration by dynamically adjusting PSO cognitive component based on population diversity.", "configspace": "", "generation": 79, "fitness": 0.305578511280694, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.28.", "error": "", "parent_id": "752dd08c-a8a0-437e-a468-27f2d1777563", "metadata": {"aucs": [0.9006144773844387, 0.9006144773844387, 0.9006144773844387, 0.8879029775991639, 0.8879029775991639, 0.8879029775991639, 0.8935596638875095, 0.8935596638875095, 0.8935596638875095, 0.6936084904454238, 0.6936084904454238, 0.6936084904454238, 0.7866986516955107, 0.7866986516955107, 0.7866986516955107, 0.788759081063104, 0.788759081063104, 0.788759081063104, 0.15535464717471892, 0.15535464717471892, 0.15535464717471892, 0.14050877422840824, 0.14050877422840824, 0.14050877422840824, 0.180609659517442, 0.180609659517442, 0.180609659517442, 0.1330695058325586, 0.1330695058325586, 0.1330695058325586, 0.13212785793856507, 0.13212785793856507, 0.13212785793856507, 0.09780291963075793, 0.09780291963075793, 0.09780291963075793, 0.9822706648390425, 0.9822706648390425, 0.9822706648390425, 0.9879589531695863, 0.9879589531695863, 0.9879589531695863, 0.9823592819717415, 0.9823592819717415, 0.9823592819717415, 0.6022938719138484, 0.6022938719138484, 0.6022938719138484, 0.6230806905721251, 0.6230806905721251, 0.6230806905721251, 0.6216112687990978, 0.6216112687990978, 0.6216112687990978, 0.7049387761017238, 0.7049387761017238, 0.7049387761017238, 0.16176671033267886, 0.16176671033267886, 0.16176671033267886, 0.3369995630681788, 0.3369995630681788, 0.3369995630681788, 0.2006469565390694, 0.2006469565390694, 0.2006469565390694, 0.19822412141622514, 0.19822412141622514, 0.19822412141622514, 0.13346057139768253, 0.13346057139768253, 0.13346057139768253, 0.21079064560488203, 0.21079064560488203, 0.21079064560488203, 0.21726281592762808, 0.21726281592762808, 0.21726281592762808, 0.1313112249111138, 0.1313112249111138, 0.1313112249111138, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.023489998941182644, 0.023489998941182644, 0.023489998941182644, 0.0474313949002968, 0.0474313949002968, 0.0474313949002968, 0.046853881998415114, 0.046853881998415114, 0.046853881998415114, 0.05031358509889705, 0.05031358509889705, 0.05031358509889705, 0.0950770297576391, 0.0950770297576391, 0.0950770297576391, 0.12778067413512217, 0.12778067413512217, 0.12778067413512217, 0.09618210554440154, 0.09618210554440154, 0.09618210554440154, 0.05959837106501842, 0.05959837106501842, 0.05959837106501842, 0.19894011806369227, 0.19894011806369227, 0.19894011806369227, 0.5075074134071733, 0.5075074134071733, 0.5075074134071733, 0.5952770590955022, 0.5952770590955022, 0.5952770590955022, 0.57746091447155, 0.57746091447155, 0.57746091447155, 0.13304273508780462, 0.13304273508780462, 0.13304273508780462, 0.0884662961365249, 0.0884662961365249, 0.0884662961365249, 0.10581267754877266, 0.10581267754877266, 0.10581267754877266, 0.21756829654916854, 0.21756829654916854, 0.21756829654916854, 0.194047404105265, 0.194047404105265, 0.194047404105265, 0.2628827914985985, 0.2628827914985985, 0.2628827914985985, 0.3662746841502299, 0.3662746841502299, 0.3662746841502299, 0.4323314912566085, 0.4323314912566085, 0.4323314912566085, 0.22427255291169035, 0.22427255291169035, 0.22427255291169035, 0.1941810857594063, 0.1941810857594063, 0.1941810857594063, 0.18835916129628127, 0.18835916129628127, 0.18835916129628127, 0.3361389092168875, 0.3361389092168875, 0.3361389092168875, 0.21140315558843992, 0.21140315558843992, 0.21140315558843992, 0.2310306610718591, 0.2310306610718591, 0.2310306610718591, 0.22047771595560772, 0.22047771595560772, 0.22047771595560772, 0.20566581997646516, 0.20566581997646516, 0.20566581997646516, 0.19800267698812657, 0.19800267698812657, 0.19800267698812657, 0.20590874940359316, 0.20590874940359316, 0.20590874940359316, 0.9252029396029657, 0.9252029396029657, 0.9252029396029657, 0.15881017948494258, 0.15881017948494258, 0.15881017948494258, 0.18565918695551153, 0.18565918695551153, 0.18565918695551153, 0.16833807760011255, 0.16833807760011255, 0.16833807760011255, 0.21066350787525057, 0.21066350787525057, 0.21066350787525057, 0.15628079109503945, 0.15628079109503945, 0.15628079109503945, 0.21182788358185378, 0.21182788358185378, 0.21182788358185378, 0.20346718174720824, 0.20346718174720824, 0.20346718174720824, 0.1926592204201425, 0.1926592204201425, 0.1926592204201425, 0.08791943090567056, 0.08791943090567056, 0.08791943090567056, 0.08986679753617777, 0.08986679753617777, 0.08986679753617777, 0.08328538146264364, 0.08328538146264364, 0.08328538146264364]}, "mutation_prompt": null}
{"id": "eb834b2a-787b-40f5-a6a3-d521504c7180", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Conditional Inertia Weight Decay\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9  # Decay if a valid best solution is found\n            \n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                # New line added for scaling based on global improvement\n                velocities[i] *= 1.2 if best_global_value < np.inf else 1.0\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Modify the velocity update rule by scaling velocities based on their contribution to global movement for faster convergence.", "configspace": "", "generation": 80, "fitness": 0.30300017709379795, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.27.", "error": "", "parent_id": "752dd08c-a8a0-437e-a468-27f2d1777563", "metadata": {"aucs": [0.8559190509930645, 0.8559190509930645, 0.8559190509930645, 0.18246135082655035, 0.18246135082655035, 0.18246135082655035, 0.8823301776172643, 0.8823301776172643, 0.8823301776172643, 0.6553157842036066, 0.6553157842036066, 0.6553157842036066, 0.6998668802086385, 0.6998668802086385, 0.6998668802086385, 0.702207580782573, 0.702207580782573, 0.702207580782573, 0.567659916161346, 0.567659916161346, 0.567659916161346, 0.07052039129566823, 0.07052039129566823, 0.07052039129566823, 0.13830006090877356, 0.13830006090877356, 0.13830006090877356, 0.1392384373669191, 0.1392384373669191, 0.1392384373669191, 0.09213566274878071, 0.09213566274878071, 0.09213566274878071, 0.13019927942451337, 0.13019927942451337, 0.13019927942451337, 0.9832539525960721, 0.9832539525960721, 0.9832539525960721, 0.9879728984348362, 0.9879728984348362, 0.9879728984348362, 0.9823313329159369, 0.9823313329159369, 0.9823313329159369, 0.6531769323937722, 0.6531769323937722, 0.6531769323937722, 0.5970063448238032, 0.5970063448238032, 0.5970063448238032, 0.6292128457208859, 0.6292128457208859, 0.6292128457208859, 0.37149874620095447, 0.37149874620095447, 0.37149874620095447, 0.8511988344424448, 0.8511988344424448, 0.8511988344424448, 0.11594661496437675, 0.11594661496437675, 0.11594661496437675, 0.22077427639461178, 0.22077427639461178, 0.22077427639461178, 0.2148485905976849, 0.2148485905976849, 0.2148485905976849, 0.21977407985886155, 0.21977407985886155, 0.21977407985886155, 0.23257639276691455, 0.23257639276691455, 0.23257639276691455, 0.1785876540386021, 0.1785876540386021, 0.1785876540386021, 0.235971803581552, 0.235971803581552, 0.235971803581552, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07306941964622726, 0.07306941964622726, 0.07306941964622726, 0.07223596705783653, 0.07223596705783653, 0.07223596705783653, 0.05901397753587412, 0.05901397753587412, 0.05901397753587412, 0.048887329725612494, 0.048887329725612494, 0.048887329725612494, 0.09833665204425868, 0.09833665204425868, 0.09833665204425868, 0.09791056136275889, 0.09791056136275889, 0.09791056136275889, 0.06579860730698839, 0.06579860730698839, 0.06579860730698839, 0.26955260586790875, 0.26955260586790875, 0.26955260586790875, 0.19664045222852833, 0.19664045222852833, 0.19664045222852833, 0.5475252824716723, 0.5475252824716723, 0.5475252824716723, 0.6078997787472141, 0.6078997787472141, 0.6078997787472141, 0.5635829502038365, 0.5635829502038365, 0.5635829502038365, 0.09115154895863475, 0.09115154895863475, 0.09115154895863475, 0.1396355274673895, 0.1396355274673895, 0.1396355274673895, 0.09451401094810086, 0.09451401094810086, 0.09451401094810086, 0.17631342507575465, 0.17631342507575465, 0.17631342507575465, 0.1703735410915881, 0.1703735410915881, 0.1703735410915881, 0.17089853267975064, 0.17089853267975064, 0.17089853267975064, 0.35691871454373014, 0.35691871454373014, 0.35691871454373014, 0.24805291733487833, 0.24805291733487833, 0.24805291733487833, 0.5088145300015265, 0.5088145300015265, 0.5088145300015265, 0.27079990463959025, 0.27079990463959025, 0.27079990463959025, 0.194858939810288, 0.194858939810288, 0.194858939810288, 0.141069080131201, 0.141069080131201, 0.141069080131201, 0.2456997705804006, 0.2456997705804006, 0.2456997705804006, 0.2106140135748692, 0.2106140135748692, 0.2106140135748692, 0.22178204990089911, 0.22178204990089911, 0.22178204990089911, 0.2407961653257662, 0.2407961653257662, 0.2407961653257662, 0.20383773697641505, 0.20383773697641505, 0.20383773697641505, 0.24231953583418897, 0.24231953583418897, 0.24231953583418897, 0.8821730630752316, 0.8821730630752316, 0.8821730630752316, 0.15846290440685584, 0.15846290440685584, 0.15846290440685584, 0.18495137940986484, 0.18495137940986484, 0.18495137940986484, 0.16145396565839187, 0.16145396565839187, 0.16145396565839187, 0.21022113837704692, 0.21022113837704692, 0.21022113837704692, 0.15617011279481463, 0.15617011279481463, 0.15617011279481463, 0.194144053562036, 0.194144053562036, 0.194144053562036, 0.18426115494641215, 0.18426115494641215, 0.18426115494641215, 0.19989987605919912, 0.19989987605919912, 0.19989987605919912, 0.08558984452919538, 0.08558984452919538, 0.08558984452919538, 0.09585573263770497, 0.09585573263770497, 0.09585573263770497, 0.08334012395400603, 0.08334012395400603, 0.08334012395400603]}, "mutation_prompt": null}
{"id": "c96e8e5c-6f04-4ffb-8793-d1411e65dcf6", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Conditional Inertia Weight Decay\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9  # Decay if a valid best solution is found\n            \n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a conditional inertia weight decay based on solution quality to balance exploration and exploitation.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "752dd08c-a8a0-437e-a468-27f2d1777563", "metadata": {"aucs": [0.9081787810540243, 0.9081787810540243, 0.9081787810540243, 0.9101954285009074, 0.9101954285009074, 0.9101954285009074, 0.9107841364490106, 0.9107841364490106, 0.9107841364490106, 0.7483156165655127, 0.7483156165655127, 0.7483156165655127, 0.6464815064975709, 0.6464815064975709, 0.6464815064975709, 0.8057354332000595, 0.8057354332000595, 0.8057354332000595, 0.1854605058828822, 0.1854605058828822, 0.1854605058828822, 0.7528346164954676, 0.7528346164954676, 0.7528346164954676, 0.11618409375929628, 0.11618409375929628, 0.11618409375929628, 0.11328750983547686, 0.11328750983547686, 0.11328750983547686, 0.09748030946803321, 0.09748030946803321, 0.09748030946803321, 0.08763212012649457, 0.08763212012649457, 0.08763212012649457, 0.9822702539559259, 0.9822702539559259, 0.9822702539559259, 0.9878512440903272, 0.9878512440903272, 0.9878512440903272, 0.9823039872840109, 0.9823039872840109, 0.9823039872840109, 0.7837329933509061, 0.7837329933509061, 0.7837329933509061, 0.773367818347519, 0.773367818347519, 0.773367818347519, 0.7702476606484692, 0.7702476606484692, 0.7702476606484692, 0.13775432753003392, 0.13775432753003392, 0.13775432753003392, 0.16185252905288394, 0.16185252905288394, 0.16185252905288394, 0.3561666446282913, 0.3561666446282913, 0.3561666446282913, 0.2650441046343073, 0.2650441046343073, 0.2650441046343073, 0.2151683948343659, 0.2151683948343659, 0.2151683948343659, 0.22360049162648332, 0.22360049162648332, 0.22360049162648332, 0.20927190814878438, 0.20927190814878438, 0.20927190814878438, 0.1319635806052354, 0.1319635806052354, 0.1319635806052354, 0.26729225066272544, 0.26729225066272544, 0.26729225066272544, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12535911903603336, 0.12535911903603336, 0.12535911903603336, 0.04679140507916857, 0.04679140507916857, 0.04679140507916857, 0.06291610814836024, 0.06291610814836024, 0.06291610814836024, 0.05165498704204752, 0.05165498704204752, 0.05165498704204752, 0.07924572819360987, 0.07924572819360987, 0.07924572819360987, 0.10223609041920245, 0.10223609041920245, 0.10223609041920245, 0.011208180774248233, 0.011208180774248233, 0.011208180774248233, 0.05924606612892336, 0.05924606612892336, 0.05924606612892336, 0.04893961627237986, 0.04893961627237986, 0.04893961627237986, 0.5663522579219449, 0.5663522579219449, 0.5663522579219449, 0.5677865175606798, 0.5677865175606798, 0.5677865175606798, 0.5818477227805137, 0.5818477227805137, 0.5818477227805137, 0.12131296934582492, 0.12131296934582492, 0.12131296934582492, 0.09254229486638177, 0.09254229486638177, 0.09254229486638177, 0.1267948846921061, 0.1267948846921061, 0.1267948846921061, 0.2260712369338016, 0.2260712369338016, 0.2260712369338016, 0.17528166390727762, 0.17528166390727762, 0.17528166390727762, 0.1563899129342815, 0.1563899129342815, 0.1563899129342815, 0.4107318854645692, 0.4107318854645692, 0.4107318854645692, 0.4074125314300533, 0.4074125314300533, 0.4074125314300533, 0.3540218660266493, 0.3540218660266493, 0.3540218660266493, 0.20688669795363301, 0.20688669795363301, 0.20688669795363301, 0.19655537420618674, 0.19655537420618674, 0.19655537420618674, 0.21353536486091085, 0.21353536486091085, 0.21353536486091085, 0.22573236760843096, 0.22573236760843096, 0.22573236760843096, 0.2466892387496462, 0.2466892387496462, 0.2466892387496462, 0.2154902109555188, 0.2154902109555188, 0.2154902109555188, 0.20700289682426676, 0.20700289682426676, 0.20700289682426676, 0.20732303725656065, 0.20732303725656065, 0.20732303725656065, 0.22795084230993068, 0.22795084230993068, 0.22795084230993068, 0.9368883173438388, 0.9368883173438388, 0.9368883173438388, 0.15911446145811492, 0.15911446145811492, 0.15911446145811492, 0.18603930491011356, 0.18603930491011356, 0.18603930491011356, 0.1686325957866125, 0.1686325957866125, 0.1686325957866125, 0.20931461766796677, 0.20931461766796677, 0.20931461766796677, 0.15638931564339198, 0.15638931564339198, 0.15638931564339198, 0.21345517264865543, 0.21345517264865543, 0.21345517264865543, 0.2002813352445274, 0.2002813352445274, 0.2002813352445274, 0.19398254204571985, 0.19398254204571985, 0.19398254204571985, 0.10278490420029607, 0.10278490420029607, 0.10278490420029607, 0.0985176300044941, 0.0985176300044941, 0.0985176300044941, 0.09267092155437806, 0.09267092155437806, 0.09267092155437806]}, "mutation_prompt": null}
{"id": "21b30946-b9f8-4e94-b97f-2dfee9adf1a0", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Conditional Inertia Weight Decay\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9  # Decay if a valid best solution is found\n            \n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a conditional inertia weight decay based on solution quality to balance exploration and exploitation.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "752dd08c-a8a0-437e-a468-27f2d1777563", "metadata": {"aucs": [0.9081787810540243, 0.9081787810540243, 0.9081787810540243, 0.9101954285009074, 0.9101954285009074, 0.9101954285009074, 0.9107841364490106, 0.9107841364490106, 0.9107841364490106, 0.7483156165655127, 0.7483156165655127, 0.7483156165655127, 0.6464815064975709, 0.6464815064975709, 0.6464815064975709, 0.8057354332000595, 0.8057354332000595, 0.8057354332000595, 0.1854605058828822, 0.1854605058828822, 0.1854605058828822, 0.7528346164954676, 0.7528346164954676, 0.7528346164954676, 0.11618409375929628, 0.11618409375929628, 0.11618409375929628, 0.11328750983547686, 0.11328750983547686, 0.11328750983547686, 0.09748030946803321, 0.09748030946803321, 0.09748030946803321, 0.08763212012649457, 0.08763212012649457, 0.08763212012649457, 0.9822702539559259, 0.9822702539559259, 0.9822702539559259, 0.9878512440903272, 0.9878512440903272, 0.9878512440903272, 0.9823039872840109, 0.9823039872840109, 0.9823039872840109, 0.7837329933509061, 0.7837329933509061, 0.7837329933509061, 0.773367818347519, 0.773367818347519, 0.773367818347519, 0.7702476606484692, 0.7702476606484692, 0.7702476606484692, 0.13775432753003392, 0.13775432753003392, 0.13775432753003392, 0.16185252905288394, 0.16185252905288394, 0.16185252905288394, 0.3561666446282913, 0.3561666446282913, 0.3561666446282913, 0.2650441046343073, 0.2650441046343073, 0.2650441046343073, 0.2151683948343659, 0.2151683948343659, 0.2151683948343659, 0.22360049162648332, 0.22360049162648332, 0.22360049162648332, 0.20927190814878438, 0.20927190814878438, 0.20927190814878438, 0.1319635806052354, 0.1319635806052354, 0.1319635806052354, 0.26729225066272544, 0.26729225066272544, 0.26729225066272544, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12535911903603336, 0.12535911903603336, 0.12535911903603336, 0.04679140507916857, 0.04679140507916857, 0.04679140507916857, 0.06291610814836024, 0.06291610814836024, 0.06291610814836024, 0.05165498704204752, 0.05165498704204752, 0.05165498704204752, 0.07924572819360987, 0.07924572819360987, 0.07924572819360987, 0.10223609041920245, 0.10223609041920245, 0.10223609041920245, 0.011208180774248233, 0.011208180774248233, 0.011208180774248233, 0.05924606612892336, 0.05924606612892336, 0.05924606612892336, 0.04893961627237986, 0.04893961627237986, 0.04893961627237986, 0.5663522579219449, 0.5663522579219449, 0.5663522579219449, 0.5677865175606798, 0.5677865175606798, 0.5677865175606798, 0.5818477227805137, 0.5818477227805137, 0.5818477227805137, 0.12131296934582492, 0.12131296934582492, 0.12131296934582492, 0.09254229486638177, 0.09254229486638177, 0.09254229486638177, 0.1267948846921061, 0.1267948846921061, 0.1267948846921061, 0.2260712369338016, 0.2260712369338016, 0.2260712369338016, 0.17528166390727762, 0.17528166390727762, 0.17528166390727762, 0.1563899129342815, 0.1563899129342815, 0.1563899129342815, 0.4107318854645692, 0.4107318854645692, 0.4107318854645692, 0.4074125314300533, 0.4074125314300533, 0.4074125314300533, 0.3540218660266493, 0.3540218660266493, 0.3540218660266493, 0.20688669795363301, 0.20688669795363301, 0.20688669795363301, 0.19655537420618674, 0.19655537420618674, 0.19655537420618674, 0.21353536486091085, 0.21353536486091085, 0.21353536486091085, 0.22573236760843096, 0.22573236760843096, 0.22573236760843096, 0.2466892387496462, 0.2466892387496462, 0.2466892387496462, 0.2154902109555188, 0.2154902109555188, 0.2154902109555188, 0.20700289682426676, 0.20700289682426676, 0.20700289682426676, 0.20732303725656065, 0.20732303725656065, 0.20732303725656065, 0.22795084230993068, 0.22795084230993068, 0.22795084230993068, 0.9368883173438388, 0.9368883173438388, 0.9368883173438388, 0.15911446145811492, 0.15911446145811492, 0.15911446145811492, 0.18603930491011356, 0.18603930491011356, 0.18603930491011356, 0.1686325957866125, 0.1686325957866125, 0.1686325957866125, 0.20931461766796677, 0.20931461766796677, 0.20931461766796677, 0.15638931564339198, 0.15638931564339198, 0.15638931564339198, 0.21345517264865543, 0.21345517264865543, 0.21345517264865543, 0.2002813352445274, 0.2002813352445274, 0.2002813352445274, 0.19398254204571985, 0.19398254204571985, 0.19398254204571985, 0.10278490420029607, 0.10278490420029607, 0.10278490420029607, 0.0985176300044941, 0.0985176300044941, 0.0985176300044941, 0.09267092155437806, 0.09267092155437806, 0.09267092155437806]}, "mutation_prompt": null}
{"id": "36aa7040-0b79-4768-b37d-e84b3c26b454", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Conditional Inertia Weight Decay\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9  # Decay if a valid best solution is found\n            \n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a conditional inertia weight decay based on solution quality to balance exploration and exploitation.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "752dd08c-a8a0-437e-a468-27f2d1777563", "metadata": {"aucs": [0.9081787810540243, 0.9081787810540243, 0.9081787810540243, 0.9101954285009074, 0.9101954285009074, 0.9101954285009074, 0.9107841364490106, 0.9107841364490106, 0.9107841364490106, 0.7483156165655127, 0.7483156165655127, 0.7483156165655127, 0.6464815064975709, 0.6464815064975709, 0.6464815064975709, 0.8057354332000595, 0.8057354332000595, 0.8057354332000595, 0.1854605058828822, 0.1854605058828822, 0.1854605058828822, 0.7528346164954676, 0.7528346164954676, 0.7528346164954676, 0.11618409375929628, 0.11618409375929628, 0.11618409375929628, 0.11328750983547686, 0.11328750983547686, 0.11328750983547686, 0.09748030946803321, 0.09748030946803321, 0.09748030946803321, 0.08763212012649457, 0.08763212012649457, 0.08763212012649457, 0.9822702539559259, 0.9822702539559259, 0.9822702539559259, 0.9878512440903272, 0.9878512440903272, 0.9878512440903272, 0.9823039872840109, 0.9823039872840109, 0.9823039872840109, 0.7837329933509061, 0.7837329933509061, 0.7837329933509061, 0.773367818347519, 0.773367818347519, 0.773367818347519, 0.7702476606484692, 0.7702476606484692, 0.7702476606484692, 0.13775432753003392, 0.13775432753003392, 0.13775432753003392, 0.16185252905288394, 0.16185252905288394, 0.16185252905288394, 0.3561666446282913, 0.3561666446282913, 0.3561666446282913, 0.2650441046343073, 0.2650441046343073, 0.2650441046343073, 0.2151683948343659, 0.2151683948343659, 0.2151683948343659, 0.22360049162648332, 0.22360049162648332, 0.22360049162648332, 0.20927190814878438, 0.20927190814878438, 0.20927190814878438, 0.1319635806052354, 0.1319635806052354, 0.1319635806052354, 0.26729225066272544, 0.26729225066272544, 0.26729225066272544, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12535911903603336, 0.12535911903603336, 0.12535911903603336, 0.04679140507916857, 0.04679140507916857, 0.04679140507916857, 0.06291610814836024, 0.06291610814836024, 0.06291610814836024, 0.05165498704204752, 0.05165498704204752, 0.05165498704204752, 0.07924572819360987, 0.07924572819360987, 0.07924572819360987, 0.10223609041920245, 0.10223609041920245, 0.10223609041920245, 0.011208180774248233, 0.011208180774248233, 0.011208180774248233, 0.05924606612892336, 0.05924606612892336, 0.05924606612892336, 0.04893961627237986, 0.04893961627237986, 0.04893961627237986, 0.5663522579219449, 0.5663522579219449, 0.5663522579219449, 0.5677865175606798, 0.5677865175606798, 0.5677865175606798, 0.5818477227805137, 0.5818477227805137, 0.5818477227805137, 0.12131296934582492, 0.12131296934582492, 0.12131296934582492, 0.09254229486638177, 0.09254229486638177, 0.09254229486638177, 0.1267948846921061, 0.1267948846921061, 0.1267948846921061, 0.2260712369338016, 0.2260712369338016, 0.2260712369338016, 0.17528166390727762, 0.17528166390727762, 0.17528166390727762, 0.1563899129342815, 0.1563899129342815, 0.1563899129342815, 0.4107318854645692, 0.4107318854645692, 0.4107318854645692, 0.4074125314300533, 0.4074125314300533, 0.4074125314300533, 0.3540218660266493, 0.3540218660266493, 0.3540218660266493, 0.20688669795363301, 0.20688669795363301, 0.20688669795363301, 0.19655537420618674, 0.19655537420618674, 0.19655537420618674, 0.21353536486091085, 0.21353536486091085, 0.21353536486091085, 0.22573236760843096, 0.22573236760843096, 0.22573236760843096, 0.2466892387496462, 0.2466892387496462, 0.2466892387496462, 0.2154902109555188, 0.2154902109555188, 0.2154902109555188, 0.20700289682426676, 0.20700289682426676, 0.20700289682426676, 0.20732303725656065, 0.20732303725656065, 0.20732303725656065, 0.22795084230993068, 0.22795084230993068, 0.22795084230993068, 0.9368883173438388, 0.9368883173438388, 0.9368883173438388, 0.15911446145811492, 0.15911446145811492, 0.15911446145811492, 0.18603930491011356, 0.18603930491011356, 0.18603930491011356, 0.1686325957866125, 0.1686325957866125, 0.1686325957866125, 0.20931461766796677, 0.20931461766796677, 0.20931461766796677, 0.15638931564339198, 0.15638931564339198, 0.15638931564339198, 0.21345517264865543, 0.21345517264865543, 0.21345517264865543, 0.2002813352445274, 0.2002813352445274, 0.2002813352445274, 0.19398254204571985, 0.19398254204571985, 0.19398254204571985, 0.10278490420029607, 0.10278490420029607, 0.10278490420029607, 0.0985176300044941, 0.0985176300044941, 0.0985176300044941, 0.09267092155437806, 0.09267092155437806, 0.09267092155437806]}, "mutation_prompt": null}
{"id": "8ba3d5ef-1263-4f5f-b488-8d7077e0b278", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Conditional Inertia Weight Decay\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9  # Decay if a valid best solution is found\n            \n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n                adaptive_scaling = 1.0 - (eval_count / self.budget) * 0.1\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling * adaptive_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce adaptive scaling for velocity update to enhance convergence speed while balancing exploration and exploitation.", "configspace": "", "generation": 84, "fitness": 0.3153479168176045, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.30.", "error": "", "parent_id": "752dd08c-a8a0-437e-a468-27f2d1777563", "metadata": {"aucs": [0.9078881442385666, 0.9078881442385666, 0.9078881442385666, 0.9096007180118723, 0.9096007180118723, 0.9096007180118723, 0.9107485942322313, 0.9107485942322313, 0.9107485942322313, 0.7429464074320384, 0.7429464074320384, 0.7429464074320384, 0.6719977587009638, 0.6719977587009638, 0.6719977587009638, 0.809964430799655, 0.809964430799655, 0.809964430799655, 0.161604014989839, 0.161604014989839, 0.161604014989839, 0.1528817512791798, 0.1528817512791798, 0.1528817512791798, 0.17719985572652464, 0.17719985572652464, 0.17719985572652464, 0.12937076179653317, 0.12937076179653317, 0.12937076179653317, 0.07171565710324268, 0.07171565710324268, 0.07171565710324268, 0.12140715153081405, 0.12140715153081405, 0.12140715153081405, 0.9822692025945557, 0.9822692025945557, 0.9822692025945557, 0.9878512263843336, 0.9878512263843336, 0.9878512263843336, 0.9823038959084859, 0.9823038959084859, 0.9823038959084859, 0.7645057859629384, 0.7645057859629384, 0.7645057859629384, 0.7764841457276177, 0.7764841457276177, 0.7764841457276177, 0.77853342449618, 0.77853342449618, 0.77853342449618, 0.21637381025458835, 0.21637381025458835, 0.21637381025458835, 0.16185299579960843, 0.16185299579960843, 0.16185299579960843, 0.24395189916379179, 0.24395189916379179, 0.24395189916379179, 0.2769739598055947, 0.2769739598055947, 0.2769739598055947, 0.20286101158811987, 0.20286101158811987, 0.20286101158811987, 0.17393431312418361, 0.17393431312418361, 0.17393431312418361, 0.22921632683736692, 0.22921632683736692, 0.22921632683736692, 0.13226795070886455, 0.13226795070886455, 0.13226795070886455, 0.274071904303391, 0.274071904303391, 0.274071904303391, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11918024870323263, 0.11918024870323263, 0.11918024870323263, 0.06671824803003512, 0.06671824803003512, 0.06671824803003512, 0.06482569501645608, 0.06482569501645608, 0.06482569501645608, 0.052473859315492866, 0.052473859315492866, 0.052473859315492866, 0.08004542064097475, 0.08004542064097475, 0.08004542064097475, 0.10512449463764173, 0.10512449463764173, 0.10512449463764173, 0.011119638982627689, 0.011119638982627689, 0.011119638982627689, 0.061966201959795075, 0.061966201959795075, 0.061966201959795075, 0.04893189382951624, 0.04893189382951624, 0.04893189382951624, 0.5781987188693725, 0.5781987188693725, 0.5781987188693725, 0.6508998859330049, 0.6508998859330049, 0.6508998859330049, 0.569636737007192, 0.569636737007192, 0.569636737007192, 0.11440802117869531, 0.11440802117869531, 0.11440802117869531, 0.09201570281466598, 0.09201570281466598, 0.09201570281466598, 0.10725387152877064, 0.10725387152877064, 0.10725387152877064, 0.2275002587121795, 0.2275002587121795, 0.2275002587121795, 0.1751072239695901, 0.1751072239695901, 0.1751072239695901, 0.16922284584479097, 0.16922284584479097, 0.16922284584479097, 0.3264504255101549, 0.3264504255101549, 0.3264504255101549, 0.5178731297220514, 0.5178731297220514, 0.5178731297220514, 0.4448713567603487, 0.4448713567603487, 0.4448713567603487, 0.1853246070597494, 0.1853246070597494, 0.1853246070597494, 0.19598639461793554, 0.19598639461793554, 0.19598639461793554, 0.22002080811987845, 0.22002080811987845, 0.22002080811987845, 0.2077074128032843, 0.2077074128032843, 0.2077074128032843, 0.2253409878404875, 0.2253409878404875, 0.2253409878404875, 0.2082439198823065, 0.2082439198823065, 0.2082439198823065, 0.20696265409669967, 0.20696265409669967, 0.20696265409669967, 0.1889606269124704, 0.1889606269124704, 0.1889606269124704, 0.8419477741922863, 0.8419477741922863, 0.8419477741922863, 0.9311518162435701, 0.9311518162435701, 0.9311518162435701, 0.1591130559732803, 0.1591130559732803, 0.1591130559732803, 0.1860386451268019, 0.1860386451268019, 0.1860386451268019, 0.1686313320383075, 0.1686313320383075, 0.1686313320383075, 0.2093296564098851, 0.2093296564098851, 0.2093296564098851, 0.15639261217971612, 0.15639261217971612, 0.15639261217971612, 0.18406700427846767, 0.18406700427846767, 0.18406700427846767, 0.19521571744102706, 0.19521571744102706, 0.19521571744102706, 0.18773134898977695, 0.18773134898977695, 0.18773134898977695, 0.09348631738393853, 0.09348631738393853, 0.09348631738393853, 0.11725697477432118, 0.11725697477432118, 0.11725697477432118, 0.10123936703566638, 0.10123936703566638, 0.10123936703566638]}, "mutation_prompt": null}
{"id": "bbc59f6d-8ef1-494e-a273-143573a72b76", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Conditional Inertia Weight Decay\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9  # Decay if a valid best solution is found\n            \n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n                adaptive_scaling = 1.0 - (eval_count / self.budget) * 0.1\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling * adaptive_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce adaptive scaling for velocity update to enhance convergence speed while balancing exploration and exploitation.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8ba3d5ef-1263-4f5f-b488-8d7077e0b278", "metadata": {"aucs": [0.9078881442385666, 0.9078881442385666, 0.9078881442385666, 0.9096007180118723, 0.9096007180118723, 0.9096007180118723, 0.9107485942322313, 0.9107485942322313, 0.9107485942322313, 0.7429464074320384, 0.7429464074320384, 0.7429464074320384, 0.6719977587009638, 0.6719977587009638, 0.6719977587009638, 0.809964430799655, 0.809964430799655, 0.809964430799655, 0.161604014989839, 0.161604014989839, 0.161604014989839, 0.1528817512791798, 0.1528817512791798, 0.1528817512791798, 0.17719985572652464, 0.17719985572652464, 0.17719985572652464, 0.12937076179653317, 0.12937076179653317, 0.12937076179653317, 0.07171565710324268, 0.07171565710324268, 0.07171565710324268, 0.12140715153081405, 0.12140715153081405, 0.12140715153081405, 0.9822692025945557, 0.9822692025945557, 0.9822692025945557, 0.9878512263843336, 0.9878512263843336, 0.9878512263843336, 0.9823038959084859, 0.9823038959084859, 0.9823038959084859, 0.7645057859629384, 0.7645057859629384, 0.7645057859629384, 0.7764841457276177, 0.7764841457276177, 0.7764841457276177, 0.77853342449618, 0.77853342449618, 0.77853342449618, 0.21637381025458835, 0.21637381025458835, 0.21637381025458835, 0.16185299579960843, 0.16185299579960843, 0.16185299579960843, 0.24395189916379179, 0.24395189916379179, 0.24395189916379179, 0.2769739598055947, 0.2769739598055947, 0.2769739598055947, 0.20286101158811987, 0.20286101158811987, 0.20286101158811987, 0.17393431312418361, 0.17393431312418361, 0.17393431312418361, 0.22921632683736692, 0.22921632683736692, 0.22921632683736692, 0.13226795070886455, 0.13226795070886455, 0.13226795070886455, 0.274071904303391, 0.274071904303391, 0.274071904303391, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11918024870323263, 0.11918024870323263, 0.11918024870323263, 0.06671824803003512, 0.06671824803003512, 0.06671824803003512, 0.06482569501645608, 0.06482569501645608, 0.06482569501645608, 0.052473859315492866, 0.052473859315492866, 0.052473859315492866, 0.08004542064097475, 0.08004542064097475, 0.08004542064097475, 0.10512449463764173, 0.10512449463764173, 0.10512449463764173, 0.011119638982627689, 0.011119638982627689, 0.011119638982627689, 0.061966201959795075, 0.061966201959795075, 0.061966201959795075, 0.04893189382951624, 0.04893189382951624, 0.04893189382951624, 0.5781987188693725, 0.5781987188693725, 0.5781987188693725, 0.6508998859330049, 0.6508998859330049, 0.6508998859330049, 0.569636737007192, 0.569636737007192, 0.569636737007192, 0.11440802117869531, 0.11440802117869531, 0.11440802117869531, 0.09201570281466598, 0.09201570281466598, 0.09201570281466598, 0.10725387152877064, 0.10725387152877064, 0.10725387152877064, 0.2275002587121795, 0.2275002587121795, 0.2275002587121795, 0.1751072239695901, 0.1751072239695901, 0.1751072239695901, 0.16922284584479097, 0.16922284584479097, 0.16922284584479097, 0.3264504255101549, 0.3264504255101549, 0.3264504255101549, 0.5178731297220514, 0.5178731297220514, 0.5178731297220514, 0.4448713567603487, 0.4448713567603487, 0.4448713567603487, 0.1853246070597494, 0.1853246070597494, 0.1853246070597494, 0.19598639461793554, 0.19598639461793554, 0.19598639461793554, 0.22002080811987845, 0.22002080811987845, 0.22002080811987845, 0.2077074128032843, 0.2077074128032843, 0.2077074128032843, 0.2253409878404875, 0.2253409878404875, 0.2253409878404875, 0.2082439198823065, 0.2082439198823065, 0.2082439198823065, 0.20696265409669967, 0.20696265409669967, 0.20696265409669967, 0.1889606269124704, 0.1889606269124704, 0.1889606269124704, 0.8419477741922863, 0.8419477741922863, 0.8419477741922863, 0.9311518162435701, 0.9311518162435701, 0.9311518162435701, 0.1591130559732803, 0.1591130559732803, 0.1591130559732803, 0.1860386451268019, 0.1860386451268019, 0.1860386451268019, 0.1686313320383075, 0.1686313320383075, 0.1686313320383075, 0.2093296564098851, 0.2093296564098851, 0.2093296564098851, 0.15639261217971612, 0.15639261217971612, 0.15639261217971612, 0.18406700427846767, 0.18406700427846767, 0.18406700427846767, 0.19521571744102706, 0.19521571744102706, 0.19521571744102706, 0.18773134898977695, 0.18773134898977695, 0.18773134898977695, 0.09348631738393853, 0.09348631738393853, 0.09348631738393853, 0.11725697477432118, 0.11725697477432118, 0.11725697477432118, 0.10123936703566638, 0.10123936703566638, 0.10123936703566638]}, "mutation_prompt": null}
{"id": "13d491ac-70f9-4f44-bd41-37e51bf1560f", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Conditional Inertia Weight Decay\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9  # Decay if a valid best solution is found\n            \n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n                adaptive_scaling = 1.0 - (eval_count / self.budget) * 0.1\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling * adaptive_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce adaptive scaling for velocity update to enhance convergence speed while balancing exploration and exploitation.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8ba3d5ef-1263-4f5f-b488-8d7077e0b278", "metadata": {"aucs": [0.9078881442385666, 0.9078881442385666, 0.9078881442385666, 0.9096007180118723, 0.9096007180118723, 0.9096007180118723, 0.9107485942322313, 0.9107485942322313, 0.9107485942322313, 0.7429464074320384, 0.7429464074320384, 0.7429464074320384, 0.6719977587009638, 0.6719977587009638, 0.6719977587009638, 0.809964430799655, 0.809964430799655, 0.809964430799655, 0.161604014989839, 0.161604014989839, 0.161604014989839, 0.1528817512791798, 0.1528817512791798, 0.1528817512791798, 0.17719985572652464, 0.17719985572652464, 0.17719985572652464, 0.12937076179653317, 0.12937076179653317, 0.12937076179653317, 0.07171565710324268, 0.07171565710324268, 0.07171565710324268, 0.12140715153081405, 0.12140715153081405, 0.12140715153081405, 0.9822692025945557, 0.9822692025945557, 0.9822692025945557, 0.9878512263843336, 0.9878512263843336, 0.9878512263843336, 0.9823038959084859, 0.9823038959084859, 0.9823038959084859, 0.7645057859629384, 0.7645057859629384, 0.7645057859629384, 0.7764841457276177, 0.7764841457276177, 0.7764841457276177, 0.77853342449618, 0.77853342449618, 0.77853342449618, 0.21637381025458835, 0.21637381025458835, 0.21637381025458835, 0.16185299579960843, 0.16185299579960843, 0.16185299579960843, 0.24395189916379179, 0.24395189916379179, 0.24395189916379179, 0.2769739598055947, 0.2769739598055947, 0.2769739598055947, 0.20286101158811987, 0.20286101158811987, 0.20286101158811987, 0.17393431312418361, 0.17393431312418361, 0.17393431312418361, 0.22921632683736692, 0.22921632683736692, 0.22921632683736692, 0.13226795070886455, 0.13226795070886455, 0.13226795070886455, 0.274071904303391, 0.274071904303391, 0.274071904303391, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11918024870323263, 0.11918024870323263, 0.11918024870323263, 0.06671824803003512, 0.06671824803003512, 0.06671824803003512, 0.06482569501645608, 0.06482569501645608, 0.06482569501645608, 0.052473859315492866, 0.052473859315492866, 0.052473859315492866, 0.08004542064097475, 0.08004542064097475, 0.08004542064097475, 0.10512449463764173, 0.10512449463764173, 0.10512449463764173, 0.011119638982627689, 0.011119638982627689, 0.011119638982627689, 0.061966201959795075, 0.061966201959795075, 0.061966201959795075, 0.04893189382951624, 0.04893189382951624, 0.04893189382951624, 0.5781987188693725, 0.5781987188693725, 0.5781987188693725, 0.6508998859330049, 0.6508998859330049, 0.6508998859330049, 0.569636737007192, 0.569636737007192, 0.569636737007192, 0.11440802117869531, 0.11440802117869531, 0.11440802117869531, 0.09201570281466598, 0.09201570281466598, 0.09201570281466598, 0.10725387152877064, 0.10725387152877064, 0.10725387152877064, 0.2275002587121795, 0.2275002587121795, 0.2275002587121795, 0.1751072239695901, 0.1751072239695901, 0.1751072239695901, 0.16922284584479097, 0.16922284584479097, 0.16922284584479097, 0.3264504255101549, 0.3264504255101549, 0.3264504255101549, 0.5178731297220514, 0.5178731297220514, 0.5178731297220514, 0.4448713567603487, 0.4448713567603487, 0.4448713567603487, 0.1853246070597494, 0.1853246070597494, 0.1853246070597494, 0.19598639461793554, 0.19598639461793554, 0.19598639461793554, 0.22002080811987845, 0.22002080811987845, 0.22002080811987845, 0.2077074128032843, 0.2077074128032843, 0.2077074128032843, 0.2253409878404875, 0.2253409878404875, 0.2253409878404875, 0.2082439198823065, 0.2082439198823065, 0.2082439198823065, 0.20696265409669967, 0.20696265409669967, 0.20696265409669967, 0.1889606269124704, 0.1889606269124704, 0.1889606269124704, 0.8419477741922863, 0.8419477741922863, 0.8419477741922863, 0.9311518162435701, 0.9311518162435701, 0.9311518162435701, 0.1591130559732803, 0.1591130559732803, 0.1591130559732803, 0.1860386451268019, 0.1860386451268019, 0.1860386451268019, 0.1686313320383075, 0.1686313320383075, 0.1686313320383075, 0.2093296564098851, 0.2093296564098851, 0.2093296564098851, 0.15639261217971612, 0.15639261217971612, 0.15639261217971612, 0.18406700427846767, 0.18406700427846767, 0.18406700427846767, 0.19521571744102706, 0.19521571744102706, 0.19521571744102706, 0.18773134898977695, 0.18773134898977695, 0.18773134898977695, 0.09348631738393853, 0.09348631738393853, 0.09348631738393853, 0.11725697477432118, 0.11725697477432118, 0.11725697477432118, 0.10123936703566638, 0.10123936703566638, 0.10123936703566638]}, "mutation_prompt": null}
{"id": "59c8fec0-3b0d-4f15-ae3b-3f5249e913ad", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F_initial = 0.8  # Initial DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Conditional Inertia Weight Decay\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9  # Decay if a valid best solution is found\n            \n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            diversity = np.std(pop, axis=0).mean()\n            self.F = self.F_initial + diversity * 0.1  # Dynamic scaling factor\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n                adaptive_scaling = 1.0 - (eval_count / self.budget) * 0.1\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling * adaptive_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce dynamic adjustment of DE scaling factor based on population diversity to improve convergence.", "configspace": "", "generation": 87, "fitness": 0.29633819805289974, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.29.", "error": "", "parent_id": "8ba3d5ef-1263-4f5f-b488-8d7077e0b278", "metadata": {"aucs": [0.8986301934048144, 0.8986301934048144, 0.8986301934048144, 0.9023590973745776, 0.9023590973745776, 0.9023590973745776, 0.914813206908327, 0.914813206908327, 0.914813206908327, 0.7491988335064663, 0.7491988335064663, 0.7491988335064663, 0.7901246402108371, 0.7901246402108371, 0.7901246402108371, 0.810048386413148, 0.810048386413148, 0.810048386413148, 0.1597860270332485, 0.1597860270332485, 0.1597860270332485, 0.1409478201097072, 0.1409478201097072, 0.1409478201097072, 0.18508980103617123, 0.18508980103617123, 0.18508980103617123, 0.11342332559541446, 0.11342332559541446, 0.11342332559541446, 0.13738910288437034, 0.13738910288437034, 0.13738910288437034, 0.10684408410059187, 0.10684408410059187, 0.10684408410059187, 0.9796879187051258, 0.9796879187051258, 0.9796879187051258, 0.9855446971569358, 0.9855446971569358, 0.9855446971569358, 0.9824161076145157, 0.9824161076145157, 0.9824161076145157, 0.7778241981820675, 0.7778241981820675, 0.7778241981820675, 0.1522575496250278, 0.1522575496250278, 0.1522575496250278, 0.7456564033086821, 0.7456564033086821, 0.7456564033086821, 0.21315899799009064, 0.21315899799009064, 0.21315899799009064, 0.16162070370063664, 0.16162070370063664, 0.16162070370063664, 0.10526503523378361, 0.10526503523378361, 0.10526503523378361, 0.13369565631574898, 0.13369565631574898, 0.13369565631574898, 0.13487824385892033, 0.13487824385892033, 0.13487824385892033, 0.12945090089646694, 0.12945090089646694, 0.12945090089646694, 0.016517897563156803, 0.016517897563156803, 0.016517897563156803, 0.24855256114998103, 0.24855256114998103, 0.24855256114998103, 0.24227951787569812, 0.24227951787569812, 0.24227951787569812, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04078343310445909, 0.04078343310445909, 0.04078343310445909, 0.05050369246060016, 0.05050369246060016, 0.05050369246060016, 0.1571330455201494, 0.1571330455201494, 0.1571330455201494, 0.05183165377380705, 0.05183165377380705, 0.05183165377380705, 0.07970265652923203, 0.07970265652923203, 0.07970265652923203, 0.0740368052081174, 0.0740368052081174, 0.0740368052081174, 0.15872412749764575, 0.15872412749764575, 0.15872412749764575, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09055185308679226, 0.09055185308679226, 0.09055185308679226, 0.5318321190913788, 0.5318321190913788, 0.5318321190913788, 0.5384565842843548, 0.5384565842843548, 0.5384565842843548, 0.6102946277074497, 0.6102946277074497, 0.6102946277074497, 0.06946399623914656, 0.06946399623914656, 0.06946399623914656, 0.15206105869359832, 0.15206105869359832, 0.15206105869359832, 0.0941058284542845, 0.0941058284542845, 0.0941058284542845, 0.1731571880048296, 0.1731571880048296, 0.1731571880048296, 0.1737461886790328, 0.1737461886790328, 0.1737461886790328, 0.26876011033187475, 0.26876011033187475, 0.26876011033187475, 0.39472982446337923, 0.39472982446337923, 0.39472982446337923, 0.3656049313142502, 0.3656049313142502, 0.3656049313142502, 0.7273602085053206, 0.7273602085053206, 0.7273602085053206, 0.2253688386033853, 0.2253688386033853, 0.2253688386033853, 0.35904470675355427, 0.35904470675355427, 0.35904470675355427, 0.12989892454507934, 0.12989892454507934, 0.12989892454507934, 0.20461999550761045, 0.20461999550761045, 0.20461999550761045, 0.2192583234740828, 0.2192583234740828, 0.2192583234740828, 0.20556696032601818, 0.20556696032601818, 0.20556696032601818, 0.1911109062282086, 0.1911109062282086, 0.1911109062282086, 0.19924911089134634, 0.19924911089134634, 0.19924911089134634, 0.20916295395803952, 0.20916295395803952, 0.20916295395803952, 0.9182916609622579, 0.9182916609622579, 0.9182916609622579, 0.1638308315175293, 0.1638308315175293, 0.1638308315175293, 0.19999021005231232, 0.19999021005231232, 0.19999021005231232, 0.16825200661558515, 0.16825200661558515, 0.16825200661558515, 0.20953906548255163, 0.20953906548255163, 0.20953906548255163, 0.15639503104227892, 0.15639503104227892, 0.15639503104227892, 0.18629716516937467, 0.18629716516937467, 0.18629716516937467, 0.18863465976672011, 0.18863465976672011, 0.18863465976672011, 0.19709863614189205, 0.19709863614189205, 0.19709863614189205, 0.09084965670466627, 0.09084965670466627, 0.09084965670466627, 0.0922556283786038, 0.0922556283786038, 0.0922556283786038, 0.10093414698346825, 0.10093414698346825, 0.10093414698346825]}, "mutation_prompt": null}
{"id": "d6c71820-7913-49e6-b028-75743b898b5a", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Conditional Inertia Weight Decay\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9  # Decay if a valid best solution is found\n            \n            # Nonlinear decay for crossover probability\n            self.CR = self.CR_initial * (1 - (eval_count / self.budget)**2)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n                adaptive_scaling = 1.0 - (eval_count / self.budget) * 0.1\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling * adaptive_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a nonlinear decay for the DE crossover probability to enhance exploration-exploitation balance.", "configspace": "", "generation": 88, "fitness": 0.3111135588737927, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.29.", "error": "", "parent_id": "8ba3d5ef-1263-4f5f-b488-8d7077e0b278", "metadata": {"aucs": [0.9053034099873274, 0.9053034099873274, 0.9053034099873274, 0.9108537172243547, 0.9108537172243547, 0.9108537172243547, 0.9078278157681313, 0.9078278157681313, 0.9078278157681313, 0.7843341604131358, 0.7843341604131358, 0.7843341604131358, 0.06051915097229066, 0.06051915097229066, 0.06051915097229066, 0.810498905721112, 0.810498905721112, 0.810498905721112, 0.7427424413708437, 0.7427424413708437, 0.7427424413708437, 0.12215919517399254, 0.12215919517399254, 0.12215919517399254, 0.15466695947758757, 0.15466695947758757, 0.15466695947758757, 0.1395067499476521, 0.1395067499476521, 0.1395067499476521, 0.07173305975032196, 0.07173305975032196, 0.07173305975032196, 0.10260900623506242, 0.10260900623506242, 0.10260900623506242, 0.9822692025945557, 0.9822692025945557, 0.9822692025945557, 0.9878512263843336, 0.9878512263843336, 0.9878512263843336, 0.9823038959084859, 0.9823038959084859, 0.9823038959084859, 0.7699258763361226, 0.7699258763361226, 0.7699258763361226, 0.7277726302006783, 0.7277726302006783, 0.7277726302006783, 0.7511404207098284, 0.7511404207098284, 0.7511404207098284, 0.13812670990635467, 0.13812670990635467, 0.13812670990635467, 0.16185299579960843, 0.16185299579960843, 0.16185299579960843, 0.24362743935395226, 0.24362743935395226, 0.24362743935395226, 0.22042056437411872, 0.22042056437411872, 0.22042056437411872, 0.19195806985665853, 0.19195806985665853, 0.19195806985665853, 0.1306250888988597, 0.1306250888988597, 0.1306250888988597, 0.20111544377442137, 0.20111544377442137, 0.20111544377442137, 0.13188608315028927, 0.13188608315028927, 0.13188608315028927, 0.2425617945845142, 0.2425617945845142, 0.2425617945845142, 0.01837106352386131, 0.01837106352386131, 0.01837106352386131, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12364694877704618, 0.12364694877704618, 0.12364694877704618, 0.04813777395755747, 0.04813777395755747, 0.04813777395755747, 0.05872550227373363, 0.05872550227373363, 0.05872550227373363, 0.05082848413940266, 0.05082848413940266, 0.05082848413940266, 0.08028535653200763, 0.08028535653200763, 0.08028535653200763, 0.10571646336745144, 0.10571646336745144, 0.10571646336745144, 0.011213898556162505, 0.011213898556162505, 0.011213898556162505, 0.06844474577435888, 0.06844474577435888, 0.06844474577435888, 0.04892369357355797, 0.04892369357355797, 0.04892369357355797, 0.5418107722565166, 0.5418107722565166, 0.5418107722565166, 0.5375646183209998, 0.5375646183209998, 0.5375646183209998, 0.5913444492252065, 0.5913444492252065, 0.5913444492252065, 0.1160917217237093, 0.1160917217237093, 0.1160917217237093, 0.11865045435084154, 0.11865045435084154, 0.11865045435084154, 0.11659294261429698, 0.11659294261429698, 0.11659294261429698, 0.22559215696931856, 0.22559215696931856, 0.22559215696931856, 0.17494824377455875, 0.17494824377455875, 0.17494824377455875, 0.2718502853573971, 0.2718502853573971, 0.2718502853573971, 0.5389026246312227, 0.5389026246312227, 0.5389026246312227, 0.6076855195649176, 0.6076855195649176, 0.6076855195649176, 0.5459270660515904, 0.5459270660515904, 0.5459270660515904, 0.23481230367619133, 0.23481230367619133, 0.23481230367619133, 0.18003017700027013, 0.18003017700027013, 0.18003017700027013, 0.3486672307170333, 0.3486672307170333, 0.3486672307170333, 0.25830806231164694, 0.25830806231164694, 0.25830806231164694, 0.21837178272765745, 0.21837178272765745, 0.21837178272765745, 0.22459797577125484, 0.22459797577125484, 0.22459797577125484, 0.20722312494042894, 0.20722312494042894, 0.20722312494042894, 0.20895836974809523, 0.20895836974809523, 0.20895836974809523, 0.22779199624548485, 0.22779199624548485, 0.22779199624548485, 0.9358036300448861, 0.9358036300448861, 0.9358036300448861, 0.15911321635345865, 0.15911321635345865, 0.15911321635345865, 0.18603864499145795, 0.18603864499145795, 0.18603864499145795, 0.1686298898837436, 0.1686298898837436, 0.1686298898837436, 0.209231090003826, 0.209231090003826, 0.209231090003826, 0.1563985292268728, 0.1563985292268728, 0.1563985292268728, 0.18757125046189438, 0.18757125046189438, 0.18757125046189438, 0.19900962826445945, 0.19900962826445945, 0.19900962826445945, 0.20205146892415726, 0.20205146892415726, 0.20205146892415726, 0.09358732028319705, 0.09358732028319705, 0.09358732028319705, 0.11757026765349332, 0.11757026765349332, 0.11757026765349332, 0.09876348049325478, 0.09876348049325478, 0.09876348049325478]}, "mutation_prompt": null}
{"id": "c4432a99-a9fd-4004-b163-b04a009f9d38", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w_initial = 0.7  # Initial maximum inertia weight\n        self.w_min = 0.4      # Minimum inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Conditional Inertia Weight Decay with dynamic range\n            if best_global_value < np.inf:\n                self.w_initial *= 0.9  # Decay if a valid best solution is found\n            self.w = self.w_min + (self.w_initial - self.w_min) * (1 - eval_count / self.budget)\n\n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n                adaptive_scaling = 1.0 - (eval_count / self.budget) * 0.1\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling * adaptive_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a dynamic inertia weight range based on the best solution found so far to further balance exploration and exploitation.", "configspace": "", "generation": 89, "fitness": 0.286694123782335, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.28.", "error": "", "parent_id": "8ba3d5ef-1263-4f5f-b488-8d7077e0b278", "metadata": {"aucs": [0.9262405849969739, 0.9262405849969739, 0.9262405849969739, 0.9213443490241059, 0.9213443490241059, 0.9213443490241059, 0.9226402372838929, 0.9226402372838929, 0.9226402372838929, 0.811494398408841, 0.811494398408841, 0.811494398408841, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.8356043511460362, 0.8356043511460362, 0.8356043511460362, 0.11693354327977468, 0.11693354327977468, 0.11693354327977468, 0.14117650175230678, 0.14117650175230678, 0.14117650175230678, 0.12462937182377354, 0.12462937182377354, 0.12462937182377354, 0.11992183548611701, 0.11992183548611701, 0.11992183548611701, 0.14082003796605436, 0.14082003796605436, 0.14082003796605436, 0.09550436316826583, 0.09550436316826583, 0.09550436316826583, 0.9822515374583313, 0.9822515374583313, 0.9822515374583313, 0.9878512263843336, 0.9878512263843336, 0.9878512263843336, 0.9823061573608821, 0.9823061573608821, 0.9823061573608821, 0.6251741153059011, 0.6251741153059011, 0.6251741153059011, 0.6756798947381351, 0.6756798947381351, 0.6756798947381351, 0.6531301418033326, 0.6531301418033326, 0.6531301418033326, 0.20058568784015374, 0.20058568784015374, 0.20058568784015374, 0.1619436222992423, 0.1619436222992423, 0.1619436222992423, 0.3954119177898464, 0.3954119177898464, 0.3954119177898464, 0.18028519589339198, 0.18028519589339198, 0.18028519589339198, 0.1321501789595062, 0.1321501789595062, 0.1321501789595062, 0.17344738792824888, 0.17344738792824888, 0.17344738792824888, 0.1282958539072917, 0.1282958539072917, 0.1282958539072917, 0.1497630714015732, 0.1497630714015732, 0.1497630714015732, 0.13063480214621925, 0.13063480214621925, 0.13063480214621925, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13758046248814748, 0.13758046248814748, 0.13758046248814748, 0.04923978317558575, 0.04923978317558575, 0.04923978317558575, 0.058254399069130214, 0.058254399069130214, 0.058254399069130214, 0.05935041724997514, 0.05935041724997514, 0.05935041724997514, 0.08462012811165165, 0.08462012811165165, 0.08462012811165165, 0.09405322914472858, 0.09405322914472858, 0.09405322914472858, 0.0264344025284432, 0.0264344025284432, 0.0264344025284432, 0.06766568841375442, 0.06766568841375442, 0.06766568841375442, 0.049085001343434076, 0.049085001343434076, 0.049085001343434076, 0.5273302167104237, 0.5273302167104237, 0.5273302167104237, 0.5613802566072301, 0.5613802566072301, 0.5613802566072301, 0.5654310581084474, 0.5654310581084474, 0.5654310581084474, 0.07946153957387503, 0.07946153957387503, 0.07946153957387503, 0.09070866106349329, 0.09070866106349329, 0.09070866106349329, 0.18768356482303594, 0.18768356482303594, 0.18768356482303594, 0.2136829572352762, 0.2136829572352762, 0.2136829572352762, 0.17401693670996266, 0.17401693670996266, 0.17401693670996266, 0.16306190429322176, 0.16306190429322176, 0.16306190429322176, 0.3062574940666065, 0.3062574940666065, 0.3062574940666065, 0.3071509709358444, 0.3071509709358444, 0.3071509709358444, 0.49153544066299637, 0.49153544066299637, 0.49153544066299637, 0.24902247467528982, 0.24902247467528982, 0.24902247467528982, 0.19792110772494076, 0.19792110772494076, 0.19792110772494076, 0.19969174341291718, 0.19969174341291718, 0.19969174341291718, 0.23191263420929886, 0.23191263420929886, 0.23191263420929886, 0.22583927530512737, 0.22583927530512737, 0.22583927530512737, 0.241609374591495, 0.241609374591495, 0.241609374591495, 0.2109076415174308, 0.2109076415174308, 0.2109076415174308, 0.2107294206365884, 0.2107294206365884, 0.2107294206365884, 0.2253143995779454, 0.2253143995779454, 0.2253143995779454, 0.907255648435484, 0.907255648435484, 0.907255648435484, 0.15910963433233116, 0.15910963433233116, 0.15910963433233116, 0.18606138304732278, 0.18606138304732278, 0.18606138304732278, 0.16861287591936414, 0.16861287591936414, 0.16861287591936414, 0.2073901348578202, 0.2073901348578202, 0.2073901348578202, 0.15654281163116301, 0.15654281163116301, 0.15654281163116301, 0.2007905913980781, 0.2007905913980781, 0.2007905913980781, 0.2102583199051663, 0.2102583199051663, 0.2102583199051663, 0.19366317891147677, 0.19366317891147677, 0.19366317891147677, 0.07844642875189889, 0.07844642875189889, 0.07844642875189889, 0.0843222249206379, 0.0843222249206379, 0.0843222249206379, 0.08697073069854855, 0.08697073069854855, 0.08697073069854855]}, "mutation_prompt": null}
{"id": "a33ed7e6-dd31-4f19-9c31-3c7de5e81d28", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Adaptive Inertia Weight Scaling\n            self.w = 0.4 + (0.6 - 0.4) * np.exp(-3.0 * eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9  # Decay if a valid best solution is found\n\n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n                adaptive_scaling = 1.0 - (eval_count / self.budget) * 0.1\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling * adaptive_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce an adaptive inertia weight scaling to enhance convergence speed by dynamically adjusting the exploration-exploitation balance.", "configspace": "", "generation": 90, "fitness": 0.2925726382550297, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.29.", "error": "", "parent_id": "8ba3d5ef-1263-4f5f-b488-8d7077e0b278", "metadata": {"aucs": [0.9103986582463093, 0.9103986582463093, 0.9103986582463093, 0.9066977234581995, 0.9066977234581995, 0.9066977234581995, 0.9213057090325489, 0.9213057090325489, 0.9213057090325489, 0.7828657888701812, 0.7828657888701812, 0.7828657888701812, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.831435898887195, 0.831435898887195, 0.831435898887195, 0.15996181459946435, 0.15996181459946435, 0.15996181459946435, 0.13300431874326935, 0.13300431874326935, 0.13300431874326935, 0.15721532838713215, 0.15721532838713215, 0.15721532838713215, 0.11920888622308123, 0.11920888622308123, 0.11920888622308123, 0.11560625499547883, 0.11560625499547883, 0.11560625499547883, 0.11556325074217566, 0.11556325074217566, 0.11556325074217566, 0.9822258670323643, 0.9822258670323643, 0.9822258670323643, 0.9878470734793995, 0.9878470734793995, 0.9878470734793995, 0.9818638130299155, 0.9818638130299155, 0.9818638130299155, 0.7666091954620978, 0.7666091954620978, 0.7666091954620978, 0.7836493448333465, 0.7836493448333465, 0.7836493448333465, 0.790693947566901, 0.790693947566901, 0.790693947566901, 0.0988046874325591, 0.0988046874325591, 0.0988046874325591, 0.1621038543638731, 0.1621038543638731, 0.1621038543638731, 0.2177547651404831, 0.2177547651404831, 0.2177547651404831, 0.19035331497786834, 0.19035331497786834, 0.19035331497786834, 0.13170000380562907, 0.13170000380562907, 0.13170000380562907, 0.20295279521046883, 0.20295279521046883, 0.20295279521046883, 0.23693194635501325, 0.23693194635501325, 0.23693194635501325, 0.192073456011993, 0.192073456011993, 0.192073456011993, 0.23458763427150686, 0.23458763427150686, 0.23458763427150686, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0958641283800098, 0.0958641283800098, 0.0958641283800098, 0.03259890150385414, 0.03259890150385414, 0.03259890150385414, 0.06836597097711561, 0.06836597097711561, 0.06836597097711561, 0.05246344225419419, 0.05246344225419419, 0.05246344225419419, 0.08426769670948175, 0.08426769670948175, 0.08426769670948175, 0.1054710179316547, 0.1054710179316547, 0.1054710179316547, 0.14874632091354834, 0.14874632091354834, 0.14874632091354834, 0.0606006595856754, 0.0606006595856754, 0.0606006595856754, 0.04945258481499204, 0.04945258481499204, 0.04945258481499204, 0.5567556277908428, 0.5567556277908428, 0.5567556277908428, 0.549010180549814, 0.549010180549814, 0.549010180549814, 0.5746045853344826, 0.5746045853344826, 0.5746045853344826, 0.1219813537683524, 0.1219813537683524, 0.1219813537683524, 0.1419644935741815, 0.1419644935741815, 0.1419644935741815, 0.12267098386903874, 0.12267098386903874, 0.12267098386903874, 0.17674130070284022, 0.17674130070284022, 0.17674130070284022, 0.17534240123503608, 0.17534240123503608, 0.17534240123503608, 0.2492175698971305, 0.2492175698971305, 0.2492175698971305, 0.32987298656444164, 0.32987298656444164, 0.32987298656444164, 0.2881618479279515, 0.2881618479279515, 0.2881618479279515, 0.4809276630783961, 0.4809276630783961, 0.4809276630783961, 0.22719248218241062, 0.22719248218241062, 0.22719248218241062, 0.21275430148597585, 0.21275430148597585, 0.21275430148597585, 0.14142268288922055, 0.14142268288922055, 0.14142268288922055, 0.2135869342633565, 0.2135869342633565, 0.2135869342633565, 0.21646927706875596, 0.21646927706875596, 0.21646927706875596, 0.1835985848819781, 0.1835985848819781, 0.1835985848819781, 0.22066402102849503, 0.22066402102849503, 0.22066402102849503, 0.197291290288774, 0.197291290288774, 0.197291290288774, 0.21006158468225766, 0.21006158468225766, 0.21006158468225766, 0.9233534630276233, 0.9233534630276233, 0.9233534630276233, 0.15896975158498916, 0.15896975158498916, 0.15896975158498916, 0.18607634824126051, 0.18607634824126051, 0.18607634824126051, 0.16861101523835753, 0.16861101523835753, 0.16861101523835753, 0.20983165391044123, 0.20983165391044123, 0.20983165391044123, 0.15645306070156584, 0.15645306070156584, 0.15645306070156584, 0.19328552786389286, 0.19328552786389286, 0.19328552786389286, 0.2111379899142125, 0.2111379899142125, 0.2111379899142125, 0.1804048624809198, 0.1804048624809198, 0.1804048624809198, 0.08824591985697772, 0.08824591985697772, 0.08824591985697772, 0.09070837668368259, 0.09070837668368259, 0.09070837668368259, 0.09621377756549832, 0.09621377756549832, 0.09621377756549832]}, "mutation_prompt": null}
{"id": "af491da3-642a-40ed-85b1-dacddda937ed", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Conditional Inertia Weight Decay\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9  # Decay if a valid best solution is found\n            \n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n                adaptive_scaling = 1.0 - (eval_count / self.budget) * 0.1\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling * adaptive_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce adaptive scaling for velocity update to enhance convergence speed while balancing exploration and exploitation.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8ba3d5ef-1263-4f5f-b488-8d7077e0b278", "metadata": {"aucs": [0.9078881442385666, 0.9078881442385666, 0.9078881442385666, 0.9096007180118723, 0.9096007180118723, 0.9096007180118723, 0.9107485942322313, 0.9107485942322313, 0.9107485942322313, 0.7429464074320384, 0.7429464074320384, 0.7429464074320384, 0.6719977587009638, 0.6719977587009638, 0.6719977587009638, 0.809964430799655, 0.809964430799655, 0.809964430799655, 0.161604014989839, 0.161604014989839, 0.161604014989839, 0.1528817512791798, 0.1528817512791798, 0.1528817512791798, 0.17719985572652464, 0.17719985572652464, 0.17719985572652464, 0.12937076179653317, 0.12937076179653317, 0.12937076179653317, 0.07171565710324268, 0.07171565710324268, 0.07171565710324268, 0.12140715153081405, 0.12140715153081405, 0.12140715153081405, 0.9822692025945557, 0.9822692025945557, 0.9822692025945557, 0.9878512263843336, 0.9878512263843336, 0.9878512263843336, 0.9823038959084859, 0.9823038959084859, 0.9823038959084859, 0.7645057859629384, 0.7645057859629384, 0.7645057859629384, 0.7764841457276177, 0.7764841457276177, 0.7764841457276177, 0.77853342449618, 0.77853342449618, 0.77853342449618, 0.21637381025458835, 0.21637381025458835, 0.21637381025458835, 0.16185299579960843, 0.16185299579960843, 0.16185299579960843, 0.24395189916379179, 0.24395189916379179, 0.24395189916379179, 0.2769739598055947, 0.2769739598055947, 0.2769739598055947, 0.20286101158811987, 0.20286101158811987, 0.20286101158811987, 0.17393431312418361, 0.17393431312418361, 0.17393431312418361, 0.22921632683736692, 0.22921632683736692, 0.22921632683736692, 0.13226795070886455, 0.13226795070886455, 0.13226795070886455, 0.274071904303391, 0.274071904303391, 0.274071904303391, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11918024870323263, 0.11918024870323263, 0.11918024870323263, 0.06671824803003512, 0.06671824803003512, 0.06671824803003512, 0.06482569501645608, 0.06482569501645608, 0.06482569501645608, 0.052473859315492866, 0.052473859315492866, 0.052473859315492866, 0.08004542064097475, 0.08004542064097475, 0.08004542064097475, 0.10512449463764173, 0.10512449463764173, 0.10512449463764173, 0.011119638982627689, 0.011119638982627689, 0.011119638982627689, 0.061966201959795075, 0.061966201959795075, 0.061966201959795075, 0.04893189382951624, 0.04893189382951624, 0.04893189382951624, 0.5781987188693725, 0.5781987188693725, 0.5781987188693725, 0.6508998859330049, 0.6508998859330049, 0.6508998859330049, 0.569636737007192, 0.569636737007192, 0.569636737007192, 0.11440802117869531, 0.11440802117869531, 0.11440802117869531, 0.09201570281466598, 0.09201570281466598, 0.09201570281466598, 0.10725387152877064, 0.10725387152877064, 0.10725387152877064, 0.2275002587121795, 0.2275002587121795, 0.2275002587121795, 0.1751072239695901, 0.1751072239695901, 0.1751072239695901, 0.16922284584479097, 0.16922284584479097, 0.16922284584479097, 0.3264504255101549, 0.3264504255101549, 0.3264504255101549, 0.5178731297220514, 0.5178731297220514, 0.5178731297220514, 0.4448713567603487, 0.4448713567603487, 0.4448713567603487, 0.1853246070597494, 0.1853246070597494, 0.1853246070597494, 0.19598639461793554, 0.19598639461793554, 0.19598639461793554, 0.22002080811987845, 0.22002080811987845, 0.22002080811987845, 0.2077074128032843, 0.2077074128032843, 0.2077074128032843, 0.2253409878404875, 0.2253409878404875, 0.2253409878404875, 0.2082439198823065, 0.2082439198823065, 0.2082439198823065, 0.20696265409669967, 0.20696265409669967, 0.20696265409669967, 0.1889606269124704, 0.1889606269124704, 0.1889606269124704, 0.8419477741922863, 0.8419477741922863, 0.8419477741922863, 0.9311518162435701, 0.9311518162435701, 0.9311518162435701, 0.1591130559732803, 0.1591130559732803, 0.1591130559732803, 0.1860386451268019, 0.1860386451268019, 0.1860386451268019, 0.1686313320383075, 0.1686313320383075, 0.1686313320383075, 0.2093296564098851, 0.2093296564098851, 0.2093296564098851, 0.15639261217971612, 0.15639261217971612, 0.15639261217971612, 0.18406700427846767, 0.18406700427846767, 0.18406700427846767, 0.19521571744102706, 0.19521571744102706, 0.19521571744102706, 0.18773134898977695, 0.18773134898977695, 0.18773134898977695, 0.09348631738393853, 0.09348631738393853, 0.09348631738393853, 0.11725697477432118, 0.11725697477432118, 0.11725697477432118, 0.10123936703566638, 0.10123936703566638, 0.10123936703566638]}, "mutation_prompt": null}
{"id": "e87ef52a-a0b7-4563-942c-24e710b8f3eb", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Conditional Inertia Weight Decay\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9  # Decay if a valid best solution is found\n            \n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Dynamic DE scaling factor\n            self.F = 0.8 + 0.2 * (1 - eval_count / self.budget)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n                adaptive_scaling = 1.0 - (eval_count / self.budget) * 0.1\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling * adaptive_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Adjust the DE mutation scaling factor to dynamically increase exploration at early stages.", "configspace": "", "generation": 92, "fitness": 0.32145962650492993, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.30.", "error": "", "parent_id": "8ba3d5ef-1263-4f5f-b488-8d7077e0b278", "metadata": {"aucs": [0.9023883556220258, 0.9023883556220258, 0.9023883556220258, 0.9078260842579366, 0.9078260842579366, 0.9078260842579366, 0.9107870172298895, 0.9107870172298895, 0.9107870172298895, 0.7924869017493928, 0.7924869017493928, 0.7924869017493928, 0.7722042712408305, 0.7722042712408305, 0.7722042712408305, 0.7970495072616028, 0.7970495072616028, 0.7970495072616028, 0.1798795833997785, 0.1798795833997785, 0.1798795833997785, 0.10437400900895266, 0.10437400900895266, 0.10437400900895266, 0.18138446346551962, 0.18138446346551962, 0.18138446346551962, 0.10641097785126208, 0.10641097785126208, 0.10641097785126208, 0.09487775063437787, 0.09487775063437787, 0.09487775063437787, 0.1426352070914454, 0.1426352070914454, 0.1426352070914454, 0.9799237628486781, 0.9799237628486781, 0.9799237628486781, 0.9855775449658846, 0.9855775449658846, 0.9855775449658846, 0.9829407723360936, 0.9829407723360936, 0.9829407723360936, 0.732255440683931, 0.732255440683931, 0.732255440683931, 0.7623827659615631, 0.7623827659615631, 0.7623827659615631, 0.7536485984712067, 0.7536485984712067, 0.7536485984712067, 0.21223150002376856, 0.21223150002376856, 0.21223150002376856, 0.1561780973447212, 0.1561780973447212, 0.1561780973447212, 0.8353581292564787, 0.8353581292564787, 0.8353581292564787, 0.22003919760902302, 0.22003919760902302, 0.22003919760902302, 0.1340382534355813, 0.1340382534355813, 0.1340382534355813, 0.2374891503486357, 0.2374891503486357, 0.2374891503486357, 0.021865111299761653, 0.021865111299761653, 0.021865111299761653, 0.21985473961893964, 0.21985473961893964, 0.21985473961893964, 0.2612208193615956, 0.2612208193615956, 0.2612208193615956, 0.0941519424778533, 0.0941519424778533, 0.0941519424778533, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09504128850758642, 0.09504128850758642, 0.09504128850758642, 0.10885645213469908, 0.10885645213469908, 0.10885645213469908, 0.03228142775041998, 0.03228142775041998, 0.03228142775041998, 0.051931834905854735, 0.051931834905854735, 0.051931834905854735, 0.09454678639266223, 0.09454678639266223, 0.09454678639266223, 0.0738655787377962, 0.0738655787377962, 0.0738655787377962, 0.28004457603156263, 0.28004457603156263, 0.28004457603156263, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11276573384123223, 0.11276573384123223, 0.11276573384123223, 0.5910558025750923, 0.5910558025750923, 0.5910558025750923, 0.544919039624145, 0.544919039624145, 0.544919039624145, 0.610524432268941, 0.610524432268941, 0.610524432268941, 0.05813566872429532, 0.05813566872429532, 0.05813566872429532, 0.11558682686462085, 0.11558682686462085, 0.11558682686462085, 0.13170788209290984, 0.13170788209290984, 0.13170788209290984, 0.14723500243686027, 0.14723500243686027, 0.14723500243686027, 0.16318726690284024, 0.16318726690284024, 0.16318726690284024, 0.21179709839698813, 0.21179709839698813, 0.21179709839698813, 0.40622715775879903, 0.40622715775879903, 0.40622715775879903, 0.23066615936611157, 0.23066615936611157, 0.23066615936611157, 0.3423023976763193, 0.3423023976763193, 0.3423023976763193, 0.25095606651137436, 0.25095606651137436, 0.25095606651137436, 0.17029559138744976, 0.17029559138744976, 0.17029559138744976, 0.19184717345839386, 0.19184717345839386, 0.19184717345839386, 0.21905352446537207, 0.21905352446537207, 0.21905352446537207, 0.22702196515264172, 0.22702196515264172, 0.22702196515264172, 0.23132663067929227, 0.23132663067929227, 0.23132663067929227, 0.8329930445461876, 0.8329930445461876, 0.8329930445461876, 0.18841014701513836, 0.18841014701513836, 0.18841014701513836, 0.25107743502539126, 0.25107743502539126, 0.25107743502539126, 0.9206124185445924, 0.9206124185445924, 0.9206124185445924, 0.1651030551035132, 0.1651030551035132, 0.1651030551035132, 0.1853126636627359, 0.1853126636627359, 0.1853126636627359, 0.1617232154536805, 0.1617232154536805, 0.1617232154536805, 0.20978620653782376, 0.20978620653782376, 0.20978620653782376, 0.156361599184751, 0.156361599184751, 0.156361599184751, 0.18954273996880888, 0.18954273996880888, 0.18954273996880888, 0.23067838764844228, 0.23067838764844228, 0.23067838764844228, 0.1861808305296868, 0.1861808305296868, 0.1861808305296868, 0.10516400421712846, 0.10516400421712846, 0.10516400421712846, 0.09200530415473807, 0.09200530415473807, 0.09200530415473807, 0.09520273726134842, 0.09520273726134842, 0.09520273726134842]}, "mutation_prompt": null}
{"id": "80e6da2b-2d0f-486a-9b03-4a6fa9cf22a4", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Conditional Inertia Weight Decay\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9  # Decay if a valid best solution is found\n            \n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Adaptive DE scaling factor based on fitness improvement\n            if eval_count > 0 and previous_global_value - best_global_value > 1e-5:\n                self.F = min(1.0, self.F * 1.05)\n            else:\n                self.F = max(0.7, self.F * 0.95)\n            previous_global_value = best_global_value\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n                adaptive_scaling = 1.0 - (eval_count / self.budget) * 0.1\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling * adaptive_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce adaptive mutation scaling for DE based on fitness improvements.", "configspace": "", "generation": 93, "fitness": 0.31463747477608, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.30.", "error": "", "parent_id": "e87ef52a-a0b7-4563-942c-24e710b8f3eb", "metadata": {"aucs": [0.9159889602676913, 0.9159889602676913, 0.9159889602676913, 0.908327545788617, 0.908327545788617, 0.908327545788617, 0.911338317691073, 0.911338317691073, 0.911338317691073, 0.04247056032371854, 0.04247056032371854, 0.04247056032371854, 0.7456442948312285, 0.7456442948312285, 0.7456442948312285, 0.7932843993404975, 0.7932843993404975, 0.7932843993404975, 0.14333752674601852, 0.14333752674601852, 0.14333752674601852, 0.1536832659809354, 0.1536832659809354, 0.1536832659809354, 0.18843964366829447, 0.18843964366829447, 0.18843964366829447, 0.07634206157811418, 0.07634206157811418, 0.07634206157811418, 0.09135245682872906, 0.09135245682872906, 0.09135245682872906, 0.12185826326285765, 0.12185826326285765, 0.12185826326285765, 0.9822380817666947, 0.9822380817666947, 0.9822380817666947, 0.987736782286267, 0.987736782286267, 0.987736782286267, 0.9823202008526661, 0.9823202008526661, 0.9823202008526661, 0.7412629497857417, 0.7412629497857417, 0.7412629497857417, 0.7385748214979592, 0.7385748214979592, 0.7385748214979592, 0.7591544002736204, 0.7591544002736204, 0.7591544002736204, 0.8855713321977183, 0.8855713321977183, 0.8855713321977183, 0.16175853419506514, 0.16175853419506514, 0.16175853419506514, 0.23518277537632326, 0.23518277537632326, 0.23518277537632326, 0.2601529742730019, 0.2601529742730019, 0.2601529742730019, 0.21764778033239918, 0.21764778033239918, 0.21764778033239918, 0.20405372801686894, 0.20405372801686894, 0.20405372801686894, 0.23190917890066076, 0.23190917890066076, 0.23190917890066076, 0.2561419905222184, 0.2561419905222184, 0.2561419905222184, 0.23191238537123382, 0.23191238537123382, 0.23191238537123382, 0.0014584245389378525, 0.0014584245389378525, 0.0014584245389378525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08894561743119178, 0.08894561743119178, 0.08894561743119178, 0.03954534276725408, 0.03954534276725408, 0.03954534276725408, 0.06269289098547248, 0.06269289098547248, 0.06269289098547248, 0.05119565729548925, 0.05119565729548925, 0.05119565729548925, 0.0799086252370107, 0.0799086252370107, 0.0799086252370107, 0.11158348995597156, 0.11158348995597156, 0.11158348995597156, 0.011228250571711174, 0.011228250571711174, 0.011228250571711174, 0.09343516867303314, 0.09343516867303314, 0.09343516867303314, 0.04899557234419627, 0.04899557234419627, 0.04899557234419627, 0.5707219777204146, 0.5707219777204146, 0.5707219777204146, 0.5672835108958674, 0.5672835108958674, 0.5672835108958674, 0.5927820588832153, 0.5927820588832153, 0.5927820588832153, 0.11393140833913618, 0.11393140833913618, 0.11393140833913618, 0.12253344074898209, 0.12253344074898209, 0.12253344074898209, 0.10827049058296967, 0.10827049058296967, 0.10827049058296967, 0.22408721916249108, 0.22408721916249108, 0.22408721916249108, 0.20337588846296784, 0.20337588846296784, 0.20337588846296784, 0.2638028061737341, 0.2638028061737341, 0.2638028061737341, 0.2815631199365206, 0.2815631199365206, 0.2815631199365206, 0.25200055937914256, 0.25200055937914256, 0.25200055937914256, 0.3699694057700421, 0.3699694057700421, 0.3699694057700421, 0.38409115614310263, 0.38409115614310263, 0.38409115614310263, 0.2068500485568796, 0.2068500485568796, 0.2068500485568796, 0.15527406303442126, 0.15527406303442126, 0.15527406303442126, 0.2255800597515436, 0.2255800597515436, 0.2255800597515436, 0.27596331217905645, 0.27596331217905645, 0.27596331217905645, 0.26600660489153005, 0.26600660489153005, 0.26600660489153005, 0.21141172919733953, 0.21141172919733953, 0.21141172919733953, 0.8194986346892801, 0.8194986346892801, 0.8194986346892801, 0.19735249226228757, 0.19735249226228757, 0.19735249226228757, 0.9340007420612345, 0.9340007420612345, 0.9340007420612345, 0.15895295018068467, 0.15895295018068467, 0.15895295018068467, 0.186025309786935, 0.186025309786935, 0.186025309786935, 0.168523723889762, 0.168523723889762, 0.168523723889762, 0.20873663126579, 0.20873663126579, 0.20873663126579, 0.15646627770823018, 0.15646627770823018, 0.15646627770823018, 0.193287610480668, 0.193287610480668, 0.193287610480668, 0.1861650811951585, 0.1861650811951585, 0.1861650811951585, 0.20521941547129463, 0.20521941547129463, 0.20521941547129463, 0.09431814423424933, 0.09431814423424933, 0.09431814423424933, 0.10012757630540658, 0.10012757630540658, 0.10012757630540658, 0.09285048278094343, 0.09285048278094343, 0.09285048278094343]}, "mutation_prompt": null}
{"id": "c49397b2-e2f9-448b-962b-963b355572e1", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Conditional Inertia Weight Decay\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9  # Decay if a valid best solution is found\n            \n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Dynamic DE scaling factor\n            self.F = 0.8 + 0.2 * (1 - eval_count / self.budget)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n                adaptive_scaling = 1.0 - (eval_count / self.budget) * 0.1\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling * adaptive_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Adjust the DE mutation scaling factor to dynamically increase exploration at early stages.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e87ef52a-a0b7-4563-942c-24e710b8f3eb", "metadata": {"aucs": [0.9023883556220258, 0.9023883556220258, 0.9023883556220258, 0.9078260842579366, 0.9078260842579366, 0.9078260842579366, 0.9107870172298895, 0.9107870172298895, 0.9107870172298895, 0.7924869017493928, 0.7924869017493928, 0.7924869017493928, 0.7722042712408305, 0.7722042712408305, 0.7722042712408305, 0.7970495072616028, 0.7970495072616028, 0.7970495072616028, 0.1798795833997785, 0.1798795833997785, 0.1798795833997785, 0.10437400900895266, 0.10437400900895266, 0.10437400900895266, 0.18138446346551962, 0.18138446346551962, 0.18138446346551962, 0.10641097785126208, 0.10641097785126208, 0.10641097785126208, 0.09487775063437787, 0.09487775063437787, 0.09487775063437787, 0.1426352070914454, 0.1426352070914454, 0.1426352070914454, 0.9799237628486781, 0.9799237628486781, 0.9799237628486781, 0.9855775449658846, 0.9855775449658846, 0.9855775449658846, 0.9829407723360936, 0.9829407723360936, 0.9829407723360936, 0.732255440683931, 0.732255440683931, 0.732255440683931, 0.7623827659615631, 0.7623827659615631, 0.7623827659615631, 0.7536485984712067, 0.7536485984712067, 0.7536485984712067, 0.21223150002376856, 0.21223150002376856, 0.21223150002376856, 0.1561780973447212, 0.1561780973447212, 0.1561780973447212, 0.8353581292564787, 0.8353581292564787, 0.8353581292564787, 0.22003919760902302, 0.22003919760902302, 0.22003919760902302, 0.1340382534355813, 0.1340382534355813, 0.1340382534355813, 0.2374891503486357, 0.2374891503486357, 0.2374891503486357, 0.021865111299761653, 0.021865111299761653, 0.021865111299761653, 0.21985473961893964, 0.21985473961893964, 0.21985473961893964, 0.2612208193615956, 0.2612208193615956, 0.2612208193615956, 0.0941519424778533, 0.0941519424778533, 0.0941519424778533, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09504128850758642, 0.09504128850758642, 0.09504128850758642, 0.10885645213469908, 0.10885645213469908, 0.10885645213469908, 0.03228142775041998, 0.03228142775041998, 0.03228142775041998, 0.051931834905854735, 0.051931834905854735, 0.051931834905854735, 0.09454678639266223, 0.09454678639266223, 0.09454678639266223, 0.0738655787377962, 0.0738655787377962, 0.0738655787377962, 0.28004457603156263, 0.28004457603156263, 0.28004457603156263, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11276573384123223, 0.11276573384123223, 0.11276573384123223, 0.5910558025750923, 0.5910558025750923, 0.5910558025750923, 0.544919039624145, 0.544919039624145, 0.544919039624145, 0.610524432268941, 0.610524432268941, 0.610524432268941, 0.05813566872429532, 0.05813566872429532, 0.05813566872429532, 0.11558682686462085, 0.11558682686462085, 0.11558682686462085, 0.13170788209290984, 0.13170788209290984, 0.13170788209290984, 0.14723500243686027, 0.14723500243686027, 0.14723500243686027, 0.16318726690284024, 0.16318726690284024, 0.16318726690284024, 0.21179709839698813, 0.21179709839698813, 0.21179709839698813, 0.40622715775879903, 0.40622715775879903, 0.40622715775879903, 0.23066615936611157, 0.23066615936611157, 0.23066615936611157, 0.3423023976763193, 0.3423023976763193, 0.3423023976763193, 0.25095606651137436, 0.25095606651137436, 0.25095606651137436, 0.17029559138744976, 0.17029559138744976, 0.17029559138744976, 0.19184717345839386, 0.19184717345839386, 0.19184717345839386, 0.21905352446537207, 0.21905352446537207, 0.21905352446537207, 0.22702196515264172, 0.22702196515264172, 0.22702196515264172, 0.23132663067929227, 0.23132663067929227, 0.23132663067929227, 0.8329930445461876, 0.8329930445461876, 0.8329930445461876, 0.18841014701513836, 0.18841014701513836, 0.18841014701513836, 0.25107743502539126, 0.25107743502539126, 0.25107743502539126, 0.9206124185445924, 0.9206124185445924, 0.9206124185445924, 0.1651030551035132, 0.1651030551035132, 0.1651030551035132, 0.1853126636627359, 0.1853126636627359, 0.1853126636627359, 0.1617232154536805, 0.1617232154536805, 0.1617232154536805, 0.20978620653782376, 0.20978620653782376, 0.20978620653782376, 0.156361599184751, 0.156361599184751, 0.156361599184751, 0.18954273996880888, 0.18954273996880888, 0.18954273996880888, 0.23067838764844228, 0.23067838764844228, 0.23067838764844228, 0.1861808305296868, 0.1861808305296868, 0.1861808305296868, 0.10516400421712846, 0.10516400421712846, 0.10516400421712846, 0.09200530415473807, 0.09200530415473807, 0.09200530415473807, 0.09520273726134842, 0.09520273726134842, 0.09520273726134842]}, "mutation_prompt": null}
{"id": "2ab5089c-9a4c-44fc-943a-c017c58ae161", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Conditional Inertia Weight Decay\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9  # Decay if a valid best solution is found\n            \n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Dynamic DE scaling factor\n            self.F = 0.8 + 0.2 * (1 - eval_count / self.budget)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n                adaptive_scaling = 1.0 - (eval_count / self.budget) * 0.1\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling * adaptive_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Adjust the DE mutation scaling factor to dynamically increase exploration at early stages.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e87ef52a-a0b7-4563-942c-24e710b8f3eb", "metadata": {"aucs": [0.9023883556220258, 0.9023883556220258, 0.9023883556220258, 0.9078260842579366, 0.9078260842579366, 0.9078260842579366, 0.9107870172298895, 0.9107870172298895, 0.9107870172298895, 0.7924869017493928, 0.7924869017493928, 0.7924869017493928, 0.7722042712408305, 0.7722042712408305, 0.7722042712408305, 0.7970495072616028, 0.7970495072616028, 0.7970495072616028, 0.1798795833997785, 0.1798795833997785, 0.1798795833997785, 0.10437400900895266, 0.10437400900895266, 0.10437400900895266, 0.18138446346551962, 0.18138446346551962, 0.18138446346551962, 0.10641097785126208, 0.10641097785126208, 0.10641097785126208, 0.09487775063437787, 0.09487775063437787, 0.09487775063437787, 0.1426352070914454, 0.1426352070914454, 0.1426352070914454, 0.9799237628486781, 0.9799237628486781, 0.9799237628486781, 0.9855775449658846, 0.9855775449658846, 0.9855775449658846, 0.9829407723360936, 0.9829407723360936, 0.9829407723360936, 0.732255440683931, 0.732255440683931, 0.732255440683931, 0.7623827659615631, 0.7623827659615631, 0.7623827659615631, 0.7536485984712067, 0.7536485984712067, 0.7536485984712067, 0.21223150002376856, 0.21223150002376856, 0.21223150002376856, 0.1561780973447212, 0.1561780973447212, 0.1561780973447212, 0.8353581292564787, 0.8353581292564787, 0.8353581292564787, 0.22003919760902302, 0.22003919760902302, 0.22003919760902302, 0.1340382534355813, 0.1340382534355813, 0.1340382534355813, 0.2374891503486357, 0.2374891503486357, 0.2374891503486357, 0.021865111299761653, 0.021865111299761653, 0.021865111299761653, 0.21985473961893964, 0.21985473961893964, 0.21985473961893964, 0.2612208193615956, 0.2612208193615956, 0.2612208193615956, 0.0941519424778533, 0.0941519424778533, 0.0941519424778533, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09504128850758642, 0.09504128850758642, 0.09504128850758642, 0.10885645213469908, 0.10885645213469908, 0.10885645213469908, 0.03228142775041998, 0.03228142775041998, 0.03228142775041998, 0.051931834905854735, 0.051931834905854735, 0.051931834905854735, 0.09454678639266223, 0.09454678639266223, 0.09454678639266223, 0.0738655787377962, 0.0738655787377962, 0.0738655787377962, 0.28004457603156263, 0.28004457603156263, 0.28004457603156263, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11276573384123223, 0.11276573384123223, 0.11276573384123223, 0.5910558025750923, 0.5910558025750923, 0.5910558025750923, 0.544919039624145, 0.544919039624145, 0.544919039624145, 0.610524432268941, 0.610524432268941, 0.610524432268941, 0.05813566872429532, 0.05813566872429532, 0.05813566872429532, 0.11558682686462085, 0.11558682686462085, 0.11558682686462085, 0.13170788209290984, 0.13170788209290984, 0.13170788209290984, 0.14723500243686027, 0.14723500243686027, 0.14723500243686027, 0.16318726690284024, 0.16318726690284024, 0.16318726690284024, 0.21179709839698813, 0.21179709839698813, 0.21179709839698813, 0.40622715775879903, 0.40622715775879903, 0.40622715775879903, 0.23066615936611157, 0.23066615936611157, 0.23066615936611157, 0.3423023976763193, 0.3423023976763193, 0.3423023976763193, 0.25095606651137436, 0.25095606651137436, 0.25095606651137436, 0.17029559138744976, 0.17029559138744976, 0.17029559138744976, 0.19184717345839386, 0.19184717345839386, 0.19184717345839386, 0.21905352446537207, 0.21905352446537207, 0.21905352446537207, 0.22702196515264172, 0.22702196515264172, 0.22702196515264172, 0.23132663067929227, 0.23132663067929227, 0.23132663067929227, 0.8329930445461876, 0.8329930445461876, 0.8329930445461876, 0.18841014701513836, 0.18841014701513836, 0.18841014701513836, 0.25107743502539126, 0.25107743502539126, 0.25107743502539126, 0.9206124185445924, 0.9206124185445924, 0.9206124185445924, 0.1651030551035132, 0.1651030551035132, 0.1651030551035132, 0.1853126636627359, 0.1853126636627359, 0.1853126636627359, 0.1617232154536805, 0.1617232154536805, 0.1617232154536805, 0.20978620653782376, 0.20978620653782376, 0.20978620653782376, 0.156361599184751, 0.156361599184751, 0.156361599184751, 0.18954273996880888, 0.18954273996880888, 0.18954273996880888, 0.23067838764844228, 0.23067838764844228, 0.23067838764844228, 0.1861808305296868, 0.1861808305296868, 0.1861808305296868, 0.10516400421712846, 0.10516400421712846, 0.10516400421712846, 0.09200530415473807, 0.09200530415473807, 0.09200530415473807, 0.09520273726134842, 0.09520273726134842, 0.09520273726134842]}, "mutation_prompt": null}
{"id": "6958b9f1-c734-47fd-a6b4-ea4b54c31a73", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Conditional Inertia Weight Decay\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9  # Decay if a valid best solution is found\n            \n            # Dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * eval_count / self.budget\n\n            # Dynamic DE scaling factor\n            self.F = 0.8 + 0.2 * (1 - eval_count / self.budget)\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n                adaptive_scaling = 1.0 - (eval_count / self.budget) * 0.1\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling * adaptive_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Adjust the DE mutation scaling factor to dynamically increase exploration at early stages.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e87ef52a-a0b7-4563-942c-24e710b8f3eb", "metadata": {"aucs": [0.9023883556220258, 0.9023883556220258, 0.9023883556220258, 0.9078260842579366, 0.9078260842579366, 0.9078260842579366, 0.9107870172298895, 0.9107870172298895, 0.9107870172298895, 0.7924869017493928, 0.7924869017493928, 0.7924869017493928, 0.7722042712408305, 0.7722042712408305, 0.7722042712408305, 0.7970495072616028, 0.7970495072616028, 0.7970495072616028, 0.1798795833997785, 0.1798795833997785, 0.1798795833997785, 0.10437400900895266, 0.10437400900895266, 0.10437400900895266, 0.18138446346551962, 0.18138446346551962, 0.18138446346551962, 0.10641097785126208, 0.10641097785126208, 0.10641097785126208, 0.09487775063437787, 0.09487775063437787, 0.09487775063437787, 0.1426352070914454, 0.1426352070914454, 0.1426352070914454, 0.9799237628486781, 0.9799237628486781, 0.9799237628486781, 0.9855775449658846, 0.9855775449658846, 0.9855775449658846, 0.9829407723360936, 0.9829407723360936, 0.9829407723360936, 0.732255440683931, 0.732255440683931, 0.732255440683931, 0.7623827659615631, 0.7623827659615631, 0.7623827659615631, 0.7536485984712067, 0.7536485984712067, 0.7536485984712067, 0.21223150002376856, 0.21223150002376856, 0.21223150002376856, 0.1561780973447212, 0.1561780973447212, 0.1561780973447212, 0.8353581292564787, 0.8353581292564787, 0.8353581292564787, 0.22003919760902302, 0.22003919760902302, 0.22003919760902302, 0.1340382534355813, 0.1340382534355813, 0.1340382534355813, 0.2374891503486357, 0.2374891503486357, 0.2374891503486357, 0.021865111299761653, 0.021865111299761653, 0.021865111299761653, 0.21985473961893964, 0.21985473961893964, 0.21985473961893964, 0.2612208193615956, 0.2612208193615956, 0.2612208193615956, 0.0941519424778533, 0.0941519424778533, 0.0941519424778533, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09504128850758642, 0.09504128850758642, 0.09504128850758642, 0.10885645213469908, 0.10885645213469908, 0.10885645213469908, 0.03228142775041998, 0.03228142775041998, 0.03228142775041998, 0.051931834905854735, 0.051931834905854735, 0.051931834905854735, 0.09454678639266223, 0.09454678639266223, 0.09454678639266223, 0.0738655787377962, 0.0738655787377962, 0.0738655787377962, 0.28004457603156263, 0.28004457603156263, 0.28004457603156263, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11276573384123223, 0.11276573384123223, 0.11276573384123223, 0.5910558025750923, 0.5910558025750923, 0.5910558025750923, 0.544919039624145, 0.544919039624145, 0.544919039624145, 0.610524432268941, 0.610524432268941, 0.610524432268941, 0.05813566872429532, 0.05813566872429532, 0.05813566872429532, 0.11558682686462085, 0.11558682686462085, 0.11558682686462085, 0.13170788209290984, 0.13170788209290984, 0.13170788209290984, 0.14723500243686027, 0.14723500243686027, 0.14723500243686027, 0.16318726690284024, 0.16318726690284024, 0.16318726690284024, 0.21179709839698813, 0.21179709839698813, 0.21179709839698813, 0.40622715775879903, 0.40622715775879903, 0.40622715775879903, 0.23066615936611157, 0.23066615936611157, 0.23066615936611157, 0.3423023976763193, 0.3423023976763193, 0.3423023976763193, 0.25095606651137436, 0.25095606651137436, 0.25095606651137436, 0.17029559138744976, 0.17029559138744976, 0.17029559138744976, 0.19184717345839386, 0.19184717345839386, 0.19184717345839386, 0.21905352446537207, 0.21905352446537207, 0.21905352446537207, 0.22702196515264172, 0.22702196515264172, 0.22702196515264172, 0.23132663067929227, 0.23132663067929227, 0.23132663067929227, 0.8329930445461876, 0.8329930445461876, 0.8329930445461876, 0.18841014701513836, 0.18841014701513836, 0.18841014701513836, 0.25107743502539126, 0.25107743502539126, 0.25107743502539126, 0.9206124185445924, 0.9206124185445924, 0.9206124185445924, 0.1651030551035132, 0.1651030551035132, 0.1651030551035132, 0.1853126636627359, 0.1853126636627359, 0.1853126636627359, 0.1617232154536805, 0.1617232154536805, 0.1617232154536805, 0.20978620653782376, 0.20978620653782376, 0.20978620653782376, 0.156361599184751, 0.156361599184751, 0.156361599184751, 0.18954273996880888, 0.18954273996880888, 0.18954273996880888, 0.23067838764844228, 0.23067838764844228, 0.23067838764844228, 0.1861808305296868, 0.1861808305296868, 0.1861808305296868, 0.10516400421712846, 0.10516400421712846, 0.10516400421712846, 0.09200530415473807, 0.09200530415473807, 0.09200530415473807, 0.09520273726134842, 0.09520273726134842, 0.09520273726134842]}, "mutation_prompt": null}
{"id": "aafe1172-acea-4e07-adeb-0b1744ad94ba", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Conditional Inertia Weight Decay\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9  # Decay if a valid best solution is found\n            \n            # Non-linear dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * np.sin(np.pi / 2 * eval_count / self.budget)\n\n            # Non-linear dynamic DE scaling factor\n            self.F = 0.8 + 0.2 * (np.cos(np.pi / 2 * eval_count / self.budget))\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n                adaptive_scaling = 1.0 - (eval_count / self.budget) * 0.1\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling * adaptive_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a non-linear adaptive scaling for DE parameters to enhance exploration and exploitation balance.", "configspace": "", "generation": 97, "fitness": 0.3245849461973415, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.30.", "error": "", "parent_id": "e87ef52a-a0b7-4563-942c-24e710b8f3eb", "metadata": {"aucs": [0.9023511212739135, 0.9023511212739135, 0.9023511212739135, 0.9077778542557506, 0.9077778542557506, 0.9077778542557506, 0.9133084661930723, 0.9133084661930723, 0.9133084661930723, 0.7806600059135074, 0.7806600059135074, 0.7806600059135074, 0.8085570498044476, 0.8085570498044476, 0.8085570498044476, 0.7976575071209958, 0.7976575071209958, 0.7976575071209958, 0.7694441199431052, 0.7694441199431052, 0.7694441199431052, 0.12687395559087877, 0.12687395559087877, 0.12687395559087877, 0.14075923062437778, 0.14075923062437778, 0.14075923062437778, 0.10490254440668523, 0.10490254440668523, 0.10490254440668523, 0.0932931859338676, 0.0932931859338676, 0.0932931859338676, 0.15714519450977438, 0.15714519450977438, 0.15714519450977438, 0.9799313424332372, 0.9799313424332372, 0.9799313424332372, 0.9855782372336378, 0.9855782372336378, 0.9855782372336378, 0.9829404308137876, 0.9829404308137876, 0.9829404308137876, 0.7850961144565085, 0.7850961144565085, 0.7850961144565085, 0.7131723457868566, 0.7131723457868566, 0.7131723457868566, 0.7480724087442108, 0.7480724087442108, 0.7480724087442108, 0.2213788146663772, 0.2213788146663772, 0.2213788146663772, 0.15642962701490837, 0.15642962701490837, 0.15642962701490837, 0.21317899142521068, 0.21317899142521068, 0.21317899142521068, 0.22424845047729536, 0.22424845047729536, 0.22424845047729536, 0.13381136540980565, 0.13381136540980565, 0.13381136540980565, 0.23669014504973773, 0.23669014504973773, 0.23669014504973773, 0.021889858978447196, 0.021889858978447196, 0.021889858978447196, 0.22382515062006036, 0.22382515062006036, 0.22382515062006036, 0.24814573917737848, 0.24814573917737848, 0.24814573917737848, 0.0020776777154385417, 0.0020776777154385417, 0.0020776777154385417, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08239798580433622, 0.08239798580433622, 0.08239798580433622, 0.10803888022066788, 0.10803888022066788, 0.10803888022066788, 0.08674400184678599, 0.08674400184678599, 0.08674400184678599, 0.0517781487063006, 0.0517781487063006, 0.0517781487063006, 0.09551076235026446, 0.09551076235026446, 0.09551076235026446, 0.07441532305420773, 0.07441532305420773, 0.07441532305420773, 0.22238193499837577, 0.22238193499837577, 0.22238193499837577, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09600683941570987, 0.09600683941570987, 0.09600683941570987, 0.6360561491710051, 0.6360561491710051, 0.6360561491710051, 0.5712416291378724, 0.5712416291378724, 0.5712416291378724, 0.6793823093887732, 0.6793823093887732, 0.6793823093887732, 0.08883246471270723, 0.08883246471270723, 0.08883246471270723, 0.1508613275143773, 0.1508613275143773, 0.1508613275143773, 0.7852705088097649, 0.7852705088097649, 0.7852705088097649, 0.1151690914722463, 0.1151690914722463, 0.1151690914722463, 0.24606868926976333, 0.24606868926976333, 0.24606868926976333, 0.18886481168614866, 0.18886481168614866, 0.18886481168614866, 0.317271195611205, 0.317271195611205, 0.317271195611205, 0.2871357110222619, 0.2871357110222619, 0.2871357110222619, 0.4310614926372165, 0.4310614926372165, 0.4310614926372165, 0.2392223382739328, 0.2392223382739328, 0.2392223382739328, 0.1954864816000349, 0.1954864816000349, 0.1954864816000349, 0.18902734961100665, 0.18902734961100665, 0.18902734961100665, 0.29475896528795287, 0.29475896528795287, 0.29475896528795287, 0.24809302534483046, 0.24809302534483046, 0.24809302534483046, 0.22210399372341227, 0.22210399372341227, 0.22210399372341227, 0.20917264965746085, 0.20917264965746085, 0.20917264965746085, 0.19559047990869072, 0.19559047990869072, 0.19559047990869072, 0.22838761528738982, 0.22838761528738982, 0.22838761528738982, 0.9221517011721767, 0.9221517011721767, 0.9221517011721767, 0.1650779611237405, 0.1650779611237405, 0.1650779611237405, 0.18537316401063864, 0.18537316401063864, 0.18537316401063864, 0.16172250354545137, 0.16172250354545137, 0.16172250354545137, 0.2096837731236495, 0.2096837731236495, 0.2096837731236495, 0.15635967132876682, 0.15635967132876682, 0.15635967132876682, 0.18719983186069733, 0.18719983186069733, 0.18719983186069733, 0.1970102267127073, 0.1970102267127073, 0.1970102267127073, 0.19055127588208398, 0.19055127588208398, 0.19055127588208398, 0.09674424346847721, 0.09674424346847721, 0.09674424346847721, 0.0838599115672094, 0.0838599115672094, 0.0838599115672094, 0.09855277131501838, 0.09855277131501838, 0.09855277131501838]}, "mutation_prompt": null}
{"id": "56c9c75b-e034-4508-8026-3bfe9b74235f", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.6  # Cognitive component (increased from 1.5 to 1.6)\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Conditional Inertia Weight Decay\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9  # Decay if a valid best solution is found\n            \n            # Non-linear dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * np.sin(np.pi / 2 * eval_count / self.budget)\n\n            # Non-linear dynamic DE scaling factor\n            self.F = 0.8 + 0.2 * (np.cos(np.pi / 2 * eval_count / self.budget))\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n                adaptive_scaling = 1.0 - (eval_count / self.budget) * 0.1\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling * adaptive_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Slightly increase the cognitive component to enhance individual learning capabilities for faster convergence.", "configspace": "", "generation": 98, "fitness": 0.2824432955646089, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.28.", "error": "", "parent_id": "aafe1172-acea-4e07-adeb-0b1744ad94ba", "metadata": {"aucs": [0.9001272147149293, 0.9001272147149293, 0.9001272147149293, 0.9031600924979266, 0.9031600924979266, 0.9031600924979266, 0.9052370114737592, 0.9052370114737592, 0.9052370114737592, 0.7456555870554002, 0.7456555870554002, 0.7456555870554002, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.7940522622129285, 0.7940522622129285, 0.7940522622129285, 0.15785315699332492, 0.15785315699332492, 0.15785315699332492, 0.10929227391104901, 0.10929227391104901, 0.10929227391104901, 0.15972489714865024, 0.15972489714865024, 0.15972489714865024, 0.09161685433255606, 0.09161685433255606, 0.09161685433255606, 0.10575255694099794, 0.10575255694099794, 0.10575255694099794, 0.1088619141574354, 0.1088619141574354, 0.1088619141574354, 0.9783492154009037, 0.9783492154009037, 0.9783492154009037, 0.9856180737041395, 0.9856180737041395, 0.9856180737041395, 0.982944075289468, 0.982944075289468, 0.982944075289468, 0.7335943008477677, 0.7335943008477677, 0.7335943008477677, 0.7348782786302271, 0.7348782786302271, 0.7348782786302271, 0.7049959139342223, 0.7049959139342223, 0.7049959139342223, 0.22149042657793316, 0.22149042657793316, 0.22149042657793316, 0.1614945631339717, 0.1614945631339717, 0.1614945631339717, 0.15037932683031507, 0.15037932683031507, 0.15037932683031507, 0.28867211760076383, 0.28867211760076383, 0.28867211760076383, 0.13565400562357388, 0.13565400562357388, 0.13565400562357388, 0.2168058171189845, 0.2168058171189845, 0.2168058171189845, 0.016639156768879393, 0.016639156768879393, 0.016639156768879393, 0.12068487048107668, 0.12068487048107668, 0.12068487048107668, 0.2432865940573038, 0.2432865940573038, 0.2432865940573038, 0.032729249811953576, 0.032729249811953576, 0.032729249811953576, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.034798807130735465, 0.034798807130735465, 0.034798807130735465, 0.051103910009731024, 0.051103910009731024, 0.051103910009731024, 0.056022492292831516, 0.056022492292831516, 0.056022492292831516, 0.051638890847997776, 0.051638890847997776, 0.051638890847997776, 0.10124849693458615, 0.10124849693458615, 0.10124849693458615, 0.10014105947057528, 0.10014105947057528, 0.10014105947057528, 0.19324614733702683, 0.19324614733702683, 0.19324614733702683, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08259887196662896, 0.08259887196662896, 0.08259887196662896, 0.5875023562101842, 0.5875023562101842, 0.5875023562101842, 0.5857892594339156, 0.5857892594339156, 0.5857892594339156, 0.6018252517207419, 0.6018252517207419, 0.6018252517207419, 0.06952760302762506, 0.06952760302762506, 0.06952760302762506, 0.11753113341005939, 0.11753113341005939, 0.11753113341005939, 0.13838860925899277, 0.13838860925899277, 0.13838860925899277, 0.15122191121018713, 0.15122191121018713, 0.15122191121018713, 0.19606441204371927, 0.19606441204371927, 0.19606441204371927, 0.16934457414157078, 0.16934457414157078, 0.16934457414157078, 0.20414628783149713, 0.20414628783149713, 0.20414628783149713, 0.20108392700392685, 0.20108392700392685, 0.20108392700392685, 0.38925331518388817, 0.38925331518388817, 0.38925331518388817, 0.3382397083654658, 0.3382397083654658, 0.3382397083654658, 0.17789157743054929, 0.17789157743054929, 0.17789157743054929, 0.17228730527527492, 0.17228730527527492, 0.17228730527527492, 0.24343858899554982, 0.24343858899554982, 0.24343858899554982, 0.20040801611449766, 0.20040801611449766, 0.20040801611449766, 0.1974965539650353, 0.1974965539650353, 0.1974965539650353, 0.19323295789286143, 0.19323295789286143, 0.19323295789286143, 0.18537391086313926, 0.18537391086313926, 0.18537391086313926, 0.223097610093981, 0.223097610093981, 0.223097610093981, 0.8982267364691583, 0.8982267364691583, 0.8982267364691583, 0.1652196124489843, 0.1652196124489843, 0.1652196124489843, 0.1869616645920522, 0.1869616645920522, 0.1869616645920522, 0.16182776094871476, 0.16182776094871476, 0.16182776094871476, 0.20960844143869606, 0.20960844143869606, 0.20960844143869606, 0.15633325340577398, 0.15633325340577398, 0.15633325340577398, 0.19318852519546348, 0.19318852519546348, 0.19318852519546348, 0.19429907193369544, 0.19429907193369544, 0.19429907193369544, 0.1818452729909018, 0.1818452729909018, 0.1818452729909018, 0.08945938376291995, 0.08945938376291995, 0.08945938376291995, 0.09681856832844715, 0.09681856832844715, 0.09681856832844715, 0.0982356364238145, 0.0982356364238145, 0.0982356364238145]}, "mutation_prompt": null}
{"id": "c8f32c71-24e6-46d4-8849-65440e4dcfcb", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget // 10)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR_initial = 0.9  # Initial DE crossover probability\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = pop.copy()\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        eval_count = 0\n        best_global_value = np.inf\n        best_global_position = None\n\n        while eval_count < self.budget:\n            # Conditional Inertia Weight Decay\n            self.w = 0.4 + (0.7 - 0.4) * (1 - eval_count / self.budget)\n            if best_global_value < np.inf:\n                self.w *= 0.9  # Decay if a valid best solution is found\n            \n            # Non-linear dynamic crossover probability\n            self.CR = self.CR_initial - 0.4 * np.sin(np.pi / 2 * eval_count / self.budget)\n\n            # Non-linear dynamic DE scaling factor\n            self.F = 0.8 + 0.2 * (np.cos(np.pi / 2 * eval_count / self.budget))\n\n            # Evaluate the population\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                current_value = func(pop[i])\n                eval_count += 1\n\n                # Update personal best\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best[i] = pop[i].copy()\n\n                # Update global best\n                if current_value < best_global_value:\n                    best_global_value = current_value\n                    best_global_position = pop[i].copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Perform DE mutation and crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                r1, r2, r3 = indices\n                while r1 == i or r2 == i or r3 == i:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    r1, r2, r3 = indices\n\n                mutant = pop[r1] + self.F * (pop[r2] - pop[r3])\n                mutant = np.clip(mutant, lower, upper)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, pop[i])\n\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_values[i] = trial_value\n                    personal_best[i] = trial.copy()\n\n                if trial_value < best_global_value:\n                    best_global_value = trial_value\n                    best_global_position = trial.copy()\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocity_scaling = 0.5 + 0.5 * eval_count / self.budget\n                adaptive_scaling = 1.0 - (eval_count / self.budget) * 0.1\n\n                velocities[i] = (self.w * velocities[i] * velocity_scaling * adaptive_scaling +\n                                 self.c1 * r1 * (personal_best[i] - pop[i]) +\n                                 self.c2 * r2 * (best_global_position - pop[i]))\n\n                pop[i] = pop[i] + velocities[i]\n                pop[i] = np.clip(pop[i], lower, upper)\n\n        return best_global_position, best_global_value", "name": "HybridDEPSO", "description": "Introduce a non-linear adaptive scaling for DE parameters to enhance exploration and exploitation balance.", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "aafe1172-acea-4e07-adeb-0b1744ad94ba", "metadata": {"aucs": [0.9023511212739135, 0.9023511212739135, 0.9023511212739135, 0.9077778542557506, 0.9077778542557506, 0.9077778542557506, 0.9133084661930723, 0.9133084661930723, 0.9133084661930723, 0.7806600059135074, 0.7806600059135074, 0.7806600059135074, 0.8085570498044476, 0.8085570498044476, 0.8085570498044476, 0.7976575071209958, 0.7976575071209958, 0.7976575071209958, 0.7694441199431052, 0.7694441199431052, 0.7694441199431052, 0.12687395559087877, 0.12687395559087877, 0.12687395559087877, 0.14075923062437778, 0.14075923062437778, 0.14075923062437778, 0.10490254440668523, 0.10490254440668523, 0.10490254440668523, 0.0932931859338676, 0.0932931859338676, 0.0932931859338676, 0.15714519450977438, 0.15714519450977438, 0.15714519450977438, 0.9799313424332372, 0.9799313424332372, 0.9799313424332372, 0.9855782372336378, 0.9855782372336378, 0.9855782372336378, 0.9829404308137876, 0.9829404308137876, 0.9829404308137876, 0.7850961144565085, 0.7850961144565085, 0.7850961144565085, 0.7131723457868566, 0.7131723457868566, 0.7131723457868566, 0.7480724087442108, 0.7480724087442108, 0.7480724087442108, 0.2213788146663772, 0.2213788146663772, 0.2213788146663772, 0.15642962701490837, 0.15642962701490837, 0.15642962701490837, 0.21317899142521068, 0.21317899142521068, 0.21317899142521068, 0.22424845047729536, 0.22424845047729536, 0.22424845047729536, 0.13381136540980565, 0.13381136540980565, 0.13381136540980565, 0.23669014504973773, 0.23669014504973773, 0.23669014504973773, 0.021889858978447196, 0.021889858978447196, 0.021889858978447196, 0.22382515062006036, 0.22382515062006036, 0.22382515062006036, 0.24814573917737848, 0.24814573917737848, 0.24814573917737848, 0.0020776777154385417, 0.0020776777154385417, 0.0020776777154385417, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08239798580433622, 0.08239798580433622, 0.08239798580433622, 0.10803888022066788, 0.10803888022066788, 0.10803888022066788, 0.08674400184678599, 0.08674400184678599, 0.08674400184678599, 0.0517781487063006, 0.0517781487063006, 0.0517781487063006, 0.09551076235026446, 0.09551076235026446, 0.09551076235026446, 0.07441532305420773, 0.07441532305420773, 0.07441532305420773, 0.22238193499837577, 0.22238193499837577, 0.22238193499837577, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09600683941570987, 0.09600683941570987, 0.09600683941570987, 0.6360561491710051, 0.6360561491710051, 0.6360561491710051, 0.5712416291378724, 0.5712416291378724, 0.5712416291378724, 0.6793823093887732, 0.6793823093887732, 0.6793823093887732, 0.08883246471270723, 0.08883246471270723, 0.08883246471270723, 0.1508613275143773, 0.1508613275143773, 0.1508613275143773, 0.7852705088097649, 0.7852705088097649, 0.7852705088097649, 0.1151690914722463, 0.1151690914722463, 0.1151690914722463, 0.24606868926976333, 0.24606868926976333, 0.24606868926976333, 0.18886481168614866, 0.18886481168614866, 0.18886481168614866, 0.317271195611205, 0.317271195611205, 0.317271195611205, 0.2871357110222619, 0.2871357110222619, 0.2871357110222619, 0.4310614926372165, 0.4310614926372165, 0.4310614926372165, 0.2392223382739328, 0.2392223382739328, 0.2392223382739328, 0.1954864816000349, 0.1954864816000349, 0.1954864816000349, 0.18902734961100665, 0.18902734961100665, 0.18902734961100665, 0.29475896528795287, 0.29475896528795287, 0.29475896528795287, 0.24809302534483046, 0.24809302534483046, 0.24809302534483046, 0.22210399372341227, 0.22210399372341227, 0.22210399372341227, 0.20917264965746085, 0.20917264965746085, 0.20917264965746085, 0.19559047990869072, 0.19559047990869072, 0.19559047990869072, 0.22838761528738982, 0.22838761528738982, 0.22838761528738982, 0.9221517011721767, 0.9221517011721767, 0.9221517011721767, 0.1650779611237405, 0.1650779611237405, 0.1650779611237405, 0.18537316401063864, 0.18537316401063864, 0.18537316401063864, 0.16172250354545137, 0.16172250354545137, 0.16172250354545137, 0.2096837731236495, 0.2096837731236495, 0.2096837731236495, 0.15635967132876682, 0.15635967132876682, 0.15635967132876682, 0.18719983186069733, 0.18719983186069733, 0.18719983186069733, 0.1970102267127073, 0.1970102267127073, 0.1970102267127073, 0.19055127588208398, 0.19055127588208398, 0.19055127588208398, 0.09674424346847721, 0.09674424346847721, 0.09674424346847721, 0.0838599115672094, 0.0838599115672094, 0.0838599115672094, 0.09855277131501838, 0.09855277131501838, 0.09855277131501838]}, "mutation_prompt": null}
