{"id": "07581666-d0b9-4299-b5d4-33bd0ed7b60d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(100, 10 * dim)\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return population[idxs[0]] + self.F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        return trial if func(trial) < func(target) else target\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                trial = self.crossover(population[i], mutant)\n                trial = np.clip(trial, *self.bounds)\n\n                # Selection\n                new_candidate = self.select(trial, population[i], func)\n                new_fitness = func(new_candidate)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "The algorithm combines Differential Evolution with Adaptive Crossover and Mutation Strategies to balance exploration and exploitation dynamically based on population diversity metrics.", "configspace": "", "generation": 0, "fitness": 0.14930203867138772, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.17.", "error": "", "parent_id": null, "metadata": {"aucs": [0.28819309809975613, 0.26613509438823335, 0.26301725839072077, 0.31625606881264834, 0.3446781156297012, 0.3317826335279682, 0.324905244666001, 0.31236598299433516, 0.2990762089398008, 0.05895126247458515, 0.06261968292427988, 0.04473979681520557, 0.04569587180843282, 0.0509353780420444, 0.06305009107205295, 0.07434705479545667, 0.08800900878986051, 0.058945535445696806, 0.05256208767373027, 0.0637815295989852, 0.07037586871706858, 0.07967502559360395, 0.0834927150694702, 0.07538041570791953, 0.07317921251697512, 0.06424280168019814, 0.07703721742578751, 0.0500610654442567, 0.05333537968076252, 0.07601438838804897, 0.054521765217671936, 0.05400728293113699, 0.04879045198132048, 0.052807919462327324, 0.04556106023636641, 0.05821414028916261, 0.9514107900049169, 0.7491718704189494, 0.9119598807205229, 0.8818714556942526, 0.7583821427902239, 0.8213579386038194, 0.9219357160765171, 0.8813658291668167, 0.9164082830495394, 0.11560148201032738, 0.124956086370421, 0.1218400464211361, 0.13015667534949316, 0.1269524803523041, 0.13802282804234278, 0.14297580320677605, 0.1289000481494682, 0.14664027399075097, 0.17965320712364197, 0.17828562238027512, 0.1568025734258508, 0.20246483587326713, 0.18947314208816013, 0.17791881187585912, 0.17151223645388547, 0.18162028771429795, 0.1682396808511898, 0.07143191308715591, 0.042477096342733556, 0.077587491952116, 0.07287728646560188, 0.06538576101841265, 0.0632293319530971, 0.07019863522129488, 0.05351217096826222, 0.04422299221030224, 0.10460332978478182, 0.07880021041076601, 0.08227054364424236, 0.04964611077737169, 0.05018467855313902, 0.06346970865328527, 0.029224162344693494, 0.04496328976187447, 0.060024571116644276, 0.0018586038009148487, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011892407571895136, 9.999999999998899e-05, 0.0003448443464109108, 0.0001255050071115038, 0.006274413511114463, 0.07888114707147775, 0.09319948473755102, 0.08728562577070931, 0.09011374156945984, 0.05139366997003614, 0.0480871955162564, 0.10173440507587017, 0.1100025344177773, 0.1055585266618635, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014406244645651656, 0.043809179869407355, 0.046346504926810694, 0.04007222862057025, 0.04205523564509572, 0.03869122731827679, 0.05207132464299902, 0.04233472850065356, 0.05078444607462884, 0.05497860118206277, 0.2595198523181619, 0.2781302764211936, 0.2723345732041704, 0.2988185505277825, 0.2757416069862535, 0.28537185220582506, 0.2579902451968905, 0.2681040794259433, 0.29181792582393706, 0.06601584299926366, 0.06687995442901717, 0.07720449494162929, 0.056059660184898386, 0.05178669905514688, 0.07057250077338117, 0.06484174957148825, 0.05651359952819579, 0.06683556286798453, 0.15349201035087334, 0.14839823367749871, 0.14404709860756593, 0.1617703386022824, 0.11069043296088732, 0.11912699751008371, 0.11827639672004153, 0.11210151827426673, 0.13213936426104644, 0.1984320870406524, 0.17154939630499144, 0.1912714539057614, 0.16574625087789574, 0.16802267763848744, 0.18916114083982838, 0.18979224736025246, 0.20497918148498961, 0.18720448562541914, 0.14834038271087557, 0.11665933504070514, 0.12946268836707298, 0.12253364720453597, 0.13024305744268116, 0.12211232598001875, 0.12958755218379503, 0.14058017753642438, 0.14343098163408086, 0.17668824652372628, 0.14481747438477977, 0.16771453020185423, 0.15931694053148637, 0.16822476250504892, 0.169774410398158, 0.179712217453053, 0.15029583677126923, 0.16463035728701814, 0.1399295611231577, 0.15256711013975, 0.14260131217125271, 0.14824232798066272, 0.15596626724358742, 0.14754581343942152, 0.14747078340805186, 0.15422515967783623, 0.15723392490026722, 0.14387817981253048, 0.20236970289092537, 0.26407455098761934, 0.15625866552574008, 0.15747417776728923, 0.16261049400246252, 0.12327359486773881, 0.17214580972913995, 0.145449633935537, 0.13233078034069534, 0.15330370205717514, 0.13060343413178976, 0.15820338263840006, 0.1441387204759711, 0.13305594948923205, 0.1790065317944407, 0.19481676168231332, 0.1934525407069756, 0.16994674396046827, 0.17054756063366416, 0.19953252234312036, 0.16333028613262812, 0.16013801067905076, 0.1748222713113401, 0.17101119035929346, 0.18845090946070442, 0.1660737651010642, 0.046860779464446556, 0.05530429236357881, 0.04863164743054316, 0.061301605645225576, 0.05268397435769989, 0.053947769633690634, 0.06441852990848207, 0.04991467427601237, 0.04866361721703838]}, "mutation_prompt": null}
{"id": "0a0e94f9-ffe5-4a4a-a55a-d54d357753e8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(100, 10 * dim)\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return population[idxs[0]] + self.F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        return trial if func(trial) < func(target) else target\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                trial = self.crossover(population[i], mutant)\n                trial = np.clip(trial, *self.bounds)\n\n                # Selection\n                new_candidate = self.select(trial, population[i], func)\n                new_fitness = func(new_candidate)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "The algorithm combines Differential Evolution with Adaptive Crossover and Mutation Strategies to balance exploration and exploitation dynamically based on population diversity metrics.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "07581666-d0b9-4299-b5d4-33bd0ed7b60d", "metadata": {"aucs": [0.28819309809975613, 0.26613509438823335, 0.26301725839072077, 0.31625606881264834, 0.3446781156297012, 0.3317826335279682, 0.324905244666001, 0.31236598299433516, 0.2990762089398008, 0.05895126247458515, 0.06261968292427988, 0.04473979681520557, 0.04569587180843282, 0.0509353780420444, 0.06305009107205295, 0.07434705479545667, 0.08800900878986051, 0.058945535445696806, 0.05256208767373027, 0.0637815295989852, 0.07037586871706858, 0.07967502559360395, 0.0834927150694702, 0.07538041570791953, 0.07317921251697512, 0.06424280168019814, 0.07703721742578751, 0.0500610654442567, 0.05333537968076252, 0.07601438838804897, 0.054521765217671936, 0.05400728293113699, 0.04879045198132048, 0.052807919462327324, 0.04556106023636641, 0.05821414028916261, 0.9514107900049169, 0.7491718704189494, 0.9119598807205229, 0.8818714556942526, 0.7583821427902239, 0.8213579386038194, 0.9219357160765171, 0.8813658291668167, 0.9164082830495394, 0.11560148201032738, 0.124956086370421, 0.1218400464211361, 0.13015667534949316, 0.1269524803523041, 0.13802282804234278, 0.14297580320677605, 0.1289000481494682, 0.14664027399075097, 0.17965320712364197, 0.17828562238027512, 0.1568025734258508, 0.20246483587326713, 0.18947314208816013, 0.17791881187585912, 0.17151223645388547, 0.18162028771429795, 0.1682396808511898, 0.07143191308715591, 0.042477096342733556, 0.077587491952116, 0.07287728646560188, 0.06538576101841265, 0.0632293319530971, 0.07019863522129488, 0.05351217096826222, 0.04422299221030224, 0.10460332978478182, 0.07880021041076601, 0.08227054364424236, 0.04964611077737169, 0.05018467855313902, 0.06346970865328527, 0.029224162344693494, 0.04496328976187447, 0.060024571116644276, 0.0018586038009148487, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011892407571895136, 9.999999999998899e-05, 0.0003448443464109108, 0.0001255050071115038, 0.006274413511114463, 0.07888114707147775, 0.09319948473755102, 0.08728562577070931, 0.09011374156945984, 0.05139366997003614, 0.0480871955162564, 0.10173440507587017, 0.1100025344177773, 0.1055585266618635, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014406244645651656, 0.043809179869407355, 0.046346504926810694, 0.04007222862057025, 0.04205523564509572, 0.03869122731827679, 0.05207132464299902, 0.04233472850065356, 0.05078444607462884, 0.05497860118206277, 0.2595198523181619, 0.2781302764211936, 0.2723345732041704, 0.2988185505277825, 0.2757416069862535, 0.28537185220582506, 0.2579902451968905, 0.2681040794259433, 0.29181792582393706, 0.06601584299926366, 0.06687995442901717, 0.07720449494162929, 0.056059660184898386, 0.05178669905514688, 0.07057250077338117, 0.06484174957148825, 0.05651359952819579, 0.06683556286798453, 0.15349201035087334, 0.14839823367749871, 0.14404709860756593, 0.1617703386022824, 0.11069043296088732, 0.11912699751008371, 0.11827639672004153, 0.11210151827426673, 0.13213936426104644, 0.1984320870406524, 0.17154939630499144, 0.1912714539057614, 0.16574625087789574, 0.16802267763848744, 0.18916114083982838, 0.18979224736025246, 0.20497918148498961, 0.18720448562541914, 0.14834038271087557, 0.11665933504070514, 0.12946268836707298, 0.12253364720453597, 0.13024305744268116, 0.12211232598001875, 0.12958755218379503, 0.14058017753642438, 0.14343098163408086, 0.17668824652372628, 0.14481747438477977, 0.16771453020185423, 0.15931694053148637, 0.16822476250504892, 0.169774410398158, 0.179712217453053, 0.15029583677126923, 0.16463035728701814, 0.1399295611231577, 0.15256711013975, 0.14260131217125271, 0.14824232798066272, 0.15596626724358742, 0.14754581343942152, 0.14747078340805186, 0.15422515967783623, 0.15723392490026722, 0.14387817981253048, 0.20236970289092537, 0.26407455098761934, 0.15625866552574008, 0.15747417776728923, 0.16261049400246252, 0.12327359486773881, 0.17214580972913995, 0.145449633935537, 0.13233078034069534, 0.15330370205717514, 0.13060343413178976, 0.15820338263840006, 0.1441387204759711, 0.13305594948923205, 0.1790065317944407, 0.19481676168231332, 0.1934525407069756, 0.16994674396046827, 0.17054756063366416, 0.19953252234312036, 0.16333028613262812, 0.16013801067905076, 0.1748222713113401, 0.17101119035929346, 0.18845090946070442, 0.1660737651010642, 0.046860779464446556, 0.05530429236357881, 0.04863164743054316, 0.061301605645225576, 0.05268397435769989, 0.053947769633690634, 0.06441852990848207, 0.04991467427601237, 0.04866361721703838]}, "mutation_prompt": null}
{"id": "78d36485-0915-48e0-af8f-b91755435616", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # New: Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return population[idxs[0]] + self.F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        return trial if func(trial) < func(target) else target\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)  # New: Dynamic population size adjustment\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                trial = self.crossover(population[i], mutant)\n                trial = np.clip(trial, *self.bounds)\n\n                # Selection\n                new_candidate = self.select(trial, population[i], func)\n                new_fitness = func(new_candidate)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "The algorithm now integrates a dynamic population size adjustment based on the convergence rate to enhance exploration and exploitation balance.", "configspace": "", "generation": 2, "fitness": 0.14937149099955108, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.17.", "error": "", "parent_id": "07581666-d0b9-4299-b5d4-33bd0ed7b60d", "metadata": {"aucs": [0.28819309809975613, 0.26613509438823335, 0.26303771452767355, 0.3110323089335779, 0.33808761379176033, 0.3521551727304547, 0.3313167839817289, 0.31236598299433516, 0.2990762089398008, 0.05895126247458515, 0.06261968292427988, 0.04473979681520557, 0.04569587180843282, 0.0509353780420444, 0.06305009107205295, 0.07434705479545667, 0.08800900878986051, 0.058945535445696806, 0.05256208767373027, 0.0637815295989852, 0.07037586871706858, 0.07967502559360395, 0.0834927150694702, 0.07538041570791953, 0.07317921251697512, 0.06424280168019814, 0.07703721742578751, 0.0500610654442567, 0.05333537968076252, 0.07601438838804897, 0.054521765217671936, 0.05400728293113699, 0.04879045198132048, 0.052807919462327324, 0.04556106023636641, 0.05821414028916261, 0.9514107900049169, 0.7491718704189494, 0.9119598807205229, 0.8818714556942526, 0.7583821427902239, 0.8213579386038194, 0.9219357160765171, 0.8813658291668167, 0.9164082830495394, 0.11560148201032738, 0.124956086370421, 0.1218400464211361, 0.13015667534949316, 0.1269524803523041, 0.13802282804234278, 0.14297580320677605, 0.1289000481494682, 0.14664027399075097, 0.17965320712364197, 0.17828562238027512, 0.1568025734258508, 0.20246483587326713, 0.18947314208816013, 0.17791881187585912, 0.17151223645388547, 0.18162028771429795, 0.1682396808511898, 0.07143191308715591, 0.042477096342733556, 0.077587491952116, 0.07287728646560188, 0.06538576101841265, 0.0632293319530971, 0.07019863522129488, 0.05351217096826222, 0.04422299221030224, 0.10460332978478182, 0.07880021041076601, 0.08227054364424236, 0.04964611077737169, 0.05018467855313902, 0.06346970865328527, 0.029224162344693494, 0.04496328976187447, 0.060024571116644276, 0.0018586038009148487, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011892407571895136, 9.999999999998899e-05, 0.0003448443464109108, 0.0001255050071115038, 0.006274413511114463, 0.07888114707147775, 0.09319948473755102, 0.08728562577070931, 0.09011374156945984, 0.05139366997003614, 0.0480871955162564, 0.10173440507587017, 0.1100025344177773, 0.1055585266618635, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014406244645651656, 0.043809179869407355, 0.046346504926810694, 0.04007222862057025, 0.04205523564509572, 0.03869122731827679, 0.05207132464299902, 0.04233472850065356, 0.05078444607462884, 0.05497860118206277, 0.2595198523181619, 0.2781302764211936, 0.2723345732041704, 0.2988185505277825, 0.2757416069862535, 0.28537185220582506, 0.2579902451968905, 0.2681040794259433, 0.29181792582393706, 0.06601584299926366, 0.06687995442901717, 0.07720449494162929, 0.056059660184898386, 0.05178669905514688, 0.07057250077338117, 0.06484174957148825, 0.05651359952819579, 0.06683556286798453, 0.15349201035087334, 0.14839823367749871, 0.14404709860756593, 0.1617703386022824, 0.11069043296088732, 0.11912699751008371, 0.11827639672004153, 0.11210151827426673, 0.13213936426104644, 0.1984320870406524, 0.17154939630499144, 0.1912714539057614, 0.16574625087789574, 0.16802267763848744, 0.18916114083982838, 0.18979224736025246, 0.20497918148498961, 0.18720448562541914, 0.14834038271087557, 0.11665933504070514, 0.12946268836707298, 0.12253364720453597, 0.13024305744268116, 0.12211232598001875, 0.12958755218379503, 0.14058017753642438, 0.14343098163408086, 0.17668824652372628, 0.14481747438477977, 0.16771453020185423, 0.15931694053148637, 0.16822476250504892, 0.169774410398158, 0.179712217453053, 0.15029583677126923, 0.16463035728701814, 0.1399295611231577, 0.15256711013975, 0.14260131217125271, 0.14824232798066272, 0.15596626724358742, 0.14754581343942152, 0.14747078340805186, 0.15422515967783623, 0.15723392490026722, 0.14387817981253048, 0.20236970289092537, 0.26407455098761934, 0.15625866552574008, 0.15747417776728923, 0.16261049400246252, 0.12327359486773881, 0.17214580972913995, 0.145449633935537, 0.13233078034069534, 0.15330370205717514, 0.13060343413178976, 0.15820338263840006, 0.1441387204759711, 0.13305594948923205, 0.17901234895101392, 0.19481676168231332, 0.1934581534955293, 0.16994674396046827, 0.17054756063366416, 0.19953252234312036, 0.16333028613262812, 0.16013801067905076, 0.1748222713113401, 0.17101119035929346, 0.18845090946070442, 0.1660737651010642, 0.046860779464446556, 0.05530429236357881, 0.04863164743054316, 0.061301605645225576, 0.05268397435769989, 0.053947769633690634, 0.06441852990848207, 0.04991467427601237, 0.04866361721703838]}, "mutation_prompt": null}
{"id": "4f6a46a2-4005-4560-a3e4-5c2e91db8b79", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))  # New: Distance-based scaling\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        return trial if func(trial) < func(target) else target\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                trial = self.crossover(population[i], mutant)\n                trial = np.clip(trial, *self.bounds)\n\n                # Selection\n                new_candidate = self.select(trial, population[i], func)\n                new_fitness = func(new_candidate)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Integrate a distance-based scaling of the differential weight to adaptively control exploration and exploitation.", "configspace": "", "generation": 3, "fitness": 0.16939488596592991, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.14.", "error": "", "parent_id": "78d36485-0915-48e0-af8f-b91755435616", "metadata": {"aucs": [0.29406698365321904, 0.29669344626155103, 0.27358126014664286, 0.34373146015222367, 0.32203336829332596, 0.2814282423380843, 0.30716868739350933, 0.3043376151965178, 0.3046777782943908, 0.028613436772474077, 0.1716153665483906, 0.12370970988216123, 0.17477377786216275, 0.11754567634755253, 0.13828254439246734, 0.15772879063850653, 0.07953983777777707, 0.14059033380421315, 0.16414009212932956, 0.1271027984608778, 0.13222195967184158, 0.10912761419106387, 0.10048475701695114, 0.1428356633878045, 0.1320013822550924, 0.12063434546422591, 0.12542403661135226, 0.11441821955813414, 0.09110109408990408, 0.12611649587577978, 0.11755584463422997, 0.12554135084291107, 0.10935765802473285, 0.11633880045291711, 0.10252736718366517, 0.10620226441352976, 0.9511224492382317, 0.5207239906169958, 0.42428944932319934, 0.5792073029598832, 0.453702166064737, 0.3354315491770934, 0.9052519866224408, 0.885685280524614, 0.8838496790663659, 0.1388287114921366, 0.0575373986525185, 0.10299243462789887, 0.11553457042048831, 0.07917341062606498, 0.14928971698631177, 0.1262574199597506, 0.08452575855659483, 0.20885614307911737, 0.20555762830128033, 0.2371754525715064, 0.2599739568225852, 0.26932130568740054, 0.24222531749469423, 0.28014227088254084, 0.3022347564066318, 0.27621809149147636, 0.28860695088252064, 0.09380240130498296, 0.11354972336612079, 0.10001238759612208, 0.13230156590382047, 0.11207045266508864, 0.10681843734594276, 0.09651495988440206, 0.10871574944850759, 0.09614625938373533, 0.059638073114066215, 0.07474890730420991, 0.1032442816039909, 0.11098682137763138, 0.10711173105879623, 0.06471846386631641, 0.13169431285322697, 0.07671017509246214, 0.09742453966609588, 0.026827409178087014, 0.04854508616280384, 0.0038458609201881266, 9.999999999998899e-05, 0.0421235109609599, 0.0007033423580456999, 0.006961344961844751, 0.05004765721105742, 0.02882540809651002, 0.16094955007164047, 0.13566490223629424, 0.1338285090054937, 0.10746708637912106, 0.09194480897860269, 0.14869878902305722, 0.12745620834474192, 0.13042236012015096, 0.1599027510887967, 0.013541207081843254, 0.006303295073195825, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011750328785089525, 0.015050433132250518, 9.999999999998899e-05, 0.0944536902405454, 0.06060694677892531, 0.10811015032519555, 0.07757622204379133, 0.041027450964476575, 0.15013949713034547, 0.08565887697625951, 0.06119974346030266, 0.04263758361289527, 0.31302011345870784, 0.33645797109192177, 0.2778880259712313, 0.3115468316788955, 0.26794234974338815, 0.26245835139896134, 0.2933043896738764, 0.31797275181159645, 0.28894510690341857, 0.1038976720354321, 0.1084643658477924, 0.07789654515782751, 0.08587358161277803, 0.08787280840967382, 0.0885270373476229, 0.11020875384938533, 0.09356729133197172, 0.10134287760039429, 0.11828037897174692, 0.11444517520095399, 0.13166009294967385, 0.1539379788980284, 0.11439228137864998, 0.12134971618679646, 0.147556603177326, 0.11475896954061737, 0.13741363453007416, 0.2224515319143121, 0.23889285779605873, 0.281118177336668, 0.27921449692841416, 0.23704527552534016, 0.23733030399293398, 0.24399401335460702, 0.26110196072836944, 0.253069866445642, 0.2306400711999156, 0.16868431164557973, 0.1866535905850577, 0.18647557415442295, 0.1699246550431215, 0.19699685208728523, 0.1955686887868614, 0.20163815421164932, 0.2083790914628526, 0.16617352915280448, 0.16412345002491224, 0.14783081470150228, 0.1764817742050112, 0.18246763280855893, 0.17409617896503893, 0.184547541830537, 0.16727544792556492, 0.19102468677641837, 0.19752930717407857, 0.17763909074561057, 0.22673103714388243, 0.17737747506711365, 0.17404429181328473, 0.18424475320519895, 0.19028868755786033, 0.1785034405684428, 0.1791247168632757, 0.15586430373785554, 0.16877726996236653, 0.19209639416822277, 0.2053438061944194, 0.1482411113982569, 0.1574932141833678, 0.15495701816731633, 0.1646530299729937, 0.16862140917021895, 0.15269325357061192, 0.18011248295867732, 0.1614377374592324, 0.14828920887153363, 0.1634905533868628, 0.21159633220734342, 0.18144506429154628, 0.1801157348011413, 0.1892564928564845, 0.18809532551747632, 0.17588820741318645, 0.1749638001391044, 0.1721865821742644, 0.1713648631259893, 0.18590882274012177, 0.1884755675755967, 0.1749177267233032, 0.1736221000164413, 0.06895735042300788, 0.0664236317880268, 0.06312674560364628, 0.07779045590085776, 0.07877981789411093, 0.06998177337051292, 0.06733892415106313, 0.07409816425075133, 0.06718164489539047]}, "mutation_prompt": null}
{"id": "a52f2419-a877-4085-9c1e-d420a524541a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))  # New: Distance-based scaling\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        return trial if func(trial) < func(target) else target\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                trial = self.crossover(population[i], mutant)\n                trial = np.clip(trial, *self.bounds)\n\n                # Selection\n                new_candidate = self.select(trial, population[i], func)\n                new_fitness = func(new_candidate)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Integrate a distance-based scaling of the differential weight to adaptively control exploration and exploitation.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4f6a46a2-4005-4560-a3e4-5c2e91db8b79", "metadata": {"aucs": [0.29406698365321904, 0.29669344626155103, 0.27358126014664286, 0.34373146015222367, 0.32203336829332596, 0.2814282423380843, 0.30716868739350933, 0.3043376151965178, 0.3046777782943908, 0.028613436772474077, 0.1716153665483906, 0.12370970988216123, 0.17477377786216275, 0.11754567634755253, 0.13828254439246734, 0.15772879063850653, 0.07953983777777707, 0.14059033380421315, 0.16414009212932956, 0.1271027984608778, 0.13222195967184158, 0.10912761419106387, 0.10048475701695114, 0.1428356633878045, 0.1320013822550924, 0.12063434546422591, 0.12542403661135226, 0.11441821955813414, 0.09110109408990408, 0.12611649587577978, 0.11755584463422997, 0.12554135084291107, 0.10935765802473285, 0.11633880045291711, 0.10252736718366517, 0.10620226441352976, 0.9511224492382317, 0.5207239906169958, 0.42428944932319934, 0.5792073029598832, 0.453702166064737, 0.3354315491770934, 0.9052519866224408, 0.885685280524614, 0.8838496790663659, 0.1388287114921366, 0.0575373986525185, 0.10299243462789887, 0.11553457042048831, 0.07917341062606498, 0.14928971698631177, 0.1262574199597506, 0.08452575855659483, 0.20885614307911737, 0.20555762830128033, 0.2371754525715064, 0.2599739568225852, 0.26932130568740054, 0.24222531749469423, 0.28014227088254084, 0.3022347564066318, 0.27621809149147636, 0.28860695088252064, 0.09380240130498296, 0.11354972336612079, 0.10001238759612208, 0.13230156590382047, 0.11207045266508864, 0.10681843734594276, 0.09651495988440206, 0.10871574944850759, 0.09614625938373533, 0.059638073114066215, 0.07474890730420991, 0.1032442816039909, 0.11098682137763138, 0.10711173105879623, 0.06471846386631641, 0.13169431285322697, 0.07671017509246214, 0.09742453966609588, 0.026827409178087014, 0.04854508616280384, 0.0038458609201881266, 9.999999999998899e-05, 0.0421235109609599, 0.0007033423580456999, 0.006961344961844751, 0.05004765721105742, 0.02882540809651002, 0.16094955007164047, 0.13566490223629424, 0.1338285090054937, 0.10746708637912106, 0.09194480897860269, 0.14869878902305722, 0.12745620834474192, 0.13042236012015096, 0.1599027510887967, 0.013541207081843254, 0.006303295073195825, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011750328785089525, 0.015050433132250518, 9.999999999998899e-05, 0.0944536902405454, 0.06060694677892531, 0.10811015032519555, 0.07757622204379133, 0.041027450964476575, 0.15013949713034547, 0.08565887697625951, 0.06119974346030266, 0.04263758361289527, 0.31302011345870784, 0.33645797109192177, 0.2778880259712313, 0.3115468316788955, 0.26794234974338815, 0.26245835139896134, 0.2933043896738764, 0.31797275181159645, 0.28894510690341857, 0.1038976720354321, 0.1084643658477924, 0.07789654515782751, 0.08587358161277803, 0.08787280840967382, 0.0885270373476229, 0.11020875384938533, 0.09356729133197172, 0.10134287760039429, 0.11828037897174692, 0.11444517520095399, 0.13166009294967385, 0.1539379788980284, 0.11439228137864998, 0.12134971618679646, 0.147556603177326, 0.11475896954061737, 0.13741363453007416, 0.2224515319143121, 0.23889285779605873, 0.281118177336668, 0.27921449692841416, 0.23704527552534016, 0.23733030399293398, 0.24399401335460702, 0.26110196072836944, 0.253069866445642, 0.2306400711999156, 0.16868431164557973, 0.1866535905850577, 0.18647557415442295, 0.1699246550431215, 0.19699685208728523, 0.1955686887868614, 0.20163815421164932, 0.2083790914628526, 0.16617352915280448, 0.16412345002491224, 0.14783081470150228, 0.1764817742050112, 0.18246763280855893, 0.17409617896503893, 0.184547541830537, 0.16727544792556492, 0.19102468677641837, 0.19752930717407857, 0.17763909074561057, 0.22673103714388243, 0.17737747506711365, 0.17404429181328473, 0.18424475320519895, 0.19028868755786033, 0.1785034405684428, 0.1791247168632757, 0.15586430373785554, 0.16877726996236653, 0.19209639416822277, 0.2053438061944194, 0.1482411113982569, 0.1574932141833678, 0.15495701816731633, 0.1646530299729937, 0.16862140917021895, 0.15269325357061192, 0.18011248295867732, 0.1614377374592324, 0.14828920887153363, 0.1634905533868628, 0.21159633220734342, 0.18144506429154628, 0.1801157348011413, 0.1892564928564845, 0.18809532551747632, 0.17588820741318645, 0.1749638001391044, 0.1721865821742644, 0.1713648631259893, 0.18590882274012177, 0.1884755675755967, 0.1749177267233032, 0.1736221000164413, 0.06895735042300788, 0.0664236317880268, 0.06312674560364628, 0.07779045590085776, 0.07877981789411093, 0.06998177337051292, 0.06733892415106313, 0.07409816425075133, 0.06718164489539047]}, "mutation_prompt": null}
{"id": "c32f5dcd-5157-4ff1-b39b-f5e16d76d354", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))  # New: Distance-based scaling\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        return trial if func(trial) < func(target) else target\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                trial = self.crossover(population[i], mutant)\n                trial = np.clip(trial, *self.bounds)\n\n                # Selection\n                new_candidate = self.select(trial, population[i], func)\n                new_fitness = func(new_candidate)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Integrate a distance-based scaling of the differential weight to adaptively control exploration and exploitation.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4f6a46a2-4005-4560-a3e4-5c2e91db8b79", "metadata": {"aucs": [0.29406698365321904, 0.29669344626155103, 0.27358126014664286, 0.34373146015222367, 0.32203336829332596, 0.2814282423380843, 0.30716868739350933, 0.3043376151965178, 0.3046777782943908, 0.028613436772474077, 0.1716153665483906, 0.12370970988216123, 0.17477377786216275, 0.11754567634755253, 0.13828254439246734, 0.15772879063850653, 0.07953983777777707, 0.14059033380421315, 0.16414009212932956, 0.1271027984608778, 0.13222195967184158, 0.10912761419106387, 0.10048475701695114, 0.1428356633878045, 0.1320013822550924, 0.12063434546422591, 0.12542403661135226, 0.11441821955813414, 0.09110109408990408, 0.12611649587577978, 0.11755584463422997, 0.12554135084291107, 0.10935765802473285, 0.11633880045291711, 0.10252736718366517, 0.10620226441352976, 0.9511224492382317, 0.5207239906169958, 0.42428944932319934, 0.5792073029598832, 0.453702166064737, 0.3354315491770934, 0.9052519866224408, 0.885685280524614, 0.8838496790663659, 0.1388287114921366, 0.0575373986525185, 0.10299243462789887, 0.11553457042048831, 0.07917341062606498, 0.14928971698631177, 0.1262574199597506, 0.08452575855659483, 0.20885614307911737, 0.20555762830128033, 0.2371754525715064, 0.2599739568225852, 0.26932130568740054, 0.24222531749469423, 0.28014227088254084, 0.3022347564066318, 0.27621809149147636, 0.28860695088252064, 0.09380240130498296, 0.11354972336612079, 0.10001238759612208, 0.13230156590382047, 0.11207045266508864, 0.10681843734594276, 0.09651495988440206, 0.10871574944850759, 0.09614625938373533, 0.059638073114066215, 0.07474890730420991, 0.1032442816039909, 0.11098682137763138, 0.10711173105879623, 0.06471846386631641, 0.13169431285322697, 0.07671017509246214, 0.09742453966609588, 0.026827409178087014, 0.04854508616280384, 0.0038458609201881266, 9.999999999998899e-05, 0.0421235109609599, 0.0007033423580456999, 0.006961344961844751, 0.05004765721105742, 0.02882540809651002, 0.16094955007164047, 0.13566490223629424, 0.1338285090054937, 0.10746708637912106, 0.09194480897860269, 0.14869878902305722, 0.12745620834474192, 0.13042236012015096, 0.1599027510887967, 0.013541207081843254, 0.006303295073195825, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011750328785089525, 0.015050433132250518, 9.999999999998899e-05, 0.0944536902405454, 0.06060694677892531, 0.10811015032519555, 0.07757622204379133, 0.041027450964476575, 0.15013949713034547, 0.08565887697625951, 0.06119974346030266, 0.04263758361289527, 0.31302011345870784, 0.33645797109192177, 0.2778880259712313, 0.3115468316788955, 0.26794234974338815, 0.26245835139896134, 0.2933043896738764, 0.31797275181159645, 0.28894510690341857, 0.1038976720354321, 0.1084643658477924, 0.07789654515782751, 0.08587358161277803, 0.08787280840967382, 0.0885270373476229, 0.11020875384938533, 0.09356729133197172, 0.10134287760039429, 0.11828037897174692, 0.11444517520095399, 0.13166009294967385, 0.1539379788980284, 0.11439228137864998, 0.12134971618679646, 0.147556603177326, 0.11475896954061737, 0.13741363453007416, 0.2224515319143121, 0.23889285779605873, 0.281118177336668, 0.27921449692841416, 0.23704527552534016, 0.23733030399293398, 0.24399401335460702, 0.26110196072836944, 0.253069866445642, 0.2306400711999156, 0.16868431164557973, 0.1866535905850577, 0.18647557415442295, 0.1699246550431215, 0.19699685208728523, 0.1955686887868614, 0.20163815421164932, 0.2083790914628526, 0.16617352915280448, 0.16412345002491224, 0.14783081470150228, 0.1764817742050112, 0.18246763280855893, 0.17409617896503893, 0.184547541830537, 0.16727544792556492, 0.19102468677641837, 0.19752930717407857, 0.17763909074561057, 0.22673103714388243, 0.17737747506711365, 0.17404429181328473, 0.18424475320519895, 0.19028868755786033, 0.1785034405684428, 0.1791247168632757, 0.15586430373785554, 0.16877726996236653, 0.19209639416822277, 0.2053438061944194, 0.1482411113982569, 0.1574932141833678, 0.15495701816731633, 0.1646530299729937, 0.16862140917021895, 0.15269325357061192, 0.18011248295867732, 0.1614377374592324, 0.14828920887153363, 0.1634905533868628, 0.21159633220734342, 0.18144506429154628, 0.1801157348011413, 0.1892564928564845, 0.18809532551747632, 0.17588820741318645, 0.1749638001391044, 0.1721865821742644, 0.1713648631259893, 0.18590882274012177, 0.1884755675755967, 0.1749177267233032, 0.1736221000164413, 0.06895735042300788, 0.0664236317880268, 0.06312674560364628, 0.07779045590085776, 0.07877981789411093, 0.06998177337051292, 0.06733892415106313, 0.07409816425075133, 0.06718164489539047]}, "mutation_prompt": null}
{"id": "ceb012b8-0c11-4c56-939b-317511a27f11", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))  # New: Distance-based scaling\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        return trial if func(trial) < func(target) else target\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                trial = self.crossover(population[i], mutant)\n                trial = np.clip(trial, *self.bounds)\n\n                # Selection\n                new_candidate = self.select(trial, population[i], func)\n                new_fitness = func(new_candidate)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Integrate a distance-based scaling of the differential weight to adaptively control exploration and exploitation.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4f6a46a2-4005-4560-a3e4-5c2e91db8b79", "metadata": {"aucs": [0.29406698365321904, 0.29669344626155103, 0.27358126014664286, 0.34373146015222367, 0.32203336829332596, 0.2814282423380843, 0.30716868739350933, 0.3043376151965178, 0.3046777782943908, 0.028613436772474077, 0.1716153665483906, 0.12370970988216123, 0.17477377786216275, 0.11754567634755253, 0.13828254439246734, 0.15772879063850653, 0.07953983777777707, 0.14059033380421315, 0.16414009212932956, 0.1271027984608778, 0.13222195967184158, 0.10912761419106387, 0.10048475701695114, 0.1428356633878045, 0.1320013822550924, 0.12063434546422591, 0.12542403661135226, 0.11441821955813414, 0.09110109408990408, 0.12611649587577978, 0.11755584463422997, 0.12554135084291107, 0.10935765802473285, 0.11633880045291711, 0.10252736718366517, 0.10620226441352976, 0.9511224492382317, 0.5207239906169958, 0.42428944932319934, 0.5792073029598832, 0.453702166064737, 0.3354315491770934, 0.9052519866224408, 0.885685280524614, 0.8838496790663659, 0.1388287114921366, 0.0575373986525185, 0.10299243462789887, 0.11553457042048831, 0.07917341062606498, 0.14928971698631177, 0.1262574199597506, 0.08452575855659483, 0.20885614307911737, 0.20555762830128033, 0.2371754525715064, 0.2599739568225852, 0.26932130568740054, 0.24222531749469423, 0.28014227088254084, 0.3022347564066318, 0.27621809149147636, 0.28860695088252064, 0.09380240130498296, 0.11354972336612079, 0.10001238759612208, 0.13230156590382047, 0.11207045266508864, 0.10681843734594276, 0.09651495988440206, 0.10871574944850759, 0.09614625938373533, 0.059638073114066215, 0.07474890730420991, 0.1032442816039909, 0.11098682137763138, 0.10711173105879623, 0.06471846386631641, 0.13169431285322697, 0.07671017509246214, 0.09742453966609588, 0.026827409178087014, 0.04854508616280384, 0.0038458609201881266, 9.999999999998899e-05, 0.0421235109609599, 0.0007033423580456999, 0.006961344961844751, 0.05004765721105742, 0.02882540809651002, 0.16094955007164047, 0.13566490223629424, 0.1338285090054937, 0.10746708637912106, 0.09194480897860269, 0.14869878902305722, 0.12745620834474192, 0.13042236012015096, 0.1599027510887967, 0.013541207081843254, 0.006303295073195825, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011750328785089525, 0.015050433132250518, 9.999999999998899e-05, 0.0944536902405454, 0.06060694677892531, 0.10811015032519555, 0.07757622204379133, 0.041027450964476575, 0.15013949713034547, 0.08565887697625951, 0.06119974346030266, 0.04263758361289527, 0.31302011345870784, 0.33645797109192177, 0.2778880259712313, 0.3115468316788955, 0.26794234974338815, 0.26245835139896134, 0.2933043896738764, 0.31797275181159645, 0.28894510690341857, 0.1038976720354321, 0.1084643658477924, 0.07789654515782751, 0.08587358161277803, 0.08787280840967382, 0.0885270373476229, 0.11020875384938533, 0.09356729133197172, 0.10134287760039429, 0.11828037897174692, 0.11444517520095399, 0.13166009294967385, 0.1539379788980284, 0.11439228137864998, 0.12134971618679646, 0.147556603177326, 0.11475896954061737, 0.13741363453007416, 0.2224515319143121, 0.23889285779605873, 0.281118177336668, 0.27921449692841416, 0.23704527552534016, 0.23733030399293398, 0.24399401335460702, 0.26110196072836944, 0.253069866445642, 0.2306400711999156, 0.16868431164557973, 0.1866535905850577, 0.18647557415442295, 0.1699246550431215, 0.19699685208728523, 0.1955686887868614, 0.20163815421164932, 0.2083790914628526, 0.16617352915280448, 0.16412345002491224, 0.14783081470150228, 0.1764817742050112, 0.18246763280855893, 0.17409617896503893, 0.184547541830537, 0.16727544792556492, 0.19102468677641837, 0.19752930717407857, 0.17763909074561057, 0.22673103714388243, 0.17737747506711365, 0.17404429181328473, 0.18424475320519895, 0.19028868755786033, 0.1785034405684428, 0.1791247168632757, 0.15586430373785554, 0.16877726996236653, 0.19209639416822277, 0.2053438061944194, 0.1482411113982569, 0.1574932141833678, 0.15495701816731633, 0.1646530299729937, 0.16862140917021895, 0.15269325357061192, 0.18011248295867732, 0.1614377374592324, 0.14828920887153363, 0.1634905533868628, 0.21159633220734342, 0.18144506429154628, 0.1801157348011413, 0.1892564928564845, 0.18809532551747632, 0.17588820741318645, 0.1749638001391044, 0.1721865821742644, 0.1713648631259893, 0.18590882274012177, 0.1884755675755967, 0.1749177267233032, 0.1736221000164413, 0.06895735042300788, 0.0664236317880268, 0.06312674560364628, 0.07779045590085776, 0.07877981789411093, 0.06998177337051292, 0.06733892415106313, 0.07409816425075133, 0.06718164489539047]}, "mutation_prompt": null}
{"id": "3ad98cab-4d05-4851-853c-0dfc6c5dbff5", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))  # New: Distance-based scaling\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        return trial if func(trial) < func(target) else target\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                trial = self.crossover(population[i], mutant)\n                trial = np.clip(trial, *self.bounds)\n\n                # Selection\n                new_candidate = self.select(trial, population[i], func)\n                new_fitness = func(new_candidate)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Integrate a distance-based scaling of the differential weight to adaptively control exploration and exploitation.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4f6a46a2-4005-4560-a3e4-5c2e91db8b79", "metadata": {"aucs": [0.29406698365321904, 0.29669344626155103, 0.27358126014664286, 0.34373146015222367, 0.32203336829332596, 0.2814282423380843, 0.30716868739350933, 0.3043376151965178, 0.3046777782943908, 0.028613436772474077, 0.1716153665483906, 0.12370970988216123, 0.17477377786216275, 0.11754567634755253, 0.13828254439246734, 0.15772879063850653, 0.07953983777777707, 0.14059033380421315, 0.16414009212932956, 0.1271027984608778, 0.13222195967184158, 0.10912761419106387, 0.10048475701695114, 0.1428356633878045, 0.1320013822550924, 0.12063434546422591, 0.12542403661135226, 0.11441821955813414, 0.09110109408990408, 0.12611649587577978, 0.11755584463422997, 0.12554135084291107, 0.10935765802473285, 0.11633880045291711, 0.10252736718366517, 0.10620226441352976, 0.9511224492382317, 0.5207239906169958, 0.42428944932319934, 0.5792073029598832, 0.453702166064737, 0.3354315491770934, 0.9052519866224408, 0.885685280524614, 0.8838496790663659, 0.1388287114921366, 0.0575373986525185, 0.10299243462789887, 0.11553457042048831, 0.07917341062606498, 0.14928971698631177, 0.1262574199597506, 0.08452575855659483, 0.20885614307911737, 0.20555762830128033, 0.2371754525715064, 0.2599739568225852, 0.26932130568740054, 0.24222531749469423, 0.28014227088254084, 0.3022347564066318, 0.27621809149147636, 0.28860695088252064, 0.09380240130498296, 0.11354972336612079, 0.10001238759612208, 0.13230156590382047, 0.11207045266508864, 0.10681843734594276, 0.09651495988440206, 0.10871574944850759, 0.09614625938373533, 0.059638073114066215, 0.07474890730420991, 0.1032442816039909, 0.11098682137763138, 0.10711173105879623, 0.06471846386631641, 0.13169431285322697, 0.07671017509246214, 0.09742453966609588, 0.026827409178087014, 0.04854508616280384, 0.0038458609201881266, 9.999999999998899e-05, 0.0421235109609599, 0.0007033423580456999, 0.006961344961844751, 0.05004765721105742, 0.02882540809651002, 0.16094955007164047, 0.13566490223629424, 0.1338285090054937, 0.10746708637912106, 0.09194480897860269, 0.14869878902305722, 0.12745620834474192, 0.13042236012015096, 0.1599027510887967, 0.013541207081843254, 0.006303295073195825, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011750328785089525, 0.015050433132250518, 9.999999999998899e-05, 0.0944536902405454, 0.06060694677892531, 0.10811015032519555, 0.07757622204379133, 0.041027450964476575, 0.15013949713034547, 0.08565887697625951, 0.06119974346030266, 0.04263758361289527, 0.31302011345870784, 0.33645797109192177, 0.2778880259712313, 0.3115468316788955, 0.26794234974338815, 0.26245835139896134, 0.2933043896738764, 0.31797275181159645, 0.28894510690341857, 0.1038976720354321, 0.1084643658477924, 0.07789654515782751, 0.08587358161277803, 0.08787280840967382, 0.0885270373476229, 0.11020875384938533, 0.09356729133197172, 0.10134287760039429, 0.11828037897174692, 0.11444517520095399, 0.13166009294967385, 0.1539379788980284, 0.11439228137864998, 0.12134971618679646, 0.147556603177326, 0.11475896954061737, 0.13741363453007416, 0.2224515319143121, 0.23889285779605873, 0.281118177336668, 0.27921449692841416, 0.23704527552534016, 0.23733030399293398, 0.24399401335460702, 0.26110196072836944, 0.253069866445642, 0.2306400711999156, 0.16868431164557973, 0.1866535905850577, 0.18647557415442295, 0.1699246550431215, 0.19699685208728523, 0.1955686887868614, 0.20163815421164932, 0.2083790914628526, 0.16617352915280448, 0.16412345002491224, 0.14783081470150228, 0.1764817742050112, 0.18246763280855893, 0.17409617896503893, 0.184547541830537, 0.16727544792556492, 0.19102468677641837, 0.19752930717407857, 0.17763909074561057, 0.22673103714388243, 0.17737747506711365, 0.17404429181328473, 0.18424475320519895, 0.19028868755786033, 0.1785034405684428, 0.1791247168632757, 0.15586430373785554, 0.16877726996236653, 0.19209639416822277, 0.2053438061944194, 0.1482411113982569, 0.1574932141833678, 0.15495701816731633, 0.1646530299729937, 0.16862140917021895, 0.15269325357061192, 0.18011248295867732, 0.1614377374592324, 0.14828920887153363, 0.1634905533868628, 0.21159633220734342, 0.18144506429154628, 0.1801157348011413, 0.1892564928564845, 0.18809532551747632, 0.17588820741318645, 0.1749638001391044, 0.1721865821742644, 0.1713648631259893, 0.18590882274012177, 0.1884755675755967, 0.1749177267233032, 0.1736221000164413, 0.06895735042300788, 0.0664236317880268, 0.06312674560364628, 0.07779045590085776, 0.07877981789411093, 0.06998177337051292, 0.06733892415106313, 0.07409816425075133, 0.06718164489539047]}, "mutation_prompt": null}
{"id": "0a3cb187-f448-43f6-a3c5-dffa55274249", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))  # New: Distance-based scaling\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        return trial if func(trial) < func(target) else target\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                trial = self.crossover(population[i], mutant)\n                trial = np.clip(trial, *self.bounds)\n\n                # Selection\n                new_candidate = self.select(trial, population[i], func)\n                new_fitness = func(new_candidate)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Integrate a distance-based scaling of the differential weight to adaptively control exploration and exploitation.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4f6a46a2-4005-4560-a3e4-5c2e91db8b79", "metadata": {"aucs": [0.29406698365321904, 0.29669344626155103, 0.27358126014664286, 0.34373146015222367, 0.32203336829332596, 0.2814282423380843, 0.30716868739350933, 0.3043376151965178, 0.3046777782943908, 0.028613436772474077, 0.1716153665483906, 0.12370970988216123, 0.17477377786216275, 0.11754567634755253, 0.13828254439246734, 0.15772879063850653, 0.07953983777777707, 0.14059033380421315, 0.16414009212932956, 0.1271027984608778, 0.13222195967184158, 0.10912761419106387, 0.10048475701695114, 0.1428356633878045, 0.1320013822550924, 0.12063434546422591, 0.12542403661135226, 0.11441821955813414, 0.09110109408990408, 0.12611649587577978, 0.11755584463422997, 0.12554135084291107, 0.10935765802473285, 0.11633880045291711, 0.10252736718366517, 0.10620226441352976, 0.9511224492382317, 0.5207239906169958, 0.42428944932319934, 0.5792073029598832, 0.453702166064737, 0.3354315491770934, 0.9052519866224408, 0.885685280524614, 0.8838496790663659, 0.1388287114921366, 0.0575373986525185, 0.10299243462789887, 0.11553457042048831, 0.07917341062606498, 0.14928971698631177, 0.1262574199597506, 0.08452575855659483, 0.20885614307911737, 0.20555762830128033, 0.2371754525715064, 0.2599739568225852, 0.26932130568740054, 0.24222531749469423, 0.28014227088254084, 0.3022347564066318, 0.27621809149147636, 0.28860695088252064, 0.09380240130498296, 0.11354972336612079, 0.10001238759612208, 0.13230156590382047, 0.11207045266508864, 0.10681843734594276, 0.09651495988440206, 0.10871574944850759, 0.09614625938373533, 0.059638073114066215, 0.07474890730420991, 0.1032442816039909, 0.11098682137763138, 0.10711173105879623, 0.06471846386631641, 0.13169431285322697, 0.07671017509246214, 0.09742453966609588, 0.026827409178087014, 0.04854508616280384, 0.0038458609201881266, 9.999999999998899e-05, 0.0421235109609599, 0.0007033423580456999, 0.006961344961844751, 0.05004765721105742, 0.02882540809651002, 0.16094955007164047, 0.13566490223629424, 0.1338285090054937, 0.10746708637912106, 0.09194480897860269, 0.14869878902305722, 0.12745620834474192, 0.13042236012015096, 0.1599027510887967, 0.013541207081843254, 0.006303295073195825, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011750328785089525, 0.015050433132250518, 9.999999999998899e-05, 0.0944536902405454, 0.06060694677892531, 0.10811015032519555, 0.07757622204379133, 0.041027450964476575, 0.15013949713034547, 0.08565887697625951, 0.06119974346030266, 0.04263758361289527, 0.31302011345870784, 0.33645797109192177, 0.2778880259712313, 0.3115468316788955, 0.26794234974338815, 0.26245835139896134, 0.2933043896738764, 0.31797275181159645, 0.28894510690341857, 0.1038976720354321, 0.1084643658477924, 0.07789654515782751, 0.08587358161277803, 0.08787280840967382, 0.0885270373476229, 0.11020875384938533, 0.09356729133197172, 0.10134287760039429, 0.11828037897174692, 0.11444517520095399, 0.13166009294967385, 0.1539379788980284, 0.11439228137864998, 0.12134971618679646, 0.147556603177326, 0.11475896954061737, 0.13741363453007416, 0.2224515319143121, 0.23889285779605873, 0.281118177336668, 0.27921449692841416, 0.23704527552534016, 0.23733030399293398, 0.24399401335460702, 0.26110196072836944, 0.253069866445642, 0.2306400711999156, 0.16868431164557973, 0.1866535905850577, 0.18647557415442295, 0.1699246550431215, 0.19699685208728523, 0.1955686887868614, 0.20163815421164932, 0.2083790914628526, 0.16617352915280448, 0.16412345002491224, 0.14783081470150228, 0.1764817742050112, 0.18246763280855893, 0.17409617896503893, 0.184547541830537, 0.16727544792556492, 0.19102468677641837, 0.19752930717407857, 0.17763909074561057, 0.22673103714388243, 0.17737747506711365, 0.17404429181328473, 0.18424475320519895, 0.19028868755786033, 0.1785034405684428, 0.1791247168632757, 0.15586430373785554, 0.16877726996236653, 0.19209639416822277, 0.2053438061944194, 0.1482411113982569, 0.1574932141833678, 0.15495701816731633, 0.1646530299729937, 0.16862140917021895, 0.15269325357061192, 0.18011248295867732, 0.1614377374592324, 0.14828920887153363, 0.1634905533868628, 0.21159633220734342, 0.18144506429154628, 0.1801157348011413, 0.1892564928564845, 0.18809532551747632, 0.17588820741318645, 0.1749638001391044, 0.1721865821742644, 0.1713648631259893, 0.18590882274012177, 0.1884755675755967, 0.1749177267233032, 0.1736221000164413, 0.06895735042300788, 0.0664236317880268, 0.06312674560364628, 0.07779045590085776, 0.07877981789411093, 0.06998177337051292, 0.06733892415106313, 0.07409816425075133, 0.06718164489539047]}, "mutation_prompt": null}
{"id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 9, "fitness": 0.19783364714788984, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.17.", "error": "", "parent_id": "4f6a46a2-4005-4560-a3e4-5c2e91db8b79", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "88f343af-dbe6-4d46-b1b0-ac6d8a54a523", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "c71d40eb-8be5-4f29-8f8a-691516870f63", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "6dec7773-66f1-4b5b-8f91-1b14f6771fcd", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "e20c5bde-5a69-427a-b4d4-020f8f4511c5", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "b51166e6-74e3-494b-9b0d-575ec5f1b3e2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "4c7dbfbc-2112-4693-a605-9d58838a868d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "656de588-8eb6-4224-b87a-901578b6fa79", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population, fitness):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        fitness_based_F = self.F * (1 - (fitness[idxs[0]] - np.min(fitness)) / (np.max(fitness) - np.min(fitness) + 1e-10))\n        adaptive_F = fitness_based_F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population, fitness)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance mutation strategy by considering fitness-based scaling for differential weight to improve convergence speed.", "configspace": "", "generation": 16, "fitness": 0.19730098317233424, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.17.", "error": "", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.3590656925512167, 0.2987122257694783, 0.3936716377163195, 0.35688557978987234, 0.3423433514801273, 0.3975886216418568, 0.44781675891183925, 0.32194603875153505, 0.39549684500622784, 0.15804787354876793, 0.19221729358033968, 0.1565574380865019, 0.1981017600999445, 0.2303898039247615, 0.09129134393589011, 0.1810869887531208, 0.20184446015054025, 0.13764782247436613, 0.21715702135162118, 0.14567118310389238, 0.2209348534158353, 0.15446085021734002, 0.2070943806605201, 0.23055004487365838, 0.1317166986447884, 0.20811678719823357, 0.14127175732399933, 0.17811178201611633, 0.11453372923270311, 0.11599735539777234, 0.13967810908191436, 0.14014942817099563, 0.1426079478596708, 0.11439288244499679, 0.12508275577986405, 0.13466008803039875, 0.9278872155268074, 0.8877007200761107, 0.8936134162073703, 0.9060363985972086, 0.8110230742421874, 0.8980921069120696, 0.9409112740993872, 0.9085223315526612, 0.8858875277025415, 0.1313106941151866, 0.09376713025916328, 0.1379673713832431, 0.1500331690927591, 0.09783436295636871, 0.12060696204085575, 0.11399663820603567, 0.12329522059025644, 0.15463313950673674, 0.27104176046333295, 0.2988088645688841, 0.30086495739737307, 0.3007655083890076, 0.27946398853089927, 0.19133248708682782, 0.20406048855705605, 0.19933162903913948, 0.2667102586048936, 0.09839325506428032, 0.1782936085958965, 0.13792947730304383, 0.11943646198801783, 0.11677224653974394, 0.1380558940374027, 0.11266740990930679, 0.18619921803147932, 0.14152178902568846, 0.10948494565018152, 0.050108981352150694, 0.08476422658719551, 0.17086625560508473, 0.1083198463441295, 0.11007904717759753, 0.13754511916366197, 0.11583250992985572, 0.11938668102234296, 0.026107541825706182, 0.030190219379137906, 0.05892535541403321, 0.1024271436073605, 0.04061723369140691, 0.12455990416539264, 0.06792006936332451, 0.06841832866173758, 0.08678463231080435, 0.11982863994728354, 0.19563793687910203, 0.20973386510268566, 0.18842671604792538, 0.13590492934528942, 0.1702979661906029, 0.142861488420288, 0.20041603429190602, 0.17182315288605388, 0.050566961117796794, 9.999999999998899e-05, 9.999999999998899e-05, 0.03527119900356024, 9.999999999998899e-05, 9.999999999998899e-05, 0.05876503863408411, 0.012447805725385841, 0.009188305570793864, 0.08444322238522872, 0.046075669078913584, 0.09386397218621845, 0.0956873185626822, 0.09264092163673088, 0.12775504402572135, 0.08600557130926267, 0.10624577057291007, 0.09908791571748277, 0.34856262925380344, 0.29068050051860306, 0.3334809876520305, 0.35570292083245114, 0.34999036324592003, 0.29070202928411815, 0.3484071606940382, 0.30505987159079373, 0.36615818862222105, 0.09496549106175312, 0.10069952216425049, 0.09742953041626057, 0.09330655804515697, 0.11519280558053546, 0.08617453228548089, 0.10709973097757552, 0.08728437639093733, 0.10825272526131846, 0.12343413718703888, 0.13337296553983602, 0.1396433790128212, 0.11336456051785548, 0.115209323642392, 0.19551635643538512, 0.15435249454745503, 0.1471751028052991, 0.11671751351260995, 0.23718262614214136, 0.2358929518478089, 0.27076943948902576, 0.25148196135025047, 0.2239035809251524, 0.28174345275955137, 0.2753185786028214, 0.270316566838379, 0.2660783147469188, 0.17915650013257922, 0.19094664649256987, 0.25414948740627374, 0.22317583830714316, 0.18382727676306354, 0.1706962049552152, 0.2052284187628206, 0.21507858226477805, 0.21654050443812545, 0.18220596102668096, 0.1944443259577171, 0.17016687974126976, 0.18221680256615214, 0.1753307905946967, 0.17427020647167935, 0.19739045841694258, 0.20149302867323882, 0.19173125802934554, 0.20512579280717314, 0.22544080400536082, 0.1996529022489555, 0.2008827469408555, 0.18970018024458069, 0.20007002554657138, 0.18698915460768506, 0.20557340667691382, 0.19063908454704281, 0.18158841735647024, 0.21363390110041025, 0.22159190777391047, 0.14758099112422152, 0.1462534086059415, 0.1763031043566936, 0.16462611863618293, 0.1424086216014746, 0.157579051587743, 0.16343036771730968, 0.15365277720480985, 0.16858303700820576, 0.1880557623518383, 0.14874112452774813, 0.15624109700274036, 0.16260530797820505, 0.1551422729363594, 0.15521656531293515, 0.1799910051797291, 0.17677578261990856, 0.168785222817893, 0.16570912906972968, 0.18165947266980287, 0.184339613973577, 0.2279782885857008, 0.1702493416289853, 0.19063894052407326, 0.08148175086354348, 0.07168866876748292, 0.0635726272002255, 0.06246084478059655, 0.08620755576707995, 0.06732063341640315, 0.06422449403165009, 0.0643374275889309, 0.07023050008500376]}, "mutation_prompt": null}
{"id": "451ea405-ea89-4e85-94b9-cce497ec2b4f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "82532d1e-5cfd-421e-b074-c703a11a1a73", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n        self.history = []\n\n    def mutation(self, population, fitness):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        if len(self.history) > 1:\n            fm_std = np.std(self.history)\n            adaptive_F = self.F * (1 + 0.5 * fm_std)\n        else:\n            distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n            adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            self.history.append(np.min(fitness))\n            for i in range(self.population_size):\n                mutant = self.mutation(population, fitness)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce an adaptive mutation strategy and memory-based parameter tuning for enhanced convergence.", "configspace": "", "generation": 18, "fitness": 0.11047311794261103, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.19.", "error": "", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.18502615189605576, 0.16572216274905116, 0.19833046575236912, 0.19385224935283119, 0.2149817540958482, 0.22842118769395525, 0.19140635696345787, 0.17363950273683437, 0.16923954042442169, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.029816710737624263, 0.03348674042569344, 0.02959364219298477, 0.0276643712420932, 0.03619981040368747, 0.026235765629492924, 0.04707091941916319, 0.037002621503442024, 0.035492235341184064, 0.011172913423701525, 0.0037078794194510545, 0.032481344313466054, 0.04189454151967964, 0.01955244711983939, 0.017759680116066878, 0.030473380932039773, 0.006723184530598725, 0.0016256627990905992, 0.9446650705743126, 0.9369943466257642, 0.9429952985735269, 0.9413520132941373, 0.9549848096767581, 0.9718375592053592, 0.9170034947305499, 0.962997152735093, 0.9724649582989886, 0.11367477493929878, 0.03091981004382849, 0.055353451490713246, 0.025763874565144174, 0.06470039721978615, 0.04380249100811995, 0.02701707058776537, 0.048569310031509105, 0.030799113662536737, 0.15510519163610292, 0.12054986107330024, 0.1003309818031779, 0.09855134805364052, 0.1138608946696893, 0.06994673720010125, 0.08694228918252556, 0.10752049582205803, 0.0945560936880484, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00901581727889389, 0.008990992057591018, 0.00799515397904016, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006856293864659357, 0.018055966569044735, 9.999999999998899e-05, 9.999999999998899e-05, 0.02250334039828994, 9.999999999998899e-05, 9.999999999998899e-05, 0.0012026071746499278, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1786626886999595, 0.2579315832105986, 0.25354772547943927, 0.21043453567256898, 0.17936519698450215, 0.1894132483377452, 0.23574254287890795, 0.18357300160856316, 0.20198660877449603, 0.037927455919835706, 0.03953926924489681, 0.0659166149128323, 0.04497778289940124, 0.031006778754218978, 0.03637563408941247, 0.02623852417277106, 0.017146017860155238, 0.03715311339890537, 0.12713939245354855, 0.15233406601397004, 0.1200272298671452, 0.12234762815063094, 0.11258888415471757, 0.13459723874274754, 0.18094860652284706, 0.12880344361272233, 0.12130877698195563, 0.14623563220746405, 0.13994807780096086, 0.18467528661154786, 0.16749610349540667, 0.1546259138553352, 0.14830018463729844, 0.17390060063664892, 0.20540485570195632, 0.17026432158740956, 0.08609465826282647, 0.0658551652305368, 0.11617157677285672, 0.08726532593772207, 0.0943488200468866, 0.08884210209152588, 0.11538712835071185, 0.1287198408126633, 0.09624855021761436, 0.1560513561161151, 0.13517135423659743, 0.15978451877462596, 0.1549477677036557, 0.13988430836138233, 0.1536420296947596, 0.16802416216372917, 0.13310302336459667, 0.16950400979483982, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04563396323279578, 9.999999999998899e-05, 0.021908973750174976, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11602015656699438, 0.11732782904021843, 0.13094449446820722, 0.1358207005842843, 0.20399520242474833, 0.11706838930529828, 0.18014052906978817, 0.13791302077244583, 0.13392019410921563, 0.16131652205097402, 0.18430299313186793, 0.10379170941098714, 0.11212828179408496, 0.0830064529762149, 0.08236520869965447, 0.14687649673432357, 0.15426926708717037, 0.12795209680867248, 0.18328790105403558, 0.1780474487072572, 0.18271969187602322, 0.18348241197566173, 0.17293036604542467, 0.17354906222284405, 0.18276132059565486, 0.18301158538001883, 0.1739924827793775, 0.03694938558703831, 0.03570254182235544, 0.054687317638330235, 0.04453607456157793, 0.043893743871538216, 0.03486471025130866, 0.03368818086332981, 0.05212951618095518, 0.0455747038578358]}, "mutation_prompt": null}
{"id": "02af7854-aee1-4102-8d2a-6f98e028270a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "8cec614f-8da9-4ecb-af35-d3dee46f5c28", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "bb5d192e-f18f-45e4-9822-907146a985a3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "c20afe21-d824-439b-a8cb-a4c3d9ed1c06", "solution": "import numpy as np\n\nclass SelfAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F_base = 0.5  # Base differential weight\n        self.CR_base = 0.3  # Base crossover probability\n        self.convergence_threshold = 0.01\n        self.alpha = 0.5  # Adaptation rate\n\n    def mutation(self, population, F):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return population[idxs[0]] + F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, CR):\n        crossover_mask = np.random.rand(self.dim) < CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_parameters(self, fitness, F, CR):\n        fitness_improvement = np.std(fitness)\n        F = self.F_base + self.alpha * fitness_improvement\n        CR = self.CR_base + self.alpha * (1 - fitness_improvement)\n        return min(1.0, max(0.1, F)), min(1.0, max(0.1, CR))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            F, CR = self.adjust_parameters(fitness, self.F_base, self.CR_base)\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population, F)\n                mutant = np.clip(mutant, *self.bounds)\n                trial = self.crossover(population[i], mutant, CR)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "SelfAdaptiveDifferentialEvolution", "description": "Introduce a self-adaptive strategy for differential weight and dynamically adjusted crossover probability based on feedback from fitness improvement to improve convergence speed.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'SelfAdaptiveDifferentialEvolution' object has no attribute 'adjust_population_size'\").", "error": "AttributeError(\"'SelfAdaptiveDifferentialEvolution' object has no attribute 'adjust_population_size'\")", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {}, "mutation_prompt": null}
{"id": "1cd30de8-7f07-45ad-bd79-7c830a70c04f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def opposition_based_initialization(self, population):\n        opposition_population = self.bounds[1] + self.bounds[0] - population\n        combined_population = np.vstack((population, opposition_population))\n        return combined_population[np.random.choice(combined_population.shape[0], self.population_size, replace=False)]\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        population = self.opposition_based_initialization(population)\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance initialization by incorporating opposition-based learning to increase population diversity and improve convergence.", "configspace": "", "generation": 23, "fitness": 0.1910246279789762, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.16.", "error": "", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.39803176985723976, 0.3330816129372729, 0.339292773127416, 0.3677572616384629, 0.36438835517593127, 0.35674452729220807, 0.3527106105474135, 0.2774288876620481, 0.34337017081241594, 0.25634646620093093, 0.1455923819637741, 0.1828504925496074, 0.1356586269935215, 0.2682082324927695, 0.1685405911664304, 0.21582169960555153, 0.1700980915032082, 0.14784280078220002, 0.1831368666563643, 0.18959019049873793, 0.18155207253750683, 0.17225476472621581, 0.1858503437079555, 0.20169500202104507, 0.19539985232305035, 0.17687676756715842, 0.13337310536917812, 0.16002661557747, 0.13410866309403957, 0.12230560482288078, 0.16929034338834448, 0.13961038019756344, 0.12497371058237583, 0.13144992534980937, 0.1099997382110911, 0.13044862651229083, 0.9022153621493948, 0.9081558836481799, 0.9246854735140347, 0.9029524636625084, 0.8701161727667401, 0.8858913501311166, 0.9251711508906239, 0.8937853574929622, 0.3588610055811229, 0.13478858474349165, 0.07819452000006932, 0.07871591149302926, 0.14461004028069468, 0.11961433395703114, 0.11497159028608861, 0.09934231310950015, 0.10318260106490995, 0.1087551717894708, 0.30514058852758796, 0.20655393130830435, 0.21884625697621973, 0.24621420418067796, 0.2460836828824695, 0.24707902398086323, 0.2589763084132426, 0.21948059090411676, 0.20188684825003322, 0.12594022323015974, 0.09831067821014672, 0.14775560811423671, 0.2893188772639036, 0.17658148814635388, 0.15115073018072467, 0.1713734793808972, 0.10485089859152963, 0.11380545481265636, 0.028233707522713147, 0.07387396647261757, 0.10274767442330068, 0.19307085900994647, 0.19806506763280607, 0.1176371696719809, 0.10722019635983249, 0.058749831664312135, 0.12061809057254069, 0.006962681442113872, 0.05978941405566984, 0.018345392688876583, 0.06329692910793472, 0.023170684891452575, 9.999999999998899e-05, 0.06054003790389051, 0.05804902852597427, 0.09738785378151005, 0.1837430090821982, 0.16997189210864816, 0.17728340947639698, 0.13822074958814734, 0.14720205508976758, 0.13016385401349995, 0.14430953594729257, 0.18107287770361802, 0.19494418979205197, 9.999999999998899e-05, 0.020174417601793948, 0.02851097153756965, 0.0003465649820616479, 9.999999999998899e-05, 0.0018741251830600714, 0.053248722026656314, 9.999999999998899e-05, 9.999999999998899e-05, 0.08935463655866638, 0.06314070831279839, 0.12335804167167475, 0.05694240505414783, 0.10976775097901958, 0.13229066617115626, 0.0830855192648845, 0.09431724713821077, 0.08562944061397049, 0.3560089555521636, 0.3259460451065743, 0.3994992775438082, 0.3180549134894115, 0.38130417970406183, 0.33802290033544125, 0.354262468547796, 0.3305895905927573, 0.340262978340941, 0.08714422363918617, 0.08978851639291152, 0.0865945420794475, 0.07434509875057915, 0.08110210539764906, 0.08480741717563345, 0.08155303364163957, 0.10410115792095798, 0.07724197503745545, 0.14961755300577984, 0.16079774509988165, 0.11679459447019269, 0.12156220533814754, 0.12246094533131313, 0.1300281835093281, 0.12884464329227308, 0.11648907578326839, 0.13742018258521116, 0.25523165560808236, 0.25684347353670955, 0.28500091329514676, 0.2481222087116115, 0.2354230882087729, 0.2854377246238393, 0.27569399658133353, 0.3013031457948596, 0.27631397774372213, 0.17875345937815423, 0.18519749343449554, 0.19723413057551775, 0.14363400935859139, 0.13966804560446, 0.1549094157944959, 0.23067298082349164, 0.19330488718811212, 0.1759185489161187, 0.19812845237027532, 0.1615247740466672, 0.17249828263284817, 0.16973180311676572, 0.15579479887256764, 0.18344281925324624, 0.1720464529591922, 0.19673377931026637, 0.17683360960619265, 0.19868585311635156, 0.22526591635574333, 0.17538838838669635, 0.17860004048713984, 0.19823433203480878, 0.22737737023723426, 0.20204374133743752, 0.20217868595845778, 0.20665509969456775, 0.14110163117649133, 0.18106566245006928, 0.1710494058424169, 0.22340496646880215, 0.16884104010539502, 0.281989451643303, 0.1401702275084845, 0.15365987630105393, 0.15240911661266165, 0.14291116102295598, 0.16822006018202995, 0.17710706955136923, 0.1479946089025298, 0.13849821244418203, 0.1582323377994107, 0.15458069251703688, 0.17380494081245634, 0.14644640057738256, 0.1731075878450119, 0.1709421016243512, 0.17214330413610002, 0.1993333748102808, 0.1745342613074159, 0.16868974329398623, 0.18087038726287785, 0.17646485547675916, 0.17906163337733394, 0.06202203723534294, 0.06983808757314602, 0.0640355843818643, 0.0644138559124261, 0.06987662711039322, 0.07228832851161537, 0.06172195018684001, 0.06198871534138084, 0.05775102254458342]}, "mutation_prompt": null}
{"id": "2fa8a0ac-d396-456b-af4a-db4cb96351e7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        diversity_factor = np.std(population, axis=0).mean() / (self.bounds[1] - self.bounds[0])\n        adaptive_F = self.F * (1 + 0.1 * diversity_factor)  # New: Adjust F based on diversity\n        adaptive_F = min(1.0, max(0.4, adaptive_F))  # Ensuring F remains within a practical range\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance mutation strategy by dynamically adjusting the differential weight based on population diversity.", "configspace": "", "generation": 24, "fitness": 0.1617079209646523, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.17.", "error": "", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.34470948306496685, 0.33504813363746433, 0.3478322587753191, 0.3953367727472358, 0.3823762747173727, 0.36330275295221914, 0.3483309358236415, 0.3638895271040823, 0.3627878301098798, 0.09644174676883743, 0.10144799007617, 0.11826927605509951, 0.11089199749698042, 0.0927279030159942, 0.10386076716784942, 0.12166769766310903, 0.12706169058401628, 0.09815972973724307, 0.07688585979401708, 0.07786921950473769, 0.08371924751805038, 0.08264284679043576, 0.07735238511333786, 0.08226070301730704, 0.08157972173909334, 0.07608699446867051, 0.08247630608705803, 0.07643191460991727, 0.06616341276078785, 0.06687380178355684, 0.06838921745321314, 0.06187030919180525, 0.0676318197563851, 0.06476331777301325, 0.07464060800112637, 0.07948023600075727, 0.8960606702452953, 0.8785205559594499, 0.9076485326741653, 0.9195178550786994, 0.9230135673287281, 0.9044093383996161, 0.8910565644413087, 0.8845427725921884, 0.8581918132472057, 0.1482278483927323, 0.11818040846763833, 0.12105231961878449, 0.136503752825182, 0.14833779987474993, 0.13071334357825104, 0.15136475398620042, 0.1435135418508977, 0.15760728135022184, 0.19547091587095056, 0.16544809725285325, 0.19713554447758186, 0.21909563352165173, 0.20794271126448016, 0.1870173250464623, 0.20785174410914642, 0.1919920314867991, 0.21106719686133024, 0.0644460791104644, 0.07509073394826649, 0.08116112219704097, 0.06818070296861556, 0.08430268753015024, 0.07941516268087612, 0.08765822114408695, 0.093446696443228, 0.09379292943646955, 0.06544880537126174, 0.07464318739833309, 0.11507347156645831, 0.09633458270348638, 0.08370388501195991, 0.07591456268789065, 0.04859698353673525, 0.07050611177654975, 0.0775679711325804, 0.01011457026621121, 0.0048082370045227085, 0.00013224505406028708, 9.999999999998899e-05, 0.008426412785131676, 0.0001079431778902018, 9.999999999998899e-05, 0.015052825410782122, 0.000280781134510133, 0.09202589379583859, 0.1289495272727208, 0.114101894014207, 0.11458415986280213, 0.08104725239350319, 0.08133980916372618, 0.11696910963627383, 0.14529422294476624, 0.1003239625054162, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.043672661236795696, 0.0474474949221223, 0.040532934925594954, 0.026203075743669646, 0.033124650215635154, 0.04450934369586612, 0.04480728757170094, 0.058110592248934, 0.044265340232497286, 0.2994912506041245, 0.3116182828596379, 0.29606334821508895, 0.321869796455745, 0.31728976974573275, 0.3185420079820107, 0.28425784257797837, 0.29306934431062426, 0.30686430672486653, 0.0669408569568044, 0.06212616151477979, 0.07527870467894315, 0.07163591130021518, 0.06129098092980567, 0.07139930692832219, 0.07855967708123113, 0.0793443443386781, 0.07743122528484037, 0.1491118853113711, 0.10677164237170678, 0.1252793727089362, 0.14957510185066736, 0.13304722432629168, 0.12781713525622784, 0.1275815609342752, 0.11785934363399919, 0.1321665123145418, 0.1876003623157314, 0.2129179035990817, 0.20001005167896768, 0.20674803940451625, 0.16846196952880332, 0.18736292072649774, 0.21377747635220035, 0.2198739853872954, 0.1927905894201054, 0.13724921342429408, 0.1299174507179106, 0.13588983171972635, 0.12215835843668721, 0.12676380366924989, 0.11763499600447735, 0.13924153247117388, 0.14857639365059472, 0.12993559488827577, 0.15704610251947793, 0.16358469354434624, 0.1668053083946961, 0.15402574180672834, 0.16714208965298927, 0.16494339745597297, 0.1677725611334272, 0.15974124624554065, 0.16453250351876125, 0.15223028922806847, 0.1588726358071212, 0.15985847513030582, 0.18271465256148423, 0.1665421716501715, 0.15193814209639767, 0.15761035223508246, 0.14549167580851285, 0.16334424765500877, 0.17662579310297866, 0.13397089332819268, 0.136241673540905, 0.17373067470176995, 0.16752720013480682, 0.14371859658069497, 0.15122920192855693, 0.2128391400506744, 0.13746367333833243, 0.15991211642275516, 0.13988550242880737, 0.15038927060420415, 0.13349895506174014, 0.12177509911746942, 0.1294100262835629, 0.15279270684664914, 0.2914703500329072, 0.14030175291146296, 0.17493637175765708, 0.18999248481327846, 0.18487857347115466, 0.17569539799816447, 0.17344691562324732, 0.17242227801017784, 0.17807592203242384, 0.17583122165153198, 0.17430801973024934, 0.05455742151257614, 0.0603285156390857, 0.06036803275110747, 0.06067421302379061, 0.07055073798510436, 0.06482084905681695, 0.05784746110777905, 0.05581128019392256, 0.05283221603027888]}, "mutation_prompt": null}
{"id": "a77b02d3-5e08-4fc2-8997-fc969f4c3ca8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "d12a233d-5c32-48f8-a8ec-9cbdfa95ca84", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(150, 10 * dim)  # Increased initial population size\n        self.population_size = self.initial_population_size\n        self.F_initial = 0.5  # Adjusted initial differential weight for exploration\n        self.CR_initial = 0.7  # Adjusted initial crossover probability for exploration\n        self.convergence_threshold = 0.01\n        self.diversity_threshold = 0.05  # Threshold for maintaining diversity\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F_initial + 0.5 * (distance / (self.bounds[1] - self.bounds[0]))  # Dynamic scaling\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        diversity_measure = np.std(target) / np.std(mutant) if np.std(mutant) > 0 else 1\n        adaptive_CR = self.CR_initial * (1 + fitness_improvement * diversity_measure)  # Enhanced CR\n        adaptive_CR = min(1.0, max(0.2, adaptive_CR))  # Ensuring CR remains between 0.2 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        diversity = np.std(fitness)\n        if diversity < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        elif diversity < self.diversity_threshold and self.population_size < self.initial_population_size:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "EnhancedDifferentialEvolution", "description": "Enhance convergence by introducing dynamic scaling factors and diversity preservation mechanisms.", "configspace": "", "generation": 26, "fitness": 0.1564286411850383, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.18.", "error": "", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.38682138570934, 0.3838408428184361, 0.4008663323873073, 0.3946107464104611, 0.4704070483389585, 0.47311110071694806, 0.38499596135265524, 0.42531056578702675, 0.39364351532655373, 0.13477783798484289, 0.12630984852228644, 0.15643586031863155, 0.13109457059723262, 0.12743070195896977, 0.12510176295470132, 0.10265872220015049, 0.11249839923794758, 0.1451689815297541, 0.08842323656901496, 0.08580657201848496, 0.08854140668671695, 0.09271584374023822, 0.09076200372907528, 0.09030941623809685, 0.11130646341122086, 0.0955232694148368, 0.09436753277190746, 0.07402228748064554, 0.08398371335956212, 0.08286762401246361, 0.08003447505877614, 0.07563053155336896, 0.080563365670699, 0.08324093032337299, 0.06969487166901722, 0.08170311043476686, 0.9188165685204189, 0.9433586151814182, 0.9027459388417232, 0.9280364815722089, 0.8683920725772166, 0.8940708141727134, 0.9279004824922016, 0.9162806965397902, 0.8966448402326442, 0.12037452324131048, 0.1237320255428569, 0.12992467114620698, 0.12071465021789995, 0.1392007792007418, 0.15206988514323871, 0.16538596658893734, 0.16031262852020678, 0.15625784934244946, 0.13574158193954222, 0.12808530605269064, 0.1374870334588041, 0.1531870522052523, 0.15450484443224688, 0.12659496396831693, 0.15278231470101578, 0.14499742470102805, 0.14857010782362523, 0.07191666404009533, 0.08316836199888056, 0.08356713172009855, 0.06693816150996679, 0.07741624726962437, 0.10463891036401396, 0.053861064951164384, 0.08894818923006065, 0.08724077933859864, 0.027098383959740513, 0.07306512209123572, 0.019740546582781127, 0.05733486218085759, 0.06275180068618624, 0.05635875857578798, 0.008206131784881832, 0.004751352328766889, 0.06761356213190906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.046271461534140856, 0.02485715934418964, 0.012070514404113442, 0.025402707514691203, 0.051593719350086054, 0.0762486844981628, 0.04073889343682291, 0.0319507053426249, 0.04656685513019654, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0213940563647268, 0.028256033995618934, 0.025429813689645364, 0.02289027845855729, 0.023733802983956553, 0.041187919127560035, 0.038098546974889125, 0.04333797482640733, 0.03748380892966796, 0.2644276743277435, 0.3202933616175584, 0.33793674834576937, 0.3275853121837674, 0.3435248940605842, 0.3278848004224546, 0.27809167760762976, 0.2595960529223428, 0.339302645508748, 0.08098120863481617, 0.06939351931710369, 0.06347021805181008, 0.054971039090063845, 0.05905421729451432, 0.057724064155224686, 0.05967110309396939, 0.06677948311327109, 0.060183097848082845, 0.14052498643567268, 0.11644285641333496, 0.11842175776965747, 0.13802192424180282, 0.14527525157877774, 0.12879083431958627, 0.13134947436254496, 0.1168132532902929, 0.12812158344795843, 0.1702223782036164, 0.16713462382303046, 0.191749263132161, 0.16140924374002275, 0.15300051445747453, 0.1609563691590753, 0.20537612036644604, 0.2022340884030861, 0.20747478130199748, 0.10090606549679815, 0.1222088830233572, 0.1222224548890738, 0.1048009360138078, 0.10529808704139121, 0.10041588811395963, 0.14360357439073956, 0.12072256687426819, 0.10343229279052302, 0.18399046451374745, 0.15238932660546411, 0.1578291601718662, 0.1554005647255241, 0.15404357587115702, 0.15840238244037774, 0.17114462299726163, 0.16254797544068367, 0.1575387197821294, 0.15210216348981498, 0.15989077355563586, 0.17910638966379389, 0.15599607180100683, 0.16910031676746307, 0.17484702537044672, 0.1635288761467053, 0.1593364657285501, 0.1607695544351807, 0.14827893871879494, 0.14459273998023459, 0.15024929246901597, 0.1374380758971302, 0.1814997629302224, 0.1321635285960836, 0.14735306108624413, 0.14292915692752473, 0.14757902715390048, 0.13824245339924668, 0.15304407853451774, 0.13982511958831978, 0.13845373036709896, 0.1267100245742102, 0.1404279960707281, 0.13272857389668768, 0.1799825951944406, 0.17308759690177178, 0.1724702963739423, 0.1790289343936009, 0.17665642573706686, 0.18768488506555858, 0.18092002109859595, 0.19199809408512714, 0.1634663975846986, 0.17254549695185284, 0.17287612419716658, 0.05321706837662654, 0.058560128959697644, 0.05565938131859982, 0.05379153953326077, 0.0639223331421499, 0.061141387285035154, 0.062196678662163274, 0.05775461149671168, 0.059665415935644894]}, "mutation_prompt": null}
{"id": "eff9f6d9-aabe-4eec-95f1-00a4c3dcbee9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "dde0529e-aaad-4f71-ae4e-7bcabaa96a6b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "e681dbae-9f7f-4669-96db-59ccf3fb9341", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "dc2bc2cd-5d5d-496d-8f40-43a115ac4454", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "16588b87-a8a2-4f87-a5d5-08853278a6a6", "solution": "import numpy as np\n\nclass AdaptiveSelfAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(120, 12 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8\n        self.CR = 0.9\n        self.convergence_threshold = 0.01\n        self.k = 0.5  # New: learning rate for self-adaptation\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, trial_fitness, target_fitness):\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def adapt_parameters(self, fitness, trial_fitness):\n        self.F = self.F + self.k * (trial_fitness - np.mean(fitness))\n        self.CR = self.CR + self.k * (0.5 - np.random.rand())\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                trial_fitness = func(trial)\n                new_candidate, new_fitness = self.select(trial, population[i], trial_fitness, fitness[i])\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n                    self.adapt_parameters(fitness, trial_fitness)\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveSelfAdaptiveDifferentialEvolution", "description": "Introduce self-adaptive strategies and modified selection mechanics to enhance convergence speed and robustness.", "configspace": "", "generation": 31, "fitness": 0.09851707621932858, "feedback": "The algorithm AdaptiveSelfAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.19.", "error": "", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.11869729595922507, 0.11246362740102345, 0.11828376373944671, 0.15405981324706586, 0.165663822643622, 0.1911796911016238, 0.13692068984394534, 0.12375457292630199, 0.13868651804039078, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005537130951650204, 0.015169340368183293, 0.012652647506786852, 0.0229753938307935, 0.019497549129902092, 0.03566988099199242, 0.022779621940200778, 0.03078835034463423, 0.015768585721178008, 0.009077128571551296, 0.0018193419388214949, 9.999999999998899e-05, 0.020547494465635974, 0.013376604341115095, 9.999999999998899e-05, 0.015294972599297907, 9.999999999998899e-05, 0.003411675871585973, 0.9844738297713436, 0.9586034974582308, 0.9859415802118052, 0.9930598027742666, 0.9759958364555295, 0.9908918850049485, 0.9873728822800516, 0.9367786472746465, 0.9718175681721777, 0.06274794416174423, 0.023258283575238403, 9.999999999998899e-05, 0.01820344047255107, 0.00031549654350837564, 0.006590478502054076, 9.999999999998899e-05, 0.01514992761684475, 9.999999999998899e-05, 0.11817894239061921, 0.08224659834595494, 0.059824388882108726, 0.09342568156577147, 0.07421884074188456, 0.08015377601032092, 0.03708671032391919, 0.12945904374800266, 0.10017772473897679, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0010834464738008753, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007606121852464454, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03840245919662644, 0.002424361237118089, 9.999999999998899e-05, 0.004131139543901541, 0.012667093344826408, 0.0066977306635573886, 0.0001930580376010571, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01089148818135488, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13914094952616707, 0.16143420344378223, 0.15708278750330884, 0.1678888074275252, 0.14202712669038153, 0.14462009435557943, 0.20628599594467867, 0.12648358403994353, 0.12758025041506937, 0.03192207308259787, 0.037474779413506853, 0.052594785317210735, 0.03266886175302153, 0.02400592914692512, 0.02919120477310322, 0.021209130560241318, 0.005945139359313956, 0.0305990350280112, 0.11834099818474275, 0.1016633872935292, 0.11842175776965747, 0.13766266535167793, 0.11685013291422552, 0.1589279138815598, 0.13544525349764203, 0.15398392360785562, 0.10709565244005204, 0.1367510963426124, 0.11932446465363666, 0.1613932299901244, 0.13800672315110074, 0.12356628087918053, 0.12923379868539864, 0.12364301050021953, 0.17377774300845283, 0.13453283256931825, 0.06974019897201911, 0.06190473563971277, 0.08398582550377798, 0.05856411222734381, 0.08971283072799119, 0.09381716651951133, 0.08497413932982778, 0.0997711199450243, 0.08695948749996807, 0.11943364695601921, 0.11723147587957661, 0.1336745582888711, 0.11423019632418852, 0.11341882221665656, 0.11646653424578857, 0.1344789064408698, 0.13338286230171692, 0.14501908718715528, 9.999999999998899e-05, 0.05673567906624377, 0.0006550670703245887, 9.999999999998899e-05, 0.12891361032365822, 9.999999999998899e-05, 9.999999999998899e-05, 0.0769841594414411, 9.999999999998899e-05, 0.13084058301864065, 0.10568980410565654, 0.1613204789649788, 0.15110309622164275, 0.12908509990593175, 0.1169551717014865, 0.11212757452973432, 0.11160171847904998, 0.1114863533728605, 0.13692749517625102, 0.10267165755511809, 0.09784743700682907, 0.0726259638715786, 0.07805913997483926, 0.091492573732326, 0.13623147525336465, 0.12454965336907375, 0.120461958177139, 0.17060401784922874, 0.1731520611826698, 0.16002676263910232, 0.17248248487329543, 0.16381028110545215, 0.15628675615829346, 0.16448713082735777, 0.16247847280456595, 0.16536795813618632, 0.026662011738312286, 0.027898732656321257, 0.032071166654530914, 0.027015293023570086, 0.03425093938292756, 0.038841296808835746, 0.02919324945400603, 0.03803354422653826, 0.018474025798513538]}, "mutation_prompt": null}
{"id": "7aeb6a24-bf15-4b71-9158-7c1cd38ea85a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "f57b9cce-cee1-49ce-b73f-9e51c9788e99", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "bab8bdb5-ebb9-4d7e-af63-d9dd5185e9c8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "8c9ff19e-21be-455e-adf8-ceed87017afa", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "446d457a-403d-4b5d-8bf7-8f35b29f220c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "e71e3e15-e249-4611-b7c0-684f3e3ee64b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "138a6cfe-c85c-44cb-bf90-613ee83be82a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "f0cd5d0a-56f8-43d3-96e9-c555982357b8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        diversity = np.mean(np.std(population, axis=0))  # New: Compute diversity\n        adaptive_F = self.F * (0.5 + 0.5 * diversity)  # New: Adaptive scaling factor based on diversity\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive scaling factor based on population diversity to dynamically balance exploration and exploitation.", "configspace": "", "generation": 39, "fitness": 0.13634556233669237, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.19.", "error": "", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.38103792853113627, 0.35352808296460414, 0.3973477646637402, 0.4331036874119808, 0.43611264609017353, 0.42577336429082324, 0.4306631475212639, 0.46778500084993824, 0.33790166363641794, 0.027732747628546384, 0.054296625209844795, 0.04276152993829163, 0.03994479652572758, 0.026007758055585306, 0.03873916263451738, 0.019565439280911368, 0.03980149959461465, 0.037727899443549706, 0.06748175736033502, 0.0673359805931033, 0.06648791791758735, 0.064466732597105, 0.07565905380099558, 0.06882542032949912, 0.06101027126817171, 0.06968327284250897, 0.08550461226255479, 0.05411859241338712, 0.042788583746921405, 0.04526209862003361, 0.05807394226109297, 0.04553561009582485, 0.047502952111112995, 0.05835018480634446, 0.06246344982477947, 0.04773576440595062, 0.9426407907690737, 0.9560970531734074, 0.9473457445695848, 0.9408643157385732, 0.9499830626941174, 0.9493705217171752, 0.9388246382204015, 0.9505589531919504, 0.9193964080210729, 0.12656441660299567, 0.12029173599854326, 0.11078639803264245, 0.09510059308207697, 0.1652835433722536, 0.11416971173836843, 0.12449575093103016, 0.12949628174019567, 0.07423506446443495, 0.11046242126650507, 0.08349879081286327, 0.08955445164952758, 0.14309493287698316, 0.11872994252854818, 0.10448495404903313, 0.09149059460121023, 0.12926625016244653, 0.1316987459498925, 0.02123759072682674, 0.03630628147758019, 0.012457044339231449, 0.06065834166790951, 0.030113944301171758, 0.05114919706905152, 0.07901789829594252, 0.03924739157901602, 0.05050804001515441, 0.009037363471539717, 0.009312422623044436, 0.043485175403010556, 0.016245033186958024, 0.00863115210214438, 0.01747201008796162, 0.0025541080100600633, 0.026350635928894528, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010719637756884115, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.014655954914189362, 0.013889644553540137, 0.030560691133220685, 0.02517954026126812, 0.071592626799718, 0.010928049636246384, 0.03627234367839505, 0.03740011809875976, 0.0394457050136634, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00040660381782076094, 0.023614681010214245, 0.01737214389797903, 0.016574403235204205, 0.023013100594431624, 0.019943176587194467, 0.02307319669460972, 0.02544089148266937, 0.01958362726918461, 0.04138019963075279, 0.03644629004250177, 0.2078027294589324, 0.19932019253253752, 0.2378247721616793, 0.286443571068669, 0.24255074938218912, 0.26591944057667904, 0.24928942051109004, 0.27580469323327583, 0.27068450567977054, 0.06001463688502284, 0.06724230098644857, 0.07062793149876101, 0.046270983141062816, 0.046963637439994765, 0.05492836272089485, 0.03922936865684479, 0.044720105327180626, 0.053068278742929076, 0.13356190567877635, 0.12319459406982192, 0.12191765440561741, 0.14136422725587983, 0.1437855065130592, 0.13009676813783222, 0.14797381503684104, 0.13260137872229005, 0.12272723892465143, 0.13590890549259493, 0.1445931467918985, 0.17447486901626563, 0.14961110026782354, 0.1380210559528987, 0.1461598208090834, 0.15796901772193628, 0.1820585661110482, 0.15492936242321687, 0.09092866133389088, 0.0883238337725053, 0.10103504595883184, 0.0856884543842561, 0.09707109668375435, 0.07944407006873422, 0.09814021602266021, 0.11196924095344951, 0.10027543410472117, 0.12811104513198424, 0.12547821826493255, 0.14963413431136063, 0.13767821967720706, 0.13511572716851183, 0.1397217668650137, 0.1461727452945243, 0.1444929198693521, 0.16262506444124725, 0.10262157238435754, 0.12687406913102017, 0.14994576908225987, 0.0837111575171241, 0.14311132242465863, 0.10729935837935323, 0.10367522177722188, 0.10880719734849986, 0.10541744587781154, 0.1475548888285383, 0.12113287879323886, 0.11993987315944399, 0.11945371701306196, 0.12755921110546098, 0.14646066811367076, 0.13947310739090657, 0.12315170769043049, 0.13526589698281255, 0.11725741976256121, 0.13209994044876772, 0.11926237682103324, 0.11086438775687968, 0.09381891574069634, 0.08823789969698048, 0.13902027090948632, 0.15339206512231818, 0.170479290894201, 0.19404785345548847, 0.1722912096702952, 0.17524495942484264, 0.17385534906022715, 0.16107626557672006, 0.17010043529765895, 0.1829074757339506, 0.17575583842725295, 0.17709971598929097, 0.03714766389185975, 0.045936634542560806, 0.044073776752895144, 0.04805576134662193, 0.04750322865019729, 0.04591756011420911, 0.04827595960989561, 0.05161848942080616, 0.06411832546703844]}, "mutation_prompt": null}
{"id": "f07ffeaa-ed03-4458-a602-7dc955ea1da2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8\n        self.CR = 0.9\n        self.convergence_threshold = 0.01\n\n    def mutation(self, population, fitness):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        # Adaptive F based on fitness diversity\n        fitness_diff = np.std(fitness) / (np.max(fitness) - np.min(fitness) + 1e-10)\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0])) * (1 + fitness_diff)\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        # Dynamic adjustment based on fitness diversity\n        fitness_diversity = np.std(fitness)\n        if fitness_diversity < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, int(self.population_size * (1 + fitness_diversity)))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population, fitness)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a dynamic population size adjustment and fitness-based F adaptation to enhance convergence speed.", "configspace": "", "generation": 40, "fitness": 0.1908247334853533, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.37721175897320125, 0.3422041445393602, 0.3910923468373301, 0.30968457489089674, 0.38173005105202273, 0.3168364894568647, 0.40060896650685673, 0.3478838857278561, 0.3439852844790423, 0.17300219626189317, 0.1951693576257174, 0.21148593435083918, 0.16320726013879028, 0.2071476507641713, 0.19915552523188218, 0.17569494216509773, 0.16738851866319493, 0.17919511318909187, 0.14020922295315108, 0.13959011082470463, 0.22839175815557167, 0.19915117506684576, 0.12790500990460751, 0.17548037652789117, 0.1050905229545237, 0.16637765405262217, 0.14683279783734815, 0.11954415884765457, 0.1166138961194021, 0.12923001849055382, 0.12252144401938148, 0.11687751345157527, 0.11873289270687326, 0.1318346138234725, 0.12017260923565387, 0.10793890341983292, 0.9208395730732731, 0.8698175352175705, 0.9531780557719296, 0.9500737885571728, 0.93158986835327, 0.9248176087369706, 0.9430022185253811, 0.9581935780383996, 0.9326466322760472, 0.12783674517872257, 0.12912204778110115, 0.11327395319430456, 0.1254696924926486, 0.06479564666766124, 0.133796586481015, 0.1222942213606637, 0.0997621204485386, 0.11239193176837436, 0.27676708402716343, 0.2674362715654476, 0.28419222722667914, 0.6552423868722344, 0.28054546331527885, 0.2870980906894327, 0.2469425869011176, 0.21849170346950908, 0.2180990778993398, 0.20250132386466468, 0.0997289401819218, 0.09987007018938765, 0.0907910433913558, 0.09681848250830083, 0.12140757391681878, 0.09858268892211908, 0.14063850704420344, 0.1372550232360803, 0.12169653567713923, 0.014527304959556564, 0.10290190492359141, 0.13253966107139337, 0.11515380480591797, 0.12076664311145868, 0.11035549596021488, 0.10046652061988315, 0.12634851544146608, 0.04269117359442276, 0.03764009182833594, 0.05144500486633574, 0.04400512532453982, 0.10680089551555416, 0.03776076353108038, 0.07357569925333796, 0.01840032367439237, 0.03652091020640058, 0.14811311768821123, 0.1308126152736837, 0.11299253958628963, 0.11543873149352457, 0.12122087389483127, 0.12466269335555968, 0.16223574131789442, 0.16464845467871914, 0.14411945449855956, 0.031111964079888255, 0.023998704640651902, 0.028036857615320376, 9.999999999998899e-05, 0.007692862022297908, 0.012930257634797604, 9.999999999998899e-05, 9.999999999998899e-05, 0.016575785600086768, 0.07108843533071307, 0.08122024741696987, 0.08234716474507242, 0.058138558247861516, 0.08084946911511692, 0.11765615408777808, 0.07864375476976582, 0.060152393826134354, 0.07943726609225521, 0.37061127718525855, 0.3524381123849677, 0.3295847637681112, 0.3280233512428049, 0.3469761289937996, 0.3746538206025605, 0.3614626991642149, 0.32488183401694803, 0.3583771453234218, 0.08744027904059515, 0.087413767548985, 0.08755887125989137, 0.08861612148633591, 0.10035098772799189, 0.07910316189488054, 0.07065522829946003, 0.06523607586186664, 0.08628613142297059, 0.12260338276727467, 0.1292554194433102, 0.14658017088413366, 0.14737107962987883, 0.16476711099764796, 0.12996926428749467, 0.13655217463913927, 0.1308218564243694, 0.13264128337110215, 0.2468186481740523, 0.24442887797378243, 0.27525764475874515, 0.20993681008981901, 0.22626033297992187, 0.21225284094703833, 0.27149013407822054, 0.26752876505172785, 0.32646118246619804, 0.19827762056767073, 0.17044817622253416, 0.1671311379633864, 0.19000054704525937, 0.14158661688419483, 0.16761594715748995, 0.17171427076730705, 0.20880748458745757, 0.18827556483225116, 0.19549723967532362, 0.16836880159846257, 0.15768958522235066, 0.18688840173088705, 0.17048771921013517, 0.163762733684908, 0.1547552682179647, 0.16325568467115004, 0.17754783944228525, 0.19788110866898856, 0.20802475831915768, 0.19923761229431813, 0.19337573184444867, 0.16950992071904603, 0.18639898473844196, 0.16836646468885008, 0.17506145443320498, 0.19428972753054896, 0.1433680591200398, 0.16118571153457584, 0.17554373319352, 0.14874894215117507, 0.13800250440106776, 0.16072304028688555, 0.12299874518136289, 0.1373397460243181, 0.17921177145085987, 0.13020169963340578, 0.1500304747759752, 0.18412962688035583, 0.1460804974617158, 0.11350146752183232, 0.12512682824051446, 0.15722087859247802, 0.1584741714865051, 0.1582715368286305, 0.1715768787607922, 0.1703453798421315, 0.18774498756174485, 0.1697165216783284, 0.1866695427266818, 0.16343393570404818, 0.18276944433737574, 0.1869531687140985, 0.17326671273246774, 0.05930733401230537, 0.06698390850344205, 0.07410264923110954, 0.06436492343775957, 0.06604082794047483, 0.07183759607935913, 0.06882507069642396, 0.06113252260336377, 0.06947895483537214]}, "mutation_prompt": null}
{"id": "92d34aa7-5abd-4c19-88b4-31bd26269a6a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "4f0915ed-450b-4f48-8877-e0be5b9f7d43", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "ae685b6a-804c-448a-bd70-ea35d1d09493", "solution": "import numpy as np\n\nclass VelocityDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.7  # Reduced Differential weight\n        self.CR = 0.8  # Reduced base crossover probability\n        self.convergence_threshold = 0.01\n        self.velocity_scale = 0.5  # New: Velocity scale\n\n    def mutation(self, population, velocities):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        diversity = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * (1 + diversity / (self.bounds[1] - self.bounds[0]))\n        new_velocity = velocities[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n        return new_velocity\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def manage_diversity(self, population):\n        centroid = np.mean(population, axis=0)\n        for i in range(self.population_size):\n            if np.linalg.norm(population[i] - centroid) < 0.5 * (self.bounds[1] - self.bounds[0]):\n                population[i] = np.random.uniform(self.bounds[0], self.bounds[1], self.dim)\n    \n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.manage_diversity(population)\n            for i in range(self.population_size):\n                velocities[i] = self.mutation(population, velocities)\n                velocities[i] = np.clip(velocities[i], -self.velocity_scale, self.velocity_scale)\n                mutant = population[i] + velocities[i]\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "VelocityDifferentialEvolution", "description": "Introduce velocity-based mutation and population diversity management to enhance convergence speed.", "configspace": "", "generation": 43, "fitness": 0.10352148475267219, "feedback": "The algorithm VelocityDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.10.", "error": "", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.14484098743223617, 0.20128151265688898, 0.17242011300891957, 0.2518508579290384, 0.23341013914094488, 0.23665962824808862, 0.23645354320829037, 0.2296992968484698, 0.20888977276149923, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04406056477887721, 0.03370844468153078, 0.045357005600049516, 0.045012175415026334, 0.0382920996957451, 0.034244399417163174, 0.029311049403208167, 0.04085288252981978, 0.03591442037643189, 0.011039905698832952, 0.010746806338313375, 0.01493200380723847, 0.021785036970062954, 0.02144115760699572, 0.028857350621655176, 0.029795405110864537, 0.022775467335875543, 0.020437994826288164, 0.4203900106967622, 0.2988861964445807, 0.2782876070447373, 0.5766000378059432, 0.5098498391754462, 0.3429501101653549, 0.3775735221269009, 0.17533511474474195, 0.44748575809399793, 0.10527649979475828, 0.09608241317919697, 0.08645930278636438, 0.11632608944734624, 0.08820184507727136, 0.11738239273144369, 0.10412466598948289, 0.10475584653665371, 0.09406305751147337, 0.13571543834995392, 0.18479632717459415, 0.10040938074387229, 0.11177790224160522, 0.15908973216296785, 0.13872233956388247, 0.13681222450666153, 0.14397253583617298, 0.1355251586581271, 0.03353087801806809, 0.039728359588502515, 0.009459882499392558, 0.05090649337858599, 0.057858596568372334, 0.0014953985383941992, 0.005323893874958796, 0.0029330872759663063, 0.007004839721286182, 0.0008583989526974589, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006818828881766437, 9.999999999998899e-05, 0.02461476541595453, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06187178072281063, 0.04218370146230932, 0.07546641231016549, 0.06757902914122094, 0.10096502819498188, 0.02265366236603783, 0.04404422254373075, 0.06015359700598222, 0.04461119847544781, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.018831659945279355, 0.016661985242780397, 0.004273950378810842, 0.006438110866271551, 0.029672169188050046, 0.018399758488190532, 0.016222486718918128, 0.017039431878921985, 0.010161819315063436, 0.16671730715397282, 0.18299788210292134, 0.1833160358546846, 0.2434455856046931, 0.2834868286246608, 0.21545208572147645, 0.17235487586627463, 0.16946114154186487, 0.20861306360169551, 0.05811674878350004, 0.044598413861813624, 0.037565214373878386, 0.05150587714337984, 0.03956579751666578, 0.05429487847601355, 0.05170870669200045, 0.050919214370716004, 0.03873158714469316, 0.1277897416191609, 0.15516193348853868, 0.1394139364919934, 0.15839798038699882, 0.16103019953734365, 0.13827444106535935, 0.15865132392637682, 0.14315179421657542, 0.13476502065218177, 0.15601505991863052, 0.1663627329599887, 0.18177019170565778, 0.1422626123904691, 0.14800159536724788, 0.1549866360083264, 0.15875303574029254, 0.19482562502579204, 0.15187246127012188, 0.09841861174595812, 0.1069028334917308, 0.11652630812981146, 0.09872781878260939, 0.10183243217174276, 0.08570601086445517, 0.12213218924841152, 0.1414584721259311, 0.13673928060175244, 0.13536620471750416, 0.1440743249723644, 0.14592279991127421, 0.15856430930792254, 0.1574821891675825, 0.13101658136472183, 0.12612163102447282, 0.13032310758222598, 0.133380829236605, 0.09168701102610033, 0.13012965544110588, 0.10748371433397241, 0.09968200401951477, 0.12997875150841465, 0.1334835484003266, 0.11392307597825369, 0.12156480900408628, 0.07464494657206178, 0.13963126010765337, 0.3163167373442267, 0.15747325934780254, 0.1650023623903789, 0.16957690329651431, 0.20617307543896357, 0.1523938192598182, 0.15674616241193795, 0.1551396700320805, 0.15197070063171614, 0.1685962427822384, 0.19065379688713435, 0.14723023960307602, 0.16914566902615535, 0.14988216232783902, 0.16217059525212696, 0.1380151647584369, 0.2368279347774418, 0.1823841281634735, 0.17155950746514537, 0.1792074749630056, 0.18311096022642082, 0.16480094672055168, 0.17346824460796584, 0.18362738010443014, 0.19777767891244014, 0.18717130548539973, 0.03446856630209372, 0.04306869440844219, 0.041526172315636156, 0.04153682126658842, 0.04714340724608479, 0.042844408871799855, 0.03749912906561459, 0.04692500637550079, 0.03997930446662179]}, "mutation_prompt": null}
{"id": "665546bc-6a8a-4c4f-8a03-a1c80f1268da", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "565e5671-bb9d-426e-b8bf-fb893f8aaa22", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "20097614-5056-4951-8317-0a3e6ae99c21", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "7272088c-4a36-4a7b-9323-b82d30541b1d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(120, 12 * dim)  # Updated initial population size\n        self.population_size = self.initial_population_size\n        self.base_F = 0.5  # Base differential weight, modified\n        self.CR = 0.85  # Crossover probability, modified\n        self.convergence_threshold = 0.01\n\n    def mutation(self, population, generation):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.base_F + 0.3 * np.sin(generation / 10.0)  # New: Adaptive scaling with generation\n        adaptive_F *= min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(6, self.population_size // 2)  # Updated minimum size\n        else:\n            self.population_size = min(self.initial_population_size, int(self.population_size * 1.5))  # Updated growth factor\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population, generation)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n            generation += 1\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive scaling of the differential weight and population mutation for enhanced convergence speed.", "configspace": "", "generation": 47, "fitness": 0.19650385196555384, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.17.", "error": "", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.3440492921360182, 0.34772244155864795, 0.4067880422583324, 0.45680313021668284, 0.39405753951722766, 0.3110636940203114, 0.38698686875558674, 0.3367624625927066, 0.3972746645387648, 0.21966033424965803, 0.18968351048673004, 0.18362056290346696, 0.21806501201559314, 0.16214246073730643, 0.20351560368904065, 0.14517354291348106, 0.19982079422661347, 0.1864378093490079, 0.1362934467589132, 0.25661541391004217, 0.1428882396463811, 0.27113805129654334, 0.20363382535898988, 0.14316260126906533, 0.13557949588883278, 0.20030973395286533, 0.2052739386976652, 0.11274574604233134, 0.13055895712968335, 0.1438359542513461, 0.14383803530678163, 0.13036683401358629, 0.133621819730678, 0.12639690191919617, 0.18245685129751932, 0.13562928741500568, 0.9188667688602543, 0.8560360750412601, 0.8808786372844692, 0.8911181715733364, 0.8964459349022628, 0.8571647691867232, 0.8729616507749471, 0.8453534680072807, 0.8856455504606371, 0.20005093055533218, 0.10927167056143539, 0.12721471023667397, 0.13105601826069957, 0.13773580015972875, 0.07827273547648161, 0.11117682481671343, 0.10935694990061251, 0.12492217687021112, 0.31469700120165145, 0.22556777462709376, 0.22565053608893781, 0.29955608640673004, 0.2784360657226682, 0.23912849718910167, 0.3033930653635154, 0.5262511662637956, 0.24956736002367297, 0.11108050231147049, 0.13745670068042926, 0.12716091003918906, 0.11573529345751032, 0.11455690435298871, 0.11544831330507055, 0.11874846828359387, 0.17887663147671518, 0.15709341846879854, 0.15658509539205112, 0.1081012845658077, 0.137955810281853, 0.14771436823127881, 0.10643554135793898, 0.11859686161428185, 0.10584434510249408, 0.10648661049700914, 0.11233436650286988, 9.999999999998899e-05, 0.016092596693771166, 0.019506095471353402, 0.049081101364058854, 0.04641346077170294, 0.023316985778382926, 0.011424046096201734, 0.05692151728541306, 0.026792606882836245, 0.13594240050514383, 0.1370163660305148, 0.1279207825563079, 0.09421224558024754, 0.04248228056649861, 0.054808513530055225, 0.11693649313784715, 0.09746703142084534, 0.13827721574988516, 0.031813160185998446, 0.022858784687136535, 0.021103629615134012, 0.023266437457383993, 0.035258538217631585, 0.015174354773117793, 0.05833154334824653, 9.999999999998899e-05, 9.999999999998899e-05, 0.11980603934264222, 0.07523181425594105, 0.06799754731491792, 0.08716071958013838, 0.09253572616193939, 0.0803038779831986, 0.07696977116953241, 0.0936567665327217, 0.07294209758883785, 0.35811529686184584, 0.3261692600676539, 0.3741752253663996, 0.37162631411846936, 0.34280991950133066, 0.35774465786896603, 0.39659335198977663, 0.3829610567024584, 0.3798806465213014, 0.09791244861521775, 0.1373261864710159, 0.09686865574768255, 0.08866122670800902, 0.09562879378206524, 0.09900995163840165, 0.09524544817039315, 0.10510834786352441, 0.07879726174311796, 0.15618820001065503, 0.11835068942072213, 0.14556417167009572, 0.13766266535167793, 0.14405509959643137, 0.14092810008715184, 0.13624448610766982, 0.13131008612594508, 0.12410842809265832, 0.23065046729769378, 0.27599489444810676, 0.28506618844667075, 0.2282894118018125, 0.2688457696274785, 0.25108598848966435, 0.26822228368771306, 0.2664376705707464, 0.2758799795754199, 0.14630168352138795, 0.16319999690025833, 0.19202673778428203, 0.1984801561617755, 0.1916668029407962, 0.19297277088600806, 0.20799239576341844, 0.221695978871833, 0.17665082609956517, 0.19082947268677686, 0.1941201642960253, 0.18365817855038769, 0.1848191936570771, 0.17203256194770944, 0.18590746126195745, 0.18450159810299416, 0.16771731432453985, 0.18434475456590038, 0.2007645915763896, 0.19303568243572367, 0.22156632414403332, 0.3049405893517695, 0.20726205316717417, 0.19352825105126414, 0.21526227390284847, 0.18542118987752398, 0.1977960709255293, 0.20156367124086416, 0.15401743811482194, 0.15450182659321632, 0.2709392896177104, 0.21734942793344558, 0.2192765289923403, 0.15000268642368608, 0.14444653634690363, 0.15006962689404102, 0.15048930937060245, 0.13921236620609834, 0.14865603128075322, 0.14615249314858536, 0.17802082387432727, 0.13663664166810252, 0.14613482230024455, 0.15512963464431961, 0.14908092624917868, 0.18695426745360588, 0.17489017273687313, 0.17898459651085907, 0.19622685132169848, 0.18195574972036044, 0.1699967923388962, 0.18769327930646462, 0.17761330538161946, 0.1753378753207424, 0.07413828365819941, 0.06415235568003996, 0.06703504114282444, 0.06677574350595572, 0.07194680581460233, 0.07013856039299993, 0.07149415535112091, 0.06051110640578494, 0.0640100272930837]}, "mutation_prompt": null}
{"id": "0fbe6491-25f4-467d-a9fd-69b73777a1cc", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "f1931494-deb1-4c0c-b355-d053fe4ed88e", "solution": "import numpy as np\n\nclass EnhancedClusteringDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01\n        self.cluster_threshold = 0.1  # New: clustering threshold for forming subpopulations\n\n    def mutation(self, population, cluster_center):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return cluster_center + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def form_clusters(self, population, fitness):\n        clusters = []\n        for i in range(self.population_size):\n            similar = [j for j in range(self.population_size) if np.linalg.norm(population[i] - population[j]) < self.cluster_threshold]\n            if similar:\n                clusters.append((np.mean(population[similar], axis=0), np.mean(fitness[similar])))\n        return clusters\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            clusters = self.form_clusters(population, fitness)\n\n            for i in range(self.population_size):\n                cluster_center = min(clusters, key=lambda x: np.linalg.norm(population[i] - x[0]))[0]\n                mutant = self.mutation(population, cluster_center)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "EnhancedClusteringDifferentialEvolution", "description": "Utilize dynamic subpopulation clustering and adaptive mutation scaling to enhance solution diversity and convergence speed.", "configspace": "", "generation": 49, "fitness": 0.15601274681034497, "feedback": "The algorithm EnhancedClusteringDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.17.", "error": "", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.2979073508040375, 0.30456636956006244, 0.33135293688768486, 0.278359092038564, 0.3033317151804058, 0.29025558477281455, 0.28676827506428326, 0.3037845420414427, 0.2904265984130101, 0.007108126853151431, 0.026099631421972802, 0.042786138588807754, 0.014135991782753043, 0.021213528100497925, 0.026796338085625204, 0.02814198848666305, 0.010350111968988718, 0.008806710848272226, 0.059972445871505076, 0.08359075082418799, 0.06812043429874615, 0.07430408861398408, 0.07640830013068156, 0.06690496833660942, 0.0776810467705007, 0.07790804151600972, 0.06569807199985223, 0.0551746589015798, 0.06395903997359642, 0.057910212786346005, 0.06207020502759775, 0.04953104675474129, 0.05096690751537358, 0.06973543940395033, 0.05277343965243342, 0.05539217409611752, 0.9644179537691714, 0.8424952838681161, 0.8100403321940616, 0.873491136722298, 0.9173298839011534, 0.9166360636988027, 0.8896748263564476, 0.8373940506803479, 0.9634040307829402, 0.11993843106439595, 0.11643813184200791, 0.11140569226260699, 0.131480297498764, 0.1413997676988643, 0.16026442421423204, 0.10951712378722955, 0.11950675124893695, 0.14988326568103183, 0.25753880255510253, 0.18899417178102085, 0.20342180617255512, 0.23372497884582755, 0.2218417273472657, 0.21761181235065785, 0.2380313003995458, 0.18183269358252896, 0.27050970100565497, 0.07827023515059917, 0.07790641969966294, 0.07404147698544672, 0.07841619307754466, 0.0866152763370801, 0.07628892850576652, 0.10917409582014137, 0.09962381582144775, 0.08559743502862571, 0.07243544901489929, 0.11489082594292266, 0.08702761196673003, 0.07645841201474435, 0.08558835101180906, 0.08577182157596597, 0.07042834061977288, 0.07798997635938687, 0.0839868238495004, 0.0018787314842629854, 9.999999999998899e-05, 0.007789522097980783, 0.003406600218703315, 0.008505778965190114, 0.004182369560673749, 0.011227393442442946, 0.021632844996762657, 0.03377446155546837, 0.11010544390791799, 0.09281399169981686, 0.09588836697603997, 0.093664260428035, 0.10394370334738867, 0.11307507703905428, 0.08258468525884799, 0.09800695932046655, 0.11498348687864601, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00044376117467548326, 9.999999999998899e-05, 9.999999999998899e-05, 0.002415390072200929, 0.04282175757929596, 0.057956024683436747, 0.041990378199593725, 0.0565019607661581, 0.05045125479490564, 0.05895570513667969, 0.055298428372758446, 0.05701273092647352, 0.053220694627147846, 0.29061033063398256, 0.299175017149946, 0.2848124599695704, 0.28520520526781923, 0.28163284243049, 0.27173041654941954, 0.2989447166809004, 0.29057850999785473, 0.28792718550498597, 0.06809527723802489, 0.07559933890058801, 0.08412655833158555, 0.06388989599324957, 0.09169333626297171, 0.06407745994286884, 0.06073266243594766, 0.06988658741073706, 0.06055233648634295, 0.12497169581553957, 0.12401148727457034, 0.12155489918832629, 0.12025493669216414, 0.15292400868758738, 0.10798713552628325, 0.1494518021470782, 0.13461837306146118, 0.14876625495973672, 0.19081788028168334, 0.18919470932090576, 0.1945046812265634, 0.18404664241009028, 0.17881540379048189, 0.1902574439847725, 0.18454331761263254, 0.19235001281659658, 0.1746259377718714, 0.1436832863349473, 0.14235450178142073, 0.13573502536761628, 0.13077298475505028, 0.11570729677429603, 0.1258393082863688, 0.1419359151924151, 0.13304759726036486, 0.12099846159782013, 0.1796056003933354, 0.16794255677843462, 0.17089442955116463, 0.1955748674278509, 0.16342889702143804, 0.1621217001743427, 0.18187504396729226, 0.18637316478403665, 0.17320969663153374, 0.15186113712248184, 0.1693196390072833, 0.160335204638978, 0.17134130697843697, 0.16573098924741547, 0.15258077731960218, 0.17660900975701443, 0.17262532815174692, 0.16722838650988092, 0.16288469503128888, 0.13687584932786234, 0.17823500635420697, 0.19553727737647042, 0.14170501013583747, 0.14854578016290887, 0.147017356946606, 0.2273622558364895, 0.18768392544342327, 0.14791517221270556, 0.17586565848964053, 0.19346502288877154, 0.14426464039073295, 0.12204844897422773, 0.12883684254795935, 0.1377063376555594, 0.16694294400084653, 0.14510968213080944, 0.1875452959412629, 0.16838090880035939, 0.17602988346201764, 0.16788509078691605, 0.1925351041278125, 0.1885517398125467, 0.22651746536472417, 0.17388345500834768, 0.17956657749284843, 0.058575994161864986, 0.06289628248857337, 0.08637140391088127, 0.055376595489404434, 0.06194779868257161, 0.055601586382372115, 0.07565180427177332, 0.056199329412776944, 0.06117621998542977]}, "mutation_prompt": null}
{"id": "16730f79-8fc1-4282-bdd5-358ed5bf5f78", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.base_F = 0.8  # Base differential weight, modified\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01\n\n    def mutation(self, population, diversity_factor):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.base_F * (1 + diversity_factor)  # Modified: Adaptive scaling with diversity\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            diversity_factor = np.std(population) / (self.bounds[1] - self.bounds[0])  # New: Diversity factor\n            for i in range(self.population_size):\n                mutant = self.mutation(population, diversity_factor)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive mutation scaling based on population diversity and employ a convergence-aware mechanism to dynamically adjust exploration-exploitation balance.", "configspace": "", "generation": 50, "fitness": 0.1421979399190132, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.18.", "error": "", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.29833443861706344, 0.2637411119201274, 0.2853107012479854, 0.2767257888537651, 0.2959627242885259, 0.2843765247863367, 0.32629071111900176, 0.32221325682392477, 0.30283099927137413, 0.04404177078458693, 0.04523922664802471, 0.04191621592179928, 0.07819357188186116, 0.031562922894290524, 0.05777875489215134, 0.0396357597421404, 0.03422973843294008, 0.0414115940870845, 0.07002844479947778, 0.09177262327960856, 0.07535729240058098, 0.07994983068697148, 0.07374548958742744, 0.07114088887338454, 0.07278790751373998, 0.08379207482328765, 0.07820504714820764, 0.05484689552556066, 0.054201280798373386, 0.053027927399934005, 0.06123749860827754, 0.05858025086130869, 0.06151255890705831, 0.07295391912739468, 0.0645127335722222, 0.05172004152730225, 0.9348172403160371, 0.9218997000004385, 0.9185223575308785, 0.9126424321682829, 0.9494604512768606, 0.9395097855823964, 0.9242391248769326, 0.9561948630025844, 0.9395748704203517, 0.09790661905454856, 0.09853781216851965, 0.10024927539341333, 0.09161912612810408, 0.10560371808334967, 0.1198164853788497, 0.12601027893860317, 0.099980614910956, 0.10269750647064646, 0.12484856637479913, 0.1359368734214519, 0.13052149795173495, 0.1627971809511528, 0.14868520712118172, 0.14947607015178477, 0.1573187856958027, 0.1486460739680059, 0.16787290869243476, 0.04733731912499628, 0.032155523932655306, 0.04794525852332676, 0.043629425611854455, 0.05507754450460778, 0.05971685022822493, 0.05881395604832196, 0.045839097458106326, 0.054003747408407965, 0.07816880731710973, 0.033583568648814066, 0.04091527546416551, 0.04272329633506711, 0.04496337378097437, 0.05754391361727851, 0.032044147820893376, 0.040217403736039214, 0.019303674237550528, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.038867007273795884, 0.04967834509206004, 0.06185543848165942, 0.05959425674809904, 0.08102088859430912, 0.062354994838620725, 0.08246258814942065, 0.06636447380005683, 0.07071102156832598, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.021328073411709503, 0.02470287523785497, 0.014446637176319554, 0.02816748898057464, 0.013718538804491476, 0.013998961794888576, 0.030710989821155277, 0.025464073633553408, 0.02680729609759469, 0.23864706582106499, 0.27483197063585674, 0.279469306623081, 0.2688943113435902, 0.2688496389385546, 0.2665619065662711, 0.26722033596519046, 0.27632098953282624, 0.24328152063644182, 0.06276099162340776, 0.06580102983022973, 0.060215730814458635, 0.05529850702782657, 0.05140725274389424, 0.0597586545091231, 0.05583553667711638, 0.05543050063785537, 0.05816070181728317, 0.1304619494210716, 0.12753499579946492, 0.13566175488389987, 0.14970940819148215, 0.12939792993303, 0.13585825483352487, 0.12451771872636908, 0.12496720211627921, 0.1209934888561236, 0.1731125092487391, 0.17205447645827665, 0.1721597789912328, 0.1550456362913878, 0.1565329920657481, 0.15241207184159544, 0.18106579908281928, 0.18687967612920142, 0.17001036278256665, 0.11795647829576261, 0.11374711533270943, 0.12504077419535164, 0.10709546890761834, 0.10424094489262903, 0.09353244530597171, 0.11562263360533032, 0.12290702808876375, 0.12311215563172229, 0.17076549188699042, 0.14286470954579378, 0.14533544648084462, 0.15992977278425313, 0.16435428878407787, 0.19786107728204583, 0.15759810481238368, 0.16571607300437297, 0.180589310653249, 0.14828430667816317, 0.13974327249388263, 0.14432448698231415, 0.155775497426609, 0.14580064730486497, 0.14100416586942177, 0.14580955505010806, 0.1323182983403498, 0.1576878771204221, 0.15639682387460652, 0.13418709007158702, 0.14621881394733316, 0.14690478743240654, 0.14884417331862954, 0.1622456520152824, 0.13895135123845304, 0.16284947018229246, 0.14002992052984897, 0.14440139495122584, 0.13178903524804242, 0.1378149599071481, 0.10971014602674589, 0.13765729325855958, 0.13471021360196878, 0.16416814172624417, 0.16770630819835752, 0.15174842894441776, 0.17694297800916847, 0.19554724817424884, 0.178793101953304, 0.18904684333747457, 0.18350358563312041, 0.18824642172648487, 0.1817386923872356, 0.16538873803539378, 0.17902975627108664, 0.04644661633542235, 0.05247319399610928, 0.046960764282877765, 0.046748575463426256, 0.060070015101788554, 0.05472753630454841, 0.045774319090795657, 0.05519430107740464, 0.05305886971482665]}, "mutation_prompt": null}
{"id": "9faa7f45-77e8-4e9c-bd19-b8e48ca5c054", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "b7db2faf-0791-45f9-be57-d34add176aa9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "25a40b12-397c-4eb4-8035-4a1bc8351245", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "0c645a20-4f4f-4088-bb5e-82bfcbb1f4db", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "5ebe1319-146a-4cb9-b3c9-848b4bb08d4f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "07e2b093-fcc1-4a87-ac1f-3a998517c125", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        mean_distance = np.mean(np.linalg.norm(population[:, np.newaxis] - population, axis=-1))\n        adaptive_F = self.F * min(1, mean_distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive mutation scaling based on population diversity to enhance convergence.", "configspace": "", "generation": 56, "fitness": 0.19652264706234077, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.17.", "error": "", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.42710712205489487, 0.3657407050148618, 0.3470685332242378, 0.3459919478254948, 0.3655129188379419, 0.3489900766712237, 0.3712243817889246, 0.3571859356198194, 0.3459250083269362, 0.15017022023309057, 0.19773810737479958, 0.14110238557897703, 0.15476778985704387, 0.14806079037636954, 0.2659893162375686, 0.23517278188360902, 0.18324147973819138, 0.17100751457779773, 0.20062999781043045, 0.17340281509837818, 0.164402417624541, 0.1482380545167573, 0.13240447460207072, 0.17836281820300592, 0.17975767024274159, 0.1729624946548436, 0.19807031610641113, 0.1766500475679652, 0.13176766794656491, 0.13557860280539769, 0.11953568601753672, 0.1378169329416089, 0.133360055642195, 0.20304695506688564, 0.13486910550966436, 0.14620085349947476, 0.8839220324236031, 0.8841261746383806, 0.9151891602891672, 0.9187473721991422, 0.911871135917614, 0.8810728304627683, 0.8677962677450421, 0.9034975737929861, 0.8977595527176542, 0.10345517396598958, 0.10692946810884663, 0.11880639597394216, 0.21942043221482255, 0.1611523316991641, 0.17833349489120753, 0.09535029320710031, 0.11492085082385861, 0.09975922185102004, 0.2338785217688505, 0.2446827487312686, 0.2471116192815378, 0.1971501557688038, 0.3281174628797373, 0.33210726618637365, 0.2795531941821602, 0.2830263315984808, 0.3082533788475754, 0.11244599024714885, 0.10169671660620083, 0.1211387150178651, 0.14016423042366932, 0.13709890268493763, 0.1431196272856261, 0.12174565410447646, 0.13250596304191387, 0.11414159332729801, 0.12048528771050149, 0.10131038495048139, 0.12266396357474751, 0.1066331627001571, 0.11209381647131578, 0.11581692862641324, 0.11577770984345093, 0.11178559596116666, 0.1776630285497638, 0.054673357234808595, 0.054606269186654566, 0.04407279550056642, 0.06616757608766999, 0.06995589829833004, 0.0388936156709242, 0.08164776869068269, 0.08630733781065447, 0.019565819000554985, 0.15726112218161836, 0.20249337718075144, 0.14118468667472694, 0.16384263193358983, 0.14208354056713357, 0.12252514528565805, 0.16071219063953357, 0.19826949855737352, 0.20396911992976163, 9.999999999998899e-05, 0.05285766919777457, 0.0033151790156412675, 0.057115687135518955, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08029923352684232, 0.04573905238140974, 0.11089536755150387, 0.08938063339622782, 0.08894975230347013, 0.12277772083517047, 0.0838056331575584, 0.1514335254490654, 0.1272352695561434, 0.08524211894249878, 0.10649390826665162, 0.3362125220387776, 0.3581678411674736, 0.3353928735573971, 0.3431175215612958, 0.31806770921490146, 0.32495248120544984, 0.34913797531341817, 0.3640002804504533, 0.34737786910342006, 0.09673392829708027, 0.10687774153258056, 0.09185494442633046, 0.08364965316750572, 0.07273506311333022, 0.08130608696666675, 0.06834487828605251, 0.09344074065089203, 0.08270368135479644, 0.1343301475330314, 0.11817214418043509, 0.12495793193716997, 0.13363200086519933, 0.12001622937103162, 0.13048241370296287, 0.1356525668511377, 0.13151061759505678, 0.11492093468481412, 0.25109000139686055, 0.2165387336296295, 0.25523432069620733, 0.24044427929398993, 0.2326376720959007, 0.22664718721293853, 0.3007321646417038, 0.2682370801837817, 0.2643567536633431, 0.19186397377074005, 0.18568659914831043, 0.22739847219129483, 0.2437270326905695, 0.12968838735735133, 0.22800798906929187, 0.20214695041368358, 0.2284929857592206, 0.2059092274741463, 0.17310838768159353, 0.18795603527941263, 0.18079541686487177, 0.19233642810348706, 0.16690696411483896, 0.1721396281995916, 0.17984150833596302, 0.18780504071130577, 0.19857376625778866, 0.21309716343663154, 0.21920125929581913, 0.19438863559227482, 0.1997181574352691, 0.22080114580742416, 0.19260656321741776, 0.1675456788752947, 0.2696104688877141, 0.1907423037457634, 0.1395964011743639, 0.14706780943959186, 0.13893948166472325, 0.14201322251481252, 0.2231065149340914, 0.16298931628904478, 0.12212832185692202, 0.11623876429009339, 0.14550880539289168, 0.17096035413537425, 0.1932643106648122, 0.18965907360490497, 0.11353790666132646, 0.12354867032044636, 0.17063191686855939, 0.1367853387068939, 0.142752046469674, 0.1593936328984601, 0.1674701178097937, 0.17742107369974236, 0.17706204677768678, 0.17586167767395322, 0.17269126032920157, 0.177017907324432, 0.1665820985994666, 0.1807874631421622, 0.17836233536759105, 0.07200897141030016, 0.07473406615792477, 0.06151228051778723, 0.061724676700989356, 0.059874981218033696, 0.06929249712996222, 0.07003375109543974, 0.0678706533737784, 0.06919468307133414]}, "mutation_prompt": null}
{"id": "8b1e84dd-632a-4bec-92f3-5b6a8287aad1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "40dbb64b-e527-441f-bc89-ed98c20594b9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "e892107e-8270-4618-b884-f0fe09a9fc9d", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.base_F = 0.8  # Base differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01\n\n    def adaptive_mutation(self, population, best):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.base_F * (1 + np.random.rand() * (best - population[idxs[0]]) / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.adaptive_mutation(population, best_solution)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (best_fitness - fitness[i]) / (np.max(fitness) - best_fitness + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if new_fitness < best_fitness:\n                    best_solution = new_candidate\n                    best_fitness = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "EnhancedDifferentialEvolution", "description": "Introduce adaptive F parameter tuning and use an elitist strategy to improve convergence efficiency in Differential Evolution.", "configspace": "", "generation": 59, "fitness": 0.159176217710084, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.18.", "error": "", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.365821355523421, 0.3532861059055865, 0.34749462401560816, 0.4136160565428345, 0.4123069654713417, 0.3618287892467551, 0.4076665341202753, 0.38779147432176053, 0.35953728865814194, 0.12309565547469825, 0.13352595886204766, 0.1033861506864352, 0.09548177244830092, 0.08502370005686277, 0.10228918294478595, 0.11281035763721559, 0.11363041736474766, 0.0993773019471853, 0.07889878091323899, 0.08903802612212075, 0.08016304504085114, 0.09728399720300784, 0.08606131527085759, 0.08984254996503582, 0.08229067516322053, 0.08728345356207423, 0.09695327312110635, 0.0711511229093359, 0.07592484132479638, 0.07119791071319159, 0.07791435957943682, 0.07431410862422871, 0.0740971007451452, 0.07027617735614389, 0.06635507033004984, 0.06479831629375199, 0.9356814618695211, 0.9330069445437879, 0.8410532919259358, 0.922696331226045, 0.9001665855554247, 0.8907127343845018, 0.9269980726951289, 0.934366492068086, 0.9178684600548123, 0.13903937169432867, 0.1287012625538615, 0.1470003367947753, 0.12370928469407083, 0.12189082170221022, 0.13431056860664725, 0.12746828402184163, 0.1305899899064289, 0.14588024723300008, 0.174955920039086, 0.17273022128906612, 0.22234598405770845, 0.17792671525689585, 0.17685746841420968, 0.21485706801399695, 0.20668025129708545, 0.21448576332098623, 0.18968093707407674, 0.10166799810107419, 0.07303038367350623, 0.09626798062954711, 0.0690574096908746, 0.08604423348374057, 0.06768406417653228, 0.06683318854548703, 0.07773718048731004, 0.08823928020897587, 0.014144953927537784, 0.04331568697250243, 0.07183972231709068, 0.07966299564931345, 0.07927926807183283, 0.07410761385878706, 0.04653174343024935, 0.06768813728424172, 0.07429450749382904, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004457597059083107, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.054217401467700266, 0.1130503247402177, 0.08462694684272176, 0.07647475666074188, 0.09533300557842761, 0.05784008001114982, 0.07323825769637993, 0.04917803376046381, 0.05891869599581656, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03586312430390226, 0.03477081594055975, 0.033725862888223324, 0.028188222614820235, 0.04619037833366968, 0.03608676664756527, 0.04806747467634209, 0.0410263844190949, 0.028779841142876794, 0.29499240515047664, 0.29687148588587364, 0.30886251407423826, 0.3353327344824073, 0.33459355987978134, 0.3087747137188147, 0.31280004827395114, 0.3086447683312603, 0.29503021961948994, 0.07325561888330812, 0.06765276306060242, 0.0670573576834167, 0.07033472731854451, 0.06105507935814325, 0.0660269374368001, 0.07215906595849941, 0.07184158838390464, 0.0633480499982727, 0.12230624848698501, 0.12353567516357056, 0.15674347841370073, 0.1328350008102227, 0.12293619229906128, 0.12027647011573006, 0.12683171437348917, 0.12825332103428222, 0.12662497947657103, 0.18836600292251937, 0.18090236769361268, 0.187137918827609, 0.18937078424391962, 0.1744849494871743, 0.18378724436691163, 0.18275537275316112, 0.20734809716964409, 0.17027118521426143, 0.1158266220561931, 0.12368601558792158, 0.12031477257149148, 0.123105810017896, 0.12223935293076915, 0.11536307883077168, 0.1393750234016472, 0.13373469000866534, 0.12595817460483727, 0.17806448597338498, 0.1648362690512959, 0.17107294324762423, 0.15552254081636052, 0.1703411882650787, 0.2011591458167582, 0.15134829827230623, 0.16166397512070652, 0.16954739779433292, 0.15855030987843566, 0.16111556558300177, 0.16380192432565432, 0.15495134245044317, 0.17449867000039043, 0.1552348488710804, 0.16780254907352665, 0.1725471796124911, 0.1673190393495304, 0.16155821109451518, 0.12585185938967258, 0.15639870950566415, 0.14810865401895645, 0.1499264547375988, 0.1445893990555882, 0.15452354191937634, 0.1400338081094531, 0.16770972005557672, 0.14692561216658828, 0.14832440289351523, 0.1446335873621727, 0.11167710731977587, 0.10372765237586246, 0.169050681050823, 0.1319127971192402, 0.14513814928006008, 0.1621199381880699, 0.201199012299206, 0.1790185516812286, 0.18200548809706474, 0.17831734718138725, 0.1853086940683646, 0.17854226402645945, 0.16430495524253896, 0.1854337599368956, 0.18277589522438298, 0.0575798691029038, 0.05172684354566115, 0.052838816308401926, 0.060382130912630005, 0.06227085889738304, 0.05771123347474183, 0.06356279648946861, 0.05965897932377062, 0.07219838551903923]}, "mutation_prompt": null}
{"id": "a690837b-a59c-47b2-9a10-0425f7ef4ed0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "eb5d120b-786a-48e7-9cdd-0e0806b7135a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "1923af7a-29d0-4fd1-b9b3-b759983828ab", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "c746de8a-0f89-4f77-ad5d-1f629ebee9be", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "abf1b248-d5b0-43bf-8868-760ee083b677", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        diversity = np.std(population, axis=0)\n        adaptive_F = self.F * (1 + np.mean(diversity) / (self.bounds[1] - self.bounds[0]))  # Modified: Adaptive mutation scaling\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive mutation scaling based on population diversity to enhance convergence speed.", "configspace": "", "generation": 64, "fitness": 0.14931143670118324, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.18.", "error": "", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.3273893261402452, 0.3211809047624371, 0.31769840409871, 0.4143559434830393, 0.3782854169901563, 0.3664343041839143, 0.3362915713394047, 0.3556318891677239, 0.3387600022336462, 0.06200491420020249, 0.09215988569213296, 0.060981897581258604, 0.08413011394306091, 0.06992387308288184, 0.07728801145629749, 0.06888087725227998, 0.08395348616608023, 0.10334758534236843, 0.08276930768280999, 0.07844872916796919, 0.07178205723272657, 0.08117570280979325, 0.08070933506904499, 0.08777722446002756, 0.08725692620023495, 0.07569241369755841, 0.08105792167171566, 0.07390234584485966, 0.06263057289154783, 0.06606626742909705, 0.06148226196356876, 0.06479663030746052, 0.08394166602625519, 0.06298560240039619, 0.051953262674133804, 0.07415442812044604, 0.9154268343849219, 0.9157458217223577, 0.9184570214016822, 0.910245077877827, 0.9494602129007171, 0.9150844922565442, 0.9210792510098597, 0.9561915786387422, 0.9395934896744476, 0.11085794736943355, 0.10073408906506431, 0.11550426294182325, 0.12385928482853492, 0.12484314269829333, 0.1381608225371781, 0.13123794846996373, 0.14481383082374977, 0.15203946926664158, 0.1663748488904686, 0.15581475806631628, 0.12228871100519167, 0.17040921580437784, 0.17219671406492432, 0.16118559339390326, 0.15700777651016473, 0.16316944010893553, 0.1925270108464079, 0.07044606104042761, 0.09253649036904077, 0.07103197543918449, 0.10455552836509285, 0.08054179692608376, 0.0663122654608631, 0.05785919273030393, 0.0545407506296417, 0.08056295699091875, 0.08024126599911308, 0.018515383473657887, 0.018905264501618557, 0.05171911697423859, 0.053832886703313654, 0.05738814150726157, 0.03951927469279215, 0.04389821355971146, 0.034180941979611856, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009518630434066089, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0682013663286205, 0.047436046947097354, 0.05191691941369059, 0.04004730637165854, 0.0490316302565329, 0.04676868065155182, 0.07311251061191948, 0.062199517825805906, 0.08106462329989061, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013109918529711329, 0.021201106769091704, 0.017694662884963464, 0.03219019409446178, 0.023361494751364953, 0.04258192635487723, 0.026078012904619974, 0.030226957779510122, 0.024856692408139147, 0.26632445378702685, 0.26595796135889027, 0.2756503650255788, 0.28973907058247517, 0.29674779147310804, 0.28737631282745746, 0.26859846895334316, 0.27794681067055527, 0.2258454567882353, 0.06520727911143365, 0.0686721428512086, 0.07183945722924623, 0.056764357667712595, 0.05529221881675439, 0.056366964345454296, 0.052734892614619056, 0.06606124630102805, 0.06739626386707953, 0.1301416737030826, 0.13022114691358233, 0.12606810177965677, 0.15734032072485848, 0.12956576273372944, 0.13191980369434675, 0.1629960759549962, 0.1256338238740765, 0.12917935411788894, 0.17547306877446012, 0.17232036384706373, 0.18716975975946493, 0.16465246490260976, 0.14947354146431624, 0.15682135752434623, 0.19365573993366847, 0.1956854757192641, 0.18137782919375167, 0.11876472479456002, 0.11414258742986982, 0.1142933867359367, 0.1182357930978234, 0.10064447186931302, 0.1126886262977661, 0.12136459311056702, 0.11534632169932224, 0.11567152659499369, 0.1502000153440638, 0.17774214465059035, 0.14531578013429336, 0.152903345307689, 0.15004609169323435, 0.18009476372767463, 0.17533509404599923, 0.15758856961810563, 0.16198814728337296, 0.1598548931229551, 0.14036685178986974, 0.14774814098542288, 0.13914515051176224, 0.15399050994186125, 0.14164880033195715, 0.1396436077241655, 0.1345495609613121, 0.16805991171636436, 0.131781713054276, 0.13208138528274282, 0.15277622291923199, 0.14605892467173798, 0.15316457066349254, 0.15085018510071257, 0.1454725062734875, 0.16267453639792984, 0.13010795338267978, 0.14109481075551178, 0.13002355564143253, 0.14058372729709867, 0.10704040975505091, 0.1088443115412494, 0.13478891917475744, 0.1633665087918924, 0.16003328413445272, 0.16307078388547858, 0.1668955329438475, 0.19806115065723628, 0.19085128797917217, 0.18660398432245762, 0.17667247556006427, 0.18824642172648487, 0.18270795011250252, 0.1731538634105757, 0.17244074708234314, 0.05311412798740911, 0.052643612797788064, 0.058576098909531304, 0.05163988871890346, 0.05407169239588949, 0.04926796723705262, 0.05063699585211978, 0.05509996698607578, 0.04470624936128553]}, "mutation_prompt": null}
{"id": "13df9eb7-7185-4747-ab26-f8b45349e07c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "c1711bfa-3857-4b41-8a79-aa11cf41f709", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "2cc23878-bd61-4a61-9501-449708de7ebc", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "df3d2371-c71b-4bbb-9108-d8a09f5a94ab", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "54f8fa68-07be-4762-87af-158fdb92e80f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "8bae8210-f72e-4e04-a292-db3bcd42c884", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * (1 - np.std(population) / (self.bounds[1] - self.bounds[0]))  # New: Adaptive differential weight\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive differential weight based on convergence rate to balance exploration and exploitation.", "configspace": "", "generation": 70, "fitness": 0.19274450863671438, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.17.", "error": "", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.4212649065256322, 0.49595258057727454, 0.40472802811956665, 0.42225709359061514, 0.4192796545783686, 0.41903384572967206, 0.40886209990845834, 0.4187855228629275, 0.426822135393667, 0.21396808968778092, 0.18279364900108763, 0.1898881629653778, 0.1683739507553903, 0.1629436751004958, 0.16222701858137478, 0.21929563335169022, 0.21918306814329902, 0.2431759909985759, 0.1043600272473656, 0.09189675261972152, 0.08708616234536004, 0.0944232360387598, 0.10423064171419771, 0.09302807993053797, 0.10824750842448794, 0.09244288451088978, 0.08823866797792712, 0.08019765359655051, 0.08801451452869535, 0.0870919071207008, 0.08003981921337233, 0.0761265086950127, 0.0832768380644131, 0.08668866732301683, 0.09036443714930209, 0.08830013579328566, 0.8709294508282295, 0.8756162887661036, 0.8798390193139618, 0.9194204470057838, 0.8659214364172733, 0.8914066512855661, 0.9062644174058979, 0.91067639615271, 0.8540617785523448, 0.18188493754097157, 0.20668573117715305, 0.19780460098571606, 0.18703867944926578, 0.20011393704829294, 0.18563769771683902, 0.1819926542857735, 0.22610426814868556, 0.21617914698819574, 0.2121004692247831, 0.33959431768501436, 0.23856134176041255, 0.3387771932649545, 0.31723347543449176, 0.25237685711161395, 0.24735175069610194, 0.2507813254205392, 0.2589120852801343, 0.10786046055081588, 0.11160164582986476, 0.11079096615183504, 0.12394014414909671, 0.11074049847274148, 0.11589324244652666, 0.12861072281937214, 0.11543116871493675, 0.13089772511219977, 0.1047454006277565, 0.10971657281342484, 0.11058175381955082, 0.10484288828869393, 0.10497905580004152, 0.11828910315580199, 0.11336601768996701, 0.10327591715963702, 0.10364549590685368, 0.0495885162237264, 0.11202401037532617, 0.08010832394114986, 0.030206861028431176, 0.06363943298416375, 0.0633081202465402, 0.0597875403096918, 0.044483208290561516, 0.03317128534628555, 0.1621905935652932, 0.18363488556587604, 0.19866404934501514, 0.16448788590614205, 0.15830862852527716, 0.18106941322254433, 0.2099677329665074, 0.17742336962728422, 0.21727109234152397, 0.015335183705866284, 0.0043219615780027976, 0.004249253872765646, 9.999999999998899e-05, 0.002194294686982179, 0.0033091265742192233, 0.012765094700724844, 0.006969233052156798, 9.999999999998899e-05, 0.055172456408900894, 0.07870585735588065, 0.05941373978710618, 0.08096730976623079, 0.11343449049973608, 0.0880325746193461, 0.057372517249349775, 0.1258786900428046, 0.06207328606820284, 0.37557465040248295, 0.3650658048960662, 0.3573841811970866, 0.3762746289591451, 0.37370114322836767, 0.42047302670584685, 0.374333094819597, 0.3641731090735657, 0.3610482470077523, 0.07530647780559752, 0.08364660211082464, 0.08398510414533722, 0.07840320999742467, 0.08112737729670494, 0.08033305611472263, 0.0696479615968052, 0.07542339890368543, 0.06939943050232955, 0.1621554585149504, 0.11522282870820633, 0.16790513433829768, 0.1358922918258435, 0.11946451032217831, 0.12348901206239238, 0.1192613009555813, 0.13051824365925135, 0.14111855342941448, 0.2179446991970858, 0.21903211725029836, 0.22286830409245129, 0.18886854840496448, 0.21453829685347625, 0.2010259546549179, 0.25573216732609416, 0.24084719866713744, 0.24357460335826198, 0.14977485602535456, 0.15144609060681946, 0.18162175924582225, 0.1457857498327354, 0.1557335539454895, 0.1595881221763511, 0.1681069022714884, 0.1664009051923906, 0.163701999603462, 0.1704228125985039, 0.16831219525022956, 0.1969066918007124, 0.16679554778873584, 0.17185111786834828, 0.18896721029298558, 0.18102376360086136, 0.19069184950716422, 0.18583426944985526, 0.1771959289337709, 0.1705575436194513, 0.17154111183565912, 0.1751912520506217, 0.16891153070894704, 0.173488685206724, 0.16496504952639512, 0.16544874054830394, 0.16761538170061008, 0.16663933207954618, 0.1897670900418854, 0.14721721363018148, 0.2010996646006834, 0.1943490458404622, 0.24081255142245772, 0.18304640304825592, 0.17214984355854335, 0.17099786545298734, 0.17631071529559883, 0.1428642529949521, 0.19578818222694383, 0.1413063932237385, 0.1391630984901644, 0.1601363989882011, 0.14635652352800643, 0.1596621543952682, 0.1691306352941463, 0.1632344612558282, 0.17478643975060348, 0.17581128898738752, 0.176120850433228, 0.17458210691627718, 0.1924101153673471, 0.17387746886785316, 0.18611590420611368, 0.1875991385676774, 0.05562876243388215, 0.07083854898225983, 0.0688919838154941, 0.06420907519983232, 0.06286284198489844, 0.10200015200206547, 0.062690638309435, 0.06546647902177105, 0.071155193344004]}, "mutation_prompt": null}
{"id": "4ab64745-6fe8-4681-b106-13c6cbbf4bea", "solution": "import numpy as np\n\nclass DynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F_min = 0.4  # Minimum differential weight\n        self.F_max = 0.9  # Maximum differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01\n\n    def mutation(self, population, diversity):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = (self.F_min + (self.F_max - self.F_min) * diversity) * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            diversity = 1 - np.std(fitness) / (np.mean(fitness) + 1e-10)  # New: Calculate diversity\n            for i in range(self.population_size):\n                mutant = self.mutation(population, diversity)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "DynamicDifferentialEvolution", "description": "Introduce dynamic differential weight scaling based on the diversity of the population to enhance convergence speed.", "configspace": "", "generation": 71, "fitness": 0.19022617392621669, "feedback": "The algorithm DynamicDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.17.", "error": "", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.3415285082148304, 0.3043732394759343, 0.32309327117155306, 0.39011979792068696, 0.3334011215824616, 0.3347292270762535, 0.3687944641218953, 0.2934303121013949, 0.3386586751683516, 0.11733004487504095, 0.18264061876738935, 0.16715108389962474, 0.19941749363496564, 0.21249121440692798, 0.1646118279795279, 0.1966596561808316, 0.12995077089544316, 0.16867123315348087, 0.16159728239602977, 0.13712309840670478, 0.16107549288537648, 0.2033421400435821, 0.19585507648825007, 0.2299327982741597, 0.12086560959601578, 0.14112789417444072, 0.2371033723547571, 0.11786259211946615, 0.11067342976340566, 0.0677579841758097, 0.13796096290910032, 0.10701110627191324, 0.07851049740795135, 0.1352056548181214, 0.18894609399248052, 0.14365856233641094, 0.8805277848608931, 0.8697243565239352, 0.892473068783429, 0.8771715685784934, 0.9135254806333976, 0.8968799418311726, 0.8913331945942221, 0.9076509046810203, 0.8808567764806436, 0.15856208787417347, 0.130620314860464, 0.1665789012058111, 0.13462314819677335, 0.13848750863887527, 0.13544381064211375, 0.14041757128948396, 0.16229685842803754, 0.1642891673401502, 0.3117198823777664, 0.210797580727641, 0.20021157191962835, 0.1645207359727443, 0.18067147893966462, 0.3122955667991645, 0.33754869564667533, 0.16877700782348437, 0.22177285020195892, 0.1313249020323286, 0.1002320017692857, 0.11074076657655874, 0.11963612436728144, 0.10827578538443083, 0.11240027241182782, 0.17409171975860083, 0.15254237495526757, 0.18823430314201683, 0.12119063849482592, 0.11888137536489407, 0.11770307620565779, 0.11552000073694546, 0.12296011966783515, 0.23076719726182493, 0.14132332525692914, 0.13070810498896956, 0.11536547601797797, 9.999999999998899e-05, 0.02452990748169448, 0.11587293389395914, 0.028706652038379965, 0.014292326844025038, 0.010397608889397447, 0.11000505332818789, 0.017180808426817795, 0.022408470625614796, 0.19892726915156123, 0.11553014178148702, 0.05184983523655917, 0.10683091050504423, 0.11967346146506008, 0.07504847901021461, 0.1017012438114252, 0.06882004141864273, 0.09070039909779193, 0.02593525540905628, 0.01250125830787363, 9.999999999998899e-05, 0.008795237339526474, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.032231107163655404, 9.999999999998899e-05, 0.06875077116393513, 0.10111489733733292, 0.07169913853809462, 0.08831791633420583, 0.10462095560979046, 0.11594047722168166, 0.10593127059642471, 0.10365268958883955, 0.08490799857545828, 0.3207970799112011, 0.31273565655458735, 0.3414028258674815, 0.29601232197027316, 0.32727770971563197, 0.3861837489700145, 0.3607538684100082, 0.33834406671404926, 0.3357834325903494, 0.09768385262791557, 0.13793009498902398, 0.09524383171442574, 0.07483657716530157, 0.09874418272727381, 0.09356213804659397, 0.06283741359409378, 0.06856778709643818, 0.08555668758643842, 0.13405274578747173, 0.11566192217221538, 0.13379174893745016, 0.13958808418321844, 0.1258602910297696, 0.16799362627596126, 0.1449488985002907, 0.11335415277102745, 0.17867623721860804, 0.22340486073304555, 0.24589601363023672, 0.2096558277068148, 0.2505288733811196, 0.21384011994590768, 0.2338089753154472, 0.24866017280028652, 0.26739511636085567, 0.2754030385599825, 0.17517387869619871, 0.2150905398086237, 0.1818303152169819, 0.21264854776262332, 0.21485395227324278, 0.17201945246384787, 0.1874888321806749, 0.21975694742920093, 0.1704326497258185, 0.15804650078077687, 0.1687485789895381, 0.1792660383175002, 0.1789438482953568, 0.15574642271295103, 0.17445635161569295, 0.19154774582002376, 0.17000785174741162, 0.17221277780943456, 0.25075639647794445, 0.19644529955795687, 0.19135970864805318, 0.1960711848111244, 0.2031625349238746, 0.191812549800222, 0.28181350966930263, 0.1880855893488217, 0.24080990539966474, 0.21438238802275467, 0.15595309001490532, 0.22049446513863646, 0.2586704172225426, 0.15767910075458802, 0.2769841818379849, 0.1357288996541267, 0.1519099020989233, 0.12576191454750496, 0.13931837230620459, 0.14914986093616522, 0.14734591234291217, 0.17022739846870316, 0.1770830287669778, 0.12884812438323168, 0.14619520610502712, 0.1806832221052158, 0.1389124035765682, 0.20354320899420641, 0.17309672668881848, 0.18454065617909365, 0.1880273291907364, 0.17266554805746415, 0.1748984659058147, 0.17758218095822287, 0.17194644599884068, 0.17846402213639445, 0.06230946646936919, 0.0662112311906099, 0.06378151543654453, 0.06564734701342823, 0.06359924760190205, 0.06513664558494947, 0.06293174942704172, 0.07387104974459613, 0.06809884588054027]}, "mutation_prompt": null}
{"id": "3510bb97-fe40-4349-93f6-01776ee4819a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "01332d03-b4c3-46f0-a124-9119f7e1de08", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.scaling_factor_decay = 0.99  # New: Dynamic scaling factor decay\n        self.stagnation_count = 0  # New: Track stagnation in improvement\n        self.max_stagnation = 3  # New: Maximum stagnation iterations before boosting exploration\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        if self.stagnation_count >= self.max_stagnation:  # New: Boost exploration on stagnation\n            adaptive_F *= 1.2\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        if trial_fitness < target_fitness:\n            self.stagnation_count = 0  # New: Reset stagnation counter\n            return trial, trial_fitness\n        else:\n            self.stagnation_count += 1  # New: Increment stagnation counter\n            return target, target_fitness\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                self.F *= self.scaling_factor_decay  # New: Decay scaling factor\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "EnhancedDifferentialEvolution", "description": "Introduce adaptive mutation strategies with dynamic scaling for improved balance between exploration and exploitation.", "configspace": "", "generation": 73, "fitness": 0.10869740797047964, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.08.", "error": "", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.26246354575399367, 0.24156090251351292, 0.24222531450363294, 0.2234738638721694, 0.2621972496162558, 0.18558853478619997, 0.195627687007356, 0.1482302041703466, 0.21398877132956007, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12885874796733987, 0.09243546540355896, 0.0877346540388011, 0.10096556507062415, 0.1054216281180177, 0.0768080873428777, 0.09204690212281763, 0.08552987824100367, 0.07948090413126119, 0.0708413261992551, 0.0672581468319684, 0.09416272487554944, 0.07979189251612073, 0.06138432775295055, 0.05815992765087685, 0.11083781431649753, 0.10446674207740103, 0.06785095433967203, 0.21704904376838163, 0.17257729081745854, 0.18453167972326567, 0.20664003542579001, 0.19371827077866144, 0.1885959107604891, 0.16490409497515135, 0.14976565686900378, 0.1968622914067233, 0.08798912069185116, 0.048636294887541176, 0.06583809845963606, 0.08622651201004972, 0.07769349306072582, 0.060343362340859685, 0.08790766657709081, 0.06459871091891878, 0.14687766386189127, 0.16152569796183303, 0.17625636592744798, 0.13855642864514395, 0.1610703797736669, 0.19433903178753686, 0.10305628023077407, 0.13853354924863903, 0.10074914448203909, 0.21251082039495928, 0.03949622161345556, 0.01403393417042098, 9.999999999998899e-05, 0.02811481164823293, 0.009183479469745737, 9.999999999998899e-05, 9.999999999998899e-05, 0.024461304369165382, 0.012536417167018588, 9.999999999998899e-05, 0.008790972421606091, 0.024015500317708938, 0.00306664196564721, 0.022574317000184196, 0.035948326336141645, 9.999999999998899e-05, 9.999999999998899e-05, 0.008316034452182652, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07447894508875907, 0.031375914588802734, 0.07910007648206141, 9.999999999998899e-05, 0.06025233026068233, 0.020889284860893698, 0.026915356084975084, 0.07269532339971196, 0.05757465340792567, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02626328435631964, 9.999999999998899e-05, 0.02732446477056416, 0.0020432532352295807, 0.012726256429692384, 0.016516393612206914, 0.0076054603022143175, 9.999999999998899e-05, 0.01642838050338835, 0.16474146233283604, 0.3473947171663265, 0.22896638924704027, 0.20017547671558455, 0.18337361442448086, 0.23203340895039126, 0.3145948235881788, 0.2491081609766419, 0.2214782452286278, 0.06564233390838037, 0.06778152501021306, 0.05603811048036966, 0.05439772477168714, 0.04624878676043431, 0.06752462953384708, 0.07109200277970051, 0.05005273520434239, 0.08142188646210502, 0.11494683302988051, 0.16514337664301437, 0.145459191604553, 0.15307451606040645, 0.13744188411751368, 0.13860087755657247, 0.13538089625937066, 0.1364864435410471, 0.1655492670401234, 0.1670233442015171, 0.24947193823829483, 0.19821127999296317, 0.22650480378747484, 0.23023967530962441, 0.1928217824142231, 0.19993178558332625, 0.22059391180322396, 0.19512412011986646, 0.1081649648679811, 0.11616405264254681, 0.14486027697631576, 0.12486202682566494, 0.12274415897708169, 0.14649408195095892, 0.09376188819128639, 0.17274549888073365, 0.16296609418271069, 0.1721615758621463, 0.19413450007333288, 0.1738738437772961, 0.17153840537097131, 0.2160520059196509, 0.19136678230137105, 0.16357597722166572, 0.209807036555547, 0.19257514464512027, 0.16471636164580172, 0.18312016100453243, 0.15763873917527693, 0.17190950132723903, 0.14510115511253496, 0.14650499706743636, 0.1555822472611731, 0.17650635173883567, 0.04003067286659301, 0.2705697473496771, 0.16331035917937164, 0.14121113110589956, 0.19054438395019602, 0.2700311399287757, 0.20981898184800807, 0.14840054013110926, 0.20905421880073194, 0.15226540791964194, 0.19758644639106093, 0.15167240907222346, 0.12417280895127647, 0.12389238475779563, 0.10993374322667915, 0.1557461584259343, 0.09478173081086494, 0.1980824783185281, 0.1326179204705702, 0.16871265839433414, 0.1832499262003393, 0.1672133154390152, 0.1782246201448866, 0.16740748143122075, 0.20383261934492913, 0.19342759650628383, 0.20019774656144218, 0.17630515256684998, 0.07088188536273043, 0.07632883606027774, 0.0648681090814276, 0.06118761264053463, 0.07361450499127076, 0.06824321689784596, 0.06662666081714275, 0.06500227565409789, 0.06352145297455225]}, "mutation_prompt": null}
{"id": "05162c0f-e95e-4693-8b84-7f0eb9168fb2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "1cbb33e9-8820-466a-93fc-8c62083f914b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "6abfc189-bd36-4eaf-9c20-8b9cee947442", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "d4ab6bde-6bc8-4125-a2f1-a8a63cb6f3f7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01\n        self.diversity_threshold = 0.1  # New: Diversity threshold\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * (1 + np.std(population) / (self.bounds[1] - self.bounds[0]))  # New: Adaptive scaling factor\n        adaptive_F = min(1.0, max(0.5, adaptive_F))  # Ensuring F remains between 0.5 and 1.0\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, population, fitness):\n        diversity = np.mean(np.std(population, axis=0))\n        if diversity < self.diversity_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        elif np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(population, fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a novel adaptive scaling factor and dynamic population size adjustment based on diversity metrics to enhance convergence speed.", "configspace": "", "generation": 77, "fitness": 0.14302789900434887, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.18.", "error": "", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.3378002507026623, 0.2865271389822963, 0.3282870362171513, 0.2979092137254452, 0.31419848322737, 0.32661085869682005, 0.3264280986459158, 0.34299289590485693, 0.3270422735492148, 0.06902337944736114, 0.06353321965466441, 0.056906215861687426, 0.03440185507914362, 0.04354447204148004, 0.06504375983101984, 0.06232840575158194, 0.056176951797711094, 0.04329167849068705, 0.07544824477479961, 0.08081468692579996, 0.08157806130512202, 0.08191577932244998, 0.0770752097656261, 0.08139077448844234, 0.07803820406218731, 0.07810848514936464, 0.07974102723491816, 0.05987605453310407, 0.05227137355577838, 0.06349207210807128, 0.06378478901279594, 0.05852015951074285, 0.06060570306301283, 0.06291219115276914, 0.06479414333307831, 0.05597820667236153, 0.9260168125124809, 0.9037540099526924, 0.8968918966761154, 0.9500663463267964, 0.8924638146066184, 0.9141793020577454, 0.9286898681412566, 0.9343457349462256, 0.9403263406967437, 0.11103489820009149, 0.10696445116576037, 0.11428438017775389, 0.09124682885479019, 0.10880654583445049, 0.11575670275673178, 0.10644934513012927, 0.12398149088123411, 0.10551181957205535, 0.1654080054667827, 0.1353525017811198, 0.1485256506138306, 0.169355971260437, 0.16158432626679875, 0.15730642090348135, 0.14855196634959233, 0.1540477443612246, 0.18368438858917446, 0.04493266344872304, 0.032388614687172246, 0.04592302402236437, 0.06651577294077815, 0.04538124857379444, 0.03336514618320108, 0.04995852134603973, 0.037303838388663135, 0.04645510741665693, 0.00933920230689711, 0.008754962975844993, 0.018130762051932425, 0.03693111712672781, 0.050398921037716926, 0.03526817202413679, 0.030841258812012717, 0.021276490620730004, 0.029966321033996768, 0.002107568894791023, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0537560820334444, 0.06629798301810497, 0.05561763855841673, 0.052725155257579925, 0.08351167027095685, 0.04826789577886137, 0.07168110824019147, 0.06345918636117909, 0.07608953807699814, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.014722978864883607, 0.02311208133271414, 0.01941960318104141, 0.018214873460766112, 0.01782724282588899, 0.024575482066305776, 0.04771313947686939, 0.03098826564530277, 0.029448034524360622, 0.24797442060663655, 0.26186072954664974, 0.2555875610686744, 0.2744586217460937, 0.2829384865257917, 0.2759559829332422, 0.2586166087180525, 0.28946688510192986, 0.23085447025815597, 0.06315506787443592, 0.05254863901918083, 0.06827869379019735, 0.06651633372583543, 0.06259599537628724, 0.06498547524112941, 0.048602735398353025, 0.05476868983818617, 0.056994442463244144, 0.14410305035513116, 0.12668619583303065, 0.1523023507478778, 0.1350785816004001, 0.13831021189223425, 0.12708697983504047, 0.13430575060839367, 0.1282187930905535, 0.13002878410366125, 0.16504953518008136, 0.1696331255142831, 0.19396524050857678, 0.16653679298749047, 0.1587135322372769, 0.16038366103692991, 0.17763417471949194, 0.185668603523913, 0.19441874808746673, 0.11471479412633523, 0.11364093997867819, 0.11001125445510496, 0.1287158103729069, 0.09346371794702357, 0.12067576084652265, 0.12216653193314653, 0.12394439369095211, 0.115146298293058, 0.1542437157820541, 0.16787252118600804, 0.15434863675999444, 0.16155059132186922, 0.14868711037160953, 0.16198968244430945, 0.15309400461634703, 0.17018970817485257, 0.17455123342077583, 0.14212207634478724, 0.15483557641807766, 0.1562703449148627, 0.15249913802017523, 0.13868450804857735, 0.14812410140957544, 0.15120799627767012, 0.1488279270529943, 0.1562047834398138, 0.1598845382633608, 0.13857728575386885, 0.13983377869505387, 0.14235751684081044, 0.15105646853958932, 0.12339837590059122, 0.12699997174050404, 0.1620329992161771, 0.1219184402864063, 0.14106182266844502, 0.12741141257641042, 0.11700015783405215, 0.13576738199344696, 0.12955980346987706, 0.12051964752496003, 0.15432519812316148, 0.15963881934497803, 0.16482988498950157, 0.18347457972479708, 0.17218487888908218, 0.1709749472440233, 0.16743722640385128, 0.17889635495676937, 0.16695310651605488, 0.1837011133339752, 0.17488180761663574, 0.17799474400479298, 0.05061026287307813, 0.06139514191201523, 0.0554041854961177, 0.04914633262736823, 0.05546698972553332, 0.054305326316262836, 0.051045422649037886, 0.05176356360792833, 0.05280399801319058]}, "mutation_prompt": null}
{"id": "cb3be4d2-059d-4d7c-9a40-d49de2563425", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "018b0351-8d37-4400-b612-d6eeff6bb19c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "b43a6bed-ca5d-47b3-ad0b-cc95ada6a4c6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.convergence_threshold = 0.01  # Threshold for convergence rate\n\n    def mutation(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        distance = np.linalg.norm(population[idxs[1]] - population[idxs[2]])\n        adaptive_F = self.F * min(1, distance / (self.bounds[1] - self.bounds[0]))\n        return population[idxs[0]] + adaptive_F * (population[idxs[1]] - population[idxs[2]])\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)  # New: Adaptive crossover probability\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))  # Ensuring CR remains between 0.1 and 1.0\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive crossover probability based on fitness improvement to enhance exploration and exploitation dynamics.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.33120139688733585, 0.3677671159162079, 0.32738938017112973, 0.36821031708816854, 0.30357321242918944, 0.33415107663263344, 0.3800713216051479, 0.29603851886787425, 0.3713472842845863, 0.1817130681700917, 0.17256164427119314, 0.1701518020063193, 0.17333860470867746, 0.1390884316757478, 0.19741818837837932, 0.1379999710912625, 0.19076246344872994, 0.21206736662784298, 0.15386030043599108, 0.16955500572787063, 0.1525666907181381, 0.1741200827396664, 0.21323486085416, 0.16427124156847772, 0.19998192981991247, 0.18920405343141689, 0.20741182634504463, 0.20423784606723983, 0.11733893957907526, 0.1392291094805549, 0.13795574585736958, 0.1722377314276744, 0.15927376067532384, 0.12264191255214152, 0.15751228390511096, 0.12578631951849384, 0.8984494260285751, 0.8835609255600225, 0.9071954554536896, 0.9183711313209101, 0.9020457785616789, 0.8998297962865077, 0.9017109973243638, 0.893959980108502, 0.9278027874998547, 0.12769995037760196, 0.12484268170634683, 0.12947113848644598, 0.1548350961093602, 0.1284865795215363, 0.10680604069784494, 0.10027551075856045, 0.12586257060795147, 0.0945636512030007, 0.2552666779570617, 0.27055391781011373, 0.3148096686721771, 0.19350530465655114, 0.28862178819528317, 0.19486614422839876, 0.2957728313813309, 0.6893409510917956, 0.2841973251227923, 0.1480633690594887, 0.09527452545680715, 0.11970863183822034, 0.09815311025491624, 0.11075186025852612, 0.10189111365643999, 0.15483270259229032, 0.12244459638988503, 0.10724151296095208, 0.09672831712951668, 0.06479099742565664, 0.10493962212762542, 0.11091107135037492, 0.12614944783077442, 0.11289542196944635, 0.12184138745976358, 0.09773695476459432, 0.09678971302080774, 0.06201691188652381, 0.032783183399842764, 0.06762982975661003, 0.039836170217635525, 0.03624341088212846, 0.11081170444025068, 0.09871805769492348, 0.05625016772059077, 0.027022729071967455, 0.14207237035879938, 0.14547234270451848, 0.18308919933419965, 0.18995870541085735, 0.1778640953020535, 0.18194790678793515, 0.1813428685380879, 0.169371975590354, 0.16176397844412893, 0.019030273395197583, 9.999999999998899e-05, 0.045202288157642045, 0.004199278136947426, 9.999999999998899e-05, 0.06830416718168708, 0.07542182160323807, 0.06536256717639499, 0.049405550134292375, 0.09604735225686678, 0.05138418087644181, 0.10482299748724055, 0.06562436011481165, 0.10696856391350906, 0.06817388830143012, 0.09185605654752327, 0.0434381861436377, 0.08264383879110482, 0.36325956688836314, 0.2957494944537913, 0.3465664810187311, 0.395536414612513, 0.33924527404956584, 0.3289414309020704, 0.34106733907481923, 0.3077181160417134, 0.3153915160738723, 0.11471079591004141, 0.12475708051465773, 0.09347077083188338, 0.08545250594669995, 0.11190328002062655, 0.1142643539822924, 0.08533022589389361, 0.08371063533275758, 0.10924117592447546, 0.11562329588867848, 0.14076773575683366, 0.1444950716147978, 0.12357242033441052, 0.1330529030071702, 0.14509382151178474, 0.12928095060893208, 0.12234151981555075, 0.135378753420351, 0.24481097519529904, 0.269424314793153, 0.2760692464722624, 0.2183212323131748, 0.2110732206916115, 0.23320686717778616, 0.2621243213564629, 0.25706521221596346, 0.27990569794797815, 0.21117165637590873, 0.23393855828695442, 0.18016493344288553, 0.17367761761249112, 0.18306869092826739, 0.1879355958783342, 0.20656598113886326, 0.22434846862080593, 0.19843437175127465, 0.19432112481460528, 0.1910615444569802, 0.15730625410500365, 0.1892472866425292, 0.1728216967191455, 0.1771416182545874, 0.16102774781885887, 0.18077141834244048, 0.1924534865816312, 0.190166749116642, 0.20271232885693358, 0.19512698247297477, 0.1877237587104359, 0.2052780556854028, 0.18248865640804457, 0.20952520304407707, 0.2601622771022608, 0.18712430790116563, 0.2812194466870874, 0.1776331313252798, 0.16401440211389018, 0.20135083620570848, 0.21503554655951762, 0.2143158673094019, 0.13296273015509463, 0.15977080052941894, 0.2333402310793855, 0.15188708379948657, 0.15261283852672114, 0.1512549581861633, 0.14129150226552012, 0.15573598828116175, 0.1336607974550139, 0.1342731291834507, 0.16788081870096505, 0.16817998876735563, 0.17743538848103635, 0.1760919192384981, 0.16875407008363363, 0.1773793212221606, 0.21800909548816638, 0.17402546783475314, 0.17034905555145818, 0.1906893211898225, 0.17728354911932764, 0.07103213143034104, 0.067795018621015, 0.06459935119775895, 0.06147022938058688, 0.07098457780707834, 0.07570334305421966, 0.0705655184401508, 0.059307251447096365, 0.06908244356410598]}, "mutation_prompt": null}
{"id": "53e51370-34c4-442f-9ebd-488e95c422aa", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8\n        self.CR = 0.9\n        self.base_convergence_threshold = 0.01\n        self.convergence_threshold = self.base_convergence_threshold\n\n    def mutation(self, population, fitness):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        sorted_idx = np.argsort(fitness[idxs])  # Sort by fitness\n        best, mid, worst = population[idxs[sorted_idx]]\n        if fitness[idxs[sorted_idx[0]]] < self.convergence_threshold:\n            adaptive_F = self.F * 0.5\n        else:\n            adaptive_F = self.F * 1.2\n        return best + adaptive_F * (mid - worst)\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        self.convergence_threshold = max(self.base_convergence_threshold / 2, np.std(fitness) / 10)\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population, fitness)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "EnhancedDifferentialEvolution", "description": "Enhance exploration and exploitation in Adaptive Differential Evolution by introducing threshold-based mutation and dynamic reduction of convergence threshold.", "configspace": "", "generation": 81, "fitness": 0.26720356208693397, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": "f9bcc027-ab52-474c-9a8a-095d2626f629", "metadata": {"aucs": [0.30236129520036015, 0.2850046132906414, 0.31316180531782034, 0.3186508148213587, 0.34587557045263173, 0.33397597486131003, 0.5476299265642639, 0.7525595133216176, 0.5917738738827856, 0.5760637047770985, 0.5622115136473553, 0.4962684546423174, 0.6033889642700815, 0.6245058680012969, 0.6590917401168723, 0.6058595646631237, 0.638108620811118, 0.5314197249829808, 0.10410255287903347, 0.10258812023936947, 0.1344004950649611, 0.08223316632102307, 0.08599149866684674, 0.10296431768631809, 0.11847471437113577, 0.09143143737328085, 0.10161067603561391, 0.11296422660433869, 0.10246378443841497, 0.1209378652536861, 0.06676026872779472, 0.07230741981639077, 0.07437255868153714, 0.06719975837862913, 0.06555748805536821, 0.06916657862586639, 0.9535832431173171, 0.956247699404561, 0.9566489219042099, 0.9660545815417472, 0.9523590600321148, 0.9609207475412704, 0.9578044851330831, 0.9701883978308043, 0.9757484019412868, 0.17088885858518565, 0.2868802641044176, 0.3431138546233081, 0.37061889913475277, 0.38108136096260636, 0.1722687074647019, 0.3985990547110896, 0.41408256856537273, 0.35581717566076954, 0.15593124039286232, 0.1587869245666439, 0.1822205083636137, 0.15772242270593684, 0.2035865710469984, 0.17041336623493886, 0.20316037506544427, 0.4952063638329318, 0.25208538743693576, 0.26920505116378557, 0.21665733731489134, 0.14330207400432404, 0.12874693771889, 0.34427136360927013, 0.21461216149978557, 0.2423196788552917, 0.29878474685990875, 0.20293783507272067, 0.18794270841839922, 0.11914351686641056, 0.13705859891038397, 0.17569835630493125, 0.15688825193851408, 0.18608286101081917, 0.25233919498841373, 0.19088618569740334, 0.15047770883723843, 0.44860710734169373, 0.16862143352281822, 0.47932420844111845, 0.494422140601097, 0.4489781636629462, 0.2674274670687409, 0.4801580573476113, 0.43852211582475664, 0.34634601474201, 0.240298199520235, 0.44019465336175745, 0.24460865977397994, 0.5385114299362563, 0.5650462137306346, 0.5833452899225648, 0.5346861259221299, 0.5327977424649197, 0.4636678670278843, 0.24844112534579343, 0.048033541356767295, 0.1672848337022388, 0.2141902755136118, 0.4080834154349626, 0.19569945640914477, 0.17792400341596726, 0.23812057024179556, 0.17471512014818324, 0.04133513562937752, 0.030207172804662008, 0.02954620476277814, 0.06217840767995564, 0.0679026482466667, 0.07105915359593351, 0.27643721928800846, 0.33537907823275837, 0.2626994111063323, 0.7266963120843419, 0.6434014129930583, 0.5891069749558541, 0.7001397809344556, 0.6806690593545373, 0.5387460934417838, 0.2754627279251398, 0.3005835969233728, 0.27039678597234984, 0.06710514083158536, 0.06785028315557262, 0.07248794042675943, 0.06176788966062685, 0.060662590408076755, 0.06778492166861139, 0.07006791135396195, 0.07627948183072664, 0.08265335480963532, 0.1319398502471535, 0.1289088048526541, 0.13241917614550835, 0.12283440376968158, 0.11382325769464097, 0.12716833592720578, 0.12277064483508349, 0.14745568869154524, 0.12388495127425647, 0.44039897081477064, 0.39376648508184986, 0.38753514060627436, 0.16973969607590467, 0.17171691064132633, 0.16416735922730497, 0.2033505050112584, 0.19299014554525018, 0.1969751583607089, 0.20193498333523596, 0.31175019154320316, 0.23782954954761104, 0.12422708618870293, 0.11494119665941527, 0.11193752417206904, 0.1347495581862882, 0.13766310298855, 0.12386414876721119, 0.22022354515617515, 0.16848634990105604, 0.19044539707083497, 0.163034287323356, 0.15369232542041467, 0.15984047129929713, 0.1612313467814933, 0.15008756581370586, 0.15880440602411638, 0.18656712496841865, 0.27252232101478036, 0.20242579879665523, 0.1858365274883299, 0.15432948777398925, 0.18617535536617957, 0.17871722665864986, 0.18345667561945633, 0.17499215613211727, 0.14363424528722302, 0.16895667023776828, 0.1499042706268321, 0.12653682649177278, 0.151133710904106, 0.2038276403359901, 0.17597200726101525, 0.1508398436384486, 0.34821225929435273, 0.26402047654674543, 0.2727423223687261, 0.22686744519366853, 0.1336858958347058, 0.16224201378271996, 0.1650463011100577, 0.18157408403890085, 0.18669066105929244, 0.18592186030930602, 0.18168852988987994, 0.17051010446638426, 0.18983299140331678, 0.1653063826770632, 0.16664601394629208, 0.17956764367251932, 0.17328037675417507, 0.20298199167910402, 0.16901682404095209, 0.05418906890149666, 0.051843505490605124, 0.05739638657972923, 0.05180473993205559, 0.04816529871508268, 0.04822073032712215, 0.06147699438607268, 0.05222525130093669, 0.05292244381416089]}, "mutation_prompt": null}
{"id": "aed17495-4ffd-401e-a082-67e6aaea8d9d", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8\n        self.CR = 0.9\n        self.base_convergence_threshold = 0.01\n        self.convergence_threshold = self.base_convergence_threshold\n\n    def mutation(self, population, fitness):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        sorted_idx = np.argsort(fitness[idxs])  # Sort by fitness\n        best, mid, worst = population[idxs[sorted_idx]]\n        if fitness[idxs[sorted_idx[0]]] < self.convergence_threshold:\n            adaptive_F = self.F * 0.5\n        else:\n            adaptive_F = self.F * 1.2\n        return best + adaptive_F * (mid - worst)\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        self.convergence_threshold = max(self.base_convergence_threshold / 2, np.std(fitness) / 10)\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population, fitness)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "EnhancedDifferentialEvolution", "description": "Enhance exploration and exploitation in Adaptive Differential Evolution by introducing threshold-based mutation and dynamic reduction of convergence threshold.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "53e51370-34c4-442f-9ebd-488e95c422aa", "metadata": {"aucs": [0.30236129520036015, 0.2850046132906414, 0.31316180531782034, 0.3186508148213587, 0.34587557045263173, 0.33397597486131003, 0.5476299265642639, 0.7525595133216176, 0.5917738738827856, 0.5760637047770985, 0.5622115136473553, 0.4962684546423174, 0.6033889642700815, 0.6245058680012969, 0.6590917401168723, 0.6058595646631237, 0.638108620811118, 0.5314197249829808, 0.10410255287903347, 0.10258812023936947, 0.1344004950649611, 0.08223316632102307, 0.08599149866684674, 0.10296431768631809, 0.11847471437113577, 0.09143143737328085, 0.10161067603561391, 0.11296422660433869, 0.10246378443841497, 0.1209378652536861, 0.06676026872779472, 0.07230741981639077, 0.07437255868153714, 0.06719975837862913, 0.06555748805536821, 0.06916657862586639, 0.9535832431173171, 0.956247699404561, 0.9566489219042099, 0.9660545815417472, 0.9523590600321148, 0.9609207475412704, 0.9578044851330831, 0.9701883978308043, 0.9757484019412868, 0.17088885858518565, 0.2868802641044176, 0.3431138546233081, 0.37061889913475277, 0.38108136096260636, 0.1722687074647019, 0.3985990547110896, 0.41408256856537273, 0.35581717566076954, 0.15593124039286232, 0.1587869245666439, 0.1822205083636137, 0.15772242270593684, 0.2035865710469984, 0.17041336623493886, 0.20316037506544427, 0.4952063638329318, 0.25208538743693576, 0.26920505116378557, 0.21665733731489134, 0.14330207400432404, 0.12874693771889, 0.34427136360927013, 0.21461216149978557, 0.2423196788552917, 0.29878474685990875, 0.20293783507272067, 0.18794270841839922, 0.11914351686641056, 0.13705859891038397, 0.17569835630493125, 0.15688825193851408, 0.18608286101081917, 0.25233919498841373, 0.19088618569740334, 0.15047770883723843, 0.44860710734169373, 0.16862143352281822, 0.47932420844111845, 0.494422140601097, 0.4489781636629462, 0.2674274670687409, 0.4801580573476113, 0.43852211582475664, 0.34634601474201, 0.240298199520235, 0.44019465336175745, 0.24460865977397994, 0.5385114299362563, 0.5650462137306346, 0.5833452899225648, 0.5346861259221299, 0.5327977424649197, 0.4636678670278843, 0.24844112534579343, 0.048033541356767295, 0.1672848337022388, 0.2141902755136118, 0.4080834154349626, 0.19569945640914477, 0.17792400341596726, 0.23812057024179556, 0.17471512014818324, 0.04133513562937752, 0.030207172804662008, 0.02954620476277814, 0.06217840767995564, 0.0679026482466667, 0.07105915359593351, 0.27643721928800846, 0.33537907823275837, 0.2626994111063323, 0.7266963120843419, 0.6434014129930583, 0.5891069749558541, 0.7001397809344556, 0.6806690593545373, 0.5387460934417838, 0.2754627279251398, 0.3005835969233728, 0.27039678597234984, 0.06710514083158536, 0.06785028315557262, 0.07248794042675943, 0.06176788966062685, 0.060662590408076755, 0.06778492166861139, 0.07006791135396195, 0.07627948183072664, 0.08265335480963532, 0.1319398502471535, 0.1289088048526541, 0.13241917614550835, 0.12283440376968158, 0.11382325769464097, 0.12716833592720578, 0.12277064483508349, 0.14745568869154524, 0.12388495127425647, 0.44039897081477064, 0.39376648508184986, 0.38753514060627436, 0.16973969607590467, 0.17171691064132633, 0.16416735922730497, 0.2033505050112584, 0.19299014554525018, 0.1969751583607089, 0.20193498333523596, 0.31175019154320316, 0.23782954954761104, 0.12422708618870293, 0.11494119665941527, 0.11193752417206904, 0.1347495581862882, 0.13766310298855, 0.12386414876721119, 0.22022354515617515, 0.16848634990105604, 0.19044539707083497, 0.163034287323356, 0.15369232542041467, 0.15984047129929713, 0.1612313467814933, 0.15008756581370586, 0.15880440602411638, 0.18656712496841865, 0.27252232101478036, 0.20242579879665523, 0.1858365274883299, 0.15432948777398925, 0.18617535536617957, 0.17871722665864986, 0.18345667561945633, 0.17499215613211727, 0.14363424528722302, 0.16895667023776828, 0.1499042706268321, 0.12653682649177278, 0.151133710904106, 0.2038276403359901, 0.17597200726101525, 0.1508398436384486, 0.34821225929435273, 0.26402047654674543, 0.2727423223687261, 0.22686744519366853, 0.1336858958347058, 0.16224201378271996, 0.1650463011100577, 0.18157408403890085, 0.18669066105929244, 0.18592186030930602, 0.18168852988987994, 0.17051010446638426, 0.18983299140331678, 0.1653063826770632, 0.16664601394629208, 0.17956764367251932, 0.17328037675417507, 0.20298199167910402, 0.16901682404095209, 0.05418906890149666, 0.051843505490605124, 0.05739638657972923, 0.05180473993205559, 0.04816529871508268, 0.04822073032712215, 0.06147699438607268, 0.05222525130093669, 0.05292244381416089]}, "mutation_prompt": null}
{"id": "5f0d301a-2c8c-46a2-8138-8ffc363ab3aa", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8\n        self.CR = 0.9\n        self.base_convergence_threshold = 0.01\n        self.convergence_threshold = self.base_convergence_threshold\n\n    def mutation(self, population, fitness):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        sorted_idx = np.argsort(fitness[idxs])  # Sort by fitness\n        best, mid, worst = population[idxs[sorted_idx]]\n        if fitness[idxs[sorted_idx[0]]] < self.convergence_threshold:\n            adaptive_F = self.F * 0.5\n        else:\n            adaptive_F = self.F * 1.2\n        return best + adaptive_F * (mid - worst)\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        self.convergence_threshold = max(self.base_convergence_threshold / 2, np.std(fitness) / 10)\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population, fitness)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "EnhancedDifferentialEvolution", "description": "Enhance exploration and exploitation in Adaptive Differential Evolution by introducing threshold-based mutation and dynamic reduction of convergence threshold.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "53e51370-34c4-442f-9ebd-488e95c422aa", "metadata": {"aucs": [0.30236129520036015, 0.2850046132906414, 0.31316180531782034, 0.3186508148213587, 0.34587557045263173, 0.33397597486131003, 0.5476299265642639, 0.7525595133216176, 0.5917738738827856, 0.5760637047770985, 0.5622115136473553, 0.4962684546423174, 0.6033889642700815, 0.6245058680012969, 0.6590917401168723, 0.6058595646631237, 0.638108620811118, 0.5314197249829808, 0.10410255287903347, 0.10258812023936947, 0.1344004950649611, 0.08223316632102307, 0.08599149866684674, 0.10296431768631809, 0.11847471437113577, 0.09143143737328085, 0.10161067603561391, 0.11296422660433869, 0.10246378443841497, 0.1209378652536861, 0.06676026872779472, 0.07230741981639077, 0.07437255868153714, 0.06719975837862913, 0.06555748805536821, 0.06916657862586639, 0.9535832431173171, 0.956247699404561, 0.9566489219042099, 0.9660545815417472, 0.9523590600321148, 0.9609207475412704, 0.9578044851330831, 0.9701883978308043, 0.9757484019412868, 0.17088885858518565, 0.2868802641044176, 0.3431138546233081, 0.37061889913475277, 0.38108136096260636, 0.1722687074647019, 0.3985990547110896, 0.41408256856537273, 0.35581717566076954, 0.15593124039286232, 0.1587869245666439, 0.1822205083636137, 0.15772242270593684, 0.2035865710469984, 0.17041336623493886, 0.20316037506544427, 0.4952063638329318, 0.25208538743693576, 0.26920505116378557, 0.21665733731489134, 0.14330207400432404, 0.12874693771889, 0.34427136360927013, 0.21461216149978557, 0.2423196788552917, 0.29878474685990875, 0.20293783507272067, 0.18794270841839922, 0.11914351686641056, 0.13705859891038397, 0.17569835630493125, 0.15688825193851408, 0.18608286101081917, 0.25233919498841373, 0.19088618569740334, 0.15047770883723843, 0.44860710734169373, 0.16862143352281822, 0.47932420844111845, 0.494422140601097, 0.4489781636629462, 0.2674274670687409, 0.4801580573476113, 0.43852211582475664, 0.34634601474201, 0.240298199520235, 0.44019465336175745, 0.24460865977397994, 0.5385114299362563, 0.5650462137306346, 0.5833452899225648, 0.5346861259221299, 0.5327977424649197, 0.4636678670278843, 0.24844112534579343, 0.048033541356767295, 0.1672848337022388, 0.2141902755136118, 0.4080834154349626, 0.19569945640914477, 0.17792400341596726, 0.23812057024179556, 0.17471512014818324, 0.04133513562937752, 0.030207172804662008, 0.02954620476277814, 0.06217840767995564, 0.0679026482466667, 0.07105915359593351, 0.27643721928800846, 0.33537907823275837, 0.2626994111063323, 0.7266963120843419, 0.6434014129930583, 0.5891069749558541, 0.7001397809344556, 0.6806690593545373, 0.5387460934417838, 0.2754627279251398, 0.3005835969233728, 0.27039678597234984, 0.06710514083158536, 0.06785028315557262, 0.07248794042675943, 0.06176788966062685, 0.060662590408076755, 0.06778492166861139, 0.07006791135396195, 0.07627948183072664, 0.08265335480963532, 0.1319398502471535, 0.1289088048526541, 0.13241917614550835, 0.12283440376968158, 0.11382325769464097, 0.12716833592720578, 0.12277064483508349, 0.14745568869154524, 0.12388495127425647, 0.44039897081477064, 0.39376648508184986, 0.38753514060627436, 0.16973969607590467, 0.17171691064132633, 0.16416735922730497, 0.2033505050112584, 0.19299014554525018, 0.1969751583607089, 0.20193498333523596, 0.31175019154320316, 0.23782954954761104, 0.12422708618870293, 0.11494119665941527, 0.11193752417206904, 0.1347495581862882, 0.13766310298855, 0.12386414876721119, 0.22022354515617515, 0.16848634990105604, 0.19044539707083497, 0.163034287323356, 0.15369232542041467, 0.15984047129929713, 0.1612313467814933, 0.15008756581370586, 0.15880440602411638, 0.18656712496841865, 0.27252232101478036, 0.20242579879665523, 0.1858365274883299, 0.15432948777398925, 0.18617535536617957, 0.17871722665864986, 0.18345667561945633, 0.17499215613211727, 0.14363424528722302, 0.16895667023776828, 0.1499042706268321, 0.12653682649177278, 0.151133710904106, 0.2038276403359901, 0.17597200726101525, 0.1508398436384486, 0.34821225929435273, 0.26402047654674543, 0.2727423223687261, 0.22686744519366853, 0.1336858958347058, 0.16224201378271996, 0.1650463011100577, 0.18157408403890085, 0.18669066105929244, 0.18592186030930602, 0.18168852988987994, 0.17051010446638426, 0.18983299140331678, 0.1653063826770632, 0.16664601394629208, 0.17956764367251932, 0.17328037675417507, 0.20298199167910402, 0.16901682404095209, 0.05418906890149666, 0.051843505490605124, 0.05739638657972923, 0.05180473993205559, 0.04816529871508268, 0.04822073032712215, 0.06147699438607268, 0.05222525130093669, 0.05292244381416089]}, "mutation_prompt": null}
{"id": "7b112690-4aaf-43b9-9a16-7a8764283b49", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8\n        self.CR = 0.9\n        self.base_convergence_threshold = 0.01\n        self.convergence_threshold = self.base_convergence_threshold\n\n    def mutation(self, population, fitness):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        sorted_idx = np.argsort(fitness[idxs])  # Sort by fitness\n        best, mid, worst = population[idxs[sorted_idx]]\n        if fitness[idxs[sorted_idx[0]]] < self.convergence_threshold:\n            adaptive_F = self.F * 0.5\n        else:\n            adaptive_F = self.F * 1.2\n        return best + adaptive_F * (mid - worst)\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        self.convergence_threshold = max(self.base_convergence_threshold / 2, np.std(fitness) / 10)\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population, fitness)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "EnhancedDifferentialEvolution", "description": "Enhance exploration and exploitation in Adaptive Differential Evolution by introducing threshold-based mutation and dynamic reduction of convergence threshold.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "53e51370-34c4-442f-9ebd-488e95c422aa", "metadata": {"aucs": [0.30236129520036015, 0.2850046132906414, 0.31316180531782034, 0.3186508148213587, 0.34587557045263173, 0.33397597486131003, 0.5476299265642639, 0.7525595133216176, 0.5917738738827856, 0.5760637047770985, 0.5622115136473553, 0.4962684546423174, 0.6033889642700815, 0.6245058680012969, 0.6590917401168723, 0.6058595646631237, 0.638108620811118, 0.5314197249829808, 0.10410255287903347, 0.10258812023936947, 0.1344004950649611, 0.08223316632102307, 0.08599149866684674, 0.10296431768631809, 0.11847471437113577, 0.09143143737328085, 0.10161067603561391, 0.11296422660433869, 0.10246378443841497, 0.1209378652536861, 0.06676026872779472, 0.07230741981639077, 0.07437255868153714, 0.06719975837862913, 0.06555748805536821, 0.06916657862586639, 0.9535832431173171, 0.956247699404561, 0.9566489219042099, 0.9660545815417472, 0.9523590600321148, 0.9609207475412704, 0.9578044851330831, 0.9701883978308043, 0.9757484019412868, 0.17088885858518565, 0.2868802641044176, 0.3431138546233081, 0.37061889913475277, 0.38108136096260636, 0.1722687074647019, 0.3985990547110896, 0.41408256856537273, 0.35581717566076954, 0.15593124039286232, 0.1587869245666439, 0.1822205083636137, 0.15772242270593684, 0.2035865710469984, 0.17041336623493886, 0.20316037506544427, 0.4952063638329318, 0.25208538743693576, 0.26920505116378557, 0.21665733731489134, 0.14330207400432404, 0.12874693771889, 0.34427136360927013, 0.21461216149978557, 0.2423196788552917, 0.29878474685990875, 0.20293783507272067, 0.18794270841839922, 0.11914351686641056, 0.13705859891038397, 0.17569835630493125, 0.15688825193851408, 0.18608286101081917, 0.25233919498841373, 0.19088618569740334, 0.15047770883723843, 0.44860710734169373, 0.16862143352281822, 0.47932420844111845, 0.494422140601097, 0.4489781636629462, 0.2674274670687409, 0.4801580573476113, 0.43852211582475664, 0.34634601474201, 0.240298199520235, 0.44019465336175745, 0.24460865977397994, 0.5385114299362563, 0.5650462137306346, 0.5833452899225648, 0.5346861259221299, 0.5327977424649197, 0.4636678670278843, 0.24844112534579343, 0.048033541356767295, 0.1672848337022388, 0.2141902755136118, 0.4080834154349626, 0.19569945640914477, 0.17792400341596726, 0.23812057024179556, 0.17471512014818324, 0.04133513562937752, 0.030207172804662008, 0.02954620476277814, 0.06217840767995564, 0.0679026482466667, 0.07105915359593351, 0.27643721928800846, 0.33537907823275837, 0.2626994111063323, 0.7266963120843419, 0.6434014129930583, 0.5891069749558541, 0.7001397809344556, 0.6806690593545373, 0.5387460934417838, 0.2754627279251398, 0.3005835969233728, 0.27039678597234984, 0.06710514083158536, 0.06785028315557262, 0.07248794042675943, 0.06176788966062685, 0.060662590408076755, 0.06778492166861139, 0.07006791135396195, 0.07627948183072664, 0.08265335480963532, 0.1319398502471535, 0.1289088048526541, 0.13241917614550835, 0.12283440376968158, 0.11382325769464097, 0.12716833592720578, 0.12277064483508349, 0.14745568869154524, 0.12388495127425647, 0.44039897081477064, 0.39376648508184986, 0.38753514060627436, 0.16973969607590467, 0.17171691064132633, 0.16416735922730497, 0.2033505050112584, 0.19299014554525018, 0.1969751583607089, 0.20193498333523596, 0.31175019154320316, 0.23782954954761104, 0.12422708618870293, 0.11494119665941527, 0.11193752417206904, 0.1347495581862882, 0.13766310298855, 0.12386414876721119, 0.22022354515617515, 0.16848634990105604, 0.19044539707083497, 0.163034287323356, 0.15369232542041467, 0.15984047129929713, 0.1612313467814933, 0.15008756581370586, 0.15880440602411638, 0.18656712496841865, 0.27252232101478036, 0.20242579879665523, 0.1858365274883299, 0.15432948777398925, 0.18617535536617957, 0.17871722665864986, 0.18345667561945633, 0.17499215613211727, 0.14363424528722302, 0.16895667023776828, 0.1499042706268321, 0.12653682649177278, 0.151133710904106, 0.2038276403359901, 0.17597200726101525, 0.1508398436384486, 0.34821225929435273, 0.26402047654674543, 0.2727423223687261, 0.22686744519366853, 0.1336858958347058, 0.16224201378271996, 0.1650463011100577, 0.18157408403890085, 0.18669066105929244, 0.18592186030930602, 0.18168852988987994, 0.17051010446638426, 0.18983299140331678, 0.1653063826770632, 0.16664601394629208, 0.17956764367251932, 0.17328037675417507, 0.20298199167910402, 0.16901682404095209, 0.05418906890149666, 0.051843505490605124, 0.05739638657972923, 0.05180473993205559, 0.04816529871508268, 0.04822073032712215, 0.06147699438607268, 0.05222525130093669, 0.05292244381416089]}, "mutation_prompt": null}
{"id": "bde010a0-2f6d-45a1-b0ca-3db91adeefd7", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8\n        self.CR = 0.9\n        self.base_convergence_threshold = 0.01\n        self.convergence_threshold = self.base_convergence_threshold\n\n    def mutation(self, population, fitness):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        sorted_idx = np.argsort(fitness[idxs])  # Sort by fitness\n        best, mid, worst = population[idxs[sorted_idx]]\n        if fitness[idxs[sorted_idx[0]]] < self.convergence_threshold:\n            adaptive_F = self.F * 0.5\n        else:\n            adaptive_F = self.F * 1.2\n        return best + adaptive_F * (mid - worst)\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        self.convergence_threshold = max(self.base_convergence_threshold / 2, np.std(fitness) / 10)\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population, fitness)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "EnhancedDifferentialEvolution", "description": "Enhance exploration and exploitation in Adaptive Differential Evolution by introducing threshold-based mutation and dynamic reduction of convergence threshold.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "53e51370-34c4-442f-9ebd-488e95c422aa", "metadata": {"aucs": [0.30236129520036015, 0.2850046132906414, 0.31316180531782034, 0.3186508148213587, 0.34587557045263173, 0.33397597486131003, 0.5476299265642639, 0.7525595133216176, 0.5917738738827856, 0.5760637047770985, 0.5622115136473553, 0.4962684546423174, 0.6033889642700815, 0.6245058680012969, 0.6590917401168723, 0.6058595646631237, 0.638108620811118, 0.5314197249829808, 0.10410255287903347, 0.10258812023936947, 0.1344004950649611, 0.08223316632102307, 0.08599149866684674, 0.10296431768631809, 0.11847471437113577, 0.09143143737328085, 0.10161067603561391, 0.11296422660433869, 0.10246378443841497, 0.1209378652536861, 0.06676026872779472, 0.07230741981639077, 0.07437255868153714, 0.06719975837862913, 0.06555748805536821, 0.06916657862586639, 0.9535832431173171, 0.956247699404561, 0.9566489219042099, 0.9660545815417472, 0.9523590600321148, 0.9609207475412704, 0.9578044851330831, 0.9701883978308043, 0.9757484019412868, 0.17088885858518565, 0.2868802641044176, 0.3431138546233081, 0.37061889913475277, 0.38108136096260636, 0.1722687074647019, 0.3985990547110896, 0.41408256856537273, 0.35581717566076954, 0.15593124039286232, 0.1587869245666439, 0.1822205083636137, 0.15772242270593684, 0.2035865710469984, 0.17041336623493886, 0.20316037506544427, 0.4952063638329318, 0.25208538743693576, 0.26920505116378557, 0.21665733731489134, 0.14330207400432404, 0.12874693771889, 0.34427136360927013, 0.21461216149978557, 0.2423196788552917, 0.29878474685990875, 0.20293783507272067, 0.18794270841839922, 0.11914351686641056, 0.13705859891038397, 0.17569835630493125, 0.15688825193851408, 0.18608286101081917, 0.25233919498841373, 0.19088618569740334, 0.15047770883723843, 0.44860710734169373, 0.16862143352281822, 0.47932420844111845, 0.494422140601097, 0.4489781636629462, 0.2674274670687409, 0.4801580573476113, 0.43852211582475664, 0.34634601474201, 0.240298199520235, 0.44019465336175745, 0.24460865977397994, 0.5385114299362563, 0.5650462137306346, 0.5833452899225648, 0.5346861259221299, 0.5327977424649197, 0.4636678670278843, 0.24844112534579343, 0.048033541356767295, 0.1672848337022388, 0.2141902755136118, 0.4080834154349626, 0.19569945640914477, 0.17792400341596726, 0.23812057024179556, 0.17471512014818324, 0.04133513562937752, 0.030207172804662008, 0.02954620476277814, 0.06217840767995564, 0.0679026482466667, 0.07105915359593351, 0.27643721928800846, 0.33537907823275837, 0.2626994111063323, 0.7266963120843419, 0.6434014129930583, 0.5891069749558541, 0.7001397809344556, 0.6806690593545373, 0.5387460934417838, 0.2754627279251398, 0.3005835969233728, 0.27039678597234984, 0.06710514083158536, 0.06785028315557262, 0.07248794042675943, 0.06176788966062685, 0.060662590408076755, 0.06778492166861139, 0.07006791135396195, 0.07627948183072664, 0.08265335480963532, 0.1319398502471535, 0.1289088048526541, 0.13241917614550835, 0.12283440376968158, 0.11382325769464097, 0.12716833592720578, 0.12277064483508349, 0.14745568869154524, 0.12388495127425647, 0.44039897081477064, 0.39376648508184986, 0.38753514060627436, 0.16973969607590467, 0.17171691064132633, 0.16416735922730497, 0.2033505050112584, 0.19299014554525018, 0.1969751583607089, 0.20193498333523596, 0.31175019154320316, 0.23782954954761104, 0.12422708618870293, 0.11494119665941527, 0.11193752417206904, 0.1347495581862882, 0.13766310298855, 0.12386414876721119, 0.22022354515617515, 0.16848634990105604, 0.19044539707083497, 0.163034287323356, 0.15369232542041467, 0.15984047129929713, 0.1612313467814933, 0.15008756581370586, 0.15880440602411638, 0.18656712496841865, 0.27252232101478036, 0.20242579879665523, 0.1858365274883299, 0.15432948777398925, 0.18617535536617957, 0.17871722665864986, 0.18345667561945633, 0.17499215613211727, 0.14363424528722302, 0.16895667023776828, 0.1499042706268321, 0.12653682649177278, 0.151133710904106, 0.2038276403359901, 0.17597200726101525, 0.1508398436384486, 0.34821225929435273, 0.26402047654674543, 0.2727423223687261, 0.22686744519366853, 0.1336858958347058, 0.16224201378271996, 0.1650463011100577, 0.18157408403890085, 0.18669066105929244, 0.18592186030930602, 0.18168852988987994, 0.17051010446638426, 0.18983299140331678, 0.1653063826770632, 0.16664601394629208, 0.17956764367251932, 0.17328037675417507, 0.20298199167910402, 0.16901682404095209, 0.05418906890149666, 0.051843505490605124, 0.05739638657972923, 0.05180473993205559, 0.04816529871508268, 0.04822073032712215, 0.06147699438607268, 0.05222525130093669, 0.05292244381416089]}, "mutation_prompt": null}
{"id": "96ef738c-cb33-43e1-a564-f009358a33dc", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8\n        self.CR = 0.9\n        self.base_convergence_threshold = 0.01\n        self.convergence_threshold = self.base_convergence_threshold\n\n    def mutation(self, population, fitness):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        sorted_idx = np.argsort(fitness[idxs])  # Sort by fitness\n        best, mid, worst = population[idxs[sorted_idx]]\n        if fitness[idxs[sorted_idx[0]]] < self.convergence_threshold:\n            adaptive_F = self.F * 0.5\n        else:\n            adaptive_F = self.F * 1.2\n        return best + adaptive_F * (mid - worst)\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        self.convergence_threshold = max(self.base_convergence_threshold / 2, np.std(fitness) / 10)\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population, fitness)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "EnhancedDifferentialEvolution", "description": "Enhance exploration and exploitation in Adaptive Differential Evolution by introducing threshold-based mutation and dynamic reduction of convergence threshold.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "53e51370-34c4-442f-9ebd-488e95c422aa", "metadata": {"aucs": [0.30236129520036015, 0.2850046132906414, 0.31316180531782034, 0.3186508148213587, 0.34587557045263173, 0.33397597486131003, 0.5476299265642639, 0.7525595133216176, 0.5917738738827856, 0.5760637047770985, 0.5622115136473553, 0.4962684546423174, 0.6033889642700815, 0.6245058680012969, 0.6590917401168723, 0.6058595646631237, 0.638108620811118, 0.5314197249829808, 0.10410255287903347, 0.10258812023936947, 0.1344004950649611, 0.08223316632102307, 0.08599149866684674, 0.10296431768631809, 0.11847471437113577, 0.09143143737328085, 0.10161067603561391, 0.11296422660433869, 0.10246378443841497, 0.1209378652536861, 0.06676026872779472, 0.07230741981639077, 0.07437255868153714, 0.06719975837862913, 0.06555748805536821, 0.06916657862586639, 0.9535832431173171, 0.956247699404561, 0.9566489219042099, 0.9660545815417472, 0.9523590600321148, 0.9609207475412704, 0.9578044851330831, 0.9701883978308043, 0.9757484019412868, 0.17088885858518565, 0.2868802641044176, 0.3431138546233081, 0.37061889913475277, 0.38108136096260636, 0.1722687074647019, 0.3985990547110896, 0.41408256856537273, 0.35581717566076954, 0.15593124039286232, 0.1587869245666439, 0.1822205083636137, 0.15772242270593684, 0.2035865710469984, 0.17041336623493886, 0.20316037506544427, 0.4952063638329318, 0.25208538743693576, 0.26920505116378557, 0.21665733731489134, 0.14330207400432404, 0.12874693771889, 0.34427136360927013, 0.21461216149978557, 0.2423196788552917, 0.29878474685990875, 0.20293783507272067, 0.18794270841839922, 0.11914351686641056, 0.13705859891038397, 0.17569835630493125, 0.15688825193851408, 0.18608286101081917, 0.25233919498841373, 0.19088618569740334, 0.15047770883723843, 0.44860710734169373, 0.16862143352281822, 0.47932420844111845, 0.494422140601097, 0.4489781636629462, 0.2674274670687409, 0.4801580573476113, 0.43852211582475664, 0.34634601474201, 0.240298199520235, 0.44019465336175745, 0.24460865977397994, 0.5385114299362563, 0.5650462137306346, 0.5833452899225648, 0.5346861259221299, 0.5327977424649197, 0.4636678670278843, 0.24844112534579343, 0.048033541356767295, 0.1672848337022388, 0.2141902755136118, 0.4080834154349626, 0.19569945640914477, 0.17792400341596726, 0.23812057024179556, 0.17471512014818324, 0.04133513562937752, 0.030207172804662008, 0.02954620476277814, 0.06217840767995564, 0.0679026482466667, 0.07105915359593351, 0.27643721928800846, 0.33537907823275837, 0.2626994111063323, 0.7266963120843419, 0.6434014129930583, 0.5891069749558541, 0.7001397809344556, 0.6806690593545373, 0.5387460934417838, 0.2754627279251398, 0.3005835969233728, 0.27039678597234984, 0.06710514083158536, 0.06785028315557262, 0.07248794042675943, 0.06176788966062685, 0.060662590408076755, 0.06778492166861139, 0.07006791135396195, 0.07627948183072664, 0.08265335480963532, 0.1319398502471535, 0.1289088048526541, 0.13241917614550835, 0.12283440376968158, 0.11382325769464097, 0.12716833592720578, 0.12277064483508349, 0.14745568869154524, 0.12388495127425647, 0.44039897081477064, 0.39376648508184986, 0.38753514060627436, 0.16973969607590467, 0.17171691064132633, 0.16416735922730497, 0.2033505050112584, 0.19299014554525018, 0.1969751583607089, 0.20193498333523596, 0.31175019154320316, 0.23782954954761104, 0.12422708618870293, 0.11494119665941527, 0.11193752417206904, 0.1347495581862882, 0.13766310298855, 0.12386414876721119, 0.22022354515617515, 0.16848634990105604, 0.19044539707083497, 0.163034287323356, 0.15369232542041467, 0.15984047129929713, 0.1612313467814933, 0.15008756581370586, 0.15880440602411638, 0.18656712496841865, 0.27252232101478036, 0.20242579879665523, 0.1858365274883299, 0.15432948777398925, 0.18617535536617957, 0.17871722665864986, 0.18345667561945633, 0.17499215613211727, 0.14363424528722302, 0.16895667023776828, 0.1499042706268321, 0.12653682649177278, 0.151133710904106, 0.2038276403359901, 0.17597200726101525, 0.1508398436384486, 0.34821225929435273, 0.26402047654674543, 0.2727423223687261, 0.22686744519366853, 0.1336858958347058, 0.16224201378271996, 0.1650463011100577, 0.18157408403890085, 0.18669066105929244, 0.18592186030930602, 0.18168852988987994, 0.17051010446638426, 0.18983299140331678, 0.1653063826770632, 0.16664601394629208, 0.17956764367251932, 0.17328037675417507, 0.20298199167910402, 0.16901682404095209, 0.05418906890149666, 0.051843505490605124, 0.05739638657972923, 0.05180473993205559, 0.04816529871508268, 0.04822073032712215, 0.06147699438607268, 0.05222525130093669, 0.05292244381416089]}, "mutation_prompt": null}
{"id": "99d195c0-65c4-4dc5-9edb-0d63e96e92b4", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8\n        self.CR = 0.9\n        self.base_convergence_threshold = 0.01\n        self.convergence_threshold = self.base_convergence_threshold\n\n    def mutation(self, population, fitness):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        sorted_idx = np.argsort(fitness[idxs])  # Sort by fitness\n        best, mid, worst = population[idxs[sorted_idx]]\n        diversity_factor = np.std(population, axis=0).mean()\n        adaptive_F = self.F * (1 + 0.5 * diversity_factor)  # Adjust F based on diversity\n        return best + adaptive_F * (mid - worst)\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        self.convergence_threshold = max(self.base_convergence_threshold / 2, np.std(fitness) / 10)\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population, fitness)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "EnhancedDifferentialEvolution", "description": "Enhance the Enhanced Differential Evolution by introducing an adaptive scaling factor adjustment based on population diversity.", "configspace": "", "generation": 87, "fitness": 0.11965375786248851, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.19.", "error": "", "parent_id": "53e51370-34c4-442f-9ebd-488e95c422aa", "metadata": {"aucs": [0.22060054015491604, 0.19400544637919137, 0.2163132739479241, 0.32038827339302867, 0.3080062035643655, 0.30287043165834904, 0.27049999671290625, 0.16039553529330586, 0.2750894259390644, 9.999999999998899e-05, 0.0012099843227837415, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0017710409224473977, 9.999999999998899e-05, 0.0012167817363306632, 0.04657318766726404, 0.053492269116525826, 0.06222338332989197, 0.06197140261843581, 0.05971678856401319, 0.06622494223154429, 0.05958319889092567, 0.04556658167150052, 0.05447536224177707, 0.022197547785539062, 0.031174772191959854, 0.0309383720683698, 0.05337853746447241, 0.04071578541572074, 0.03338394087361485, 0.04719806918406888, 0.029538736987538172, 0.03661960874863157, 0.970189563957034, 0.9711271358332136, 0.9642055257545521, 0.9719587634650607, 0.9721927907098373, 0.9687138683186988, 0.9692960618493603, 0.9707448044072224, 0.9510761146145629, 0.07836161805331665, 0.10185529515363068, 0.04910769340076859, 0.07174501886942053, 0.0825707945992612, 0.10633510439520977, 0.0717220941936979, 0.11141052507922955, 0.044847252293929385, 0.11977466263521852, 0.11365159817607395, 0.08283196687248762, 0.12378309792849429, 0.1129553232567585, 0.14307266616747605, 0.11669528560973108, 0.14616744332227005, 0.10096103127812361, 0.00020219050429259866, 9.999999999998899e-05, 9.999999999998899e-05, 0.00793135985099691, 0.004347548678244717, 0.027325684450438703, 0.008837775139022286, 0.003639321387787109, 0.022042293213932362, 0.008843021392101913, 0.009870070887272209, 0.009382454201399382, 0.0018740670635927215, 0.0015945451646435238, 0.024627145376529547, 0.0117599073784872, 0.006098508158443261, 0.021553673074500734, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03218409367121622, 0.022337685841578248, 0.02097064201945742, 0.055477517945142774, 9.999999999998899e-05, 0.016458759820784152, 9.999999999998899e-05, 0.041682793347228686, 0.03869891130384118, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0046349149656278454, 0.00947242856217545, 0.003417171523584006, 0.0016066668578501586, 0.0019690981579624234, 0.0016125361052038434, 0.013527571042783015, 0.03346150450192942, 0.01843662110694244, 0.22615252861330348, 0.1692584991496915, 0.17570451093059125, 0.21324992263039177, 0.18717506571861553, 0.22285398622984853, 0.2121694799884526, 0.23139536340863265, 0.16731679931791965, 0.054122918580630675, 0.048216417357703545, 0.0655252489578595, 0.05523254277947198, 0.03773634889513322, 0.03888142353964774, 0.04366846440530847, 0.027504765550362187, 0.0379457428408847, 0.12481138928149971, 0.1296379341539614, 0.1613864742558564, 0.12317159365216557, 0.13835032999103947, 0.13745262735904673, 0.11858446067662376, 0.12896965591882203, 0.11347907655331091, 0.13470411287121697, 0.14087492206909136, 0.1613932299901244, 0.15064627885857662, 0.13100477024605572, 0.12372309061774378, 0.15885792240064145, 0.17895305112275495, 0.15623188921358955, 0.08294727939142454, 0.0882021688611716, 0.0939529771787817, 0.0826697298640433, 0.09453379640403758, 0.09465713378427865, 0.09649430288965322, 0.10196669040556428, 0.08755819298443224, 0.1428398131628592, 0.1282499764552627, 0.1449422056640557, 0.1677645148191761, 0.14461131415932305, 0.1569802515379679, 0.1375063438462777, 0.13569035223631687, 0.1354834551997185, 0.05753266671393087, 0.11098245088506753, 0.07036622153683969, 0.056917661576623924, 0.0989618361795831, 0.08956416560770919, 0.07643534308199762, 0.07852935036371722, 0.0840728730482071, 0.1268909981973928, 0.1338849724168395, 0.12560817824933512, 0.1190251267383704, 0.12701933625374062, 0.10879693813418012, 0.11809499977330873, 0.1085414438586687, 0.1186456812750315, 0.11050833353451583, 0.13394798306989375, 0.1158593885992788, 0.08772183372051023, 0.09953971517970095, 0.10609876613156888, 0.1626820054811824, 0.17036009381810202, 0.16392684502883148, 0.18441770562490645, 0.17051297064201576, 0.18762627726188896, 0.1746622890528834, 0.1646317523932026, 0.2102867500506055, 0.16563622556737134, 0.1651681239163545, 0.16392371113389204, 0.04215645330847961, 0.04490870734268393, 0.04102393827229245, 0.05963072724604568, 0.036808734007976796, 0.03471461398453979, 0.03545491448797167, 0.04100739431913769, 0.03536086029419039]}, "mutation_prompt": null}
{"id": "58701851-ebbb-4bcc-982c-9d0d86317258", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8\n        self.CR = 0.9\n        self.base_convergence_threshold = 0.01\n        self.convergence_threshold = self.base_convergence_threshold\n\n    def mutation(self, population, fitness):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        sorted_idx = np.argsort(fitness[idxs])  # Sort by fitness\n        best, mid, worst = population[idxs[sorted_idx]]\n        if fitness[idxs[sorted_idx[0]]] < self.convergence_threshold:\n            adaptive_F = self.F * 0.5\n        else:\n            adaptive_F = self.F * 1.2\n        return best + adaptive_F * (mid - worst)\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        self.convergence_threshold = max(self.base_convergence_threshold / 2, np.std(fitness) / 10)\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population, fitness)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "EnhancedDifferentialEvolution", "description": "Enhance exploration and exploitation in Adaptive Differential Evolution by introducing threshold-based mutation and dynamic reduction of convergence threshold.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "53e51370-34c4-442f-9ebd-488e95c422aa", "metadata": {"aucs": [0.30236129520036015, 0.2850046132906414, 0.31316180531782034, 0.3186508148213587, 0.34587557045263173, 0.33397597486131003, 0.5476299265642639, 0.7525595133216176, 0.5917738738827856, 0.5760637047770985, 0.5622115136473553, 0.4962684546423174, 0.6033889642700815, 0.6245058680012969, 0.6590917401168723, 0.6058595646631237, 0.638108620811118, 0.5314197249829808, 0.10410255287903347, 0.10258812023936947, 0.1344004950649611, 0.08223316632102307, 0.08599149866684674, 0.10296431768631809, 0.11847471437113577, 0.09143143737328085, 0.10161067603561391, 0.11296422660433869, 0.10246378443841497, 0.1209378652536861, 0.06676026872779472, 0.07230741981639077, 0.07437255868153714, 0.06719975837862913, 0.06555748805536821, 0.06916657862586639, 0.9535832431173171, 0.956247699404561, 0.9566489219042099, 0.9660545815417472, 0.9523590600321148, 0.9609207475412704, 0.9578044851330831, 0.9701883978308043, 0.9757484019412868, 0.17088885858518565, 0.2868802641044176, 0.3431138546233081, 0.37061889913475277, 0.38108136096260636, 0.1722687074647019, 0.3985990547110896, 0.41408256856537273, 0.35581717566076954, 0.15593124039286232, 0.1587869245666439, 0.1822205083636137, 0.15772242270593684, 0.2035865710469984, 0.17041336623493886, 0.20316037506544427, 0.4952063638329318, 0.25208538743693576, 0.26920505116378557, 0.21665733731489134, 0.14330207400432404, 0.12874693771889, 0.34427136360927013, 0.21461216149978557, 0.2423196788552917, 0.29878474685990875, 0.20293783507272067, 0.18794270841839922, 0.11914351686641056, 0.13705859891038397, 0.17569835630493125, 0.15688825193851408, 0.18608286101081917, 0.25233919498841373, 0.19088618569740334, 0.15047770883723843, 0.44860710734169373, 0.16862143352281822, 0.47932420844111845, 0.494422140601097, 0.4489781636629462, 0.2674274670687409, 0.4801580573476113, 0.43852211582475664, 0.34634601474201, 0.240298199520235, 0.44019465336175745, 0.24460865977397994, 0.5385114299362563, 0.5650462137306346, 0.5833452899225648, 0.5346861259221299, 0.5327977424649197, 0.4636678670278843, 0.24844112534579343, 0.048033541356767295, 0.1672848337022388, 0.2141902755136118, 0.4080834154349626, 0.19569945640914477, 0.17792400341596726, 0.23812057024179556, 0.17471512014818324, 0.04133513562937752, 0.030207172804662008, 0.02954620476277814, 0.06217840767995564, 0.0679026482466667, 0.07105915359593351, 0.27643721928800846, 0.33537907823275837, 0.2626994111063323, 0.7266963120843419, 0.6434014129930583, 0.5891069749558541, 0.7001397809344556, 0.6806690593545373, 0.5387460934417838, 0.2754627279251398, 0.3005835969233728, 0.27039678597234984, 0.06710514083158536, 0.06785028315557262, 0.07248794042675943, 0.06176788966062685, 0.060662590408076755, 0.06778492166861139, 0.07006791135396195, 0.07627948183072664, 0.08265335480963532, 0.1319398502471535, 0.1289088048526541, 0.13241917614550835, 0.12283440376968158, 0.11382325769464097, 0.12716833592720578, 0.12277064483508349, 0.14745568869154524, 0.12388495127425647, 0.44039897081477064, 0.39376648508184986, 0.38753514060627436, 0.16973969607590467, 0.17171691064132633, 0.16416735922730497, 0.2033505050112584, 0.19299014554525018, 0.1969751583607089, 0.20193498333523596, 0.31175019154320316, 0.23782954954761104, 0.12422708618870293, 0.11494119665941527, 0.11193752417206904, 0.1347495581862882, 0.13766310298855, 0.12386414876721119, 0.22022354515617515, 0.16848634990105604, 0.19044539707083497, 0.163034287323356, 0.15369232542041467, 0.15984047129929713, 0.1612313467814933, 0.15008756581370586, 0.15880440602411638, 0.18656712496841865, 0.27252232101478036, 0.20242579879665523, 0.1858365274883299, 0.15432948777398925, 0.18617535536617957, 0.17871722665864986, 0.18345667561945633, 0.17499215613211727, 0.14363424528722302, 0.16895667023776828, 0.1499042706268321, 0.12653682649177278, 0.151133710904106, 0.2038276403359901, 0.17597200726101525, 0.1508398436384486, 0.34821225929435273, 0.26402047654674543, 0.2727423223687261, 0.22686744519366853, 0.1336858958347058, 0.16224201378271996, 0.1650463011100577, 0.18157408403890085, 0.18669066105929244, 0.18592186030930602, 0.18168852988987994, 0.17051010446638426, 0.18983299140331678, 0.1653063826770632, 0.16664601394629208, 0.17956764367251932, 0.17328037675417507, 0.20298199167910402, 0.16901682404095209, 0.05418906890149666, 0.051843505490605124, 0.05739638657972923, 0.05180473993205559, 0.04816529871508268, 0.04822073032712215, 0.06147699438607268, 0.05222525130093669, 0.05292244381416089]}, "mutation_prompt": null}
{"id": "54ec0ae7-4565-42cd-86c7-774e75193002", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8\n        self.CR = 0.9\n        self.base_convergence_threshold = 0.01\n        self.convergence_threshold = self.base_convergence_threshold\n\n    def mutation(self, population, fitness):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        sorted_idx = np.argsort(fitness[idxs])  # Sort by fitness\n        best, mid, worst = population[idxs[sorted_idx]]\n        if fitness[idxs[sorted_idx[0]]] < self.convergence_threshold:\n            adaptive_F = self.F * 0.5\n        else:\n            adaptive_F = self.F * 1.2\n        return best + adaptive_F * (mid - worst)\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        self.convergence_threshold = max(self.base_convergence_threshold / 2, np.std(fitness) / 10)\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population, fitness)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "EnhancedDifferentialEvolution", "description": "Enhance exploration and exploitation in Adaptive Differential Evolution by introducing threshold-based mutation and dynamic reduction of convergence threshold.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "53e51370-34c4-442f-9ebd-488e95c422aa", "metadata": {"aucs": [0.30236129520036015, 0.2850046132906414, 0.31316180531782034, 0.3186508148213587, 0.34587557045263173, 0.33397597486131003, 0.5476299265642639, 0.7525595133216176, 0.5917738738827856, 0.5760637047770985, 0.5622115136473553, 0.4962684546423174, 0.6033889642700815, 0.6245058680012969, 0.6590917401168723, 0.6058595646631237, 0.638108620811118, 0.5314197249829808, 0.10410255287903347, 0.10258812023936947, 0.1344004950649611, 0.08223316632102307, 0.08599149866684674, 0.10296431768631809, 0.11847471437113577, 0.09143143737328085, 0.10161067603561391, 0.11296422660433869, 0.10246378443841497, 0.1209378652536861, 0.06676026872779472, 0.07230741981639077, 0.07437255868153714, 0.06719975837862913, 0.06555748805536821, 0.06916657862586639, 0.9535832431173171, 0.956247699404561, 0.9566489219042099, 0.9660545815417472, 0.9523590600321148, 0.9609207475412704, 0.9578044851330831, 0.9701883978308043, 0.9757484019412868, 0.17088885858518565, 0.2868802641044176, 0.3431138546233081, 0.37061889913475277, 0.38108136096260636, 0.1722687074647019, 0.3985990547110896, 0.41408256856537273, 0.35581717566076954, 0.15593124039286232, 0.1587869245666439, 0.1822205083636137, 0.15772242270593684, 0.2035865710469984, 0.17041336623493886, 0.20316037506544427, 0.4952063638329318, 0.25208538743693576, 0.26920505116378557, 0.21665733731489134, 0.14330207400432404, 0.12874693771889, 0.34427136360927013, 0.21461216149978557, 0.2423196788552917, 0.29878474685990875, 0.20293783507272067, 0.18794270841839922, 0.11914351686641056, 0.13705859891038397, 0.17569835630493125, 0.15688825193851408, 0.18608286101081917, 0.25233919498841373, 0.19088618569740334, 0.15047770883723843, 0.44860710734169373, 0.16862143352281822, 0.47932420844111845, 0.494422140601097, 0.4489781636629462, 0.2674274670687409, 0.4801580573476113, 0.43852211582475664, 0.34634601474201, 0.240298199520235, 0.44019465336175745, 0.24460865977397994, 0.5385114299362563, 0.5650462137306346, 0.5833452899225648, 0.5346861259221299, 0.5327977424649197, 0.4636678670278843, 0.24844112534579343, 0.048033541356767295, 0.1672848337022388, 0.2141902755136118, 0.4080834154349626, 0.19569945640914477, 0.17792400341596726, 0.23812057024179556, 0.17471512014818324, 0.04133513562937752, 0.030207172804662008, 0.02954620476277814, 0.06217840767995564, 0.0679026482466667, 0.07105915359593351, 0.27643721928800846, 0.33537907823275837, 0.2626994111063323, 0.7266963120843419, 0.6434014129930583, 0.5891069749558541, 0.7001397809344556, 0.6806690593545373, 0.5387460934417838, 0.2754627279251398, 0.3005835969233728, 0.27039678597234984, 0.06710514083158536, 0.06785028315557262, 0.07248794042675943, 0.06176788966062685, 0.060662590408076755, 0.06778492166861139, 0.07006791135396195, 0.07627948183072664, 0.08265335480963532, 0.1319398502471535, 0.1289088048526541, 0.13241917614550835, 0.12283440376968158, 0.11382325769464097, 0.12716833592720578, 0.12277064483508349, 0.14745568869154524, 0.12388495127425647, 0.44039897081477064, 0.39376648508184986, 0.38753514060627436, 0.16973969607590467, 0.17171691064132633, 0.16416735922730497, 0.2033505050112584, 0.19299014554525018, 0.1969751583607089, 0.20193498333523596, 0.31175019154320316, 0.23782954954761104, 0.12422708618870293, 0.11494119665941527, 0.11193752417206904, 0.1347495581862882, 0.13766310298855, 0.12386414876721119, 0.22022354515617515, 0.16848634990105604, 0.19044539707083497, 0.163034287323356, 0.15369232542041467, 0.15984047129929713, 0.1612313467814933, 0.15008756581370586, 0.15880440602411638, 0.18656712496841865, 0.27252232101478036, 0.20242579879665523, 0.1858365274883299, 0.15432948777398925, 0.18617535536617957, 0.17871722665864986, 0.18345667561945633, 0.17499215613211727, 0.14363424528722302, 0.16895667023776828, 0.1499042706268321, 0.12653682649177278, 0.151133710904106, 0.2038276403359901, 0.17597200726101525, 0.1508398436384486, 0.34821225929435273, 0.26402047654674543, 0.2727423223687261, 0.22686744519366853, 0.1336858958347058, 0.16224201378271996, 0.1650463011100577, 0.18157408403890085, 0.18669066105929244, 0.18592186030930602, 0.18168852988987994, 0.17051010446638426, 0.18983299140331678, 0.1653063826770632, 0.16664601394629208, 0.17956764367251932, 0.17328037675417507, 0.20298199167910402, 0.16901682404095209, 0.05418906890149666, 0.051843505490605124, 0.05739638657972923, 0.05180473993205559, 0.04816529871508268, 0.04822073032712215, 0.06147699438607268, 0.05222525130093669, 0.05292244381416089]}, "mutation_prompt": null}
{"id": "71fef994-fb75-402d-b0e1-04172511b64a", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8\n        self.CR = 0.9\n        self.base_convergence_threshold = 0.01\n        self.convergence_threshold = self.base_convergence_threshold\n\n    def mutation(self, population, fitness):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        sorted_idx = np.argsort(fitness[idxs])  # Sort by fitness\n        best, mid, worst = population[idxs[sorted_idx]]\n        if fitness[idxs[sorted_idx[0]]] < self.convergence_threshold:\n            adaptive_F = self.F * 0.5\n        else:\n            adaptive_F = self.F * 1.2\n        return best + adaptive_F * (mid - worst)\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        self.convergence_threshold = max(self.base_convergence_threshold / 2, np.std(fitness) / 10)\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population, fitness)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "EnhancedDifferentialEvolution", "description": "Enhance exploration and exploitation in Adaptive Differential Evolution by introducing threshold-based mutation and dynamic reduction of convergence threshold.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "53e51370-34c4-442f-9ebd-488e95c422aa", "metadata": {"aucs": [0.30236129520036015, 0.2850046132906414, 0.31316180531782034, 0.3186508148213587, 0.34587557045263173, 0.33397597486131003, 0.5476299265642639, 0.7525595133216176, 0.5917738738827856, 0.5760637047770985, 0.5622115136473553, 0.4962684546423174, 0.6033889642700815, 0.6245058680012969, 0.6590917401168723, 0.6058595646631237, 0.638108620811118, 0.5314197249829808, 0.10410255287903347, 0.10258812023936947, 0.1344004950649611, 0.08223316632102307, 0.08599149866684674, 0.10296431768631809, 0.11847471437113577, 0.09143143737328085, 0.10161067603561391, 0.11296422660433869, 0.10246378443841497, 0.1209378652536861, 0.06676026872779472, 0.07230741981639077, 0.07437255868153714, 0.06719975837862913, 0.06555748805536821, 0.06916657862586639, 0.9535832431173171, 0.956247699404561, 0.9566489219042099, 0.9660545815417472, 0.9523590600321148, 0.9609207475412704, 0.9578044851330831, 0.9701883978308043, 0.9757484019412868, 0.17088885858518565, 0.2868802641044176, 0.3431138546233081, 0.37061889913475277, 0.38108136096260636, 0.1722687074647019, 0.3985990547110896, 0.41408256856537273, 0.35581717566076954, 0.15593124039286232, 0.1587869245666439, 0.1822205083636137, 0.15772242270593684, 0.2035865710469984, 0.17041336623493886, 0.20316037506544427, 0.4952063638329318, 0.25208538743693576, 0.26920505116378557, 0.21665733731489134, 0.14330207400432404, 0.12874693771889, 0.34427136360927013, 0.21461216149978557, 0.2423196788552917, 0.29878474685990875, 0.20293783507272067, 0.18794270841839922, 0.11914351686641056, 0.13705859891038397, 0.17569835630493125, 0.15688825193851408, 0.18608286101081917, 0.25233919498841373, 0.19088618569740334, 0.15047770883723843, 0.44860710734169373, 0.16862143352281822, 0.47932420844111845, 0.494422140601097, 0.4489781636629462, 0.2674274670687409, 0.4801580573476113, 0.43852211582475664, 0.34634601474201, 0.240298199520235, 0.44019465336175745, 0.24460865977397994, 0.5385114299362563, 0.5650462137306346, 0.5833452899225648, 0.5346861259221299, 0.5327977424649197, 0.4636678670278843, 0.24844112534579343, 0.048033541356767295, 0.1672848337022388, 0.2141902755136118, 0.4080834154349626, 0.19569945640914477, 0.17792400341596726, 0.23812057024179556, 0.17471512014818324, 0.04133513562937752, 0.030207172804662008, 0.02954620476277814, 0.06217840767995564, 0.0679026482466667, 0.07105915359593351, 0.27643721928800846, 0.33537907823275837, 0.2626994111063323, 0.7266963120843419, 0.6434014129930583, 0.5891069749558541, 0.7001397809344556, 0.6806690593545373, 0.5387460934417838, 0.2754627279251398, 0.3005835969233728, 0.27039678597234984, 0.06710514083158536, 0.06785028315557262, 0.07248794042675943, 0.06176788966062685, 0.060662590408076755, 0.06778492166861139, 0.07006791135396195, 0.07627948183072664, 0.08265335480963532, 0.1319398502471535, 0.1289088048526541, 0.13241917614550835, 0.12283440376968158, 0.11382325769464097, 0.12716833592720578, 0.12277064483508349, 0.14745568869154524, 0.12388495127425647, 0.44039897081477064, 0.39376648508184986, 0.38753514060627436, 0.16973969607590467, 0.17171691064132633, 0.16416735922730497, 0.2033505050112584, 0.19299014554525018, 0.1969751583607089, 0.20193498333523596, 0.31175019154320316, 0.23782954954761104, 0.12422708618870293, 0.11494119665941527, 0.11193752417206904, 0.1347495581862882, 0.13766310298855, 0.12386414876721119, 0.22022354515617515, 0.16848634990105604, 0.19044539707083497, 0.163034287323356, 0.15369232542041467, 0.15984047129929713, 0.1612313467814933, 0.15008756581370586, 0.15880440602411638, 0.18656712496841865, 0.27252232101478036, 0.20242579879665523, 0.1858365274883299, 0.15432948777398925, 0.18617535536617957, 0.17871722665864986, 0.18345667561945633, 0.17499215613211727, 0.14363424528722302, 0.16895667023776828, 0.1499042706268321, 0.12653682649177278, 0.151133710904106, 0.2038276403359901, 0.17597200726101525, 0.1508398436384486, 0.34821225929435273, 0.26402047654674543, 0.2727423223687261, 0.22686744519366853, 0.1336858958347058, 0.16224201378271996, 0.1650463011100577, 0.18157408403890085, 0.18669066105929244, 0.18592186030930602, 0.18168852988987994, 0.17051010446638426, 0.18983299140331678, 0.1653063826770632, 0.16664601394629208, 0.17956764367251932, 0.17328037675417507, 0.20298199167910402, 0.16901682404095209, 0.05418906890149666, 0.051843505490605124, 0.05739638657972923, 0.05180473993205559, 0.04816529871508268, 0.04822073032712215, 0.06147699438607268, 0.05222525130093669, 0.05292244381416089]}, "mutation_prompt": null}
{"id": "ab9e536b-d44d-42ce-876c-4704e1cfb79d", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8\n        self.CR = 0.9\n        self.base_convergence_threshold = 0.01\n        self.convergence_threshold = self.base_convergence_threshold\n\n    def mutation(self, population, fitness):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        sorted_idx = np.argsort(fitness[idxs])  # Sort by fitness\n        best, mid, worst = population[idxs[sorted_idx]]\n        if fitness[idxs[sorted_idx[0]]] < self.convergence_threshold:\n            adaptive_F = self.F * 0.5\n        else:\n            adaptive_F = self.F * 1.2\n        return best + adaptive_F * (mid - worst)\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        self.convergence_threshold = max(self.base_convergence_threshold / 2, np.std(fitness) / 10)\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population, fitness)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "EnhancedDifferentialEvolution", "description": "Enhance exploration and exploitation in Adaptive Differential Evolution by introducing threshold-based mutation and dynamic reduction of convergence threshold.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "53e51370-34c4-442f-9ebd-488e95c422aa", "metadata": {"aucs": [0.30236129520036015, 0.2850046132906414, 0.31316180531782034, 0.3186508148213587, 0.34587557045263173, 0.33397597486131003, 0.5476299265642639, 0.7525595133216176, 0.5917738738827856, 0.5760637047770985, 0.5622115136473553, 0.4962684546423174, 0.6033889642700815, 0.6245058680012969, 0.6590917401168723, 0.6058595646631237, 0.638108620811118, 0.5314197249829808, 0.10410255287903347, 0.10258812023936947, 0.1344004950649611, 0.08223316632102307, 0.08599149866684674, 0.10296431768631809, 0.11847471437113577, 0.09143143737328085, 0.10161067603561391, 0.11296422660433869, 0.10246378443841497, 0.1209378652536861, 0.06676026872779472, 0.07230741981639077, 0.07437255868153714, 0.06719975837862913, 0.06555748805536821, 0.06916657862586639, 0.9535832431173171, 0.956247699404561, 0.9566489219042099, 0.9660545815417472, 0.9523590600321148, 0.9609207475412704, 0.9578044851330831, 0.9701883978308043, 0.9757484019412868, 0.17088885858518565, 0.2868802641044176, 0.3431138546233081, 0.37061889913475277, 0.38108136096260636, 0.1722687074647019, 0.3985990547110896, 0.41408256856537273, 0.35581717566076954, 0.15593124039286232, 0.1587869245666439, 0.1822205083636137, 0.15772242270593684, 0.2035865710469984, 0.17041336623493886, 0.20316037506544427, 0.4952063638329318, 0.25208538743693576, 0.26920505116378557, 0.21665733731489134, 0.14330207400432404, 0.12874693771889, 0.34427136360927013, 0.21461216149978557, 0.2423196788552917, 0.29878474685990875, 0.20293783507272067, 0.18794270841839922, 0.11914351686641056, 0.13705859891038397, 0.17569835630493125, 0.15688825193851408, 0.18608286101081917, 0.25233919498841373, 0.19088618569740334, 0.15047770883723843, 0.44860710734169373, 0.16862143352281822, 0.47932420844111845, 0.494422140601097, 0.4489781636629462, 0.2674274670687409, 0.4801580573476113, 0.43852211582475664, 0.34634601474201, 0.240298199520235, 0.44019465336175745, 0.24460865977397994, 0.5385114299362563, 0.5650462137306346, 0.5833452899225648, 0.5346861259221299, 0.5327977424649197, 0.4636678670278843, 0.24844112534579343, 0.048033541356767295, 0.1672848337022388, 0.2141902755136118, 0.4080834154349626, 0.19569945640914477, 0.17792400341596726, 0.23812057024179556, 0.17471512014818324, 0.04133513562937752, 0.030207172804662008, 0.02954620476277814, 0.06217840767995564, 0.0679026482466667, 0.07105915359593351, 0.27643721928800846, 0.33537907823275837, 0.2626994111063323, 0.7266963120843419, 0.6434014129930583, 0.5891069749558541, 0.7001397809344556, 0.6806690593545373, 0.5387460934417838, 0.2754627279251398, 0.3005835969233728, 0.27039678597234984, 0.06710514083158536, 0.06785028315557262, 0.07248794042675943, 0.06176788966062685, 0.060662590408076755, 0.06778492166861139, 0.07006791135396195, 0.07627948183072664, 0.08265335480963532, 0.1319398502471535, 0.1289088048526541, 0.13241917614550835, 0.12283440376968158, 0.11382325769464097, 0.12716833592720578, 0.12277064483508349, 0.14745568869154524, 0.12388495127425647, 0.44039897081477064, 0.39376648508184986, 0.38753514060627436, 0.16973969607590467, 0.17171691064132633, 0.16416735922730497, 0.2033505050112584, 0.19299014554525018, 0.1969751583607089, 0.20193498333523596, 0.31175019154320316, 0.23782954954761104, 0.12422708618870293, 0.11494119665941527, 0.11193752417206904, 0.1347495581862882, 0.13766310298855, 0.12386414876721119, 0.22022354515617515, 0.16848634990105604, 0.19044539707083497, 0.163034287323356, 0.15369232542041467, 0.15984047129929713, 0.1612313467814933, 0.15008756581370586, 0.15880440602411638, 0.18656712496841865, 0.27252232101478036, 0.20242579879665523, 0.1858365274883299, 0.15432948777398925, 0.18617535536617957, 0.17871722665864986, 0.18345667561945633, 0.17499215613211727, 0.14363424528722302, 0.16895667023776828, 0.1499042706268321, 0.12653682649177278, 0.151133710904106, 0.2038276403359901, 0.17597200726101525, 0.1508398436384486, 0.34821225929435273, 0.26402047654674543, 0.2727423223687261, 0.22686744519366853, 0.1336858958347058, 0.16224201378271996, 0.1650463011100577, 0.18157408403890085, 0.18669066105929244, 0.18592186030930602, 0.18168852988987994, 0.17051010446638426, 0.18983299140331678, 0.1653063826770632, 0.16664601394629208, 0.17956764367251932, 0.17328037675417507, 0.20298199167910402, 0.16901682404095209, 0.05418906890149666, 0.051843505490605124, 0.05739638657972923, 0.05180473993205559, 0.04816529871508268, 0.04822073032712215, 0.06147699438607268, 0.05222525130093669, 0.05292244381416089]}, "mutation_prompt": null}
{"id": "ab869742-b71f-43ef-a9d8-8c741e1efde8", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8\n        self.CR = 0.9\n        self.base_convergence_threshold = 0.01\n        self.convergence_threshold = self.base_convergence_threshold\n\n    def mutation(self, population, fitness):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        sorted_idx = np.argsort(fitness[idxs])  # Sort by fitness\n        best, mid, worst = population[idxs[sorted_idx]]\n        if fitness[idxs[sorted_idx[0]]] < self.convergence_threshold:\n            adaptive_F = self.F * 0.5\n        else:\n            adaptive_F = self.F * 1.2\n        return best + adaptive_F * (mid - worst)\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        self.convergence_threshold = max(self.base_convergence_threshold / 2, np.std(fitness) / 10)\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population, fitness)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "EnhancedDifferentialEvolution", "description": "Enhance exploration and exploitation in Adaptive Differential Evolution by introducing threshold-based mutation and dynamic reduction of convergence threshold.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "53e51370-34c4-442f-9ebd-488e95c422aa", "metadata": {"aucs": [0.30236129520036015, 0.2850046132906414, 0.31316180531782034, 0.3186508148213587, 0.34587557045263173, 0.33397597486131003, 0.5476299265642639, 0.7525595133216176, 0.5917738738827856, 0.5760637047770985, 0.5622115136473553, 0.4962684546423174, 0.6033889642700815, 0.6245058680012969, 0.6590917401168723, 0.6058595646631237, 0.638108620811118, 0.5314197249829808, 0.10410255287903347, 0.10258812023936947, 0.1344004950649611, 0.08223316632102307, 0.08599149866684674, 0.10296431768631809, 0.11847471437113577, 0.09143143737328085, 0.10161067603561391, 0.11296422660433869, 0.10246378443841497, 0.1209378652536861, 0.06676026872779472, 0.07230741981639077, 0.07437255868153714, 0.06719975837862913, 0.06555748805536821, 0.06916657862586639, 0.9535832431173171, 0.956247699404561, 0.9566489219042099, 0.9660545815417472, 0.9523590600321148, 0.9609207475412704, 0.9578044851330831, 0.9701883978308043, 0.9757484019412868, 0.17088885858518565, 0.2868802641044176, 0.3431138546233081, 0.37061889913475277, 0.38108136096260636, 0.1722687074647019, 0.3985990547110896, 0.41408256856537273, 0.35581717566076954, 0.15593124039286232, 0.1587869245666439, 0.1822205083636137, 0.15772242270593684, 0.2035865710469984, 0.17041336623493886, 0.20316037506544427, 0.4952063638329318, 0.25208538743693576, 0.26920505116378557, 0.21665733731489134, 0.14330207400432404, 0.12874693771889, 0.34427136360927013, 0.21461216149978557, 0.2423196788552917, 0.29878474685990875, 0.20293783507272067, 0.18794270841839922, 0.11914351686641056, 0.13705859891038397, 0.17569835630493125, 0.15688825193851408, 0.18608286101081917, 0.25233919498841373, 0.19088618569740334, 0.15047770883723843, 0.44860710734169373, 0.16862143352281822, 0.47932420844111845, 0.494422140601097, 0.4489781636629462, 0.2674274670687409, 0.4801580573476113, 0.43852211582475664, 0.34634601474201, 0.240298199520235, 0.44019465336175745, 0.24460865977397994, 0.5385114299362563, 0.5650462137306346, 0.5833452899225648, 0.5346861259221299, 0.5327977424649197, 0.4636678670278843, 0.24844112534579343, 0.048033541356767295, 0.1672848337022388, 0.2141902755136118, 0.4080834154349626, 0.19569945640914477, 0.17792400341596726, 0.23812057024179556, 0.17471512014818324, 0.04133513562937752, 0.030207172804662008, 0.02954620476277814, 0.06217840767995564, 0.0679026482466667, 0.07105915359593351, 0.27643721928800846, 0.33537907823275837, 0.2626994111063323, 0.7266963120843419, 0.6434014129930583, 0.5891069749558541, 0.7001397809344556, 0.6806690593545373, 0.5387460934417838, 0.2754627279251398, 0.3005835969233728, 0.27039678597234984, 0.06710514083158536, 0.06785028315557262, 0.07248794042675943, 0.06176788966062685, 0.060662590408076755, 0.06778492166861139, 0.07006791135396195, 0.07627948183072664, 0.08265335480963532, 0.1319398502471535, 0.1289088048526541, 0.13241917614550835, 0.12283440376968158, 0.11382325769464097, 0.12716833592720578, 0.12277064483508349, 0.14745568869154524, 0.12388495127425647, 0.44039897081477064, 0.39376648508184986, 0.38753514060627436, 0.16973969607590467, 0.17171691064132633, 0.16416735922730497, 0.2033505050112584, 0.19299014554525018, 0.1969751583607089, 0.20193498333523596, 0.31175019154320316, 0.23782954954761104, 0.12422708618870293, 0.11494119665941527, 0.11193752417206904, 0.1347495581862882, 0.13766310298855, 0.12386414876721119, 0.22022354515617515, 0.16848634990105604, 0.19044539707083497, 0.163034287323356, 0.15369232542041467, 0.15984047129929713, 0.1612313467814933, 0.15008756581370586, 0.15880440602411638, 0.18656712496841865, 0.27252232101478036, 0.20242579879665523, 0.1858365274883299, 0.15432948777398925, 0.18617535536617957, 0.17871722665864986, 0.18345667561945633, 0.17499215613211727, 0.14363424528722302, 0.16895667023776828, 0.1499042706268321, 0.12653682649177278, 0.151133710904106, 0.2038276403359901, 0.17597200726101525, 0.1508398436384486, 0.34821225929435273, 0.26402047654674543, 0.2727423223687261, 0.22686744519366853, 0.1336858958347058, 0.16224201378271996, 0.1650463011100577, 0.18157408403890085, 0.18669066105929244, 0.18592186030930602, 0.18168852988987994, 0.17051010446638426, 0.18983299140331678, 0.1653063826770632, 0.16664601394629208, 0.17956764367251932, 0.17328037675417507, 0.20298199167910402, 0.16901682404095209, 0.05418906890149666, 0.051843505490605124, 0.05739638657972923, 0.05180473993205559, 0.04816529871508268, 0.04822073032712215, 0.06147699438607268, 0.05222525130093669, 0.05292244381416089]}, "mutation_prompt": null}
{"id": "f388653c-956f-4261-9f66-6e599121dfaf", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 12 * dim)  # Adjusted for better initial exploration\n        self.population_size = self.initial_population_size\n        self.F = 0.8\n        self.CR = 0.9\n        self.base_convergence_threshold = 0.01\n        self.convergence_threshold = self.base_convergence_threshold\n        self.dynamic_scaling_factor = 0.5  # New scaling factor for dynamic mutation\n\n    def mutation(self, population, fitness):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        sorted_idx = np.argsort(fitness[idxs])  # Sort by fitness\n        best, mid, worst = population[idxs[sorted_idx]]\n        adaptive_F = self.F * (1 + self.dynamic_scaling_factor * (fitness[idxs[sorted_idx[0]]] - fitness[idxs[sorted_idx[1]]]) / (fitness[idxs[sorted_idx[0]]] - fitness[idxs[sorted_idx[2]]] + 1e-10))\n        return best + adaptive_F * (mid - worst)\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        self.convergence_threshold = max(self.base_convergence_threshold / 2, np.std(fitness) / 10)\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population, fitness)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "EnhancedDifferentialEvolution", "description": "Refine exploration with dynamic mutation scaling and adaptive population diversification for Improved Differential Evolution.", "configspace": "", "generation": 93, "fitness": 0.14693053047844307, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.18.", "error": "", "parent_id": "53e51370-34c4-442f-9ebd-488e95c422aa", "metadata": {"aucs": [0.2821195104799844, 0.24853102187786358, 0.26745671481723643, 0.3119646147427424, 0.3206942271581401, 0.2992485470631253, 0.30242477671000323, 0.30281321754476664, 0.29443607340888933, 0.04291520919356495, 0.053507882817538155, 0.03978457465747465, 0.035578580952065564, 0.05043698228988158, 0.046757679738006264, 0.043790461131269165, 0.03986065842071218, 0.05780101368219637, 0.07632997059818614, 0.08080230039116032, 0.0867317209340841, 0.07444764495987033, 0.08480082041864101, 0.07276028052968997, 0.08477327127226142, 0.07470425975876804, 0.07665018562712833, 0.05686829023964879, 0.06843102687283531, 0.060922743051758155, 0.060906966140482965, 0.05589114552139818, 0.0584197540071707, 0.05014911797181654, 0.06089331306396639, 0.06242365054090604, 0.9463148345388417, 0.9472378277594324, 0.9221045038944743, 0.9474884116324076, 0.9352786765009312, 0.9548940975387262, 0.9568450245031983, 0.9678197070221729, 0.9769814395499892, 0.12464319390897849, 0.11871869759137132, 0.11308501260385606, 0.11410333505935577, 0.11435016942926812, 0.12467664533467981, 0.1277361354504608, 0.12103164916391329, 0.16051961708595985, 0.1369107126351935, 0.16270011949586205, 0.15262554670547868, 0.20054220227021413, 0.14609516811090684, 0.1670962120098517, 0.17189275686575656, 0.1763463289620666, 0.22121325647996537, 0.03850972859090229, 0.05093570959576477, 0.06824909146552671, 0.0865175685784505, 0.07107893096403517, 0.09189278051896088, 0.080180170273487, 0.03489552286254294, 0.07449436782909491, 0.009465438386430103, 0.008916643250333589, 0.019252086344386576, 0.06145450061950708, 0.06100961470503152, 0.058598612516114534, 0.046663430613974155, 0.05591079104705199, 0.044271234073631205, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007290722049953957, 9.999999999998899e-05, 0.06458318496021198, 0.09324085208371158, 0.1056945055987406, 0.07392486987760272, 0.057822819789435154, 0.07873451463098224, 0.05111681542146285, 0.11320334101626794, 0.09454619175168333, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02158967489728747, 0.03011218624327361, 0.026475948768822644, 0.02910521564867008, 0.03309884108563943, 0.03233018629305329, 0.024851665889753183, 0.026668242226661865, 0.02794609586757557, 0.23396506459645017, 0.2676854894169183, 0.2554901798037963, 0.26862927457255525, 0.2681434608303207, 0.2737233872972764, 0.22872198400870147, 0.24047168561451904, 0.2524671176113906, 0.06222208674802043, 0.06325283514120494, 0.06583565459919916, 0.05544802288948181, 0.0611669741104548, 0.08498184689045118, 0.05622456673951126, 0.051244166252175316, 0.058679979584760567, 0.12834928482877472, 0.1369178204412428, 0.12754109810804581, 0.15313744358280967, 0.13855306547807522, 0.13219008347573513, 0.13294756609593095, 0.11104823513455542, 0.12196256781401915, 0.1659223485560336, 0.16359578435457456, 0.17435151291913376, 0.17709212485515036, 0.15867712003280898, 0.1704037743514546, 0.18366556792109834, 0.20617225577552833, 0.20270817548573572, 0.11013980356941033, 0.11613580823772773, 0.12023375104569589, 0.1048069646665779, 0.10984736967031916, 0.10041573981901364, 0.1262746152640295, 0.15515637873339472, 0.11521641638516344, 0.15765496907806886, 0.1528852532377094, 0.1505106833905827, 0.1618116922893903, 0.1662803999883783, 0.1593183387955145, 0.1665689599650093, 0.15061556826886657, 0.17179051581004823, 0.13651111136047278, 0.15869978171412658, 0.15655184450593462, 0.1397759590126625, 0.16323203397224717, 0.15502793127515246, 0.1761865929273685, 0.14424447092950654, 0.15729027175783195, 0.150971107183423, 0.16546703830825915, 0.12688107853660058, 0.19032116749678574, 0.14338865690908364, 0.14600195964201235, 0.1324123858158458, 0.15619291663734347, 0.13681997463571682, 0.11821639939600193, 0.13328729502359382, 0.12722598904557914, 0.14309792311364378, 0.13005533428931393, 0.18948878385499734, 0.17211225361575966, 0.14586727732440852, 0.181336943771913, 0.173852349125587, 0.17727793100620926, 0.1906462072895566, 0.17734285366461267, 0.16875872930676883, 0.18079063438639442, 0.17803382845978777, 0.1950768281701275, 0.15820153899652323, 0.05061794629330307, 0.049665734419379604, 0.046685157525509724, 0.04679319309841268, 0.06583907391800836, 0.057547241187290266, 0.05303746668867115, 0.04999220759372891, 0.05830675900088811]}, "mutation_prompt": null}
{"id": "ccd38e59-2096-4d2b-a4f1-642f2247176a", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8\n        self.CR = 0.9\n        self.base_convergence_threshold = 0.01\n        self.convergence_threshold = self.base_convergence_threshold\n\n    def mutation(self, population, fitness):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        sorted_idx = np.argsort(fitness[idxs])  # Sort by fitness\n        best, mid, worst = population[idxs[sorted_idx]]\n        if fitness[idxs[sorted_idx[0]]] < self.convergence_threshold:\n            adaptive_F = self.F * 0.5\n        else:\n            adaptive_F = self.F * 1.2\n        return best + adaptive_F * (mid - worst)\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        self.convergence_threshold = max(self.base_convergence_threshold / 2, np.std(fitness) / 10)\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population, fitness)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "EnhancedDifferentialEvolution", "description": "Enhance exploration and exploitation in Adaptive Differential Evolution by introducing threshold-based mutation and dynamic reduction of convergence threshold.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "53e51370-34c4-442f-9ebd-488e95c422aa", "metadata": {"aucs": [0.30236129520036015, 0.2850046132906414, 0.31316180531782034, 0.3186508148213587, 0.34587557045263173, 0.33397597486131003, 0.5476299265642639, 0.7525595133216176, 0.5917738738827856, 0.5760637047770985, 0.5622115136473553, 0.4962684546423174, 0.6033889642700815, 0.6245058680012969, 0.6590917401168723, 0.6058595646631237, 0.638108620811118, 0.5314197249829808, 0.10410255287903347, 0.10258812023936947, 0.1344004950649611, 0.08223316632102307, 0.08599149866684674, 0.10296431768631809, 0.11847471437113577, 0.09143143737328085, 0.10161067603561391, 0.11296422660433869, 0.10246378443841497, 0.1209378652536861, 0.06676026872779472, 0.07230741981639077, 0.07437255868153714, 0.06719975837862913, 0.06555748805536821, 0.06916657862586639, 0.9535832431173171, 0.956247699404561, 0.9566489219042099, 0.9660545815417472, 0.9523590600321148, 0.9609207475412704, 0.9578044851330831, 0.9701883978308043, 0.9757484019412868, 0.17088885858518565, 0.2868802641044176, 0.3431138546233081, 0.37061889913475277, 0.38108136096260636, 0.1722687074647019, 0.3985990547110896, 0.41408256856537273, 0.35581717566076954, 0.15593124039286232, 0.1587869245666439, 0.1822205083636137, 0.15772242270593684, 0.2035865710469984, 0.17041336623493886, 0.20316037506544427, 0.4952063638329318, 0.25208538743693576, 0.26920505116378557, 0.21665733731489134, 0.14330207400432404, 0.12874693771889, 0.34427136360927013, 0.21461216149978557, 0.2423196788552917, 0.29878474685990875, 0.20293783507272067, 0.18794270841839922, 0.11914351686641056, 0.13705859891038397, 0.17569835630493125, 0.15688825193851408, 0.18608286101081917, 0.25233919498841373, 0.19088618569740334, 0.15047770883723843, 0.44860710734169373, 0.16862143352281822, 0.47932420844111845, 0.494422140601097, 0.4489781636629462, 0.2674274670687409, 0.4801580573476113, 0.43852211582475664, 0.34634601474201, 0.240298199520235, 0.44019465336175745, 0.24460865977397994, 0.5385114299362563, 0.5650462137306346, 0.5833452899225648, 0.5346861259221299, 0.5327977424649197, 0.4636678670278843, 0.24844112534579343, 0.048033541356767295, 0.1672848337022388, 0.2141902755136118, 0.4080834154349626, 0.19569945640914477, 0.17792400341596726, 0.23812057024179556, 0.17471512014818324, 0.04133513562937752, 0.030207172804662008, 0.02954620476277814, 0.06217840767995564, 0.0679026482466667, 0.07105915359593351, 0.27643721928800846, 0.33537907823275837, 0.2626994111063323, 0.7266963120843419, 0.6434014129930583, 0.5891069749558541, 0.7001397809344556, 0.6806690593545373, 0.5387460934417838, 0.2754627279251398, 0.3005835969233728, 0.27039678597234984, 0.06710514083158536, 0.06785028315557262, 0.07248794042675943, 0.06176788966062685, 0.060662590408076755, 0.06778492166861139, 0.07006791135396195, 0.07627948183072664, 0.08265335480963532, 0.1319398502471535, 0.1289088048526541, 0.13241917614550835, 0.12283440376968158, 0.11382325769464097, 0.12716833592720578, 0.12277064483508349, 0.14745568869154524, 0.12388495127425647, 0.44039897081477064, 0.39376648508184986, 0.38753514060627436, 0.16973969607590467, 0.17171691064132633, 0.16416735922730497, 0.2033505050112584, 0.19299014554525018, 0.1969751583607089, 0.20193498333523596, 0.31175019154320316, 0.23782954954761104, 0.12422708618870293, 0.11494119665941527, 0.11193752417206904, 0.1347495581862882, 0.13766310298855, 0.12386414876721119, 0.22022354515617515, 0.16848634990105604, 0.19044539707083497, 0.163034287323356, 0.15369232542041467, 0.15984047129929713, 0.1612313467814933, 0.15008756581370586, 0.15880440602411638, 0.18656712496841865, 0.27252232101478036, 0.20242579879665523, 0.1858365274883299, 0.15432948777398925, 0.18617535536617957, 0.17871722665864986, 0.18345667561945633, 0.17499215613211727, 0.14363424528722302, 0.16895667023776828, 0.1499042706268321, 0.12653682649177278, 0.151133710904106, 0.2038276403359901, 0.17597200726101525, 0.1508398436384486, 0.34821225929435273, 0.26402047654674543, 0.2727423223687261, 0.22686744519366853, 0.1336858958347058, 0.16224201378271996, 0.1650463011100577, 0.18157408403890085, 0.18669066105929244, 0.18592186030930602, 0.18168852988987994, 0.17051010446638426, 0.18983299140331678, 0.1653063826770632, 0.16664601394629208, 0.17956764367251932, 0.17328037675417507, 0.20298199167910402, 0.16901682404095209, 0.05418906890149666, 0.051843505490605124, 0.05739638657972923, 0.05180473993205559, 0.04816529871508268, 0.04822073032712215, 0.06147699438607268, 0.05222525130093669, 0.05292244381416089]}, "mutation_prompt": null}
{"id": "2d153662-1adf-43e3-9151-9a7dd21c068c", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8\n        self.CR = 0.9\n        self.base_convergence_threshold = 0.01\n        self.convergence_threshold = self.base_convergence_threshold\n\n    def mutation(self, population, fitness):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        sorted_idx = np.argsort(fitness[idxs])  # Sort by fitness\n        best, mid, worst = population[idxs[sorted_idx]]\n        if fitness[idxs[sorted_idx[0]]] < self.convergence_threshold:\n            adaptive_F = self.F * 0.5\n        else:\n            adaptive_F = self.F * 1.2\n        return best + adaptive_F * (mid - worst)\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        self.convergence_threshold = max(self.base_convergence_threshold / 2, np.std(fitness) / 10)\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population, fitness)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "EnhancedDifferentialEvolution", "description": "Enhance exploration and exploitation in Adaptive Differential Evolution by introducing threshold-based mutation and dynamic reduction of convergence threshold.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "53e51370-34c4-442f-9ebd-488e95c422aa", "metadata": {"aucs": [0.30236129520036015, 0.2850046132906414, 0.31316180531782034, 0.3186508148213587, 0.34587557045263173, 0.33397597486131003, 0.5476299265642639, 0.7525595133216176, 0.5917738738827856, 0.5760637047770985, 0.5622115136473553, 0.4962684546423174, 0.6033889642700815, 0.6245058680012969, 0.6590917401168723, 0.6058595646631237, 0.638108620811118, 0.5314197249829808, 0.10410255287903347, 0.10258812023936947, 0.1344004950649611, 0.08223316632102307, 0.08599149866684674, 0.10296431768631809, 0.11847471437113577, 0.09143143737328085, 0.10161067603561391, 0.11296422660433869, 0.10246378443841497, 0.1209378652536861, 0.06676026872779472, 0.07230741981639077, 0.07437255868153714, 0.06719975837862913, 0.06555748805536821, 0.06916657862586639, 0.9535832431173171, 0.956247699404561, 0.9566489219042099, 0.9660545815417472, 0.9523590600321148, 0.9609207475412704, 0.9578044851330831, 0.9701883978308043, 0.9757484019412868, 0.17088885858518565, 0.2868802641044176, 0.3431138546233081, 0.37061889913475277, 0.38108136096260636, 0.1722687074647019, 0.3985990547110896, 0.41408256856537273, 0.35581717566076954, 0.15593124039286232, 0.1587869245666439, 0.1822205083636137, 0.15772242270593684, 0.2035865710469984, 0.17041336623493886, 0.20316037506544427, 0.4952063638329318, 0.25208538743693576, 0.26920505116378557, 0.21665733731489134, 0.14330207400432404, 0.12874693771889, 0.34427136360927013, 0.21461216149978557, 0.2423196788552917, 0.29878474685990875, 0.20293783507272067, 0.18794270841839922, 0.11914351686641056, 0.13705859891038397, 0.17569835630493125, 0.15688825193851408, 0.18608286101081917, 0.25233919498841373, 0.19088618569740334, 0.15047770883723843, 0.44860710734169373, 0.16862143352281822, 0.47932420844111845, 0.494422140601097, 0.4489781636629462, 0.2674274670687409, 0.4801580573476113, 0.43852211582475664, 0.34634601474201, 0.240298199520235, 0.44019465336175745, 0.24460865977397994, 0.5385114299362563, 0.5650462137306346, 0.5833452899225648, 0.5346861259221299, 0.5327977424649197, 0.4636678670278843, 0.24844112534579343, 0.048033541356767295, 0.1672848337022388, 0.2141902755136118, 0.4080834154349626, 0.19569945640914477, 0.17792400341596726, 0.23812057024179556, 0.17471512014818324, 0.04133513562937752, 0.030207172804662008, 0.02954620476277814, 0.06217840767995564, 0.0679026482466667, 0.07105915359593351, 0.27643721928800846, 0.33537907823275837, 0.2626994111063323, 0.7266963120843419, 0.6434014129930583, 0.5891069749558541, 0.7001397809344556, 0.6806690593545373, 0.5387460934417838, 0.2754627279251398, 0.3005835969233728, 0.27039678597234984, 0.06710514083158536, 0.06785028315557262, 0.07248794042675943, 0.06176788966062685, 0.060662590408076755, 0.06778492166861139, 0.07006791135396195, 0.07627948183072664, 0.08265335480963532, 0.1319398502471535, 0.1289088048526541, 0.13241917614550835, 0.12283440376968158, 0.11382325769464097, 0.12716833592720578, 0.12277064483508349, 0.14745568869154524, 0.12388495127425647, 0.44039897081477064, 0.39376648508184986, 0.38753514060627436, 0.16973969607590467, 0.17171691064132633, 0.16416735922730497, 0.2033505050112584, 0.19299014554525018, 0.1969751583607089, 0.20193498333523596, 0.31175019154320316, 0.23782954954761104, 0.12422708618870293, 0.11494119665941527, 0.11193752417206904, 0.1347495581862882, 0.13766310298855, 0.12386414876721119, 0.22022354515617515, 0.16848634990105604, 0.19044539707083497, 0.163034287323356, 0.15369232542041467, 0.15984047129929713, 0.1612313467814933, 0.15008756581370586, 0.15880440602411638, 0.18656712496841865, 0.27252232101478036, 0.20242579879665523, 0.1858365274883299, 0.15432948777398925, 0.18617535536617957, 0.17871722665864986, 0.18345667561945633, 0.17499215613211727, 0.14363424528722302, 0.16895667023776828, 0.1499042706268321, 0.12653682649177278, 0.151133710904106, 0.2038276403359901, 0.17597200726101525, 0.1508398436384486, 0.34821225929435273, 0.26402047654674543, 0.2727423223687261, 0.22686744519366853, 0.1336858958347058, 0.16224201378271996, 0.1650463011100577, 0.18157408403890085, 0.18669066105929244, 0.18592186030930602, 0.18168852988987994, 0.17051010446638426, 0.18983299140331678, 0.1653063826770632, 0.16664601394629208, 0.17956764367251932, 0.17328037675417507, 0.20298199167910402, 0.16901682404095209, 0.05418906890149666, 0.051843505490605124, 0.05739638657972923, 0.05180473993205559, 0.04816529871508268, 0.04822073032712215, 0.06147699438607268, 0.05222525130093669, 0.05292244381416089]}, "mutation_prompt": null}
{"id": "623f08a8-2ccc-49a3-a145-bdc28b394ab1", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8\n        self.CR = 0.9\n        self.base_convergence_threshold = 0.01\n        self.convergence_threshold = self.base_convergence_threshold\n        self.dynamic_factor = 0.2\n\n    def mutation(self, population, fitness):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        sorted_idx = np.argsort(fitness[idxs])\n        best, mid, worst = population[idxs[sorted_idx]]\n        adaptive_F = self.F * (1.0 + self.dynamic_factor * np.random.uniform(-0.5, 0.5)) \n        return best + adaptive_F * (mid - worst)\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement * self.dynamic_factor)\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        self.convergence_threshold = max(self.base_convergence_threshold / 2, np.std(fitness) / 10)\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population, fitness)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "EnhancedDifferentialEvolution", "description": "Adaptive convergence via dynamic scaling factor and crossover rate adjustments for improved exploration.", "configspace": "", "generation": 96, "fitness": 0.18770170979746603, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.19.", "error": "", "parent_id": "53e51370-34c4-442f-9ebd-488e95c422aa", "metadata": {"aucs": [0.3899084742306773, 0.4200805540886495, 0.3936409692537274, 0.46056468701843745, 0.4053806553531807, 0.48923537847045495, 0.4465170778294729, 0.4460867204839445, 0.4795944018139213, 0.1606033545291886, 0.19279202943800133, 0.16321125336525089, 0.1685736315899954, 0.16769123537028374, 0.15260429733493852, 0.18582342196201218, 0.1548592473149194, 0.15356177398860948, 0.08738205407154442, 0.07933876175849441, 0.09467785859633626, 0.0919165777061467, 0.08282613455944376, 0.0813197828224711, 0.07254221954920526, 0.10012665895388728, 0.09420037459914077, 0.06372705843947046, 0.0821498182275141, 0.0693991278586158, 0.062399410397638744, 0.06025782268640867, 0.07462553657468851, 0.07151460105502572, 0.07735903807246158, 0.0741961381139008, 0.9626861892496626, 0.9447088977883594, 0.9475645107819648, 0.9314035718493806, 0.9634511397634523, 0.9627422073753056, 0.9782901321793992, 0.9610997048040318, 0.9820976509005005, 0.16712065698623868, 0.17332610448344676, 0.17853693395150094, 0.17663814313318393, 0.19644579501979575, 0.16217135309056463, 0.18985982461913242, 0.17579247124017328, 0.1756589272093897, 0.24036651276453802, 0.238036419562078, 0.21353719686027384, 0.2539540584812149, 0.24666526247096277, 0.21804796817130123, 0.23277600540636068, 0.21604009732544205, 0.21026944733407704, 0.09020465946776035, 0.10179012736940074, 0.10812370191251086, 0.09613780013603734, 0.11766299754155829, 0.10483903022791075, 0.1162982077016732, 0.12449886467615001, 0.11489031598548138, 0.14902742704052108, 0.1750754003008691, 0.015728708366957278, 0.11254413976811761, 0.11736473952782234, 0.09384507069158532, 0.09836127564856412, 0.08414434463763243, 0.11934167382346239, 0.01754068054886415, 0.0023075025434964314, 0.011458955165630336, 0.023672862068028322, 0.03352408193153311, 0.011136303415085091, 0.025187409524053184, 0.014233577118244467, 0.03858900418029809, 0.1160506323929914, 0.15386900860715336, 0.09569869393693609, 0.10535852989472116, 0.12391754458419801, 0.11308817864695486, 0.11723518690251489, 0.14030669653051742, 0.1650918710193715, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0003201466908416828, 9.999999999998899e-05, 0.0749816775864407, 0.06715263164006646, 0.07530063522115449, 0.0736697336116926, 0.08709576147720233, 0.07100110665726866, 0.07804612937379263, 0.07151446964997232, 0.059250657133401385, 0.38369619697068114, 0.3762409914338385, 0.3604840230336994, 0.3648243539010597, 0.3799349826061569, 0.37727456050481556, 0.3657816293243715, 0.344855100419417, 0.356948926436257, 0.0768559331575307, 0.07856132952126604, 0.07923292204883092, 0.07824666508034372, 0.07324495323948543, 0.07430528240968792, 0.07015318271459658, 0.0865105047700021, 0.08027752868168825, 0.16396232649962006, 0.11813679744890537, 0.135928859901712, 0.14748526546416574, 0.12182261353596313, 0.12278795329321401, 0.1384173148961838, 0.13338162324643021, 0.1516744171553761, 0.2177640331821049, 0.22729142572072425, 0.21609322705636802, 0.20087534235867088, 0.21501803355073057, 0.2072777327182137, 0.22887526580886397, 0.25251216844554414, 0.231252385269064, 0.15785617204614644, 0.148291968202363, 0.1564691740075267, 0.1536545373602748, 0.16030882854607498, 0.1431748582462966, 0.1587527048485603, 0.19118908595508033, 0.18543644130236459, 0.16028707781995277, 0.16829406343432418, 0.17537821638040385, 0.1830847038506217, 0.17706777383568406, 0.17767760068473604, 0.1662990226433123, 0.18512945186350271, 0.17907969344132435, 0.1703897317240558, 0.1578135450803344, 0.16665459940969207, 0.17310212454820362, 0.16916066558707532, 0.1644516830431081, 0.15954656675267254, 0.16689727323972603, 0.1629254197352128, 0.2155686343326293, 0.4056101647658934, 0.44553643971990897, 0.1229948347745643, 0.16701058754942155, 0.16162143823184383, 0.1631764780854299, 0.15489194845683474, 0.18018671843256417, 0.18226013813720876, 0.1597253747319104, 0.15676299273923455, 0.1448531667277253, 0.14725245889731742, 0.17619358685745268, 0.1801882730470612, 0.20243041211347534, 0.19869104865497478, 0.1754025212840652, 0.18901361000090733, 0.17095134818475122, 0.17140203618109495, 0.16833718595342162, 0.16896101313867817, 0.18882482247119647, 0.17537052769482508, 0.18572129464957465, 0.0589961987217239, 0.060616310810164054, 0.0621075730559667, 0.05750547582177601, 0.06270803067363173, 0.06815329488710664, 0.059184614890444354, 0.07750383256696314, 0.06424262046047713]}, "mutation_prompt": null}
{"id": "48705db9-5188-444a-a92c-8789dded1a67", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8\n        self.CR = 0.9\n        self.base_convergence_threshold = 0.01\n        self.convergence_threshold = self.base_convergence_threshold\n\n    def mutation(self, population, fitness):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        sorted_idx = np.argsort(fitness[idxs])  # Sort by fitness\n        best, mid, worst = population[idxs[sorted_idx]]\n        if fitness[idxs[sorted_idx[0]]] < self.convergence_threshold:\n            adaptive_F = self.F * 0.5\n        else:\n            adaptive_F = self.F * 1.2\n        return best + adaptive_F * (mid - worst)\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        self.convergence_threshold = max(self.base_convergence_threshold / 2, np.std(fitness) / 10)\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population, fitness)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "EnhancedDifferentialEvolution", "description": "Enhance exploration and exploitation in Adaptive Differential Evolution by introducing threshold-based mutation and dynamic reduction of convergence threshold.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "53e51370-34c4-442f-9ebd-488e95c422aa", "metadata": {"aucs": [0.30236129520036015, 0.2850046132906414, 0.31316180531782034, 0.3186508148213587, 0.34587557045263173, 0.33397597486131003, 0.5476299265642639, 0.7525595133216176, 0.5917738738827856, 0.5760637047770985, 0.5622115136473553, 0.4962684546423174, 0.6033889642700815, 0.6245058680012969, 0.6590917401168723, 0.6058595646631237, 0.638108620811118, 0.5314197249829808, 0.10410255287903347, 0.10258812023936947, 0.1344004950649611, 0.08223316632102307, 0.08599149866684674, 0.10296431768631809, 0.11847471437113577, 0.09143143737328085, 0.10161067603561391, 0.11296422660433869, 0.10246378443841497, 0.1209378652536861, 0.06676026872779472, 0.07230741981639077, 0.07437255868153714, 0.06719975837862913, 0.06555748805536821, 0.06916657862586639, 0.9535832431173171, 0.956247699404561, 0.9566489219042099, 0.9660545815417472, 0.9523590600321148, 0.9609207475412704, 0.9578044851330831, 0.9701883978308043, 0.9757484019412868, 0.17088885858518565, 0.2868802641044176, 0.3431138546233081, 0.37061889913475277, 0.38108136096260636, 0.1722687074647019, 0.3985990547110896, 0.41408256856537273, 0.35581717566076954, 0.15593124039286232, 0.1587869245666439, 0.1822205083636137, 0.15772242270593684, 0.2035865710469984, 0.17041336623493886, 0.20316037506544427, 0.4952063638329318, 0.25208538743693576, 0.26920505116378557, 0.21665733731489134, 0.14330207400432404, 0.12874693771889, 0.34427136360927013, 0.21461216149978557, 0.2423196788552917, 0.29878474685990875, 0.20293783507272067, 0.18794270841839922, 0.11914351686641056, 0.13705859891038397, 0.17569835630493125, 0.15688825193851408, 0.18608286101081917, 0.25233919498841373, 0.19088618569740334, 0.15047770883723843, 0.44860710734169373, 0.16862143352281822, 0.47932420844111845, 0.494422140601097, 0.4489781636629462, 0.2674274670687409, 0.4801580573476113, 0.43852211582475664, 0.34634601474201, 0.240298199520235, 0.44019465336175745, 0.24460865977397994, 0.5385114299362563, 0.5650462137306346, 0.5833452899225648, 0.5346861259221299, 0.5327977424649197, 0.4636678670278843, 0.24844112534579343, 0.048033541356767295, 0.1672848337022388, 0.2141902755136118, 0.4080834154349626, 0.19569945640914477, 0.17792400341596726, 0.23812057024179556, 0.17471512014818324, 0.04133513562937752, 0.030207172804662008, 0.02954620476277814, 0.06217840767995564, 0.0679026482466667, 0.07105915359593351, 0.27643721928800846, 0.33537907823275837, 0.2626994111063323, 0.7266963120843419, 0.6434014129930583, 0.5891069749558541, 0.7001397809344556, 0.6806690593545373, 0.5387460934417838, 0.2754627279251398, 0.3005835969233728, 0.27039678597234984, 0.06710514083158536, 0.06785028315557262, 0.07248794042675943, 0.06176788966062685, 0.060662590408076755, 0.06778492166861139, 0.07006791135396195, 0.07627948183072664, 0.08265335480963532, 0.1319398502471535, 0.1289088048526541, 0.13241917614550835, 0.12283440376968158, 0.11382325769464097, 0.12716833592720578, 0.12277064483508349, 0.14745568869154524, 0.12388495127425647, 0.44039897081477064, 0.39376648508184986, 0.38753514060627436, 0.16973969607590467, 0.17171691064132633, 0.16416735922730497, 0.2033505050112584, 0.19299014554525018, 0.1969751583607089, 0.20193498333523596, 0.31175019154320316, 0.23782954954761104, 0.12422708618870293, 0.11494119665941527, 0.11193752417206904, 0.1347495581862882, 0.13766310298855, 0.12386414876721119, 0.22022354515617515, 0.16848634990105604, 0.19044539707083497, 0.163034287323356, 0.15369232542041467, 0.15984047129929713, 0.1612313467814933, 0.15008756581370586, 0.15880440602411638, 0.18656712496841865, 0.27252232101478036, 0.20242579879665523, 0.1858365274883299, 0.15432948777398925, 0.18617535536617957, 0.17871722665864986, 0.18345667561945633, 0.17499215613211727, 0.14363424528722302, 0.16895667023776828, 0.1499042706268321, 0.12653682649177278, 0.151133710904106, 0.2038276403359901, 0.17597200726101525, 0.1508398436384486, 0.34821225929435273, 0.26402047654674543, 0.2727423223687261, 0.22686744519366853, 0.1336858958347058, 0.16224201378271996, 0.1650463011100577, 0.18157408403890085, 0.18669066105929244, 0.18592186030930602, 0.18168852988987994, 0.17051010446638426, 0.18983299140331678, 0.1653063826770632, 0.16664601394629208, 0.17956764367251932, 0.17328037675417507, 0.20298199167910402, 0.16901682404095209, 0.05418906890149666, 0.051843505490605124, 0.05739638657972923, 0.05180473993205559, 0.04816529871508268, 0.04822073032712215, 0.06147699438607268, 0.05222525130093669, 0.05292244381416089]}, "mutation_prompt": null}
{"id": "5a1234a6-17bc-4aa4-bab6-50cb7e8433a6", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8\n        self.CR = 0.9\n        self.base_convergence_threshold = 0.01\n        self.convergence_threshold = self.base_convergence_threshold\n\n    def mutation(self, population, fitness):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        sorted_idx = np.argsort(fitness[idxs])  # Sort by fitness\n        best, mid, worst = population[idxs[sorted_idx]]\n        if fitness[idxs[sorted_idx[0]]] < self.convergence_threshold:\n            adaptive_F = self.F * 0.5\n        else:\n            adaptive_F = self.F * 1.2\n        return best + adaptive_F * (mid - worst)\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        self.convergence_threshold = max(self.base_convergence_threshold / 2, np.std(fitness) / 10)\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population, fitness)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "EnhancedDifferentialEvolution", "description": "Enhance exploration and exploitation in Adaptive Differential Evolution by introducing threshold-based mutation and dynamic reduction of convergence threshold.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "53e51370-34c4-442f-9ebd-488e95c422aa", "metadata": {"aucs": [0.30236129520036015, 0.2850046132906414, 0.31316180531782034, 0.3186508148213587, 0.34587557045263173, 0.33397597486131003, 0.5476299265642639, 0.7525595133216176, 0.5917738738827856, 0.5760637047770985, 0.5622115136473553, 0.4962684546423174, 0.6033889642700815, 0.6245058680012969, 0.6590917401168723, 0.6058595646631237, 0.638108620811118, 0.5314197249829808, 0.10410255287903347, 0.10258812023936947, 0.1344004950649611, 0.08223316632102307, 0.08599149866684674, 0.10296431768631809, 0.11847471437113577, 0.09143143737328085, 0.10161067603561391, 0.11296422660433869, 0.10246378443841497, 0.1209378652536861, 0.06676026872779472, 0.07230741981639077, 0.07437255868153714, 0.06719975837862913, 0.06555748805536821, 0.06916657862586639, 0.9535832431173171, 0.956247699404561, 0.9566489219042099, 0.9660545815417472, 0.9523590600321148, 0.9609207475412704, 0.9578044851330831, 0.9701883978308043, 0.9757484019412868, 0.17088885858518565, 0.2868802641044176, 0.3431138546233081, 0.37061889913475277, 0.38108136096260636, 0.1722687074647019, 0.3985990547110896, 0.41408256856537273, 0.35581717566076954, 0.15593124039286232, 0.1587869245666439, 0.1822205083636137, 0.15772242270593684, 0.2035865710469984, 0.17041336623493886, 0.20316037506544427, 0.4952063638329318, 0.25208538743693576, 0.26920505116378557, 0.21665733731489134, 0.14330207400432404, 0.12874693771889, 0.34427136360927013, 0.21461216149978557, 0.2423196788552917, 0.29878474685990875, 0.20293783507272067, 0.18794270841839922, 0.11914351686641056, 0.13705859891038397, 0.17569835630493125, 0.15688825193851408, 0.18608286101081917, 0.25233919498841373, 0.19088618569740334, 0.15047770883723843, 0.44860710734169373, 0.16862143352281822, 0.47932420844111845, 0.494422140601097, 0.4489781636629462, 0.2674274670687409, 0.4801580573476113, 0.43852211582475664, 0.34634601474201, 0.240298199520235, 0.44019465336175745, 0.24460865977397994, 0.5385114299362563, 0.5650462137306346, 0.5833452899225648, 0.5346861259221299, 0.5327977424649197, 0.4636678670278843, 0.24844112534579343, 0.048033541356767295, 0.1672848337022388, 0.2141902755136118, 0.4080834154349626, 0.19569945640914477, 0.17792400341596726, 0.23812057024179556, 0.17471512014818324, 0.04133513562937752, 0.030207172804662008, 0.02954620476277814, 0.06217840767995564, 0.0679026482466667, 0.07105915359593351, 0.27643721928800846, 0.33537907823275837, 0.2626994111063323, 0.7266963120843419, 0.6434014129930583, 0.5891069749558541, 0.7001397809344556, 0.6806690593545373, 0.5387460934417838, 0.2754627279251398, 0.3005835969233728, 0.27039678597234984, 0.06710514083158536, 0.06785028315557262, 0.07248794042675943, 0.06176788966062685, 0.060662590408076755, 0.06778492166861139, 0.07006791135396195, 0.07627948183072664, 0.08265335480963532, 0.1319398502471535, 0.1289088048526541, 0.13241917614550835, 0.12283440376968158, 0.11382325769464097, 0.12716833592720578, 0.12277064483508349, 0.14745568869154524, 0.12388495127425647, 0.44039897081477064, 0.39376648508184986, 0.38753514060627436, 0.16973969607590467, 0.17171691064132633, 0.16416735922730497, 0.2033505050112584, 0.19299014554525018, 0.1969751583607089, 0.20193498333523596, 0.31175019154320316, 0.23782954954761104, 0.12422708618870293, 0.11494119665941527, 0.11193752417206904, 0.1347495581862882, 0.13766310298855, 0.12386414876721119, 0.22022354515617515, 0.16848634990105604, 0.19044539707083497, 0.163034287323356, 0.15369232542041467, 0.15984047129929713, 0.1612313467814933, 0.15008756581370586, 0.15880440602411638, 0.18656712496841865, 0.27252232101478036, 0.20242579879665523, 0.1858365274883299, 0.15432948777398925, 0.18617535536617957, 0.17871722665864986, 0.18345667561945633, 0.17499215613211727, 0.14363424528722302, 0.16895667023776828, 0.1499042706268321, 0.12653682649177278, 0.151133710904106, 0.2038276403359901, 0.17597200726101525, 0.1508398436384486, 0.34821225929435273, 0.26402047654674543, 0.2727423223687261, 0.22686744519366853, 0.1336858958347058, 0.16224201378271996, 0.1650463011100577, 0.18157408403890085, 0.18669066105929244, 0.18592186030930602, 0.18168852988987994, 0.17051010446638426, 0.18983299140331678, 0.1653063826770632, 0.16664601394629208, 0.17956764367251932, 0.17328037675417507, 0.20298199167910402, 0.16901682404095209, 0.05418906890149666, 0.051843505490605124, 0.05739638657972923, 0.05180473993205559, 0.04816529871508268, 0.04822073032712215, 0.06147699438607268, 0.05222525130093669, 0.05292244381416089]}, "mutation_prompt": null}
{"id": "ba201b7f-e786-4fda-935e-acd8944dad12", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = min(100, 10 * dim)\n        self.population_size = self.initial_population_size\n        self.F = 0.8\n        self.CR = 0.9\n        self.base_convergence_threshold = 0.01\n        self.convergence_threshold = self.base_convergence_threshold\n\n    def mutation(self, population, fitness):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        sorted_idx = np.argsort(fitness[idxs])  # Sort by fitness\n        best, mid, worst = population[idxs[sorted_idx]]\n        if fitness[idxs[sorted_idx[0]]] < self.convergence_threshold:\n            adaptive_F = self.F * 0.5\n        else:\n            adaptive_F = self.F * 1.2\n        return best + adaptive_F * (mid - worst)\n\n    def crossover(self, target, mutant, fitness_improvement):\n        adaptive_CR = self.CR * (1 + fitness_improvement)\n        adaptive_CR = min(1.0, max(0.1, adaptive_CR))\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, trial, target, func):\n        trial_fitness = func(trial)\n        target_fitness = func(target)\n        return (trial, trial_fitness) if trial_fitness < target_fitness else (target, target_fitness)\n\n    def adjust_population_size(self, fitness):\n        self.convergence_threshold = max(self.base_convergence_threshold / 2, np.std(fitness) / 10)\n        if np.std(fitness) < self.convergence_threshold:\n            self.population_size = max(4, self.population_size // 2)\n        else:\n            self.population_size = min(self.initial_population_size, self.population_size * 2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adjust_population_size(fitness)\n            for i in range(self.population_size):\n                mutant = self.mutation(population, fitness)\n                mutant = np.clip(mutant, *self.bounds)\n                fitness_improvement = (np.min(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-10)\n                trial = self.crossover(population[i], mutant, fitness_improvement)\n                trial = np.clip(trial, *self.bounds)\n\n                new_candidate, new_fitness = self.select(trial, population[i], func)\n                evaluations += 1\n\n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "EnhancedDifferentialEvolution", "description": "Enhance exploration and exploitation in Adaptive Differential Evolution by introducing threshold-based mutation and dynamic reduction of convergence threshold.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "53e51370-34c4-442f-9ebd-488e95c422aa", "metadata": {"aucs": [0.30236129520036015, 0.2850046132906414, 0.31316180531782034, 0.3186508148213587, 0.34587557045263173, 0.33397597486131003, 0.5476299265642639, 0.7525595133216176, 0.5917738738827856, 0.5760637047770985, 0.5622115136473553, 0.4962684546423174, 0.6033889642700815, 0.6245058680012969, 0.6590917401168723, 0.6058595646631237, 0.638108620811118, 0.5314197249829808, 0.10410255287903347, 0.10258812023936947, 0.1344004950649611, 0.08223316632102307, 0.08599149866684674, 0.10296431768631809, 0.11847471437113577, 0.09143143737328085, 0.10161067603561391, 0.11296422660433869, 0.10246378443841497, 0.1209378652536861, 0.06676026872779472, 0.07230741981639077, 0.07437255868153714, 0.06719975837862913, 0.06555748805536821, 0.06916657862586639, 0.9535832431173171, 0.956247699404561, 0.9566489219042099, 0.9660545815417472, 0.9523590600321148, 0.9609207475412704, 0.9578044851330831, 0.9701883978308043, 0.9757484019412868, 0.17088885858518565, 0.2868802641044176, 0.3431138546233081, 0.37061889913475277, 0.38108136096260636, 0.1722687074647019, 0.3985990547110896, 0.41408256856537273, 0.35581717566076954, 0.15593124039286232, 0.1587869245666439, 0.1822205083636137, 0.15772242270593684, 0.2035865710469984, 0.17041336623493886, 0.20316037506544427, 0.4952063638329318, 0.25208538743693576, 0.26920505116378557, 0.21665733731489134, 0.14330207400432404, 0.12874693771889, 0.34427136360927013, 0.21461216149978557, 0.2423196788552917, 0.29878474685990875, 0.20293783507272067, 0.18794270841839922, 0.11914351686641056, 0.13705859891038397, 0.17569835630493125, 0.15688825193851408, 0.18608286101081917, 0.25233919498841373, 0.19088618569740334, 0.15047770883723843, 0.44860710734169373, 0.16862143352281822, 0.47932420844111845, 0.494422140601097, 0.4489781636629462, 0.2674274670687409, 0.4801580573476113, 0.43852211582475664, 0.34634601474201, 0.240298199520235, 0.44019465336175745, 0.24460865977397994, 0.5385114299362563, 0.5650462137306346, 0.5833452899225648, 0.5346861259221299, 0.5327977424649197, 0.4636678670278843, 0.24844112534579343, 0.048033541356767295, 0.1672848337022388, 0.2141902755136118, 0.4080834154349626, 0.19569945640914477, 0.17792400341596726, 0.23812057024179556, 0.17471512014818324, 0.04133513562937752, 0.030207172804662008, 0.02954620476277814, 0.06217840767995564, 0.0679026482466667, 0.07105915359593351, 0.27643721928800846, 0.33537907823275837, 0.2626994111063323, 0.7266963120843419, 0.6434014129930583, 0.5891069749558541, 0.7001397809344556, 0.6806690593545373, 0.5387460934417838, 0.2754627279251398, 0.3005835969233728, 0.27039678597234984, 0.06710514083158536, 0.06785028315557262, 0.07248794042675943, 0.06176788966062685, 0.060662590408076755, 0.06778492166861139, 0.07006791135396195, 0.07627948183072664, 0.08265335480963532, 0.1319398502471535, 0.1289088048526541, 0.13241917614550835, 0.12283440376968158, 0.11382325769464097, 0.12716833592720578, 0.12277064483508349, 0.14745568869154524, 0.12388495127425647, 0.44039897081477064, 0.39376648508184986, 0.38753514060627436, 0.16973969607590467, 0.17171691064132633, 0.16416735922730497, 0.2033505050112584, 0.19299014554525018, 0.1969751583607089, 0.20193498333523596, 0.31175019154320316, 0.23782954954761104, 0.12422708618870293, 0.11494119665941527, 0.11193752417206904, 0.1347495581862882, 0.13766310298855, 0.12386414876721119, 0.22022354515617515, 0.16848634990105604, 0.19044539707083497, 0.163034287323356, 0.15369232542041467, 0.15984047129929713, 0.1612313467814933, 0.15008756581370586, 0.15880440602411638, 0.18656712496841865, 0.27252232101478036, 0.20242579879665523, 0.1858365274883299, 0.15432948777398925, 0.18617535536617957, 0.17871722665864986, 0.18345667561945633, 0.17499215613211727, 0.14363424528722302, 0.16895667023776828, 0.1499042706268321, 0.12653682649177278, 0.151133710904106, 0.2038276403359901, 0.17597200726101525, 0.1508398436384486, 0.34821225929435273, 0.26402047654674543, 0.2727423223687261, 0.22686744519366853, 0.1336858958347058, 0.16224201378271996, 0.1650463011100577, 0.18157408403890085, 0.18669066105929244, 0.18592186030930602, 0.18168852988987994, 0.17051010446638426, 0.18983299140331678, 0.1653063826770632, 0.16664601394629208, 0.17956764367251932, 0.17328037675417507, 0.20298199167910402, 0.16901682404095209, 0.05418906890149666, 0.051843505490605124, 0.05739638657972923, 0.05180473993205559, 0.04816529871508268, 0.04822073032712215, 0.06147699438607268, 0.05222525130093669, 0.05292244381416089]}, "mutation_prompt": null}
