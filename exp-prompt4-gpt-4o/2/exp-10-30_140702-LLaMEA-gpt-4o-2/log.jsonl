{"id": "7d0d7893-98a0-4d53-8db0-4aea3894b0a3", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        mutant = a + self.diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        step_size = (self.upper_bound - self.lower_bound) * 0.1\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.current_budget >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "A hybrid metaheuristic combining Differential Evolution and Directional Search for efficient black-box optimization.", "configspace": "", "generation": 0, "fitness": 0.16168921167934264, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.17.", "error": "", "parent_id": null, "metadata": {"aucs": [0.31537579522539394, 0.3161618794503954, 0.3432111460879922, 0.3425734932719633, 0.36964931585568506, 0.3744426225517573, 0.356058231865934, 0.3479680595892244, 0.3315169954635566, 0.08512703667793009, 0.06647053435635464, 0.07878688018231828, 0.06437734048279142, 0.09813675387252918, 0.056977124238178134, 0.084664370970987, 0.09280425602716313, 0.07220065469442616, 0.07651287769050108, 0.070500105268548, 0.07701942213438162, 0.07741890395160389, 0.08220996650303858, 0.07194634751755569, 0.09331083581247768, 0.08411424396825351, 0.06921757184983834, 0.05731470680900552, 0.05538708554782368, 0.06104533785536226, 0.05803184254264793, 0.0721111636288615, 0.06895488597945754, 0.05423253366357783, 0.052746159410844706, 0.0693149011427413, 0.8882933594321745, 0.8985937746079865, 0.8363375352490298, 0.949562148941193, 0.8689990601015559, 0.8082443040629588, 0.8900228345966336, 0.7331175368593361, 0.7513897148587687, 0.1389235198492904, 0.126939080414202, 0.1331132392328065, 0.13961773357664553, 0.1470159543673777, 0.1287304293054189, 0.15027744755931183, 0.15255217533288856, 0.1493416433423319, 0.21968855793512432, 0.1962225091274833, 0.16563927673715406, 0.193216608196231, 0.2283317157937894, 0.22999891746015988, 0.2001546865729651, 0.20537262620704255, 0.2182984370861204, 0.07773139267516038, 0.07614629379795368, 0.06933351645657826, 0.09330444827507856, 0.06267300238648454, 0.08002679548755953, 0.0804300762031791, 0.08390860913477938, 0.10064807798017006, 0.09183399360824984, 0.08668934102719672, 0.06923778900231115, 0.07386089501501081, 0.06251192703769082, 0.08522810252629265, 0.058119336963969204, 0.07449294594194511, 0.08070122283039705, 0.011798051905678175, 0.007665760994903903, 0.011188823135525494, 0.012852370630093701, 0.00019026611445149832, 0.001467719439562809, 0.0028193826709582703, 0.00013930817475704682, 0.004233181476431147, 0.09774006933282309, 0.09335155845292209, 0.09925603499935676, 0.08427665820432717, 0.10984250374293736, 0.08976855066209644, 0.10594017327077332, 0.09250944940557326, 0.08413773091911625, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06873277271362077, 0.04169245991982895, 0.05004406895537872, 0.06547721470400125, 0.048459023914768085, 0.05529228125116292, 0.0614772575507494, 0.05633431968375169, 0.05289680716293965, 0.30216801690092443, 0.303888446793418, 0.30445616045527824, 0.3241644741129679, 0.3103446353267282, 0.337329347508194, 0.2961776417069316, 0.28854625378791365, 0.29438218476405953, 0.07972063172218713, 0.07905005708851676, 0.08132201180039977, 0.06964213539831221, 0.06093185997870676, 0.06568723868649262, 0.0695738540430284, 0.06855521734061587, 0.06992025673504865, 0.1347285630987406, 0.12436292465422905, 0.13721409221406122, 0.12844438682451398, 0.12519528378157718, 0.1650769430806417, 0.14801715993012, 0.13144741625376832, 0.1314866213363317, 0.20093558351950247, 0.18192492086096823, 0.1971088598468007, 0.20084485003580244, 0.19373115203610314, 0.2030630155845099, 0.20828229535443266, 0.21479661216269919, 0.2062995393338113, 0.15710351072303563, 0.13778160208038914, 0.155854586075176, 0.1422162283729198, 0.14505858823271223, 0.14675844411662475, 0.14337712514860157, 0.15649437911673902, 0.14960945026005212, 0.17949722927880918, 0.17086351853871562, 0.16068044081484534, 0.1696972628911826, 0.1801092560214136, 0.17344052105666818, 0.1667652348226647, 0.1736834499807023, 0.2008692511975716, 0.15392552905099766, 0.1689900011521197, 0.16523554495025805, 0.16171968009223014, 0.1779896147193436, 0.17053084299359467, 0.15719898356529394, 0.1554460804122233, 0.155423901842749, 0.18724689435074005, 0.14884614099059823, 0.15309533490779414, 0.14296296577509748, 0.16629510102393996, 0.21229469991459549, 0.21188092398581582, 0.14435095575993906, 0.15171783208894007, 0.1941963012162824, 0.15972828841118192, 0.19845243724673867, 0.14871305327277518, 0.14576177899963094, 0.1437399139224652, 0.27480576317209393, 0.2705347180698011, 0.1995995208694078, 0.19257986602418953, 0.18923689556725298, 0.1882658409993191, 0.19325009468551435, 0.17554572911425093, 0.2012870423653902, 0.16568351807162418, 0.17185136415072044, 0.17433013137437514, 0.06192489552723235, 0.06579418759748079, 0.06565832667182114, 0.06053242472857523, 0.06597071326239201, 0.06538903356285941, 0.06511913490580723, 0.060694781905913264, 0.07914444199391002]}, "mutation_prompt": null}
{"id": "159f339d-61d8-4f98-baaf-3f340d68b8a9", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        mutant = a + self.diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        step_size = (self.upper_bound - self.lower_bound) * 0.1\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.current_budget >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "A hybrid metaheuristic combining Differential Evolution and Directional Search for efficient black-box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7d0d7893-98a0-4d53-8db0-4aea3894b0a3", "metadata": {"aucs": [0.31537579522539394, 0.3161618794503954, 0.3432111460879922, 0.3425734932719633, 0.36964931585568506, 0.3744426225517573, 0.356058231865934, 0.3479680595892244, 0.3315169954635566, 0.08512703667793009, 0.06647053435635464, 0.07878688018231828, 0.06437734048279142, 0.09813675387252918, 0.056977124238178134, 0.084664370970987, 0.09280425602716313, 0.07220065469442616, 0.07651287769050108, 0.070500105268548, 0.07701942213438162, 0.07741890395160389, 0.08220996650303858, 0.07194634751755569, 0.09331083581247768, 0.08411424396825351, 0.06921757184983834, 0.05731470680900552, 0.05538708554782368, 0.06104533785536226, 0.05803184254264793, 0.0721111636288615, 0.06895488597945754, 0.05423253366357783, 0.052746159410844706, 0.0693149011427413, 0.8882933594321745, 0.8985937746079865, 0.8363375352490298, 0.949562148941193, 0.8689990601015559, 0.8082443040629588, 0.8900228345966336, 0.7331175368593361, 0.7513897148587687, 0.1389235198492904, 0.126939080414202, 0.1331132392328065, 0.13961773357664553, 0.1470159543673777, 0.1287304293054189, 0.15027744755931183, 0.15255217533288856, 0.1493416433423319, 0.21968855793512432, 0.1962225091274833, 0.16563927673715406, 0.193216608196231, 0.2283317157937894, 0.22999891746015988, 0.2001546865729651, 0.20537262620704255, 0.2182984370861204, 0.07773139267516038, 0.07614629379795368, 0.06933351645657826, 0.09330444827507856, 0.06267300238648454, 0.08002679548755953, 0.0804300762031791, 0.08390860913477938, 0.10064807798017006, 0.09183399360824984, 0.08668934102719672, 0.06923778900231115, 0.07386089501501081, 0.06251192703769082, 0.08522810252629265, 0.058119336963969204, 0.07449294594194511, 0.08070122283039705, 0.011798051905678175, 0.007665760994903903, 0.011188823135525494, 0.012852370630093701, 0.00019026611445149832, 0.001467719439562809, 0.0028193826709582703, 0.00013930817475704682, 0.004233181476431147, 0.09774006933282309, 0.09335155845292209, 0.09925603499935676, 0.08427665820432717, 0.10984250374293736, 0.08976855066209644, 0.10594017327077332, 0.09250944940557326, 0.08413773091911625, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06873277271362077, 0.04169245991982895, 0.05004406895537872, 0.06547721470400125, 0.048459023914768085, 0.05529228125116292, 0.0614772575507494, 0.05633431968375169, 0.05289680716293965, 0.30216801690092443, 0.303888446793418, 0.30445616045527824, 0.3241644741129679, 0.3103446353267282, 0.337329347508194, 0.2961776417069316, 0.28854625378791365, 0.29438218476405953, 0.07972063172218713, 0.07905005708851676, 0.08132201180039977, 0.06964213539831221, 0.06093185997870676, 0.06568723868649262, 0.0695738540430284, 0.06855521734061587, 0.06992025673504865, 0.1347285630987406, 0.12436292465422905, 0.13721409221406122, 0.12844438682451398, 0.12519528378157718, 0.1650769430806417, 0.14801715993012, 0.13144741625376832, 0.1314866213363317, 0.20093558351950247, 0.18192492086096823, 0.1971088598468007, 0.20084485003580244, 0.19373115203610314, 0.2030630155845099, 0.20828229535443266, 0.21479661216269919, 0.2062995393338113, 0.15710351072303563, 0.13778160208038914, 0.155854586075176, 0.1422162283729198, 0.14505858823271223, 0.14675844411662475, 0.14337712514860157, 0.15649437911673902, 0.14960945026005212, 0.17949722927880918, 0.17086351853871562, 0.16068044081484534, 0.1696972628911826, 0.1801092560214136, 0.17344052105666818, 0.1667652348226647, 0.1736834499807023, 0.2008692511975716, 0.15392552905099766, 0.1689900011521197, 0.16523554495025805, 0.16171968009223014, 0.1779896147193436, 0.17053084299359467, 0.15719898356529394, 0.1554460804122233, 0.155423901842749, 0.18724689435074005, 0.14884614099059823, 0.15309533490779414, 0.14296296577509748, 0.16629510102393996, 0.21229469991459549, 0.21188092398581582, 0.14435095575993906, 0.15171783208894007, 0.1941963012162824, 0.15972828841118192, 0.19845243724673867, 0.14871305327277518, 0.14576177899963094, 0.1437399139224652, 0.27480576317209393, 0.2705347180698011, 0.1995995208694078, 0.19257986602418953, 0.18923689556725298, 0.1882658409993191, 0.19325009468551435, 0.17554572911425093, 0.2012870423653902, 0.16568351807162418, 0.17185136415072044, 0.17433013137437514, 0.06192489552723235, 0.06579418759748079, 0.06565832667182114, 0.06053242472857523, 0.06597071326239201, 0.06538903356285941, 0.06511913490580723, 0.060694781905913264, 0.07914444199391002]}, "mutation_prompt": null}
{"id": "33c06edf-564b-4a1b-acb6-4efcc7cf4a48", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        mutant = a + self.diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        step_size = (self.upper_bound - self.lower_bound) * 0.1\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.current_budget >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "A hybrid metaheuristic combining Differential Evolution and Directional Search for efficient black-box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7d0d7893-98a0-4d53-8db0-4aea3894b0a3", "metadata": {"aucs": [0.31537579522539394, 0.3161618794503954, 0.3432111460879922, 0.3425734932719633, 0.36964931585568506, 0.3744426225517573, 0.356058231865934, 0.3479680595892244, 0.3315169954635566, 0.08512703667793009, 0.06647053435635464, 0.07878688018231828, 0.06437734048279142, 0.09813675387252918, 0.056977124238178134, 0.084664370970987, 0.09280425602716313, 0.07220065469442616, 0.07651287769050108, 0.070500105268548, 0.07701942213438162, 0.07741890395160389, 0.08220996650303858, 0.07194634751755569, 0.09331083581247768, 0.08411424396825351, 0.06921757184983834, 0.05731470680900552, 0.05538708554782368, 0.06104533785536226, 0.05803184254264793, 0.0721111636288615, 0.06895488597945754, 0.05423253366357783, 0.052746159410844706, 0.0693149011427413, 0.8882933594321745, 0.8985937746079865, 0.8363375352490298, 0.949562148941193, 0.8689990601015559, 0.8082443040629588, 0.8900228345966336, 0.7331175368593361, 0.7513897148587687, 0.1389235198492904, 0.126939080414202, 0.1331132392328065, 0.13961773357664553, 0.1470159543673777, 0.1287304293054189, 0.15027744755931183, 0.15255217533288856, 0.1493416433423319, 0.21968855793512432, 0.1962225091274833, 0.16563927673715406, 0.193216608196231, 0.2283317157937894, 0.22999891746015988, 0.2001546865729651, 0.20537262620704255, 0.2182984370861204, 0.07773139267516038, 0.07614629379795368, 0.06933351645657826, 0.09330444827507856, 0.06267300238648454, 0.08002679548755953, 0.0804300762031791, 0.08390860913477938, 0.10064807798017006, 0.09183399360824984, 0.08668934102719672, 0.06923778900231115, 0.07386089501501081, 0.06251192703769082, 0.08522810252629265, 0.058119336963969204, 0.07449294594194511, 0.08070122283039705, 0.011798051905678175, 0.007665760994903903, 0.011188823135525494, 0.012852370630093701, 0.00019026611445149832, 0.001467719439562809, 0.0028193826709582703, 0.00013930817475704682, 0.004233181476431147, 0.09774006933282309, 0.09335155845292209, 0.09925603499935676, 0.08427665820432717, 0.10984250374293736, 0.08976855066209644, 0.10594017327077332, 0.09250944940557326, 0.08413773091911625, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06873277271362077, 0.04169245991982895, 0.05004406895537872, 0.06547721470400125, 0.048459023914768085, 0.05529228125116292, 0.0614772575507494, 0.05633431968375169, 0.05289680716293965, 0.30216801690092443, 0.303888446793418, 0.30445616045527824, 0.3241644741129679, 0.3103446353267282, 0.337329347508194, 0.2961776417069316, 0.28854625378791365, 0.29438218476405953, 0.07972063172218713, 0.07905005708851676, 0.08132201180039977, 0.06964213539831221, 0.06093185997870676, 0.06568723868649262, 0.0695738540430284, 0.06855521734061587, 0.06992025673504865, 0.1347285630987406, 0.12436292465422905, 0.13721409221406122, 0.12844438682451398, 0.12519528378157718, 0.1650769430806417, 0.14801715993012, 0.13144741625376832, 0.1314866213363317, 0.20093558351950247, 0.18192492086096823, 0.1971088598468007, 0.20084485003580244, 0.19373115203610314, 0.2030630155845099, 0.20828229535443266, 0.21479661216269919, 0.2062995393338113, 0.15710351072303563, 0.13778160208038914, 0.155854586075176, 0.1422162283729198, 0.14505858823271223, 0.14675844411662475, 0.14337712514860157, 0.15649437911673902, 0.14960945026005212, 0.17949722927880918, 0.17086351853871562, 0.16068044081484534, 0.1696972628911826, 0.1801092560214136, 0.17344052105666818, 0.1667652348226647, 0.1736834499807023, 0.2008692511975716, 0.15392552905099766, 0.1689900011521197, 0.16523554495025805, 0.16171968009223014, 0.1779896147193436, 0.17053084299359467, 0.15719898356529394, 0.1554460804122233, 0.155423901842749, 0.18724689435074005, 0.14884614099059823, 0.15309533490779414, 0.14296296577509748, 0.16629510102393996, 0.21229469991459549, 0.21188092398581582, 0.14435095575993906, 0.15171783208894007, 0.1941963012162824, 0.15972828841118192, 0.19845243724673867, 0.14871305327277518, 0.14576177899963094, 0.1437399139224652, 0.27480576317209393, 0.2705347180698011, 0.1995995208694078, 0.19257986602418953, 0.18923689556725298, 0.1882658409993191, 0.19325009468551435, 0.17554572911425093, 0.2012870423653902, 0.16568351807162418, 0.17185136415072044, 0.17433013137437514, 0.06192489552723235, 0.06579418759748079, 0.06565832667182114, 0.06053242472857523, 0.06597071326239201, 0.06538903356285941, 0.06511913490580723, 0.060694781905913264, 0.07914444199391002]}, "mutation_prompt": null}
{"id": "57ef1bfd-7340-44f1-828e-5c785bee5a69", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        mutant = a + self.diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        step_size = (self.upper_bound - self.lower_bound) * 0.1\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.current_budget >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "A hybrid metaheuristic combining Differential Evolution and Directional Search for efficient black-box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7d0d7893-98a0-4d53-8db0-4aea3894b0a3", "metadata": {"aucs": [0.31537579522539394, 0.3161618794503954, 0.3432111460879922, 0.3425734932719633, 0.36964931585568506, 0.3744426225517573, 0.356058231865934, 0.3479680595892244, 0.3315169954635566, 0.08512703667793009, 0.06647053435635464, 0.07878688018231828, 0.06437734048279142, 0.09813675387252918, 0.056977124238178134, 0.084664370970987, 0.09280425602716313, 0.07220065469442616, 0.07651287769050108, 0.070500105268548, 0.07701942213438162, 0.07741890395160389, 0.08220996650303858, 0.07194634751755569, 0.09331083581247768, 0.08411424396825351, 0.06921757184983834, 0.05731470680900552, 0.05538708554782368, 0.06104533785536226, 0.05803184254264793, 0.0721111636288615, 0.06895488597945754, 0.05423253366357783, 0.052746159410844706, 0.0693149011427413, 0.8882933594321745, 0.8985937746079865, 0.8363375352490298, 0.949562148941193, 0.8689990601015559, 0.8082443040629588, 0.8900228345966336, 0.7331175368593361, 0.7513897148587687, 0.1389235198492904, 0.126939080414202, 0.1331132392328065, 0.13961773357664553, 0.1470159543673777, 0.1287304293054189, 0.15027744755931183, 0.15255217533288856, 0.1493416433423319, 0.21968855793512432, 0.1962225091274833, 0.16563927673715406, 0.193216608196231, 0.2283317157937894, 0.22999891746015988, 0.2001546865729651, 0.20537262620704255, 0.2182984370861204, 0.07773139267516038, 0.07614629379795368, 0.06933351645657826, 0.09330444827507856, 0.06267300238648454, 0.08002679548755953, 0.0804300762031791, 0.08390860913477938, 0.10064807798017006, 0.09183399360824984, 0.08668934102719672, 0.06923778900231115, 0.07386089501501081, 0.06251192703769082, 0.08522810252629265, 0.058119336963969204, 0.07449294594194511, 0.08070122283039705, 0.011798051905678175, 0.007665760994903903, 0.011188823135525494, 0.012852370630093701, 0.00019026611445149832, 0.001467719439562809, 0.0028193826709582703, 0.00013930817475704682, 0.004233181476431147, 0.09774006933282309, 0.09335155845292209, 0.09925603499935676, 0.08427665820432717, 0.10984250374293736, 0.08976855066209644, 0.10594017327077332, 0.09250944940557326, 0.08413773091911625, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06873277271362077, 0.04169245991982895, 0.05004406895537872, 0.06547721470400125, 0.048459023914768085, 0.05529228125116292, 0.0614772575507494, 0.05633431968375169, 0.05289680716293965, 0.30216801690092443, 0.303888446793418, 0.30445616045527824, 0.3241644741129679, 0.3103446353267282, 0.337329347508194, 0.2961776417069316, 0.28854625378791365, 0.29438218476405953, 0.07972063172218713, 0.07905005708851676, 0.08132201180039977, 0.06964213539831221, 0.06093185997870676, 0.06568723868649262, 0.0695738540430284, 0.06855521734061587, 0.06992025673504865, 0.1347285630987406, 0.12436292465422905, 0.13721409221406122, 0.12844438682451398, 0.12519528378157718, 0.1650769430806417, 0.14801715993012, 0.13144741625376832, 0.1314866213363317, 0.20093558351950247, 0.18192492086096823, 0.1971088598468007, 0.20084485003580244, 0.19373115203610314, 0.2030630155845099, 0.20828229535443266, 0.21479661216269919, 0.2062995393338113, 0.15710351072303563, 0.13778160208038914, 0.155854586075176, 0.1422162283729198, 0.14505858823271223, 0.14675844411662475, 0.14337712514860157, 0.15649437911673902, 0.14960945026005212, 0.17949722927880918, 0.17086351853871562, 0.16068044081484534, 0.1696972628911826, 0.1801092560214136, 0.17344052105666818, 0.1667652348226647, 0.1736834499807023, 0.2008692511975716, 0.15392552905099766, 0.1689900011521197, 0.16523554495025805, 0.16171968009223014, 0.1779896147193436, 0.17053084299359467, 0.15719898356529394, 0.1554460804122233, 0.155423901842749, 0.18724689435074005, 0.14884614099059823, 0.15309533490779414, 0.14296296577509748, 0.16629510102393996, 0.21229469991459549, 0.21188092398581582, 0.14435095575993906, 0.15171783208894007, 0.1941963012162824, 0.15972828841118192, 0.19845243724673867, 0.14871305327277518, 0.14576177899963094, 0.1437399139224652, 0.27480576317209393, 0.2705347180698011, 0.1995995208694078, 0.19257986602418953, 0.18923689556725298, 0.1882658409993191, 0.19325009468551435, 0.17554572911425093, 0.2012870423653902, 0.16568351807162418, 0.17185136415072044, 0.17433013137437514, 0.06192489552723235, 0.06579418759748079, 0.06565832667182114, 0.06053242472857523, 0.06597071326239201, 0.06538903356285941, 0.06511913490580723, 0.060694781905913264, 0.07914444199391002]}, "mutation_prompt": null}
{"id": "c3823d8e-c1eb-43c7-8e2b-3f7d9bbf86a8", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        mutant = a + self.diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        step_size = (self.upper_bound - self.lower_bound) * 0.1\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.current_budget >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "A hybrid metaheuristic combining Differential Evolution and Directional Search for efficient black-box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7d0d7893-98a0-4d53-8db0-4aea3894b0a3", "metadata": {"aucs": [0.31537579522539394, 0.3161618794503954, 0.3432111460879922, 0.3425734932719633, 0.36964931585568506, 0.3744426225517573, 0.356058231865934, 0.3479680595892244, 0.3315169954635566, 0.08512703667793009, 0.06647053435635464, 0.07878688018231828, 0.06437734048279142, 0.09813675387252918, 0.056977124238178134, 0.084664370970987, 0.09280425602716313, 0.07220065469442616, 0.07651287769050108, 0.070500105268548, 0.07701942213438162, 0.07741890395160389, 0.08220996650303858, 0.07194634751755569, 0.09331083581247768, 0.08411424396825351, 0.06921757184983834, 0.05731470680900552, 0.05538708554782368, 0.06104533785536226, 0.05803184254264793, 0.0721111636288615, 0.06895488597945754, 0.05423253366357783, 0.052746159410844706, 0.0693149011427413, 0.8882933594321745, 0.8985937746079865, 0.8363375352490298, 0.949562148941193, 0.8689990601015559, 0.8082443040629588, 0.8900228345966336, 0.7331175368593361, 0.7513897148587687, 0.1389235198492904, 0.126939080414202, 0.1331132392328065, 0.13961773357664553, 0.1470159543673777, 0.1287304293054189, 0.15027744755931183, 0.15255217533288856, 0.1493416433423319, 0.21968855793512432, 0.1962225091274833, 0.16563927673715406, 0.193216608196231, 0.2283317157937894, 0.22999891746015988, 0.2001546865729651, 0.20537262620704255, 0.2182984370861204, 0.07773139267516038, 0.07614629379795368, 0.06933351645657826, 0.09330444827507856, 0.06267300238648454, 0.08002679548755953, 0.0804300762031791, 0.08390860913477938, 0.10064807798017006, 0.09183399360824984, 0.08668934102719672, 0.06923778900231115, 0.07386089501501081, 0.06251192703769082, 0.08522810252629265, 0.058119336963969204, 0.07449294594194511, 0.08070122283039705, 0.011798051905678175, 0.007665760994903903, 0.011188823135525494, 0.012852370630093701, 0.00019026611445149832, 0.001467719439562809, 0.0028193826709582703, 0.00013930817475704682, 0.004233181476431147, 0.09774006933282309, 0.09335155845292209, 0.09925603499935676, 0.08427665820432717, 0.10984250374293736, 0.08976855066209644, 0.10594017327077332, 0.09250944940557326, 0.08413773091911625, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06873277271362077, 0.04169245991982895, 0.05004406895537872, 0.06547721470400125, 0.048459023914768085, 0.05529228125116292, 0.0614772575507494, 0.05633431968375169, 0.05289680716293965, 0.30216801690092443, 0.303888446793418, 0.30445616045527824, 0.3241644741129679, 0.3103446353267282, 0.337329347508194, 0.2961776417069316, 0.28854625378791365, 0.29438218476405953, 0.07972063172218713, 0.07905005708851676, 0.08132201180039977, 0.06964213539831221, 0.06093185997870676, 0.06568723868649262, 0.0695738540430284, 0.06855521734061587, 0.06992025673504865, 0.1347285630987406, 0.12436292465422905, 0.13721409221406122, 0.12844438682451398, 0.12519528378157718, 0.1650769430806417, 0.14801715993012, 0.13144741625376832, 0.1314866213363317, 0.20093558351950247, 0.18192492086096823, 0.1971088598468007, 0.20084485003580244, 0.19373115203610314, 0.2030630155845099, 0.20828229535443266, 0.21479661216269919, 0.2062995393338113, 0.15710351072303563, 0.13778160208038914, 0.155854586075176, 0.1422162283729198, 0.14505858823271223, 0.14675844411662475, 0.14337712514860157, 0.15649437911673902, 0.14960945026005212, 0.17949722927880918, 0.17086351853871562, 0.16068044081484534, 0.1696972628911826, 0.1801092560214136, 0.17344052105666818, 0.1667652348226647, 0.1736834499807023, 0.2008692511975716, 0.15392552905099766, 0.1689900011521197, 0.16523554495025805, 0.16171968009223014, 0.1779896147193436, 0.17053084299359467, 0.15719898356529394, 0.1554460804122233, 0.155423901842749, 0.18724689435074005, 0.14884614099059823, 0.15309533490779414, 0.14296296577509748, 0.16629510102393996, 0.21229469991459549, 0.21188092398581582, 0.14435095575993906, 0.15171783208894007, 0.1941963012162824, 0.15972828841118192, 0.19845243724673867, 0.14871305327277518, 0.14576177899963094, 0.1437399139224652, 0.27480576317209393, 0.2705347180698011, 0.1995995208694078, 0.19257986602418953, 0.18923689556725298, 0.1882658409993191, 0.19325009468551435, 0.17554572911425093, 0.2012870423653902, 0.16568351807162418, 0.17185136415072044, 0.17433013137437514, 0.06192489552723235, 0.06579418759748079, 0.06565832667182114, 0.06053242472857523, 0.06597071326239201, 0.06538903356285941, 0.06511913490580723, 0.060694781905913264, 0.07914444199391002]}, "mutation_prompt": null}
{"id": "555d257a-95c2-44f5-b250-0a00af4e0a1a", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        mutant = a + self.diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        step_size = (self.upper_bound - self.lower_bound) * 0.1\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.current_budget >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "A hybrid metaheuristic combining Differential Evolution and Directional Search for efficient black-box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7d0d7893-98a0-4d53-8db0-4aea3894b0a3", "metadata": {"aucs": [0.31537579522539394, 0.3161618794503954, 0.3432111460879922, 0.3425734932719633, 0.36964931585568506, 0.3744426225517573, 0.356058231865934, 0.3479680595892244, 0.3315169954635566, 0.08512703667793009, 0.06647053435635464, 0.07878688018231828, 0.06437734048279142, 0.09813675387252918, 0.056977124238178134, 0.084664370970987, 0.09280425602716313, 0.07220065469442616, 0.07651287769050108, 0.070500105268548, 0.07701942213438162, 0.07741890395160389, 0.08220996650303858, 0.07194634751755569, 0.09331083581247768, 0.08411424396825351, 0.06921757184983834, 0.05731470680900552, 0.05538708554782368, 0.06104533785536226, 0.05803184254264793, 0.0721111636288615, 0.06895488597945754, 0.05423253366357783, 0.052746159410844706, 0.0693149011427413, 0.8882933594321745, 0.8985937746079865, 0.8363375352490298, 0.949562148941193, 0.8689990601015559, 0.8082443040629588, 0.8900228345966336, 0.7331175368593361, 0.7513897148587687, 0.1389235198492904, 0.126939080414202, 0.1331132392328065, 0.13961773357664553, 0.1470159543673777, 0.1287304293054189, 0.15027744755931183, 0.15255217533288856, 0.1493416433423319, 0.21968855793512432, 0.1962225091274833, 0.16563927673715406, 0.193216608196231, 0.2283317157937894, 0.22999891746015988, 0.2001546865729651, 0.20537262620704255, 0.2182984370861204, 0.07773139267516038, 0.07614629379795368, 0.06933351645657826, 0.09330444827507856, 0.06267300238648454, 0.08002679548755953, 0.0804300762031791, 0.08390860913477938, 0.10064807798017006, 0.09183399360824984, 0.08668934102719672, 0.06923778900231115, 0.07386089501501081, 0.06251192703769082, 0.08522810252629265, 0.058119336963969204, 0.07449294594194511, 0.08070122283039705, 0.011798051905678175, 0.007665760994903903, 0.011188823135525494, 0.012852370630093701, 0.00019026611445149832, 0.001467719439562809, 0.0028193826709582703, 0.00013930817475704682, 0.004233181476431147, 0.09774006933282309, 0.09335155845292209, 0.09925603499935676, 0.08427665820432717, 0.10984250374293736, 0.08976855066209644, 0.10594017327077332, 0.09250944940557326, 0.08413773091911625, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06873277271362077, 0.04169245991982895, 0.05004406895537872, 0.06547721470400125, 0.048459023914768085, 0.05529228125116292, 0.0614772575507494, 0.05633431968375169, 0.05289680716293965, 0.30216801690092443, 0.303888446793418, 0.30445616045527824, 0.3241644741129679, 0.3103446353267282, 0.337329347508194, 0.2961776417069316, 0.28854625378791365, 0.29438218476405953, 0.07972063172218713, 0.07905005708851676, 0.08132201180039977, 0.06964213539831221, 0.06093185997870676, 0.06568723868649262, 0.0695738540430284, 0.06855521734061587, 0.06992025673504865, 0.1347285630987406, 0.12436292465422905, 0.13721409221406122, 0.12844438682451398, 0.12519528378157718, 0.1650769430806417, 0.14801715993012, 0.13144741625376832, 0.1314866213363317, 0.20093558351950247, 0.18192492086096823, 0.1971088598468007, 0.20084485003580244, 0.19373115203610314, 0.2030630155845099, 0.20828229535443266, 0.21479661216269919, 0.2062995393338113, 0.15710351072303563, 0.13778160208038914, 0.155854586075176, 0.1422162283729198, 0.14505858823271223, 0.14675844411662475, 0.14337712514860157, 0.15649437911673902, 0.14960945026005212, 0.17949722927880918, 0.17086351853871562, 0.16068044081484534, 0.1696972628911826, 0.1801092560214136, 0.17344052105666818, 0.1667652348226647, 0.1736834499807023, 0.2008692511975716, 0.15392552905099766, 0.1689900011521197, 0.16523554495025805, 0.16171968009223014, 0.1779896147193436, 0.17053084299359467, 0.15719898356529394, 0.1554460804122233, 0.155423901842749, 0.18724689435074005, 0.14884614099059823, 0.15309533490779414, 0.14296296577509748, 0.16629510102393996, 0.21229469991459549, 0.21188092398581582, 0.14435095575993906, 0.15171783208894007, 0.1941963012162824, 0.15972828841118192, 0.19845243724673867, 0.14871305327277518, 0.14576177899963094, 0.1437399139224652, 0.27480576317209393, 0.2705347180698011, 0.1995995208694078, 0.19257986602418953, 0.18923689556725298, 0.1882658409993191, 0.19325009468551435, 0.17554572911425093, 0.2012870423653902, 0.16568351807162418, 0.17185136415072044, 0.17433013137437514, 0.06192489552723235, 0.06579418759748079, 0.06565832667182114, 0.06053242472857523, 0.06597071326239201, 0.06538903356285941, 0.06511913490580723, 0.060694781905913264, 0.07914444199391002]}, "mutation_prompt": null}
{"id": "4dd96593-2a03-4bca-870b-a2c25f517822", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population, fitness):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        f_adaptive = self.diff_weight + 0.2 * (np.min(fitness) / max(fitness))\n        mutant = a + f_adaptive * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        step_size = (self.upper_bound - self.lower_bound) * 0.1\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, fitness)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.current_budget >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Introduce adaptive differential weight in Differential Evolution to enhance exploration and convergence.", "configspace": "", "generation": 6, "fitness": 0.15149630942155148, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.17.", "error": "", "parent_id": "7d0d7893-98a0-4d53-8db0-4aea3894b0a3", "metadata": {"aucs": [0.26252145793471804, 0.252750878177615, 0.26488299264920756, 0.2911671011360337, 0.3141173717684834, 0.30862588219821796, 0.2808127118542738, 0.27588103263577823, 0.27547322358491944, 0.08404800502746934, 0.034937329837097186, 0.032709564506050115, 0.05088667158105453, 0.08022322523008629, 0.05615982552839183, 0.05780841822905147, 0.04061944891180613, 0.059918646839120626, 0.05932547440348612, 0.05908922879958989, 0.05632444504470646, 0.06611444816188727, 0.07677718125714672, 0.075840980847798, 0.1040175002017244, 0.07765676736320415, 0.07617821611962738, 0.04566979479401867, 0.06350689857801262, 0.02263117675920434, 0.060416876246175755, 0.05336868685455143, 0.05840742984431413, 0.04855659221152653, 0.05936520046467486, 0.05706424997078319, 0.8744323143426946, 0.8940331120386439, 0.8156419564759216, 0.8766735501349369, 0.9481839146586565, 0.8430631072913309, 0.8939527622061674, 0.8323108922765462, 0.753581763024676, 0.15336386633527777, 0.13247345497295626, 0.109650543988013, 0.13810187152935227, 0.10853429531818415, 0.1289934976046141, 0.1016786237113072, 0.14122326309111888, 0.10402538351792268, 0.18145480644011103, 0.17411223321347202, 0.19991888268646796, 0.20591427584557054, 0.1927026231222071, 0.19892671128611128, 0.22705879499293147, 0.2191605707478752, 0.19144691607483655, 0.10712867862396702, 0.08017085428718396, 0.07318796303642283, 0.03379738787268083, 0.0076894724519205315, 0.06273404531267357, 0.06407351351868495, 0.07112082180229551, 0.08344412812504287, 0.10770911116806892, 0.09044113732542014, 0.07506145017414179, 0.06733200818365204, 0.07562909398596729, 0.08363160253754054, 0.05386982224231529, 0.07349625296839091, 0.0684420815607848, 0.0020448293455789246, 0.0025918602200787344, 0.00030061649029589077, 0.017034676601263676, 0.0031572135025952353, 9.999999999998899e-05, 0.0010222401469043296, 0.0033310929798943123, 0.00840650980389468, 0.10152011290610785, 0.055901556393345486, 0.10346949793547044, 0.08490685366357598, 0.11184756878389379, 0.08674454948191757, 0.10611326303308688, 0.10364537225746318, 0.10628039312368054, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.039647675204385835, 0.04206696877736793, 0.047166790952805626, 0.05564974776027609, 0.06224039909372625, 0.0548071171671527, 0.023688968128253496, 0.03494536893528677, 0.04071578603448911, 0.23259484479376158, 0.23654703422092593, 0.24303092022078598, 0.26536273707988367, 0.28203998227180604, 0.26648105024704716, 0.2952923780819361, 0.25634549368957726, 0.2759493181202163, 0.09358049943424906, 0.07438555919169243, 0.0660134510686683, 0.05763662294585825, 0.06397538910887146, 0.06594085928914117, 0.07314915384688048, 0.06535890471852113, 0.06751266251738086, 0.1599482089929839, 0.18312853763207304, 0.1312569655778565, 0.1397720684593885, 0.1475293538263539, 0.1359065024931284, 0.16406034487022048, 0.15647131088045318, 0.12496890278990291, 0.17347675036074506, 0.17332875885874655, 0.18650356163874016, 0.17851207523726476, 0.1700682218321119, 0.1794140386538633, 0.1978157159089765, 0.19443645746319815, 0.18462922241883684, 0.14491353290174624, 0.14699250289639698, 0.1277012079036045, 0.13568903239581975, 0.1352749051572869, 0.12284860076980297, 0.11926427492937308, 0.1345842477561897, 0.14587548155110908, 0.1648205512092309, 0.15905628154783502, 0.16615611337999803, 0.1613287718927484, 0.1833635172118886, 0.1498157897069483, 0.1697359973806255, 0.15117691197240923, 0.16330048582032375, 0.1511116377355607, 0.14960120716943115, 0.16480120472834658, 0.16811165181807153, 0.1630558643899045, 0.16458228716622414, 0.14917499474513696, 0.1501467912511698, 0.15063780103061197, 0.1901846231994282, 0.1813144173083313, 0.15271277682308737, 0.2660425461695076, 0.14966661049704655, 0.23277753914654442, 0.16340290018999026, 0.1309859417007203, 0.1596591474168565, 0.1583848195835189, 0.15596417861489464, 0.15515217835349593, 0.15403950380654718, 0.14178732158575458, 0.11503316790832319, 0.18253658004264284, 0.21986668924101382, 0.19169872225467244, 0.17153144337743675, 0.1881587697031013, 0.17975487602618412, 0.18508133290318818, 0.2044318139989818, 0.19644054326947624, 0.1777928836406425, 0.18312220943920388, 0.1905321106286315, 0.06302500834697033, 0.05914927097930289, 0.05982806381311179, 0.04904370539414482, 0.07004036059256191, 0.05090942733496706, 0.05718964087151113, 0.050858099456021266, 0.06588272989780819]}, "mutation_prompt": null}
{"id": "e2e07228-1005-4e4f-80b8-1813916fcb99", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        mutant = a + self.diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        step_size = (self.upper_bound - self.lower_bound) * 0.1\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.current_budget >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "A hybrid metaheuristic combining Differential Evolution and Directional Search for efficient black-box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7d0d7893-98a0-4d53-8db0-4aea3894b0a3", "metadata": {"aucs": [0.31537579522539394, 0.3161618794503954, 0.3432111460879922, 0.3425734932719633, 0.36964931585568506, 0.3744426225517573, 0.356058231865934, 0.3479680595892244, 0.3315169954635566, 0.08512703667793009, 0.06647053435635464, 0.07878688018231828, 0.06437734048279142, 0.09813675387252918, 0.056977124238178134, 0.084664370970987, 0.09280425602716313, 0.07220065469442616, 0.07651287769050108, 0.070500105268548, 0.07701942213438162, 0.07741890395160389, 0.08220996650303858, 0.07194634751755569, 0.09331083581247768, 0.08411424396825351, 0.06921757184983834, 0.05731470680900552, 0.05538708554782368, 0.06104533785536226, 0.05803184254264793, 0.0721111636288615, 0.06895488597945754, 0.05423253366357783, 0.052746159410844706, 0.0693149011427413, 0.8882933594321745, 0.8985937746079865, 0.8363375352490298, 0.949562148941193, 0.8689990601015559, 0.8082443040629588, 0.8900228345966336, 0.7331175368593361, 0.7513897148587687, 0.1389235198492904, 0.126939080414202, 0.1331132392328065, 0.13961773357664553, 0.1470159543673777, 0.1287304293054189, 0.15027744755931183, 0.15255217533288856, 0.1493416433423319, 0.21968855793512432, 0.1962225091274833, 0.16563927673715406, 0.193216608196231, 0.2283317157937894, 0.22999891746015988, 0.2001546865729651, 0.20537262620704255, 0.2182984370861204, 0.07773139267516038, 0.07614629379795368, 0.06933351645657826, 0.09330444827507856, 0.06267300238648454, 0.08002679548755953, 0.0804300762031791, 0.08390860913477938, 0.10064807798017006, 0.09183399360824984, 0.08668934102719672, 0.06923778900231115, 0.07386089501501081, 0.06251192703769082, 0.08522810252629265, 0.058119336963969204, 0.07449294594194511, 0.08070122283039705, 0.011798051905678175, 0.007665760994903903, 0.011188823135525494, 0.012852370630093701, 0.00019026611445149832, 0.001467719439562809, 0.0028193826709582703, 0.00013930817475704682, 0.004233181476431147, 0.09774006933282309, 0.09335155845292209, 0.09925603499935676, 0.08427665820432717, 0.10984250374293736, 0.08976855066209644, 0.10594017327077332, 0.09250944940557326, 0.08413773091911625, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06873277271362077, 0.04169245991982895, 0.05004406895537872, 0.06547721470400125, 0.048459023914768085, 0.05529228125116292, 0.0614772575507494, 0.05633431968375169, 0.05289680716293965, 0.30216801690092443, 0.303888446793418, 0.30445616045527824, 0.3241644741129679, 0.3103446353267282, 0.337329347508194, 0.2961776417069316, 0.28854625378791365, 0.29438218476405953, 0.07972063172218713, 0.07905005708851676, 0.08132201180039977, 0.06964213539831221, 0.06093185997870676, 0.06568723868649262, 0.0695738540430284, 0.06855521734061587, 0.06992025673504865, 0.1347285630987406, 0.12436292465422905, 0.13721409221406122, 0.12844438682451398, 0.12519528378157718, 0.1650769430806417, 0.14801715993012, 0.13144741625376832, 0.1314866213363317, 0.20093558351950247, 0.18192492086096823, 0.1971088598468007, 0.20084485003580244, 0.19373115203610314, 0.2030630155845099, 0.20828229535443266, 0.21479661216269919, 0.2062995393338113, 0.15710351072303563, 0.13778160208038914, 0.155854586075176, 0.1422162283729198, 0.14505858823271223, 0.14675844411662475, 0.14337712514860157, 0.15649437911673902, 0.14960945026005212, 0.17949722927880918, 0.17086351853871562, 0.16068044081484534, 0.1696972628911826, 0.1801092560214136, 0.17344052105666818, 0.1667652348226647, 0.1736834499807023, 0.2008692511975716, 0.15392552905099766, 0.1689900011521197, 0.16523554495025805, 0.16171968009223014, 0.1779896147193436, 0.17053084299359467, 0.15719898356529394, 0.1554460804122233, 0.155423901842749, 0.18724689435074005, 0.14884614099059823, 0.15309533490779414, 0.14296296577509748, 0.16629510102393996, 0.21229469991459549, 0.21188092398581582, 0.14435095575993906, 0.15171783208894007, 0.1941963012162824, 0.15972828841118192, 0.19845243724673867, 0.14871305327277518, 0.14576177899963094, 0.1437399139224652, 0.27480576317209393, 0.2705347180698011, 0.1995995208694078, 0.19257986602418953, 0.18923689556725298, 0.1882658409993191, 0.19325009468551435, 0.17554572911425093, 0.2012870423653902, 0.16568351807162418, 0.17185136415072044, 0.17433013137437514, 0.06192489552723235, 0.06579418759748079, 0.06565832667182114, 0.06053242472857523, 0.06597071326239201, 0.06538903356285941, 0.06511913490580723, 0.060694781905913264, 0.07914444199391002]}, "mutation_prompt": null}
{"id": "d7a529be-56a8-4c03-884c-1f76207ae0f0", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        mutant = a + self.diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        step_size = (self.upper_bound - self.lower_bound) * 0.1\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.current_budget >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "A hybrid metaheuristic combining Differential Evolution and Directional Search for efficient black-box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7d0d7893-98a0-4d53-8db0-4aea3894b0a3", "metadata": {"aucs": [0.31537579522539394, 0.3161618794503954, 0.3432111460879922, 0.3425734932719633, 0.36964931585568506, 0.3744426225517573, 0.356058231865934, 0.3479680595892244, 0.3315169954635566, 0.08512703667793009, 0.06647053435635464, 0.07878688018231828, 0.06437734048279142, 0.09813675387252918, 0.056977124238178134, 0.084664370970987, 0.09280425602716313, 0.07220065469442616, 0.07651287769050108, 0.070500105268548, 0.07701942213438162, 0.07741890395160389, 0.08220996650303858, 0.07194634751755569, 0.09331083581247768, 0.08411424396825351, 0.06921757184983834, 0.05731470680900552, 0.05538708554782368, 0.06104533785536226, 0.05803184254264793, 0.0721111636288615, 0.06895488597945754, 0.05423253366357783, 0.052746159410844706, 0.0693149011427413, 0.8882933594321745, 0.8985937746079865, 0.8363375352490298, 0.949562148941193, 0.8689990601015559, 0.8082443040629588, 0.8900228345966336, 0.7331175368593361, 0.7513897148587687, 0.1389235198492904, 0.126939080414202, 0.1331132392328065, 0.13961773357664553, 0.1470159543673777, 0.1287304293054189, 0.15027744755931183, 0.15255217533288856, 0.1493416433423319, 0.21968855793512432, 0.1962225091274833, 0.16563927673715406, 0.193216608196231, 0.2283317157937894, 0.22999891746015988, 0.2001546865729651, 0.20537262620704255, 0.2182984370861204, 0.07773139267516038, 0.07614629379795368, 0.06933351645657826, 0.09330444827507856, 0.06267300238648454, 0.08002679548755953, 0.0804300762031791, 0.08390860913477938, 0.10064807798017006, 0.09183399360824984, 0.08668934102719672, 0.06923778900231115, 0.07386089501501081, 0.06251192703769082, 0.08522810252629265, 0.058119336963969204, 0.07449294594194511, 0.08070122283039705, 0.011798051905678175, 0.007665760994903903, 0.011188823135525494, 0.012852370630093701, 0.00019026611445149832, 0.001467719439562809, 0.0028193826709582703, 0.00013930817475704682, 0.004233181476431147, 0.09774006933282309, 0.09335155845292209, 0.09925603499935676, 0.08427665820432717, 0.10984250374293736, 0.08976855066209644, 0.10594017327077332, 0.09250944940557326, 0.08413773091911625, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06873277271362077, 0.04169245991982895, 0.05004406895537872, 0.06547721470400125, 0.048459023914768085, 0.05529228125116292, 0.0614772575507494, 0.05633431968375169, 0.05289680716293965, 0.30216801690092443, 0.303888446793418, 0.30445616045527824, 0.3241644741129679, 0.3103446353267282, 0.337329347508194, 0.2961776417069316, 0.28854625378791365, 0.29438218476405953, 0.07972063172218713, 0.07905005708851676, 0.08132201180039977, 0.06964213539831221, 0.06093185997870676, 0.06568723868649262, 0.0695738540430284, 0.06855521734061587, 0.06992025673504865, 0.1347285630987406, 0.12436292465422905, 0.13721409221406122, 0.12844438682451398, 0.12519528378157718, 0.1650769430806417, 0.14801715993012, 0.13144741625376832, 0.1314866213363317, 0.20093558351950247, 0.18192492086096823, 0.1971088598468007, 0.20084485003580244, 0.19373115203610314, 0.2030630155845099, 0.20828229535443266, 0.21479661216269919, 0.2062995393338113, 0.15710351072303563, 0.13778160208038914, 0.155854586075176, 0.1422162283729198, 0.14505858823271223, 0.14675844411662475, 0.14337712514860157, 0.15649437911673902, 0.14960945026005212, 0.17949722927880918, 0.17086351853871562, 0.16068044081484534, 0.1696972628911826, 0.1801092560214136, 0.17344052105666818, 0.1667652348226647, 0.1736834499807023, 0.2008692511975716, 0.15392552905099766, 0.1689900011521197, 0.16523554495025805, 0.16171968009223014, 0.1779896147193436, 0.17053084299359467, 0.15719898356529394, 0.1554460804122233, 0.155423901842749, 0.18724689435074005, 0.14884614099059823, 0.15309533490779414, 0.14296296577509748, 0.16629510102393996, 0.21229469991459549, 0.21188092398581582, 0.14435095575993906, 0.15171783208894007, 0.1941963012162824, 0.15972828841118192, 0.19845243724673867, 0.14871305327277518, 0.14576177899963094, 0.1437399139224652, 0.27480576317209393, 0.2705347180698011, 0.1995995208694078, 0.19257986602418953, 0.18923689556725298, 0.1882658409993191, 0.19325009468551435, 0.17554572911425093, 0.2012870423653902, 0.16568351807162418, 0.17185136415072044, 0.17433013137437514, 0.06192489552723235, 0.06579418759748079, 0.06565832667182114, 0.06053242472857523, 0.06597071326239201, 0.06538903356285941, 0.06511913490580723, 0.060694781905913264, 0.07914444199391002]}, "mutation_prompt": null}
{"id": "7b07b227-4e9b-4686-aa14-acbdf2cc6cfb", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        mutant = a + self.diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        step_size = (self.upper_bound - self.lower_bound) * 0.1\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.current_budget >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "A hybrid metaheuristic combining Differential Evolution and Directional Search for efficient black-box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7d0d7893-98a0-4d53-8db0-4aea3894b0a3", "metadata": {"aucs": [0.31537579522539394, 0.3161618794503954, 0.3432111460879922, 0.3425734932719633, 0.36964931585568506, 0.3744426225517573, 0.356058231865934, 0.3479680595892244, 0.3315169954635566, 0.08512703667793009, 0.06647053435635464, 0.07878688018231828, 0.06437734048279142, 0.09813675387252918, 0.056977124238178134, 0.084664370970987, 0.09280425602716313, 0.07220065469442616, 0.07651287769050108, 0.070500105268548, 0.07701942213438162, 0.07741890395160389, 0.08220996650303858, 0.07194634751755569, 0.09331083581247768, 0.08411424396825351, 0.06921757184983834, 0.05731470680900552, 0.05538708554782368, 0.06104533785536226, 0.05803184254264793, 0.0721111636288615, 0.06895488597945754, 0.05423253366357783, 0.052746159410844706, 0.0693149011427413, 0.8882933594321745, 0.8985937746079865, 0.8363375352490298, 0.949562148941193, 0.8689990601015559, 0.8082443040629588, 0.8900228345966336, 0.7331175368593361, 0.7513897148587687, 0.1389235198492904, 0.126939080414202, 0.1331132392328065, 0.13961773357664553, 0.1470159543673777, 0.1287304293054189, 0.15027744755931183, 0.15255217533288856, 0.1493416433423319, 0.21968855793512432, 0.1962225091274833, 0.16563927673715406, 0.193216608196231, 0.2283317157937894, 0.22999891746015988, 0.2001546865729651, 0.20537262620704255, 0.2182984370861204, 0.07773139267516038, 0.07614629379795368, 0.06933351645657826, 0.09330444827507856, 0.06267300238648454, 0.08002679548755953, 0.0804300762031791, 0.08390860913477938, 0.10064807798017006, 0.09183399360824984, 0.08668934102719672, 0.06923778900231115, 0.07386089501501081, 0.06251192703769082, 0.08522810252629265, 0.058119336963969204, 0.07449294594194511, 0.08070122283039705, 0.011798051905678175, 0.007665760994903903, 0.011188823135525494, 0.012852370630093701, 0.00019026611445149832, 0.001467719439562809, 0.0028193826709582703, 0.00013930817475704682, 0.004233181476431147, 0.09774006933282309, 0.09335155845292209, 0.09925603499935676, 0.08427665820432717, 0.10984250374293736, 0.08976855066209644, 0.10594017327077332, 0.09250944940557326, 0.08413773091911625, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06873277271362077, 0.04169245991982895, 0.05004406895537872, 0.06547721470400125, 0.048459023914768085, 0.05529228125116292, 0.0614772575507494, 0.05633431968375169, 0.05289680716293965, 0.30216801690092443, 0.303888446793418, 0.30445616045527824, 0.3241644741129679, 0.3103446353267282, 0.337329347508194, 0.2961776417069316, 0.28854625378791365, 0.29438218476405953, 0.07972063172218713, 0.07905005708851676, 0.08132201180039977, 0.06964213539831221, 0.06093185997870676, 0.06568723868649262, 0.0695738540430284, 0.06855521734061587, 0.06992025673504865, 0.1347285630987406, 0.12436292465422905, 0.13721409221406122, 0.12844438682451398, 0.12519528378157718, 0.1650769430806417, 0.14801715993012, 0.13144741625376832, 0.1314866213363317, 0.20093558351950247, 0.18192492086096823, 0.1971088598468007, 0.20084485003580244, 0.19373115203610314, 0.2030630155845099, 0.20828229535443266, 0.21479661216269919, 0.2062995393338113, 0.15710351072303563, 0.13778160208038914, 0.155854586075176, 0.1422162283729198, 0.14505858823271223, 0.14675844411662475, 0.14337712514860157, 0.15649437911673902, 0.14960945026005212, 0.17949722927880918, 0.17086351853871562, 0.16068044081484534, 0.1696972628911826, 0.1801092560214136, 0.17344052105666818, 0.1667652348226647, 0.1736834499807023, 0.2008692511975716, 0.15392552905099766, 0.1689900011521197, 0.16523554495025805, 0.16171968009223014, 0.1779896147193436, 0.17053084299359467, 0.15719898356529394, 0.1554460804122233, 0.155423901842749, 0.18724689435074005, 0.14884614099059823, 0.15309533490779414, 0.14296296577509748, 0.16629510102393996, 0.21229469991459549, 0.21188092398581582, 0.14435095575993906, 0.15171783208894007, 0.1941963012162824, 0.15972828841118192, 0.19845243724673867, 0.14871305327277518, 0.14576177899963094, 0.1437399139224652, 0.27480576317209393, 0.2705347180698011, 0.1995995208694078, 0.19257986602418953, 0.18923689556725298, 0.1882658409993191, 0.19325009468551435, 0.17554572911425093, 0.2012870423653902, 0.16568351807162418, 0.17185136415072044, 0.17433013137437514, 0.06192489552723235, 0.06579418759748079, 0.06565832667182114, 0.06053242472857523, 0.06597071326239201, 0.06538903356285941, 0.06511913490580723, 0.060694781905913264, 0.07914444199391002]}, "mutation_prompt": null}
{"id": "d1ac41ce-85c3-4993-9e3e-43509410e449", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        mutant = a + self.diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        step_size = (self.upper_bound - self.lower_bound) * 0.1\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.current_budget >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "A hybrid metaheuristic combining Differential Evolution and Directional Search for efficient black-box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7d0d7893-98a0-4d53-8db0-4aea3894b0a3", "metadata": {"aucs": [0.31537579522539394, 0.3161618794503954, 0.3432111460879922, 0.3425734932719633, 0.36964931585568506, 0.3744426225517573, 0.356058231865934, 0.3479680595892244, 0.3315169954635566, 0.08512703667793009, 0.06647053435635464, 0.07878688018231828, 0.06437734048279142, 0.09813675387252918, 0.056977124238178134, 0.084664370970987, 0.09280425602716313, 0.07220065469442616, 0.07651287769050108, 0.070500105268548, 0.07701942213438162, 0.07741890395160389, 0.08220996650303858, 0.07194634751755569, 0.09331083581247768, 0.08411424396825351, 0.06921757184983834, 0.05731470680900552, 0.05538708554782368, 0.06104533785536226, 0.05803184254264793, 0.0721111636288615, 0.06895488597945754, 0.05423253366357783, 0.052746159410844706, 0.0693149011427413, 0.8882933594321745, 0.8985937746079865, 0.8363375352490298, 0.949562148941193, 0.8689990601015559, 0.8082443040629588, 0.8900228345966336, 0.7331175368593361, 0.7513897148587687, 0.1389235198492904, 0.126939080414202, 0.1331132392328065, 0.13961773357664553, 0.1470159543673777, 0.1287304293054189, 0.15027744755931183, 0.15255217533288856, 0.1493416433423319, 0.21968855793512432, 0.1962225091274833, 0.16563927673715406, 0.193216608196231, 0.2283317157937894, 0.22999891746015988, 0.2001546865729651, 0.20537262620704255, 0.2182984370861204, 0.07773139267516038, 0.07614629379795368, 0.06933351645657826, 0.09330444827507856, 0.06267300238648454, 0.08002679548755953, 0.0804300762031791, 0.08390860913477938, 0.10064807798017006, 0.09183399360824984, 0.08668934102719672, 0.06923778900231115, 0.07386089501501081, 0.06251192703769082, 0.08522810252629265, 0.058119336963969204, 0.07449294594194511, 0.08070122283039705, 0.011798051905678175, 0.007665760994903903, 0.011188823135525494, 0.012852370630093701, 0.00019026611445149832, 0.001467719439562809, 0.0028193826709582703, 0.00013930817475704682, 0.004233181476431147, 0.09774006933282309, 0.09335155845292209, 0.09925603499935676, 0.08427665820432717, 0.10984250374293736, 0.08976855066209644, 0.10594017327077332, 0.09250944940557326, 0.08413773091911625, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06873277271362077, 0.04169245991982895, 0.05004406895537872, 0.06547721470400125, 0.048459023914768085, 0.05529228125116292, 0.0614772575507494, 0.05633431968375169, 0.05289680716293965, 0.30216801690092443, 0.303888446793418, 0.30445616045527824, 0.3241644741129679, 0.3103446353267282, 0.337329347508194, 0.2961776417069316, 0.28854625378791365, 0.29438218476405953, 0.07972063172218713, 0.07905005708851676, 0.08132201180039977, 0.06964213539831221, 0.06093185997870676, 0.06568723868649262, 0.0695738540430284, 0.06855521734061587, 0.06992025673504865, 0.1347285630987406, 0.12436292465422905, 0.13721409221406122, 0.12844438682451398, 0.12519528378157718, 0.1650769430806417, 0.14801715993012, 0.13144741625376832, 0.1314866213363317, 0.20093558351950247, 0.18192492086096823, 0.1971088598468007, 0.20084485003580244, 0.19373115203610314, 0.2030630155845099, 0.20828229535443266, 0.21479661216269919, 0.2062995393338113, 0.15710351072303563, 0.13778160208038914, 0.155854586075176, 0.1422162283729198, 0.14505858823271223, 0.14675844411662475, 0.14337712514860157, 0.15649437911673902, 0.14960945026005212, 0.17949722927880918, 0.17086351853871562, 0.16068044081484534, 0.1696972628911826, 0.1801092560214136, 0.17344052105666818, 0.1667652348226647, 0.1736834499807023, 0.2008692511975716, 0.15392552905099766, 0.1689900011521197, 0.16523554495025805, 0.16171968009223014, 0.1779896147193436, 0.17053084299359467, 0.15719898356529394, 0.1554460804122233, 0.155423901842749, 0.18724689435074005, 0.14884614099059823, 0.15309533490779414, 0.14296296577509748, 0.16629510102393996, 0.21229469991459549, 0.21188092398581582, 0.14435095575993906, 0.15171783208894007, 0.1941963012162824, 0.15972828841118192, 0.19845243724673867, 0.14871305327277518, 0.14576177899963094, 0.1437399139224652, 0.27480576317209393, 0.2705347180698011, 0.1995995208694078, 0.19257986602418953, 0.18923689556725298, 0.1882658409993191, 0.19325009468551435, 0.17554572911425093, 0.2012870423653902, 0.16568351807162418, 0.17185136415072044, 0.17433013137437514, 0.06192489552723235, 0.06579418759748079, 0.06565832667182114, 0.06053242472857523, 0.06597071326239201, 0.06538903356285941, 0.06511913490580723, 0.060694781905913264, 0.07914444199391002]}, "mutation_prompt": null}
{"id": "272ea894-05e0-4249-8094-3ac1cee5a39f", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.85  # Adjusted differential weight for better diversity\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        mutant = a + self.diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        step_size = (self.upper_bound - self.lower_bound) * 0.1\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.current_budget >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Improved hybrid metaheuristic by adjusting the mutation strategy for enhanced exploration.", "configspace": "", "generation": 11, "fitness": 0.15741778398038567, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.17.", "error": "", "parent_id": "7d0d7893-98a0-4d53-8db0-4aea3894b0a3", "metadata": {"aucs": [0.3201327857376405, 0.31170824726105106, 0.27987689628233237, 0.3315878561886785, 0.3485773470109659, 0.3360167655288433, 0.32665265994303094, 0.3170205224102878, 0.317510368137354, 0.05986461722909808, 0.05441962094650721, 0.07885174642414972, 0.04171979169915374, 0.05964272567911322, 0.056013177201064024, 0.05692023921742506, 0.045821005541192616, 0.07084707240618338, 0.0711053573991931, 0.08306325889404831, 0.06492168733129788, 0.06827782937321814, 0.06224665252168071, 0.07042465205229198, 0.07382456464182363, 0.07345086889205799, 0.07375675185789443, 0.05036200793198786, 0.05504394864745099, 0.05318101353842608, 0.06578435449466846, 0.05510160152139543, 0.055800315982234006, 0.055832655837503964, 0.051279162860355276, 0.08710629786848856, 0.8434044240838502, 0.9141112167658803, 0.8412427150174693, 0.9497233990148587, 0.8377657006963173, 0.8640019425782597, 0.8943800789161096, 0.8205896173399047, 0.8070128089949308, 0.14418562270940316, 0.14776809621789122, 0.13772692655568497, 0.12291449685446931, 0.13375828840140325, 0.13100882983901851, 0.13418365824655043, 0.16573021136638422, 0.14571734622233212, 0.1822944594145648, 0.22761713151469842, 0.18361667225577039, 0.2213735961485791, 0.21112608939415556, 0.21205100777896346, 0.1690789118518986, 0.20992578051415256, 0.20055001427786268, 0.059420013050051956, 0.06714276332347413, 0.062057129036132364, 0.08684797572175862, 0.08014275194656062, 0.08697857912376183, 0.06735698868480045, 0.06609033280862842, 0.08027742578220809, 0.09185755083055924, 0.09638241096212463, 0.0955884009381942, 0.08299604930119442, 0.06338308766400647, 0.07938220120100392, 0.06540753029476032, 0.07568142647272091, 0.05838412873537313, 9.999999999998899e-05, 0.0004580088312734487, 0.0005544966793904482, 0.013188761338631227, 0.005019311516593183, 0.00018814105881537202, 0.005322181664641046, 0.0015742969226166803, 9.999999999998899e-05, 0.11880304550424625, 0.059855494860002856, 0.08848762119762321, 0.07299492504547833, 0.0526892019102444, 0.09247675078673168, 0.09307500125012957, 0.09422324111915026, 0.09168306641673152, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.045390300341720646, 0.04141278959150718, 0.04600715324919635, 0.05185201699017161, 0.04401295875792399, 0.03613248669663227, 0.05006176426653386, 0.045286711336558816, 0.057491672214703415, 0.2832324086425039, 0.2892733570135726, 0.2900320597709747, 0.287028608435168, 0.2972283059212276, 0.29091667926174847, 0.2999349640110144, 0.284490553569792, 0.31986401047715896, 0.07891876169953593, 0.07333274958125835, 0.07218397671559251, 0.06638101281122422, 0.06669367007283833, 0.06849359009859235, 0.06752115578165252, 0.06632823056365067, 0.07784207326097037, 0.12819070751356043, 0.1321041907831937, 0.13531106505358004, 0.14025946340355078, 0.1433831355404407, 0.13445876748169672, 0.1613229903300113, 0.12408180391320289, 0.1235188880931255, 0.20815262072424634, 0.18165451025753632, 0.20293271568005156, 0.19856370604290718, 0.1910030651636152, 0.19403597445604825, 0.2014024533077946, 0.2024296667848715, 0.20699661222859278, 0.1334403202105301, 0.11562255793753118, 0.13191553073036555, 0.13045023902913455, 0.14280469419668718, 0.13591249366342528, 0.14787846113172787, 0.1396723616166884, 0.13914812893592154, 0.1649612102135286, 0.16475358433708587, 0.16745514774224435, 0.17456021291613577, 0.18602341968820502, 0.16197400016165286, 0.17744001580441693, 0.1668665096700621, 0.1740818679640188, 0.15008183715824108, 0.1435512324904048, 0.16557811628214913, 0.16509627066768806, 0.1658058978370387, 0.1766145092035758, 0.15908283182675675, 0.15344675903354477, 0.15002551396140784, 0.2686442480480732, 0.18953983153178278, 0.16747262508131877, 0.22224940891211153, 0.15869592542737632, 0.15702569172791192, 0.20629263161381017, 0.16279584756254206, 0.13189756873641378, 0.21632765666260179, 0.16278426698873227, 0.3060268009432171, 0.13702695461959102, 0.13825545679899587, 0.1450117348676575, 0.2082130412951274, 0.19905661218976045, 0.18930462218041055, 0.17355111388015032, 0.17640466070161842, 0.18848907425235373, 0.16466211376453288, 0.17726059909331293, 0.17753869554918567, 0.21004608482485354, 0.18437459737106243, 0.17096906995018157, 0.06244826515890456, 0.05549624498779282, 0.058179395302103476, 0.06616154189808454, 0.05223396675205472, 0.05698696167066031, 0.05874891207483146, 0.06113903046486158, 0.055864243136642844]}, "mutation_prompt": null}
{"id": "35e7f635-82f4-4fd0-8870-712c05c0d457", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        mutant = a + self.diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        step_size = (self.upper_bound - self.lower_bound) * 0.1\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.current_budget >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "A hybrid metaheuristic combining Differential Evolution and Directional Search for efficient black-box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7d0d7893-98a0-4d53-8db0-4aea3894b0a3", "metadata": {"aucs": [0.31537579522539394, 0.3161618794503954, 0.3432111460879922, 0.3425734932719633, 0.36964931585568506, 0.3744426225517573, 0.356058231865934, 0.3479680595892244, 0.3315169954635566, 0.08512703667793009, 0.06647053435635464, 0.07878688018231828, 0.06437734048279142, 0.09813675387252918, 0.056977124238178134, 0.084664370970987, 0.09280425602716313, 0.07220065469442616, 0.07651287769050108, 0.070500105268548, 0.07701942213438162, 0.07741890395160389, 0.08220996650303858, 0.07194634751755569, 0.09331083581247768, 0.08411424396825351, 0.06921757184983834, 0.05731470680900552, 0.05538708554782368, 0.06104533785536226, 0.05803184254264793, 0.0721111636288615, 0.06895488597945754, 0.05423253366357783, 0.052746159410844706, 0.0693149011427413, 0.8882933594321745, 0.8985937746079865, 0.8363375352490298, 0.949562148941193, 0.8689990601015559, 0.8082443040629588, 0.8900228345966336, 0.7331175368593361, 0.7513897148587687, 0.1389235198492904, 0.126939080414202, 0.1331132392328065, 0.13961773357664553, 0.1470159543673777, 0.1287304293054189, 0.15027744755931183, 0.15255217533288856, 0.1493416433423319, 0.21968855793512432, 0.1962225091274833, 0.16563927673715406, 0.193216608196231, 0.2283317157937894, 0.22999891746015988, 0.2001546865729651, 0.20537262620704255, 0.2182984370861204, 0.07773139267516038, 0.07614629379795368, 0.06933351645657826, 0.09330444827507856, 0.06267300238648454, 0.08002679548755953, 0.0804300762031791, 0.08390860913477938, 0.10064807798017006, 0.09183399360824984, 0.08668934102719672, 0.06923778900231115, 0.07386089501501081, 0.06251192703769082, 0.08522810252629265, 0.058119336963969204, 0.07449294594194511, 0.08070122283039705, 0.011798051905678175, 0.007665760994903903, 0.011188823135525494, 0.012852370630093701, 0.00019026611445149832, 0.001467719439562809, 0.0028193826709582703, 0.00013930817475704682, 0.004233181476431147, 0.09774006933282309, 0.09335155845292209, 0.09925603499935676, 0.08427665820432717, 0.10984250374293736, 0.08976855066209644, 0.10594017327077332, 0.09250944940557326, 0.08413773091911625, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06873277271362077, 0.04169245991982895, 0.05004406895537872, 0.06547721470400125, 0.048459023914768085, 0.05529228125116292, 0.0614772575507494, 0.05633431968375169, 0.05289680716293965, 0.30216801690092443, 0.303888446793418, 0.30445616045527824, 0.3241644741129679, 0.3103446353267282, 0.337329347508194, 0.2961776417069316, 0.28854625378791365, 0.29438218476405953, 0.07972063172218713, 0.07905005708851676, 0.08132201180039977, 0.06964213539831221, 0.06093185997870676, 0.06568723868649262, 0.0695738540430284, 0.06855521734061587, 0.06992025673504865, 0.1347285630987406, 0.12436292465422905, 0.13721409221406122, 0.12844438682451398, 0.12519528378157718, 0.1650769430806417, 0.14801715993012, 0.13144741625376832, 0.1314866213363317, 0.20093558351950247, 0.18192492086096823, 0.1971088598468007, 0.20084485003580244, 0.19373115203610314, 0.2030630155845099, 0.20828229535443266, 0.21479661216269919, 0.2062995393338113, 0.15710351072303563, 0.13778160208038914, 0.155854586075176, 0.1422162283729198, 0.14505858823271223, 0.14675844411662475, 0.14337712514860157, 0.15649437911673902, 0.14960945026005212, 0.17949722927880918, 0.17086351853871562, 0.16068044081484534, 0.1696972628911826, 0.1801092560214136, 0.17344052105666818, 0.1667652348226647, 0.1736834499807023, 0.2008692511975716, 0.15392552905099766, 0.1689900011521197, 0.16523554495025805, 0.16171968009223014, 0.1779896147193436, 0.17053084299359467, 0.15719898356529394, 0.1554460804122233, 0.155423901842749, 0.18724689435074005, 0.14884614099059823, 0.15309533490779414, 0.14296296577509748, 0.16629510102393996, 0.21229469991459549, 0.21188092398581582, 0.14435095575993906, 0.15171783208894007, 0.1941963012162824, 0.15972828841118192, 0.19845243724673867, 0.14871305327277518, 0.14576177899963094, 0.1437399139224652, 0.27480576317209393, 0.2705347180698011, 0.1995995208694078, 0.19257986602418953, 0.18923689556725298, 0.1882658409993191, 0.19325009468551435, 0.17554572911425093, 0.2012870423653902, 0.16568351807162418, 0.17185136415072044, 0.17433013137437514, 0.06192489552723235, 0.06579418759748079, 0.06565832667182114, 0.06053242472857523, 0.06597071326239201, 0.06538903356285941, 0.06511913490580723, 0.060694781905913264, 0.07914444199391002]}, "mutation_prompt": null}
{"id": "2bf9cf79-8808-46d4-a938-5e3d9a749882", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.8\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        mutant = a + self.diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        step_size = (self.upper_bound - self.lower_bound) * 0.1\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.current_budget >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "A hybrid metaheuristic combining Differential Evolution and Directional Search for efficient black-box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7d0d7893-98a0-4d53-8db0-4aea3894b0a3", "metadata": {"aucs": [0.31537579522539394, 0.3161618794503954, 0.3432111460879922, 0.3425734932719633, 0.36964931585568506, 0.3744426225517573, 0.356058231865934, 0.3479680595892244, 0.3315169954635566, 0.08512703667793009, 0.06647053435635464, 0.07878688018231828, 0.06437734048279142, 0.09813675387252918, 0.056977124238178134, 0.084664370970987, 0.09280425602716313, 0.07220065469442616, 0.07651287769050108, 0.070500105268548, 0.07701942213438162, 0.07741890395160389, 0.08220996650303858, 0.07194634751755569, 0.09331083581247768, 0.08411424396825351, 0.06921757184983834, 0.05731470680900552, 0.05538708554782368, 0.06104533785536226, 0.05803184254264793, 0.0721111636288615, 0.06895488597945754, 0.05423253366357783, 0.052746159410844706, 0.0693149011427413, 0.8882933594321745, 0.8985937746079865, 0.8363375352490298, 0.949562148941193, 0.8689990601015559, 0.8082443040629588, 0.8900228345966336, 0.7331175368593361, 0.7513897148587687, 0.1389235198492904, 0.126939080414202, 0.1331132392328065, 0.13961773357664553, 0.1470159543673777, 0.1287304293054189, 0.15027744755931183, 0.15255217533288856, 0.1493416433423319, 0.21968855793512432, 0.1962225091274833, 0.16563927673715406, 0.193216608196231, 0.2283317157937894, 0.22999891746015988, 0.2001546865729651, 0.20537262620704255, 0.2182984370861204, 0.07773139267516038, 0.07614629379795368, 0.06933351645657826, 0.09330444827507856, 0.06267300238648454, 0.08002679548755953, 0.0804300762031791, 0.08390860913477938, 0.10064807798017006, 0.09183399360824984, 0.08668934102719672, 0.06923778900231115, 0.07386089501501081, 0.06251192703769082, 0.08522810252629265, 0.058119336963969204, 0.07449294594194511, 0.08070122283039705, 0.011798051905678175, 0.007665760994903903, 0.011188823135525494, 0.012852370630093701, 0.00019026611445149832, 0.001467719439562809, 0.0028193826709582703, 0.00013930817475704682, 0.004233181476431147, 0.09774006933282309, 0.09335155845292209, 0.09925603499935676, 0.08427665820432717, 0.10984250374293736, 0.08976855066209644, 0.10594017327077332, 0.09250944940557326, 0.08413773091911625, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06873277271362077, 0.04169245991982895, 0.05004406895537872, 0.06547721470400125, 0.048459023914768085, 0.05529228125116292, 0.0614772575507494, 0.05633431968375169, 0.05289680716293965, 0.30216801690092443, 0.303888446793418, 0.30445616045527824, 0.3241644741129679, 0.3103446353267282, 0.337329347508194, 0.2961776417069316, 0.28854625378791365, 0.29438218476405953, 0.07972063172218713, 0.07905005708851676, 0.08132201180039977, 0.06964213539831221, 0.06093185997870676, 0.06568723868649262, 0.0695738540430284, 0.06855521734061587, 0.06992025673504865, 0.1347285630987406, 0.12436292465422905, 0.13721409221406122, 0.12844438682451398, 0.12519528378157718, 0.1650769430806417, 0.14801715993012, 0.13144741625376832, 0.1314866213363317, 0.20093558351950247, 0.18192492086096823, 0.1971088598468007, 0.20084485003580244, 0.19373115203610314, 0.2030630155845099, 0.20828229535443266, 0.21479661216269919, 0.2062995393338113, 0.15710351072303563, 0.13778160208038914, 0.155854586075176, 0.1422162283729198, 0.14505858823271223, 0.14675844411662475, 0.14337712514860157, 0.15649437911673902, 0.14960945026005212, 0.17949722927880918, 0.17086351853871562, 0.16068044081484534, 0.1696972628911826, 0.1801092560214136, 0.17344052105666818, 0.1667652348226647, 0.1736834499807023, 0.2008692511975716, 0.15392552905099766, 0.1689900011521197, 0.16523554495025805, 0.16171968009223014, 0.1779896147193436, 0.17053084299359467, 0.15719898356529394, 0.1554460804122233, 0.155423901842749, 0.18724689435074005, 0.14884614099059823, 0.15309533490779414, 0.14296296577509748, 0.16629510102393996, 0.21229469991459549, 0.21188092398581582, 0.14435095575993906, 0.15171783208894007, 0.1941963012162824, 0.15972828841118192, 0.19845243724673867, 0.14871305327277518, 0.14576177899963094, 0.1437399139224652, 0.27480576317209393, 0.2705347180698011, 0.1995995208694078, 0.19257986602418953, 0.18923689556725298, 0.1882658409993191, 0.19325009468551435, 0.17554572911425093, 0.2012870423653902, 0.16568351807162418, 0.17185136415072044, 0.17433013137437514, 0.06192489552723235, 0.06579418759748079, 0.06565832667182114, 0.06053242472857523, 0.06597071326239201, 0.06538903356285941, 0.06511913490580723, 0.060694781905913264, 0.07914444199391002]}, "mutation_prompt": null}
{"id": "5f344df5-a9cd-4ec3-9e89-915454c17e91", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9\n        self.diff_weight = 0.5 + np.random.rand() * 0.5  # Change: Adaptive differential weight\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        mutant = a + self.diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        step_size = (self.upper_bound - self.lower_bound) * 0.1\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.current_budget >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "A hybrid metaheuristic with enhanced differential weight adaptivity for improved optimization performance.", "configspace": "", "generation": 14, "fitness": 0.17225298957132448, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.17.", "error": "", "parent_id": "7d0d7893-98a0-4d53-8db0-4aea3894b0a3", "metadata": {"aucs": [0.3248437191280674, 0.3612044171388641, 0.3584193861042896, 0.35327715887073463, 0.36559604346567554, 0.3521381471430812, 0.34940248866424084, 0.378076857701814, 0.38410557219773844, 0.09189053072475784, 0.1088915794038956, 0.11132544171431413, 0.08899850201281301, 0.10758588528419988, 0.09360128058974804, 0.09439856159594306, 0.09990740636508455, 0.12849071431413306, 0.0788485925816198, 0.08087587164829857, 0.07482520748452703, 0.0747862882739524, 0.08307071929980736, 0.07920088340809928, 0.07083029537776797, 0.0852537005189079, 0.07879115981737272, 0.06232745987914001, 0.07226725745521945, 0.06496120538847205, 0.07018666348248714, 0.07701898850805355, 0.07423957756437272, 0.05729135824609244, 0.06363020153563981, 0.06964841635672747, 0.9224685506606798, 0.8234554946252335, 0.8261547110596998, 0.8231915878676219, 0.7821397032169727, 0.8737748841568236, 0.9342799095893708, 0.9059374803722918, 0.8672920061267277, 0.14334593107014293, 0.1796813475527177, 0.1613081788416375, 0.14796818108470144, 0.14930490710270483, 0.1531944229058223, 0.1642330845370239, 0.17040379245079496, 0.18078523797205215, 0.22014464844050252, 0.2099099553158731, 0.2222528723260926, 0.2092601143978816, 0.27232688078021117, 0.2416728291682546, 0.21031088043511204, 0.2368279894518549, 0.22989206067473011, 0.05933467163077022, 0.11334165348027259, 0.07474919723023299, 0.09213451608498457, 0.08865862744580222, 0.10909729852252403, 0.0777950099678385, 0.10401120560427757, 0.11468499922305908, 0.09875639806757808, 0.12049417242327964, 0.10876341934377065, 0.061677624528959085, 0.07613901996843708, 0.09766957443223967, 0.080103656353125, 0.0839973032129041, 0.08178489614294582, 0.015395540187059797, 0.019217553700338952, 0.03254777585804891, 0.005810350348446125, 0.010456423292857342, 0.010193088538236972, 0.013775182306713374, 0.022148377297220967, 0.01887559870985056, 0.1431363868028489, 0.08609221655601085, 0.10890183473052006, 0.07740024453300554, 0.10607578246971805, 0.14674003391281676, 0.1323481151022894, 0.11975536803557174, 0.13718846471151558, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06958595181586458, 0.05584940955364304, 0.06562591450864963, 0.06083690923006779, 0.06156042452870514, 0.07064377397424448, 0.05996584307599784, 0.07133623370542153, 0.06175322096883629, 0.3122975017929419, 0.3296283268645297, 0.3481874506733367, 0.3130320516042796, 0.3440980493432103, 0.33517918041141825, 0.33116815914874587, 0.348551784037365, 0.3322507243855082, 0.08661781925038958, 0.08561580415539904, 0.0735690189122783, 0.06957175468347543, 0.07408372909429384, 0.07092652930878363, 0.08128570473184848, 0.06970204745986852, 0.0684162754084704, 0.14056892998785275, 0.155257866455212, 0.14441609884469742, 0.13307699316253163, 0.15461691797034605, 0.1636516817268543, 0.1736977703839171, 0.15011316902533967, 0.13047540697063065, 0.2055718354342696, 0.22914529381580873, 0.20600497894628844, 0.19595685936198726, 0.2100947596800109, 0.20652016294755438, 0.22229181384544872, 0.20524459196054423, 0.22108629709437322, 0.16336352987621816, 0.15565138941296808, 0.16794117494045369, 0.16307178315445003, 0.15683675467408864, 0.15008850691724807, 0.15956440601205946, 0.16454953387489035, 0.1662253454976571, 0.1854645801232675, 0.15743221822477738, 0.1766272761146711, 0.16360176675367677, 0.16198299159657348, 0.1693994941510929, 0.16979208295930204, 0.17567024430157996, 0.19081992980674645, 0.16486207727961044, 0.1661179834556168, 0.1651760192460211, 0.1584693686963492, 0.1715737462557163, 0.16629795883035892, 0.16206899967904353, 0.16913269271217324, 0.1580980274164362, 0.1672608870832999, 0.16503260560188193, 0.33716322014441646, 0.13008078310939286, 0.16750232533799714, 0.14419829423819608, 0.1476349095991376, 0.1699817292392558, 0.16777856928952228, 0.16403008481772963, 0.28307017806436674, 0.1832170184902675, 0.18511657646787094, 0.23659954936653993, 0.19100173059483294, 0.19120577568337016, 0.19994991442236398, 0.19855566998590513, 0.17496894891785164, 0.1707105213424862, 0.1822159463191112, 0.18782487675703097, 0.16784327191911685, 0.17761331239904843, 0.18088785244415317, 0.16155114391968528, 0.18711234868783566, 0.08311707165351967, 0.06084455990302595, 0.07679525945683852, 0.06548279806216084, 0.06899902292493931, 0.07017038304270495, 0.06659371180714146, 0.06728563684868838, 0.06636159507455597]}, "mutation_prompt": null}
{"id": "738021ab-7dec-4578-838a-8c9754ac67f0", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim  # Change: Adaptive crossover probability\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        mutant = a + self.diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        step_size = (self.upper_bound - self.lower_bound) * 0.1\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.current_budget >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Enhanced differential weight adaptivity and selective crossover probability to improve convergence in optimization.", "configspace": "", "generation": 15, "fitness": 0.1756994279831755, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.16.", "error": "", "parent_id": "5f344df5-a9cd-4ec3-9e89-915454c17e91", "metadata": {"aucs": [0.31695485697914294, 0.36443626703723664, 0.3280035590197171, 0.36682164785123517, 0.3784952077196003, 0.35809858006930906, 0.34526807382454117, 0.40433105248239, 0.4013801647214893, 0.07876118645730745, 0.10622104268088584, 0.10160225904119957, 0.09700446530008633, 0.116258718150823, 0.11122641969329017, 0.10314230443947747, 0.10873724642469629, 0.11936940726787981, 0.06731571169212569, 0.0738305382486042, 0.07639225633996083, 0.07772708164858899, 0.08683297955279345, 0.08247241259196669, 0.0765843996780905, 0.08310370713857906, 0.08024875369852491, 0.05690990153622422, 0.0672607201262454, 0.06366979041035703, 0.06594794389638647, 0.06152898801581086, 0.06333410000867201, 0.05799175897876885, 0.06599325216573437, 0.0756024058151945, 0.7984881750853494, 0.87845240993234, 0.8446966305005529, 0.8001945952220999, 0.8136984037038798, 0.8564928718980906, 0.8757139173616789, 0.9195848190348581, 0.8083827056369808, 0.17157482790477185, 0.16495232882215094, 0.15020317566734087, 0.15083128489927078, 0.14666062607242403, 0.16288809823848238, 0.16238917430588806, 0.1586137608052044, 0.19073636443602193, 0.2323532686131421, 0.23010946326405235, 0.23642281605053928, 0.2199099050854565, 0.2563817907450653, 0.22734349198391202, 0.24416572392366853, 0.22809209802312624, 0.2249811217729102, 0.08566478628908791, 0.09466827127695598, 0.1012350943136493, 0.07767944065281152, 0.0990182328341167, 0.13555486020769536, 0.08066966842614998, 0.12386174710491504, 0.09389900928455719, 0.09063122013624836, 0.1060642155261381, 0.08760668599281274, 0.07572436482506528, 0.10450435434479355, 0.11436780575448979, 0.06892843644638669, 0.0999530635482897, 0.10089850664116107, 0.005914694747429561, 0.044062534445959534, 0.03474009616448004, 0.016239594924405742, 0.015246069053198363, 0.06374913000334403, 0.020632472236858268, 0.032657182831741016, 0.021744779359503807, 0.15435466161014866, 0.11966209304519304, 0.1465653623609523, 0.14599691233862833, 0.08999521105033215, 0.11183044877019654, 0.12351379566187881, 0.15236199352225865, 0.14664402071532856, 9.999999999998899e-05, 9.999999999998899e-05, 0.001657424446436906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00012132126524522224, 9.999999999998899e-05, 0.07220155424391017, 0.06849057904187617, 0.06640212785634592, 0.05388759741778926, 0.0631690708499224, 0.08537756493413906, 0.07081871755579217, 0.07851829342426775, 0.0687595506597174, 0.30966431284156437, 0.3416895559296599, 0.3516602807542295, 0.3153868050860211, 0.3359715002071605, 0.3463232422345751, 0.3196486737330697, 0.3214921985984188, 0.3471839046616626, 0.07656966686488886, 0.08918548368208179, 0.06927245161783757, 0.0794998834788877, 0.07775424422168487, 0.08828539941004765, 0.07882178661878081, 0.06733102409516745, 0.0778218038766767, 0.13097105842592793, 0.13401139662423833, 0.23129274169541214, 0.14622296933386947, 0.15594827143074108, 0.15665670963490774, 0.15614185076159515, 0.15442169001893857, 0.14998085140690653, 0.20224416972422532, 0.2201542700614758, 0.22384909288967414, 0.20883535167751466, 0.19928145237153383, 0.20452932692898507, 0.2160507373752243, 0.24126046773825205, 0.22644731761574044, 0.14715479918303176, 0.15455094410850856, 0.1625567469651389, 0.1417491969012915, 0.15018974160449838, 0.15222922280673878, 0.15701601924686492, 0.15657990682927614, 0.17306719458067876, 0.18682707153828593, 0.18183574031775152, 0.1807793447254682, 0.17443724900011093, 0.17613432147033958, 0.17684030346840607, 0.15915206094432344, 0.1801567364036113, 0.18614462339030302, 0.16777048074936063, 0.17282330210652508, 0.16514674053567102, 0.15719368156744584, 0.164715022060001, 0.16868453482129897, 0.16221958364455236, 0.1621652290812744, 0.16144577925288472, 0.15827530232263487, 0.16712645615586097, 0.3459349795962193, 0.19968330686111202, 0.19466286646989805, 0.14603278133198327, 0.14611399297975147, 0.20409322827616416, 0.18622673992709393, 0.21069919997297204, 0.2751674431269293, 0.2506901525562497, 0.21585211623077705, 0.1782682568003071, 0.18076030443508384, 0.19232507001248877, 0.19495197282120524, 0.25245655954661483, 0.18370763469588025, 0.18331936208970656, 0.18326388870830235, 0.17602738598475642, 0.1732645233748633, 0.19916933779209134, 0.19913462337353272, 0.1807468403256658, 0.17943209927311377, 0.06995534495330846, 0.08582678492122486, 0.06476096030301759, 0.06160122296069115, 0.05451864288579167, 0.0714078837536517, 0.06725511700944353, 0.06640115776166244, 0.06041775600984023]}, "mutation_prompt": null}
{"id": "e22aa4de-9a20-4a9c-9bdc-1f3856fc4fd4", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim  # Change: Adaptive crossover probability\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        mutant = a + self.diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        step_size = (self.upper_bound - self.lower_bound) * 0.1\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.current_budget >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Enhanced differential weight adaptivity and selective crossover probability to improve convergence in optimization.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "738021ab-7dec-4578-838a-8c9754ac67f0", "metadata": {"aucs": [0.31695485697914294, 0.36443626703723664, 0.3280035590197171, 0.36682164785123517, 0.3784952077196003, 0.35809858006930906, 0.34526807382454117, 0.40433105248239, 0.4013801647214893, 0.07876118645730745, 0.10622104268088584, 0.10160225904119957, 0.09700446530008633, 0.116258718150823, 0.11122641969329017, 0.10314230443947747, 0.10873724642469629, 0.11936940726787981, 0.06731571169212569, 0.0738305382486042, 0.07639225633996083, 0.07772708164858899, 0.08683297955279345, 0.08247241259196669, 0.0765843996780905, 0.08310370713857906, 0.08024875369852491, 0.05690990153622422, 0.0672607201262454, 0.06366979041035703, 0.06594794389638647, 0.06152898801581086, 0.06333410000867201, 0.05799175897876885, 0.06599325216573437, 0.0756024058151945, 0.7984881750853494, 0.87845240993234, 0.8446966305005529, 0.8001945952220999, 0.8136984037038798, 0.8564928718980906, 0.8757139173616789, 0.9195848190348581, 0.8083827056369808, 0.17157482790477185, 0.16495232882215094, 0.15020317566734087, 0.15083128489927078, 0.14666062607242403, 0.16288809823848238, 0.16238917430588806, 0.1586137608052044, 0.19073636443602193, 0.2323532686131421, 0.23010946326405235, 0.23642281605053928, 0.2199099050854565, 0.2563817907450653, 0.22734349198391202, 0.24416572392366853, 0.22809209802312624, 0.2249811217729102, 0.08566478628908791, 0.09466827127695598, 0.1012350943136493, 0.07767944065281152, 0.0990182328341167, 0.13555486020769536, 0.08066966842614998, 0.12386174710491504, 0.09389900928455719, 0.09063122013624836, 0.1060642155261381, 0.08760668599281274, 0.07572436482506528, 0.10450435434479355, 0.11436780575448979, 0.06892843644638669, 0.0999530635482897, 0.10089850664116107, 0.005914694747429561, 0.044062534445959534, 0.03474009616448004, 0.016239594924405742, 0.015246069053198363, 0.06374913000334403, 0.020632472236858268, 0.032657182831741016, 0.021744779359503807, 0.15435466161014866, 0.11966209304519304, 0.1465653623609523, 0.14599691233862833, 0.08999521105033215, 0.11183044877019654, 0.12351379566187881, 0.15236199352225865, 0.14664402071532856, 9.999999999998899e-05, 9.999999999998899e-05, 0.001657424446436906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00012132126524522224, 9.999999999998899e-05, 0.07220155424391017, 0.06849057904187617, 0.06640212785634592, 0.05388759741778926, 0.0631690708499224, 0.08537756493413906, 0.07081871755579217, 0.07851829342426775, 0.0687595506597174, 0.30966431284156437, 0.3416895559296599, 0.3516602807542295, 0.3153868050860211, 0.3359715002071605, 0.3463232422345751, 0.3196486737330697, 0.3214921985984188, 0.3471839046616626, 0.07656966686488886, 0.08918548368208179, 0.06927245161783757, 0.0794998834788877, 0.07775424422168487, 0.08828539941004765, 0.07882178661878081, 0.06733102409516745, 0.0778218038766767, 0.13097105842592793, 0.13401139662423833, 0.23129274169541214, 0.14622296933386947, 0.15594827143074108, 0.15665670963490774, 0.15614185076159515, 0.15442169001893857, 0.14998085140690653, 0.20224416972422532, 0.2201542700614758, 0.22384909288967414, 0.20883535167751466, 0.19928145237153383, 0.20452932692898507, 0.2160507373752243, 0.24126046773825205, 0.22644731761574044, 0.14715479918303176, 0.15455094410850856, 0.1625567469651389, 0.1417491969012915, 0.15018974160449838, 0.15222922280673878, 0.15701601924686492, 0.15657990682927614, 0.17306719458067876, 0.18682707153828593, 0.18183574031775152, 0.1807793447254682, 0.17443724900011093, 0.17613432147033958, 0.17684030346840607, 0.15915206094432344, 0.1801567364036113, 0.18614462339030302, 0.16777048074936063, 0.17282330210652508, 0.16514674053567102, 0.15719368156744584, 0.164715022060001, 0.16868453482129897, 0.16221958364455236, 0.1621652290812744, 0.16144577925288472, 0.15827530232263487, 0.16712645615586097, 0.3459349795962193, 0.19968330686111202, 0.19466286646989805, 0.14603278133198327, 0.14611399297975147, 0.20409322827616416, 0.18622673992709393, 0.21069919997297204, 0.2751674431269293, 0.2506901525562497, 0.21585211623077705, 0.1782682568003071, 0.18076030443508384, 0.19232507001248877, 0.19495197282120524, 0.25245655954661483, 0.18370763469588025, 0.18331936208970656, 0.18326388870830235, 0.17602738598475642, 0.1732645233748633, 0.19916933779209134, 0.19913462337353272, 0.1807468403256658, 0.17943209927311377, 0.06995534495330846, 0.08582678492122486, 0.06476096030301759, 0.06160122296069115, 0.05451864288579167, 0.0714078837536517, 0.06725511700944353, 0.06640115776166244, 0.06041775600984023]}, "mutation_prompt": null}
{"id": "5e3e8505-f5aa-4b77-8a89-c6efd7e844ab", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim  # Change: Adaptive crossover probability\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        mutant = a + self.diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        step_size = (self.upper_bound - self.lower_bound) * 0.1\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.current_budget >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Enhanced differential weight adaptivity and selective crossover probability to improve convergence in optimization.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "738021ab-7dec-4578-838a-8c9754ac67f0", "metadata": {"aucs": [0.31695485697914294, 0.36443626703723664, 0.3280035590197171, 0.36682164785123517, 0.3784952077196003, 0.35809858006930906, 0.34526807382454117, 0.40433105248239, 0.4013801647214893, 0.07876118645730745, 0.10622104268088584, 0.10160225904119957, 0.09700446530008633, 0.116258718150823, 0.11122641969329017, 0.10314230443947747, 0.10873724642469629, 0.11936940726787981, 0.06731571169212569, 0.0738305382486042, 0.07639225633996083, 0.07772708164858899, 0.08683297955279345, 0.08247241259196669, 0.0765843996780905, 0.08310370713857906, 0.08024875369852491, 0.05690990153622422, 0.0672607201262454, 0.06366979041035703, 0.06594794389638647, 0.06152898801581086, 0.06333410000867201, 0.05799175897876885, 0.06599325216573437, 0.0756024058151945, 0.7984881750853494, 0.87845240993234, 0.8446966305005529, 0.8001945952220999, 0.8136984037038798, 0.8564928718980906, 0.8757139173616789, 0.9195848190348581, 0.8083827056369808, 0.17157482790477185, 0.16495232882215094, 0.15020317566734087, 0.15083128489927078, 0.14666062607242403, 0.16288809823848238, 0.16238917430588806, 0.1586137608052044, 0.19073636443602193, 0.2323532686131421, 0.23010946326405235, 0.23642281605053928, 0.2199099050854565, 0.2563817907450653, 0.22734349198391202, 0.24416572392366853, 0.22809209802312624, 0.2249811217729102, 0.08566478628908791, 0.09466827127695598, 0.1012350943136493, 0.07767944065281152, 0.0990182328341167, 0.13555486020769536, 0.08066966842614998, 0.12386174710491504, 0.09389900928455719, 0.09063122013624836, 0.1060642155261381, 0.08760668599281274, 0.07572436482506528, 0.10450435434479355, 0.11436780575448979, 0.06892843644638669, 0.0999530635482897, 0.10089850664116107, 0.005914694747429561, 0.044062534445959534, 0.03474009616448004, 0.016239594924405742, 0.015246069053198363, 0.06374913000334403, 0.020632472236858268, 0.032657182831741016, 0.021744779359503807, 0.15435466161014866, 0.11966209304519304, 0.1465653623609523, 0.14599691233862833, 0.08999521105033215, 0.11183044877019654, 0.12351379566187881, 0.15236199352225865, 0.14664402071532856, 9.999999999998899e-05, 9.999999999998899e-05, 0.001657424446436906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00012132126524522224, 9.999999999998899e-05, 0.07220155424391017, 0.06849057904187617, 0.06640212785634592, 0.05388759741778926, 0.0631690708499224, 0.08537756493413906, 0.07081871755579217, 0.07851829342426775, 0.0687595506597174, 0.30966431284156437, 0.3416895559296599, 0.3516602807542295, 0.3153868050860211, 0.3359715002071605, 0.3463232422345751, 0.3196486737330697, 0.3214921985984188, 0.3471839046616626, 0.07656966686488886, 0.08918548368208179, 0.06927245161783757, 0.0794998834788877, 0.07775424422168487, 0.08828539941004765, 0.07882178661878081, 0.06733102409516745, 0.0778218038766767, 0.13097105842592793, 0.13401139662423833, 0.23129274169541214, 0.14622296933386947, 0.15594827143074108, 0.15665670963490774, 0.15614185076159515, 0.15442169001893857, 0.14998085140690653, 0.20224416972422532, 0.2201542700614758, 0.22384909288967414, 0.20883535167751466, 0.19928145237153383, 0.20452932692898507, 0.2160507373752243, 0.24126046773825205, 0.22644731761574044, 0.14715479918303176, 0.15455094410850856, 0.1625567469651389, 0.1417491969012915, 0.15018974160449838, 0.15222922280673878, 0.15701601924686492, 0.15657990682927614, 0.17306719458067876, 0.18682707153828593, 0.18183574031775152, 0.1807793447254682, 0.17443724900011093, 0.17613432147033958, 0.17684030346840607, 0.15915206094432344, 0.1801567364036113, 0.18614462339030302, 0.16777048074936063, 0.17282330210652508, 0.16514674053567102, 0.15719368156744584, 0.164715022060001, 0.16868453482129897, 0.16221958364455236, 0.1621652290812744, 0.16144577925288472, 0.15827530232263487, 0.16712645615586097, 0.3459349795962193, 0.19968330686111202, 0.19466286646989805, 0.14603278133198327, 0.14611399297975147, 0.20409322827616416, 0.18622673992709393, 0.21069919997297204, 0.2751674431269293, 0.2506901525562497, 0.21585211623077705, 0.1782682568003071, 0.18076030443508384, 0.19232507001248877, 0.19495197282120524, 0.25245655954661483, 0.18370763469588025, 0.18331936208970656, 0.18326388870830235, 0.17602738598475642, 0.1732645233748633, 0.19916933779209134, 0.19913462337353272, 0.1807468403256658, 0.17943209927311377, 0.06995534495330846, 0.08582678492122486, 0.06476096030301759, 0.06160122296069115, 0.05451864288579167, 0.0714078837536517, 0.06725511700944353, 0.06640115776166244, 0.06041775600984023]}, "mutation_prompt": null}
{"id": "4b86bd78-e08d-43c5-b8ea-1e4090f4c3ba", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim  # Change: Adaptive crossover probability\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        mutant = a + self.diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        step_size = (self.upper_bound - self.lower_bound) * 0.1\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.current_budget >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Enhanced differential weight adaptivity and selective crossover probability to improve convergence in optimization.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "738021ab-7dec-4578-838a-8c9754ac67f0", "metadata": {"aucs": [0.31695485697914294, 0.36443626703723664, 0.3280035590197171, 0.36682164785123517, 0.3784952077196003, 0.35809858006930906, 0.34526807382454117, 0.40433105248239, 0.4013801647214893, 0.07876118645730745, 0.10622104268088584, 0.10160225904119957, 0.09700446530008633, 0.116258718150823, 0.11122641969329017, 0.10314230443947747, 0.10873724642469629, 0.11936940726787981, 0.06731571169212569, 0.0738305382486042, 0.07639225633996083, 0.07772708164858899, 0.08683297955279345, 0.08247241259196669, 0.0765843996780905, 0.08310370713857906, 0.08024875369852491, 0.05690990153622422, 0.0672607201262454, 0.06366979041035703, 0.06594794389638647, 0.06152898801581086, 0.06333410000867201, 0.05799175897876885, 0.06599325216573437, 0.0756024058151945, 0.7984881750853494, 0.87845240993234, 0.8446966305005529, 0.8001945952220999, 0.8136984037038798, 0.8564928718980906, 0.8757139173616789, 0.9195848190348581, 0.8083827056369808, 0.17157482790477185, 0.16495232882215094, 0.15020317566734087, 0.15083128489927078, 0.14666062607242403, 0.16288809823848238, 0.16238917430588806, 0.1586137608052044, 0.19073636443602193, 0.2323532686131421, 0.23010946326405235, 0.23642281605053928, 0.2199099050854565, 0.2563817907450653, 0.22734349198391202, 0.24416572392366853, 0.22809209802312624, 0.2249811217729102, 0.08566478628908791, 0.09466827127695598, 0.1012350943136493, 0.07767944065281152, 0.0990182328341167, 0.13555486020769536, 0.08066966842614998, 0.12386174710491504, 0.09389900928455719, 0.09063122013624836, 0.1060642155261381, 0.08760668599281274, 0.07572436482506528, 0.10450435434479355, 0.11436780575448979, 0.06892843644638669, 0.0999530635482897, 0.10089850664116107, 0.005914694747429561, 0.044062534445959534, 0.03474009616448004, 0.016239594924405742, 0.015246069053198363, 0.06374913000334403, 0.020632472236858268, 0.032657182831741016, 0.021744779359503807, 0.15435466161014866, 0.11966209304519304, 0.1465653623609523, 0.14599691233862833, 0.08999521105033215, 0.11183044877019654, 0.12351379566187881, 0.15236199352225865, 0.14664402071532856, 9.999999999998899e-05, 9.999999999998899e-05, 0.001657424446436906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00012132126524522224, 9.999999999998899e-05, 0.07220155424391017, 0.06849057904187617, 0.06640212785634592, 0.05388759741778926, 0.0631690708499224, 0.08537756493413906, 0.07081871755579217, 0.07851829342426775, 0.0687595506597174, 0.30966431284156437, 0.3416895559296599, 0.3516602807542295, 0.3153868050860211, 0.3359715002071605, 0.3463232422345751, 0.3196486737330697, 0.3214921985984188, 0.3471839046616626, 0.07656966686488886, 0.08918548368208179, 0.06927245161783757, 0.0794998834788877, 0.07775424422168487, 0.08828539941004765, 0.07882178661878081, 0.06733102409516745, 0.0778218038766767, 0.13097105842592793, 0.13401139662423833, 0.23129274169541214, 0.14622296933386947, 0.15594827143074108, 0.15665670963490774, 0.15614185076159515, 0.15442169001893857, 0.14998085140690653, 0.20224416972422532, 0.2201542700614758, 0.22384909288967414, 0.20883535167751466, 0.19928145237153383, 0.20452932692898507, 0.2160507373752243, 0.24126046773825205, 0.22644731761574044, 0.14715479918303176, 0.15455094410850856, 0.1625567469651389, 0.1417491969012915, 0.15018974160449838, 0.15222922280673878, 0.15701601924686492, 0.15657990682927614, 0.17306719458067876, 0.18682707153828593, 0.18183574031775152, 0.1807793447254682, 0.17443724900011093, 0.17613432147033958, 0.17684030346840607, 0.15915206094432344, 0.1801567364036113, 0.18614462339030302, 0.16777048074936063, 0.17282330210652508, 0.16514674053567102, 0.15719368156744584, 0.164715022060001, 0.16868453482129897, 0.16221958364455236, 0.1621652290812744, 0.16144577925288472, 0.15827530232263487, 0.16712645615586097, 0.3459349795962193, 0.19968330686111202, 0.19466286646989805, 0.14603278133198327, 0.14611399297975147, 0.20409322827616416, 0.18622673992709393, 0.21069919997297204, 0.2751674431269293, 0.2506901525562497, 0.21585211623077705, 0.1782682568003071, 0.18076030443508384, 0.19232507001248877, 0.19495197282120524, 0.25245655954661483, 0.18370763469588025, 0.18331936208970656, 0.18326388870830235, 0.17602738598475642, 0.1732645233748633, 0.19916933779209134, 0.19913462337353272, 0.1807468403256658, 0.17943209927311377, 0.06995534495330846, 0.08582678492122486, 0.06476096030301759, 0.06160122296069115, 0.05451864288579167, 0.0714078837536517, 0.06725511700944353, 0.06640115776166244, 0.06041775600984023]}, "mutation_prompt": null}
{"id": "916ee6e4-d32d-4fc5-a4ef-71ffd6f34403", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim  # Change: Adaptive crossover probability\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        mutant = a + self.diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        # Changed from fixed to dynamic step size\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.9 * (self.current_budget / self.budget))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.current_budget >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Introduced dynamic step size in the directional search to enhance exploration and convergence of the search space.", "configspace": "", "generation": 19, "fitness": 0.1706593513847514, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.16.", "error": "", "parent_id": "738021ab-7dec-4578-838a-8c9754ac67f0", "metadata": {"aucs": [0.30697895220495786, 0.3386655566973745, 0.33038713693740973, 0.3539019768733216, 0.36069900181182524, 0.3489915308485725, 0.3536440248378413, 0.37201162241233154, 0.3804908087197447, 0.08331398091954745, 0.10305401847469653, 0.1080645388416337, 0.0957469357186368, 0.11759028611708178, 0.10642209447194251, 0.0845776769586506, 0.08517229362493706, 0.1120863981358341, 0.06382475120276809, 0.08325137231223922, 0.07850027282726402, 0.06627255568630241, 0.0730745453906918, 0.0663664582070973, 0.07206604241274495, 0.07804026121546737, 0.07101242357419868, 0.06520554591780858, 0.06945069338345455, 0.06474001661421358, 0.05307171598886529, 0.063545751800968, 0.06771541561992978, 0.05696930554921642, 0.08363957740342465, 0.08111896285931852, 0.7822318214502519, 0.8469227130025511, 0.797845670972337, 0.8651121024688233, 0.8386287363488616, 0.8816046811679003, 0.8305641588162892, 0.928488054318521, 0.7835149261167789, 0.13166568676793267, 0.1571704716126382, 0.1585149911773751, 0.16231909745898243, 0.1670748175668716, 0.16458017879261444, 0.1615914165002279, 0.1778089379308574, 0.19307364691299267, 0.20062296076477137, 0.2151893403375007, 0.2594801763205551, 0.20565728034652653, 0.23993360071045577, 0.2340099510857787, 0.20976721127017628, 0.25405326032915776, 0.21650125035110956, 0.08601645747981579, 0.11066726445618003, 0.09833631095885265, 0.0732364391088477, 0.10447923107084622, 0.09303005663092112, 0.08530952185610718, 0.09680713858906675, 0.08511151608842105, 0.0772211789197148, 0.11314548141639791, 0.09221896526860474, 0.08557890021304315, 0.08399373384618103, 0.10090220132053762, 0.07854921090629507, 0.08204847300197837, 0.12069362391488847, 0.013605116368276549, 0.015502386274602986, 0.02124224851893508, 0.006910191641951835, 0.010422504746339878, 0.018965931558288185, 0.01001884758570959, 0.02234174977530823, 0.016774904249687306, 0.11067571938558829, 0.1361159040101958, 0.1373009486362503, 0.08277251805355301, 0.13707521667247713, 0.15477839630500234, 0.13954312959301862, 0.14447050470884548, 0.11358083252125528, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003499756475027982, 0.0017435759679559348, 9.999999999998899e-05, 0.06517324708064953, 0.06126851807115474, 0.07081954145495206, 0.06203980309703805, 0.07043257593313468, 0.06521087343466458, 0.06427558893293972, 0.09000800453330726, 0.06924529755963449, 0.30676366491344464, 0.31022592753128697, 0.32601215704071573, 0.3155711037055644, 0.33656776573636527, 0.32784126194719776, 0.3054935965380896, 0.3164092577152453, 0.32639081147064575, 0.07481897804493798, 0.08394118629257741, 0.07714848568209709, 0.06270084191798997, 0.08664650818017894, 0.06481750166303168, 0.06747189413401322, 0.06200691015480375, 0.06929441688514093, 0.12363376026301554, 0.12807700124324672, 0.13042914612413892, 0.14500052793783247, 0.15694872914988867, 0.11922378232105113, 0.16348284594227203, 0.15126504211425762, 0.12274125804665759, 0.18533783636985324, 0.21814697728769228, 0.22337045609492512, 0.17778087268383347, 0.19819997673636158, 0.19017921074854072, 0.22101073963548257, 0.21825420818970498, 0.22290557416678236, 0.12776727018299894, 0.14815704430610022, 0.16888226866084666, 0.149368652952117, 0.1466511351628258, 0.14394719245773646, 0.1419833259129738, 0.15129736432362317, 0.1656256751188192, 0.17772829382634225, 0.17786496164018317, 0.1830313707525134, 0.1694375068712447, 0.1622385567852812, 0.18935157912644662, 0.17328260223662306, 0.18221036508606703, 0.1782869791165973, 0.17774709664249966, 0.1555193010001663, 0.18056389647628313, 0.16073453598730325, 0.16191176439546306, 0.16852692235537958, 0.168873966454253, 0.16807073701998576, 0.16575530268570016, 0.15737488843905179, 0.17265815290869158, 0.3332062523603685, 0.17807832029992243, 0.28729682710293125, 0.1966020962207744, 0.14981450994557477, 0.1684251392609596, 0.1848899191979787, 0.1566483530308791, 0.2394765881328519, 0.1734558901063119, 0.16369447803229975, 0.2229257977141057, 0.1822869320080227, 0.1910313267529633, 0.30852756723825825, 0.1882568121165814, 0.17690222241653297, 0.18168952569556973, 0.18413244832673692, 0.17188457384563793, 0.18268932370540247, 0.19023509016959705, 0.2037441631893514, 0.1868969329129776, 0.17280542183889935, 0.05992381911927769, 0.06155051889015284, 0.06928569284427155, 0.05517553810147835, 0.06203789326903919, 0.05359448960212232, 0.06645146607122765, 0.062007931236425784, 0.05838593319424601]}, "mutation_prompt": null}
{"id": "001c1fa5-a074-407b-be8a-a24fc649b417", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim  # Change: Adaptive crossover probability\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        mutant = a + self.diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        step_size = (self.upper_bound - self.lower_bound) * 0.1\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.current_budget >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Enhanced differential weight adaptivity and selective crossover probability to improve convergence in optimization.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "738021ab-7dec-4578-838a-8c9754ac67f0", "metadata": {"aucs": [0.31695485697914294, 0.36443626703723664, 0.3280035590197171, 0.36682164785123517, 0.3784952077196003, 0.35809858006930906, 0.34526807382454117, 0.40433105248239, 0.4013801647214893, 0.07876118645730745, 0.10622104268088584, 0.10160225904119957, 0.09700446530008633, 0.116258718150823, 0.11122641969329017, 0.10314230443947747, 0.10873724642469629, 0.11936940726787981, 0.06731571169212569, 0.0738305382486042, 0.07639225633996083, 0.07772708164858899, 0.08683297955279345, 0.08247241259196669, 0.0765843996780905, 0.08310370713857906, 0.08024875369852491, 0.05690990153622422, 0.0672607201262454, 0.06366979041035703, 0.06594794389638647, 0.06152898801581086, 0.06333410000867201, 0.05799175897876885, 0.06599325216573437, 0.0756024058151945, 0.7984881750853494, 0.87845240993234, 0.8446966305005529, 0.8001945952220999, 0.8136984037038798, 0.8564928718980906, 0.8757139173616789, 0.9195848190348581, 0.8083827056369808, 0.17157482790477185, 0.16495232882215094, 0.15020317566734087, 0.15083128489927078, 0.14666062607242403, 0.16288809823848238, 0.16238917430588806, 0.1586137608052044, 0.19073636443602193, 0.2323532686131421, 0.23010946326405235, 0.23642281605053928, 0.2199099050854565, 0.2563817907450653, 0.22734349198391202, 0.24416572392366853, 0.22809209802312624, 0.2249811217729102, 0.08566478628908791, 0.09466827127695598, 0.1012350943136493, 0.07767944065281152, 0.0990182328341167, 0.13555486020769536, 0.08066966842614998, 0.12386174710491504, 0.09389900928455719, 0.09063122013624836, 0.1060642155261381, 0.08760668599281274, 0.07572436482506528, 0.10450435434479355, 0.11436780575448979, 0.06892843644638669, 0.0999530635482897, 0.10089850664116107, 0.005914694747429561, 0.044062534445959534, 0.03474009616448004, 0.016239594924405742, 0.015246069053198363, 0.06374913000334403, 0.020632472236858268, 0.032657182831741016, 0.021744779359503807, 0.15435466161014866, 0.11966209304519304, 0.1465653623609523, 0.14599691233862833, 0.08999521105033215, 0.11183044877019654, 0.12351379566187881, 0.15236199352225865, 0.14664402071532856, 9.999999999998899e-05, 9.999999999998899e-05, 0.001657424446436906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00012132126524522224, 9.999999999998899e-05, 0.07220155424391017, 0.06849057904187617, 0.06640212785634592, 0.05388759741778926, 0.0631690708499224, 0.08537756493413906, 0.07081871755579217, 0.07851829342426775, 0.0687595506597174, 0.30966431284156437, 0.3416895559296599, 0.3516602807542295, 0.3153868050860211, 0.3359715002071605, 0.3463232422345751, 0.3196486737330697, 0.3214921985984188, 0.3471839046616626, 0.07656966686488886, 0.08918548368208179, 0.06927245161783757, 0.0794998834788877, 0.07775424422168487, 0.08828539941004765, 0.07882178661878081, 0.06733102409516745, 0.0778218038766767, 0.13097105842592793, 0.13401139662423833, 0.23129274169541214, 0.14622296933386947, 0.15594827143074108, 0.15665670963490774, 0.15614185076159515, 0.15442169001893857, 0.14998085140690653, 0.20224416972422532, 0.2201542700614758, 0.22384909288967414, 0.20883535167751466, 0.19928145237153383, 0.20452932692898507, 0.2160507373752243, 0.24126046773825205, 0.22644731761574044, 0.14715479918303176, 0.15455094410850856, 0.1625567469651389, 0.1417491969012915, 0.15018974160449838, 0.15222922280673878, 0.15701601924686492, 0.15657990682927614, 0.17306719458067876, 0.18682707153828593, 0.18183574031775152, 0.1807793447254682, 0.17443724900011093, 0.17613432147033958, 0.17684030346840607, 0.15915206094432344, 0.1801567364036113, 0.18614462339030302, 0.16777048074936063, 0.17282330210652508, 0.16514674053567102, 0.15719368156744584, 0.164715022060001, 0.16868453482129897, 0.16221958364455236, 0.1621652290812744, 0.16144577925288472, 0.15827530232263487, 0.16712645615586097, 0.3459349795962193, 0.19968330686111202, 0.19466286646989805, 0.14603278133198327, 0.14611399297975147, 0.20409322827616416, 0.18622673992709393, 0.21069919997297204, 0.2751674431269293, 0.2506901525562497, 0.21585211623077705, 0.1782682568003071, 0.18076030443508384, 0.19232507001248877, 0.19495197282120524, 0.25245655954661483, 0.18370763469588025, 0.18331936208970656, 0.18326388870830235, 0.17602738598475642, 0.1732645233748633, 0.19916933779209134, 0.19913462337353272, 0.1807468403256658, 0.17943209927311377, 0.06995534495330846, 0.08582678492122486, 0.06476096030301759, 0.06160122296069115, 0.05451864288579167, 0.0714078837536517, 0.06725511700944353, 0.06640115776166244, 0.06041775600984023]}, "mutation_prompt": null}
{"id": "e92ceebe-4370-4207-83f4-6471ad62327f", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim  # Change: Adaptive crossover probability\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        mutant = a + self.diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        step_size = (self.upper_bound - self.lower_bound) * 0.1\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                self.diff_weight = 0.5 + (self.budget - self.current_budget) / self.budget * 0.5  # Change: Adaptive differential weight\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.current_budget >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Introduced adaptive differential weight adjustment based on convergence rate to enhance exploration-exploitation balance.", "configspace": "", "generation": 21, "fitness": 0.15125413140544663, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.17.", "error": "", "parent_id": "738021ab-7dec-4578-838a-8c9754ac67f0", "metadata": {"aucs": [0.25970537345432054, 0.2645791915212844, 0.23332280388943383, 0.30738081694329866, 0.31050692793151535, 0.2964735233101524, 0.30792745140482025, 0.3168293518621442, 0.2901776830017446, 0.042153428986403174, 0.0458625438060255, 0.062184191098529684, 0.03846852096387998, 0.04439844300314577, 0.0374875630211422, 0.034479543877225516, 0.04320365040924956, 0.07149887465889337, 0.06671091240886706, 0.06305266645878915, 0.06553185591060595, 0.0642545394194114, 0.0689708754203282, 0.06476548239858626, 0.06349495338809064, 0.0732135160761147, 0.060516903695300384, 0.04488848210095597, 0.059448324432975985, 0.057183680014165295, 0.05615710898498383, 0.05454310663211581, 0.05998656776698641, 0.06005539248060088, 0.04728426010717468, 0.05838188171477121, 0.9000819970411185, 0.9670085032880555, 0.8969272176346414, 0.9585234132260589, 0.7373604600905126, 0.8972073607970246, 0.913914291741476, 0.858210110671115, 0.8292719151979986, 0.12086685276464337, 0.11844025993763063, 0.12863524634320145, 0.1142715697914296, 0.1262043391812776, 0.11025106484596403, 0.13700530438148284, 0.12842241395561682, 0.15636314366818183, 0.18137186910451553, 0.16896691124296426, 0.1752276577822407, 0.19721262982978272, 0.205395052915611, 0.18172982228107804, 0.18280019904135592, 0.19054959865838939, 0.2059037014755779, 0.04279148255310661, 0.051705995845828356, 0.0805874220682703, 0.07557633167848776, 0.053552260853578115, 0.058756156842626694, 0.05165524033062607, 0.05534209575315274, 0.04971736638528923, 0.0982964614181503, 0.10185545652803918, 0.07795189238931777, 0.04639242663927923, 0.03938310166543124, 0.07642248735111334, 0.061264915568691514, 0.06155868541631804, 0.0682818237001599, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011430856538229284, 0.008538557237728117, 0.016713458392809688, 0.00195664225580916, 0.010994591284511968, 9.999999999998899e-05, 0.0029468876256057985, 0.09063011089185802, 0.09452520420807575, 0.09072163936760302, 0.06928436467393606, 0.09001572241431222, 0.10910477762461956, 0.08338422366993636, 0.06954171680759069, 0.10832482014430644, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03553960664548883, 0.036116692338534095, 0.03662984121631796, 0.033932338595583644, 0.032508900285387776, 0.03918682924119332, 0.05443870136893891, 0.05306887560141038, 0.04785220357010744, 0.26987473509542625, 0.27791857691752353, 0.2829117740374776, 0.2671058873461075, 0.28539926752991984, 0.28507266608777704, 0.26074389462437053, 0.2664941152527083, 0.26448963162059613, 0.07558569859331399, 0.0800819858144205, 0.06839211647742671, 0.062033488553946525, 0.06832908777410507, 0.0670741465446143, 0.05922959241585468, 0.05980695980468842, 0.06189255556501905, 0.1286901097620946, 0.1391761983904375, 0.18731807306723336, 0.13588575435099826, 0.1446032987540422, 0.12591877045141286, 0.12430131379160325, 0.17240362215588834, 0.12998639187697048, 0.19046065529693024, 0.19070897551603339, 0.19280462221812678, 0.19193546058767275, 0.17943500552370917, 0.17572165449227672, 0.20012413716905586, 0.2044759184842867, 0.18127148893438505, 0.12975606350506586, 0.13029153184757647, 0.133785131778823, 0.1349501179299898, 0.1365381802332537, 0.12887511751123382, 0.1395585118203122, 0.11900344324564172, 0.13793274661638788, 0.17850295363466118, 0.14865538487138075, 0.1637845636138323, 0.1622306137677113, 0.17124549922817534, 0.1536889343493142, 0.19921066286322253, 0.1600184601639798, 0.16907588155788855, 0.15907727239171832, 0.15221052915936129, 0.1568094477488643, 0.13224865159528254, 0.15440183927865037, 0.15656468824526104, 0.15299620589446383, 0.12564830739092958, 0.15982934617133016, 0.14426909688887313, 0.27705162948777606, 0.26307420139524984, 0.14103744727815537, 0.1721650720571899, 0.16254974297685965, 0.15469880069360353, 0.1461175812066926, 0.1666438965498317, 0.16187620307397088, 0.15188666807398365, 0.16332454504924376, 0.1418370855608706, 0.15240037072827128, 0.15111375199391874, 0.1913448449515961, 0.20029301987843062, 0.25933858096262097, 0.1728057655468037, 0.16998860137429583, 0.1744074926533027, 0.1787333312467415, 0.16861530048472118, 0.18302936900459854, 0.17724085656055288, 0.17349007668470928, 0.1786535495803777, 0.056450898623291335, 0.05958682443332941, 0.050852716061375425, 0.06303437345207819, 0.07095816079925021, 0.06010924364497494, 0.07043811606748118, 0.05374598602254643, 0.05058677169020087]}, "mutation_prompt": null}
{"id": "3d7896c2-1532-4899-9909-4fb5f5bfc864", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim  # Change: Adaptive crossover probability\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        # Change: Adaptive differential weight\n        progress_ratio = self.current_budget / self.budget\n        adaptive_diff_weight = self.diff_weight * (1 - progress_ratio)\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        step_size = (self.upper_bound - self.lower_bound) * 0.1\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.current_budget >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Introducing adaptive differential weight scaling based on iteration progress to enhance convergence stability.", "configspace": "", "generation": 22, "fitness": 0.18805302037903637, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.17.", "error": "", "parent_id": "738021ab-7dec-4578-838a-8c9754ac67f0", "metadata": {"aucs": [0.3501431631376295, 0.38430097528971974, 0.4045969107113476, 0.43247538523891726, 0.4558527086703662, 0.39260721504199203, 0.4037091931513467, 0.40894847252225275, 0.48010604925504585, 0.11177201890993438, 0.12417550837012692, 0.13587453381795944, 0.11131249418194455, 0.12809661917849002, 0.15433257255302835, 0.13060567226724873, 0.1418896913174179, 0.15670636121344284, 0.08244036654717002, 0.07448731699638755, 0.07620190647450387, 0.06741421726803032, 0.07329218165423446, 0.07431660388567907, 0.08364884743051026, 0.08097651331399591, 0.08171912721283536, 0.07890738404829101, 0.062136826026006786, 0.07265646044724616, 0.07430104329972653, 0.06650330311991925, 0.06918305810006009, 0.059136527824881546, 0.07286844788207203, 0.07308462798399729, 0.8832509935494794, 0.9053610266529524, 0.8419954006340487, 0.8596940498427066, 0.8145920575783292, 0.8986244524588864, 0.776244654820352, 0.918836000737687, 0.7800150979247543, 0.17066264690558652, 0.21373084869413517, 0.17777795169166888, 0.17725793079636587, 0.1637290084029963, 0.19565383192622043, 0.18317165718056927, 0.1930879832650959, 0.2195841784975514, 0.23808700522019288, 0.23946473346203934, 0.25924170690042014, 0.24494057775795897, 0.34879491433544363, 0.32434759533142843, 0.2824406372828838, 0.36064411044213995, 0.2788759549054476, 0.10472468650018785, 0.15080454158794887, 0.12796426535831484, 0.0890854398224421, 0.1163221773900992, 0.09822449965330493, 0.0956485628098086, 0.13029394977778974, 0.09934022654205255, 0.11004812030212374, 0.10330272449570599, 0.10301241484969126, 0.08925857532138348, 0.10779370453594417, 0.11459257838250292, 0.07418634351568165, 0.09707619351962982, 0.10443641128589676, 0.05162754564376515, 0.03236184714085033, 0.06516698683310018, 0.04035420149976876, 0.05228148446414138, 0.07042164019305841, 0.04071913581170139, 0.05334393431074147, 0.04451650520889672, 0.14021490414747118, 0.16085778802691186, 0.19785288177192495, 0.16196261650035015, 0.13930711918373795, 0.17001345703414905, 0.12747208151787293, 0.17006733190172418, 0.19744190586028254, 0.006119565268192462, 0.0006087484859920167, 0.005772727651662701, 0.0009299808938669774, 0.003006760710566825, 0.00701658504266911, 0.0041288567755742855, 0.002058944070983504, 0.0006770491503677034, 0.08479628493921187, 0.0883739871822441, 0.08983264007698222, 0.07492665694417266, 0.09948468641602937, 0.0834989359084739, 0.07577014785729264, 0.09723783606085212, 0.08836882213726927, 0.3383652807504368, 0.354628993492197, 0.37377166228878345, 0.3583959567606767, 0.36859272362659756, 0.387859191470992, 0.35328346036271485, 0.3852305561708639, 0.3647411084696752, 0.0894682173731588, 0.07653085609108201, 0.09139159261743279, 0.07725432919292086, 0.07956275682341452, 0.07759828280277214, 0.07609637414441062, 0.07056772471549988, 0.0717613054529318, 0.13308573767878273, 0.13105759102905723, 0.12166461710176046, 0.12489348381906673, 0.1491771139409127, 0.17860310336534202, 0.13164982321855168, 0.15024522712951927, 0.12150086134650062, 0.22681095036520993, 0.22030189830040126, 0.2500740946107848, 0.21062253475219617, 0.22584528015648986, 0.21702081520263805, 0.22924292103204436, 0.23585179516937915, 0.24373239880311226, 0.14825723547048963, 0.17241436716386616, 0.18240994431820556, 0.14494288492181662, 0.16009215425705448, 0.17206402886109862, 0.17552916195296242, 0.1695498176138639, 0.16686671191269375, 0.16450707829929834, 0.1760840287496389, 0.1674037981238775, 0.1892502353086305, 0.15771090205923732, 0.18699568350321905, 0.18785977184756042, 0.16849947138345378, 0.18191441389298357, 0.17437682244125585, 0.1562814092085868, 0.15848419823529913, 0.1595801489171934, 0.1673916601493891, 0.17304853421135735, 0.165078648496912, 0.16449437229844766, 0.1614525572067993, 0.16659352082869938, 0.16852660075175896, 0.49071698351731985, 0.21892893962318594, 0.22548885112105566, 0.17494040661252042, 0.20078978772511746, 0.16595236046083972, 0.16333282979163855, 0.17315127235252492, 0.18650933082968013, 0.18434628937870756, 0.20473461214808453, 0.19171198927384647, 0.17989236211221482, 0.19066448098340294, 0.19754607938811253, 0.19123381872821155, 0.171223051920957, 0.18921963482249038, 0.1768841724612379, 0.18079642532737905, 0.19645885474803548, 0.19609197088277996, 0.1760819174037933, 0.1748860974019133, 0.1885014139760819, 0.059702922977269535, 0.06591437933939526, 0.07649639658133878, 0.06182482878875617, 0.06346116702770965, 0.07836617906480403, 0.07855139741155248, 0.06753250810890699, 0.06778259775257522]}, "mutation_prompt": null}
{"id": "28291760-9529-4718-985f-42501f80e678", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim  # Change: Adaptive crossover probability\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        # Change: Adaptive differential weight\n        progress_ratio = self.current_budget / self.budget\n        adaptive_diff_weight = self.diff_weight * (1 - progress_ratio)\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        step_size = (self.upper_bound - self.lower_bound) * 0.1\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.current_budget >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Introducing adaptive differential weight scaling based on iteration progress to enhance convergence stability.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3d7896c2-1532-4899-9909-4fb5f5bfc864", "metadata": {"aucs": [0.3501431631376295, 0.38430097528971974, 0.4045969107113476, 0.43247538523891726, 0.4558527086703662, 0.39260721504199203, 0.4037091931513467, 0.40894847252225275, 0.48010604925504585, 0.11177201890993438, 0.12417550837012692, 0.13587453381795944, 0.11131249418194455, 0.12809661917849002, 0.15433257255302835, 0.13060567226724873, 0.1418896913174179, 0.15670636121344284, 0.08244036654717002, 0.07448731699638755, 0.07620190647450387, 0.06741421726803032, 0.07329218165423446, 0.07431660388567907, 0.08364884743051026, 0.08097651331399591, 0.08171912721283536, 0.07890738404829101, 0.062136826026006786, 0.07265646044724616, 0.07430104329972653, 0.06650330311991925, 0.06918305810006009, 0.059136527824881546, 0.07286844788207203, 0.07308462798399729, 0.8832509935494794, 0.9053610266529524, 0.8419954006340487, 0.8596940498427066, 0.8145920575783292, 0.8986244524588864, 0.776244654820352, 0.918836000737687, 0.7800150979247543, 0.17066264690558652, 0.21373084869413517, 0.17777795169166888, 0.17725793079636587, 0.1637290084029963, 0.19565383192622043, 0.18317165718056927, 0.1930879832650959, 0.2195841784975514, 0.23808700522019288, 0.23946473346203934, 0.25924170690042014, 0.24494057775795897, 0.34879491433544363, 0.32434759533142843, 0.2824406372828838, 0.36064411044213995, 0.2788759549054476, 0.10472468650018785, 0.15080454158794887, 0.12796426535831484, 0.0890854398224421, 0.1163221773900992, 0.09822449965330493, 0.0956485628098086, 0.13029394977778974, 0.09934022654205255, 0.11004812030212374, 0.10330272449570599, 0.10301241484969126, 0.08925857532138348, 0.10779370453594417, 0.11459257838250292, 0.07418634351568165, 0.09707619351962982, 0.10443641128589676, 0.05162754564376515, 0.03236184714085033, 0.06516698683310018, 0.04035420149976876, 0.05228148446414138, 0.07042164019305841, 0.04071913581170139, 0.05334393431074147, 0.04451650520889672, 0.14021490414747118, 0.16085778802691186, 0.19785288177192495, 0.16196261650035015, 0.13930711918373795, 0.17001345703414905, 0.12747208151787293, 0.17006733190172418, 0.19744190586028254, 0.006119565268192462, 0.0006087484859920167, 0.005772727651662701, 0.0009299808938669774, 0.003006760710566825, 0.00701658504266911, 0.0041288567755742855, 0.002058944070983504, 0.0006770491503677034, 0.08479628493921187, 0.0883739871822441, 0.08983264007698222, 0.07492665694417266, 0.09948468641602937, 0.0834989359084739, 0.07577014785729264, 0.09723783606085212, 0.08836882213726927, 0.3383652807504368, 0.354628993492197, 0.37377166228878345, 0.3583959567606767, 0.36859272362659756, 0.387859191470992, 0.35328346036271485, 0.3852305561708639, 0.3647411084696752, 0.0894682173731588, 0.07653085609108201, 0.09139159261743279, 0.07725432919292086, 0.07956275682341452, 0.07759828280277214, 0.07609637414441062, 0.07056772471549988, 0.0717613054529318, 0.13308573767878273, 0.13105759102905723, 0.12166461710176046, 0.12489348381906673, 0.1491771139409127, 0.17860310336534202, 0.13164982321855168, 0.15024522712951927, 0.12150086134650062, 0.22681095036520993, 0.22030189830040126, 0.2500740946107848, 0.21062253475219617, 0.22584528015648986, 0.21702081520263805, 0.22924292103204436, 0.23585179516937915, 0.24373239880311226, 0.14825723547048963, 0.17241436716386616, 0.18240994431820556, 0.14494288492181662, 0.16009215425705448, 0.17206402886109862, 0.17552916195296242, 0.1695498176138639, 0.16686671191269375, 0.16450707829929834, 0.1760840287496389, 0.1674037981238775, 0.1892502353086305, 0.15771090205923732, 0.18699568350321905, 0.18785977184756042, 0.16849947138345378, 0.18191441389298357, 0.17437682244125585, 0.1562814092085868, 0.15848419823529913, 0.1595801489171934, 0.1673916601493891, 0.17304853421135735, 0.165078648496912, 0.16449437229844766, 0.1614525572067993, 0.16659352082869938, 0.16852660075175896, 0.49071698351731985, 0.21892893962318594, 0.22548885112105566, 0.17494040661252042, 0.20078978772511746, 0.16595236046083972, 0.16333282979163855, 0.17315127235252492, 0.18650933082968013, 0.18434628937870756, 0.20473461214808453, 0.19171198927384647, 0.17989236211221482, 0.19066448098340294, 0.19754607938811253, 0.19123381872821155, 0.171223051920957, 0.18921963482249038, 0.1768841724612379, 0.18079642532737905, 0.19645885474803548, 0.19609197088277996, 0.1760819174037933, 0.1748860974019133, 0.1885014139760819, 0.059702922977269535, 0.06591437933939526, 0.07649639658133878, 0.06182482878875617, 0.06346116702770965, 0.07836617906480403, 0.07855139741155248, 0.06753250810890699, 0.06778259775257522]}, "mutation_prompt": null}
{"id": "02d9108e-754c-445e-b8e2-2a3326c555c6", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim  # Change: Adaptive crossover probability\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        # Change: Adaptive differential weight\n        progress_ratio = self.current_budget / self.budget\n        adaptive_diff_weight = self.diff_weight * (1 - progress_ratio)\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - self.current_budget / self.budget))  # Change: Adaptive step size\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.current_budget >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Incorporate an adaptive step size based on the convergence rate to refine search exploration and exploitation balance.", "configspace": "", "generation": 24, "fitness": 0.1900993414845527, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.17.", "error": "", "parent_id": "3d7896c2-1532-4899-9909-4fb5f5bfc864", "metadata": {"aucs": [0.40577431916924955, 0.4100101233878689, 0.4016882139125906, 0.4363280656573938, 0.4191818658086822, 0.40697727725764, 0.4131294962201677, 0.41217376938929395, 0.451199695054634, 0.11660686567641698, 0.1532770904650761, 0.15114932900208955, 0.12174848877365074, 0.12184268107739649, 0.1396059304510756, 0.1400635724794752, 0.14390880174129794, 0.12132160151585325, 0.07487769826062662, 0.08147432377625319, 0.08267915751999921, 0.0766871668852962, 0.08361432508501798, 0.07777430085701287, 0.10108990001517815, 0.06721363821196757, 0.0745816481281878, 0.073514365344991, 0.08059858338333492, 0.07547944776249205, 0.060572320008010494, 0.06442843527920228, 0.07534359026439819, 0.06914695232610502, 0.07455265660462695, 0.06775400808724974, 0.8358835909500333, 0.9053736690455798, 0.9275023017868779, 0.8805768284732467, 0.8449004233498726, 0.9185842741203486, 0.8510455088781025, 0.8824777981540427, 0.8619404241459729, 0.16971964720439625, 0.17774886274955426, 0.1681552043600636, 0.19691650002910077, 0.17227608883392098, 0.17995439293376836, 0.18023665745627382, 0.17730707384107713, 0.18813249307449242, 0.23991438576369195, 0.2552529592808922, 0.30235773057365234, 0.24534415448365132, 0.25987437257635726, 0.31929699611826523, 0.30586826536866396, 0.28917890173392, 0.3423843609634547, 0.1010538108272584, 0.10913296907438852, 0.10839664429567253, 0.09844451732202875, 0.11091817940963977, 0.12084449255281837, 0.11382204866218859, 0.10313781925872212, 0.10640528145542627, 0.12536484420839278, 0.09095464656637797, 0.09194004417113955, 0.09903445317037962, 0.10038429972106189, 0.11286870514556491, 0.09754300118838166, 0.09843667352653429, 0.1096308945700113, 0.024942345987589376, 0.052028083583364415, 0.03902167271673529, 0.0455480377559534, 0.05337785177176302, 0.052299445530090805, 0.045158364327906875, 0.04612128756167022, 0.055356986249754825, 0.15573441601051163, 0.14810929488689129, 0.15780890415064586, 0.1505072919917262, 0.15369226105986322, 0.12221173511684125, 0.16266265697093785, 0.15286080128118706, 0.18408761533869633, 0.00043124875610900393, 0.00035776920265429, 0.0007162007458065833, 0.00036999080401312057, 0.0062831341556433, 0.0015273961849238127, 0.0042319778966657395, 0.0025720596598372003, 0.00407896218250503, 0.07957833686927529, 0.09659841748895848, 0.09900355992933307, 0.08100093902278205, 0.08465404281684608, 0.10555288902261506, 0.07531601340571181, 0.0943487371202335, 0.08442909536096688, 0.33324016846073834, 0.355413930543357, 0.3682174122510655, 0.35815969516916313, 0.36831656342434815, 0.3872773722347198, 0.33678163965897534, 0.37409639922492777, 0.37423021182090577, 0.08107459431274255, 0.07508434143177489, 0.06763848711328846, 0.07287583165180678, 0.08403916160107616, 0.08682893212712095, 0.0661928104443903, 0.06851116504918298, 0.07403240888304286, 0.1327356775892896, 0.12732741578195206, 0.14969131851923956, 0.13856072210939308, 0.1492863881000085, 0.1522880564849114, 0.12446297573191445, 0.13964822045899505, 0.1276744801225128, 0.2210443396061199, 0.2453500903683402, 0.2418418011045267, 0.20529396407385603, 0.23360006040086934, 0.24022435621172133, 0.23907909668752558, 0.24095107513201397, 0.234885443723304, 0.16225547972560195, 0.17317292561129194, 0.18457464691942738, 0.15360226050441284, 0.16543529054789363, 0.16550113741492134, 0.16338366428825335, 0.18392386538431427, 0.1638577986810842, 0.17457810432724363, 0.19991152236586818, 0.17288976959429037, 0.17385507117596732, 0.17586023608769197, 0.1894004074979675, 0.16404122506918462, 0.2005172491220757, 0.20134895824790555, 0.18027637458512913, 0.1686179605205934, 0.16282337135779656, 0.18094875777362363, 0.16398106175806348, 0.16269744788828666, 0.16874777794622042, 0.16056670566587505, 0.1669143849542919, 0.18848882293769242, 0.1551244330555973, 0.2940734747178083, 0.17698499108055765, 0.2856318883964821, 0.18071137831345752, 0.15428123831003326, 0.14453819186067796, 0.28677874993492003, 0.17505401237379514, 0.18476845072817716, 0.17952047653627, 0.18640241469022045, 0.23739812702458607, 0.18154661317989473, 0.1768903686729527, 0.4484780295986548, 0.3021110740950257, 0.1843942729319754, 0.17456795856237572, 0.1862226422798815, 0.18203485793927743, 0.1863130519311157, 0.18753970992956948, 0.20082508833959944, 0.17874261828837956, 0.16764631657692075, 0.058156614172997445, 0.06539805918304842, 0.06804401550829531, 0.0629674434070383, 0.06506465452130983, 0.06581141282093017, 0.07161302341854658, 0.0639148659295784, 0.06731163765928427]}, "mutation_prompt": null}
{"id": "ea2a4f05-f141-4bd2-90b4-4ac8ecdce661", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim  # Change: Adaptive crossover probability\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        # Change: Adaptive differential weight\n        diversity = np.std(population, axis=0).mean()\n        adaptive_diff_weight = self.diff_weight * (1 + 0.5 * diversity)  # Adjusting with diversity\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - self.current_budget / self.budget))  # Change: Adaptive step size\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.current_budget >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Integrate an adaptive mutation strategy by dynamically adjusting the differential weight based on population diversity.", "configspace": "", "generation": 25, "fitness": 0.12607648002819355, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.18.", "error": "", "parent_id": "02d9108e-754c-445e-b8e2-2a3326c555c6", "metadata": {"aucs": [0.17166359918707552, 0.21247165750609398, 0.18316344147547547, 0.2852991601916749, 0.31838416247667534, 0.30288022566727546, 0.2693908194260457, 0.2840512214987775, 0.24635925416531912, 9.999999999998899e-05, 0.00590308959844954, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04320910040806325, 0.04422598910083364, 0.05069711187439074, 0.04883106881785226, 0.0457170388895205, 0.05040789828763281, 0.045423041654361396, 0.060998929225294374, 0.0567469325564236, 0.028226324574275763, 0.03226093895946902, 0.020841498461350083, 0.030034762898723977, 0.03561600581174884, 0.04276874138672393, 0.03484707661973896, 0.026865101883550957, 0.03565248086481354, 0.931516506082986, 0.9667091015793366, 0.9273412205529723, 0.9520556851891586, 0.8675819838826035, 0.9489838925120857, 0.9349178135202636, 0.9349575980612482, 0.9462710610311809, 0.10324788138261154, 0.11200710263377656, 0.08326620420434572, 0.09807055148606392, 0.08181798756049596, 0.08866563331836586, 0.11763492436282597, 0.09697541574070312, 0.09705927758623001, 0.11898668657686717, 0.07760933616363597, 0.09386458318203805, 0.12278322288765431, 0.10699062313727559, 0.15187389082196856, 0.11372644247543462, 0.11879954574585194, 0.14891102008988577, 9.999999999998899e-05, 0.0077082439724383, 0.01651636217281305, 0.035901425967514666, 0.015353636570592077, 0.05382206976935755, 0.010536816499452262, 0.03304967620210686, 0.023727467433303895, 0.04535200377393811, 0.07609826149445653, 0.08212794696899106, 0.0024346891113822267, 0.01367989621342991, 0.009774078612259096, 0.006056098228256479, 0.012273374199743503, 0.005688346900716179, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0267207396580188, 0.03819885411321533, 0.03130094121392213, 0.06708388655054076, 0.04687299410687862, 0.06014409347369687, 0.013828022380171223, 0.03523572121803553, 0.0316874633159725, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016368245039851126, 0.018421348627379652, 0.017603530547158353, 0.011046416474986609, 0.023424689292493195, 0.025498310275950842, 0.012107143965659484, 0.032933190944951285, 0.027001583766590342, 0.1769143101652697, 0.1879253951456522, 0.20845872013395694, 0.24226619735878008, 0.25061553387995117, 0.22373223274574605, 0.19781859948641844, 0.21828172311371308, 0.22738910422697833, 0.054961191807845866, 0.06810903224881715, 0.06522410007295854, 0.03878699875032743, 0.050721593178985724, 0.044321487095487444, 0.040444103841034695, 0.03867337933563553, 0.038174754630523555, 0.1388663955562166, 0.141175346429948, 0.13224817343803774, 0.12188937112610765, 0.1481865361382243, 0.14774420934325916, 0.16798230636166522, 0.1425094083419306, 0.15611047421663715, 0.14901236751751878, 0.1480960631399123, 0.13907093732964715, 0.15731131682414323, 0.16210087815287866, 0.14335413926281815, 0.1676076975153028, 0.1584023077703245, 0.16325398845421601, 0.09973434887727384, 0.09517950432864908, 0.08734005762575325, 0.10423983620784005, 0.1000875205772771, 0.10529510426335398, 0.10430067724181935, 0.1300831813279434, 0.11701016532723296, 0.14330437193482526, 0.15594220427378425, 0.15544102679629546, 0.1500025328358443, 0.15100112744227479, 0.1437444596358517, 0.1634208642955135, 0.14050338325091705, 0.17104599515791796, 0.13868038047638453, 0.12415604139301828, 0.08044414743456785, 0.08139888725855471, 0.06473074121990197, 0.1151546470089132, 0.10514694609916353, 0.09087668729172216, 0.11552272731069857, 0.14158035503054256, 0.14513219485984352, 0.1546470256475897, 0.1663281949926011, 0.1689923410977624, 0.14695758767831468, 0.12447895667944353, 0.1154898339000916, 0.14547800916838005, 0.14328578909915302, 0.15708862006686286, 0.1593319546168579, 0.09106951678964703, 0.08108307475944199, 0.10061940832597027, 0.19171637286489074, 0.1774011163603587, 0.19649202672862776, 0.1722104077163562, 0.18861425616718985, 0.1763180306584392, 0.1745964747398291, 0.16734131690671494, 0.18676382100762512, 0.17802753584158926, 0.17947786064546922, 0.1862491171972087, 0.03910161345040175, 0.04756462652329063, 0.040954794716799525, 0.04339703939401973, 0.038706309351418944, 0.036502355734441494, 0.057303757127379895, 0.043720227284109736, 0.03313038763926457]}, "mutation_prompt": null}
{"id": "fbc465b1-3d85-43fd-b144-11432b19d62a", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim  # Change: Adaptive crossover probability with stochastic variance\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        # Change: Adaptive differential weight\n        progress_ratio = self.current_budget / self.budget\n        adaptive_diff_weight = self.diff_weight * (1 - progress_ratio)\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        # Introduced stochastic variance\n        cross_prob_variance = self.cross_prob * np.random.uniform(0.95, 1.05)\n        crossover_mask = np.random.rand(self.dim) < cross_prob_variance\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - self.current_budget / self.budget))  # Change: Adaptive step size\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.current_budget >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Enhance exploration by introducing stochastic variance in adaptive crossover probability to maintain diversity.", "configspace": "", "generation": 26, "fitness": 0.1863794846587629, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.17.", "error": "", "parent_id": "02d9108e-754c-445e-b8e2-2a3326c555c6", "metadata": {"aucs": [0.38476933303349925, 0.3907718979760991, 0.4104786943755633, 0.40059696746006934, 0.40574263042599723, 0.41565515618660276, 0.3969979506781849, 0.4195060463989154, 0.42505735929299293, 0.11420347427572597, 0.15133192210950708, 0.12727456465853115, 0.13797012009449683, 0.13600131620465195, 0.1368443271837041, 0.11690758459343431, 0.13613930649643646, 0.13920395133214847, 0.07209625589422464, 0.08182705742571594, 0.07644847973477731, 0.075984539381454, 0.0807239105908546, 0.07970174972812438, 0.07692543473074598, 0.08761093284137356, 0.07761710379518283, 0.05969154128816556, 0.06424535143353327, 0.07146672473270665, 0.06376045867225999, 0.06210826503702904, 0.07864387577653398, 0.06835793785434985, 0.08643087899068691, 0.06951337080652975, 0.8092946561050769, 0.8754968413596289, 0.8292749524340665, 0.8776299732450583, 0.9013961467226169, 0.8385550841648801, 0.8927397356840034, 0.9434530044364562, 0.8707020874024385, 0.1733708672889288, 0.18165525501192625, 0.19141027474689642, 0.17994034486624388, 0.15210669669258892, 0.15786861243798012, 0.1675238676779256, 0.19571883701235981, 0.19015865056765835, 0.21791458434068123, 0.23649447524362388, 0.28396889631908684, 0.2788146276109317, 0.2614363612681484, 0.2981221447808202, 0.23513059506383527, 0.25973795312772474, 0.3039360557078655, 0.09502622792872084, 0.11332484822399636, 0.09390512627151437, 0.1159942447896839, 0.10267983049994345, 0.10642690031093005, 0.10471368818095583, 0.11358476246252269, 0.10917567325791933, 0.1531493983909875, 0.1034725876916458, 0.0925015535225715, 0.09573705112181741, 0.11313609781349954, 0.12277681395501117, 0.08869468462341834, 0.10700759396922899, 0.0838611524384083, 0.0428212766274646, 0.05907886265968898, 0.037337299085326014, 0.027935267379956885, 0.04611185553694652, 0.06595918205053897, 0.04099627164061237, 0.05740883419099885, 0.04004543340483013, 0.1482662887004086, 0.16873820085704738, 0.15822245319401196, 0.116893629054735, 0.12708280395513338, 0.15320121133486952, 0.14770688229423812, 0.1721029832956652, 0.1985852321559367, 0.00010869365272370146, 0.0033056955527305254, 0.0035184748219401207, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.001082222486428308, 0.0031974987333757143, 0.0036165390094509142, 0.07432269281118664, 0.08916295761810566, 0.09378325588785086, 0.06837121326795337, 0.07805204574592772, 0.08433267551394952, 0.07987814091808487, 0.09386128580378095, 0.08414389297170632, 0.3450026495298666, 0.3672431226095102, 0.3389184690410231, 0.35367408226663744, 0.3720648663699885, 0.36006203153070127, 0.33633806650023945, 0.37130535502353035, 0.38414307389704905, 0.0840305116590192, 0.08467886517247425, 0.083540335979719, 0.08009056118880598, 0.07879304034428314, 0.08114332424301207, 0.07235897858757401, 0.0860772994408533, 0.07013083800183317, 0.14153806530276347, 0.12443947774203445, 0.15314334890933656, 0.115712560623345, 0.15639904395456927, 0.12877109148451416, 0.1339641758587049, 0.12698992627080752, 0.1404385970727644, 0.22358955289198512, 0.23979793038920494, 0.22436939483469776, 0.22715707115607897, 0.2181356329453974, 0.21956670317489657, 0.24133993738581316, 0.24924104538120873, 0.23427732523372935, 0.15154553863007691, 0.1694561583580766, 0.18235779958755216, 0.1538615150695537, 0.17677631270821526, 0.1565407076273967, 0.17183774033020605, 0.189764250455996, 0.1661823762293545, 0.17303379069677471, 0.17506750644925773, 0.1849005338315609, 0.1713117861797402, 0.1766878527767678, 0.18721313892707592, 0.18262675061459188, 0.18177450704627618, 0.20042278785113643, 0.17818734993276208, 0.17123835751843453, 0.15441298377268609, 0.15915762442353898, 0.1700144399440363, 0.16766266458419088, 0.16620186059396602, 0.16200970047813412, 0.17047337184555655, 0.21767394351334002, 0.2282197308125582, 0.179654056389833, 0.1596386504872198, 0.16672120354642062, 0.19874709998611673, 0.16334295850157776, 0.25058368897481764, 0.1592327979232152, 0.2545512596868996, 0.19347388057763293, 0.1773647975621423, 0.16902572149398254, 0.18996756569156392, 0.15296257071656438, 0.20296847023732112, 0.1994288164409993, 0.35757763304969203, 0.1918097021986358, 0.17816167903280333, 0.1932778850298279, 0.18435060203038645, 0.17181959454047369, 0.18046090498822764, 0.18070372708896176, 0.1807395226577584, 0.18911594462988723, 0.06021239783551502, 0.07106679441205122, 0.07530312757801072, 0.061746715610189185, 0.05682999927054222, 0.06375646559866288, 0.07431700251450146, 0.07952481850930582, 0.07729365823761813]}, "mutation_prompt": null}
{"id": "c3fdf19b-d2f6-4474-a9cc-31d13f35d2b8", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim  # Change: Adaptive crossover probability\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        # Change: Adaptive differential weight\n        progress_ratio = self.current_budget / self.budget\n        adaptive_diff_weight = self.diff_weight * (1 - progress_ratio)\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        population_std = np.std(population, axis=0)  # New: Calculate population diversity\n        adaptive_cross_prob = self.cross_prob * (1 + population_std.mean())  # New: Adjust crossover probability\n        crossover_mask = np.random.rand(self.dim) < adaptive_cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - self.current_budget / self.budget))  # Change: Adaptive step size\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.current_budget >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Introduce self-adjusting crossover probability based on population diversity to improve exploration and exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'population' is not defined\").", "error": "NameError(\"name 'population' is not defined\")", "parent_id": "02d9108e-754c-445e-b8e2-2a3326c555c6", "metadata": {}, "mutation_prompt": null}
{"id": "40dab439-9f37-4674-8c80-61e7a323f0ab", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim  # Change: Adaptive crossover probability\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        # Change: Adaptive differential weight\n        progress_ratio = self.current_budget / self.budget\n        adaptive_diff_weight = self.diff_weight * (1 - progress_ratio)\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - self.current_budget / self.budget))  # Change: Adaptive step size\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.current_budget >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Incorporate an adaptive step size based on the convergence rate to refine search exploration and exploitation balance.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "02d9108e-754c-445e-b8e2-2a3326c555c6", "metadata": {"aucs": [0.40577431916924955, 0.4100101233878689, 0.4016882139125906, 0.4363280656573938, 0.4191818658086822, 0.40697727725764, 0.4131294962201677, 0.41217376938929395, 0.451199695054634, 0.11660686567641698, 0.1532770904650761, 0.15114932900208955, 0.12174848877365074, 0.12184268107739649, 0.1396059304510756, 0.1400635724794752, 0.14390880174129794, 0.12132160151585325, 0.07487769826062662, 0.08147432377625319, 0.08267915751999921, 0.0766871668852962, 0.08361432508501798, 0.07777430085701287, 0.10108990001517815, 0.06721363821196757, 0.0745816481281878, 0.073514365344991, 0.08059858338333492, 0.07547944776249205, 0.060572320008010494, 0.06442843527920228, 0.07534359026439819, 0.06914695232610502, 0.07455265660462695, 0.06775400808724974, 0.8358835909500333, 0.9053736690455798, 0.9275023017868779, 0.8805768284732467, 0.8449004233498726, 0.9185842741203486, 0.8510455088781025, 0.8824777981540427, 0.8619404241459729, 0.16971964720439625, 0.17774886274955426, 0.1681552043600636, 0.19691650002910077, 0.17227608883392098, 0.17995439293376836, 0.18023665745627382, 0.17730707384107713, 0.18813249307449242, 0.23991438576369195, 0.2552529592808922, 0.30235773057365234, 0.24534415448365132, 0.25987437257635726, 0.31929699611826523, 0.30586826536866396, 0.28917890173392, 0.3423843609634547, 0.1010538108272584, 0.10913296907438852, 0.10839664429567253, 0.09844451732202875, 0.11091817940963977, 0.12084449255281837, 0.11382204866218859, 0.10313781925872212, 0.10640528145542627, 0.12536484420839278, 0.09095464656637797, 0.09194004417113955, 0.09903445317037962, 0.10038429972106189, 0.11286870514556491, 0.09754300118838166, 0.09843667352653429, 0.1096308945700113, 0.024942345987589376, 0.052028083583364415, 0.03902167271673529, 0.0455480377559534, 0.05337785177176302, 0.052299445530090805, 0.045158364327906875, 0.04612128756167022, 0.055356986249754825, 0.15573441601051163, 0.14810929488689129, 0.15780890415064586, 0.1505072919917262, 0.15369226105986322, 0.12221173511684125, 0.16266265697093785, 0.15286080128118706, 0.18408761533869633, 0.00043124875610900393, 0.00035776920265429, 0.0007162007458065833, 0.00036999080401312057, 0.0062831341556433, 0.0015273961849238127, 0.0042319778966657395, 0.0025720596598372003, 0.00407896218250503, 0.07957833686927529, 0.09659841748895848, 0.09900355992933307, 0.08100093902278205, 0.08465404281684608, 0.10555288902261506, 0.07531601340571181, 0.0943487371202335, 0.08442909536096688, 0.33324016846073834, 0.355413930543357, 0.3682174122510655, 0.35815969516916313, 0.36831656342434815, 0.3872773722347198, 0.33678163965897534, 0.37409639922492777, 0.37423021182090577, 0.08107459431274255, 0.07508434143177489, 0.06763848711328846, 0.07287583165180678, 0.08403916160107616, 0.08682893212712095, 0.0661928104443903, 0.06851116504918298, 0.07403240888304286, 0.1327356775892896, 0.12732741578195206, 0.14969131851923956, 0.13856072210939308, 0.1492863881000085, 0.1522880564849114, 0.12446297573191445, 0.13964822045899505, 0.1276744801225128, 0.2210443396061199, 0.2453500903683402, 0.2418418011045267, 0.20529396407385603, 0.23360006040086934, 0.24022435621172133, 0.23907909668752558, 0.24095107513201397, 0.234885443723304, 0.16225547972560195, 0.17317292561129194, 0.18457464691942738, 0.15360226050441284, 0.16543529054789363, 0.16550113741492134, 0.16338366428825335, 0.18392386538431427, 0.1638577986810842, 0.17457810432724363, 0.19991152236586818, 0.17288976959429037, 0.17385507117596732, 0.17586023608769197, 0.1894004074979675, 0.16404122506918462, 0.2005172491220757, 0.20134895824790555, 0.18027637458512913, 0.1686179605205934, 0.16282337135779656, 0.18094875777362363, 0.16398106175806348, 0.16269744788828666, 0.16874777794622042, 0.16056670566587505, 0.1669143849542919, 0.18848882293769242, 0.1551244330555973, 0.2940734747178083, 0.17698499108055765, 0.2856318883964821, 0.18071137831345752, 0.15428123831003326, 0.14453819186067796, 0.28677874993492003, 0.17505401237379514, 0.18476845072817716, 0.17952047653627, 0.18640241469022045, 0.23739812702458607, 0.18154661317989473, 0.1768903686729527, 0.4484780295986548, 0.3021110740950257, 0.1843942729319754, 0.17456795856237572, 0.1862226422798815, 0.18203485793927743, 0.1863130519311157, 0.18753970992956948, 0.20082508833959944, 0.17874261828837956, 0.16764631657692075, 0.058156614172997445, 0.06539805918304842, 0.06804401550829531, 0.0629674434070383, 0.06506465452130983, 0.06581141282093017, 0.07161302341854658, 0.0639148659295784, 0.06731163765928427]}, "mutation_prompt": null}
{"id": "8b4d22e6-08d3-4bee-85f0-7062fe503dd6", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim  # Change: Adaptive crossover probability\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        # Change: Adaptive differential weight\n        progress_ratio = self.current_budget / self.budget\n        adaptive_diff_weight = self.diff_weight * (1 - progress_ratio)\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - self.current_budget / self.budget))  # Change: Adaptive step size\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.current_budget >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Incorporate an adaptive step size based on the convergence rate to refine search exploration and exploitation balance.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "02d9108e-754c-445e-b8e2-2a3326c555c6", "metadata": {"aucs": [0.40577431916924955, 0.4100101233878689, 0.4016882139125906, 0.4363280656573938, 0.4191818658086822, 0.40697727725764, 0.4131294962201677, 0.41217376938929395, 0.451199695054634, 0.11660686567641698, 0.1532770904650761, 0.15114932900208955, 0.12174848877365074, 0.12184268107739649, 0.1396059304510756, 0.1400635724794752, 0.14390880174129794, 0.12132160151585325, 0.07487769826062662, 0.08147432377625319, 0.08267915751999921, 0.0766871668852962, 0.08361432508501798, 0.07777430085701287, 0.10108990001517815, 0.06721363821196757, 0.0745816481281878, 0.073514365344991, 0.08059858338333492, 0.07547944776249205, 0.060572320008010494, 0.06442843527920228, 0.07534359026439819, 0.06914695232610502, 0.07455265660462695, 0.06775400808724974, 0.8358835909500333, 0.9053736690455798, 0.9275023017868779, 0.8805768284732467, 0.8449004233498726, 0.9185842741203486, 0.8510455088781025, 0.8824777981540427, 0.8619404241459729, 0.16971964720439625, 0.17774886274955426, 0.1681552043600636, 0.19691650002910077, 0.17227608883392098, 0.17995439293376836, 0.18023665745627382, 0.17730707384107713, 0.18813249307449242, 0.23991438576369195, 0.2552529592808922, 0.30235773057365234, 0.24534415448365132, 0.25987437257635726, 0.31929699611826523, 0.30586826536866396, 0.28917890173392, 0.3423843609634547, 0.1010538108272584, 0.10913296907438852, 0.10839664429567253, 0.09844451732202875, 0.11091817940963977, 0.12084449255281837, 0.11382204866218859, 0.10313781925872212, 0.10640528145542627, 0.12536484420839278, 0.09095464656637797, 0.09194004417113955, 0.09903445317037962, 0.10038429972106189, 0.11286870514556491, 0.09754300118838166, 0.09843667352653429, 0.1096308945700113, 0.024942345987589376, 0.052028083583364415, 0.03902167271673529, 0.0455480377559534, 0.05337785177176302, 0.052299445530090805, 0.045158364327906875, 0.04612128756167022, 0.055356986249754825, 0.15573441601051163, 0.14810929488689129, 0.15780890415064586, 0.1505072919917262, 0.15369226105986322, 0.12221173511684125, 0.16266265697093785, 0.15286080128118706, 0.18408761533869633, 0.00043124875610900393, 0.00035776920265429, 0.0007162007458065833, 0.00036999080401312057, 0.0062831341556433, 0.0015273961849238127, 0.0042319778966657395, 0.0025720596598372003, 0.00407896218250503, 0.07957833686927529, 0.09659841748895848, 0.09900355992933307, 0.08100093902278205, 0.08465404281684608, 0.10555288902261506, 0.07531601340571181, 0.0943487371202335, 0.08442909536096688, 0.33324016846073834, 0.355413930543357, 0.3682174122510655, 0.35815969516916313, 0.36831656342434815, 0.3872773722347198, 0.33678163965897534, 0.37409639922492777, 0.37423021182090577, 0.08107459431274255, 0.07508434143177489, 0.06763848711328846, 0.07287583165180678, 0.08403916160107616, 0.08682893212712095, 0.0661928104443903, 0.06851116504918298, 0.07403240888304286, 0.1327356775892896, 0.12732741578195206, 0.14969131851923956, 0.13856072210939308, 0.1492863881000085, 0.1522880564849114, 0.12446297573191445, 0.13964822045899505, 0.1276744801225128, 0.2210443396061199, 0.2453500903683402, 0.2418418011045267, 0.20529396407385603, 0.23360006040086934, 0.24022435621172133, 0.23907909668752558, 0.24095107513201397, 0.234885443723304, 0.16225547972560195, 0.17317292561129194, 0.18457464691942738, 0.15360226050441284, 0.16543529054789363, 0.16550113741492134, 0.16338366428825335, 0.18392386538431427, 0.1638577986810842, 0.17457810432724363, 0.19991152236586818, 0.17288976959429037, 0.17385507117596732, 0.17586023608769197, 0.1894004074979675, 0.16404122506918462, 0.2005172491220757, 0.20134895824790555, 0.18027637458512913, 0.1686179605205934, 0.16282337135779656, 0.18094875777362363, 0.16398106175806348, 0.16269744788828666, 0.16874777794622042, 0.16056670566587505, 0.1669143849542919, 0.18848882293769242, 0.1551244330555973, 0.2940734747178083, 0.17698499108055765, 0.2856318883964821, 0.18071137831345752, 0.15428123831003326, 0.14453819186067796, 0.28677874993492003, 0.17505401237379514, 0.18476845072817716, 0.17952047653627, 0.18640241469022045, 0.23739812702458607, 0.18154661317989473, 0.1768903686729527, 0.4484780295986548, 0.3021110740950257, 0.1843942729319754, 0.17456795856237572, 0.1862226422798815, 0.18203485793927743, 0.1863130519311157, 0.18753970992956948, 0.20082508833959944, 0.17874261828837956, 0.16764631657692075, 0.058156614172997445, 0.06539805918304842, 0.06804401550829531, 0.0629674434070383, 0.06506465452130983, 0.06581141282093017, 0.07161302341854658, 0.0639148659295784, 0.06731163765928427]}, "mutation_prompt": null}
{"id": "cc9f0a47-db05-4f99-bb1f-329257a6369e", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim  # Change: Adaptive crossover probability\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        # Change: Adaptive differential weight\n        progress_ratio = self.current_budget / self.budget\n        adaptive_diff_weight = self.diff_weight * (1 - progress_ratio)\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - self.current_budget / self.budget))  # Change: Adaptive step size\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0  # Track successful mutations\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1  # Count successful improvements\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:  # Adaptive adjustment based on success\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Enhance convergence by tuning the crossover probability adaptively based on the current generation's success rate.", "configspace": "", "generation": 30, "fitness": 0.19816180453656745, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.17.", "error": "", "parent_id": "02d9108e-754c-445e-b8e2-2a3326c555c6", "metadata": {"aucs": [0.3725293013910128, 0.421497760011293, 0.39970267514377755, 0.4175489994427871, 0.4208940455144655, 0.40113893322490246, 0.40360989275739434, 0.4193585294857497, 0.4428991744807269, 0.13492171185963253, 0.17302270854240664, 0.1411939485937106, 0.0969126511220707, 0.14396150700670096, 0.14937261595458873, 0.1423270419103696, 0.12754935356999564, 0.13371041851590548, 0.08156929188191842, 0.08500140172772952, 0.08410031284064279, 0.06923274375540223, 0.08017898933316414, 0.08522179174761735, 0.06760849232810273, 0.09192642774184223, 0.07666858132056364, 0.06251541540520522, 0.07751291708339758, 0.06945577404962555, 0.06394670144463765, 0.06575487903422639, 0.0642554270958341, 0.061900211447957876, 0.07008909577813116, 0.06942768550504275, 0.8289982390408275, 0.8413382103305516, 0.9259753858288668, 0.8552425120116028, 0.8540982302907459, 0.9277051884266774, 0.8105499700998462, 0.8456174490118791, 0.8232755811075536, 0.15967127857725316, 0.18791630951152216, 0.16652063260072758, 0.17469427558754358, 0.18678622153590563, 0.14740611108326285, 0.19103052830331246, 0.1619395120668542, 0.1894161208353906, 0.3048272217752217, 0.31884988591475016, 0.3021696527685179, 0.3219052862475521, 0.35522202433883354, 0.40136237781234485, 0.31085323791799024, 0.46113953358402937, 0.42276002610543784, 0.09077731164125602, 0.1206498778823274, 0.1197930150324219, 0.09534612658362107, 0.09279103516650611, 0.1206149530934314, 0.10378256865975022, 0.13515871561766313, 0.13405307349611417, 0.05100853169870567, 0.12672850245249667, 0.1111987888785596, 0.11117272886293139, 0.12539163563756572, 0.11232138589577567, 0.09115264583386473, 0.11109052288756194, 0.12312384831658896, 0.07616498935869565, 0.09663466736404591, 0.09505140081318664, 0.0869273319574777, 0.09764463933835743, 0.08859938074826057, 0.07629313635087653, 0.10242116850306682, 0.09174931676193443, 0.16187447267221466, 0.2306441402941175, 0.231278001073826, 0.15615219426535443, 0.18986796096249758, 0.17293405144262564, 0.19469684706008927, 0.23585386465190405, 0.223543360810608, 0.0008731347212566076, 0.004198652887971166, 0.01836599743938172, 0.0038538252808766327, 0.021997287124562948, 0.0349182531798049, 0.008729084752038263, 0.04093105823835974, 0.018288277157254007, 0.09032661092495109, 0.11137037072581968, 0.12203452487631561, 0.0804437662043761, 0.12650129964530277, 0.10940235938376186, 0.09800784985127753, 0.13171670054193219, 0.10876014148031676, 0.3354201584273314, 0.368632414586494, 0.3717451177700297, 0.3363563792836245, 0.4116108994613321, 0.40935282021878716, 0.35143407363471146, 0.396691536215129, 0.36436487977017185, 0.08015958065706674, 0.07246155036590485, 0.08038805077847833, 0.06287787296646585, 0.0756558001254487, 0.07270902591074613, 0.07769569656780673, 0.07449101712944595, 0.09063192980683743, 0.12028936598397943, 0.13978477291854252, 0.13853200603923088, 0.1375481988532361, 0.12198795106946725, 0.14991474859101694, 0.12343600276722977, 0.1413141685257142, 0.15241446111324475, 0.22091505761950658, 0.24093516872540854, 0.25315833606770344, 0.22343964918798287, 0.22985596287167442, 0.23671065237350175, 0.23045432614040717, 0.24197009267557779, 0.2546035016406323, 0.18139038543840724, 0.18887039544870676, 0.18782257591942575, 0.16005455259500445, 0.17758092385389357, 0.1702062793084328, 0.16804867445389904, 0.17424051622041148, 0.19361012079544748, 0.1755454845023765, 0.19991152236586818, 0.1769318456403104, 0.17092468237731828, 0.1961243570115957, 0.1765819446611866, 0.16906954503604033, 0.18173157152875208, 0.20110220190765127, 0.1680478213980181, 0.1659253116606233, 0.15911635816625036, 0.16639931896101157, 0.16141689832007633, 0.16404626649286513, 0.16732274687783633, 0.15898171729710453, 0.16580679410685029, 0.15853119692129836, 0.15211881882040557, 0.3516351286883229, 0.24707416033409102, 0.3533655339559819, 0.2885417720745488, 0.14906699239578325, 0.14441232541993598, 0.19738737294857212, 0.2537805887610215, 0.1792689088528897, 0.18602824857167266, 0.2804193107459102, 0.18191741606956913, 0.26840483628857004, 0.1727311727923554, 0.19993200812808176, 0.18363449303374346, 0.17614350976690862, 0.1927816333546427, 0.16796420121925915, 0.22318015024024085, 0.1860992457956837, 0.17541100880459604, 0.17795491069550373, 0.1700836890737626, 0.20085228327553117, 0.0600832500128734, 0.06878984725732773, 0.06962021981925814, 0.06017486515563375, 0.0695480383682674, 0.0724765760937427, 0.06756928387840666, 0.06646948663105212, 0.0717494592225203]}, "mutation_prompt": null}
{"id": "b2eedf2c-c318-4b84-8fe6-519b66f2e958", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        progress_ratio = self.current_budget / self.budget\n        adaptive_diff_weight = self.diff_weight * (1 - progress_ratio)\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - self.current_budget / self.budget))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n                self.diff_weight *= (1 / (1 + successes))  # Change: Scale diff_weight inversely with success rate\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Integrate adaptive mutation by scaling differential weight with the inverse success rate to balance exploration and exploitation.", "configspace": "", "generation": 31, "fitness": 0.14616002720205193, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.17.", "error": "", "parent_id": "cc9f0a47-db05-4f99-bb1f-329257a6369e", "metadata": {"aucs": [0.21745326596082515, 0.2115855540625523, 0.25199236285117754, 0.2360317212082096, 0.23038647393318434, 0.22259851916305073, 0.22513692719427225, 0.2568876622941447, 0.25031270134433914, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0887784513686638, 0.08979022839391548, 0.07770853138934053, 0.07434413580861488, 0.06964777455973492, 0.07861180704715176, 0.08594133082779642, 0.07914652660968002, 0.06952028948895206, 0.07554738031133801, 0.06506908804983957, 0.053557248264599955, 0.05631922163709513, 0.06373123193948227, 0.05748523826678631, 0.08227493058494406, 0.05900458524547525, 0.06307652824619547, 0.8240876744245695, 0.8813434304385425, 0.8785617452577064, 0.872966659746297, 0.8921786081069338, 0.8495783507715059, 0.8576412541511578, 0.8977121831915358, 0.7243985220754885, 0.12914340863933116, 0.15289261941350363, 0.11130575503083295, 0.13719912821954672, 0.11544558055021448, 0.1294230094861759, 0.12476465914351609, 0.1243040018321615, 0.11788385163725812, 0.17335861698830124, 0.18062810252752803, 0.18012217442137735, 0.16492098927750176, 0.1573981768420043, 0.17230064362128872, 0.19145403148290863, 0.17453465061848505, 0.1862902310595287, 0.017884126410491974, 0.0437024856309316, 0.06312723692399669, 0.05739123001340507, 0.06568535818666221, 0.07683383786147935, 0.06746040613059923, 0.046155566217414346, 0.05305344364309983, 0.07124362137692919, 0.027932968575073547, 0.05619074977968308, 0.055678144200441926, 0.015229081519972487, 0.06464211272901177, 0.05037237435292374, 0.07474527894891092, 0.06383827504813, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11152527312465299, 0.05755465541130256, 0.09053853038941684, 0.014986179315422898, 0.031919539279484654, 0.04400419958766688, 0.05684375595046387, 0.033067549133714236, 0.05225886595072893, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009602902711679961, 0.02319133300648968, 0.020633593462179856, 0.025240458267157373, 0.014243891690813304, 0.02891989874242229, 0.014605717508858973, 0.017172709988670376, 0.021480344449749333, 0.2291359850554433, 0.26982111923968655, 0.2542573200033874, 0.2398461503587026, 0.25603400879231286, 0.2266991619193297, 0.23762562945202204, 0.2842267005097435, 0.23304942926762784, 0.06733535085007514, 0.08686855516312464, 0.07447127311531732, 0.09411364551897095, 0.07868156627553013, 0.06616786966723198, 0.07283344538130443, 0.07041293073305821, 0.06556172175546449, 0.13956381170481358, 0.17763869462015824, 0.1165707116985415, 0.13004572819045734, 0.13677227953710536, 0.14412898322721956, 0.13720117826888223, 0.145955741106081, 0.1452506261203924, 0.18378733693066818, 0.1962597586645699, 0.19797797854776167, 0.2077306877458669, 0.1999264112086092, 0.19350145214285586, 0.21983995134174994, 0.1960569048835037, 0.20526966985795925, 0.15972874450859031, 0.14794093156475352, 0.13990966018137474, 0.1534289360350818, 0.14549168683454716, 0.13863866236046574, 0.14707216570680393, 0.13103832249704106, 0.1372513790299168, 0.17222251578657777, 0.18746540283159563, 0.20023115980562, 0.18051023802917188, 0.17745971931724358, 0.2008975634268627, 0.18065456819724746, 0.16811930565118094, 0.18262329526564514, 0.16579700284949883, 0.15831990249412997, 0.18887340855224932, 0.1568031915381749, 0.15805864402862058, 0.1672228631655165, 0.1767984358258009, 0.15587358539462803, 0.16601620407055018, 0.15255432560169901, 0.1597912967252192, 0.2366655179191769, 0.1818380701854726, 0.24785659365707546, 0.2550445005776263, 0.1538925624757852, 0.16105325722168728, 0.2809510681307803, 0.24340120834322376, 0.14861162949222328, 0.18099186827459957, 0.24909134533434407, 0.22724882746520403, 0.1830409765715706, 0.12320502866955918, 0.10745425727483349, 0.13218826915129356, 0.1770700264383508, 0.17389014916378032, 0.17477828226629666, 0.19757606928625226, 0.17238592713952616, 0.192104016486775, 0.18763045647850896, 0.16849004224280473, 0.19843286792981196, 0.07053180828910677, 0.07783074755734087, 0.061796243738096224, 0.07876556452972405, 0.08047219583881937, 0.07052395491044294, 0.0718372014806522, 0.06448487679234349, 0.06658410767219813]}, "mutation_prompt": null}
{"id": "21b176e2-ded7-48cd-aa7a-3098d63edb8c", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population, fitness):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        # Change: Dynamic differential weight adjustment based on fitness variance\n        fitness_variance = np.var(fitness)\n        adaptive_diff_weight = self.diff_weight * (1 - fitness_variance / (fitness_variance + 1e-8))\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - self.current_budget / self.budget))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population, fitness)  # Pass fitness here\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Fine-tune mutation strategy by dynamically adjusting differential weight based on fitness variance.", "configspace": "", "generation": 32, "fitness": 0.14723170918229142, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.17.", "error": "", "parent_id": "cc9f0a47-db05-4f99-bb1f-329257a6369e", "metadata": {"aucs": [0.2847407178924204, 0.2665110767639639, 0.2568465780370053, 0.23322116073608745, 0.21941538456487875, 0.21385406047316324, 0.2307462986989265, 0.23991971773441068, 0.24549079247242933, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08420525014469493, 0.073794851708886, 0.07055308898965829, 0.07744428998098596, 0.07922360290162689, 0.07460164858490903, 0.07375962832160388, 0.07404545383735261, 0.0746635594088022, 0.083113374528203, 0.059263239091436826, 0.07382114622823299, 0.06151815883348244, 0.05033297747187515, 0.05429357872146934, 0.06827434843982805, 0.05797808864614906, 0.0896888383851896, 0.860776368370799, 0.9319233493057126, 0.8760815659962256, 0.6811186435499658, 0.854404183877239, 0.8942381237738468, 0.8562473307932554, 0.8948491861764771, 0.6848432805893183, 0.1327512692704278, 0.14024519178478512, 0.11018759151331958, 0.13872578206681485, 0.12269338257163032, 0.13542240943615202, 0.13432637901761102, 0.12621217661686712, 0.11877296567626128, 0.17069797336141967, 0.16841307546685025, 0.2086872322426534, 0.20781923572468464, 0.16841445151003864, 0.2280663101925955, 0.1755455410892669, 0.1868160305864882, 0.16583997001828066, 0.06483074971695946, 0.015989587289809593, 0.060261742160792386, 0.029583694073708422, 0.07331411315938019, 0.06721797806571594, 0.08087950479456263, 0.032476551917105634, 0.05652180515855143, 0.05829266427404778, 0.06660004129599406, 0.05193979381357017, 0.04657418590783602, 0.016080550444468877, 0.06342053013498283, 0.03439145289302303, 0.04104801810906211, 0.07584861153155376, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0768917109644135, 0.06561832075645302, 0.07596973060575785, 0.0198501426194031, 0.03448319662996602, 0.030951505475100616, 0.027676794194664733, 0.0905616602774777, 0.04046585597309027, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020323006534389232, 0.024755527229799235, 0.019504886389461906, 0.0332582745809914, 0.023430836082046325, 0.009744294667336728, 0.010944232980103163, 0.029423703283196434, 0.017417295528066812, 0.25406151489812034, 0.27175167533639355, 0.24054141929796147, 0.2335296557058396, 0.23324617618985788, 0.25937059188930056, 0.261219934115848, 0.257922392830906, 0.24807886285307523, 0.09694323472817301, 0.07377371935594745, 0.07103177438900765, 0.07604508588740011, 0.06818987326833681, 0.08408406825864168, 0.0664936700499793, 0.06974016692693896, 0.06497883360050549, 0.1391300902296453, 0.12232478305023908, 0.1134319823952481, 0.25132297372815826, 0.14446702165695446, 0.11805636187967117, 0.14039643324877726, 0.14109058477444414, 0.14290519457617223, 0.1956142270470974, 0.19875685784046426, 0.20720310705605716, 0.20670614607451676, 0.2017311145866778, 0.1880650629618299, 0.18742490546647705, 0.1816376302220385, 0.19334105082663966, 0.13454070761412185, 0.14585292678430684, 0.13795628831601392, 0.14797179212116984, 0.13475750237477713, 0.1385332632181131, 0.12183180925887771, 0.14122593355781987, 0.15602750088728934, 0.17873187865747264, 0.1714703627723313, 0.1729177966030978, 0.2244699325737166, 0.1768574446441924, 0.21175329922216612, 0.19420230210047817, 0.19776397883432717, 0.18259615042285005, 0.16533798035139857, 0.16085819428253434, 0.1837311807323897, 0.16381749072353247, 0.15889643819472388, 0.1656350670914628, 0.16774158241686365, 0.1739230770246608, 0.1631545593460918, 0.15792719647003628, 0.23799792179379786, 0.11333970381628877, 0.2703869982798578, 0.2813513288256233, 0.14022608596323993, 0.15326873233478144, 0.16485799944972968, 0.16666303237912306, 0.16523667394877795, 0.30881693154399403, 0.17236495464354318, 0.156400362859198, 0.16229884464183653, 0.3037461961644877, 0.1440970147538464, 0.1643295013246272, 0.27866897878873853, 0.171539435411998, 0.1757943988141164, 0.17147303595520313, 0.19860781180194598, 0.17027857374195687, 0.21236201980046399, 0.18791480573045094, 0.17609761893246145, 0.19383896045489812, 0.06947378826867823, 0.08316848293680579, 0.07233325892233222, 0.07653598756665891, 0.07963743978014626, 0.08679815622910625, 0.07183929278488099, 0.08025388027898261, 0.07027669896271382]}, "mutation_prompt": null}
{"id": "8f8aa8ae-8840-4c20-ba55-2329d5cf81fc", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim  # Change: Adaptive crossover probability\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        # Change: Adaptive differential weight\n        progress_ratio = self.current_budget / self.budget\n        adaptive_diff_weight = self.diff_weight * (1 - progress_ratio)\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        # Change: Fine-tune adaptive step size with decay factor\n        decay_factor = 0.8 ** (self.current_budget / self.budget)\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - self.current_budget / self.budget) * decay_factor)\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0  # Track successful mutations\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1  # Count successful improvements\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:  # Adaptive adjustment based on success\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Fine-tune adaptive step size by incorporating a dynamic decay factor based on budget utilization.", "configspace": "", "generation": 33, "fitness": 0.19826865245425618, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.17.", "error": "", "parent_id": "cc9f0a47-db05-4f99-bb1f-329257a6369e", "metadata": {"aucs": [0.3722164809424553, 0.4059517421757278, 0.40915478316521803, 0.41075097062777044, 0.4300815433682904, 0.38147983543403274, 0.37978949973331677, 0.42096510315282243, 0.4311318548700632, 0.1333383254611339, 0.13062541417226148, 0.1249799312514186, 0.1092248520318142, 0.14161614981629878, 0.15136368485925455, 0.12797270677140937, 0.1623686784241296, 0.12222707036963798, 0.09032084514833028, 0.08409052990561905, 0.08893295757845976, 0.07223545499536688, 0.07352861380174058, 0.07476471176259658, 0.07100638444760166, 0.0888216660341048, 0.08745887150021825, 0.0813247085460147, 0.07237220631516961, 0.0639015734589119, 0.058639795962229124, 0.06859607618750085, 0.06059643318093677, 0.0652799893787962, 0.06703564354031155, 0.07254563510085099, 0.860745715778715, 0.8421565523661733, 0.9259715569440841, 0.8748545713613982, 0.8541109225604552, 0.9277037600900402, 0.8101701414183778, 0.8457773585985755, 0.82337333394526, 0.17279030634900083, 0.20470450177724575, 0.16644922282383812, 0.18077087910742484, 0.18795759146755986, 0.1715284445233043, 0.19020963408452407, 0.16265931315676985, 0.23314045390928684, 0.26819921041071515, 0.28952014326059283, 0.325191903547575, 0.3462476342250024, 0.452670351638915, 0.44134183624526035, 0.36345758469233036, 0.4408851588671536, 0.39333682925335656, 0.08230815169291505, 0.11558442086303, 0.10702508321906246, 0.09854761928431943, 0.10910463698001516, 0.11204825605969215, 0.10350721132572505, 0.1432820660668549, 0.11782147842618529, 0.07923949145462206, 0.1312309554845964, 0.07463898836748817, 0.11263648661668535, 0.13581536565753372, 0.09409243005824042, 0.10573830090210667, 0.11730956890614253, 0.09589736816542149, 0.06527720496169676, 0.08250863652488405, 0.09023002889743947, 0.08599551102050318, 0.10537414788084842, 0.1161051345780566, 0.08090480790188526, 0.1041991240905964, 0.10108985077281252, 0.16191696234499342, 0.21675604713536933, 0.21251299724044626, 0.18021033961206212, 0.19656331883651046, 0.18378170887611545, 0.16663952273355953, 0.20934688566542048, 0.21644061875537368, 0.009288741866400052, 0.008648687482101014, 0.0172027652461324, 0.003468590876798072, 0.028657779980205467, 0.033857296604046905, 0.004853600075335973, 0.020601733360457675, 0.014256638679953748, 0.07959962040561352, 0.11222089397641188, 0.10220558284292669, 0.0947907436727412, 0.1097400086937973, 0.12359272051883619, 0.10030793419947626, 0.13215139382495, 0.12266587450106547, 0.3538818267828008, 0.3819505555077213, 0.3967085022519914, 0.3653565886063256, 0.3953270489977122, 0.3839524415974406, 0.3523878133153082, 0.3868874601194816, 0.3874707900971529, 0.07418196193898052, 0.08013914959849822, 0.08638157912499955, 0.06898418013411833, 0.08397670374245392, 0.06684761165865438, 0.07149772489046735, 0.07877680065283388, 0.07090477385329064, 0.12174235805051481, 0.14796338078303872, 0.11836599848965157, 0.1233473149439187, 0.13151696408901425, 0.1287746957906718, 0.12664754444903648, 0.13574707441597222, 0.12394670838518196, 0.23282747351490463, 0.23247605223280499, 0.24542603452054812, 0.21249431794918827, 0.22910618093727853, 0.2380774066421062, 0.2251174615918199, 0.25065562592710733, 0.24232274704021972, 0.17018213469530108, 0.18482744376966231, 0.1834997583671124, 0.17295044770373247, 0.16077953700602754, 0.1847624001556344, 0.1653973910115386, 0.1943361744357639, 0.1991702819694785, 0.1761167290090465, 0.16098626499539093, 0.19919914404231243, 0.166937565436862, 0.17769323728209163, 0.16401680355882964, 0.17888327945577043, 0.18439244219118622, 0.18057870798504916, 0.1667682191112132, 0.16387854020210002, 0.1682973253380855, 0.16907174215720022, 0.16316901462774136, 0.16615797156856915, 0.16362752817135118, 0.15851699439866263, 0.1610808799324639, 0.16468839873350283, 0.15399095912548622, 0.344032297560102, 0.24791278081871004, 0.3435883285613899, 0.2198346066499718, 0.17305187834199243, 0.13801143810473893, 0.31243435171547196, 0.26340662719778607, 0.1811883970770919, 0.17916056604116515, 0.2955919570365775, 0.2042115892150016, 0.26294945622078036, 0.17501480740110964, 0.20222905284711323, 0.1830114643646198, 0.17550517383700148, 0.1863890050168603, 0.1723009861913335, 0.19186257326184142, 0.1654959362005769, 0.17622476577207125, 0.17333506450771052, 0.17824072556528192, 0.176999206886721, 0.07306944330061416, 0.06853166010556488, 0.06594671525127593, 0.05845890957800548, 0.058624784505173166, 0.061164082131380026, 0.06503327781295953, 0.0634451664319986, 0.061238715507766384]}, "mutation_prompt": null}
{"id": "18de0f0c-04b7-4544-b9c2-3d5642d1fbab", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim  # Change: Adaptive crossover probability\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        # Change: Adaptive differential weight\n        progress_ratio = self.current_budget / self.budget\n        # Change: Added weighted recency effect\n        adaptive_diff_weight = self.diff_weight * (1 - 0.5 * progress_ratio)\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        # Change: Fine-tune adaptive step size with decay factor\n        decay_factor = 0.8 ** (self.current_budget / self.budget)\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - self.current_budget / self.budget) * decay_factor)\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0  # Track successful mutations\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1  # Count successful improvements\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:  # Adaptive adjustment based on success\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Enhance convergence by adding a weighted recency effect on the adaptive differential weight.", "configspace": "", "generation": 34, "fitness": 0.18355634658343514, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.16.", "error": "", "parent_id": "8f8aa8ae-8840-4c20-ba55-2329d5cf81fc", "metadata": {"aucs": [0.36883507509903857, 0.3873498995800224, 0.37546911925048954, 0.38275404760855314, 0.39919799648713583, 0.37809638042801985, 0.37551917912655597, 0.37951917084252185, 0.39540162316814254, 0.078172029535022, 0.1382504632466569, 0.11232774341003793, 0.09329528621443861, 0.11927882439259008, 0.1188799898752444, 0.10247397356335275, 0.10185794465641396, 0.11366959466432203, 0.07864311672159496, 0.08602333007058938, 0.09140657422536136, 0.07740283231328371, 0.07215925800249934, 0.07273625084046509, 0.06285621479654324, 0.08367526343480336, 0.07004562496315414, 0.06900321386527253, 0.07931127937122617, 0.05763369971120502, 0.0707315786320536, 0.059932347202465985, 0.058752352430931354, 0.05274128489123575, 0.06360930574506019, 0.06066320574031381, 0.8605785154343335, 0.8702824674909221, 0.8450025668853804, 0.872477315890429, 0.8542702632072108, 0.9277288341525006, 0.784941818443978, 0.850317475078459, 0.7425439395330083, 0.14652369038770252, 0.1851591915167009, 0.17931077531117678, 0.1712154534436755, 0.16283507008631637, 0.17880654677470098, 0.17984077693512268, 0.1847050796294024, 0.21731912384120855, 0.2319521467507355, 0.2455450480608785, 0.29007998094176457, 0.27260783697923296, 0.32259630992866395, 0.25679413944133744, 0.26074198936489934, 0.3563766655692442, 0.2528469271782545, 0.0942553717393132, 0.086015335111153, 0.08752096731813852, 0.09116030422933874, 0.09001816727458278, 0.10802574298118528, 0.11922881626667481, 0.10789029844272213, 0.08484759543852283, 0.12269901634410985, 0.11419103380171114, 0.11123559938896688, 0.09258609196950696, 0.10236680503440898, 0.09590475718360736, 0.08075334873311435, 0.08515582940259592, 0.09931421584640665, 0.055145842728609784, 0.09758703539086078, 0.06919377106031332, 0.057099118666503856, 0.07178608018074917, 0.08347751397801262, 0.04264326976675492, 0.08286277205018688, 0.06003074226858718, 0.17344368282767042, 0.170499970613334, 0.18136107082830866, 0.15734020265554027, 0.1703012819009505, 0.17616909696550465, 0.1431591459348185, 0.20664284467738248, 0.20237060184518896, 9.999999999998899e-05, 0.010322598751590473, 0.0007724953917437327, 0.0021981345244262984, 0.010732763946838864, 0.006771580757093942, 0.0014720727352041107, 0.012196114398732472, 0.003421494905822553, 0.07857270849635911, 0.09213843415220146, 0.08180165024301145, 0.0914383441216563, 0.092653606145776, 0.09892659586837704, 0.08325574594014595, 0.11264259281800826, 0.10022788665121685, 0.3326001915432577, 0.340408369300064, 0.33089599424300664, 0.3360803929506575, 0.36404499779940613, 0.37161758384996546, 0.3166310844656953, 0.3522301047806772, 0.3355102224516253, 0.08698730726855464, 0.07292189451681186, 0.08151656297107635, 0.08252950904015122, 0.07408675895156414, 0.08765848881067273, 0.07539594729020427, 0.07350624722424415, 0.07932467400111765, 0.1283694597296532, 0.1256686637213308, 0.14559285981160697, 0.12226217231028602, 0.14710500946974048, 0.12741787895129764, 0.13443164174058841, 0.13750694729444113, 0.1304032304819086, 0.20256461776393908, 0.21675591128403604, 0.23716960266004594, 0.19760051939494194, 0.20664671927525824, 0.2139087997397, 0.2246709113458929, 0.22678415410452368, 0.22432640975881113, 0.16756539006723548, 0.17142528266302948, 0.1693229420729363, 0.14629638402784784, 0.17286048865098003, 0.16600639976822362, 0.17152503878633774, 0.1606673214775165, 0.1604048096736269, 0.1794810602817788, 0.16369910112904051, 0.17661830570271086, 0.17424137826261865, 0.1834644039584742, 0.16596248394459068, 0.1659531059004401, 0.17085393536731974, 0.17430883979262157, 0.16236040004001084, 0.16035483791386274, 0.15706095847780321, 0.15517003694813136, 0.15603274257042377, 0.16343159880494218, 0.1696914672068558, 0.15682574361609736, 0.16431367552822118, 0.15363570399792825, 0.2551640443567925, 0.2508186227667858, 0.198459376923539, 0.23691365730263592, 0.15261763126173922, 0.16023989154553087, 0.14155880430136658, 0.30337397456303516, 0.1507269099482863, 0.17663698362459834, 0.1842088815338755, 0.16105377254370867, 0.21689363670185324, 0.23234590980582281, 0.17771740269992387, 0.19931823924705694, 0.31116683354082475, 0.19136438994067895, 0.17610371036158134, 0.1839031486807602, 0.1850186874284343, 0.20833040641509715, 0.18956725944325992, 0.17769996998654114, 0.190181534089243, 0.19569271605588978, 0.060273991011737804, 0.07685696328775216, 0.06619457081228175, 0.055225202841699184, 0.07898070738352947, 0.06540952961751667, 0.07002101403091343, 0.07105022917283554, 0.06941339880909958]}, "mutation_prompt": null}
{"id": "d66b42e8-9091-4617-a079-505b2da48453", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim  # Change: Adaptive crossover probability\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        # Change: Adaptive differential weight\n        progress_ratio = self.current_budget / self.budget\n        adaptive_diff_weight = self.diff_weight * (1 - progress_ratio)\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        # Change: Fine-tune adaptive step size with decay factor\n        decay_factor = 0.8 ** (self.current_budget / self.budget)\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - self.current_budget / self.budget) * decay_factor)\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n        no_improvement_count = 0  # Track iterations without improvement\n\n        while self.current_budget < self.budget:\n            successes = 0  # Track successful mutations\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1  # Count successful improvements\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:  # Adaptive adjustment based on success\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n                no_improvement_count = 0  # Reset no improvement counter\n            else:\n                no_improvement_count += 1\n\n            # Change: Random reset mechanism\n            if no_improvement_count > self.budget * 0.05:  # After 5% of budget without improvement\n                population = self._initialize_population()  # Reinitialize population\n                fitness = np.array([func(ind) for ind in population])\n                no_improvement_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Enhance exploration by introducing a random reset mechanism when no improvement is observed for a significant portion of the budget.", "configspace": "", "generation": 35, "fitness": 0.19826865245425618, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.17.", "error": "", "parent_id": "8f8aa8ae-8840-4c20-ba55-2329d5cf81fc", "metadata": {"aucs": [0.3722164809424553, 0.4059517421757278, 0.40915478316521803, 0.41075097062777044, 0.4300815433682904, 0.38147983543403274, 0.37978949973331677, 0.42096510315282243, 0.4311318548700632, 0.1333383254611339, 0.13062541417226148, 0.1249799312514186, 0.1092248520318142, 0.14161614981629878, 0.15136368485925455, 0.12797270677140937, 0.1623686784241296, 0.12222707036963798, 0.09032084514833028, 0.08409052990561905, 0.08893295757845976, 0.07223545499536688, 0.07352861380174058, 0.07476471176259658, 0.07100638444760166, 0.0888216660341048, 0.08745887150021825, 0.0813247085460147, 0.07237220631516961, 0.0639015734589119, 0.058639795962229124, 0.06859607618750085, 0.06059643318093677, 0.0652799893787962, 0.06703564354031155, 0.07254563510085099, 0.860745715778715, 0.8421565523661733, 0.9259715569440841, 0.8748545713613982, 0.8541109225604552, 0.9277037600900402, 0.8101701414183778, 0.8457773585985755, 0.82337333394526, 0.17279030634900083, 0.20470450177724575, 0.16644922282383812, 0.18077087910742484, 0.18795759146755986, 0.1715284445233043, 0.19020963408452407, 0.16265931315676985, 0.23314045390928684, 0.26819921041071515, 0.28952014326059283, 0.325191903547575, 0.3462476342250024, 0.452670351638915, 0.44134183624526035, 0.36345758469233036, 0.4408851588671536, 0.39333682925335656, 0.08230815169291505, 0.11558442086303, 0.10702508321906246, 0.09854761928431943, 0.10910463698001516, 0.11204825605969215, 0.10350721132572505, 0.1432820660668549, 0.11782147842618529, 0.07923949145462206, 0.1312309554845964, 0.07463898836748817, 0.11263648661668535, 0.13581536565753372, 0.09409243005824042, 0.10573830090210667, 0.11730956890614253, 0.09589736816542149, 0.06527720496169676, 0.08250863652488405, 0.09023002889743947, 0.08599551102050318, 0.10537414788084842, 0.1161051345780566, 0.08090480790188526, 0.1041991240905964, 0.10108985077281252, 0.16191696234499342, 0.21675604713536933, 0.21251299724044626, 0.18021033961206212, 0.19656331883651046, 0.18378170887611545, 0.16663952273355953, 0.20934688566542048, 0.21644061875537368, 0.009288741866400052, 0.008648687482101014, 0.0172027652461324, 0.003468590876798072, 0.028657779980205467, 0.033857296604046905, 0.004853600075335973, 0.020601733360457675, 0.014256638679953748, 0.07959962040561352, 0.11222089397641188, 0.10220558284292669, 0.0947907436727412, 0.1097400086937973, 0.12359272051883619, 0.10030793419947626, 0.13215139382495, 0.12266587450106547, 0.3538818267828008, 0.3819505555077213, 0.3967085022519914, 0.3653565886063256, 0.3953270489977122, 0.3839524415974406, 0.3523878133153082, 0.3868874601194816, 0.3874707900971529, 0.07418196193898052, 0.08013914959849822, 0.08638157912499955, 0.06898418013411833, 0.08397670374245392, 0.06684761165865438, 0.07149772489046735, 0.07877680065283388, 0.07090477385329064, 0.12174235805051481, 0.14796338078303872, 0.11836599848965157, 0.1233473149439187, 0.13151696408901425, 0.1287746957906718, 0.12664754444903648, 0.13574707441597222, 0.12394670838518196, 0.23282747351490463, 0.23247605223280499, 0.24542603452054812, 0.21249431794918827, 0.22910618093727853, 0.2380774066421062, 0.2251174615918199, 0.25065562592710733, 0.24232274704021972, 0.17018213469530108, 0.18482744376966231, 0.1834997583671124, 0.17295044770373247, 0.16077953700602754, 0.1847624001556344, 0.1653973910115386, 0.1943361744357639, 0.1991702819694785, 0.1761167290090465, 0.16098626499539093, 0.19919914404231243, 0.166937565436862, 0.17769323728209163, 0.16401680355882964, 0.17888327945577043, 0.18439244219118622, 0.18057870798504916, 0.1667682191112132, 0.16387854020210002, 0.1682973253380855, 0.16907174215720022, 0.16316901462774136, 0.16615797156856915, 0.16362752817135118, 0.15851699439866263, 0.1610808799324639, 0.16468839873350283, 0.15399095912548622, 0.344032297560102, 0.24791278081871004, 0.3435883285613899, 0.2198346066499718, 0.17305187834199243, 0.13801143810473893, 0.31243435171547196, 0.26340662719778607, 0.1811883970770919, 0.17916056604116515, 0.2955919570365775, 0.2042115892150016, 0.26294945622078036, 0.17501480740110964, 0.20222905284711323, 0.1830114643646198, 0.17550517383700148, 0.1863890050168603, 0.1723009861913335, 0.19186257326184142, 0.1654959362005769, 0.17622476577207125, 0.17333506450771052, 0.17824072556528192, 0.176999206886721, 0.07306944330061416, 0.06853166010556488, 0.06594671525127593, 0.05845890957800548, 0.058624784505173166, 0.061164082131380026, 0.06503327781295953, 0.0634451664319986, 0.061238715507766384]}, "mutation_prompt": null}
{"id": "96fd7cb1-9d25-46ab-bae1-212f5f91a0b8", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim  # Change: Adaptive crossover probability\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        # Change: Adaptive differential weight\n        progress_ratio = self.current_budget / self.budget\n        adaptive_diff_weight = self.diff_weight * (1 - progress_ratio)\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        # Change: Fine-tune adaptive step size with decay factor\n        decay_factor = 0.8 ** (self.current_budget / self.budget)\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - self.current_budget / self.budget) * decay_factor)\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0  # Track successful mutations\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1  # Count successful improvements\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:  # Adaptive adjustment based on success\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Fine-tune adaptive step size by incorporating a dynamic decay factor based on budget utilization.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8f8aa8ae-8840-4c20-ba55-2329d5cf81fc", "metadata": {"aucs": [0.3722164809424553, 0.4059517421757278, 0.40915478316521803, 0.41075097062777044, 0.4300815433682904, 0.38147983543403274, 0.37978949973331677, 0.42096510315282243, 0.4311318548700632, 0.1333383254611339, 0.13062541417226148, 0.1249799312514186, 0.1092248520318142, 0.14161614981629878, 0.15136368485925455, 0.12797270677140937, 0.1623686784241296, 0.12222707036963798, 0.09032084514833028, 0.08409052990561905, 0.08893295757845976, 0.07223545499536688, 0.07352861380174058, 0.07476471176259658, 0.07100638444760166, 0.0888216660341048, 0.08745887150021825, 0.0813247085460147, 0.07237220631516961, 0.0639015734589119, 0.058639795962229124, 0.06859607618750085, 0.06059643318093677, 0.0652799893787962, 0.06703564354031155, 0.07254563510085099, 0.860745715778715, 0.8421565523661733, 0.9259715569440841, 0.8748545713613982, 0.8541109225604552, 0.9277037600900402, 0.8101701414183778, 0.8457773585985755, 0.82337333394526, 0.17279030634900083, 0.20470450177724575, 0.16644922282383812, 0.18077087910742484, 0.18795759146755986, 0.1715284445233043, 0.19020963408452407, 0.16265931315676985, 0.23314045390928684, 0.26819921041071515, 0.28952014326059283, 0.325191903547575, 0.3462476342250024, 0.452670351638915, 0.44134183624526035, 0.36345758469233036, 0.4408851588671536, 0.39333682925335656, 0.08230815169291505, 0.11558442086303, 0.10702508321906246, 0.09854761928431943, 0.10910463698001516, 0.11204825605969215, 0.10350721132572505, 0.1432820660668549, 0.11782147842618529, 0.07923949145462206, 0.1312309554845964, 0.07463898836748817, 0.11263648661668535, 0.13581536565753372, 0.09409243005824042, 0.10573830090210667, 0.11730956890614253, 0.09589736816542149, 0.06527720496169676, 0.08250863652488405, 0.09023002889743947, 0.08599551102050318, 0.10537414788084842, 0.1161051345780566, 0.08090480790188526, 0.1041991240905964, 0.10108985077281252, 0.16191696234499342, 0.21675604713536933, 0.21251299724044626, 0.18021033961206212, 0.19656331883651046, 0.18378170887611545, 0.16663952273355953, 0.20934688566542048, 0.21644061875537368, 0.009288741866400052, 0.008648687482101014, 0.0172027652461324, 0.003468590876798072, 0.028657779980205467, 0.033857296604046905, 0.004853600075335973, 0.020601733360457675, 0.014256638679953748, 0.07959962040561352, 0.11222089397641188, 0.10220558284292669, 0.0947907436727412, 0.1097400086937973, 0.12359272051883619, 0.10030793419947626, 0.13215139382495, 0.12266587450106547, 0.3538818267828008, 0.3819505555077213, 0.3967085022519914, 0.3653565886063256, 0.3953270489977122, 0.3839524415974406, 0.3523878133153082, 0.3868874601194816, 0.3874707900971529, 0.07418196193898052, 0.08013914959849822, 0.08638157912499955, 0.06898418013411833, 0.08397670374245392, 0.06684761165865438, 0.07149772489046735, 0.07877680065283388, 0.07090477385329064, 0.12174235805051481, 0.14796338078303872, 0.11836599848965157, 0.1233473149439187, 0.13151696408901425, 0.1287746957906718, 0.12664754444903648, 0.13574707441597222, 0.12394670838518196, 0.23282747351490463, 0.23247605223280499, 0.24542603452054812, 0.21249431794918827, 0.22910618093727853, 0.2380774066421062, 0.2251174615918199, 0.25065562592710733, 0.24232274704021972, 0.17018213469530108, 0.18482744376966231, 0.1834997583671124, 0.17295044770373247, 0.16077953700602754, 0.1847624001556344, 0.1653973910115386, 0.1943361744357639, 0.1991702819694785, 0.1761167290090465, 0.16098626499539093, 0.19919914404231243, 0.166937565436862, 0.17769323728209163, 0.16401680355882964, 0.17888327945577043, 0.18439244219118622, 0.18057870798504916, 0.1667682191112132, 0.16387854020210002, 0.1682973253380855, 0.16907174215720022, 0.16316901462774136, 0.16615797156856915, 0.16362752817135118, 0.15851699439866263, 0.1610808799324639, 0.16468839873350283, 0.15399095912548622, 0.344032297560102, 0.24791278081871004, 0.3435883285613899, 0.2198346066499718, 0.17305187834199243, 0.13801143810473893, 0.31243435171547196, 0.26340662719778607, 0.1811883970770919, 0.17916056604116515, 0.2955919570365775, 0.2042115892150016, 0.26294945622078036, 0.17501480740110964, 0.20222905284711323, 0.1830114643646198, 0.17550517383700148, 0.1863890050168603, 0.1723009861913335, 0.19186257326184142, 0.1654959362005769, 0.17622476577207125, 0.17333506450771052, 0.17824072556528192, 0.176999206886721, 0.07306944330061416, 0.06853166010556488, 0.06594671525127593, 0.05845890957800548, 0.058624784505173166, 0.061164082131380026, 0.06503327781295953, 0.0634451664319986, 0.061238715507766384]}, "mutation_prompt": null}
{"id": "d7aae100-751c-4b3a-b879-4782c2af1e04", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim  # Change: Adaptive crossover probability\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        # Change: Adaptive differential weight\n        progress_ratio = self.current_budget / self.budget\n        adaptive_diff_weight = self.diff_weight * (1 - progress_ratio)\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        # Change: Fine-tune adaptive step size with decay factor\n        decay_factor = 0.8 ** (self.current_budget / self.budget)\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - self.current_budget / self.budget) * decay_factor)\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0  # Track successful mutations\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1  # Count successful improvements\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:  # Adaptive adjustment based on success\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Fine-tune adaptive step size by incorporating a dynamic decay factor based on budget utilization.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8f8aa8ae-8840-4c20-ba55-2329d5cf81fc", "metadata": {"aucs": [0.3722164809424553, 0.4059517421757278, 0.40915478316521803, 0.41075097062777044, 0.4300815433682904, 0.38147983543403274, 0.37978949973331677, 0.42096510315282243, 0.4311318548700632, 0.1333383254611339, 0.13062541417226148, 0.1249799312514186, 0.1092248520318142, 0.14161614981629878, 0.15136368485925455, 0.12797270677140937, 0.1623686784241296, 0.12222707036963798, 0.09032084514833028, 0.08409052990561905, 0.08893295757845976, 0.07223545499536688, 0.07352861380174058, 0.07476471176259658, 0.07100638444760166, 0.0888216660341048, 0.08745887150021825, 0.0813247085460147, 0.07237220631516961, 0.0639015734589119, 0.058639795962229124, 0.06859607618750085, 0.06059643318093677, 0.0652799893787962, 0.06703564354031155, 0.07254563510085099, 0.860745715778715, 0.8421565523661733, 0.9259715569440841, 0.8748545713613982, 0.8541109225604552, 0.9277037600900402, 0.8101701414183778, 0.8457773585985755, 0.82337333394526, 0.17279030634900083, 0.20470450177724575, 0.16644922282383812, 0.18077087910742484, 0.18795759146755986, 0.1715284445233043, 0.19020963408452407, 0.16265931315676985, 0.23314045390928684, 0.26819921041071515, 0.28952014326059283, 0.325191903547575, 0.3462476342250024, 0.452670351638915, 0.44134183624526035, 0.36345758469233036, 0.4408851588671536, 0.39333682925335656, 0.08230815169291505, 0.11558442086303, 0.10702508321906246, 0.09854761928431943, 0.10910463698001516, 0.11204825605969215, 0.10350721132572505, 0.1432820660668549, 0.11782147842618529, 0.07923949145462206, 0.1312309554845964, 0.07463898836748817, 0.11263648661668535, 0.13581536565753372, 0.09409243005824042, 0.10573830090210667, 0.11730956890614253, 0.09589736816542149, 0.06527720496169676, 0.08250863652488405, 0.09023002889743947, 0.08599551102050318, 0.10537414788084842, 0.1161051345780566, 0.08090480790188526, 0.1041991240905964, 0.10108985077281252, 0.16191696234499342, 0.21675604713536933, 0.21251299724044626, 0.18021033961206212, 0.19656331883651046, 0.18378170887611545, 0.16663952273355953, 0.20934688566542048, 0.21644061875537368, 0.009288741866400052, 0.008648687482101014, 0.0172027652461324, 0.003468590876798072, 0.028657779980205467, 0.033857296604046905, 0.004853600075335973, 0.020601733360457675, 0.014256638679953748, 0.07959962040561352, 0.11222089397641188, 0.10220558284292669, 0.0947907436727412, 0.1097400086937973, 0.12359272051883619, 0.10030793419947626, 0.13215139382495, 0.12266587450106547, 0.3538818267828008, 0.3819505555077213, 0.3967085022519914, 0.3653565886063256, 0.3953270489977122, 0.3839524415974406, 0.3523878133153082, 0.3868874601194816, 0.3874707900971529, 0.07418196193898052, 0.08013914959849822, 0.08638157912499955, 0.06898418013411833, 0.08397670374245392, 0.06684761165865438, 0.07149772489046735, 0.07877680065283388, 0.07090477385329064, 0.12174235805051481, 0.14796338078303872, 0.11836599848965157, 0.1233473149439187, 0.13151696408901425, 0.1287746957906718, 0.12664754444903648, 0.13574707441597222, 0.12394670838518196, 0.23282747351490463, 0.23247605223280499, 0.24542603452054812, 0.21249431794918827, 0.22910618093727853, 0.2380774066421062, 0.2251174615918199, 0.25065562592710733, 0.24232274704021972, 0.17018213469530108, 0.18482744376966231, 0.1834997583671124, 0.17295044770373247, 0.16077953700602754, 0.1847624001556344, 0.1653973910115386, 0.1943361744357639, 0.1991702819694785, 0.1761167290090465, 0.16098626499539093, 0.19919914404231243, 0.166937565436862, 0.17769323728209163, 0.16401680355882964, 0.17888327945577043, 0.18439244219118622, 0.18057870798504916, 0.1667682191112132, 0.16387854020210002, 0.1682973253380855, 0.16907174215720022, 0.16316901462774136, 0.16615797156856915, 0.16362752817135118, 0.15851699439866263, 0.1610808799324639, 0.16468839873350283, 0.15399095912548622, 0.344032297560102, 0.24791278081871004, 0.3435883285613899, 0.2198346066499718, 0.17305187834199243, 0.13801143810473893, 0.31243435171547196, 0.26340662719778607, 0.1811883970770919, 0.17916056604116515, 0.2955919570365775, 0.2042115892150016, 0.26294945622078036, 0.17501480740110964, 0.20222905284711323, 0.1830114643646198, 0.17550517383700148, 0.1863890050168603, 0.1723009861913335, 0.19186257326184142, 0.1654959362005769, 0.17622476577207125, 0.17333506450771052, 0.17824072556528192, 0.176999206886721, 0.07306944330061416, 0.06853166010556488, 0.06594671525127593, 0.05845890957800548, 0.058624784505173166, 0.061164082131380026, 0.06503327781295953, 0.0634451664319986, 0.061238715507766384]}, "mutation_prompt": null}
{"id": "46d79b8f-dc77-4247-b44f-9f6c4f8e67f2", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim  # Change: Adaptive crossover probability\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        # Change: Adaptive differential weight\n        progress_ratio = self.current_budget / self.budget\n        adaptive_diff_weight = self.diff_weight * (1 - progress_ratio)\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        # Change: Fine-tune adaptive step size with decay factor\n        decay_factor = 0.8 ** (self.current_budget / self.budget)\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - self.current_budget / self.budget) * decay_factor)\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0  # Track successful mutations\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1  # Count successful improvements\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:  # Adaptive adjustment based on success\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Fine-tune adaptive step size by incorporating a dynamic decay factor based on budget utilization.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8f8aa8ae-8840-4c20-ba55-2329d5cf81fc", "metadata": {"aucs": [0.3722164809424553, 0.4059517421757278, 0.40915478316521803, 0.41075097062777044, 0.4300815433682904, 0.38147983543403274, 0.37978949973331677, 0.42096510315282243, 0.4311318548700632, 0.1333383254611339, 0.13062541417226148, 0.1249799312514186, 0.1092248520318142, 0.14161614981629878, 0.15136368485925455, 0.12797270677140937, 0.1623686784241296, 0.12222707036963798, 0.09032084514833028, 0.08409052990561905, 0.08893295757845976, 0.07223545499536688, 0.07352861380174058, 0.07476471176259658, 0.07100638444760166, 0.0888216660341048, 0.08745887150021825, 0.0813247085460147, 0.07237220631516961, 0.0639015734589119, 0.058639795962229124, 0.06859607618750085, 0.06059643318093677, 0.0652799893787962, 0.06703564354031155, 0.07254563510085099, 0.860745715778715, 0.8421565523661733, 0.9259715569440841, 0.8748545713613982, 0.8541109225604552, 0.9277037600900402, 0.8101701414183778, 0.8457773585985755, 0.82337333394526, 0.17279030634900083, 0.20470450177724575, 0.16644922282383812, 0.18077087910742484, 0.18795759146755986, 0.1715284445233043, 0.19020963408452407, 0.16265931315676985, 0.23314045390928684, 0.26819921041071515, 0.28952014326059283, 0.325191903547575, 0.3462476342250024, 0.452670351638915, 0.44134183624526035, 0.36345758469233036, 0.4408851588671536, 0.39333682925335656, 0.08230815169291505, 0.11558442086303, 0.10702508321906246, 0.09854761928431943, 0.10910463698001516, 0.11204825605969215, 0.10350721132572505, 0.1432820660668549, 0.11782147842618529, 0.07923949145462206, 0.1312309554845964, 0.07463898836748817, 0.11263648661668535, 0.13581536565753372, 0.09409243005824042, 0.10573830090210667, 0.11730956890614253, 0.09589736816542149, 0.06527720496169676, 0.08250863652488405, 0.09023002889743947, 0.08599551102050318, 0.10537414788084842, 0.1161051345780566, 0.08090480790188526, 0.1041991240905964, 0.10108985077281252, 0.16191696234499342, 0.21675604713536933, 0.21251299724044626, 0.18021033961206212, 0.19656331883651046, 0.18378170887611545, 0.16663952273355953, 0.20934688566542048, 0.21644061875537368, 0.009288741866400052, 0.008648687482101014, 0.0172027652461324, 0.003468590876798072, 0.028657779980205467, 0.033857296604046905, 0.004853600075335973, 0.020601733360457675, 0.014256638679953748, 0.07959962040561352, 0.11222089397641188, 0.10220558284292669, 0.0947907436727412, 0.1097400086937973, 0.12359272051883619, 0.10030793419947626, 0.13215139382495, 0.12266587450106547, 0.3538818267828008, 0.3819505555077213, 0.3967085022519914, 0.3653565886063256, 0.3953270489977122, 0.3839524415974406, 0.3523878133153082, 0.3868874601194816, 0.3874707900971529, 0.07418196193898052, 0.08013914959849822, 0.08638157912499955, 0.06898418013411833, 0.08397670374245392, 0.06684761165865438, 0.07149772489046735, 0.07877680065283388, 0.07090477385329064, 0.12174235805051481, 0.14796338078303872, 0.11836599848965157, 0.1233473149439187, 0.13151696408901425, 0.1287746957906718, 0.12664754444903648, 0.13574707441597222, 0.12394670838518196, 0.23282747351490463, 0.23247605223280499, 0.24542603452054812, 0.21249431794918827, 0.22910618093727853, 0.2380774066421062, 0.2251174615918199, 0.25065562592710733, 0.24232274704021972, 0.17018213469530108, 0.18482744376966231, 0.1834997583671124, 0.17295044770373247, 0.16077953700602754, 0.1847624001556344, 0.1653973910115386, 0.1943361744357639, 0.1991702819694785, 0.1761167290090465, 0.16098626499539093, 0.19919914404231243, 0.166937565436862, 0.17769323728209163, 0.16401680355882964, 0.17888327945577043, 0.18439244219118622, 0.18057870798504916, 0.1667682191112132, 0.16387854020210002, 0.1682973253380855, 0.16907174215720022, 0.16316901462774136, 0.16615797156856915, 0.16362752817135118, 0.15851699439866263, 0.1610808799324639, 0.16468839873350283, 0.15399095912548622, 0.344032297560102, 0.24791278081871004, 0.3435883285613899, 0.2198346066499718, 0.17305187834199243, 0.13801143810473893, 0.31243435171547196, 0.26340662719778607, 0.1811883970770919, 0.17916056604116515, 0.2955919570365775, 0.2042115892150016, 0.26294945622078036, 0.17501480740110964, 0.20222905284711323, 0.1830114643646198, 0.17550517383700148, 0.1863890050168603, 0.1723009861913335, 0.19186257326184142, 0.1654959362005769, 0.17622476577207125, 0.17333506450771052, 0.17824072556528192, 0.176999206886721, 0.07306944330061416, 0.06853166010556488, 0.06594671525127593, 0.05845890957800548, 0.058624784505173166, 0.061164082131380026, 0.06503327781295953, 0.0634451664319986, 0.061238715507766384]}, "mutation_prompt": null}
{"id": "54749629-0f63-4f76-bd3e-2338db9a1c6e", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim  # Change: Adaptive crossover probability\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        # Change: Adaptive differential weight\n        progress_ratio = self.current_budget / self.budget\n        adaptive_diff_weight = self.diff_weight * (1 - progress_ratio)\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        # Change: Fine-tune adaptive step size with decay factor\n        decay_factor = 0.8 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2  # Added secondary decay\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - self.current_budget / self.budget) * decay_factor * secondary_decay)  # Incorporating secondary decay\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0  # Track successful mutations\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1  # Count successful improvements\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:  # Adaptive adjustment based on success\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Enhance convergence by introducing a secondary decay factor to adaptively refine step size progressively through iterations, maintaining precision.", "configspace": "", "generation": 39, "fitness": 0.1999643756118489, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.17.", "error": "", "parent_id": "8f8aa8ae-8840-4c20-ba55-2329d5cf81fc", "metadata": {"aucs": [0.35043018574328366, 0.40129377308942915, 0.4183642956653928, 0.4154744163553409, 0.4527023764466337, 0.41283701076829193, 0.4470521696967289, 0.41495753779453926, 0.43156587547711867, 0.12117655482302292, 0.1689218432404892, 0.14577076203531447, 0.11451892511388961, 0.16660907398483016, 0.13574604836847248, 0.12960936311109583, 0.14129333424369162, 0.16635984533370296, 0.08083394123138865, 0.08674150693423621, 0.0771207745454705, 0.07702349536237985, 0.07474853365513079, 0.08494733043770086, 0.07682452388127314, 0.08784422810336423, 0.08446841582446452, 0.06698952176143758, 0.06448864217337835, 0.06417559493158365, 0.06024842504426464, 0.06425776239037728, 0.07329027644272557, 0.07936955495639597, 0.05640889546760153, 0.07306123308354384, 0.8200792272141813, 0.8439755575807177, 0.9259391288966861, 0.8590772617300406, 0.8676080942035538, 0.8900419863883173, 0.7673715944851769, 0.8945814110315459, 0.8122741048480921, 0.15964823177780474, 0.17707474221517694, 0.15821564177477687, 0.17357246831046902, 0.19950201725616512, 0.17237993152471354, 0.17651878393310994, 0.21214849637604416, 0.2178954835535889, 0.4431771238833787, 0.47451995476734876, 0.4050240956465587, 0.2973426380730475, 0.40835991436027885, 0.3615141818229508, 0.30633565060712575, 0.30091521898118434, 0.4185833541163002, 0.10267825090189198, 0.09390699960961735, 0.10323700557019255, 0.10197570530870748, 0.10644168754253647, 0.12721516731764004, 0.09824530308734303, 0.12724492564842727, 0.10453669848239389, 0.16674426999509684, 0.12832735922791638, 0.10306683252587279, 0.09877455606672159, 0.11645380365046387, 0.11985031706162685, 0.10058486801676503, 0.15182058592321301, 0.10647903677181858, 0.09769619595432089, 0.09583374206767403, 0.07323129824124985, 0.09154780918196448, 0.09746419103737247, 0.1086514235863133, 0.0702765535792167, 0.09251618666126393, 0.10589033204202347, 0.18552642326134539, 0.21696026728510986, 0.1981766212738043, 0.1766743055993939, 0.19862598540115273, 0.2014637338513222, 0.16961064189935604, 0.18732561184624807, 0.2387088854046172, 0.010769443723423144, 0.015981052975688526, 0.024671095520396147, 0.005649717016890654, 0.02338740091544389, 0.021071016880269022, 0.006142125325192316, 0.02992371199660593, 0.019695242023232473, 0.09750679395022144, 0.09393830159380068, 0.11475001760629566, 0.09867981391054093, 0.11480315087130788, 0.10827600511458402, 0.09714605433840084, 0.13744564059321185, 0.1327087250217237, 0.34804974084550144, 0.37111855093083146, 0.37322637332367015, 0.3719276360994026, 0.3928715508608771, 0.4027339888768394, 0.3642356083730943, 0.4047325128006126, 0.38421740550957595, 0.08411831217922294, 0.07839490879476485, 0.06841034741363416, 0.10554666973768123, 0.08709297686155337, 0.080683262227641, 0.07058654977477419, 0.06401657591081533, 0.06214510011593466, 0.13538381484630735, 0.13327156707722987, 0.12602782858645556, 0.1433778292145389, 0.1240361114102656, 0.14895071329393272, 0.14496058776593568, 0.1708107432433793, 0.12332627351064618, 0.2256064563971225, 0.2415532962709097, 0.2428660901500812, 0.23571914051741938, 0.22634110865784685, 0.22904618732443172, 0.22449251167033935, 0.23584793168409957, 0.2488572576837489, 0.16790260241196941, 0.19284220363182203, 0.1895733799431074, 0.17437225674237744, 0.18061151514848517, 0.17315884588878017, 0.1803729183721, 0.19046222314022032, 0.18320975430543962, 0.1812923080879646, 0.17496632692011338, 0.18790781391245892, 0.17964701119846027, 0.16166969927169106, 0.19274540203815227, 0.17106799185381638, 0.1682794804957526, 0.2166587265148292, 0.17091305907552357, 0.16252651055533074, 0.15731091118497975, 0.15862613139467252, 0.16490247967385818, 0.16609385661740994, 0.18554179196490517, 0.16588716901691736, 0.1625140615608196, 0.14529696296183758, 0.24992335066281157, 0.39860510327467, 0.17432361348890058, 0.3149998406813749, 0.17836897759947534, 0.15625400232023023, 0.1558201748616852, 0.3338437379471957, 0.17420986550049455, 0.18484363808514048, 0.18888943261316749, 0.14639924962583717, 0.22488323325047277, 0.17956190301525787, 0.18696781730552214, 0.19742873076735112, 0.183055899054399, 0.1751017489632659, 0.17297184533672283, 0.17313460579733042, 0.18931767773654862, 0.18766049620184755, 0.19104417430834875, 0.17008705019929315, 0.1871849672348459, 0.1883899452093165, 0.06173735193490104, 0.07422556383616497, 0.06434079248503854, 0.07046777492615963, 0.07009737427002272, 0.06403343521106508, 0.07204417611705505, 0.07801756574377028, 0.0656218696332238]}, "mutation_prompt": null}
{"id": "996ab13d-c424-4aec-b272-19f3fa2eebfc", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim  # Change: Adaptive crossover probability\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        # Change: Dynamic selection of differential vectors based on success rate\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()  # Random success rate simulation\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)  # Use success rate for adaptation\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        # Change: Fine-tune adaptive step size with decay factor\n        decay_factor = 0.8 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2  # Added secondary decay\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - self.current_budget / self.budget) * decay_factor * secondary_decay)  # Incorporating secondary decay\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0  # Track successful mutations\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1  # Count successful improvements\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:  # Adaptive adjustment based on success\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Refine mutation by introducing dynamic selection of differential vectors based on the success rate to enhance global exploration.", "configspace": "", "generation": 40, "fitness": 0.2369039889089646, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.19.", "error": "", "parent_id": "54749629-0f63-4f76-bd3e-2338db9a1c6e", "metadata": {"aucs": [0.45019780492227557, 0.39872298686111307, 0.5512007850750056, 0.4907108991084419, 0.35201050446422655, 0.49273087953218564, 0.4195022277662651, 0.45043935236056964, 0.36786284522290247, 0.10304825806188234, 0.20632000737717227, 0.13175893700050367, 0.10047662736854124, 0.09351412056619879, 0.09649148420463116, 0.12599569210419015, 0.055176343007779516, 0.1778946003487616, 0.11206839980161476, 0.10201210159833685, 0.10727209454269848, 0.09693505982405426, 0.10996903192588214, 0.10690698493902495, 0.10687876420978715, 0.10501557983750043, 0.10948121744955586, 0.1033452640237088, 0.08719040815061418, 0.08320104485577284, 0.10235759232511243, 0.08052270131550288, 0.11288062343773453, 0.09287542025720463, 0.12031152716337279, 0.08425823559152468, 0.847735558572976, 0.8842000369788117, 0.8471963055554016, 0.8689125124229111, 0.877012304848979, 0.8355210620822131, 0.8876320891652854, 0.8881225917799758, 0.9137693827045603, 0.16424288493607997, 0.15686598716376943, 0.1496476687756818, 0.17744033392160785, 0.14934540858154488, 0.13475109144432396, 0.19603258471512175, 0.13816507309304704, 0.16025757844764144, 0.3076460448436623, 0.5956197224897184, 0.2591793260189017, 0.691736843513968, 0.7566133225460389, 0.7338857934313239, 0.22627424850416245, 0.21859340396839744, 0.31099603519616825, 0.2578493494939933, 0.21271278719331344, 0.12892555186560217, 0.11751214344991678, 0.15831626362123785, 0.12835002459431288, 0.12026299748403313, 0.12528066457735565, 0.11858644060708268, 0.18096302169947187, 0.14381258103324635, 0.10177169777889705, 0.12826120699550525, 0.11672447452130086, 0.12528311506426892, 0.1073817434638542, 0.10530539293947727, 0.12477609693277658, 0.21004353354172167, 0.2514121708223419, 0.22747986417683774, 0.1154493313470657, 0.217448633525139, 0.09795819399663885, 0.22839433440458334, 0.13040208090865812, 0.16513838172776685, 0.2699329356174388, 0.20714082819448898, 0.1806817327735647, 0.2596607441366181, 0.11867669369644318, 0.16109069076829563, 0.3935650006760132, 0.34414774750842103, 0.28696036903682565, 0.061349036414170444, 9.999999999998899e-05, 0.05884760608448103, 0.11447448946850325, 0.0636733294831201, 0.1140584410242913, 0.06459436765206805, 0.0737075577025389, 0.05103759603999736, 0.14140498656522138, 0.16686150602523064, 0.06810879429088268, 0.14974005248142208, 0.08336761189533959, 0.15024240732363436, 0.11525066769211312, 0.18908425189171885, 0.13702055808522784, 0.49773438536866466, 0.5381367294925086, 0.4175662526443418, 0.36808095261414, 0.4810513872179657, 0.40294265954798736, 0.44633195295573214, 0.3941737214205009, 0.33095039109903346, 0.09319048470259728, 0.09736349949768641, 0.1052645019705325, 0.08663351146390086, 0.09101851005823869, 0.0926946263389169, 0.11029664018007002, 0.09290185709699528, 0.11592058398708394, 0.14759036002294867, 0.15397325014663032, 0.27510198081176873, 0.19096247340514916, 0.14124783598756152, 0.17000245487251997, 0.18657846204764383, 0.2036196603833591, 0.17131599992869562, 0.2783244611640704, 0.26842479257457885, 0.34192781557370633, 0.29593646254527517, 0.26691706769071444, 0.30305213667214626, 0.3294178705704657, 0.31138878980708085, 0.3143148497708168, 0.19777102685208525, 0.22225166558524467, 0.2210304120573624, 0.2558136918636278, 0.25883578076430647, 0.2618457657762717, 0.19624046669282091, 0.2271333143002886, 0.23656737991368393, 0.1825241387212745, 0.21691251756032426, 0.19292042233199747, 0.17506458860526652, 0.18850977750694176, 0.2062492510327797, 0.1902684372005462, 0.18397790711713446, 0.19448229799140315, 0.1872132047116053, 0.18453030611012966, 0.1938127887447233, 0.19406501038195734, 0.2090394057144216, 0.19716387685142478, 0.17828845186312248, 0.17571110505469334, 0.1854506423930311, 0.18024549358740483, 0.5024572824230122, 0.1647961817833331, 0.46697347534536315, 0.4206683743471872, 0.1588360805629363, 0.3675120862944091, 0.18590189159322312, 0.6696657925481779, 0.5299876628211931, 0.24254269751833002, 0.22119475655262855, 0.4773357677966603, 0.16171560417498043, 0.3984391705949363, 0.15065926033877164, 0.25266977026990767, 0.20186988757639102, 0.18641583482710544, 0.18068525231667043, 0.19581957817704965, 0.20581908771424062, 0.18266591868779491, 0.17696004213093386, 0.18720423155886856, 0.1896633531310017, 0.17655533301210657, 0.08082750546977935, 0.07788260535901792, 0.0787821310622756, 0.06752175676442262, 0.07089317767663017, 0.06915373505255562, 0.07904117057938476, 0.07736692071930207, 0.07299604603948262]}, "mutation_prompt": null}
{"id": "79c41319-e188-4043-9af5-fefcdd873c3c", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim  # Change: Adaptive crossover probability\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        # Change: Dynamic selection of differential vectors based on success rate\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()  # Random success rate simulation\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)  # Use success rate for adaptation\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        # Change: Fine-tune adaptive step size with decay factor\n        decay_factor = 0.8 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2  # Added secondary decay\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - self.current_budget / self.budget) * decay_factor * secondary_decay)  # Incorporating secondary decay\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0  # Track successful mutations\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1  # Count successful improvements\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:  # Adaptive adjustment based on success\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Refine mutation by introducing dynamic selection of differential vectors based on the success rate to enhance global exploration.", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "996ab13d-c424-4aec-b272-19f3fa2eebfc", "metadata": {"aucs": [0.45019780492227557, 0.39872298686111307, 0.5512007850750056, 0.4907108991084419, 0.35201050446422655, 0.49273087953218564, 0.4195022277662651, 0.45043935236056964, 0.36786284522290247, 0.10304825806188234, 0.20632000737717227, 0.13175893700050367, 0.10047662736854124, 0.09351412056619879, 0.09649148420463116, 0.12599569210419015, 0.055176343007779516, 0.1778946003487616, 0.11206839980161476, 0.10201210159833685, 0.10727209454269848, 0.09693505982405426, 0.10996903192588214, 0.10690698493902495, 0.10687876420978715, 0.10501557983750043, 0.10948121744955586, 0.1033452640237088, 0.08719040815061418, 0.08320104485577284, 0.10235759232511243, 0.08052270131550288, 0.11288062343773453, 0.09287542025720463, 0.12031152716337279, 0.08425823559152468, 0.847735558572976, 0.8842000369788117, 0.8471963055554016, 0.8689125124229111, 0.877012304848979, 0.8355210620822131, 0.8876320891652854, 0.8881225917799758, 0.9137693827045603, 0.16424288493607997, 0.15686598716376943, 0.1496476687756818, 0.17744033392160785, 0.14934540858154488, 0.13475109144432396, 0.19603258471512175, 0.13816507309304704, 0.16025757844764144, 0.3076460448436623, 0.5956197224897184, 0.2591793260189017, 0.691736843513968, 0.7566133225460389, 0.7338857934313239, 0.22627424850416245, 0.21859340396839744, 0.31099603519616825, 0.2578493494939933, 0.21271278719331344, 0.12892555186560217, 0.11751214344991678, 0.15831626362123785, 0.12835002459431288, 0.12026299748403313, 0.12528066457735565, 0.11858644060708268, 0.18096302169947187, 0.14381258103324635, 0.10177169777889705, 0.12826120699550525, 0.11672447452130086, 0.12528311506426892, 0.1073817434638542, 0.10530539293947727, 0.12477609693277658, 0.21004353354172167, 0.2514121708223419, 0.22747986417683774, 0.1154493313470657, 0.217448633525139, 0.09795819399663885, 0.22839433440458334, 0.13040208090865812, 0.16513838172776685, 0.2699329356174388, 0.20714082819448898, 0.1806817327735647, 0.2596607441366181, 0.11867669369644318, 0.16109069076829563, 0.3935650006760132, 0.34414774750842103, 0.28696036903682565, 0.061349036414170444, 9.999999999998899e-05, 0.05884760608448103, 0.11447448946850325, 0.0636733294831201, 0.1140584410242913, 0.06459436765206805, 0.0737075577025389, 0.05103759603999736, 0.14140498656522138, 0.16686150602523064, 0.06810879429088268, 0.14974005248142208, 0.08336761189533959, 0.15024240732363436, 0.11525066769211312, 0.18908425189171885, 0.13702055808522784, 0.49773438536866466, 0.5381367294925086, 0.4175662526443418, 0.36808095261414, 0.4810513872179657, 0.40294265954798736, 0.44633195295573214, 0.3941737214205009, 0.33095039109903346, 0.09319048470259728, 0.09736349949768641, 0.1052645019705325, 0.08663351146390086, 0.09101851005823869, 0.0926946263389169, 0.11029664018007002, 0.09290185709699528, 0.11592058398708394, 0.14759036002294867, 0.15397325014663032, 0.27510198081176873, 0.19096247340514916, 0.14124783598756152, 0.17000245487251997, 0.18657846204764383, 0.2036196603833591, 0.17131599992869562, 0.2783244611640704, 0.26842479257457885, 0.34192781557370633, 0.29593646254527517, 0.26691706769071444, 0.30305213667214626, 0.3294178705704657, 0.31138878980708085, 0.3143148497708168, 0.19777102685208525, 0.22225166558524467, 0.2210304120573624, 0.2558136918636278, 0.25883578076430647, 0.2618457657762717, 0.19624046669282091, 0.2271333143002886, 0.23656737991368393, 0.1825241387212745, 0.21691251756032426, 0.19292042233199747, 0.17506458860526652, 0.18850977750694176, 0.2062492510327797, 0.1902684372005462, 0.18397790711713446, 0.19448229799140315, 0.1872132047116053, 0.18453030611012966, 0.1938127887447233, 0.19406501038195734, 0.2090394057144216, 0.19716387685142478, 0.17828845186312248, 0.17571110505469334, 0.1854506423930311, 0.18024549358740483, 0.5024572824230122, 0.1647961817833331, 0.46697347534536315, 0.4206683743471872, 0.1588360805629363, 0.3675120862944091, 0.18590189159322312, 0.6696657925481779, 0.5299876628211931, 0.24254269751833002, 0.22119475655262855, 0.4773357677966603, 0.16171560417498043, 0.3984391705949363, 0.15065926033877164, 0.25266977026990767, 0.20186988757639102, 0.18641583482710544, 0.18068525231667043, 0.19581957817704965, 0.20581908771424062, 0.18266591868779491, 0.17696004213093386, 0.18720423155886856, 0.1896633531310017, 0.17655533301210657, 0.08082750546977935, 0.07788260535901792, 0.0787821310622756, 0.06752175676442262, 0.07089317767663017, 0.06915373505255562, 0.07904117057938476, 0.07736692071930207, 0.07299604603948262]}, "mutation_prompt": null}
{"id": "8298dd63-3ff2-48b3-a696-5778fe5e06e3", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim  # Change: Adaptive crossover probability\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()  # Random success rate simulation\n        # Change: Adaptive differential weight using population diversity\n        diversity = np.mean(np.std(population, axis=0))  # Added population diversity measure\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate) * diversity / 2  # Adjusted adaptation factor with diversity\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.8 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - self.current_budget / self.budget) * decay_factor * secondary_decay)\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Introduce a novel adaptive mutation scale using population diversity to improve convergence balance.", "configspace": "", "generation": 42, "fitness": 0.1736054734157642, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.17.", "error": "", "parent_id": "996ab13d-c424-4aec-b272-19f3fa2eebfc", "metadata": {"aucs": [0.2999865223915059, 0.24532638162883114, 0.304519800009167, 0.30371626320290135, 0.26000095863982986, 0.25973845076760127, 0.2463746168123968, 0.27063666799097374, 0.2649678137280075, 0.09057686065467774, 9.999999999998899e-05, 9.999999999998899e-05, 0.024073253483348545, 9.999999999998899e-05, 9.999999999998899e-05, 0.005063711279886918, 9.999999999998899e-05, 0.00960093512438509, 0.10825956596373054, 0.10479811466256428, 0.0956771936247649, 0.10283946844706093, 0.10133834238840067, 0.10704096388351247, 0.09481450484819565, 0.10395675116381664, 0.09184804327996066, 0.08936169343988243, 0.0887461916777198, 0.0745050018825274, 0.0941342732216166, 0.08399342638652307, 0.07414261391222643, 0.10260381182303768, 0.07733351450803116, 0.09102143682059993, 0.8716758837991407, 0.8838215821224606, 0.7940243089121246, 0.8648485636183496, 0.902482729637963, 0.8887954859745293, 0.8438347412410545, 0.8581580114666821, 0.9236829016370125, 0.1506445399363553, 0.13308312159689117, 0.15348046047016417, 0.13434895086016418, 0.13440627416277273, 0.1348602794784982, 0.13993395046191615, 0.17128581494296136, 0.13552320358746706, 0.2479554664389254, 0.20818556950534994, 0.23199245694481363, 0.3120502232671474, 0.22704809002416237, 0.20596190621130894, 0.23570665850438666, 0.20769671143656665, 0.20784454592882273, 0.08173029716361946, 0.1392983225903408, 0.08696576734748962, 0.101904933832479, 0.09526893832696148, 0.09936393911565466, 0.09038081623948324, 0.09034938126959224, 0.09877233583297906, 0.027553312861136825, 0.05792238218371659, 0.09138804036668913, 0.15424641965874997, 0.0860364727799301, 0.07829115534353226, 0.08201026297376102, 0.11177200218434213, 0.08073923359795177, 0.028305360600076157, 9.999999999998899e-05, 9.999999999998899e-05, 0.004895600802621636, 9.999999999998899e-05, 0.0418905535704569, 9.999999999998899e-05, 9.999999999998899e-05, 0.05932884735226385, 0.14614990028464037, 0.17522989841813796, 0.1534182973001823, 0.16764144945950243, 0.13512450305826695, 0.07044793342617728, 0.16756671634982556, 0.13833814220620866, 0.19023980957144848, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.025706752612282946, 0.0306993150898337, 0.04204231047265716, 0.0417128409204619, 0.020436149333195708, 0.03957037493462612, 0.0786730580025764, 0.037536907097250105, 0.061016054409065545, 0.3299723653649098, 0.27137884115819144, 0.2788924320287919, 0.2413075806418531, 0.2530894021111244, 0.28155007144903543, 0.26356585341965655, 0.2355789730713087, 0.2765233104963133, 0.11787032319769242, 0.10424136696215569, 0.11319747469091856, 0.1323162944587819, 0.09249783593714733, 0.08391042858300424, 0.12077033795152603, 0.10301530444592732, 0.11231547015015353, 0.14586953276071013, 0.18410443227289608, 0.14760094841929716, 0.1463674214124936, 0.17991201249965794, 0.1526527570873677, 0.14665299033690826, 0.15776799666454244, 0.14689944541830158, 0.23070234192139227, 0.2177204419243396, 0.20659406602866937, 0.24597778217317334, 0.21078873303828627, 0.21471957145078802, 0.22009713609955983, 0.24775229983199065, 0.23002335005192698, 0.19758967520359105, 0.184423012183487, 0.17978435900473755, 0.16204775218265222, 0.16731596545292027, 0.21880620827792052, 0.17253481902921464, 0.17696337990878697, 0.18335365178360963, 0.18780966102845498, 0.19477015628713423, 0.21165013880711303, 0.21343188249620448, 0.18974352677846285, 0.1959949066279425, 0.1948410388212054, 0.19212536682351922, 0.20936187829924013, 0.20269439198580186, 0.17685439064627406, 0.1944059959339416, 0.18751643287675201, 0.16868973407295285, 0.18215935753664403, 0.18429831365228133, 0.17804614184310463, 0.18264193530251727, 0.2865596375942654, 0.17909345019064982, 0.32757723371953884, 0.34731088074221117, 0.16438360416613373, 0.2717766217622105, 0.1745961354189307, 0.1774323774642882, 0.32540504606397247, 0.3360234205978957, 0.1611579262932874, 0.1730648758497777, 0.34901748928983967, 0.15202855856842123, 0.18900021125241917, 0.19179578036876277, 0.1922099690075223, 0.18854656235774614, 0.18524269721513598, 0.18218550041583614, 0.18770564794337086, 0.2046582043550632, 0.17374659032334872, 0.1817759625258184, 0.18547757442819413, 0.17534118180162517, 0.19323541690142387, 0.08936419247949157, 0.08398840637110316, 0.07640283188065877, 0.08100625781456017, 0.08034144602615012, 0.0749769286933668, 0.07383694853900924, 0.080203669172903, 0.08206765309703545]}, "mutation_prompt": null}
{"id": "fdff702c-2e7c-4699-bc6e-b05edbf546df", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim  # Change: Adaptive crossover probability\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n        self.prev_best_fitness = np.inf  # Track previous best fitness for trend analysis\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        # Change: Incorporate historical fitness trends in differential vectors\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()  # Random success rate simulation\n        fitness_trend_factor = (self.prev_best_fitness / (np.min([self.prev_best_fitness, success_rate]) + 1e-8))\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate) * fitness_trend_factor\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cross_prob\n        return np.where(crossover_mask, mutant, target)\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        # Change: Fine-tune adaptive step size with decay factor\n        decay_factor = 0.8 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2  # Added secondary decay\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - self.current_budget / self.budget) * decay_factor * secondary_decay)  # Incorporating secondary decay\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0  # Track successful mutations\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1  # Count successful improvements\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:  # Adaptive adjustment based on success\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n            self.prev_best_fitness = np.min(fitness)  # Update the previous best fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Improve adaptive mutation by incorporating historical fitness trends for enhanced convergence efficiency.", "configspace": "", "generation": 43, "fitness": 0.13961793658982696, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.22.", "error": "", "parent_id": "996ab13d-c424-4aec-b272-19f3fa2eebfc", "metadata": {"aucs": [0.08690037957988939, 0.11915176840811714, 0.09810631771111511, 0.14301449786188059, 0.12942577566656221, 0.15341582201752824, 0.5277331698665932, 0.377003439916173, 0.42000132435012283, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08860635803521, 0.10347063634998088, 0.1001174232635671, 0.021460712578131647, 0.020380878003109282, 0.020327931527773235, 0.011701727698624764, 0.018965915282791346, 0.020989363718549092, 0.09518993575255974, 0.09641134031814069, 0.0949932523899164, 0.015044457170342085, 9.999999999998899e-05, 0.015032598516230289, 0.013342462913590092, 9.999999999998899e-05, 0.005325319250480631, 0.9925166911149629, 0.9930826372841608, 0.9921994641327264, 0.9679550260058263, 0.9951510735995639, 0.95912274071507, 0.9655760812134319, 0.9868282893671106, 0.9267695670194501, 0.020074907247734863, 0.04852903053099322, 0.03435645830257417, 0.017004810209515053, 0.01894344985713181, 0.009567586151641216, 0.163695772947837, 0.25151888207493955, 0.16434088653639778, 0.053481527489213865, 0.036598934645393766, 0.05455755570284071, 0.13342663240878028, 0.08571659395621467, 0.10653704612395543, 0.125062274360765, 0.1017849821065191, 0.14856084502643951, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11266623688657151, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006199598888574465, 0.002445800426599476, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05756945738234809, 0.0021534634116913143, 0.004244038010810636, 0.054543312465934135, 0.0201203799618761, 0.035285898785631487, 0.02368470051398841, 0.014304295791982113, 0.02263806224386211, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08222060528908859, 0.17727121724342376, 0.13229810380616147, 0.4395848412483577, 0.5157777886729753, 0.4883785269230799, 0.5031959367289142, 0.5090964419696993, 0.4229359297095864, 0.13956297646025362, 0.14728899558277886, 0.12413319615956131, 0.05387622734292474, 0.02505618800461884, 0.03715214555120128, 0.0190667144323885, 0.01038817225146138, 0.025903876894395994, 0.0953726660682025, 0.0470660574385493, 0.07264599637681768, 0.16648267484647983, 0.14045191481323094, 0.13405128535055044, 0.17739793978582397, 0.18559899155053083, 0.1659946521818383, 0.15077766855509434, 0.13608955174502202, 0.12127816010810843, 0.29165832514069145, 0.31741411580273593, 0.30209513025117507, 0.16146105386065812, 0.13647103299885965, 0.1437433834557833, 0.1378157433840833, 0.13963220508816, 0.12066783176361628, 0.16538281671613642, 0.2344040162810752, 0.17539587312168625, 0.09360377004933196, 0.08678648605771155, 0.08371312651554996, 0.07349928344662016, 0.06777246481582189, 0.08488585514185087, 0.18535201336137597, 0.20008598431452929, 0.20536008542664652, 0.13934620731510006, 0.12040313019147542, 0.12527307012230704, 0.1278977552812388, 0.0982138301418981, 0.16648128963766595, 0.17700377224437092, 9.999999999998899e-05, 0.1826177722271033, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.15351834485261062, 0.13943408131036505, 0.1316852767103064, 0.1524565010899701, 0.17386795171007796, 0.1702089813273373, 0.6187560839231617, 0.5192229532532386, 0.18918839042522728, 0.32788485107207677, 0.18825509380728733, 0.3532747893032039, 0.06262732960162354, 0.06445154136947728, 0.07886795318082473, 0.2884244353300812, 0.5945254154321394, 0.503642624422483, 0.16817651570360126, 0.17194359180101915, 0.17859320166232007, 0.2041057528788931, 0.21168834224824362, 0.1808426478779307, 0.1822805569547632, 0.1826145464591724, 0.18916911867486919, 0.0337054392580729, 0.022173145592272014, 0.024599456964539468, 0.025188584234478895, 0.02906249411625228, 0.026200138543616802, 0.057303757127379895, 0.03245304445502717, 0.02562070443425868]}, "mutation_prompt": null}
{"id": "ab721750-ba94-4164-941c-225085b96ff8", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim  # Change: Adaptive crossover probability\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        # Change: Dynamic selection of differential vectors based on success rate\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()  # Random success rate simulation\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)  # Use success rate for adaptation\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        # Change: Probabilistic selection of crossover strategy based on success rate\n        use_binomial = np.random.rand() < 0.5  # 50% chance to use binomial crossover\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < self.cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            # Arithmetic crossover as alternative strategy\n            return self.cross_prob * mutant + (1 - self.cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        # Change: Fine-tune adaptive step size with decay factor\n        decay_factor = 0.8 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2  # Added secondary decay\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - self.current_budget / self.budget) * decay_factor * secondary_decay)  # Incorporating secondary decay\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0  # Track successful mutations\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1  # Count successful improvements\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:  # Adaptive adjustment based on success\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Introduce probabilistic selection of crossover strategy based on success rate to enhance diversification.", "configspace": "", "generation": 44, "fitness": 0.25181533965206626, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.19.", "error": "", "parent_id": "996ab13d-c424-4aec-b272-19f3fa2eebfc", "metadata": {"aucs": [0.4940671153568892, 0.4052693274208542, 0.3866332811429306, 0.5655223182658036, 0.3955140261246959, 0.5660898325241357, 0.4088333627814049, 0.35534759895032353, 0.45452207191468175, 0.15282159470423506, 0.17774547489765335, 0.27992560942988753, 0.33973456704017757, 0.12060156958495172, 0.3380372095190757, 0.061860117210439935, 0.0860394626127936, 0.21356041822320282, 0.12722551354187894, 0.09246129248244839, 0.12056536199798351, 0.09892623282201696, 0.09728322573564108, 0.13112690221510825, 0.12904711711130312, 0.11592813866660168, 0.08263830469965927, 0.10502218522371554, 0.08733425262872041, 0.09147846876509935, 0.08017447013966417, 0.10768479632910799, 0.11382538607732917, 0.10440044401290671, 0.10562035928328062, 0.08928287064557738, 0.7581574412761943, 0.8445941637443714, 0.8837191368886816, 0.8311614778576445, 0.813009753609982, 0.8716435456953826, 0.8517715103677852, 0.8566703187103096, 0.8144291872874592, 0.13443116174242464, 0.16370022487667757, 0.13168122885904554, 0.18641317137086466, 0.1619852187949664, 0.18666559463284138, 0.15633849406947153, 0.17568831201274893, 0.2365843275049171, 0.33752963756146515, 0.22003367917305194, 0.723663855176075, 0.7183525366347641, 0.6968602910188818, 0.6564111575993454, 0.5603069741497335, 0.62295108820771, 0.30309380030408284, 0.17994217567257043, 0.12491000599776603, 0.12355759493713736, 0.15829180446513968, 0.2052313711514807, 0.12798313958776508, 0.138036209606063, 0.15467273283428729, 0.17002466798806837, 0.1735144474319804, 0.12736926021092765, 0.330285541256952, 0.1203790755880062, 0.20154373027689299, 0.22340463441171743, 0.2805317748216535, 0.1203723208379539, 0.12145545428458426, 0.11337474143523452, 0.10360143651877529, 0.04701956991426104, 0.22757065078401728, 0.14898953739701482, 0.05821161112511164, 0.10511332045152244, 0.07439585421256811, 0.07576235023650335, 0.502513982551319, 0.18913556571093226, 0.38257913286797496, 0.3315176905163999, 0.0770366183985548, 0.14850824622925396, 0.2616093220880006, 0.31024741673710166, 0.17104234854570566, 0.03995902954486574, 0.06466401041026382, 0.13035329395884787, 0.1101135033018954, 0.0702790199651665, 0.143487410425308, 0.08997841685298869, 9.999999999998899e-05, 0.06707340409265583, 0.2018583640116295, 0.13155858607724746, 0.1873855992113317, 0.15777789903653228, 0.1592561427769097, 0.23615082173176105, 0.16085847958831456, 0.21291383021585597, 0.14526288562315381, 0.45060415929891573, 0.4141810650027301, 0.45278653482093334, 0.4507994141060804, 0.4840277893812681, 0.457117644971649, 0.40015432827188013, 0.49643065620948157, 0.42446920800421506, 0.09282971288388686, 0.10931189702281097, 0.16344314993126186, 0.11470910650430555, 0.08546910855285916, 0.09989740669886082, 0.10695961948337285, 0.08502298569925693, 0.11728198741554374, 0.16143216543005146, 0.16598282966336397, 0.16234242535874, 0.212083464674389, 0.14311095635209603, 0.15146872837885728, 0.15468237391260176, 0.1606196202720961, 0.1785815792717398, 0.268700112442547, 0.2975526446414205, 0.29156631568336955, 0.30138415898780846, 0.31081578845889524, 0.29622793890085464, 0.2576859782634858, 0.2880617131118194, 0.29535592844959135, 0.25796811734577174, 0.28485972036376905, 0.2586601735920224, 0.24414606805748307, 0.23206920167590284, 0.24819434729127943, 0.23056351205403924, 0.3060474961014298, 0.23122010584331087, 0.18889705204042917, 0.22706962044810164, 0.19551890333316013, 0.228178513316473, 0.18152284108356842, 0.19050466078777295, 0.19309600644821, 0.1807037636961566, 0.19724582318375017, 0.20982302640207295, 0.17940515145904534, 0.19972095977829896, 0.20353998996724476, 0.18759441476731864, 0.2221836632104176, 0.1808829371169478, 0.19073705714823241, 0.18763107881005492, 0.18158943258063132, 0.699256345324277, 0.6693053134396436, 0.18304014680901104, 0.5333928216651322, 0.47015893953079624, 0.1562730359750918, 0.595882542722902, 0.5838664504279493, 0.4470038528034105, 0.20132347070019563, 0.20354576680242087, 0.3342361404617299, 0.1573780211058935, 0.322682079005863, 0.20304340968362156, 0.1988757694188804, 0.6617406286996409, 0.1814722916165472, 0.1843384511680607, 0.1832374552120567, 0.18047267446729243, 0.1713221451499457, 0.20063141811216934, 0.16971968794534553, 0.19624313105401736, 0.1746815768870883, 0.07692100475059238, 0.07846396928274246, 0.0820059179236925, 0.07501823108090755, 0.07896460331431776, 0.08502703837988701, 0.08804064503366082, 0.06374218349328153, 0.07931846786732344]}, "mutation_prompt": null}
{"id": "02db01a5-fb74-4cd4-baa7-f769c4e85dad", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        # Change: Introduce self-adaptive threshold for differential weight\n        if success_rate > 0.6:  \n            adaptive_diff_weight *= 1.2  # Increase weight\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < self.cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return self.cross_prob * mutant + (1 - self.cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.8 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - self.current_budget / self.budget) * decay_factor * secondary_decay)\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Improve mutation by dynamically adjusting differential weight using a novel self-adaptive threshold.", "configspace": "", "generation": 45, "fitness": 0.25982732897889826, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "ab721750-ba94-4164-941c-225085b96ff8", "metadata": {"aucs": [0.5845817369714541, 0.5936058681529965, 0.4374032310173165, 0.49675264767017147, 0.429532366787993, 0.5745960648756611, 0.5357931620061507, 0.563625345440322, 0.5713809825655867, 0.1735396824359341, 0.1213796376350178, 0.12070228239004044, 0.1381647621518276, 0.3177446636689014, 0.18737992221808597, 0.24293149430710748, 0.204234068992875, 0.2834948375865586, 0.10837978219374322, 0.12003723422074486, 0.1529593802491629, 0.11049792204562892, 0.11059509515739774, 0.1254671431184935, 0.1074481401967512, 0.10112670488296571, 0.12180379442679257, 0.11509792704045341, 0.08023038806606697, 0.0889525102763149, 0.10923448083586773, 0.0921458042931077, 0.11921935670971728, 0.10508679198054993, 0.07488759870129347, 0.11227117143360499, 0.8197166749628871, 0.8453214370510016, 0.8677092799172559, 0.8459259813988622, 0.8037687828654677, 0.8715830733826128, 0.7876239088567875, 0.8552538679141876, 0.8157056722046555, 0.21185194704270105, 0.16066174172008996, 0.17133751423453414, 0.19968854193059127, 0.17916155218008667, 0.1810901254917725, 0.2074963714163619, 0.21318845621890792, 0.18218094719848588, 0.22963606923701574, 0.6142670258707223, 0.6898707690737652, 0.6928764288516869, 0.6461075758142412, 0.7246304789117308, 0.6411311062099913, 0.7003860440225469, 0.33555273730426793, 0.16358958100693965, 0.14500710491881563, 0.11797613810664498, 0.11309732809651107, 0.15831485953653102, 0.13565184018949417, 0.12088490610909264, 0.14978273768898198, 0.13965668343270898, 0.137747929241388, 0.13545323069569004, 0.12464492609074618, 0.15589295835993489, 0.18339527938522193, 0.17733353963927434, 0.17025570460133788, 0.18944870388835633, 0.13926900587899416, 0.35327762224043224, 0.11643397005301281, 0.18186302633735107, 0.20026454359744517, 0.15666348895107274, 0.0926049602073803, 0.19716435469163385, 0.0076163030662828035, 0.09916035523741717, 0.2694404095051959, 0.27761867698951825, 0.30729425094560225, 0.3840109197462668, 0.10465183734740202, 0.10832050547244965, 0.4015696702582007, 0.20459349475547706, 0.16331592461144606, 0.09850584217566938, 0.050017120057899045, 0.08037161964247319, 0.15402783280877697, 0.16413664501366987, 0.13613123862827547, 0.06684197060826014, 0.08184482956336725, 0.09987237046005248, 0.19160757870020817, 0.18161142292673527, 0.16609015847605058, 0.11816687853738528, 0.16511921944440766, 0.20276397515454592, 0.19996961931039314, 0.2072133621202552, 0.21112264753377874, 0.5259410109171583, 0.5453669689670106, 0.5076039979342469, 0.4617971696692984, 0.3875469504094947, 0.3913481426606813, 0.4921528361930473, 0.5459364840529333, 0.4161952016769197, 0.11233195166719057, 0.10874161165481111, 0.0868681470493482, 0.10052276133453486, 0.10312439922511873, 0.09856524126564059, 0.08599336598911034, 0.10790281337815177, 0.08484020413700133, 0.16901265415865097, 0.15095673586328828, 0.15106613457914153, 0.19082908253971365, 0.1880149281402611, 0.19518068633339392, 0.17112149558205836, 0.16070800042364208, 0.1379522107108172, 0.28377001983977745, 0.27875893126222895, 0.30925997620412204, 0.3087495404305425, 0.30026069019928725, 0.3241063914308293, 0.283498585171888, 0.2836376565245632, 0.3206914869758226, 0.25461162564341977, 0.2680808347582183, 0.2817010696704858, 0.2593463925596172, 0.205797100168006, 0.2237760461678675, 0.23704370697947896, 0.2270927867010455, 0.26437759190515686, 0.19818591462840784, 0.17459693760977624, 0.1917771732525576, 0.1812640575551312, 0.2159285991478449, 0.1932671860386619, 0.2102358577963389, 0.19828710008589012, 0.19334515472640545, 0.210250500667843, 0.17653959812687103, 0.1778571847542808, 0.17559963107768695, 0.17456301614343772, 0.19723700531628974, 0.1934178157933556, 0.185248438085733, 0.18956897768950065, 0.18014249156032425, 0.6658937343914448, 0.6772331262110691, 0.15909617812523624, 0.5076495437698245, 0.6174492032427503, 0.5204167607469536, 0.562635753158796, 0.600259662948992, 0.19618450020220612, 0.19886430259612387, 0.2008711106825266, 0.3761531485620546, 0.15818686919515224, 0.19753257517939393, 0.20438012451971765, 0.19944018896893223, 0.702335359952106, 0.16742898676699025, 0.18040744543821619, 0.1940698773187346, 0.18066216475364505, 0.16917396036364152, 0.1726425931536293, 0.17179870299104572, 0.18058459848004604, 0.17431659580236214, 0.085127082858661, 0.06562452403622132, 0.07790933749877427, 0.09348303479238895, 0.07400994915969605, 0.07994203330326488, 0.06894297383498527, 0.0741043465997, 0.07370925464705291]}, "mutation_prompt": null}
{"id": "284cd2da-5c5f-4897-8bea-4d498893c229", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        # Change: Introduce self-adaptive threshold for differential weight\n        if success_rate > 0.6:  \n            adaptive_diff_weight *= 1.2  # Increase weight\n        # New: Introduce random scaling for mutation\n        mutant = a + (0.5 + np.random.rand() * 0.5) * adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < self.cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return self.cross_prob * mutant + (1 - self.cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.8 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - self.current_budget / self.budget) * decay_factor * secondary_decay)\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                # Change: Increase cross_prob adaptation rate\n                self.cross_prob = min(1.0, self.cross_prob + 0.015 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Adjust mutation strategy by introducing random scaling and increase cross_prob adaptation rate.", "configspace": "", "generation": 46, "fitness": 0.22252758952980262, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "02db01a5-fb74-4cd4-baa7-f769c4e85dad", "metadata": {"aucs": [0.3361808630154748, 0.470153727772324, 0.3391749429660236, 0.39631634734700016, 0.3720464084260061, 0.5143052876570331, 0.3724017028017257, 0.42752094514761463, 0.3050947882530255, 0.06177422877566974, 9.999999999998899e-05, 0.03221152914956693, 0.11286920443924042, 0.0894330440706742, 0.06162947982520417, 9.999999999998899e-05, 0.09915964451618875, 0.17816015421179576, 0.11249421598070475, 0.10414188083931186, 0.10678158848375663, 0.10759923481999045, 0.10936793404175538, 0.10132732194742389, 0.09551651163904806, 0.09726822171628535, 0.12685369507960387, 0.10315717104419786, 0.09468790775247549, 0.10021337710708955, 0.07396271626544026, 0.08646370309212048, 0.0859664051821839, 0.0838353399260039, 0.08999465517318694, 0.08314915531690314, 0.8869394251179342, 0.8558825052943122, 0.7915564591386444, 0.8872979646705994, 0.8637269251461921, 0.857598229958946, 0.8469036347073686, 0.8746103273396155, 0.7296928735360704, 0.15601570121282526, 0.12443810582607129, 0.133171043606937, 0.1699945192701463, 0.1390670666057262, 0.15872309521226835, 0.16865164168485358, 0.13673822464169427, 0.24178231274132, 0.33140192867394, 0.3353984869593395, 0.2536575723643719, 0.6498134837308773, 0.23000518300681005, 0.6949224692445448, 0.7519287349741155, 0.22154169402510238, 0.2939991169114643, 0.1178092721881181, 0.1257991306051428, 0.18248026022951536, 0.11116769687751926, 0.12097397258838305, 0.11493415283401742, 0.1386438677043359, 0.1931372193931774, 0.12842763211544916, 0.16077604253248734, 0.1089031880041137, 0.18454301106834392, 0.12967935326206903, 0.12361896813279671, 0.11574930192306565, 0.13426223218968147, 0.10153528345861318, 0.10409820787809787, 0.008438212275556745, 0.11462895526970807, 0.09203335798143708, 0.07639887630029485, 0.1459500408986858, 9.999999999998899e-05, 0.05631950459207091, 0.04704312770539232, 0.14812723493345803, 0.1759275641149174, 0.23937709432818033, 0.1386936540761866, 0.22937117205605762, 0.2615535709122887, 0.08958688712875285, 0.15578346294571643, 0.11338867263502506, 0.1935346414972129, 0.05113396412574622, 9.999999999998899e-05, 0.035639371634736516, 0.015880023139633548, 0.11258378206033193, 0.06625960061547265, 0.0058745528874389885, 0.0915714824527506, 0.09634598207318545, 0.19995010697943127, 0.03189886079440807, 0.08732671924600521, 0.050120213101140454, 0.10415036755060714, 0.11963378517684164, 0.07730953776974514, 0.1905499904125766, 0.08057594287994874, 0.33288623541237894, 0.4466344276338797, 0.36023540435369406, 0.37724515954908433, 0.4429178281560838, 0.49552412657631806, 0.3239228260904995, 0.3045221215736946, 0.35987936020612576, 0.0922822476285784, 0.12272880460571145, 0.12366311138806196, 0.09158940611112887, 0.12877509879232152, 0.11058211969460008, 0.1072071113550026, 0.12199914227323716, 0.10047063434382486, 0.16527288292629816, 0.1488959524124882, 0.17843601827822897, 0.17140360337378913, 0.20497581226751416, 0.16243869561989177, 0.21316559759246245, 0.16656683836292452, 0.1966314370957517, 0.2903828707799897, 0.31428026549087473, 0.3266296561719939, 0.26728710452540416, 0.2977562615490973, 0.3215046426361813, 0.3313496245858818, 0.3605802779150551, 0.2700246539946396, 0.26921319793710186, 0.2750921584008179, 0.24062813223601365, 0.2449693607153487, 0.22397594368266205, 0.207566084290133, 0.23623771160158558, 0.17654155654854198, 0.23397849440838137, 0.20691230269467586, 0.18613521925397758, 0.22040303981632914, 0.19165470127099982, 0.18043116509544777, 0.19904389912233023, 0.18850761896966084, 0.1832551800678438, 0.1962852474554525, 0.18882831995049443, 0.17731810186255448, 0.19533437567698853, 0.21384810073010563, 0.19981767094758685, 0.20234236013119955, 0.18465155180586446, 0.20363686915447643, 0.21075519352380856, 0.6849384979818881, 0.19063680914894376, 0.5376108662104315, 0.17935369962864156, 0.805665995127858, 0.31044887288268275, 0.5144108375524477, 0.16603610304302052, 0.43247332397684746, 0.538581411255152, 0.42975014589526894, 0.1997850979954885, 0.26850627991911746, 0.4083178562670159, 0.2066001238264833, 0.20078331589737564, 0.2056390980045485, 0.14385424480661435, 0.17814807834133684, 0.17424224558082502, 0.17611459773823757, 0.17943837708023946, 0.18135273437398003, 0.18325056485759283, 0.18984293053738333, 0.18110053940260618, 0.1907022949522953, 0.07586283728916698, 0.0899942106145456, 0.07093724816826763, 0.07812308554917924, 0.07853399385260951, 0.07778615227850894, 0.0863653067521093, 0.08223406424312052, 0.08395541381245186]}, "mutation_prompt": null}
{"id": "1483316b-d9bf-4ea1-944d-34ccecc06942", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        # Change: Adjust self-adaptive threshold for differential weight\n        if success_rate > 0.55:  \n            adaptive_diff_weight *= 1.25  # Increase weight\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < self.cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return self.cross_prob * mutant + (1 - self.cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)  # Change: Adjust decay factor\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - self.current_budget / self.budget) * decay_factor * secondary_decay)\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Enhance the adaptive strategy by refining self-adaptive threshold and decay factor for improved convergence.", "configspace": "", "generation": 47, "fitness": 0.2636870804320439, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "02db01a5-fb74-4cd4-baa7-f769c4e85dad", "metadata": {"aucs": [0.5158052801678797, 0.6194450935782465, 0.3964455810313642, 0.47381776547029464, 0.4680563645668151, 0.5400941685179355, 0.6081725494463015, 0.517255147319412, 0.6786818204886285, 0.2590405781557923, 0.14102988468421174, 0.043347451686467364, 0.2700409072513099, 0.21945565403161804, 0.20870074797170668, 0.32200442426455933, 0.18673489893607942, 0.19155865920286375, 0.09901508190723618, 0.10770894554388599, 0.11228581600680432, 0.0879013938788441, 0.10933494033994484, 0.14721392599812244, 0.12097878291924313, 0.111019626603721, 0.11925245372764437, 0.07960615556800221, 0.08279695124229569, 0.10006111235065795, 0.09233778257415304, 0.0767336091692794, 0.1232244199121878, 0.09049483667670499, 0.08481027119029605, 0.08961130331405054, 0.8263508847246273, 0.84172009874775, 0.8708963710890845, 0.8258044345587199, 0.7602678014244307, 0.8528517555391806, 0.8115045943231196, 0.8548173122025237, 0.8064389657593889, 0.20939721283435897, 0.15811975658398492, 0.22650260061769634, 0.24552370883773345, 0.16072619925884224, 0.17154110688749702, 0.14139865761752224, 0.17562664164508424, 0.19649396864453805, 0.6881897372588838, 0.7009059877750841, 0.6022368548929667, 0.6685199801144164, 0.6760438847440603, 0.5349582966790951, 0.6613292469463071, 0.6872218806398649, 0.6946459846132671, 0.2575646322870947, 0.1405744328784746, 0.1094273420320051, 0.12728385791303132, 0.15455599759138328, 0.12856256583522185, 0.1770562971191848, 0.10894313723796223, 0.12421841195893013, 0.20369199860207943, 0.1856285606356276, 0.1403336916490212, 0.12420878652087963, 0.11767091523677176, 0.21350142656870064, 0.11723857448371566, 0.23218927205263895, 0.11818550142694295, 0.23840408114795653, 0.17435060211377218, 0.22356848235061888, 0.2525091990778605, 0.08522769555793197, 0.06991016958904839, 0.2231457912066669, 0.001369658037799315, 0.21543088689628098, 0.18311427795944613, 0.39176604854485964, 0.29332148585418505, 0.2540663248189403, 0.19340443264466523, 0.08532867090799368, 0.4255775253029822, 0.33114682446798493, 0.4412012445695157, 0.03200326858383651, 0.04671697494691629, 0.10051244778360746, 0.11305514505520764, 0.07429235229113351, 0.13180751338034047, 0.07101485580978517, 0.10747719547412127, 0.12749303698518233, 0.09291748821532142, 0.15982017837468598, 0.09745850268707235, 0.1932653756080519, 0.2276369956120844, 0.18932034820087684, 0.1227697054661927, 0.19694268568189877, 0.1672400773968895, 0.5484323159722206, 0.40702318576127605, 0.46747207937596214, 0.5152310509828882, 0.39425474687439166, 0.453406400843289, 0.49356149640003244, 0.566132736524068, 0.5382208933877957, 0.10309320393346133, 0.09570760755115937, 0.10166553424913616, 0.10898732257585908, 0.10667977695677622, 0.11534159885581774, 0.10437371332273848, 0.0852904292978568, 0.09212310590425021, 0.15213715788602056, 0.15718222654595881, 0.16882429467350535, 0.15187985208613686, 0.1409881504224384, 0.21575981158080482, 0.14154396029627203, 0.13870220746867257, 0.1609009579871037, 0.32369483585624104, 0.32004102919781563, 0.3237736831815371, 0.2999806769928135, 0.3091736007528304, 0.2977903877520497, 0.2766748815571314, 0.2863324505334811, 0.34967295407708743, 0.242989176406174, 0.2581025393356283, 0.23173447956548066, 0.2551732537190634, 0.19381820808286576, 0.23620195580462655, 0.22575970895466457, 0.267849610720546, 0.2309737504753231, 0.2037009295944443, 0.1834929045579573, 0.24332110770078985, 0.1957764183838201, 0.1872141682804307, 0.21924877496817008, 0.1901050450281324, 0.19633857877131344, 0.18248812525895486, 0.18458646277714108, 0.19803344576883564, 0.19394591445431697, 0.17957628877776755, 0.18607730562702318, 0.18257204348913014, 0.1932158591270715, 0.19199294586924498, 0.21570471836557492, 0.1793064369144779, 0.6179897253596013, 0.6935758932338347, 0.18126137302739798, 0.5881442648156552, 0.1781196475596022, 0.46994439809662325, 0.37800502269836866, 0.5797710833015843, 0.5857242205844089, 0.20057560662887042, 0.20320937270790185, 0.39493912271129517, 0.15809094856751948, 0.3813510310693575, 0.2040375286551548, 0.19938585351913984, 0.5669354513935353, 0.18710526398086036, 0.20337802271616845, 0.1766243966559965, 0.20002030314619312, 0.17738483167470187, 0.18498312420136986, 0.17953041279747795, 0.169382084424345, 0.16518228575129557, 0.08667585355187202, 0.07604547017972896, 0.07783809709899447, 0.07351470342038702, 0.06731551277478265, 0.07974830841014358, 0.08560534706799494, 0.08394395146103306, 0.08018912439647086]}, "mutation_prompt": null}
{"id": "4be9c5e4-6c99-4da7-b6c0-87e279379d2b", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        # Change: Adjust self-adaptive threshold for differential weight\n        if success_rate > 0.5:  \n            adaptive_diff_weight *= 1.3  # Increase weight slightly more\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < self.cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return self.cross_prob * mutant + (1 - self.cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)  # Change: Adjust decay factor\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - self.current_budget / self.budget) * decay_factor * secondary_decay)\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Fine-tune mutation strategy by integrating success rate-driven differential weight scaling for enhanced adaptability.", "configspace": "", "generation": 48, "fitness": 0.25489826874658156, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.20.", "error": "", "parent_id": "1483316b-d9bf-4ea1-944d-34ccecc06942", "metadata": {"aucs": [0.5599397795078723, 0.4023770217276549, 0.5883073497588514, 0.5322771963765751, 0.5270482109623036, 0.5061283065466318, 0.5781721220049039, 0.4714586207349769, 0.4120087653255923, 0.16406404692893595, 0.08712478296960402, 0.12530925312672458, 0.23307510556410294, 0.08366735961553806, 0.2201856201613147, 0.27595724434060787, 0.09989813014525972, 0.14776918472882794, 0.09724002890518446, 0.10598077232090852, 0.11756034678725535, 0.10077664246805229, 0.09891472176318805, 0.11081512817845596, 0.11146463082921887, 0.10747807491936345, 0.11272806841764682, 0.08746786076109692, 0.08475340255331953, 0.09514530851128022, 0.0815553687038233, 0.09938932620173369, 0.10067467305270095, 0.08064373629672805, 0.10991622045367622, 0.09711077346457464, 0.823650653488368, 0.8434341276914735, 0.848161067673479, 0.8294827239143179, 0.8004478781068015, 0.8745604186714404, 0.8279067427005213, 0.8568142141448555, 0.8574482515332809, 0.15941673335212103, 0.17805361278490672, 0.1311480984290473, 0.22691942325303593, 0.1544562853625665, 0.15039755214180583, 0.17426033990963186, 0.18954950109650603, 0.1988765932882709, 0.6220652650295838, 0.6631770784887319, 0.5946059808327485, 0.6907600099601051, 0.6271735080280283, 0.6494436823421208, 0.3720052132047367, 0.6823670603498013, 0.6711624452217244, 0.12137207422971874, 0.15685840019830177, 0.17035236416267363, 0.1115652085086043, 0.13149934968147536, 0.13300065085687562, 0.1685486689852469, 0.14247036049951678, 0.1298630193870689, 0.11496044527038352, 0.1186236230324581, 0.27873568701958995, 0.15366591749329694, 0.11292171721065059, 0.17436374013881828, 0.12062984887852402, 0.2861617570975822, 0.1169885434867356, 0.26759824709869207, 0.14778622208657377, 0.23741514967649613, 0.17440531804968074, 0.07920686326409376, 0.05412795310704255, 0.11332470604425149, 0.18698511740400148, 0.0673318364109109, 0.34730176654580946, 0.3349286398512308, 0.20822545814738302, 0.16346174714918438, 0.12175912797171695, 0.3235690587462191, 0.247787199018488, 0.39680470182365957, 0.31767455118885046, 0.04592862289731925, 0.04200144086288149, 0.09021335075158299, 0.07026063185863674, 0.09206930638149935, 0.1348908808633278, 0.07665422013226852, 9.999999999998899e-05, 0.06891273355194771, 0.1984761411275645, 0.22144467621926067, 0.23415663592426061, 0.1135279720921668, 0.20510413256384386, 0.2231333763395077, 0.07171931869189752, 0.1749734885660882, 0.1751620813956144, 0.3987307233370584, 0.5155440794060676, 0.5198855390271685, 0.4561712942499434, 0.5390707621400312, 0.5864232871274431, 0.5692029762224765, 0.48859057862594324, 0.5542721742749475, 0.09047686291119572, 0.10638913496536084, 0.08949349908410675, 0.10463208673818702, 0.106264329068808, 0.1532839454723508, 0.0936475239127671, 0.10899447364800163, 0.09785919130501097, 0.18017437781263435, 0.1674862941874088, 0.16069304684842267, 0.15301707466365078, 0.1693817030703958, 0.18859503926550658, 0.15818546059033056, 0.1420960231306755, 0.14637554448418344, 0.28655980390839086, 0.31188128650954805, 0.311107256515994, 0.3299325173172186, 0.29489393357826943, 0.30797111534373733, 0.2620577275427618, 0.3167193252754621, 0.29340183424301935, 0.27680269189712126, 0.2569071028995601, 0.27118810476614863, 0.24477193162185784, 0.23900898642568935, 0.2324752111746191, 0.22143208582202123, 0.25561142767879064, 0.26092879233815625, 0.21090107602852515, 0.1894652423657628, 0.19843638144757747, 0.18642632071960363, 0.21780261497788656, 0.19377773571179324, 0.1859202680924188, 0.20146540798961554, 0.194989378151459, 0.18795420631710646, 0.16884330742209153, 0.1771272699588764, 0.17521023841346595, 0.1877127808654151, 0.21141691385875716, 0.182292192436884, 0.19741886236816353, 0.18016897558607892, 0.18813074332520818, 0.1887670524878019, 0.6913081570442567, 0.1565617299488513, 0.6384223152177168, 0.16166593789216654, 0.5714822676236224, 0.3985060024490903, 0.5936716845668879, 0.3591113779346843, 0.2017939613310462, 0.20287865544312012, 0.43642770571228484, 0.15848187365169375, 0.18646541999187305, 0.20405240572235672, 0.19979790537367859, 0.4470473082882276, 0.1743529566103622, 0.17542781931073992, 0.1920116366734399, 0.18357221276840507, 0.1778433767913168, 0.17396076937880645, 0.17843826139877184, 0.18817145955544246, 0.18579720425080481, 0.07409887539414017, 0.07653861992687161, 0.07146839710359276, 0.07344204453034275, 0.08275044211403804, 0.07718228561557827, 0.07774276401388847, 0.0751280763172203, 0.08647731430739491]}, "mutation_prompt": null}
{"id": "09d48c82-4ced-4055-973b-458d009febe8", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        # Change: Adjust self-adaptive threshold for differential weight\n        if success_rate > 0.55:  \n            adaptive_diff_weight *= 1.25  # Increase weight\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < self.cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return self.cross_prob * mutant + (1 - self.cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)  # Change: Adjust decay factor\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - self.current_budget / self.budget) * decay_factor * secondary_decay)\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Enhance the adaptive strategy by refining self-adaptive threshold and decay factor for improved convergence.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1483316b-d9bf-4ea1-944d-34ccecc06942", "metadata": {"aucs": [0.5158052801678797, 0.6194450935782465, 0.3964455810313642, 0.47381776547029464, 0.4680563645668151, 0.5400941685179355, 0.6081725494463015, 0.517255147319412, 0.6786818204886285, 0.2590405781557923, 0.14102988468421174, 0.043347451686467364, 0.2700409072513099, 0.21945565403161804, 0.20870074797170668, 0.32200442426455933, 0.18673489893607942, 0.19155865920286375, 0.09901508190723618, 0.10770894554388599, 0.11228581600680432, 0.0879013938788441, 0.10933494033994484, 0.14721392599812244, 0.12097878291924313, 0.111019626603721, 0.11925245372764437, 0.07960615556800221, 0.08279695124229569, 0.10006111235065795, 0.09233778257415304, 0.0767336091692794, 0.1232244199121878, 0.09049483667670499, 0.08481027119029605, 0.08961130331405054, 0.8263508847246273, 0.84172009874775, 0.8708963710890845, 0.8258044345587199, 0.7602678014244307, 0.8528517555391806, 0.8115045943231196, 0.8548173122025237, 0.8064389657593889, 0.20939721283435897, 0.15811975658398492, 0.22650260061769634, 0.24552370883773345, 0.16072619925884224, 0.17154110688749702, 0.14139865761752224, 0.17562664164508424, 0.19649396864453805, 0.6881897372588838, 0.7009059877750841, 0.6022368548929667, 0.6685199801144164, 0.6760438847440603, 0.5349582966790951, 0.6613292469463071, 0.6872218806398649, 0.6946459846132671, 0.2575646322870947, 0.1405744328784746, 0.1094273420320051, 0.12728385791303132, 0.15455599759138328, 0.12856256583522185, 0.1770562971191848, 0.10894313723796223, 0.12421841195893013, 0.20369199860207943, 0.1856285606356276, 0.1403336916490212, 0.12420878652087963, 0.11767091523677176, 0.21350142656870064, 0.11723857448371566, 0.23218927205263895, 0.11818550142694295, 0.23840408114795653, 0.17435060211377218, 0.22356848235061888, 0.2525091990778605, 0.08522769555793197, 0.06991016958904839, 0.2231457912066669, 0.001369658037799315, 0.21543088689628098, 0.18311427795944613, 0.39176604854485964, 0.29332148585418505, 0.2540663248189403, 0.19340443264466523, 0.08532867090799368, 0.4255775253029822, 0.33114682446798493, 0.4412012445695157, 0.03200326858383651, 0.04671697494691629, 0.10051244778360746, 0.11305514505520764, 0.07429235229113351, 0.13180751338034047, 0.07101485580978517, 0.10747719547412127, 0.12749303698518233, 0.09291748821532142, 0.15982017837468598, 0.09745850268707235, 0.1932653756080519, 0.2276369956120844, 0.18932034820087684, 0.1227697054661927, 0.19694268568189877, 0.1672400773968895, 0.5484323159722206, 0.40702318576127605, 0.46747207937596214, 0.5152310509828882, 0.39425474687439166, 0.453406400843289, 0.49356149640003244, 0.566132736524068, 0.5382208933877957, 0.10309320393346133, 0.09570760755115937, 0.10166553424913616, 0.10898732257585908, 0.10667977695677622, 0.11534159885581774, 0.10437371332273848, 0.0852904292978568, 0.09212310590425021, 0.15213715788602056, 0.15718222654595881, 0.16882429467350535, 0.15187985208613686, 0.1409881504224384, 0.21575981158080482, 0.14154396029627203, 0.13870220746867257, 0.1609009579871037, 0.32369483585624104, 0.32004102919781563, 0.3237736831815371, 0.2999806769928135, 0.3091736007528304, 0.2977903877520497, 0.2766748815571314, 0.2863324505334811, 0.34967295407708743, 0.242989176406174, 0.2581025393356283, 0.23173447956548066, 0.2551732537190634, 0.19381820808286576, 0.23620195580462655, 0.22575970895466457, 0.267849610720546, 0.2309737504753231, 0.2037009295944443, 0.1834929045579573, 0.24332110770078985, 0.1957764183838201, 0.1872141682804307, 0.21924877496817008, 0.1901050450281324, 0.19633857877131344, 0.18248812525895486, 0.18458646277714108, 0.19803344576883564, 0.19394591445431697, 0.17957628877776755, 0.18607730562702318, 0.18257204348913014, 0.1932158591270715, 0.19199294586924498, 0.21570471836557492, 0.1793064369144779, 0.6179897253596013, 0.6935758932338347, 0.18126137302739798, 0.5881442648156552, 0.1781196475596022, 0.46994439809662325, 0.37800502269836866, 0.5797710833015843, 0.5857242205844089, 0.20057560662887042, 0.20320937270790185, 0.39493912271129517, 0.15809094856751948, 0.3813510310693575, 0.2040375286551548, 0.19938585351913984, 0.5669354513935353, 0.18710526398086036, 0.20337802271616845, 0.1766243966559965, 0.20002030314619312, 0.17738483167470187, 0.18498312420136986, 0.17953041279747795, 0.169382084424345, 0.16518228575129557, 0.08667585355187202, 0.07604547017972896, 0.07783809709899447, 0.07351470342038702, 0.06731551277478265, 0.07974830841014358, 0.08560534706799494, 0.08394395146103306, 0.08018912439647086]}, "mutation_prompt": null}
{"id": "5eb1d231-8959-4da6-99b4-0146d89c70fe", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.55:  \n            adaptive_diff_weight *= 1.25\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        # Change: Introduce dynamic scaling in crossover probability\n        use_binomial = np.random.rand() < 0.5\n        dynamic_cross_prob = self.cross_prob * (1 - self.current_budget/self.budget) + (self.current_budget/self.budget) * 0.5\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < dynamic_cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return dynamic_cross_prob * mutant + (1 - dynamic_cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - self.current_budget / self.budget) * decay_factor * secondary_decay)\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Introduce a dynamic scaling factor in the crossover probability to enhance exploration-exploitation balance.", "configspace": "", "generation": 50, "fitness": 0.26282183907249607, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "1483316b-d9bf-4ea1-944d-34ccecc06942", "metadata": {"aucs": [0.6039013076027695, 0.6313037506256226, 0.6284123000845087, 0.5797925742418826, 0.613471338657894, 0.49237411295325095, 0.4693666588782417, 0.6653818585565676, 0.46057903817380175, 0.260267960146193, 0.18196373944623845, 0.11762630716149103, 0.2431737102142535, 0.3376302160016368, 0.1621729638692304, 0.32215258006700065, 0.16886692139781012, 0.25602031819360016, 0.10377015864285333, 0.08895115698946088, 0.09526909956104357, 0.11357287275474759, 0.11204737189307978, 0.11482948839735085, 0.10109242636842153, 0.10685180951221807, 0.10388895421192923, 0.09410357794321755, 0.08677074599603307, 0.08591119148182735, 0.0964427023018487, 0.09047496808870858, 0.10455513948825024, 0.10138663910761647, 0.08802314289260271, 0.0962933577062598, 0.8828781305111071, 0.8417350011358211, 0.8703326263595762, 0.8465545016822129, 0.7702648889565187, 0.8716989592115335, 0.7696305325786318, 0.8540542034997685, 0.8155005850920336, 0.23525769108343642, 0.22732893203391402, 0.19648649265355878, 0.22681826746508593, 0.2078895453927, 0.18929451807609166, 0.17053866511517313, 0.24007310440243013, 0.21855069914272474, 0.5475729026838589, 0.4530209233939966, 0.6676053375156723, 0.6433883746920759, 0.6013358387324745, 0.6835571450642457, 0.6523000456733756, 0.4407352765826653, 0.7215111073298077, 0.18618947006765607, 0.13967983396089034, 0.11899716525346393, 0.19744569710744242, 0.20300100256870612, 0.14155992421071006, 0.11939923048141865, 0.1278752897842984, 0.11588479488020098, 0.15159878153673234, 0.1721797569822071, 0.1615756574387075, 0.16179663494697394, 0.12604672366019853, 0.14749475643970944, 0.14201294314827717, 0.1722549051713138, 0.1442685403455849, 0.22629327314765801, 0.02887226229789519, 0.3019808036285817, 0.04435993104044189, 0.0624970570903024, 0.10240610881969225, 0.0978053236620754, 0.19790420018469468, 0.17997929156836667, 0.45412464909066697, 0.2642814776964989, 0.3453050428884562, 0.18777913332582197, 0.11002148212174634, 0.19718772481969293, 0.41307971177816727, 0.22107842693352053, 0.4269168180033106, 0.05085289484387945, 0.09934831547593026, 0.04425311452549907, 0.0793803727332375, 0.060311558906657736, 0.12665776485142266, 0.11456406310112144, 0.1002631704226371, 0.09983782838882704, 0.1916034832206296, 0.1568931993474857, 0.15225629661107742, 0.20190823681075531, 0.22393797977256347, 0.1697303856627177, 0.1960451117781874, 0.1641706045015291, 0.19957377554164257, 0.519369198462057, 0.4835857932959713, 0.38767187257644276, 0.5117217509841852, 0.45356444252146944, 0.5126491013648586, 0.44050046009306065, 0.5082033225333635, 0.5150385183975525, 0.10197626668644266, 0.11106593094893902, 0.10994543225670694, 0.10601573028042766, 0.10165620316239743, 0.1061005368748803, 0.08964816067807113, 0.10669042411723462, 0.11679565425983784, 0.16806662425705676, 0.12571435287281763, 0.16214338767606984, 0.1687920596763166, 0.12073259725798235, 0.16471110035338477, 0.15756868377038868, 0.16548594262465355, 0.14640921230908666, 0.3137713442678899, 0.34402870778002115, 0.3332495755576923, 0.3181331465830116, 0.30868250721412016, 0.33101418549493533, 0.29256042979986285, 0.31056921945234606, 0.32140791115334133, 0.23780566829880034, 0.23282667670384927, 0.24491768226356325, 0.2547006637282315, 0.25051773012993384, 0.2767190066119488, 0.19648139530958963, 0.24717485602620493, 0.248948750773881, 0.23730052688520042, 0.21721049811578907, 0.19241270319992854, 0.19499088148841504, 0.19311683920123845, 0.1981456895663588, 0.2283272283048119, 0.2237958713352587, 0.2051124508161083, 0.1914246477566166, 0.18195289502380985, 0.18249095491424572, 0.18059985678866486, 0.18477704380226978, 0.1934370356111802, 0.1981627521953303, 0.20156450527322545, 0.1957480637543373, 0.1767405313219228, 0.1797344576630483, 0.7121650033422047, 0.42436459867279896, 0.6672290959349962, 0.16230192631742102, 0.5725515581656935, 0.5988877189869353, 0.6369048094151684, 0.30711640111662786, 0.2249905626980354, 0.2035907372465755, 0.4056602077631375, 0.21905530806722517, 0.19208321286579966, 0.20251575141975497, 0.19970925715805288, 0.1922684333761011, 0.16868978936061607, 0.1849498950149303, 0.19137730929909103, 0.17297823121031874, 0.19163582429384118, 0.1735211835055005, 0.1809319419262383, 0.17636440943062515, 0.1760612378386237, 0.07179279806358085, 0.07172105745972401, 0.08148221425947, 0.08280458162512483, 0.07617051194006763, 0.08081532439165895, 0.09048838372248935, 0.0768232978045309, 0.0698082772597105]}, "mutation_prompt": null}
{"id": "0434517d-4a47-4c64-a382-17271b8802fc", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        # Change: Adjust self-adaptive threshold for differential weight\n        if success_rate > 0.55:  \n            adaptive_diff_weight *= 1.25  # Increase weight\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < self.cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return self.cross_prob * mutant + (1 - self.cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)  # Change: Adjust decay factor\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - self.current_budget / self.budget) * decay_factor * secondary_decay)\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Enhance the adaptive strategy by refining self-adaptive threshold and decay factor for improved convergence.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1483316b-d9bf-4ea1-944d-34ccecc06942", "metadata": {"aucs": [0.5158052801678797, 0.6194450935782465, 0.3964455810313642, 0.47381776547029464, 0.4680563645668151, 0.5400941685179355, 0.6081725494463015, 0.517255147319412, 0.6786818204886285, 0.2590405781557923, 0.14102988468421174, 0.043347451686467364, 0.2700409072513099, 0.21945565403161804, 0.20870074797170668, 0.32200442426455933, 0.18673489893607942, 0.19155865920286375, 0.09901508190723618, 0.10770894554388599, 0.11228581600680432, 0.0879013938788441, 0.10933494033994484, 0.14721392599812244, 0.12097878291924313, 0.111019626603721, 0.11925245372764437, 0.07960615556800221, 0.08279695124229569, 0.10006111235065795, 0.09233778257415304, 0.0767336091692794, 0.1232244199121878, 0.09049483667670499, 0.08481027119029605, 0.08961130331405054, 0.8263508847246273, 0.84172009874775, 0.8708963710890845, 0.8258044345587199, 0.7602678014244307, 0.8528517555391806, 0.8115045943231196, 0.8548173122025237, 0.8064389657593889, 0.20939721283435897, 0.15811975658398492, 0.22650260061769634, 0.24552370883773345, 0.16072619925884224, 0.17154110688749702, 0.14139865761752224, 0.17562664164508424, 0.19649396864453805, 0.6881897372588838, 0.7009059877750841, 0.6022368548929667, 0.6685199801144164, 0.6760438847440603, 0.5349582966790951, 0.6613292469463071, 0.6872218806398649, 0.6946459846132671, 0.2575646322870947, 0.1405744328784746, 0.1094273420320051, 0.12728385791303132, 0.15455599759138328, 0.12856256583522185, 0.1770562971191848, 0.10894313723796223, 0.12421841195893013, 0.20369199860207943, 0.1856285606356276, 0.1403336916490212, 0.12420878652087963, 0.11767091523677176, 0.21350142656870064, 0.11723857448371566, 0.23218927205263895, 0.11818550142694295, 0.23840408114795653, 0.17435060211377218, 0.22356848235061888, 0.2525091990778605, 0.08522769555793197, 0.06991016958904839, 0.2231457912066669, 0.001369658037799315, 0.21543088689628098, 0.18311427795944613, 0.39176604854485964, 0.29332148585418505, 0.2540663248189403, 0.19340443264466523, 0.08532867090799368, 0.4255775253029822, 0.33114682446798493, 0.4412012445695157, 0.03200326858383651, 0.04671697494691629, 0.10051244778360746, 0.11305514505520764, 0.07429235229113351, 0.13180751338034047, 0.07101485580978517, 0.10747719547412127, 0.12749303698518233, 0.09291748821532142, 0.15982017837468598, 0.09745850268707235, 0.1932653756080519, 0.2276369956120844, 0.18932034820087684, 0.1227697054661927, 0.19694268568189877, 0.1672400773968895, 0.5484323159722206, 0.40702318576127605, 0.46747207937596214, 0.5152310509828882, 0.39425474687439166, 0.453406400843289, 0.49356149640003244, 0.566132736524068, 0.5382208933877957, 0.10309320393346133, 0.09570760755115937, 0.10166553424913616, 0.10898732257585908, 0.10667977695677622, 0.11534159885581774, 0.10437371332273848, 0.0852904292978568, 0.09212310590425021, 0.15213715788602056, 0.15718222654595881, 0.16882429467350535, 0.15187985208613686, 0.1409881504224384, 0.21575981158080482, 0.14154396029627203, 0.13870220746867257, 0.1609009579871037, 0.32369483585624104, 0.32004102919781563, 0.3237736831815371, 0.2999806769928135, 0.3091736007528304, 0.2977903877520497, 0.2766748815571314, 0.2863324505334811, 0.34967295407708743, 0.242989176406174, 0.2581025393356283, 0.23173447956548066, 0.2551732537190634, 0.19381820808286576, 0.23620195580462655, 0.22575970895466457, 0.267849610720546, 0.2309737504753231, 0.2037009295944443, 0.1834929045579573, 0.24332110770078985, 0.1957764183838201, 0.1872141682804307, 0.21924877496817008, 0.1901050450281324, 0.19633857877131344, 0.18248812525895486, 0.18458646277714108, 0.19803344576883564, 0.19394591445431697, 0.17957628877776755, 0.18607730562702318, 0.18257204348913014, 0.1932158591270715, 0.19199294586924498, 0.21570471836557492, 0.1793064369144779, 0.6179897253596013, 0.6935758932338347, 0.18126137302739798, 0.5881442648156552, 0.1781196475596022, 0.46994439809662325, 0.37800502269836866, 0.5797710833015843, 0.5857242205844089, 0.20057560662887042, 0.20320937270790185, 0.39493912271129517, 0.15809094856751948, 0.3813510310693575, 0.2040375286551548, 0.19938585351913984, 0.5669354513935353, 0.18710526398086036, 0.20337802271616845, 0.1766243966559965, 0.20002030314619312, 0.17738483167470187, 0.18498312420136986, 0.17953041279747795, 0.169382084424345, 0.16518228575129557, 0.08667585355187202, 0.07604547017972896, 0.07783809709899447, 0.07351470342038702, 0.06731551277478265, 0.07974830841014358, 0.08560534706799494, 0.08394395146103306, 0.08018912439647086]}, "mutation_prompt": null}
{"id": "1caa1344-4dd9-4bce-94c4-ebcda65bb790", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        # Change: Slight refinement in the success rate threshold for differential weight\n        if success_rate > 0.5:  \n            adaptive_diff_weight *= 1.25  # Increase weight\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < self.cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return self.cross_prob * mutant + (1 - self.cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)  # Change: Adjust decay factor\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - self.current_budget / self.budget) * decay_factor * secondary_decay)\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Slightly refine the mutation step to enhance exploration by adjusting the success rate threshold.", "configspace": "", "generation": 52, "fitness": 0.26391723814097623, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "1483316b-d9bf-4ea1-944d-34ccecc06942", "metadata": {"aucs": [0.5039614806619592, 0.5141829941312215, 0.4330713831990157, 0.489679195807063, 0.60327967879353, 0.5745046964879635, 0.539382919602303, 0.5434260076411533, 0.621709245631969, 0.2553743921388759, 0.05295525630563769, 0.24626394836577203, 0.09160249430634027, 0.3026489432790056, 0.23110917346380233, 0.3176762109225768, 0.30099525732863563, 0.1918194933315911, 0.09968298028498634, 0.10178966412701118, 0.09846239892005815, 0.12159373679119412, 0.10221047042463471, 0.11102545921241436, 0.10056542064387719, 0.10469522872083836, 0.11697698711835869, 0.10842763179891135, 0.09305917234464356, 0.08352267534999169, 0.06981770486765726, 0.08087569846965925, 0.1072085902329567, 0.09268938085943335, 0.07813827204145096, 0.07740072858772185, 0.8029353899783085, 0.8419202669546155, 0.8704939284780483, 0.827247866133215, 0.8004717624885304, 0.8699218215917971, 0.7965433579409965, 0.8572603450280507, 0.8035775106848647, 0.1983605584848761, 0.22669908609203393, 0.13957472012545546, 0.272334711018149, 0.17475396953697542, 0.17856480244056516, 0.14641822736935506, 0.24343601070248033, 0.2064020417753617, 0.6482252481956388, 0.7037461184777681, 0.6855413112620388, 0.6438041465641322, 0.699323962287679, 0.7175789173515081, 0.6370569691600485, 0.6210481696094752, 0.683180259206807, 0.1222777063490319, 0.1793984240854124, 0.1156710580257081, 0.13427065877302935, 0.16093933772322, 0.1353912962368482, 0.13705469666877712, 0.1354608686433001, 0.12763173456804144, 0.10477022894532106, 0.1432022788063959, 0.14850830117271085, 0.2788679426613381, 0.1923161790907142, 0.16119781084334317, 0.14027068657998498, 0.12135525307364203, 0.18019003993441673, 0.21789669765739728, 0.03168896999342341, 0.2503020807266332, 0.23547884918777695, 0.09646432527490945, 0.0812460804032471, 0.11968926943696478, 0.2637930185284938, 0.16411949014869553, 0.2594876962442133, 0.3760621916471554, 0.4209085116103394, 0.3356005394340045, 0.25373176986664625, 0.2497009862341959, 0.4012001295937152, 0.3771618565078978, 0.4134093830354104, 0.07705091936015995, 0.10925747870090052, 0.1421535438797915, 0.05597778502141515, 0.08929464600965142, 0.11372873547089601, 0.08161989721383356, 0.0777977433954189, 0.041426779831489347, 0.19980690585675265, 0.17153305185979228, 0.1824549808803646, 0.19287154874794565, 0.15583292682359118, 0.22106719876593406, 0.18607378200684266, 0.18605643886665613, 0.16125302703175126, 0.5210103146445673, 0.46009525099342885, 0.4364757157802738, 0.5151937887904969, 0.5098298442387048, 0.5611005721281439, 0.42941985928244575, 0.440605315889124, 0.4674599187913866, 0.10456076113745383, 0.08865340384628329, 0.0843424304402366, 0.10141498167118568, 0.09715380563586273, 0.08984447629602732, 0.09897763936490178, 0.11956284527409755, 0.09490378038870151, 0.1825588171482424, 0.14030003398224944, 0.15100552883385499, 0.18289996542112297, 0.13855590899224812, 0.20909127737984967, 0.19422311179946028, 0.21840307462760034, 0.1414785558967353, 0.29901350956408046, 0.34272832952909393, 0.2913677988240275, 0.3082428065187284, 0.2877554700377579, 0.2972784066431333, 0.3238847989515957, 0.2932730930458659, 0.31136214000973694, 0.2149958354322281, 0.2433788674183064, 0.23881243943641306, 0.19712545434894924, 0.2524858073688647, 0.26367616881895395, 0.2397333053628855, 0.23436678149982537, 0.22913823032146763, 0.18895746042273798, 0.18854419040507586, 0.19022390461132188, 0.21311498888338742, 0.18381393363424103, 0.1866749921224241, 0.19992835475027337, 0.1951906273754166, 0.1974096984615048, 0.1877770682438631, 0.170474174274715, 0.18539153548084653, 0.17637756830457674, 0.18584705776644284, 0.17893968212212363, 0.18467637588936103, 0.2554047589698871, 0.20802900727532914, 0.17182833017548804, 0.561697504112711, 0.6042927152540027, 0.17757034518223302, 0.59332837048832, 0.16180563155170802, 0.5129147874101703, 0.47597150370141394, 0.6405234698408053, 0.34811336282026195, 0.1994196968970645, 0.2012713857181322, 0.3574770055143909, 0.1581712224653996, 0.19794091912067668, 0.2031504957609902, 0.200030490856566, 0.22600569363743128, 0.18874017549168143, 0.17801374591650598, 0.19057294505484856, 0.18213748208563119, 0.17383301027513576, 0.1758069932380929, 0.18338532040794753, 0.17530402566588654, 0.16776280280509148, 0.07228832579102218, 0.07771181865740362, 0.07762121628702956, 0.07553550745949866, 0.07595766982036822, 0.07359874040108683, 0.08881795013738047, 0.08224567987932618, 0.08058130920050988]}, "mutation_prompt": null}
{"id": "9dc42488-7d24-4890-9a1f-3eca9fb6bec8", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        # Change: Slight refinement in the success rate threshold for differential weight\n        if success_rate > 0.5:  \n            adaptive_diff_weight *= 1.25  # Increase weight\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < self.cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return self.cross_prob * mutant + (1 - self.cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)  # Change: Adjust decay factor\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - self.current_budget / self.budget) * decay_factor * secondary_decay)\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Slightly refine the mutation step to enhance exploration by adjusting the success rate threshold.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1caa1344-4dd9-4bce-94c4-ebcda65bb790", "metadata": {"aucs": [0.5039614806619592, 0.5141829941312215, 0.4330713831990157, 0.489679195807063, 0.60327967879353, 0.5745046964879635, 0.539382919602303, 0.5434260076411533, 0.621709245631969, 0.2553743921388759, 0.05295525630563769, 0.24626394836577203, 0.09160249430634027, 0.3026489432790056, 0.23110917346380233, 0.3176762109225768, 0.30099525732863563, 0.1918194933315911, 0.09968298028498634, 0.10178966412701118, 0.09846239892005815, 0.12159373679119412, 0.10221047042463471, 0.11102545921241436, 0.10056542064387719, 0.10469522872083836, 0.11697698711835869, 0.10842763179891135, 0.09305917234464356, 0.08352267534999169, 0.06981770486765726, 0.08087569846965925, 0.1072085902329567, 0.09268938085943335, 0.07813827204145096, 0.07740072858772185, 0.8029353899783085, 0.8419202669546155, 0.8704939284780483, 0.827247866133215, 0.8004717624885304, 0.8699218215917971, 0.7965433579409965, 0.8572603450280507, 0.8035775106848647, 0.1983605584848761, 0.22669908609203393, 0.13957472012545546, 0.272334711018149, 0.17475396953697542, 0.17856480244056516, 0.14641822736935506, 0.24343601070248033, 0.2064020417753617, 0.6482252481956388, 0.7037461184777681, 0.6855413112620388, 0.6438041465641322, 0.699323962287679, 0.7175789173515081, 0.6370569691600485, 0.6210481696094752, 0.683180259206807, 0.1222777063490319, 0.1793984240854124, 0.1156710580257081, 0.13427065877302935, 0.16093933772322, 0.1353912962368482, 0.13705469666877712, 0.1354608686433001, 0.12763173456804144, 0.10477022894532106, 0.1432022788063959, 0.14850830117271085, 0.2788679426613381, 0.1923161790907142, 0.16119781084334317, 0.14027068657998498, 0.12135525307364203, 0.18019003993441673, 0.21789669765739728, 0.03168896999342341, 0.2503020807266332, 0.23547884918777695, 0.09646432527490945, 0.0812460804032471, 0.11968926943696478, 0.2637930185284938, 0.16411949014869553, 0.2594876962442133, 0.3760621916471554, 0.4209085116103394, 0.3356005394340045, 0.25373176986664625, 0.2497009862341959, 0.4012001295937152, 0.3771618565078978, 0.4134093830354104, 0.07705091936015995, 0.10925747870090052, 0.1421535438797915, 0.05597778502141515, 0.08929464600965142, 0.11372873547089601, 0.08161989721383356, 0.0777977433954189, 0.041426779831489347, 0.19980690585675265, 0.17153305185979228, 0.1824549808803646, 0.19287154874794565, 0.15583292682359118, 0.22106719876593406, 0.18607378200684266, 0.18605643886665613, 0.16125302703175126, 0.5210103146445673, 0.46009525099342885, 0.4364757157802738, 0.5151937887904969, 0.5098298442387048, 0.5611005721281439, 0.42941985928244575, 0.440605315889124, 0.4674599187913866, 0.10456076113745383, 0.08865340384628329, 0.0843424304402366, 0.10141498167118568, 0.09715380563586273, 0.08984447629602732, 0.09897763936490178, 0.11956284527409755, 0.09490378038870151, 0.1825588171482424, 0.14030003398224944, 0.15100552883385499, 0.18289996542112297, 0.13855590899224812, 0.20909127737984967, 0.19422311179946028, 0.21840307462760034, 0.1414785558967353, 0.29901350956408046, 0.34272832952909393, 0.2913677988240275, 0.3082428065187284, 0.2877554700377579, 0.2972784066431333, 0.3238847989515957, 0.2932730930458659, 0.31136214000973694, 0.2149958354322281, 0.2433788674183064, 0.23881243943641306, 0.19712545434894924, 0.2524858073688647, 0.26367616881895395, 0.2397333053628855, 0.23436678149982537, 0.22913823032146763, 0.18895746042273798, 0.18854419040507586, 0.19022390461132188, 0.21311498888338742, 0.18381393363424103, 0.1866749921224241, 0.19992835475027337, 0.1951906273754166, 0.1974096984615048, 0.1877770682438631, 0.170474174274715, 0.18539153548084653, 0.17637756830457674, 0.18584705776644284, 0.17893968212212363, 0.18467637588936103, 0.2554047589698871, 0.20802900727532914, 0.17182833017548804, 0.561697504112711, 0.6042927152540027, 0.17757034518223302, 0.59332837048832, 0.16180563155170802, 0.5129147874101703, 0.47597150370141394, 0.6405234698408053, 0.34811336282026195, 0.1994196968970645, 0.2012713857181322, 0.3574770055143909, 0.1581712224653996, 0.19794091912067668, 0.2031504957609902, 0.200030490856566, 0.22600569363743128, 0.18874017549168143, 0.17801374591650598, 0.19057294505484856, 0.18213748208563119, 0.17383301027513576, 0.1758069932380929, 0.18338532040794753, 0.17530402566588654, 0.16776280280509148, 0.07228832579102218, 0.07771181865740362, 0.07762121628702956, 0.07553550745949866, 0.07595766982036822, 0.07359874040108683, 0.08881795013738047, 0.08224567987932618, 0.08058130920050988]}, "mutation_prompt": null}
{"id": "c053b97d-dafa-4aa2-b0a5-c484386bd7cb", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:  \n            adaptive_diff_weight *= 1.25\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < self.cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return self.cross_prob * mutant + (1 - self.cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        # Change: Introduce a dynamic adjustment to the step size\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Introduce a dynamic adjustment to the step size in the directional search to better balance exploration and exploitation.", "configspace": "", "generation": 54, "fitness": 0.26735078092893644, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.20.", "error": "", "parent_id": "1caa1344-4dd9-4bce-94c4-ebcda65bb790", "metadata": {"aucs": [0.49993364447277167, 0.578514780538546, 0.5654213252984656, 0.5338798482202358, 0.5146886167930057, 0.5725463844532885, 0.6086323171219379, 0.5253221883193565, 0.45679305141194126, 0.08133379561967502, 0.1862113773151559, 0.275373509339256, 0.09083185569438679, 0.05073268046392165, 0.23522702219094804, 0.1592544551705405, 0.2067772141942411, 0.1623213518932134, 0.09724780079846618, 0.1246109288317706, 0.09940941787963398, 0.11050154221187891, 0.10143759286261211, 0.08804674993754269, 0.0879253961892118, 0.0950520908323107, 0.1086388980683074, 0.08041139996203728, 0.07490437418297247, 0.08430138515537966, 0.0863665516428831, 0.07387093376886023, 0.08639956504799151, 0.08282253241308757, 0.1003315014003765, 0.0881788197780825, 0.8223345247886336, 0.8511854272677393, 0.8839262241314515, 0.756894629674816, 0.8265229483018428, 0.8742059935482849, 0.8056193187500138, 0.8581623592139263, 0.8026819723487321, 0.2223555133674192, 0.2712292585276699, 0.17633747200545002, 0.18543619778546094, 0.13996336382079044, 0.13959409884086094, 0.21702909003429516, 0.17723313083812098, 0.1472045885671791, 0.636017189426187, 0.5919897540809516, 0.6662903228718402, 0.6827451433654874, 0.685182640936479, 0.7015969090620078, 0.6556140860415169, 0.6233393958505313, 0.5941729199342329, 0.12061783404489124, 0.10980935179578322, 0.13448513551898178, 0.14881033631943685, 0.20788284885952757, 0.13680318060024454, 0.1171882730702195, 0.19781587730443184, 0.13082072791674948, 0.15423969224289447, 0.25683078285755034, 0.1511513449566948, 0.14157211448873153, 0.14398169740758926, 0.16378820356132306, 0.1522433512946505, 0.19320702780187182, 0.1715740243771292, 0.29084969541882033, 0.22346637547558657, 0.22943712330247956, 0.25230624633765375, 0.07188537106233273, 0.05609935463390503, 0.23310390722446273, 0.2425543696119865, 0.2586259701361051, 0.3926467637278732, 0.43341908260182505, 0.18353799512344626, 0.41006561876025316, 0.45216103682177566, 0.22650450555709845, 0.21170821212948931, 0.3604276603989237, 0.3733123909664897, 0.10450310553193942, 0.1482568626770584, 0.17544849600051637, 0.09304632625650211, 0.058054421554266655, 0.07777191124084215, 0.08182671441063594, 0.147653878180523, 0.0949920012161789, 0.2231466285716327, 0.13487722808042235, 0.1931442880676133, 0.20405385315438118, 0.16682284038597972, 0.12394063223373597, 0.2008558578944638, 0.13807760998725083, 0.2130884007799858, 0.4319995570548194, 0.4278765926159004, 0.4060557114507901, 0.5059734525213035, 0.5072763805441065, 0.4538914723187617, 0.5014832146668265, 0.38758861044079196, 0.5160946290237778, 0.11426695155411704, 0.10361146511785391, 0.09175415146851706, 0.09300225406024043, 0.11327867078668585, 0.09764137883870205, 0.09348330450667908, 0.0971856087935028, 0.1260082458273375, 0.17028508530889974, 0.13345961410588203, 0.158508245169921, 0.17241746075109277, 0.1374302533318782, 0.15724200703757618, 0.19222261349655312, 0.12489439662595647, 0.1305866655807848, 0.30068067294968526, 0.3200224877711422, 0.28604163607321953, 0.29317170788915725, 0.2971755178546124, 0.31878879108015, 0.30540079149850385, 0.3371040615282668, 0.33889563954531954, 0.23093910568399434, 0.23286367691219856, 0.2874088160829973, 0.22982424721768524, 0.23399975144957252, 0.24989604008862643, 0.2535398466038613, 0.21024335362604696, 0.2532999747470813, 0.21758615587849495, 0.19798318266992887, 0.18916334271404156, 0.1925216980171921, 0.1819065504299865, 0.19251343164427326, 0.22998055135646722, 0.22014942184984188, 0.22336809647847056, 0.18353220973786222, 0.18411148699479685, 0.19497647254290507, 0.21080610091229923, 0.18307534781422163, 0.17347271692370814, 0.18393858450135792, 0.1972612338671148, 0.1765947174064284, 0.1835469072894641, 0.6461806890776718, 0.6030073777999956, 0.18473993666507493, 0.6971151877524451, 0.1617878627218694, 0.561773199059302, 0.5260216807938747, 0.7005943042889777, 0.6522980644837186, 0.4729243992936759, 0.20302013820920117, 0.4576544135366053, 0.15817679904045634, 0.23742691912821123, 0.19985547291534322, 0.19820981809425076, 0.3290949613614427, 0.17294748397863458, 0.18354798882517376, 0.1738807897823348, 0.18364963883110952, 0.1777652371615468, 0.19223303534973946, 0.1859254467211393, 0.1768267351142616, 0.17709547031767747, 0.0844817251969534, 0.07400208134989517, 0.08783329537843731, 0.0750267985852241, 0.07459322344957586, 0.07083731215821587, 0.08606976854743331, 0.09252637426694998, 0.06373081799426894]}, "mutation_prompt": null}
{"id": "d20a3bd0-08cd-43ff-8412-a5c9c9a99c93", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:  \n            adaptive_diff_weight *= 1.25\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < self.cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return self.cross_prob * mutant + (1 - self.cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        # Refined secondary decay influence\n        secondary_decay = (1 - self.current_budget/self.budget) ** 1.5\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Enhance directional search effectiveness by refining secondary decay influence on step size.", "configspace": "", "generation": 55, "fitness": 0.26012601519999995, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.19.", "error": "", "parent_id": "c053b97d-dafa-4aa2-b0a5-c484386bd7cb", "metadata": {"aucs": [0.5546559823970956, 0.5259725958687762, 0.42732976696967284, 0.5580673583548408, 0.4269305635745484, 0.4420282320537161, 0.6087480220368937, 0.4174650972554458, 0.5479407727070736, 0.288106409667483, 0.20575237381755607, 0.24983231976286568, 0.16302477796339665, 0.3079187685595238, 0.20776388530336765, 0.2670162955388621, 0.30493303823672535, 0.12289182034729407, 0.11880089024517837, 0.10442654205918056, 0.082772202056146, 0.10015058031203228, 0.09684901610370089, 0.09892512214202054, 0.10357469191613178, 0.1012979084066361, 0.10166264973318517, 0.09129467048149886, 0.09352400881010614, 0.09528008430696078, 0.09184063122238917, 0.08641469761693987, 0.09943407925038594, 0.09335229970648729, 0.08260300922205821, 0.08923008659818732, 0.8223583738715684, 0.851182199648119, 0.8703164670471493, 0.7703762884318924, 0.8265955224369017, 0.8741935837154577, 0.8414577236450904, 0.8580817392454188, 0.8067646530716805, 0.24129400683890012, 0.21710900535867617, 0.19000140217145922, 0.17232211249911655, 0.19503422290637018, 0.16296522791844237, 0.20106308342916712, 0.2091562500983919, 0.12685514434140877, 0.32362391622134434, 0.6519668075561963, 0.35439261886998785, 0.7093977092807218, 0.6267958871413776, 0.6742632162051543, 0.2264893435860308, 0.6324860633575491, 0.30296692495695055, 0.1645251255211435, 0.11562501158672367, 0.1918179177521726, 0.11355731618760379, 0.16559366211321924, 0.13752837225379932, 0.2080387069982319, 0.1598067310017497, 0.12124457502966868, 0.12145530006958394, 0.291960828141135, 0.1318753899329682, 0.15823834515925028, 0.11892294265461456, 0.1155245530338429, 0.13307466441266336, 0.1779346448047039, 0.15555782236613103, 0.23210486228904326, 0.297153894257827, 0.16567178600234767, 0.06878645932086314, 0.06916113170819316, 0.05543604321627227, 0.3170344223592869, 0.2629803277161811, 0.15881107572115705, 0.414474669436081, 0.3247995578759203, 0.30267226054986984, 0.23439930954003374, 0.21726818029630934, 0.4030440981769471, 0.27170137754677737, 0.17166886812187476, 0.3947599300534069, 0.07476162755031945, 0.09503838419117439, 0.05353502779937169, 0.12681854170155527, 0.11631970635192734, 0.16622487177939949, 0.07503699197921432, 0.07247812452141567, 0.055323633365442215, 0.19802594182317357, 0.1423426523159289, 0.2047538910290746, 0.14050177783889906, 0.1732297012384041, 0.1765963501277008, 0.1538196259500666, 0.16123526597422755, 0.19530930673393831, 0.39384527946834247, 0.4962679194228883, 0.4843228377287153, 0.4948471330630624, 0.46575218992534706, 0.41974848324238956, 0.45692150678240073, 0.4107563352020689, 0.3579161974477477, 0.12691351224242475, 0.12018208138583819, 0.10251853814351364, 0.11074429375630535, 0.09944996349584634, 0.10599265566784288, 0.1022344254617874, 0.09888906663970387, 0.10644464142682031, 0.13252363686267676, 0.15423033390292584, 0.16258155111975214, 0.19438669764834737, 0.13499253121105392, 0.16190445386984065, 0.1559685988755849, 0.13819493386278814, 0.1371740233867953, 0.3178230404653817, 0.3088635134149704, 0.3082567301887983, 0.32246960049878426, 0.3181326801863684, 0.3097250252789101, 0.2880807556641588, 0.3245789432517009, 0.3539291780889833, 0.23830772816969392, 0.26999360041848364, 0.24954416317810246, 0.24889741428905743, 0.27654413000122835, 0.2916302025093658, 0.2668698734026256, 0.2086160343796747, 0.26060942887445415, 0.18012231274394452, 0.19845158893878934, 0.20964635769995799, 0.17188339981956802, 0.1797198748918356, 0.20233432994178546, 0.19579528124933598, 0.18615549645405383, 0.20041198999472032, 0.1921203686716737, 0.1801036734538053, 0.1806213376269472, 0.189207498423687, 0.19259381240413975, 0.1962725041120318, 0.19856219140008768, 0.19402899231104098, 0.19856690485411088, 0.18430547393160024, 0.6698052646979862, 0.4623474962570754, 0.1813619427483113, 0.7292768121330921, 0.1617715975475419, 0.5188994209255146, 0.5705953902858213, 0.6730264914425244, 0.5040554657852164, 0.5613482562596188, 0.20521102954312664, 0.36745919385057846, 0.15815033866169903, 0.2646122878366829, 0.20112694354812233, 0.1984237759090436, 0.6797551082305942, 0.1935777721960683, 0.17763178888020703, 0.18321877594510128, 0.18215711008563196, 0.17490918275338918, 0.18802874907422396, 0.18100294157500563, 0.182026565073791, 0.18610288392270613, 0.07748687300620227, 0.07754802901581914, 0.06783005271042963, 0.08046440848960024, 0.07669985756434639, 0.07967055361467879, 0.08232366816485626, 0.06679752732633437, 0.08015414577866209]}, "mutation_prompt": null}
{"id": "78c01449-7918-42b4-9804-249e8417392e", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:  \n            adaptive_diff_weight *= 1.25\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < self.cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return self.cross_prob * mutant + (1 - self.cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        # Change: Introduce a dynamic adjustment to the step size\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Introduce a dynamic adjustment to the step size in the directional search to better balance exploration and exploitation.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c053b97d-dafa-4aa2-b0a5-c484386bd7cb", "metadata": {"aucs": [0.49993364447277167, 0.578514780538546, 0.5654213252984656, 0.5338798482202358, 0.5146886167930057, 0.5725463844532885, 0.6086323171219379, 0.5253221883193565, 0.45679305141194126, 0.08133379561967502, 0.1862113773151559, 0.275373509339256, 0.09083185569438679, 0.05073268046392165, 0.23522702219094804, 0.1592544551705405, 0.2067772141942411, 0.1623213518932134, 0.09724780079846618, 0.1246109288317706, 0.09940941787963398, 0.11050154221187891, 0.10143759286261211, 0.08804674993754269, 0.0879253961892118, 0.0950520908323107, 0.1086388980683074, 0.08041139996203728, 0.07490437418297247, 0.08430138515537966, 0.0863665516428831, 0.07387093376886023, 0.08639956504799151, 0.08282253241308757, 0.1003315014003765, 0.0881788197780825, 0.8223345247886336, 0.8511854272677393, 0.8839262241314515, 0.756894629674816, 0.8265229483018428, 0.8742059935482849, 0.8056193187500138, 0.8581623592139263, 0.8026819723487321, 0.2223555133674192, 0.2712292585276699, 0.17633747200545002, 0.18543619778546094, 0.13996336382079044, 0.13959409884086094, 0.21702909003429516, 0.17723313083812098, 0.1472045885671791, 0.636017189426187, 0.5919897540809516, 0.6662903228718402, 0.6827451433654874, 0.685182640936479, 0.7015969090620078, 0.6556140860415169, 0.6233393958505313, 0.5941729199342329, 0.12061783404489124, 0.10980935179578322, 0.13448513551898178, 0.14881033631943685, 0.20788284885952757, 0.13680318060024454, 0.1171882730702195, 0.19781587730443184, 0.13082072791674948, 0.15423969224289447, 0.25683078285755034, 0.1511513449566948, 0.14157211448873153, 0.14398169740758926, 0.16378820356132306, 0.1522433512946505, 0.19320702780187182, 0.1715740243771292, 0.29084969541882033, 0.22346637547558657, 0.22943712330247956, 0.25230624633765375, 0.07188537106233273, 0.05609935463390503, 0.23310390722446273, 0.2425543696119865, 0.2586259701361051, 0.3926467637278732, 0.43341908260182505, 0.18353799512344626, 0.41006561876025316, 0.45216103682177566, 0.22650450555709845, 0.21170821212948931, 0.3604276603989237, 0.3733123909664897, 0.10450310553193942, 0.1482568626770584, 0.17544849600051637, 0.09304632625650211, 0.058054421554266655, 0.07777191124084215, 0.08182671441063594, 0.147653878180523, 0.0949920012161789, 0.2231466285716327, 0.13487722808042235, 0.1931442880676133, 0.20405385315438118, 0.16682284038597972, 0.12394063223373597, 0.2008558578944638, 0.13807760998725083, 0.2130884007799858, 0.4319995570548194, 0.4278765926159004, 0.4060557114507901, 0.5059734525213035, 0.5072763805441065, 0.4538914723187617, 0.5014832146668265, 0.38758861044079196, 0.5160946290237778, 0.11426695155411704, 0.10361146511785391, 0.09175415146851706, 0.09300225406024043, 0.11327867078668585, 0.09764137883870205, 0.09348330450667908, 0.0971856087935028, 0.1260082458273375, 0.17028508530889974, 0.13345961410588203, 0.158508245169921, 0.17241746075109277, 0.1374302533318782, 0.15724200703757618, 0.19222261349655312, 0.12489439662595647, 0.1305866655807848, 0.30068067294968526, 0.3200224877711422, 0.28604163607321953, 0.29317170788915725, 0.2971755178546124, 0.31878879108015, 0.30540079149850385, 0.3371040615282668, 0.33889563954531954, 0.23093910568399434, 0.23286367691219856, 0.2874088160829973, 0.22982424721768524, 0.23399975144957252, 0.24989604008862643, 0.2535398466038613, 0.21024335362604696, 0.2532999747470813, 0.21758615587849495, 0.19798318266992887, 0.18916334271404156, 0.1925216980171921, 0.1819065504299865, 0.19251343164427326, 0.22998055135646722, 0.22014942184984188, 0.22336809647847056, 0.18353220973786222, 0.18411148699479685, 0.19497647254290507, 0.21080610091229923, 0.18307534781422163, 0.17347271692370814, 0.18393858450135792, 0.1972612338671148, 0.1765947174064284, 0.1835469072894641, 0.6461806890776718, 0.6030073777999956, 0.18473993666507493, 0.6971151877524451, 0.1617878627218694, 0.561773199059302, 0.5260216807938747, 0.7005943042889777, 0.6522980644837186, 0.4729243992936759, 0.20302013820920117, 0.4576544135366053, 0.15817679904045634, 0.23742691912821123, 0.19985547291534322, 0.19820981809425076, 0.3290949613614427, 0.17294748397863458, 0.18354798882517376, 0.1738807897823348, 0.18364963883110952, 0.1777652371615468, 0.19223303534973946, 0.1859254467211393, 0.1768267351142616, 0.17709547031767747, 0.0844817251969534, 0.07400208134989517, 0.08783329537843731, 0.0750267985852241, 0.07459322344957586, 0.07083731215821587, 0.08606976854743331, 0.09252637426694998, 0.06373081799426894]}, "mutation_prompt": null}
{"id": "aeded27e-57eb-46c0-a5cf-72f4e977140a", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:  \n            adaptive_diff_weight *= 1.25\n        # Modify: Introduce a weighted sum strategy\n        mutant = a + adaptive_diff_weight * (b - c) + (1 - adaptive_diff_weight) * (c - b)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < self.cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return self.cross_prob * mutant + (1 - self.cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Refine the mutant selection by incorporating a weighted sum strategy based on adaptive differential weights to enhance convergence.", "configspace": "", "generation": 57, "fitness": 0.23976969465883677, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.19.", "error": "", "parent_id": "c053b97d-dafa-4aa2-b0a5-c484386bd7cb", "metadata": {"aucs": [0.6090764375847189, 0.5090534356645346, 0.4152827018708949, 0.4764451098661092, 0.42692013465380463, 0.49609956998839877, 0.629872547429066, 0.4203798114105911, 0.49549640116571947, 0.1880878641992031, 0.0332583223824946, 0.0858522997824468, 0.13434969418777398, 0.15167288130931955, 0.11142597725638914, 0.0892097384872299, 0.1028308313450561, 0.12079770563326109, 0.11207482725658158, 0.10818755268057845, 0.102355326776429, 0.09514493116579181, 0.10389000204569365, 0.11797146222521171, 0.10855007839802189, 0.106741784138778, 0.11245022280910599, 0.09167511593325794, 0.10751251418218055, 0.08525213080319083, 0.09256243530458963, 0.11670269875708783, 0.09468120323777496, 0.09081128871483102, 0.11192388061767855, 0.11311695636025487, 0.7466359478219053, 0.8194000073981682, 0.8145735117488314, 0.8868267014909478, 0.8065738020870884, 0.8443994799324523, 0.8951368076926149, 0.8646948615046324, 0.7742188672188098, 0.17172284991744258, 0.14272905800135227, 0.15696843305931885, 0.16732402672009217, 0.16583546343184408, 0.1812034924040653, 0.22016130517772425, 0.17786669908992536, 0.12948663390881032, 0.3307767787028417, 0.3195735940528569, 0.621002014305845, 0.35034765668923284, 0.66960215403905, 0.6857692974085151, 0.21797739776184222, 0.633679931565444, 0.2801918038749639, 0.14919443248840558, 0.10561157450992709, 0.12609140205690694, 0.1331231265246714, 0.12785288464442512, 0.10990502524848722, 0.12217093273406787, 0.14339849198206245, 0.14360522711856905, 0.1696527000021557, 0.10925903227802969, 0.11369588107713047, 0.11800622160528251, 0.16025466955074352, 0.32476329337497545, 0.1696880330502918, 0.13857976134892902, 0.1267533661072333, 0.05044699977329603, 0.13857592628482995, 0.17631143929435944, 0.01122431520501721, 0.05101414654417458, 0.12866321222452626, 0.20458189852242947, 0.05043494289193495, 0.12906502391266117, 0.2063125957622799, 0.21458080881997066, 0.2063133950979481, 0.18706710950268002, 0.15360435177263465, 0.1553780636258134, 0.3378942346793813, 0.2390107215704983, 0.15966290384165005, 0.11623215207103821, 0.11368566309737016, 0.09864735686878612, 0.07224044316527967, 0.11252800564703269, 0.14878433068848684, 0.15006046184756283, 0.07430973428381948, 0.09249357508191902, 0.23182924198352428, 0.0988113761796825, 0.0691454955374784, 0.21087249453228274, 0.08462385072361978, 0.11778593776245139, 0.13258539857081053, 0.2315499284707102, 0.06545004936369259, 0.3492211095948833, 0.47355309362261955, 0.41817547907651054, 0.3491840194338022, 0.45521333239925277, 0.4774857417960713, 0.48343057607114903, 0.5138948473054004, 0.4187504604419644, 0.10214450887719617, 0.10312433162325274, 0.1138646092983141, 0.09254734893237637, 0.10398383998707106, 0.12251622492419845, 0.10230750158793622, 0.10130477775056079, 0.10042419144448778, 0.1629913432145118, 0.21164743498853322, 0.16668492180094585, 0.16853110748291333, 0.14100145124489227, 0.17169859739143523, 0.16610599469987497, 0.1448555232852463, 0.1913989911887728, 0.2954714524091553, 0.3731345961215182, 0.3118314099749566, 0.285716952039734, 0.33884294713516105, 0.33100825104150666, 0.2977751197510913, 0.2955095821701351, 0.27623078887393904, 0.20986619052502098, 0.28376142858499775, 0.2715060931417781, 0.24282766274828105, 0.22203738789539706, 0.21875473370516652, 0.2423054255399798, 0.2733680241701518, 0.21402686455131303, 0.2004979833155387, 0.20609821643432213, 0.20801102732852672, 0.17808928545740343, 0.1941774916329848, 0.17593947887929084, 0.20426916357955782, 0.20222960294324166, 0.1872154679182063, 0.19343293549651697, 0.19845956486312677, 0.18222574251431345, 0.17887229851571196, 0.17879226096289313, 0.22310656178894617, 0.18209443753521648, 0.19538298025743073, 0.2007964508595279, 0.1902223633295318, 0.7026398088595982, 0.18353956284509954, 0.15613598011458563, 0.7627993059877684, 0.3660969967942318, 0.16013086435493318, 0.6771544169434839, 0.5015431945280293, 0.6339074153083244, 0.19359715076221717, 0.19407203119944771, 0.30310867511205475, 0.1968673695325408, 0.31633140923043535, 0.33767795256878785, 0.2914898426357365, 0.3117521068470722, 0.1817228249483407, 0.1831222437974156, 0.17894536150400198, 0.17741493000338449, 0.1808251432284821, 0.17027823249771956, 0.17949381159322397, 0.2000279812843755, 0.17329709959293582, 0.08423832419229549, 0.07578064304402854, 0.08746640329561928, 0.0970243928476191, 0.07686419616221396, 0.0773518282824407, 0.09715013475600898, 0.0813109420936815, 0.07338779257026784]}, "mutation_prompt": null}
{"id": "0f364998-f2b2-4070-9c1c-9e7b8b4d64ee", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:  \n            adaptive_diff_weight *= 1.25 + 0.01  # Slightly increase diversity\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < self.cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return self.cross_prob * mutant + (1 - self.cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Enhance the exploration capability by adjusting the mutation strategy with increased diversity.", "configspace": "", "generation": 58, "fitness": 0.2603662375273053, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "c053b97d-dafa-4aa2-b0a5-c484386bd7cb", "metadata": {"aucs": [0.5155674795014092, 0.49004094564909706, 0.5701932594266883, 0.5190346765925036, 0.5768883789139969, 0.36214936648796336, 0.5290989635268708, 0.553265987908142, 0.5857211979457428, 0.10015855897884285, 0.06490331990909892, 0.007104196784337047, 0.250480226982866, 0.18473653571773307, 0.04930829765214817, 0.1362201850495096, 0.23810977389789645, 0.1665652226803277, 0.0960647099828531, 0.14938327562427423, 0.08693639015587451, 0.09551359055089292, 0.09607123675122398, 0.08399681223727962, 0.0990322130002691, 0.09720111137929166, 0.10105605978054177, 0.09062464292187578, 0.09474601873153754, 0.10589257765520921, 0.07489605858624215, 0.09339534046985731, 0.08680897274260901, 0.08543411505231047, 0.06942486359765976, 0.0910054173466045, 0.8224729836520817, 0.8563593943286192, 0.8839717002095477, 0.8087023615327014, 0.8265336655848294, 0.874206667404741, 0.8414267744584251, 0.8580294047883006, 0.8026820176741019, 0.19011247176316703, 0.21991058377835315, 0.20173899253228467, 0.18370745605768235, 0.17826249296901842, 0.15180679026768662, 0.20776151363331796, 0.20662438784585602, 0.18439183029260287, 0.32820473996829014, 0.6708889722261306, 0.3455297345745967, 0.6867915418628083, 0.5867389944952395, 0.34656850582680465, 0.325542414685845, 0.6538662199664362, 0.6136889490950925, 0.11955207398099588, 0.11545370412536327, 0.17190870978774508, 0.17782539981555512, 0.18221521574613064, 0.11363697898330105, 0.116353669644776, 0.1789751630838884, 0.15859471710453976, 0.12348700104578514, 0.13191387197839743, 0.12866261849875138, 0.13720081398906092, 0.2181651251672615, 0.11739742784019891, 0.15259140299680551, 0.18600262218257713, 0.12814865255004826, 0.28375208801111407, 0.206596790113324, 0.07972654754179198, 0.0777708793231372, 0.07170287237171524, 0.12386253616914777, 0.1770837663026994, 0.25834433056950457, 0.24777199337106626, 0.3333627593712615, 0.36293417655256277, 0.30833864707380976, 0.25534321350308486, 0.40897272685565145, 0.3375450836620877, 0.3580375026700289, 0.22715180097360854, 0.31627981135608096, 0.08568751910358074, 0.08292392075819643, 0.040260163301894525, 0.09534661107630982, 0.12041982656979366, 0.106876005086188, 0.14870584996457636, 0.09041216975745958, 0.12103578985263308, 0.21354198149293346, 0.20846103015381812, 0.19299481814582498, 0.12477005854790058, 0.20018326271261344, 0.23392284275097508, 0.19560748712145837, 0.2078856970820918, 0.18745678708936298, 0.5283361224487121, 0.3919284337221055, 0.37130513268583176, 0.5472893488518376, 0.5185012227123509, 0.5751132749956397, 0.45888420865358204, 0.4296100156220888, 0.5374531994312721, 0.11956392761234236, 0.14245668338719897, 0.11316100577414401, 0.11929192587725213, 0.09550109893399061, 0.1014172033363564, 0.09199636417831247, 0.11953619043207686, 0.1027820921111281, 0.147981662461937, 0.1385108414260069, 0.2127714383165129, 0.17338974265572782, 0.15398658469542092, 0.1777348305085863, 0.1571007882604053, 0.16026553988436976, 0.13361894031562827, 0.28311440894943396, 0.3230001059752142, 0.29146953606623915, 0.3275081701909349, 0.2893068092244715, 0.28450070772329505, 0.29602316100624504, 0.29967639521629663, 0.2877534577751273, 0.2269957960707325, 0.2173709436743102, 0.26110362540101273, 0.2238013148235003, 0.27843188732779256, 0.27153553581515777, 0.25623492620173083, 0.26921343944538334, 0.25136689389714306, 0.2000309086781772, 0.1857268558847699, 0.18455968104861264, 0.1957004175343151, 0.17380535739440217, 0.21659045092712415, 0.1939206787847233, 0.18270734279004042, 0.23398333232245838, 0.1974175754039882, 0.17949209595510496, 0.18364505119588104, 0.20398479080466647, 0.20387027628659415, 0.18735892351443317, 0.1871998052038233, 0.18283526561617813, 0.19323586960545613, 0.6388346833749731, 0.7637456610017374, 0.6463490175830131, 0.18305473274313544, 0.60804910047322, 0.16166078014369578, 0.45318920323753886, 0.5027428700996954, 0.6621865440541743, 0.5510054200591116, 0.6261249896847492, 0.20440640196025073, 0.344879174017513, 0.15762350291733362, 0.19558690816324154, 0.3300711885106433, 0.19807081415148942, 0.19770628709694493, 0.18267640920947326, 0.18642853484402833, 0.18519805859496175, 0.1943501126291225, 0.1813577569217446, 0.17676728976571865, 0.1858696341028675, 0.17950272311899518, 0.19339223313196885, 0.08234684427905936, 0.08348450163065968, 0.07687315089096958, 0.07952366369549002, 0.07191395729726335, 0.0702504531631174, 0.08421354121486824, 0.0688916322382509, 0.08411386034472512]}, "mutation_prompt": null}
{"id": "ab1eac4b-c8df-4a3d-b2aa-72eff8e8d2eb", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        secondary_component = 0.2 * np.random.rand()  # Change\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate) + secondary_component  # Change\n        if success_rate > 0.5:  \n            adaptive_diff_weight *= 1.25\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < self.cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return self.cross_prob * mutant + (1 - self.cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Enhance the mutation strategy by adding a second adaptive component to the differential weight, improving convergence speed.", "configspace": "", "generation": 59, "fitness": 0.25328524229726346, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.18.", "error": "", "parent_id": "c053b97d-dafa-4aa2-b0a5-c484386bd7cb", "metadata": {"aucs": [0.4876638216185005, 0.5430331741466552, 0.4724012838898579, 0.5069188349387921, 0.5686379663079848, 0.5504307145731455, 0.5013799347756139, 0.5421104644836763, 0.5510097575279449, 0.20614670083233622, 0.2388195635972017, 0.24435216758349232, 0.19264389840482654, 0.23079460082972814, 0.23297487062583455, 0.24637862851823467, 0.24478564650661916, 0.1986017351423145, 0.09011370142235842, 0.07982013597915794, 0.09642161852897113, 0.08401662912873764, 0.0827776932033415, 0.09739294482776495, 0.09495363724867878, 0.10011313872521788, 0.0925827975246013, 0.08362244129144147, 0.06698141067047125, 0.07500287156161844, 0.0756150165368441, 0.0825373130702668, 0.07835037413708901, 0.09722421188108399, 0.08137957604192347, 0.08469673046512693, 0.7892186396315642, 0.8326766761904885, 0.7800470814727418, 0.88446130115439, 0.7693522487806286, 0.7689695927343416, 0.8629819199388921, 0.7807606219424825, 0.8409242237904695, 0.17277274313020408, 0.24505610470539463, 0.17823025195261433, 0.18756770305690107, 0.21623131620064995, 0.21948662062339386, 0.2314557664661845, 0.21894053838135685, 0.24639656785951813, 0.5563758970597112, 0.5767136264633527, 0.5283778943948789, 0.6377498689296335, 0.6145688543638328, 0.5458962474620388, 0.586713067159139, 0.5045321748595699, 0.540457961990983, 0.13412777830992362, 0.18259000175413787, 0.14254882189329598, 0.11985456161000752, 0.15598441157719223, 0.11409536164258172, 0.2153074155108038, 0.1477348309103892, 0.12723870848945917, 0.13926955458871726, 0.14351095958739568, 0.1611010840936411, 0.17979220218349423, 0.13496991639172706, 0.14467614088625635, 0.18243088837164434, 0.15043387475637715, 0.14460415742078636, 0.20764357526313493, 0.24270008351892913, 0.11161082431180835, 0.18407052383654887, 0.23972418289931952, 0.1910224098091754, 0.20874032326382108, 0.18910941610282117, 0.1676308520815012, 0.3159921310275773, 0.3475195073939762, 0.35135776396406704, 0.3023923924647307, 0.3328984237870878, 0.3152584301296433, 0.40073269354049124, 0.3098661553259885, 0.33108558965527435, 0.04340539525417331, 0.07155484380124777, 0.02890758648131797, 0.04131081043893825, 0.08699961553384417, 0.08484797477354244, 0.04547298969301106, 0.062396545423989314, 0.07634974404122463, 0.14507043153648702, 0.1728693209022596, 0.16509823001213697, 0.1404685661137426, 0.14454748541295703, 0.19128286895822844, 0.1674938086662351, 0.18337123852846382, 0.1436800394213511, 0.43916519396441034, 0.48477047748663327, 0.49330082229052663, 0.4510324706651837, 0.4570290352084737, 0.49672048450353956, 0.4153750033334842, 0.5079113953892023, 0.4817064852748131, 0.1065639137036315, 0.08017113820843003, 0.08962732449429733, 0.08040120637845849, 0.09326093820475911, 0.1190008473862797, 0.09255627035124758, 0.09416268540755934, 0.08949078346079875, 0.13122064148561408, 0.12380967628257766, 0.13839155165419392, 0.1419712665259818, 0.17778567265744072, 0.13564518087612054, 0.16030341311195084, 0.16480582742041783, 0.17727014550138143, 0.2702204644762556, 0.3090578767179917, 0.2694083842164192, 0.28287580606664064, 0.29128692634396625, 0.2784346272743483, 0.2828687755776341, 0.2778069082804894, 0.2799691666557217, 0.2264954691691009, 0.2549772257248283, 0.2163232046077057, 0.2261204008909551, 0.24276802497623406, 0.2371915812936094, 0.21812481078653534, 0.2433772275117888, 0.24785416808267058, 0.194869659403766, 0.18635309361479546, 0.19248312747645613, 0.1904324802405225, 0.1837415346588398, 0.1914706875764718, 0.20665628253716195, 0.21080854292493267, 0.18959931567873423, 0.17705853794102422, 0.16919631121556267, 0.16978920672218423, 0.1797361632357286, 0.16851895083510138, 0.17486646765851088, 0.17826453512402696, 0.19215254592951703, 0.1916697323509884, 0.4769897088351379, 0.1838171682960963, 0.49958730819930075, 0.17120577005822601, 0.5362755246791987, 0.555926149084983, 0.4654292710246718, 0.5364598563013648, 0.49493247500159543, 0.25136448389279054, 0.2703612116794818, 0.19115677384720897, 0.27095190889020626, 0.16005024978743365, 0.19631705154550705, 0.20007878368713106, 0.20133159849329907, 0.15537030422094744, 0.18018386527204933, 0.1912111938571872, 0.1965722724620056, 0.18417498465750026, 0.18014496086603016, 0.19155901384114404, 0.18856172562542228, 0.2055495518399434, 0.17634010522876775, 0.07536632821465505, 0.08009770974780672, 0.07344572288255424, 0.07058737844295282, 0.07340265613361074, 0.08191585381519495, 0.08662999296549223, 0.0653826225860028, 0.08024776465169692]}, "mutation_prompt": null}
{"id": "82b8b7e8-f48e-47eb-b343-c34bcc72757d", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:  \n            adaptive_diff_weight *= 1.25\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < self.cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return self.cross_prob * mutant + (1 - self.cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        # Refine: Exponential decay in step size\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * np.exp(-budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Refine the dynamic adjustment in step size using an exponential decay factor for improved balance in exploration and exploitation.", "configspace": "", "generation": 60, "fitness": 0.26372712055191994, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "c053b97d-dafa-4aa2-b0a5-c484386bd7cb", "metadata": {"aucs": [0.5627737812920459, 0.4718201012485901, 0.5144509121820424, 0.4362351896438106, 0.6268563195601037, 0.5897002323466903, 0.5615646207713111, 0.5981353445680384, 0.4745107643831258, 0.080423807814191, 0.24952579304158484, 0.18166631262608657, 0.08606095600787356, 0.3179390271581034, 0.34706152213617203, 0.2757464365627298, 0.2059042530293359, 0.106891341816718, 0.07974612413599369, 0.1248984505101769, 0.10666444007733078, 0.11160747900852674, 0.1007425639452122, 0.08918917676856086, 0.09391777353123876, 0.09104233030220166, 0.1085209716022697, 0.08192007324783734, 0.07559314675580153, 0.08299323184537355, 0.09277874880237125, 0.06692459514046045, 0.08918398924674475, 0.0815470448171145, 0.08030788521890608, 0.09197114803928674, 0.8223344397050316, 0.8511853214233938, 0.883927244343707, 0.7431263591459232, 0.8265247924849076, 0.8742059433202304, 0.8056216893279824, 0.8581631553175859, 0.8026840370862194, 0.2518634946926831, 0.2579038212432022, 0.17240579984695326, 0.17429448760609378, 0.13773490522837895, 0.1747295859406911, 0.2082756371508595, 0.1755684861329435, 0.15492761170244485, 0.5807158414166755, 0.5793349256941618, 0.6680493079744393, 0.6827451433654874, 0.3949080539386076, 0.7027497906032415, 0.630514673853437, 0.726333089395099, 0.5095301341796721, 0.12335129049484184, 0.10966890631130732, 0.13508518829206717, 0.1551579431268143, 0.2037706044687032, 0.14724413738818531, 0.11852873257937113, 0.18000493300179699, 0.13122428611819725, 0.15193410915395544, 0.2818607620071666, 0.15182892137885806, 0.1417372925356125, 0.151789609270913, 0.1623955115626965, 0.14438440463676083, 0.19935527127006114, 0.13299044227530832, 0.3169862462458123, 0.257557977251039, 0.15994223820647402, 0.06698635723022894, 0.07495572526304262, 0.058619633563474216, 0.2536480920519637, 0.26390899943396284, 0.21726043385412286, 0.3837551364946029, 0.38830202175336626, 0.23877891903952764, 0.38796704944910065, 0.2580404773585334, 0.2571161759481815, 0.19590560385153155, 0.3591757854562142, 0.2045475331010418, 0.07175505450312136, 0.12261843619321722, 0.11708769606969349, 0.07504861054393108, 0.06855990085770658, 0.06645809083886689, 0.10991783499433094, 0.1339503972843329, 0.09690301055879957, 0.23489413155145122, 0.18563091420468203, 0.21809191086758106, 0.21368607822032926, 0.1581813973855225, 0.16728007864866068, 0.17062711976130873, 0.13715242486609747, 0.22419635426667717, 0.3963492054370219, 0.4939384929639422, 0.42356047426944166, 0.5233816453910598, 0.4972154098453089, 0.4621199252427681, 0.4896591816768169, 0.4097820371222013, 0.3450779087437513, 0.10046425457697772, 0.10373925006236095, 0.0884165948082033, 0.09282847154634455, 0.11349068595971457, 0.09770631882762337, 0.09834325479663475, 0.10962852849920113, 0.127795057119497, 0.14854899359260343, 0.16093335249505702, 0.15595514928081378, 0.15420958399509566, 0.15718109985331064, 0.156037484093131, 0.14859578787102712, 0.14249741088515022, 0.1532166784264054, 0.2655523012122737, 0.3098647263940375, 0.2710781770804418, 0.28000830280475986, 0.2906328107168977, 0.27435481567805675, 0.3084313418039749, 0.31155019320751276, 0.33673841973108887, 0.2608451732483018, 0.2382223610452574, 0.2696063247524214, 0.21792468596946912, 0.2490468481077659, 0.26004248250367057, 0.2613424860938016, 0.2481513919067192, 0.28315555686982696, 0.19515180107217445, 0.17204604232795118, 0.19439950453591548, 0.19867571425233532, 0.19354846519802382, 0.20149566751167625, 0.21674875723886555, 0.18155010186307308, 0.21228102052549525, 0.1835934265966268, 0.1849197204020686, 0.19193473553970797, 0.1878232407017324, 0.18272930348282324, 0.1732771153002588, 0.1916246694009872, 0.19758069501491438, 0.18481032251747342, 0.1835412116308741, 0.6292253019145655, 0.5960680983570459, 0.18066139735570774, 0.7283766244510349, 0.16178794616476677, 0.5299603655501222, 0.49876817455489353, 0.6984673420920138, 0.652575148787086, 0.5056445015660997, 0.20346695951167415, 0.4572983850921484, 0.15818115493186558, 0.19458445030071314, 0.19984906591618823, 0.19820711071821395, 0.36456330045589225, 0.189712601957715, 0.1748298321427566, 0.1795539926852998, 0.18556943554541683, 0.16974385916465473, 0.1928957103209774, 0.19125167479822391, 0.1869999123619951, 0.19568594060658473, 0.08712524359511209, 0.08203651796414091, 0.08259361891990069, 0.0752161779756354, 0.07600853136910934, 0.07559758457840049, 0.08389226035035047, 0.07070998485529145, 0.06801782633723341]}, "mutation_prompt": null}
{"id": "ce41c8d9-8242-413e-a0fd-33784e8dc280", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:  \n            adaptive_diff_weight *= 1.25\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < self.cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return self.cross_prob * mutant + (1 - self.cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        # Change: Introduce a dynamic adjustment to the step size\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Introduce a dynamic adjustment to the step size in the directional search to better balance exploration and exploitation.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c053b97d-dafa-4aa2-b0a5-c484386bd7cb", "metadata": {"aucs": [0.49993364447277167, 0.578514780538546, 0.5654213252984656, 0.5338798482202358, 0.5146886167930057, 0.5725463844532885, 0.6086323171219379, 0.5253221883193565, 0.45679305141194126, 0.08133379561967502, 0.1862113773151559, 0.275373509339256, 0.09083185569438679, 0.05073268046392165, 0.23522702219094804, 0.1592544551705405, 0.2067772141942411, 0.1623213518932134, 0.09724780079846618, 0.1246109288317706, 0.09940941787963398, 0.11050154221187891, 0.10143759286261211, 0.08804674993754269, 0.0879253961892118, 0.0950520908323107, 0.1086388980683074, 0.08041139996203728, 0.07490437418297247, 0.08430138515537966, 0.0863665516428831, 0.07387093376886023, 0.08639956504799151, 0.08282253241308757, 0.1003315014003765, 0.0881788197780825, 0.8223345247886336, 0.8511854272677393, 0.8839262241314515, 0.756894629674816, 0.8265229483018428, 0.8742059935482849, 0.8056193187500138, 0.8581623592139263, 0.8026819723487321, 0.2223555133674192, 0.2712292585276699, 0.17633747200545002, 0.18543619778546094, 0.13996336382079044, 0.13959409884086094, 0.21702909003429516, 0.17723313083812098, 0.1472045885671791, 0.636017189426187, 0.5919897540809516, 0.6662903228718402, 0.6827451433654874, 0.685182640936479, 0.7015969090620078, 0.6556140860415169, 0.6233393958505313, 0.5941729199342329, 0.12061783404489124, 0.10980935179578322, 0.13448513551898178, 0.14881033631943685, 0.20788284885952757, 0.13680318060024454, 0.1171882730702195, 0.19781587730443184, 0.13082072791674948, 0.15423969224289447, 0.25683078285755034, 0.1511513449566948, 0.14157211448873153, 0.14398169740758926, 0.16378820356132306, 0.1522433512946505, 0.19320702780187182, 0.1715740243771292, 0.29084969541882033, 0.22346637547558657, 0.22943712330247956, 0.25230624633765375, 0.07188537106233273, 0.05609935463390503, 0.23310390722446273, 0.2425543696119865, 0.2586259701361051, 0.3926467637278732, 0.43341908260182505, 0.18353799512344626, 0.41006561876025316, 0.45216103682177566, 0.22650450555709845, 0.21170821212948931, 0.3604276603989237, 0.3733123909664897, 0.10450310553193942, 0.1482568626770584, 0.17544849600051637, 0.09304632625650211, 0.058054421554266655, 0.07777191124084215, 0.08182671441063594, 0.147653878180523, 0.0949920012161789, 0.2231466285716327, 0.13487722808042235, 0.1931442880676133, 0.20405385315438118, 0.16682284038597972, 0.12394063223373597, 0.2008558578944638, 0.13807760998725083, 0.2130884007799858, 0.4319995570548194, 0.4278765926159004, 0.4060557114507901, 0.5059734525213035, 0.5072763805441065, 0.4538914723187617, 0.5014832146668265, 0.38758861044079196, 0.5160946290237778, 0.11426695155411704, 0.10361146511785391, 0.09175415146851706, 0.09300225406024043, 0.11327867078668585, 0.09764137883870205, 0.09348330450667908, 0.0971856087935028, 0.1260082458273375, 0.17028508530889974, 0.13345961410588203, 0.158508245169921, 0.17241746075109277, 0.1374302533318782, 0.15724200703757618, 0.19222261349655312, 0.12489439662595647, 0.1305866655807848, 0.30068067294968526, 0.3200224877711422, 0.28604163607321953, 0.29317170788915725, 0.2971755178546124, 0.31878879108015, 0.30540079149850385, 0.3371040615282668, 0.33889563954531954, 0.23093910568399434, 0.23286367691219856, 0.2874088160829973, 0.22982424721768524, 0.23399975144957252, 0.24989604008862643, 0.2535398466038613, 0.21024335362604696, 0.2532999747470813, 0.21758615587849495, 0.19798318266992887, 0.18916334271404156, 0.1925216980171921, 0.1819065504299865, 0.19251343164427326, 0.22998055135646722, 0.22014942184984188, 0.22336809647847056, 0.18353220973786222, 0.18411148699479685, 0.19497647254290507, 0.21080610091229923, 0.18307534781422163, 0.17347271692370814, 0.18393858450135792, 0.1972612338671148, 0.1765947174064284, 0.1835469072894641, 0.6461806890776718, 0.6030073777999956, 0.18473993666507493, 0.6971151877524451, 0.1617878627218694, 0.561773199059302, 0.5260216807938747, 0.7005943042889777, 0.6522980644837186, 0.4729243992936759, 0.20302013820920117, 0.4576544135366053, 0.15817679904045634, 0.23742691912821123, 0.19985547291534322, 0.19820981809425076, 0.3290949613614427, 0.17294748397863458, 0.18354798882517376, 0.1738807897823348, 0.18364963883110952, 0.1777652371615468, 0.19223303534973946, 0.1859254467211393, 0.1768267351142616, 0.17709547031767747, 0.0844817251969534, 0.07400208134989517, 0.08783329537843731, 0.0750267985852241, 0.07459322344957586, 0.07083731215821587, 0.08606976854743331, 0.09252637426694998, 0.06373081799426894]}, "mutation_prompt": null}
{"id": "6ff644f9-4220-4ce6-98ba-e5e0ddda43c2", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        budget_ratio = self.current_budget / self.budget\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate) * (1 + 0.5 * budget_ratio)  # Change: Added budget ratio factor\n        if success_rate > 0.5:  \n            adaptive_diff_weight *= 1.25\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < self.cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return self.cross_prob * mutant + (1 - self.cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Improve exploration by dynamically adjusting the differential weight based on the current budget ratio.", "configspace": "", "generation": 62, "fitness": 0.2671230193749865, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.20.", "error": "", "parent_id": "c053b97d-dafa-4aa2-b0a5-c484386bd7cb", "metadata": {"aucs": [0.5572812148983476, 0.5523130061387804, 0.4901682660562182, 0.5369782030753496, 0.5731875261317929, 0.5516508589659201, 0.5088639727276274, 0.57361786068516, 0.5153102223990186, 0.25997719728923085, 0.22850475809698023, 0.195101771720112, 0.2852502317144914, 0.2627167210825355, 0.11468544789001067, 0.26610796641073164, 0.2600083378178194, 0.11340580645950338, 0.13374528635781424, 0.10345437349526188, 0.12360559440348295, 0.08973611593968522, 0.09876397669208814, 0.11390762622445605, 0.09083444958296294, 0.11799519678939341, 0.10423484101853031, 0.07635590019146443, 0.095845293347541, 0.11325502313244507, 0.09300862446962832, 0.0721846922890641, 0.10244024040296795, 0.10240607694565673, 0.07980169777797497, 0.08300922164406344, 0.8209651638102472, 0.8516318683996541, 0.8810327550162973, 0.7673568500800028, 0.7725072592191807, 0.8742433462071653, 0.8256709835338946, 0.8577983049859594, 0.7964851201787746, 0.16879475738858596, 0.1697052324368724, 0.14109246781150264, 0.25636204999293255, 0.15802572205451537, 0.19981910332491593, 0.19715777772076404, 0.203141091534635, 0.2082869738914136, 0.5921098914889806, 0.6433243612536402, 0.5935146989124873, 0.5916210777772684, 0.6363850164032314, 0.33234667218648695, 0.7171087644873757, 0.7564237653352406, 0.4161255127723079, 0.16107894842077253, 0.1986135260939781, 0.14685286634287076, 0.11795149444732156, 0.17045410103704106, 0.16648384516399006, 0.11282739325151592, 0.1274092214817909, 0.117662993148545, 0.11779646114890097, 0.1493315381474174, 0.17515642956326738, 0.14058316988346742, 0.1527843152690973, 0.17089985810084285, 0.11785159054223637, 0.24429950293651748, 0.16949574360841924, 0.24270156569967405, 0.28869165932901464, 0.2062816612538131, 0.25570859700944937, 0.11487515091138434, 0.09563760936900068, 0.10931953009244566, 0.038504199137038286, 0.26692186689416686, 0.41609093665353425, 0.37600879392643416, 0.369173535761841, 0.3281605250836286, 0.15397458325413604, 0.1446053761047298, 0.3730175323731093, 0.33776668776657626, 0.3347598038891678, 0.07549333702848382, 0.07726514891724945, 0.015138504665094255, 0.08385605371232485, 0.04309771819526764, 0.0574610080221708, 0.09555661772184898, 0.0586603486824111, 0.07677520550824357, 0.16960150125681317, 0.194726923805693, 0.15851261689366747, 0.15784464828590994, 0.23555682290692215, 0.1866353340697553, 0.2019429303427661, 0.1529081185048934, 0.18107597607445636, 0.4862539467835526, 0.49703620578642016, 0.5494373579282927, 0.4957813998461482, 0.4811021394507913, 0.5639735132873549, 0.5094743271484059, 0.5233556833632158, 0.4102428014152528, 0.0989386572238129, 0.13243236056128993, 0.1045575294653247, 0.0952930805430231, 0.11628222468862037, 0.1007173657513406, 0.11391635065899064, 0.11989198641252752, 0.09426622855033151, 0.14794819204064802, 0.14610641827820325, 0.19180422109337947, 0.17099248089181251, 0.1491613778751787, 0.1845760339219571, 0.13975740620630128, 0.13346619138169857, 0.15253581098323898, 0.29805729628505473, 0.31135736030272887, 0.3128861937690851, 0.2880025825961682, 0.27708957346607854, 0.3001991603114693, 0.3123054661885678, 0.3022124180802249, 0.30527655915602403, 0.23900031765083485, 0.25225652017968614, 0.24795702196281988, 0.2129694623566385, 0.26360179761409586, 0.2622514987307851, 0.2460161944108168, 0.27189911002647715, 0.305607781374419, 0.17427030329873472, 0.1885907205802394, 0.20514756342802365, 0.17988733912787758, 0.18528414691335104, 0.187579285793115, 0.1857624837796491, 0.17526251502823365, 0.19639913162979183, 0.186317892703024, 0.1701357410006583, 0.18654031776748237, 0.17739193607889958, 0.18603423955686382, 0.17948753447102517, 0.1857387373632421, 0.1902495119340658, 0.18387779642193625, 0.185254194479337, 0.567332125810602, 0.5703228941518165, 0.18365197355570917, 0.6826289961967749, 0.16146998286627878, 0.5264438394968112, 0.6385448463571601, 0.6795086277204856, 0.6148576068561329, 0.5175539238657847, 0.2036932127911114, 0.41119398517919736, 0.15754547850334277, 0.19540721937371086, 0.2054365383578327, 0.5826769690103749, 0.5538731082350561, 0.18886111834393127, 0.17414684048014029, 0.17872947169944342, 0.18293171741695513, 0.17995613562230306, 0.19220872994384697, 0.1801210231283792, 0.19966943172147267, 0.17361881665150014, 0.07141282719488207, 0.07299051717839833, 0.07929779712813656, 0.07675401108049551, 0.07649043842596803, 0.07190337628910515, 0.07096190053015494, 0.07310460393547324, 0.07522148638413106]}, "mutation_prompt": null}
{"id": "bc420af6-bbc1-46e3-8e98-b9fdf18c459e", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:  \n            adaptive_diff_weight *= 1.25\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < self.cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return self.cross_prob * mutant + (1 - self.cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        # Change: Introduce a dynamic adjustment to the step size\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.015 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Improve search by introducing adaptive crossover probability based on fitness improvements.", "configspace": "", "generation": 63, "fitness": 0.26421335478520036, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "c053b97d-dafa-4aa2-b0a5-c484386bd7cb", "metadata": {"aucs": [0.5965197076900504, 0.5573286969615869, 0.4212677058025146, 0.5577966955965457, 0.5153738438391455, 0.5224767862647403, 0.5391701791470382, 0.5167324631296935, 0.5919104801972079, 0.22464227075428544, 0.07157951126758877, 0.20293703238497252, 0.30987735562617025, 0.24292165159910994, 0.09926440349146648, 0.24981165127764082, 0.18385105460084794, 0.06603941704512928, 0.10269035703536533, 0.11130328135087242, 0.1442322499969143, 0.08155942218280066, 0.11035780704554776, 0.11061497788209795, 0.1100061272174433, 0.09469382506607293, 0.09620096715242776, 0.08407014667386536, 0.08911931420927544, 0.09820311206234877, 0.0760448665983895, 0.08133771074380369, 0.10471966360047513, 0.08318770843178869, 0.09385326220992118, 0.09099647278673706, 0.7558857100632026, 0.8431886181088752, 0.8832330963114047, 0.809847162169939, 0.7813434595114406, 0.8879445917690131, 0.8053038988893821, 0.8547083575477908, 0.8247043129905488, 0.20978366663457282, 0.15997278754533895, 0.16750184073078034, 0.1677127934316588, 0.2450182989635027, 0.1417764610759672, 0.1863042624653224, 0.18227114474335515, 0.21700351049455335, 0.6350067702616806, 0.6294517459247144, 0.686869428594508, 0.6413287249977238, 0.7057374077473754, 0.2927722469506562, 0.48230900702035373, 0.6559839556293237, 0.7237322681878745, 0.13460037131605063, 0.1655184497180242, 0.15561854692369126, 0.11093860690847868, 0.1346117685478737, 0.19779070132866017, 0.2025066844232455, 0.17821532497415227, 0.1439477286272557, 0.19526305407440525, 0.1655398935883029, 0.12828047781438856, 0.15172221337969038, 0.1083121239581869, 0.22631932936406907, 0.11635020307326538, 0.21746731383335804, 0.16672096017169769, 0.20832692952895748, 0.27115432105368464, 0.16708111711745, 0.15505166653545488, 0.08157116545018817, 0.05345479535168174, 0.2352696114269509, 0.07491242433396927, 0.3004647435588139, 0.4192568312319612, 0.4522414551820463, 0.2595189288422247, 0.3973646911219757, 0.20501051138059467, 0.21981360797878247, 0.39358820388650395, 0.16390223732037335, 0.3250209680621873, 0.048876421419324245, 0.08197034020134308, 0.03702856581572378, 0.10053840630772337, 0.14685416359365266, 0.14635729901659855, 0.08084997418720485, 0.11413539292866792, 0.06631402087161531, 0.09994348125208596, 0.11172812238990537, 0.1820856183763866, 0.20520716537908867, 0.07550775863840442, 0.1864173029252293, 0.2054723433147294, 0.12752999302849055, 0.08631646930536319, 0.47978804982901624, 0.5357738746454701, 0.5392410604426685, 0.45830450133155476, 0.35842498577322435, 0.5044991971986491, 0.49423022270803607, 0.432173917320939, 0.40717142426691233, 0.11070998443259739, 0.09071087001345113, 0.11816341260867647, 0.09798564722318137, 0.10598125476916942, 0.11798207476866285, 0.10829819061266188, 0.1132490270934905, 0.09244051353102334, 0.1606649812056954, 0.14275202512520158, 0.17968404801607263, 0.1498428195182443, 0.12995691312413982, 0.19889763323057708, 0.18779522628073342, 0.1713984032406941, 0.1412200436072628, 0.29046713269941316, 0.300292889109096, 0.30883988242454286, 0.3118301256151127, 0.260934248459636, 0.2725665410952668, 0.2949366104374863, 0.2652282787599082, 0.2638759631242269, 0.24113137978969068, 0.23070607663222475, 0.2388833317549287, 0.2044878112815034, 0.27617985545112, 0.2726125092086018, 0.21653451595643924, 0.2562228672651581, 0.2671489868895859, 0.18286481721904246, 0.19481705480732903, 0.20917597596684623, 0.18498894679055633, 0.19213647401985623, 0.18647624854367673, 0.20096225205029228, 0.20475207129698825, 0.19808279315907962, 0.17956363907936213, 0.18849377777206733, 0.19417812548416324, 0.19475791121765273, 0.1865368052440909, 0.21127333405833248, 0.18829892184606933, 0.1964952140615296, 0.19903516458967285, 0.18430829726008358, 0.3970544557039182, 0.7010159255767089, 0.18156571896285956, 0.6487424051657685, 0.6548704611684222, 0.4789481195331412, 0.5392827266643841, 0.6767774091083685, 0.6100757426963653, 0.16689817367292326, 0.20471511104591322, 0.6082730461362174, 0.15794372451783423, 0.24807696276978008, 0.20113603122997037, 0.505875557191257, 0.4330487173397539, 0.19029401941232305, 0.18058562940085665, 0.1846250812827147, 0.19050642651894856, 0.19550232832150993, 0.1774840368905205, 0.18606094971235265, 0.18911692029616112, 0.18737658894290488, 0.07258897996414071, 0.0752903563170465, 0.10045659376360094, 0.0740599672677208, 0.07151479304133901, 0.08004717111218329, 0.07934442951857035, 0.07416209952576414, 0.07410233346951822]}, "mutation_prompt": null}
{"id": "77dcdd7e-3106-4768-af42-2244e8729bc6", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:  \n            adaptive_diff_weight *= 1.25\n        # Change: Increase diversity influence in mutation\n        diversity_factor = np.std(population) / (self.upper_bound - self.lower_bound)\n        adaptive_diff_weight *= 1 + diversity_factor\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < self.cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return self.cross_prob * mutant + (1 - self.cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Introduce adaptive mutation based on population diversity to enhance convergence.", "configspace": "", "generation": 64, "fitness": 0.26354213382239633, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.19.", "error": "", "parent_id": "c053b97d-dafa-4aa2-b0a5-c484386bd7cb", "metadata": {"aucs": [0.5605770359513544, 0.5089075073245427, 0.5481082485497876, 0.5264103463356253, 0.5224613031517664, 0.4781786488952362, 0.5216587243161208, 0.563992688335311, 0.5083541621678136, 0.2212652875763308, 0.24842968406007981, 0.2094080679730005, 0.24580345974654738, 0.23745135056355204, 0.2532141926409448, 0.14729623648302437, 0.228977636827568, 0.2328592515221355, 0.11831834705677557, 0.09007984096666732, 0.0848102388912364, 0.09487343358158651, 0.09825924358724625, 0.09887488079380657, 0.10144652663797082, 0.11772179569559427, 0.13084061736924413, 0.08852459128649914, 0.09170903108363349, 0.08441780947931543, 0.0811119202540993, 0.07214336451129677, 0.08257352754189429, 0.10076553882886452, 0.09243560899883618, 0.09401084187968123, 0.7894894213771299, 0.8371094453528769, 0.8627581010779333, 0.8147333918085125, 0.8646148434837433, 0.9060742541743365, 0.7418218275275896, 0.861957491104312, 0.8808695793119455, 0.24249504289756285, 0.2537942118108877, 0.2403800376840639, 0.23985547824412778, 0.2394205587979833, 0.2190591686370248, 0.1568436816040294, 0.1997520993158819, 0.18663567152755622, 0.3134985447791143, 0.6001655633641501, 0.6642992181252008, 0.6941430990160051, 0.5616854599527463, 0.6416224729689672, 0.7130973483685159, 0.6246511006396605, 0.5976410268924395, 0.14351557730237396, 0.16274060530508172, 0.11211035846489736, 0.15733937484598026, 0.18890236226149804, 0.1376049440455248, 0.2429543582987158, 0.1890612429253662, 0.15194503594576925, 0.1443666738194701, 0.19216546900781084, 0.13994447413059463, 0.1282512849510855, 0.15820103321998447, 0.12738963618453802, 0.1542962579233621, 0.14118808144328598, 0.14786726284199125, 0.18518948877827623, 0.2304727521465294, 0.24817586897426713, 0.17551081848633343, 0.17780638684054428, 0.19844294268874418, 0.18097470032232033, 0.20472422567402693, 0.26510633577604426, 0.2541784244066495, 0.2718014136806628, 0.341857929449936, 0.3432223959092394, 0.14885561274267178, 0.29663907519085053, 0.32946444230311767, 0.32394868773981855, 0.3207517314193725, 0.0691266495014159, 0.0985395341462052, 0.026802100379741067, 0.049780785395267424, 0.0925173043316263, 0.08199100913087021, 0.05304612047217472, 0.05851198679351599, 0.0681100731246248, 0.16494013084013337, 0.16015539260621192, 0.1812456023049337, 0.13992133463964673, 0.18186013628011544, 0.12958626223784508, 0.14948516587651994, 0.1845002438972252, 0.1754802265437967, 0.5085990259756532, 0.48099080365027835, 0.45756815091471503, 0.44585522237838626, 0.4879858670110089, 0.4979629402109804, 0.4824418627057374, 0.48601205246874957, 0.5023548811396618, 0.09093071498780769, 0.09637653316418437, 0.10626484962283844, 0.11049603362054172, 0.09005435271533391, 0.12588586113547795, 0.09460266331700717, 0.09329541391985952, 0.09918881801103874, 0.14585930539844671, 0.13096411271933228, 0.14771193331172872, 0.17495043997659088, 0.1393549005793897, 0.1591269111428859, 0.15683446871380347, 0.18522441133031775, 0.12002898049482214, 0.2908768995909188, 0.30318687773337694, 0.31081311001635115, 0.2933296016849445, 0.2828049791470262, 0.3054068228239003, 0.3067986754867863, 0.28877745964641965, 0.32334010545654535, 0.24300450801171414, 0.22891501195960118, 0.2594844740799057, 0.22997997730378095, 0.2230714060181136, 0.2195375248340875, 0.2532532330559437, 0.2150460327515945, 0.23395883823161623, 0.20185772887237086, 0.1961804261048391, 0.19027131775232287, 0.16983444134580516, 0.18061633226089668, 0.17358149203101114, 0.1796467085367094, 0.1978892995866739, 0.18592008365393853, 0.2101925973810097, 0.1912763787946805, 0.1846205272808651, 0.18656021406399825, 0.18201147102108783, 0.18379326105740246, 0.20239814161104663, 0.18794090122160245, 0.19475303773726182, 0.17838741487999343, 0.615832113190869, 0.6247791501833677, 0.4834213097220168, 0.5347086027862074, 0.5307541015806181, 0.392379924834913, 0.605810582566179, 0.5634087784308891, 0.16811042173585733, 0.19986225466569751, 0.19757022102596988, 0.2997291326640804, 0.1908869002827972, 0.5368990758090959, 0.2032686212789846, 0.41865175880493255, 0.1994959907423437, 0.18774632381834655, 0.18172848376864636, 0.1795275842357027, 0.1808364513425823, 0.18989033928030297, 0.18009685980543566, 0.185617064351268, 0.17852768803240326, 0.17496139786406384, 0.08076673950756341, 0.08765462434092042, 0.06779474478619174, 0.07709890992081159, 0.06881788776458708, 0.07035834241668437, 0.08328041741939884, 0.08625120566244204, 0.075031622714818]}, "mutation_prompt": null}
{"id": "73e3c2f9-5d2d-4ac9-8be0-2011d0ae1902", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:\n            adaptive_diff_weight *= 1.25\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < self.cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return self.cross_prob * mutant + (1 - self.cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        # Change: Adjust step size coefficient to improve adaptation\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.08 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Revise directional search step size calculation by fine-tuning budget ratio impact.", "configspace": "", "generation": 65, "fitness": 0.26722091623476457, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.20.", "error": "", "parent_id": "c053b97d-dafa-4aa2-b0a5-c484386bd7cb", "metadata": {"aucs": [0.5952722055202904, 0.4786993920611806, 0.5758375748942148, 0.5503284224762733, 0.5035709631959902, 0.46863327297999346, 0.5682989927857871, 0.5812376481131992, 0.6135784123720818, 0.25154052040811736, 0.24206034058164194, 0.06871559278706596, 0.34856990413253, 0.3108223131794613, 0.158803246983516, 0.346602452110665, 0.13563811894862376, 0.322884930461401, 0.09159356341573255, 0.11260470203020012, 0.08929234443626077, 0.10742349321895839, 0.10038756803665927, 0.0989958320261407, 0.09753442122646316, 0.11418666687242007, 0.12239546402415602, 0.11493142498012421, 0.08442654899686308, 0.08475933565457872, 0.08678500211459905, 0.08945419804834531, 0.09310007546717458, 0.10316586380269566, 0.08145674020085136, 0.07991312367290015, 0.8255273000968596, 0.8591711514627505, 0.8469954386492367, 0.7518994412365332, 0.7756749311422325, 0.8655954458579208, 0.8434818873430902, 0.8584699301134916, 0.808853294005995, 0.16164057474565785, 0.1656941698459583, 0.24308929156571824, 0.20223408113001806, 0.1507230307899814, 0.15927558433482025, 0.21691693990127492, 0.1575540008599683, 0.18905490569879457, 0.32107704152536054, 0.6360555303624906, 0.5385530101110281, 0.6209280497812399, 0.705629849634268, 0.6114053675135341, 0.6727595253287008, 0.637630993635006, 0.6017410854496682, 0.1853137897948427, 0.12596738983778355, 0.11166073720003278, 0.11888523892239133, 0.13174479755023727, 0.18611315430477082, 0.10726015203241623, 0.11472256515913193, 0.1396264744255291, 0.15553509725038817, 0.18260649127524375, 0.13244542228302492, 0.12496711901258095, 0.11994629703688298, 0.13032628581250028, 0.23834680734156077, 0.27275280967986304, 0.213499023516167, 0.31205348887746476, 0.24091631213918197, 0.25565861416163793, 0.14484054295506799, 0.06870896681391392, 0.28841794523819575, 0.10986766555052696, 0.19782330657295155, 0.24301990317236388, 0.3507763975420215, 0.43395681048198476, 0.2735547030269051, 0.13322052131157047, 0.2440143659136348, 0.42665257862620243, 0.35560306857744794, 0.3186705019731587, 0.24443340181600548, 0.10048244570076126, 0.043835660414595634, 0.05944431762982072, 0.1339723034547443, 0.055486502985468866, 0.02300460655137282, 0.12586013039208588, 0.08553841538255325, 0.11385099883121497, 0.16634753227151344, 0.13686769563647905, 0.0745812725301046, 0.22286480112520468, 0.2059504842444877, 0.21941404526909591, 0.201972815688109, 0.17067292513447718, 0.22424497357608453, 0.4645246424830567, 0.5150004871297489, 0.5268087206554377, 0.5017856617027259, 0.49793708152253957, 0.5855357973642205, 0.4165752611046257, 0.5136435693886952, 0.5580310609417147, 0.10977743691150332, 0.11691955572018087, 0.09811813129092739, 0.12272808208056452, 0.1155881037428419, 0.10123307897180256, 0.0931234385625247, 0.11118681111810058, 0.09621847748694234, 0.19755852758766201, 0.14400923093295548, 0.17957919142417578, 0.13112242118784234, 0.15021089538260635, 0.15678771193658014, 0.14115187271214513, 0.13350397774436062, 0.17530171204640355, 0.32703485454261527, 0.2753073406662093, 0.3404578252738504, 0.2940354219606487, 0.32360895257502864, 0.2746807533001713, 0.32734627729646193, 0.2360547734063092, 0.2963953388614079, 0.23554400167716572, 0.24963883154200572, 0.27697340463449804, 0.22525070822642712, 0.25789080344945914, 0.26545512773466295, 0.2353104064960574, 0.2602498593380643, 0.26190648444096476, 0.21161597903968588, 0.17875204351555263, 0.17958162521446352, 0.18724625097734815, 0.16824954368867218, 0.2178671648590116, 0.1900629088317487, 0.18909486023389188, 0.20619852991411558, 0.2024809317605597, 0.1755459896198701, 0.19477006304278555, 0.1867233853767154, 0.17483752112885764, 0.18714550800313645, 0.17396866917708298, 0.1821208992439025, 0.20031463209055933, 0.18849200928502607, 0.7043677444556988, 0.6124467067510244, 0.18398710253810235, 0.6773121267616633, 0.16245658157130805, 0.16063626887486349, 0.33558853615085893, 0.6743995109825691, 0.5053008172936475, 0.4129825420659716, 0.20324771224330784, 0.5809905973940376, 0.1845751957169518, 0.2762471742802268, 0.2039116559023335, 0.27197006087993025, 0.6227448176799699, 0.17955218835589548, 0.18650356718546657, 0.18224028701984052, 0.181459254917686, 0.17799516332068455, 0.1666799084190006, 0.17277083856256303, 0.19329209631059507, 0.17785330163909208, 0.0737772975257327, 0.06683595771863804, 0.0938733623861484, 0.07804168906978992, 0.08193669459749331, 0.07941302086865287, 0.0897995799877177, 0.0776918999369729, 0.07523282944432663]}, "mutation_prompt": null}
{"id": "91f73ad1-3466-4bd5-91a3-07a3ea78dc99", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:  \n            adaptive_diff_weight *= 1.25\n        # Change: Introduce a new mutation scaling factor\n        mutation_scaling = 1.0 - (self.current_budget / self.budget) * 0.2\n        mutant = a + adaptive_diff_weight * (b - c) * mutation_scaling\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < self.cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return self.cross_prob * mutant + (1 - self.cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Adapt mutation strategy by introducing a new mutation scaling factor to improve convergence.", "configspace": "", "generation": 66, "fitness": 0.2602049269368668, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "c053b97d-dafa-4aa2-b0a5-c484386bd7cb", "metadata": {"aucs": [0.3576925209081774, 0.48754536806961013, 0.527848892313469, 0.5820028018819039, 0.4734339908357086, 0.5596215982138484, 0.5430155138863483, 0.6263118437199326, 0.3945892032965813, 0.28591391118949094, 0.244385150954197, 0.25567512922920677, 0.17494051339207695, 0.1990997533308807, 0.1443750237767406, 0.17693906571677676, 0.24700603476547078, 0.2694182064416738, 0.08143143548047627, 0.12225978507724389, 0.12151571580758913, 0.0954354188116624, 0.10746863328990242, 0.07402229702767305, 0.11473094787589888, 0.0947050608384914, 0.11487062368340417, 0.0946353122788518, 0.08804124388056211, 0.09316652236900247, 0.09688920468665052, 0.09176434616466889, 0.11738303815820761, 0.0988513606639837, 0.0840785113430047, 0.09870342039928692, 0.8139988235311095, 0.8512110809827527, 0.8702811364824863, 0.7599392379090693, 0.8265469188632849, 0.868549163005548, 0.7992116368126096, 0.858324825967948, 0.8061127225596791, 0.1965463556540682, 0.1456527757820808, 0.19613282624968653, 0.16680990787540828, 0.1774288764258406, 0.2063343728712499, 0.21394044587881578, 0.25269798041271574, 0.15540582243426104, 0.6410335188352142, 0.6169555892615031, 0.30852042906820876, 0.7493844917335661, 0.6649402296035054, 0.6426164749554979, 0.7582272934060525, 0.6272912620102289, 0.29171689319000293, 0.18517436528349562, 0.1616878833447537, 0.141330293167245, 0.17576421010748944, 0.18065536514837055, 0.13101552853043996, 0.15168444988050522, 0.15811383897086362, 0.1287021982102522, 0.11587950045149886, 0.14385962726580326, 0.19608551177542588, 0.16128818946076484, 0.10098274846850364, 0.11444242199251653, 0.13428786595384468, 0.1655103542658115, 0.1530639257977926, 0.26286659699960624, 0.21028741030980513, 0.21810876276458258, 0.13554282907153337, 0.09210615045762316, 0.1810248414655503, 0.06889149459654786, 0.2297564610437267, 0.25701573207990847, 0.3114944515076772, 0.47105310725448457, 0.1356845046168339, 0.260287900254784, 0.11400972405247867, 0.11629504283477687, 0.4096289801884232, 0.255491325953213, 0.22837546541426612, 0.13463004113065402, 0.18824275458388728, 0.12932467714138307, 0.09892227516556518, 0.06812042037166088, 0.09855679012869456, 0.07438615056693565, 0.07416830551958498, 0.07673957859637759, 0.1882004766597316, 0.13272155060474866, 0.14668281594746435, 0.12847616062172196, 0.23587129324008516, 0.14876231450866728, 0.1734966070686429, 0.11171544247885834, 0.16342324517318574, 0.5144421524048025, 0.33191567097952657, 0.4287105142255284, 0.48769478162001023, 0.41082069853971603, 0.4423063598958745, 0.46867192698912985, 0.41594926278467914, 0.45364692487088054, 0.09869982858869186, 0.09715922799699439, 0.0985624983487492, 0.10415649558456697, 0.1028022788548093, 0.09214711756201799, 0.09511726878058213, 0.1175517112776977, 0.09824042114118692, 0.15749762379480148, 0.14067261754800164, 0.15754460756823208, 0.1623085817763198, 0.1465959039618725, 0.17171929364513594, 0.13179968296639477, 0.13635903067679334, 0.16111105099998313, 0.2944676363570694, 0.3544805613969092, 0.3545881345358871, 0.3314700767152641, 0.3072389931335161, 0.30346918199015205, 0.28677571647939926, 0.3098389113740061, 0.28865227421145934, 0.220095013153904, 0.25080819517242603, 0.2699530819398799, 0.2541300528369689, 0.24455662891472496, 0.20954400703989773, 0.23187999496444744, 0.19570315634556268, 0.25423758954537046, 0.21358169668469706, 0.1985432020202318, 0.19267977624315824, 0.19161220053835737, 0.19677842584564376, 0.1787078186130533, 0.20143144079057906, 0.19561109782673314, 0.21944597375095976, 0.17585014021091228, 0.18854287266246317, 0.18146894789201296, 0.18251022696793384, 0.18029077039820873, 0.1875526858035207, 0.18400739122869736, 0.19620284380147313, 0.19809677287296512, 0.1850302531950263, 0.636741123394069, 0.6700563414842863, 0.1809026486885087, 0.7087733686693776, 0.34647983766661006, 0.498782408591396, 0.4893797974165084, 0.7067230672894875, 0.5071117892911179, 0.5133777618883892, 0.20290734653589892, 0.4993030427239016, 0.15784155901272845, 0.20093943887188226, 0.39294354967003364, 0.19783347385598649, 0.30163966886718474, 0.1809086126602487, 0.19630973838883703, 0.1921757987259366, 0.17300727800482707, 0.18250428445098588, 0.18982037045923716, 0.17425886598533924, 0.1758526305349376, 0.17699046233881432, 0.06803632322844244, 0.08498921580237673, 0.06927211280464596, 0.07475338013840538, 0.0718904775343635, 0.08211633720919109, 0.08085116426573147, 0.0775236933418697, 0.07176152176513384]}, "mutation_prompt": null}
{"id": "d11483f3-6492-4931-9a1d-708ab9a3b969", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:  \n            adaptive_diff_weight *= 1.25\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < self.cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return self.cross_prob * mutant + (1 - self.cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        # Change: Introduce a dynamic adjustment to the step size\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Introduce a dynamic adjustment to the step size in the directional search to better balance exploration and exploitation.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c053b97d-dafa-4aa2-b0a5-c484386bd7cb", "metadata": {"aucs": [0.49993364447277167, 0.578514780538546, 0.5654213252984656, 0.5338798482202358, 0.5146886167930057, 0.5725463844532885, 0.6086323171219379, 0.5253221883193565, 0.45679305141194126, 0.08133379561967502, 0.1862113773151559, 0.275373509339256, 0.09083185569438679, 0.05073268046392165, 0.23522702219094804, 0.1592544551705405, 0.2067772141942411, 0.1623213518932134, 0.09724780079846618, 0.1246109288317706, 0.09940941787963398, 0.11050154221187891, 0.10143759286261211, 0.08804674993754269, 0.0879253961892118, 0.0950520908323107, 0.1086388980683074, 0.08041139996203728, 0.07490437418297247, 0.08430138515537966, 0.0863665516428831, 0.07387093376886023, 0.08639956504799151, 0.08282253241308757, 0.1003315014003765, 0.0881788197780825, 0.8223345247886336, 0.8511854272677393, 0.8839262241314515, 0.756894629674816, 0.8265229483018428, 0.8742059935482849, 0.8056193187500138, 0.8581623592139263, 0.8026819723487321, 0.2223555133674192, 0.2712292585276699, 0.17633747200545002, 0.18543619778546094, 0.13996336382079044, 0.13959409884086094, 0.21702909003429516, 0.17723313083812098, 0.1472045885671791, 0.636017189426187, 0.5919897540809516, 0.6662903228718402, 0.6827451433654874, 0.685182640936479, 0.7015969090620078, 0.6556140860415169, 0.6233393958505313, 0.5941729199342329, 0.12061783404489124, 0.10980935179578322, 0.13448513551898178, 0.14881033631943685, 0.20788284885952757, 0.13680318060024454, 0.1171882730702195, 0.19781587730443184, 0.13082072791674948, 0.15423969224289447, 0.25683078285755034, 0.1511513449566948, 0.14157211448873153, 0.14398169740758926, 0.16378820356132306, 0.1522433512946505, 0.19320702780187182, 0.1715740243771292, 0.29084969541882033, 0.22346637547558657, 0.22943712330247956, 0.25230624633765375, 0.07188537106233273, 0.05609935463390503, 0.23310390722446273, 0.2425543696119865, 0.2586259701361051, 0.3926467637278732, 0.43341908260182505, 0.18353799512344626, 0.41006561876025316, 0.45216103682177566, 0.22650450555709845, 0.21170821212948931, 0.3604276603989237, 0.3733123909664897, 0.10450310553193942, 0.1482568626770584, 0.17544849600051637, 0.09304632625650211, 0.058054421554266655, 0.07777191124084215, 0.08182671441063594, 0.147653878180523, 0.0949920012161789, 0.2231466285716327, 0.13487722808042235, 0.1931442880676133, 0.20405385315438118, 0.16682284038597972, 0.12394063223373597, 0.2008558578944638, 0.13807760998725083, 0.2130884007799858, 0.4319995570548194, 0.4278765926159004, 0.4060557114507901, 0.5059734525213035, 0.5072763805441065, 0.4538914723187617, 0.5014832146668265, 0.38758861044079196, 0.5160946290237778, 0.11426695155411704, 0.10361146511785391, 0.09175415146851706, 0.09300225406024043, 0.11327867078668585, 0.09764137883870205, 0.09348330450667908, 0.0971856087935028, 0.1260082458273375, 0.17028508530889974, 0.13345961410588203, 0.158508245169921, 0.17241746075109277, 0.1374302533318782, 0.15724200703757618, 0.19222261349655312, 0.12489439662595647, 0.1305866655807848, 0.30068067294968526, 0.3200224877711422, 0.28604163607321953, 0.29317170788915725, 0.2971755178546124, 0.31878879108015, 0.30540079149850385, 0.3371040615282668, 0.33889563954531954, 0.23093910568399434, 0.23286367691219856, 0.2874088160829973, 0.22982424721768524, 0.23399975144957252, 0.24989604008862643, 0.2535398466038613, 0.21024335362604696, 0.2532999747470813, 0.21758615587849495, 0.19798318266992887, 0.18916334271404156, 0.1925216980171921, 0.1819065504299865, 0.19251343164427326, 0.22998055135646722, 0.22014942184984188, 0.22336809647847056, 0.18353220973786222, 0.18411148699479685, 0.19497647254290507, 0.21080610091229923, 0.18307534781422163, 0.17347271692370814, 0.18393858450135792, 0.1972612338671148, 0.1765947174064284, 0.1835469072894641, 0.6461806890776718, 0.6030073777999956, 0.18473993666507493, 0.6971151877524451, 0.1617878627218694, 0.561773199059302, 0.5260216807938747, 0.7005943042889777, 0.6522980644837186, 0.4729243992936759, 0.20302013820920117, 0.4576544135366053, 0.15817679904045634, 0.23742691912821123, 0.19985547291534322, 0.19820981809425076, 0.3290949613614427, 0.17294748397863458, 0.18354798882517376, 0.1738807897823348, 0.18364963883110952, 0.1777652371615468, 0.19223303534973946, 0.1859254467211393, 0.1768267351142616, 0.17709547031767747, 0.0844817251969534, 0.07400208134989517, 0.08783329537843731, 0.0750267985852241, 0.07459322344957586, 0.07083731215821587, 0.08606976854743331, 0.09252637426694998, 0.06373081799426894]}, "mutation_prompt": null}
{"id": "7f053001-8f12-4e59-9e8c-a09e2fd85954", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:  \n            adaptive_diff_weight *= 1.25\n        # Change: Introduce a small noise factor to the mutation process\n        noise = np.random.normal(0, 0.1, size=self.dim)\n        mutant = a + adaptive_diff_weight * (b - c) + noise\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < self.cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return self.cross_prob * mutant + (1 - self.cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Introduce a slight modification to the mutation strategy to enhance diversity and improve convergence rates.", "configspace": "", "generation": 68, "fitness": 0.20195016148534328, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.18.", "error": "", "parent_id": "c053b97d-dafa-4aa2-b0a5-c484386bd7cb", "metadata": {"aucs": [0.38708419404749306, 0.39173576565239143, 0.38270676304061924, 0.37894900759527794, 0.4116892660532169, 0.3667610381065941, 0.39407007177837794, 0.39741812152685174, 0.3886073399563169, 0.035238407225135604, 0.018649738120887882, 0.006448744248310656, 0.02414176005628632, 0.030003107541567986, 0.002807856112266527, 0.011073856252549974, 0.00782043357943163, 0.022195770585275, 0.09774389545391204, 0.09641432736750943, 0.10516447797646156, 0.10035832178502391, 0.08613335085404283, 0.0880528418180907, 0.10620981703979782, 0.10639233281489668, 0.08768235091365129, 0.08305922890985495, 0.0865141393118114, 0.07376628906086657, 0.08349481737206366, 0.07190036717418824, 0.08811547406259101, 0.07928782713498239, 0.08309104612065454, 0.08015354211646941, 0.8551049908848631, 0.8361106456056184, 0.8158925141816111, 0.8373352637353119, 0.825906026658529, 0.7589828729943281, 0.8505162459302387, 0.8253041474084124, 0.7607461319790506, 0.21155598304990986, 0.20472978951719867, 0.2115103017460931, 0.2022176690804195, 0.21003705378880122, 0.21799207848287694, 0.22007111373750243, 0.20979777334187222, 0.22201064694247374, 0.31028246588251107, 0.2976379248143284, 0.3060255445779141, 0.34159558483964425, 0.29481295061416424, 0.28952420613199725, 0.3224044073130454, 0.27510556580057377, 0.2809138442673288, 0.15554243899304487, 0.1521675813630209, 0.1662518113970346, 0.1480989100064467, 0.1210116241959609, 0.14242319691054783, 0.12835681092817175, 0.13127197721109474, 0.13643332338864889, 0.15710642415992515, 0.12248032307506362, 0.11976706876164334, 0.11914558545805976, 0.1526059855870774, 0.1485634063260961, 0.122315066362088, 0.12397540849732724, 0.13345432014738512, 0.023497090177536428, 0.005652049011461879, 0.003643042749873149, 0.012195131368064938, 0.02637940577658171, 0.01097920363669913, 0.028861357756140182, 0.02815718412365642, 0.028120333727236213, 0.09293628566709722, 0.11401392995415449, 0.09872021100155948, 0.05968606242210994, 0.09219386828784792, 0.09945389026613916, 0.0930355297997637, 0.15217209771035833, 0.07377854724346578, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07765620535976725, 0.09870392115957927, 0.06935416290714602, 0.08353579939779954, 0.09821259975361296, 0.08485057499160265, 0.08583968983451029, 0.08336339487961919, 0.08623668749554003, 0.38117404875223104, 0.3826709971870862, 0.3796496358723753, 0.3727979331829806, 0.366211447635053, 0.3725488737013406, 0.3693764267551699, 0.381438616292897, 0.3657555625166671, 0.10007742241123674, 0.08393148792433713, 0.09380601275347489, 0.08785881069705115, 0.09516923486869078, 0.0895145896111077, 0.09522601298184419, 0.09731505753267944, 0.09706711345451347, 0.1437686893388942, 0.13285551275439555, 0.1451657102991296, 0.14492957815291851, 0.14362596226035507, 0.17628836322136354, 0.13067983693058027, 0.1275522627192338, 0.1483819067859682, 0.25547016121054533, 0.25820496946353333, 0.26126876122987097, 0.2769356610095274, 0.2795796607805422, 0.2561032777758291, 0.2705343127046188, 0.2629907981741276, 0.26467272413593035, 0.2008022328009772, 0.2088348396254439, 0.2031399881219672, 0.20502278839559207, 0.20175025924146617, 0.20768300541879492, 0.19191799817816668, 0.19725584608307611, 0.19480858349804142, 0.182790088593335, 0.20082989268975593, 0.2056052057802492, 0.16595866404591708, 0.187305372899786, 0.2089304455072436, 0.1957853705184852, 0.17995833717022247, 0.1971924318807532, 0.18805663584208576, 0.1932530928571503, 0.18063934964861217, 0.1823840207164158, 0.17876230167618856, 0.18289098862782915, 0.1854313357837999, 0.1995216829089662, 0.1823903445543429, 0.1583220354219067, 0.5981478857713228, 0.1807954915139437, 0.39299565665998004, 0.4943995358231932, 0.17824563422332618, 0.535324224312575, 0.5100007283351261, 0.5766622706770738, 0.5428234571817949, 0.20063172247926175, 0.20074839446226667, 0.19809402134878695, 0.4118223122752104, 0.19462706504295613, 0.3546924280195932, 0.41691762108728403, 0.45572015525472553, 0.20247078521654516, 0.18164137200058827, 0.1740693321069382, 0.178326747955302, 0.1778226393685396, 0.17962962494643542, 0.18638019879502477, 0.18494806656593643, 0.21447297775154262, 0.07450663837555493, 0.07231423042443075, 0.07470762329754665, 0.07072469599636466, 0.07592242839108798, 0.07279176543646704, 0.08999945795453335, 0.07223832947419029, 0.08963983944414033]}, "mutation_prompt": null}
{"id": "77761786-573d-484e-8d12-0e5c39306733", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.6:  # Change: adjusted threshold for robustness\n            adaptive_diff_weight *= 1.35  # Change: adjusted amplification factor\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < self.cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return self.cross_prob * mutant + (1 - self.cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Refine the adaptive differential weight in mutation using a more robust stochastic mechanism to improve convergence.", "configspace": "", "generation": 69, "fitness": 0.25386002479568875, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.19.", "error": "", "parent_id": "c053b97d-dafa-4aa2-b0a5-c484386bd7cb", "metadata": {"aucs": [0.4301255480484335, 0.5690811704363983, 0.546008330934096, 0.5411053371539044, 0.6275629918834262, 0.4320194292560674, 0.5370216571453152, 0.4584580806094778, 0.4743623909718715, 0.16344794849718614, 0.29275087079815754, 0.26078110380521835, 0.18708025535406714, 0.30831159882721726, 0.2894441329982943, 0.18817151364650742, 0.2649054986091903, 0.15969221768071107, 0.09987122043887897, 0.10656753130665653, 0.11760882752689117, 0.10747355188943386, 0.10478279865550943, 0.09650877624280196, 0.09157765472665891, 0.09900701898331188, 0.09481929615053764, 0.11338792501058892, 0.08953173624845112, 0.0768325777684935, 0.08109013324403636, 0.09248531527576664, 0.0924698501478195, 0.08801373554335512, 0.08533950096530385, 0.09177444240178978, 0.7988641469665234, 0.8486645443484774, 0.8412525090855947, 0.8143518250019883, 0.7504063824614785, 0.8721832928015919, 0.7982537802321592, 0.8544026774381254, 0.8059441767207095, 0.20860184962220774, 0.23866317690720418, 0.1695143511376398, 0.20459672960118314, 0.1889145401547535, 0.15866998428002355, 0.16698629320398106, 0.15153303474401414, 0.15582481924529767, 0.5896780703614173, 0.5739656676459797, 0.6291513847864496, 0.5963734393982302, 0.7514677509219827, 0.24214654982241435, 0.338122835439588, 0.2880781718644436, 0.6075504167280612, 0.1868146234240483, 0.12676549120684755, 0.11725050340333532, 0.12214161721137318, 0.12484823118634447, 0.20842511737919656, 0.1195048100603453, 0.23143939604414798, 0.15317326014373134, 0.13611077136448713, 0.1556459176922097, 0.15601181856839663, 0.13314793680903203, 0.1187771261880034, 0.12038554969363591, 0.11831136249110041, 0.17874879379934794, 0.212773740159808, 0.2601260359898975, 0.16425767586925644, 0.23340833676552375, 0.21776530622803036, 0.07083052330410866, 0.18410343591695666, 0.2676461472385626, 0.1507305294785598, 0.1271854658867867, 0.3080290218502326, 0.1626192340563004, 0.19155066313476155, 0.34230955058884194, 0.18809183832634824, 0.3174347200902221, 0.2937692852256236, 0.40505624058636636, 0.4002750117970785, 0.11255822513562819, 0.04005547908637985, 0.04961674583755171, 0.05713862840805106, 0.06293489773039329, 0.08005118870893146, 0.03474452173580245, 0.0832731305509955, 0.0632173968208497, 0.18748757086530343, 0.1558232291733238, 0.07457193110337612, 0.1544572221034387, 0.17774493386758095, 0.09724593479095378, 0.21415915011581477, 0.15037334713101713, 0.19126711905367821, 0.4590514111635504, 0.4536479506344645, 0.5255202318490694, 0.36571047738321016, 0.5097973326074976, 0.3664582376675075, 0.5259334233372085, 0.41071547585399226, 0.5000199959499774, 0.09217814493753484, 0.1185207341485699, 0.11452519323507282, 0.11312274666976607, 0.11612216794141783, 0.10393349383043948, 0.08723790396322217, 0.1049042397260419, 0.08632690887671501, 0.14538065857272886, 0.1770140891879639, 0.1557151414699629, 0.1664582684632876, 0.1338223338302783, 0.17458971752569763, 0.15461356139566684, 0.14977626454648452, 0.15412639296113428, 0.3091603761911108, 0.29444841223764495, 0.33707754657730404, 0.32176042964573837, 0.3274569147226284, 0.2783877612790491, 0.3035245833858977, 0.3138627719454806, 0.291713464056936, 0.24501595508113838, 0.2417474928404576, 0.26801393068540225, 0.2603749518341122, 0.24361563690884736, 0.23248779813607667, 0.24719156866461667, 0.2628918832854662, 0.2666715343922892, 0.2061227181366817, 0.1900215753686726, 0.19482655915474179, 0.1830823749887004, 0.20397735823456287, 0.1998586234063996, 0.1922646793201399, 0.19174708790719075, 0.1998824202795818, 0.20100059036885376, 0.17367804256146335, 0.18237255916241013, 0.20293575575061107, 0.19187098797784852, 0.18905000274034733, 0.18167031393118716, 0.1812311718300813, 0.17674660037395684, 0.18894920113206115, 0.6717104112800879, 0.4316023604937751, 0.18440638366539097, 0.6294634542607837, 0.5907124503671628, 0.15858622743519046, 0.5207469806745748, 0.18101766283931842, 0.6864684402835801, 0.5444444917978857, 0.2011047322186661, 0.3799296660431709, 0.157401756739311, 0.19659438491408265, 0.2051338903690697, 0.19970933896245668, 0.37011833059298993, 0.17713926362245036, 0.17068372508306662, 0.1831432236319961, 0.17975011997473755, 0.17984905634318982, 0.17973802633999458, 0.170056283783942, 0.17188292124133298, 0.18752160905187054, 0.08026308196811582, 0.08827343387119257, 0.0650515377510672, 0.07370187845488885, 0.07117135344429315, 0.07471352429553735, 0.08282643401111178, 0.07403830140148315, 0.07707637495558683]}, "mutation_prompt": null}
{"id": "ae807084-934e-42a8-832f-6358ee530716", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:  \n            adaptive_diff_weight *= 1.25\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < self.cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return self.cross_prob * mutant + (1 - self.cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        # Change: Slightly increase the range of dynamic adjustment to step size\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.11 + 0.11 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Enhance exploration by slightly increasing the dynamic range of step size adjustment in directional search.", "configspace": "", "generation": 70, "fitness": 0.25331400198103105, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.19.", "error": "", "parent_id": "c053b97d-dafa-4aa2-b0a5-c484386bd7cb", "metadata": {"aucs": [0.5634100576314486, 0.49271399246464487, 0.3601912109840536, 0.5230249570484102, 0.5048996515634685, 0.5690690064037788, 0.5619404750004373, 0.5752583476399323, 0.44032379202714533, 0.23659070251386782, 0.14448359096009222, 9.999999999998899e-05, 0.13220956774865245, 0.3373247465836199, 0.1502140833183907, 0.1628726189773002, 0.3351293094821526, 0.08378253368496313, 0.11000072445812492, 0.0954953209314342, 0.10714741637256064, 0.1327336706773814, 0.10098485452338246, 0.10732931287207759, 0.09995396978436077, 0.10777454019266275, 0.10406817103387433, 0.10691635178917003, 0.09322196059160248, 0.07260918066024569, 0.07885529804148206, 0.10519203575352187, 0.10707520870358489, 0.09184356135289529, 0.08087716096373843, 0.09876054530936051, 0.7665390009434968, 0.8427157690566375, 0.8704917153610641, 0.8273317850112147, 0.8006095889474389, 0.8682386599256853, 0.7977663039690935, 0.8572406781430394, 0.8071754407214353, 0.2430878886192983, 0.21053790153584473, 0.1680771803960659, 0.20451622347575937, 0.16526784358625268, 0.1484363055784932, 0.17707840468204117, 0.17609421488404386, 0.18829570348324298, 0.6989991239970411, 0.3325077147715526, 0.33897628109201183, 0.32630478924863204, 0.6483152216216992, 0.6436664202408007, 0.25792022957770544, 0.6954545193082111, 0.6309520703768373, 0.14835073818890465, 0.2327608261683668, 0.15053153618716297, 0.11501990018268482, 0.18609253989999408, 0.11493238528679572, 0.11940945485300691, 0.1851741671255026, 0.12042998692017315, 0.1251061794346049, 0.13025223611176429, 0.1764045996666469, 0.12527517657908482, 0.22811978886659612, 0.12921607212472042, 0.18607131626136297, 0.15583286573864696, 0.1968615505237541, 0.29635488394945886, 0.10603526804612595, 0.0069727564052469715, 0.13855939483389357, 0.05517179728851662, 0.06317186277935993, 0.29662191901988066, 0.2711961539603306, 0.17925538960376597, 0.22895680675360086, 0.4113409733644422, 0.2859293537431449, 0.20285462427255452, 0.19294270696880522, 0.1517922975375985, 0.3873541722527494, 0.4017947172111016, 0.3974512775289303, 0.04387489529326627, 0.16811001744456333, 0.115986383539189, 0.05034365912392591, 0.11004388521951192, 0.13243832374519737, 0.08111238590754688, 0.0862820986394387, 0.0977932336088192, 0.1875777562287977, 0.22941865674698858, 0.19970445153517957, 0.17044596849590454, 0.1971782839519507, 0.14708456515191537, 0.1482416521409088, 0.16424649709690986, 0.19853482916644927, 0.5069518329160884, 0.4403941032714208, 0.4515356291383922, 0.4356525320987342, 0.4189173679577388, 0.5050369062005173, 0.5173341780975369, 0.5019780789074471, 0.46105150164448694, 0.13964494849876485, 0.09132307283794838, 0.09669824305735908, 0.09480663183596716, 0.10272020002068183, 0.10358788345232983, 0.11314086627235809, 0.09372503013851019, 0.09903885805732293, 0.1493074176526541, 0.1519902844176757, 0.16904028860979492, 0.17379052128181316, 0.16073133557832753, 0.20825839799758572, 0.14378556810877963, 0.1458933310685414, 0.149614525543313, 0.27554210368480203, 0.31127766864707884, 0.2781571404363533, 0.2865621593367884, 0.32556539842131904, 0.36383894493280944, 0.31059012602970215, 0.29837672969010265, 0.28307096115987784, 0.20765583751549865, 0.24271584499143117, 0.2554760295160454, 0.2119195399504179, 0.21071581992609612, 0.2917128168849412, 0.227000100647048, 0.2964041969108534, 0.23224992396698185, 0.18959551146211684, 0.1970479389046106, 0.18341907182860462, 0.18449115264010263, 0.19452653222096172, 0.20447972034013495, 0.18932289772961508, 0.2169393928988439, 0.21481525652878886, 0.18774333704098733, 0.17881499002144896, 0.17841267792481486, 0.22065407754200717, 0.19818094173267886, 0.1858180572636675, 0.18614757598663167, 0.19251348557574943, 0.19233796441187678, 0.18020302579140102, 0.3455623513364975, 0.6529367148981444, 0.17764178191142965, 0.5986743177712986, 0.1806406709747913, 0.6358030622422055, 0.5192201300447308, 0.6450725821603296, 0.3282892400778499, 0.19976457201070308, 0.202334423125896, 0.38746689850410276, 0.15840911360989451, 0.18661885643974296, 0.20342495221572365, 0.19872716500585852, 0.46577232553210857, 0.18629461787311274, 0.169758407422832, 0.1872096342995132, 0.17091593750744882, 0.18279650471883824, 0.1845782048307868, 0.182487036153695, 0.1811465642187644, 0.18130883156301703, 0.07749615439953339, 0.08022066126769245, 0.07955909591769506, 0.07357860263086946, 0.07088354691747678, 0.07660743755799448, 0.08925810488610042, 0.07231848522508266, 0.07781283222145763]}, "mutation_prompt": null}
{"id": "61cb785a-4a6c-4bd5-a09b-fa666a4e6b48", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:  \n            adaptive_diff_weight *= 1.25\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < self.cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return self.cross_prob * mutant + (1 - self.cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        # Change: Introduce a dynamic adjustment to the step size\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            # Change: Implement an adaptive crossover probability adjustment\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.02 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Implement an adaptive crossover probability based on performance to boost convergence speed and precision.", "configspace": "", "generation": 71, "fitness": 0.2603509483724064, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "c053b97d-dafa-4aa2-b0a5-c484386bd7cb", "metadata": {"aucs": [0.45816385202823107, 0.44685531871845297, 0.44208650457577603, 0.5059124333754647, 0.5036364921759391, 0.533431989390025, 0.5911618630006933, 0.583308481571687, 0.5872804497293758, 0.20144291453656193, 9.999999999998899e-05, 0.13075093482589695, 0.29677368533992665, 0.1656475692428716, 0.15070871690386667, 0.18686582490090498, 0.2071730413854509, 0.19660628694704907, 0.09647172600967902, 0.1108285508875344, 0.0935245301405574, 0.0942856077809251, 0.10884124212526491, 0.10018037415048675, 0.09689415718194616, 0.1190408442126405, 0.09807136126775418, 0.08362292180254716, 0.0867029225799395, 0.09221370269075757, 0.10026771228133202, 0.08548465844663411, 0.10150591857580948, 0.11485613399378669, 0.08055107087594515, 0.09237202269782996, 0.7895529002871835, 0.8413595661577749, 0.8835124512886714, 0.8448450930842526, 0.782824540802932, 0.9008311716836533, 0.7783013680217837, 0.8471920959062574, 0.8097705813947842, 0.15154783324572052, 0.17138890369605486, 0.16709828890104672, 0.1669157140083074, 0.15757398072671136, 0.153148420216355, 0.18031692120130616, 0.17206961459236048, 0.17031599891819083, 0.3564551114090977, 0.6643519015178254, 0.7471084671212314, 0.7138175581924326, 0.7174631516878789, 0.6329065972000251, 0.7365017536730698, 0.6547957051122621, 0.5511282407255034, 0.1641479425952148, 0.16143384454454912, 0.16801879361510252, 0.1168212721919395, 0.12396702605634435, 0.13627112606315672, 0.13187041426227586, 0.11876554684868645, 0.20846459237047843, 0.16320031817796443, 0.14648660262758717, 0.12706210937048001, 0.2304429422127986, 0.13896703972189428, 0.14356623926638235, 0.12858923795270616, 0.21499613448484867, 0.13205825662306492, 0.2882898532232747, 0.09095984925090184, 0.3008508909477908, 0.1004008712609078, 0.06924030155395355, 0.07310699239819873, 0.17918354297020345, 0.03379902252805933, 0.10359772502396258, 0.293356428042283, 0.37392233618388804, 0.3233088253531672, 0.17942351677850132, 0.11716846834987904, 0.14106245615395274, 0.4294163589087868, 0.44137043255981623, 0.4460346366179224, 0.1464855889817387, 0.08006645489342623, 0.040875321636654416, 0.059750216817973656, 0.07223314535742797, 0.1345893788514162, 0.07246813615136927, 0.12980467711094112, 0.08645046161461345, 0.08441037436199716, 0.13966247634225182, 0.21408515993575483, 0.22543653737052938, 0.17380328974921266, 0.1982766285453882, 0.16283013426989945, 0.22413619676645058, 0.13475048415014823, 0.47201431012663775, 0.5293709582352379, 0.5383403911706055, 0.4787816052724344, 0.4158548534377977, 0.38870726503661013, 0.4882455213428025, 0.5729618805108476, 0.4957167277500356, 0.09613414925605412, 0.11204017240649389, 0.1075244664310625, 0.09366567436257356, 0.10738868447638217, 0.09507543242264527, 0.08681336201930445, 0.08353925799063888, 0.09363216319744383, 0.17888725685774753, 0.1693682109607687, 0.2343981050302244, 0.18181893789445636, 0.1550396675122454, 0.17835228726258268, 0.15492476956388856, 0.14192036802604668, 0.16460369445552658, 0.3179882841059588, 0.294951608810494, 0.30944068026470406, 0.29998779430708467, 0.2726672967454259, 0.3077421453320921, 0.28477803307681504, 0.3150684171398821, 0.3221006663374978, 0.2477199419766143, 0.2517048795965299, 0.25818337076482945, 0.23281259658304798, 0.2641430591069691, 0.2839276874832022, 0.19264603458378038, 0.2051876939396886, 0.2594690008747975, 0.21967285788157764, 0.19588149275348155, 0.18722220443173643, 0.18512541378760328, 0.1914800027105854, 0.1886814782466042, 0.18692386405813144, 0.18070965060412802, 0.2684516747545347, 0.19321822818970102, 0.20036265495548777, 0.19615388955631075, 0.18321384237703842, 0.186498266593625, 0.19298554100724763, 0.19890996395748817, 0.18049225253035106, 0.20243514514429373, 0.17487311573310416, 0.39627681585925034, 0.6817599117196578, 0.17786439474339755, 0.3656294781964975, 0.1615217935845028, 0.47726289441312775, 0.7067638608932045, 0.6644321783419072, 0.6439435608626705, 0.18555038279868163, 0.2047215028412983, 0.7309306506786728, 0.1572511201346538, 0.19967033797285882, 0.20298528975218333, 0.19885982291102433, 0.4373470080111612, 0.18317475256478422, 0.18974882127715365, 0.17815735502905738, 0.20469791506215784, 0.17971181312888462, 0.2027680009292956, 0.18667570671508127, 0.17982850303555564, 0.1946822449452823, 0.06914744909369874, 0.0712617593050614, 0.07681754245819317, 0.07689795699236546, 0.07892839338250524, 0.08332311897598299, 0.07596504205271382, 0.0779827560830334, 0.07788145326235385]}, "mutation_prompt": null}
{"id": "a53df2cb-eb01-4177-a05d-46fcd2958e77", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        budget_ratio = self.current_budget / self.budget  # Change 1: Added budget_ratio\n        if success_rate > 0.5:  \n            adaptive_diff_weight *= (1.25 + 0.75 * budget_ratio)  # Change 2: Modified multiplier\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < self.cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return self.cross_prob * mutant + (1 - self.cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Adjust the differential weight to dynamically increase exploration as budget usage increases.", "configspace": "", "generation": 72, "fitness": 0.26613616790418637, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.20.", "error": "", "parent_id": "c053b97d-dafa-4aa2-b0a5-c484386bd7cb", "metadata": {"aucs": [0.5115761514581249, 0.576964613231252, 0.3976048868169568, 0.5482523534082523, 0.4279338639122239, 0.5552228862660297, 0.6020853374263251, 0.585656561742306, 0.440398194883619, 0.20036364694650088, 0.1402328508139823, 0.0794781317409523, 0.1353125331053907, 0.21982505640461902, 0.11088626572167737, 0.28941553991549906, 0.2941123762957495, 0.1542705101510251, 0.1279258504924683, 0.11212435139212318, 0.09076856851294601, 0.08958446247521135, 0.09317811940405296, 0.09337713780838186, 0.09717512090726688, 0.10036778690346804, 0.10628680646317612, 0.09926829797365988, 0.06991588317496811, 0.09502310968542138, 0.08496674868874965, 0.09696376071540358, 0.0892568615028898, 0.08738284466565915, 0.09691143091632626, 0.0981647084626649, 0.7972034516708653, 0.8518549555507308, 0.8839659506694522, 0.8088339787356011, 0.8265316088870861, 0.8751626225725715, 0.8414393739297567, 0.8578125835974707, 0.8026338525495833, 0.17077494067535348, 0.15232081905019934, 0.1605568717750191, 0.2620136095906539, 0.18256935986908907, 0.14981683411327829, 0.20285350754642884, 0.14420916429118003, 0.24570588633962287, 0.5393478449273885, 0.638878930936992, 0.6520453764810686, 0.5681356605679487, 0.6858653437655033, 0.6153201030346371, 0.5748282510551356, 0.599182053412332, 0.6613710181200942, 0.1273345384446024, 0.13768754362117563, 0.21970769423974856, 0.11599897475723497, 0.3588069262263748, 0.1367359035767679, 0.13941733316056393, 0.2139506273685009, 0.12057540258240784, 0.1318549906374492, 0.16015997428786033, 0.1521700514388794, 0.143878488544527, 0.11166117066667469, 0.11614266890686631, 0.14862063373637246, 0.16560664572345085, 0.11380256821328172, 0.3196917855731529, 0.2381130883711613, 0.2610861759554671, 0.10936407861520314, 0.09540652800970384, 0.08349754198666903, 0.13641287825446036, 0.16163942436621692, 0.18466886224045342, 0.39632674712101645, 0.3137455340983002, 0.18267394074931076, 0.2610123357444891, 0.16534570838064666, 0.26958075629355194, 0.3697524412787413, 0.1767906720085215, 0.40497090766903043, 0.09995387753650853, 0.10610551644333699, 0.028292646128565635, 0.1346513258185672, 0.07073747378302508, 0.137167658246387, 0.07692512371292182, 0.08238227556431776, 0.09590728406501636, 0.19172036209521726, 0.1191900697731818, 0.19448994844970247, 0.16382363767081964, 0.22142875946754537, 0.2019229528366362, 0.1385767485790047, 0.10983533507322041, 0.15291732776459543, 0.5207410886784762, 0.4857083339064443, 0.5317061766957987, 0.5100961047318586, 0.4767118716569768, 0.5745806212777098, 0.5594395276905701, 0.43563131841987457, 0.49534025176700613, 0.10871377455713427, 0.15813970599916682, 0.10487617023825546, 0.1053455349017206, 0.11207790063993817, 0.1018332128760896, 0.10014491296447792, 0.10785378271722224, 0.09712689046259182, 0.1623811412968147, 0.1488753859875851, 0.1517578390455221, 0.17829519885233747, 0.13363925184368908, 0.17149131157784392, 0.14097542745572522, 0.1364925765079581, 0.1930873739113078, 0.31597265688139164, 0.3486972527550356, 0.3194983408617007, 0.2544711922078977, 0.30764037200643957, 0.31361085085670803, 0.2972945724914383, 0.3197162376040871, 0.31552227437789493, 0.22382178621704174, 0.2658238856234749, 0.2609141191281633, 0.2230575650250637, 0.24856198915734518, 0.2355147477188123, 0.24730574888340606, 0.21671835838280562, 0.2632494069934168, 0.20773228440611968, 0.246838834830305, 0.18845281575583595, 0.20053530565566746, 0.20235442408568483, 0.20034688159090197, 0.20069170614869736, 0.18424310801650579, 0.1937952123834038, 0.1777745755501634, 0.1717572116219679, 0.1780980386726112, 0.186869200302051, 0.18331006226715418, 0.19831739083177802, 0.18489642154789565, 0.17641809550264975, 0.1939608707810424, 0.1757650091160038, 0.7152266372296318, 0.6739361229219736, 0.1828262751907268, 0.6640240659008854, 0.16158487740257987, 0.5039949876891647, 0.6580988612811167, 0.6604685846752419, 0.5951657856309234, 0.650893857996542, 0.2027304723244262, 0.5537504697442861, 0.15753548223449765, 0.16515003794174066, 0.19963658219158864, 0.3409337351038312, 0.3832661749838937, 0.18648008835984153, 0.18927037497358, 0.1856454456544916, 0.19377911693340988, 0.18037945684794154, 0.18083280062824825, 0.18974690238936642, 0.19245039523676155, 0.1728157387197663, 0.07651264410448766, 0.07596493724031583, 0.09053909269141225, 0.07150402367811326, 0.08623837304586357, 0.0718035387250302, 0.07713370607412162, 0.06912235013173051, 0.07367134857029356]}, "mutation_prompt": null}
{"id": "04901972-a407-4a57-89c7-f281ec916be2", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:  \n            adaptive_diff_weight *= 1.25\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < self.cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return self.cross_prob * mutant + (1 - self.cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            diversity = np.std(population, axis=0).mean()\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n            # Change: Adjust cross_prob based on diversity feedback\n            self.cross_prob = max(0.5, min(self.cross_prob, 1.0 - 0.3 * diversity))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Introduce a feedback mechanism to adjust the crossover probability based on population diversity to enhance convergence.", "configspace": "", "generation": 73, "fitness": 0.2231335064138186, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.18.", "error": "", "parent_id": "c053b97d-dafa-4aa2-b0a5-c484386bd7cb", "metadata": {"aucs": [0.6320115544316592, 0.7177562007610427, 0.5546111891737617, 0.6817110604113576, 0.64424888027853, 0.5128139482512943, 0.6537114873824497, 0.6708671881911261, 0.7313704421517753, 0.20110289578801144, 0.12756058081289867, 0.15497115600073064, 0.02530236003199371, 0.28212908328140807, 0.0913939686166726, 0.16624529021712808, 0.20636224437291717, 0.062090324318472945, 0.11586186366808326, 0.1165153147489475, 0.12457841654340296, 0.12128815980581809, 0.11476342556714203, 0.1144159018977744, 0.11234762592176861, 0.1248713476156087, 0.11283409695102475, 0.09665246747992828, 0.09972100424020935, 0.09795928666363984, 0.10444607241343562, 0.10639491611176222, 0.10043656623221453, 0.09448697248849536, 0.10459037422525108, 0.09336146509606114, 0.6829275940008438, 0.6995507076597958, 0.6798206737527146, 0.7032110262635158, 0.7526218093140019, 0.7803830597571121, 0.7688362358976145, 0.7928920157225976, 0.7681278540363118, 0.17245272144267276, 0.15732939786632183, 0.14120706832936225, 0.1552370480627433, 0.16700450416438328, 0.16437411288428283, 0.16219852088309494, 0.17818981237235498, 0.14670098712127178, 0.21085587652193816, 0.20672589950922804, 0.2143628912806207, 0.7021843471181596, 0.7301896521123985, 0.3349933265839802, 0.2237532731108628, 0.23499988896522783, 0.21007239063973682, 0.12446349494516051, 0.13925677594368824, 0.12180917771321853, 0.17945563237024909, 0.13420837511787087, 0.13854602657118287, 0.15734457017019055, 0.20147033032137363, 0.13493520294635364, 0.13216953615754523, 0.14197645556457794, 0.1369930632289177, 0.15936460717443512, 0.13272530833953333, 0.14377106315907162, 0.1364351665637088, 0.1889774304576617, 0.1885575863714093, 0.030205082992283083, 0.00020673563256656813, 0.03466589062879888, 0.05220142998511523, 0.10401106232074453, 0.04249681650241133, 0.015154759602371115, 0.013957609636573554, 0.06256020777427496, 0.10897259963887085, 0.17301955526686674, 0.17881882787242687, 0.1611191047994347, 0.07153218070521539, 0.07544991877837781, 0.1607947777819685, 0.18133575984874217, 0.09783390331948472, 0.058552859736932805, 0.1033830219179297, 0.06430946475517141, 0.06985588844005453, 0.06532686558660838, 0.07841954114083527, 0.07276167006853829, 0.08375033610706373, 0.12731786933001732, 0.03837294824781312, 0.09876554931548853, 0.12302961580252125, 0.13321756374044125, 0.1812384001938958, 0.16735949221091795, 0.09035464943743587, 0.09443858481885237, 0.12132460486217311, 0.4893664836539634, 0.5477579841767913, 0.5329716294842917, 0.5435357786752892, 0.3830368350905621, 0.5292101615152154, 0.45146773272349094, 0.5058029734674083, 0.4823276031337522, 0.08645144243317104, 0.08430958101071828, 0.10087733344533467, 0.12244583729175051, 0.09496673004354905, 0.09207212724862912, 0.09447246864680658, 0.100307234457507, 0.10031398108897172, 0.13139274868676165, 0.12405973724960095, 0.1351410052174098, 0.1312848334481287, 0.13849716397223477, 0.12071879473793856, 0.1657378711517693, 0.13775366031844627, 0.13753750123322117, 0.32099734285513826, 0.2514100111437447, 0.2852100280644373, 0.30240166908950883, 0.31049690811710196, 0.3539419974722561, 0.24354091329067185, 0.2866492711776, 0.2888211420711627, 0.24765352512983396, 0.21863132800826512, 0.22190407702143322, 0.23949167651027115, 0.24026727545086046, 0.22815408324900976, 0.18659950587458785, 0.1914437185938087, 0.1938047200606441, 0.2128075168767296, 0.19652540089896653, 0.22022614997921808, 0.22599261162113804, 0.21184269280242451, 0.2105851862674839, 0.20569010162489443, 0.21895820663101506, 0.19834217375879093, 0.20294994994768445, 0.17326159541040143, 0.18491288867803468, 0.17683137995589526, 0.17619258424196993, 0.1751408286554439, 0.19587674816077127, 0.17889850642263316, 0.18063751307598452, 0.18063558559253257, 0.5076676316794705, 0.1817893572530468, 0.17793111244542648, 0.19649081783665123, 0.3221784974785652, 0.20712363918176635, 0.2748110597705562, 0.37507433916397326, 0.39776045320337783, 0.4481554059227456, 0.26261202715517984, 0.17973882544922493, 0.27113803531506, 0.20116982526764504, 0.17963867853360793, 0.23908173394680166, 0.24722536186076405, 0.18908324480392447, 0.177007081215261, 0.18852347092286748, 0.18610135777459158, 0.1787800310576928, 0.17244068203487573, 0.18717673615248676, 0.1842065658835198, 0.17436433319528044, 0.08089865122003448, 0.08545282946698374, 0.07809719526530479, 0.07369682684086742, 0.10505983611706526, 0.07953355217256153, 0.07961729921273053, 0.08670811486206398, 0.07739594890547341]}, "mutation_prompt": null}
{"id": "ca1a5960-e096-4794-b89f-6ffab7f0cd87", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n        self.success_history = []\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if self.success_history and np.mean(self.success_history[-10:]) > 0.5:\n            adaptive_diff_weight *= 1.5  # Change: More adaptive based on success history\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < self.cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return self.cross_prob * mutant + (1 - self.cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            self.success_history.append(successes / self.population_size)  # Track success history\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Enhance the mutation strategy by introducing a more adaptive differential weight that considers the success history of the population.", "configspace": "", "generation": 74, "fitness": 0.25853547096676505, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "c053b97d-dafa-4aa2-b0a5-c484386bd7cb", "metadata": {"aucs": [0.5738244089382487, 0.44313194662931366, 0.41863621010625063, 0.5508007605348526, 0.6108349289721328, 0.579283842194687, 0.5187466399887707, 0.37821463464101857, 0.5278389689565184, 0.2239910669759565, 0.258275072792141, 0.21532570230749815, 0.18595493463581614, 0.26062033222989844, 0.24624720057260907, 0.27024991381625285, 0.10488137034764766, 0.17015305285932059, 0.09736535835729487, 0.10366103174954477, 0.09401755029727332, 0.09143302773791218, 0.0989863188524932, 0.12720051956459955, 0.10200415513062178, 0.11771753651285088, 0.0960009208038749, 0.07331521636104932, 0.07964691411247693, 0.09918474003646549, 0.08814767027083037, 0.09219689729109415, 0.10453332382394509, 0.11107832463294831, 0.11007651996373824, 0.07554335367075327, 0.7932403707871254, 0.8636310370795943, 0.8686789210320689, 0.8320687034290575, 0.7922820462009881, 0.9118489269428216, 0.8470840828731158, 0.8933004046201876, 0.8311334530113298, 0.2193732303177387, 0.19793636618035138, 0.15960419275298043, 0.1531245332949135, 0.19825715760963825, 0.24986673074112264, 0.17043276353292602, 0.1679986221303854, 0.19890851829958778, 0.6041705037241545, 0.7254182189982747, 0.6517666877370611, 0.32624855903814576, 0.7118865514168788, 0.6710557193177247, 0.5959699956408959, 0.22789721898530235, 0.6730191050110592, 0.10597189211417357, 0.15406550375378303, 0.13576845918385227, 0.10687726632489591, 0.2105944158506431, 0.17787262160922923, 0.12094812093278284, 0.2108758198752667, 0.3550084528165125, 0.21008786748091124, 0.1466472616680754, 0.2580713345943427, 0.1482685484591102, 0.20084756321169628, 0.12976827570380234, 0.2372092747901604, 0.18597283774441986, 0.1517993475305237, 0.20510427024124223, 0.19209871816161095, 0.10953484196119956, 0.07840433280862413, 0.05280325036640099, 0.10587315364588468, 0.2736055253141201, 0.3130779091849726, 0.10196902864714796, 0.24173495418226787, 0.3928703021787703, 0.2316423134446448, 0.3586179855067039, 0.11259546609609894, 0.2774337361627156, 0.15690242654745357, 0.17897930614382462, 0.1659641649308491, 0.08846699592796503, 0.09343078052771503, 0.018227283906944503, 0.07784911941605333, 0.050463066482002605, 0.11442636999106814, 0.0008830971823956535, 0.07874018418742712, 0.07947902595643586, 0.178337049048502, 0.15915926870755648, 0.12450818214490977, 0.1865491569080049, 0.1653005158377029, 0.16028487651110246, 0.10351158403059557, 0.14877833177183553, 0.10183939706759504, 0.4851095634591347, 0.47671322569597674, 0.3639409806946231, 0.48862426817098636, 0.5005329534846366, 0.5338373605666684, 0.4647538668551935, 0.5027896530626921, 0.3610980623788147, 0.09282778903031152, 0.11333781090494721, 0.11344927281910877, 0.10170507832390907, 0.11776026328597677, 0.1123158272154191, 0.12077333652468569, 0.11762080650420881, 0.09526668873186794, 0.1499847954515524, 0.15096413363712002, 0.2004615365379343, 0.1585817389833588, 0.1651996182271197, 0.1486064166992408, 0.15014173355890548, 0.16469163734544667, 0.17811919660571296, 0.3194994160876705, 0.3316717279388306, 0.3234024438197728, 0.331467208163572, 0.33170076642298596, 0.32787566305929494, 0.276237641951641, 0.28354204757729307, 0.29596020421936986, 0.2324549809332288, 0.24879888944963546, 0.23188022992041346, 0.2206413582045147, 0.2568841920896613, 0.22067908180095952, 0.260246396338607, 0.23950495787841752, 0.19928717755983427, 0.2074373948186622, 0.19166124383452854, 0.19680296910728579, 0.18095299188625225, 0.1918902544752389, 0.21893532099515656, 0.21526627339434057, 0.19347387884951694, 0.19408312043754483, 0.20954192448206, 0.16811099254354722, 0.18090344706737083, 0.2033574923027952, 0.1827423427171696, 0.1938865092128199, 0.18014419242388646, 0.17957853739828078, 0.18207029878418257, 0.18445691520705743, 0.6471359271949818, 0.7128335194966926, 0.1735332320925852, 0.5530108993236489, 0.18852740376779498, 0.1936050301088349, 0.34248824570731884, 0.6602130260883601, 0.417192334063455, 0.6110109918350937, 0.5525646498818996, 0.44867212607106866, 0.24880426646232667, 0.1970175385447024, 0.2027068411232541, 0.20001770094127957, 0.37454142385944167, 0.18757963888727847, 0.1709268390732035, 0.19077045591799646, 0.18567914175011824, 0.17180816810456145, 0.186167939872237, 0.17614381266320378, 0.18780433114464856, 0.17082625168861743, 0.07738650946925751, 0.08144432542306967, 0.07427071526618167, 0.08062687272992985, 0.08119661504415854, 0.0910663749883841, 0.07804412405474082, 0.08136678531973007, 0.06901575060358356]}, "mutation_prompt": null}
{"id": "430248f9-eabd-44fd-9266-0945eec2b673", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:  \n            adaptive_diff_weight *= 1.25\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < self.cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return self.cross_prob * mutant + (1 - self.cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        # Change: Introduce a dynamic adjustment to the step size\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Introduce a dynamic adjustment to the step size in the directional search to better balance exploration and exploitation.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c053b97d-dafa-4aa2-b0a5-c484386bd7cb", "metadata": {"aucs": [0.49993364447277167, 0.578514780538546, 0.5654213252984656, 0.5338798482202358, 0.5146886167930057, 0.5725463844532885, 0.6086323171219379, 0.5253221883193565, 0.45679305141194126, 0.08133379561967502, 0.1862113773151559, 0.275373509339256, 0.09083185569438679, 0.05073268046392165, 0.23522702219094804, 0.1592544551705405, 0.2067772141942411, 0.1623213518932134, 0.09724780079846618, 0.1246109288317706, 0.09940941787963398, 0.11050154221187891, 0.10143759286261211, 0.08804674993754269, 0.0879253961892118, 0.0950520908323107, 0.1086388980683074, 0.08041139996203728, 0.07490437418297247, 0.08430138515537966, 0.0863665516428831, 0.07387093376886023, 0.08639956504799151, 0.08282253241308757, 0.1003315014003765, 0.0881788197780825, 0.8223345247886336, 0.8511854272677393, 0.8839262241314515, 0.756894629674816, 0.8265229483018428, 0.8742059935482849, 0.8056193187500138, 0.8581623592139263, 0.8026819723487321, 0.2223555133674192, 0.2712292585276699, 0.17633747200545002, 0.18543619778546094, 0.13996336382079044, 0.13959409884086094, 0.21702909003429516, 0.17723313083812098, 0.1472045885671791, 0.636017189426187, 0.5919897540809516, 0.6662903228718402, 0.6827451433654874, 0.685182640936479, 0.7015969090620078, 0.6556140860415169, 0.6233393958505313, 0.5941729199342329, 0.12061783404489124, 0.10980935179578322, 0.13448513551898178, 0.14881033631943685, 0.20788284885952757, 0.13680318060024454, 0.1171882730702195, 0.19781587730443184, 0.13082072791674948, 0.15423969224289447, 0.25683078285755034, 0.1511513449566948, 0.14157211448873153, 0.14398169740758926, 0.16378820356132306, 0.1522433512946505, 0.19320702780187182, 0.1715740243771292, 0.29084969541882033, 0.22346637547558657, 0.22943712330247956, 0.25230624633765375, 0.07188537106233273, 0.05609935463390503, 0.23310390722446273, 0.2425543696119865, 0.2586259701361051, 0.3926467637278732, 0.43341908260182505, 0.18353799512344626, 0.41006561876025316, 0.45216103682177566, 0.22650450555709845, 0.21170821212948931, 0.3604276603989237, 0.3733123909664897, 0.10450310553193942, 0.1482568626770584, 0.17544849600051637, 0.09304632625650211, 0.058054421554266655, 0.07777191124084215, 0.08182671441063594, 0.147653878180523, 0.0949920012161789, 0.2231466285716327, 0.13487722808042235, 0.1931442880676133, 0.20405385315438118, 0.16682284038597972, 0.12394063223373597, 0.2008558578944638, 0.13807760998725083, 0.2130884007799858, 0.4319995570548194, 0.4278765926159004, 0.4060557114507901, 0.5059734525213035, 0.5072763805441065, 0.4538914723187617, 0.5014832146668265, 0.38758861044079196, 0.5160946290237778, 0.11426695155411704, 0.10361146511785391, 0.09175415146851706, 0.09300225406024043, 0.11327867078668585, 0.09764137883870205, 0.09348330450667908, 0.0971856087935028, 0.1260082458273375, 0.17028508530889974, 0.13345961410588203, 0.158508245169921, 0.17241746075109277, 0.1374302533318782, 0.15724200703757618, 0.19222261349655312, 0.12489439662595647, 0.1305866655807848, 0.30068067294968526, 0.3200224877711422, 0.28604163607321953, 0.29317170788915725, 0.2971755178546124, 0.31878879108015, 0.30540079149850385, 0.3371040615282668, 0.33889563954531954, 0.23093910568399434, 0.23286367691219856, 0.2874088160829973, 0.22982424721768524, 0.23399975144957252, 0.24989604008862643, 0.2535398466038613, 0.21024335362604696, 0.2532999747470813, 0.21758615587849495, 0.19798318266992887, 0.18916334271404156, 0.1925216980171921, 0.1819065504299865, 0.19251343164427326, 0.22998055135646722, 0.22014942184984188, 0.22336809647847056, 0.18353220973786222, 0.18411148699479685, 0.19497647254290507, 0.21080610091229923, 0.18307534781422163, 0.17347271692370814, 0.18393858450135792, 0.1972612338671148, 0.1765947174064284, 0.1835469072894641, 0.6461806890776718, 0.6030073777999956, 0.18473993666507493, 0.6971151877524451, 0.1617878627218694, 0.561773199059302, 0.5260216807938747, 0.7005943042889777, 0.6522980644837186, 0.4729243992936759, 0.20302013820920117, 0.4576544135366053, 0.15817679904045634, 0.23742691912821123, 0.19985547291534322, 0.19820981809425076, 0.3290949613614427, 0.17294748397863458, 0.18354798882517376, 0.1738807897823348, 0.18364963883110952, 0.1777652371615468, 0.19223303534973946, 0.1859254467211393, 0.1768267351142616, 0.17709547031767747, 0.0844817251969534, 0.07400208134989517, 0.08783329537843731, 0.0750267985852241, 0.07459322344957586, 0.07083731215821587, 0.08606976854743331, 0.09252637426694998, 0.06373081799426894]}, "mutation_prompt": null}
{"id": "58f7d7d9-0bd0-44ec-bb86-d999c6008443", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:  \n            adaptive_diff_weight *= 1.25\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < self.cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return self.cross_prob * mutant + (1 - self.cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        # Change: Introduce a dynamic adjustment to the step size\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Introduce a dynamic adjustment to the step size in the directional search to better balance exploration and exploitation.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c053b97d-dafa-4aa2-b0a5-c484386bd7cb", "metadata": {"aucs": [0.49993364447277167, 0.578514780538546, 0.5654213252984656, 0.5338798482202358, 0.5146886167930057, 0.5725463844532885, 0.6086323171219379, 0.5253221883193565, 0.45679305141194126, 0.08133379561967502, 0.1862113773151559, 0.275373509339256, 0.09083185569438679, 0.05073268046392165, 0.23522702219094804, 0.1592544551705405, 0.2067772141942411, 0.1623213518932134, 0.09724780079846618, 0.1246109288317706, 0.09940941787963398, 0.11050154221187891, 0.10143759286261211, 0.08804674993754269, 0.0879253961892118, 0.0950520908323107, 0.1086388980683074, 0.08041139996203728, 0.07490437418297247, 0.08430138515537966, 0.0863665516428831, 0.07387093376886023, 0.08639956504799151, 0.08282253241308757, 0.1003315014003765, 0.0881788197780825, 0.8223345247886336, 0.8511854272677393, 0.8839262241314515, 0.756894629674816, 0.8265229483018428, 0.8742059935482849, 0.8056193187500138, 0.8581623592139263, 0.8026819723487321, 0.2223555133674192, 0.2712292585276699, 0.17633747200545002, 0.18543619778546094, 0.13996336382079044, 0.13959409884086094, 0.21702909003429516, 0.17723313083812098, 0.1472045885671791, 0.636017189426187, 0.5919897540809516, 0.6662903228718402, 0.6827451433654874, 0.685182640936479, 0.7015969090620078, 0.6556140860415169, 0.6233393958505313, 0.5941729199342329, 0.12061783404489124, 0.10980935179578322, 0.13448513551898178, 0.14881033631943685, 0.20788284885952757, 0.13680318060024454, 0.1171882730702195, 0.19781587730443184, 0.13082072791674948, 0.15423969224289447, 0.25683078285755034, 0.1511513449566948, 0.14157211448873153, 0.14398169740758926, 0.16378820356132306, 0.1522433512946505, 0.19320702780187182, 0.1715740243771292, 0.29084969541882033, 0.22346637547558657, 0.22943712330247956, 0.25230624633765375, 0.07188537106233273, 0.05609935463390503, 0.23310390722446273, 0.2425543696119865, 0.2586259701361051, 0.3926467637278732, 0.43341908260182505, 0.18353799512344626, 0.41006561876025316, 0.45216103682177566, 0.22650450555709845, 0.21170821212948931, 0.3604276603989237, 0.3733123909664897, 0.10450310553193942, 0.1482568626770584, 0.17544849600051637, 0.09304632625650211, 0.058054421554266655, 0.07777191124084215, 0.08182671441063594, 0.147653878180523, 0.0949920012161789, 0.2231466285716327, 0.13487722808042235, 0.1931442880676133, 0.20405385315438118, 0.16682284038597972, 0.12394063223373597, 0.2008558578944638, 0.13807760998725083, 0.2130884007799858, 0.4319995570548194, 0.4278765926159004, 0.4060557114507901, 0.5059734525213035, 0.5072763805441065, 0.4538914723187617, 0.5014832146668265, 0.38758861044079196, 0.5160946290237778, 0.11426695155411704, 0.10361146511785391, 0.09175415146851706, 0.09300225406024043, 0.11327867078668585, 0.09764137883870205, 0.09348330450667908, 0.0971856087935028, 0.1260082458273375, 0.17028508530889974, 0.13345961410588203, 0.158508245169921, 0.17241746075109277, 0.1374302533318782, 0.15724200703757618, 0.19222261349655312, 0.12489439662595647, 0.1305866655807848, 0.30068067294968526, 0.3200224877711422, 0.28604163607321953, 0.29317170788915725, 0.2971755178546124, 0.31878879108015, 0.30540079149850385, 0.3371040615282668, 0.33889563954531954, 0.23093910568399434, 0.23286367691219856, 0.2874088160829973, 0.22982424721768524, 0.23399975144957252, 0.24989604008862643, 0.2535398466038613, 0.21024335362604696, 0.2532999747470813, 0.21758615587849495, 0.19798318266992887, 0.18916334271404156, 0.1925216980171921, 0.1819065504299865, 0.19251343164427326, 0.22998055135646722, 0.22014942184984188, 0.22336809647847056, 0.18353220973786222, 0.18411148699479685, 0.19497647254290507, 0.21080610091229923, 0.18307534781422163, 0.17347271692370814, 0.18393858450135792, 0.1972612338671148, 0.1765947174064284, 0.1835469072894641, 0.6461806890776718, 0.6030073777999956, 0.18473993666507493, 0.6971151877524451, 0.1617878627218694, 0.561773199059302, 0.5260216807938747, 0.7005943042889777, 0.6522980644837186, 0.4729243992936759, 0.20302013820920117, 0.4576544135366053, 0.15817679904045634, 0.23742691912821123, 0.19985547291534322, 0.19820981809425076, 0.3290949613614427, 0.17294748397863458, 0.18354798882517376, 0.1738807897823348, 0.18364963883110952, 0.1777652371615468, 0.19223303534973946, 0.1859254467211393, 0.1768267351142616, 0.17709547031767747, 0.0844817251969534, 0.07400208134989517, 0.08783329537843731, 0.0750267985852241, 0.07459322344957586, 0.07083731215821587, 0.08606976854743331, 0.09252637426694998, 0.06373081799426894]}, "mutation_prompt": null}
{"id": "2b3f8a94-63ed-4a85-ba12-2fa725ca2a01", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:  \n            adaptive_diff_weight *= 1.25\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        adaptive_cross_prob = self.cross_prob * (0.8 + 0.2 * np.random.rand())  # Change: Context-sensitive scaling\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < adaptive_cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return adaptive_cross_prob * mutant + (1 - adaptive_cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Introduce a context-sensitive scaling in the crossover operation to enhance solution diversity.", "configspace": "", "generation": 77, "fitness": 0.26925315460771243, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "c053b97d-dafa-4aa2-b0a5-c484386bd7cb", "metadata": {"aucs": [0.6524211598810439, 0.5618721906978286, 0.6346030527786524, 0.6065823201093343, 0.5568749195019072, 0.5097199055923244, 0.6544722615942372, 0.6463784813647077, 0.722940631409587, 0.06591618721171977, 0.11784140248513508, 0.37148677976208944, 0.0766255053611189, 0.23751565578209854, 0.35832876559201066, 0.32224594913375204, 0.31674267309532345, 0.327359816706397, 0.11041922526217018, 0.10854097649714589, 0.08936961549285549, 0.12443012967111267, 0.10745869784947704, 0.1274344725659846, 0.11053526378385925, 0.12579082826838117, 0.12735532037077957, 0.09655599743752641, 0.09436079875210235, 0.10085432177662279, 0.09187791125386924, 0.09854771676132734, 0.10272665650619162, 0.09275376598305152, 0.09863130310899781, 0.09150223014154768, 0.7891826416657731, 0.8454460477922073, 0.7655946087501508, 0.7663186311247663, 0.8177463568342807, 0.850205764642695, 0.9297082483933004, 0.8177792387305476, 0.8285438244994016, 0.27062637067101536, 0.17456943039817996, 0.15938061989151597, 0.21956115696735012, 0.18079768821060027, 0.2827258788583167, 0.19211061013532138, 0.1891639372106011, 0.1557262403876284, 0.6296056585124735, 0.6852434317003063, 0.6964778190434847, 0.6978896669707826, 0.738277559909511, 0.32287501963783083, 0.6007892906520136, 0.7016700580295403, 0.6683214443062346, 0.12723463204288454, 0.12353882357988788, 0.09888286948663572, 0.15562492814838647, 0.11858249892475525, 0.1451767196425846, 0.16150955584126836, 0.12710454723900844, 0.16857261642221055, 0.1326067730493471, 0.12637927659788362, 0.17258626856102366, 0.23238978468381555, 0.15369723000337088, 0.2064210378655953, 0.21383500938978528, 0.14102033920910473, 0.14015020377002219, 0.06146282163137606, 0.09232837407152905, 0.02382964039669566, 0.25280545335703186, 0.06947267264194779, 0.10626571551771924, 0.027035658295718523, 0.17584452685892615, 0.0834112377424735, 0.2910154620314612, 0.2764627376814286, 0.21661221854592994, 0.2799669246952392, 0.14572495959491427, 0.3739879387823448, 0.2642557893388815, 0.3189944628817054, 0.4105806723654598, 0.06422045944996657, 0.11796902176701551, 0.07603432887723138, 0.09793895441755562, 0.12406456925540732, 0.11528240091720621, 0.15305822257345647, 0.09810460403403887, 0.08922116055590124, 0.189213904394685, 0.15032036349861777, 0.1926678329800311, 0.20841122651945165, 0.11834636012642474, 0.16801615821125782, 0.1408717965237284, 0.20153121724666712, 0.18895411486112534, 0.5852961029603665, 0.507580180219446, 0.5400632278585376, 0.4793321433672385, 0.4950408492912588, 0.45867865939094876, 0.48929615326123255, 0.48222279367234655, 0.5136309152876789, 0.12548161324367535, 0.11149589751099342, 0.09137146807550012, 0.09117166837837298, 0.10013596247229983, 0.10363740259029441, 0.09765256635741171, 0.08828314665958936, 0.08963259306978777, 0.1461513703087125, 0.13883927016668152, 0.14584613304797134, 0.14687665857914822, 0.14376954319862967, 0.16218120368227118, 0.12898241525623144, 0.15061216445367187, 0.1376837602151747, 0.3169427461183352, 0.34386462526872685, 0.3057104266998155, 0.2986203068301636, 0.33319403046641505, 0.3436864035176004, 0.31814539148879495, 0.28517616169212745, 0.3527831093285304, 0.26033001630210395, 0.25895826412748124, 0.2901704507589373, 0.24354082130890975, 0.2571409714852785, 0.2957835893334615, 0.2374161399033815, 0.25107206004441884, 0.2872489663439858, 0.1888204380871502, 0.1976473788155959, 0.21299735383748708, 0.19116978514105643, 0.20127152127709813, 0.19304556060732336, 0.23879271725003848, 0.1916790972124388, 0.1901399134109506, 0.2121257806701865, 0.19221122805958435, 0.17954795988133465, 0.18830615741926027, 0.19636231934545934, 0.21731974420209776, 0.17929247598425369, 0.1930642740190135, 0.17023388984901044, 0.17812214246558744, 0.48379818576681277, 0.1755921509097117, 0.48726863794451447, 0.6130055580159988, 0.6937018574661924, 0.15101993387605617, 0.1624328108688594, 0.7090086339350312, 0.6297663320144637, 0.3280007284579648, 0.2009142962810605, 0.5784599224702245, 0.5470408264464486, 0.19449398754850045, 0.19501162814105633, 0.19553831053155124, 0.3397674650534095, 0.20932087102176788, 0.17572072736133681, 0.18979614295114244, 0.19697242682234928, 0.17331750918348643, 0.19200860117108687, 0.19009099639797, 0.17679947218705383, 0.17675369159805343, 0.08987940317559928, 0.0811104614004391, 0.07351988358138917, 0.08041884458930293, 0.07516738948418189, 0.0831066374685353, 0.07642398661646332, 0.08767138582415623, 0.07789440700862726]}, "mutation_prompt": null}
{"id": "67f106cf-5a1b-486d-ab24-9c271f5612a1", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:  \n            adaptive_diff_weight *= 1.25\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        progress_factor = 1.0 - (self.current_budget / self.budget)  # Change: base cross_prob on progress\n        adaptive_cross_prob = self.cross_prob * progress_factor * (0.8 + 0.2 * np.random.rand())\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < adaptive_cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return adaptive_cross_prob * mutant + (1 - adaptive_cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Introduce adaptive crossover probability scaling based on function progress to improve exploration.", "configspace": "", "generation": 78, "fitness": 0.2553825802475424, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "2b3f8a94-63ed-4a85-ba12-2fa725ca2a01", "metadata": {"aucs": [0.5389719675329449, 0.6586103461505128, 0.667156664626698, 0.6173327587653089, 0.5635032498991025, 0.6341582445164358, 0.6422618719843778, 0.6132656373275922, 0.4807028866066759, 0.374249211017308, 0.20563507313573692, 0.3827535000316131, 0.16118002272516518, 0.4168149442879173, 0.3689222094570148, 0.3567114009668896, 0.2942368666642512, 0.37952544532438526, 0.09763482437265414, 0.10969516630547571, 0.11305643022150835, 0.10453794644125225, 0.09800022955244492, 0.1073564087718305, 0.10179634753437039, 0.13025541649031513, 0.1069018350184584, 0.1008066231778918, 0.11289690680820841, 0.0973007450199258, 0.10071900336984851, 0.08774006008779611, 0.08792289594605207, 0.09021231447818823, 0.09809200431697496, 0.09860346503320339, 0.7682675005819795, 0.8363580549567443, 0.8048627966033688, 0.7987652648592842, 0.7827975572464991, 0.7901206972535766, 0.9295136948705667, 0.8237720970481088, 0.8203446767110458, 0.17261686946234822, 0.18890789542222308, 0.2290626371190997, 0.21120648023641775, 0.15863210874983447, 0.16288001932427743, 0.184305067221738, 0.21571899615221746, 0.19802134778605018, 0.21799244875975865, 0.4638076800421683, 0.35117418788926535, 0.7022244733801252, 0.6739086959815159, 0.6840937627549543, 0.5947631616522523, 0.25373356214288456, 0.30103413596895146, 0.12947350803003121, 0.15499162913827735, 0.11387601080793741, 0.1359669589302368, 0.12599371886313726, 0.12014989266179799, 0.18452972813338875, 0.18197426737267308, 0.13986449609814533, 0.14457098814141423, 0.13341283391663328, 0.14219427893673697, 0.14295400611036424, 0.12865110752437958, 0.1572687466342486, 0.14300999717407836, 0.11704117144188098, 0.12564570769020333, 0.08354212226506375, 0.004840666981004493, 9.999999999998899e-05, 0.07232378540237072, 0.004354619117626135, 0.07146981809580133, 0.04560801266741421, 0.07073977920670238, 0.03463416711095524, 0.16260544678669342, 0.30783955021842124, 0.13237161067693037, 0.32172841920636797, 0.13506851071453874, 0.25475514369132957, 0.3939411401287133, 0.3298216787977626, 0.14175252555702578, 0.05943580287428507, 0.054608621613508546, 0.08479428582697024, 0.10007977114498989, 0.09979740450719343, 0.08841735340056944, 0.07134781034196336, 0.10022229812978145, 0.09539512018555996, 0.14074204184783534, 0.1724284122716908, 0.20217853549419973, 0.18284522489108435, 0.1423269671187145, 0.08736264480051448, 0.1893249251252449, 0.16018177451728555, 0.19198438976535914, 0.4865798718577088, 0.48854150716612743, 0.5339940799233716, 0.46491970766992996, 0.4237623420622796, 0.5848983475385771, 0.6078788592484444, 0.525063792343234, 0.5048004982167421, 0.09019520050731933, 0.10531404271691824, 0.08551218567832453, 0.08840452865141213, 0.09752705819485674, 0.12121087732170477, 0.09655068489429364, 0.10051401650268221, 0.08363729087368577, 0.15487120099692164, 0.13843196985710837, 0.1324536604344616, 0.14676934240936168, 0.13255447948812893, 0.16020059332364345, 0.13357855959109732, 0.137558484443274, 0.12253781761026805, 0.31850133207984077, 0.3304857759310057, 0.3634904753218512, 0.2942333403171088, 0.36063697341965273, 0.33709954098741457, 0.3547574870146587, 0.35905728066640574, 0.33924285000444276, 0.25460214304070594, 0.24607179633134058, 0.2407462772746024, 0.25256188587237416, 0.2311575362367827, 0.237523738288955, 0.2004250402175085, 0.28065590308701405, 0.23763451066164432, 0.23957400347770286, 0.18960486636327045, 0.22158801612077128, 0.17898736029553364, 0.19831422637097607, 0.19932265670076854, 0.19503019823309764, 0.19723408992645886, 0.18687061521718729, 0.19403041223523598, 0.2060582222357209, 0.17846610529311124, 0.17710091680957907, 0.1855328845021058, 0.17457797191540791, 0.18336064706321242, 0.1801810906692788, 0.1747066378544394, 0.42775362485417967, 0.5119150078869734, 0.18642845402048336, 0.26816000950007524, 0.5635553662679984, 0.5166528396649529, 0.5549136852124175, 0.1601910085064836, 0.746012435629368, 0.4794223449899585, 0.3802912771062894, 0.2303940155331199, 0.3227777519535001, 0.1788540407125132, 0.18809847668418933, 0.18868019921849022, 0.4430670044896303, 0.21519910729369984, 0.18710352117737372, 0.1673892712130466, 0.17474192320890403, 0.17144959611691957, 0.18644464718039666, 0.1735497596509744, 0.18641612473497926, 0.17903266766253745, 0.17083485093100603, 0.08371529892784724, 0.07978480637831198, 0.07690857470440171, 0.0777970708902136, 0.0806655419369785, 0.08529519268132701, 0.07742111496165638, 0.07898990449918131, 0.08409878729911247]}, "mutation_prompt": null}
{"id": "eb100e0d-df77-4dc4-ade1-883504b03d9d", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        diversity = np.std(population, axis=0).mean()  # Change: Calculate diversity\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate) * (1 + diversity)  # Change: Use diversity\n        if success_rate > 0.5:  \n            adaptive_diff_weight *= 1.25\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        adaptive_cross_prob = self.cross_prob * (0.8 + 0.2 * np.random.rand())  # Change: Context-sensitive scaling\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < adaptive_cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return adaptive_cross_prob * mutant + (1 - adaptive_cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Introduce adaptive mutation scaling based on population diversity to improve exploration.", "configspace": "", "generation": 79, "fitness": 0.2072774195629906, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "2b3f8a94-63ed-4a85-ba12-2fa725ca2a01", "metadata": {"aucs": [0.5155927705971961, 0.5063353112735611, 0.5367046520086287, 0.5857725165744505, 0.5884408215522035, 0.5591544355835927, 0.5020756113738318, 0.5565154752084134, 0.5880653822902313, 0.11661009790206556, 0.1252117270670411, 0.15537755438683487, 0.09905271209535327, 0.14372550930906514, 0.14820403656978764, 0.09740971608915894, 0.18077808509643056, 0.16060449140532074, 0.07177144100005572, 0.08682831314985273, 0.09528187573876634, 0.08170223585139358, 0.10011586673035433, 0.1013570196651693, 0.08571983031752983, 0.10116988762733359, 0.08542131835620925, 0.07408291351966778, 0.07493384321053798, 0.056207603572767995, 0.06843415769732442, 0.07595202285100622, 0.06526773356121707, 0.06813339851741307, 0.07830397454252414, 0.07896249011476408, 0.8460546177387713, 0.930244072926403, 0.9434025541655697, 0.8051091097899503, 0.8267898841137089, 0.8575427877867067, 0.8034204823527753, 0.9246251562023174, 0.9616520210516761, 0.16904816292895009, 0.19824561305680888, 0.20410350732920757, 0.18507099377624048, 0.16783877368150002, 0.16165873707818534, 0.20945269268933264, 0.17254734736123478, 0.22341487152660788, 0.44300614878472033, 0.2958280338205779, 0.27653998949927716, 0.46113431914320524, 0.4504615629508467, 0.5170394759591923, 0.45383151236779995, 0.42549142054603606, 0.4285534852319921, 0.09678026805786122, 0.10444308000584046, 0.1017141750196191, 0.09803256171346497, 0.141020606171806, 0.12167466826652307, 0.10994862544757122, 0.1045670122354242, 0.1209185096346409, 0.09040927547231337, 0.10542084062621382, 0.10901938423471458, 0.13491703858173498, 0.11969016334124938, 0.11378156230098435, 0.08087162382727253, 0.12724580937076535, 0.11661002940896215, 0.051094616306949336, 0.08310786175164686, 0.07015013603855369, 0.023198823307187588, 0.04393020366819689, 0.019468209699253558, 0.08366958683356784, 0.034914953502112045, 0.029908875812757252, 0.10711160029068811, 0.14518886563424915, 0.1325099364971748, 0.16483354009285345, 0.10087929915816896, 0.1636779552497517, 0.14529417983701565, 0.14359256479329474, 0.1417935682292113, 0.03052263937612587, 0.01171663003511425, 0.024238083304092606, 0.007869179319694775, 0.049046907470882584, 0.04057927241009618, 0.03639126583801133, 0.07023038156099992, 0.04396340296128787, 0.1086937881536294, 0.1461903150288255, 0.13676641603543527, 0.15930810937174866, 0.15597026151605098, 0.1381690026762642, 0.15745900934190582, 0.16885483943628898, 0.13973969650829932, 0.4204253449068256, 0.3970217603053783, 0.465248790239024, 0.39675607136486923, 0.43478429356361514, 0.4806095217269968, 0.431951712562733, 0.4317580569732371, 0.41968263023484764, 0.09497415670399345, 0.08130794522865292, 0.0813522826573515, 0.0813583874537257, 0.08540985068711104, 0.08801266607357827, 0.07123762212754792, 0.08375024016493338, 0.07895975468872618, 0.13323782732127243, 0.14318648334021833, 0.13652291203661748, 0.20748816148215699, 0.15575243706374653, 0.1378957114644651, 0.14104314739576307, 0.11980461893428307, 0.17138854775433232, 0.23720835739815893, 0.25221355652283584, 0.2763701499419764, 0.2197946451332059, 0.245934782942425, 0.24585668841544128, 0.2450626283483508, 0.28869496811774775, 0.25273877308050974, 0.15825714245633338, 0.19081009793270565, 0.18467581397273714, 0.15487172863381726, 0.18179350635255165, 0.17659415234656262, 0.19299246256801017, 0.1807350528436018, 0.2363885801775205, 0.17207110011301052, 0.18766515828052333, 0.16405115128245162, 0.17748507512205702, 0.1714980838707566, 0.1693082088278992, 0.18941965416315887, 0.1801031074968421, 0.18094121698200005, 0.16813479741278825, 0.170134843583023, 0.17283339690812605, 0.15445304762510603, 0.16322212076138098, 0.1680428966969445, 0.17212092198864337, 0.16805981155909844, 0.18647272594911635, 0.17026053709356914, 0.22862749391888204, 0.17056118824377386, 0.16899790414752058, 0.2043685755206366, 0.2608060278440898, 0.18145391778196385, 0.21304324010997755, 0.14530615724429063, 0.17595450374994193, 0.15378370370710837, 0.17610392274553288, 0.14842501337547853, 0.18710381902760131, 0.15437326356418213, 0.1864187578921499, 0.18628489667746495, 0.16681905741435854, 0.1672919623526593, 0.17444803365322203, 0.1775592205622153, 0.18638452314408982, 0.17150060060430827, 0.18593401795668862, 0.1796049246811301, 0.174836228030128, 0.18778276372354108, 0.06080143937587723, 0.06613462162930805, 0.07265078813304993, 0.06714852403100924, 0.07349220183198779, 0.07160279225427824, 0.07108138693076094, 0.06398256860839724, 0.06857933075037503]}, "mutation_prompt": null}
{"id": "a06259f8-9bf6-401e-9897-fd7788fbfcf1", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:  \n            adaptive_diff_weight *= 1.25\n        # Change: Dynamic scaling based on budget usage\n        scale_factor = 1.0 + 0.5 * (self.current_budget / self.budget) \n        mutant = a + scale_factor * adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        adaptive_cross_prob = self.cross_prob * (0.8 + 0.2 * np.random.rand())\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < adaptive_cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return adaptive_cross_prob * mutant + (1 - adaptive_cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Refine mutation strategy using dynamic scaling to adaptively increase exploration capability.", "configspace": "", "generation": 80, "fitness": 0.2639282882960182, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "2b3f8a94-63ed-4a85-ba12-2fa725ca2a01", "metadata": {"aucs": [0.6518862967784711, 0.6218535387115254, 0.47353340118161247, 0.596696560047181, 0.5824936179872986, 0.6288284239153412, 0.6311002481532014, 0.6094887929631718, 0.6647113773571216, 0.23760279071978785, 0.36583759691243634, 0.3413614584989402, 0.2729366001780006, 0.0825316882819277, 0.191192930026568, 0.29911462489760887, 0.33503790444731807, 0.3266397453971779, 0.08693012111371423, 0.10396128570522101, 0.11139075329169523, 0.09683731951874275, 0.08995625907444593, 0.1152691215610332, 0.10161141887308878, 0.10495254749532201, 0.1058673916142816, 0.088802235669736, 0.1074183164726954, 0.09903063721704586, 0.07943611389609051, 0.0964539463461106, 0.08878465160151094, 0.0918452612581594, 0.09432187619052401, 0.0868516136919858, 0.8466166333168672, 0.845272832955096, 0.7787571822148595, 0.758576391249245, 0.817698483093656, 0.898235144087511, 0.9297073899031997, 0.8094803162737387, 0.8286851585138854, 0.23238629702430647, 0.21970958384642758, 0.1679810669703946, 0.18368413779404613, 0.1940897262742819, 0.205119972300575, 0.20624395534847395, 0.20838270741109866, 0.191709712531143, 0.2979996896298729, 0.5397312788618033, 0.7505113887356856, 0.6939140340536127, 0.6971050892591726, 0.650882621627481, 0.6192601042855481, 0.6680755431016238, 0.2239870290171504, 0.1975974358114727, 0.1963022434437517, 0.12305790479586753, 0.21834443859682984, 0.1338688374814645, 0.15507701160695142, 0.1387032858865337, 0.17147651156252053, 0.13045870436001517, 0.14622904960302163, 0.16064837996828119, 0.1668560857616178, 0.22453020009156577, 0.1692405742788231, 0.1855969694693157, 0.19178028045159035, 0.15298451839961658, 0.13562871049418102, 0.1798430556828784, 0.2392932400270653, 0.0009220419560888038, 0.07422654523192873, 0.24495964439311757, 0.07183648249470154, 0.06314851525927279, 0.2586133883639199, 0.010328823925445652, 0.33617771094039717, 0.36941732269934713, 0.20732127596862004, 0.1703543032685606, 0.21582332919601033, 0.22557370658628872, 0.3090276766641824, 0.32722618547172744, 0.21387267703328872, 0.08803385094873606, 0.08962393923498546, 0.08790832938846016, 0.07878945046266439, 0.0862131238848417, 0.07465897688936507, 0.10564938017509484, 0.12391724827805572, 0.06161055037465435, 0.20228586592775044, 0.1828778825946461, 0.1752718516035835, 0.20284272562548944, 0.18633898118266345, 0.18665885933719129, 0.10967591018786971, 0.16022952833793058, 0.20967325080734045, 0.4911219597413602, 0.5063361631797199, 0.5299635722311223, 0.4760524355378021, 0.46924556612595103, 0.45561139298898756, 0.5401508715207513, 0.5363770647910139, 0.5975121939221966, 0.09807995928333735, 0.10183488568898735, 0.10136480169383577, 0.10340616415656567, 0.10433248851411103, 0.11641000744128194, 0.09489033915096245, 0.0878910494968459, 0.09478367325119452, 0.13411312934719133, 0.12994764323390662, 0.13966040750902042, 0.14065800252493244, 0.16401779160237895, 0.13257941318614663, 0.12263416823658868, 0.14150931903802788, 0.14412315560872868, 0.307688226914275, 0.3397131307307173, 0.3040358007865497, 0.3021164547467937, 0.3053466400221262, 0.3637851932584041, 0.3304959637243895, 0.3319701431505728, 0.32707519948754293, 0.2654701409444107, 0.250984107408426, 0.2829939643653856, 0.23391709317372522, 0.28225385854834306, 0.2769360325352186, 0.18925123365977636, 0.2605060132340472, 0.25960263443846965, 0.20758974155755083, 0.22893301775669084, 0.18772180812908457, 0.1837697481156465, 0.20155205946166566, 0.21502736737237216, 0.19241339012938308, 0.20986124134675033, 0.1919690037592955, 0.18832199799721006, 0.17720149127259688, 0.1859947783472563, 0.18912698955651008, 0.1773170940283213, 0.2054296495531711, 0.1811514261216456, 0.17862848294759193, 0.18573907503357046, 0.1771373678694096, 0.18056416838356415, 0.17788758230211665, 0.6147672295649638, 0.6233600414445586, 0.6139636059026704, 0.1543940696181404, 0.35712351067066983, 0.7191630265040211, 0.5554459204726802, 0.25008230747894966, 0.20223981728205742, 0.45734931148156477, 0.18944301233572924, 0.17620854088054494, 0.19982057524464758, 0.27487261694832965, 0.2171073013788769, 0.1877472321691679, 0.1694742594222738, 0.18239027230465843, 0.17874449855327168, 0.19003934203328876, 0.18632889834988486, 0.19134887615926244, 0.18418607153263244, 0.1747211829706442, 0.07031653288075612, 0.083555400427343, 0.08061435669168482, 0.0773959779505814, 0.07672799784641993, 0.0779323227996832, 0.08179076376655392, 0.07208203820095183, 0.09070772030451502]}, "mutation_prompt": null}
{"id": "096edddd-8be8-4a38-b357-83b07fc76fce", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n        self.success_rate_history = []  # New line for tracking success rates\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:\n            adaptive_diff_weight *= 1.25\n        if self.success_rate_history:  # Modified to adjust mutation weight based on success history\n            historical_success_rate = np.mean(self.success_rate_history[-min(len(self.success_rate_history), 10):])  # New line\n            adaptive_diff_weight *= (1 + 0.2 * historical_success_rate)  # New line\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        adaptive_cross_prob = self.cross_prob * (0.8 + 0.2 * np.random.rand())\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < adaptive_cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return adaptive_cross_prob * mutant + (1 - adaptive_cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n                self.success_rate_history.append(successes / self.population_size)  # New line to track success rates\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Dynamically adjust the mutation weight based on historical success rates to balance exploration and exploitation.", "configspace": "", "generation": 81, "fitness": 0.2733980643283442, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.20.", "error": "", "parent_id": "2b3f8a94-63ed-4a85-ba12-2fa725ca2a01", "metadata": {"aucs": [0.6269554526359937, 0.6173465928544242, 0.6075952252556658, 0.5770278710896117, 0.648909244685548, 0.5884819517122373, 0.5632594641964337, 0.6128487451273316, 0.6025865351847643, 0.2129994788594276, 0.3340964529291719, 0.34759635086655993, 0.2744476258947367, 0.29545188977176506, 0.30025197744449683, 0.2941215109194366, 0.30440663057598005, 0.3085508573108242, 0.10149027922180032, 0.09980971901589875, 0.10941019424191722, 0.10791856079678186, 0.11279325846040933, 0.11023744488843279, 0.11807643948541224, 0.09882203197203654, 0.11360535551714479, 0.08526975280519455, 0.1098276617092162, 0.09177568521930957, 0.09675076114099845, 0.10587703234225243, 0.09487477634285968, 0.09746512140081864, 0.0912728367805834, 0.08845706944987664, 0.8024319189734294, 0.8411244909135098, 0.8262751357556309, 0.8232487952116149, 0.8095201589794269, 0.828116487705919, 0.8923375586535418, 0.8193150838588679, 0.818302054386681, 0.2399732560313923, 0.22480685719854077, 0.18625663978995655, 0.2116890440246617, 0.21968630521589938, 0.18259621553172878, 0.19822931644274, 0.16730913695365712, 0.2059225167645462, 0.6360789733331309, 0.6372091844372942, 0.6361083378984573, 0.7037085790572992, 0.6741695087123103, 0.6123212459107568, 0.551469650731345, 0.5895335887331897, 0.6411893193153769, 0.3007771474395563, 0.1237689834235991, 0.1770408473397389, 0.12585503088845396, 0.1324411814469495, 0.1590604645072906, 0.1447597413637539, 0.15821974733128585, 0.1338088926088663, 0.14635082604291416, 0.12447145335365017, 0.14691227616415214, 0.15047315610923162, 0.12899505950258627, 0.13240140786802146, 0.19886270575174492, 0.15835772684407368, 0.1342301182449699, 0.2532946365568032, 0.20881568909614212, 0.2078316733146235, 0.2306686460005699, 0.06389863050694089, 0.0822152009420064, 0.22520630461220614, 0.13778204025515317, 0.16563535689259168, 0.32450276191137717, 0.3721240452539153, 0.41145622778583757, 0.40278641014900485, 0.33396509945662023, 0.36822497261919107, 0.29973396452868184, 0.41019206423678334, 0.23121029330415221, 0.07712647471962086, 0.09437704949909476, 0.10450792700703748, 0.10092746727608426, 0.07629597575456537, 0.10068964838234717, 0.0747466506969311, 0.07114582760554544, 0.07665626217144494, 0.1724554493372218, 0.14578642927081187, 0.20189338977679472, 0.16668397879431673, 0.14892770621227847, 0.17842059132848698, 0.1711865063584832, 0.17014244604665296, 0.2238834747356655, 0.48982379782159347, 0.4712090273220898, 0.4768811743331306, 0.5343442687381441, 0.5141452737705008, 0.4861802373589038, 0.5073342294349867, 0.47724754088904897, 0.5823153554858527, 0.0922349297452234, 0.10249173486604579, 0.10121940785445604, 0.10151910879160464, 0.12684465785566768, 0.09534983436587896, 0.10588576991819587, 0.08615481707775141, 0.1057263795933523, 0.12126742924105238, 0.12980569419626076, 0.1561761340390594, 0.1458042093782138, 0.14672002106797644, 0.13273148112848043, 0.13909878947236243, 0.15250170849559364, 0.13745034334160955, 0.29942934449761816, 0.3292558426286666, 0.31251080666737985, 0.31918163302149705, 0.33066890750662037, 0.36967804632803336, 0.3026160680081339, 0.3197832455010743, 0.2888975025193178, 0.24747940346960218, 0.2617173255479778, 0.2805729383422404, 0.2553548681384874, 0.22998599010616294, 0.2567310633118365, 0.23509488149816293, 0.19113410004986653, 0.23397501626789619, 0.19139322898472866, 0.19238783704998108, 0.1993485182135889, 0.20100152995638487, 0.18457587420565025, 0.198404112181489, 0.1855465255817763, 0.201709884013618, 0.20839177165472522, 0.19175682282929418, 0.18770490229983328, 0.22120735539266412, 0.1904033337793486, 0.20587851921629186, 0.17876517495061928, 0.19567885171028676, 0.1834756263501759, 0.18589398480724995, 0.17214399121398805, 0.17563077350284007, 0.17521478373361898, 0.677147795214266, 0.5576681227167437, 0.7030294388626904, 0.1556479068378085, 0.16543796559798551, 0.6515925894252204, 0.63517665145706, 0.3762934356433908, 0.20137555711020605, 0.4911413058117171, 0.1741079410864339, 0.18832818655782535, 0.19213740434655424, 0.2519747399018999, 0.6679221767365457, 0.18116382789130026, 0.18481738353968058, 0.1828313057127089, 0.18090344829606164, 0.17625062852323625, 0.18270801721850927, 0.1870216188490872, 0.17729484316535982, 0.17738221374333119, 0.07291914980729475, 0.08138878728410559, 0.0801453732150359, 0.0781665514023604, 0.08538756716010032, 0.08232724258570667, 0.08489864987641649, 0.08915146296019993, 0.0794176285106567]}, "mutation_prompt": null}
{"id": "fdadc509-d0fb-4e18-9b1a-18f12f91cb6f", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n        self.success_rate_history = []  # New line for tracking success rates\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:\n            adaptive_diff_weight *= 1.25\n        if self.success_rate_history:  # Modified to adjust mutation weight based on success history\n            historical_success_rate = np.mean(self.success_rate_history[-min(len(self.success_rate_history), 10):])  # New line\n            success_rate_variance = np.var(self.success_rate_history[-min(len(self.success_rate_history), 10):])  # New line\n            adaptive_diff_weight *= (1 + 0.2 * historical_success_rate + 0.1 * success_rate_variance)  # Adjusted line\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        adaptive_cross_prob = self.cross_prob * (0.8 + 0.2 * np.random.rand())\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < adaptive_cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return adaptive_cross_prob * mutant + (1 - adaptive_cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n                self.success_rate_history.append(successes / self.population_size)  # New line to track success rates\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Enhance adaptive differential weight by incorporating the variance of recent success rates to dynamically balance exploration and exploitation.", "configspace": "", "generation": 82, "fitness": 0.2768601484427012, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.21.", "error": "", "parent_id": "096edddd-8be8-4a38-b357-83b07fc76fce", "metadata": {"aucs": [0.6140302129027424, 0.6047997412025918, 0.6052184294269318, 0.5894527370992966, 0.630185527120144, 0.6308178128928017, 0.5773827944095129, 0.6164492687339496, 0.600912364273281, 0.22544600080055666, 0.3483793382312975, 0.37790999955505644, 0.28654090323246395, 0.2054461830083777, 0.3518909874373729, 0.29216870055680444, 0.34775130461892745, 0.30373958521507516, 0.09773282193762278, 0.1087519858263799, 0.11600314923452604, 0.10199370962334886, 0.10075670358561872, 0.11576200696134087, 0.10754235137812806, 0.10409421240299055, 0.10905719657465729, 0.0985190577754449, 0.11522756801710288, 0.09438377039994394, 0.08695119418522335, 0.10617713311391475, 0.09162416386868277, 0.08736773403812226, 0.09582750842923415, 0.09553276675487232, 0.8024321821720515, 0.8411244682522285, 0.8262746998724947, 0.8232526707105423, 0.8095368358447166, 0.828117961344299, 0.8923377030337964, 0.8193140441075677, 0.8183009330746589, 0.26401856874446905, 0.2221859423464836, 0.22393041860474217, 0.20679491343648193, 0.26616886166387443, 0.1826494330695484, 0.2154224976065544, 0.1802953735982452, 0.21660254580999705, 0.614394145985732, 0.6543034500629101, 0.6475959957617181, 0.7421922816450273, 0.7331821903042607, 0.611071309611342, 0.7001976720171429, 0.6259177698696933, 0.576812236365273, 0.3360223595652543, 0.12421957860372601, 0.17294038068499162, 0.12552562682698132, 0.13063571057736412, 0.2030567019750571, 0.1411803888425549, 0.14295787760014733, 0.14959223336828487, 0.1471465791284693, 0.12538108826859062, 0.14438502918488882, 0.15536118614799743, 0.12735846362487735, 0.13522809233483846, 0.20760045332941568, 0.1556188478631889, 0.13363470033540692, 0.20840021788346252, 0.21786762195059806, 0.11528949144415923, 0.1976833880553217, 0.06784322014322974, 0.06079838872544385, 0.06278684802117895, 0.3066172501560871, 0.13489250265698172, 0.39227333461527547, 0.3981900807453652, 0.3379480519909712, 0.3924654605094735, 0.3724416580043237, 0.15881014191368248, 0.3752850938912581, 0.39899937490521364, 0.20407446612526947, 0.08474000947581184, 0.10436858212238198, 0.09981107591559246, 0.11337329846772903, 0.07057349881966402, 0.09397160469121113, 0.08032639771216998, 0.08339522738982375, 0.07876456502748919, 0.19449244134006138, 0.15929600450273063, 0.19604755213012381, 0.18768263773620697, 0.1652338394295857, 0.1722442174803811, 0.16624586263060714, 0.14450180442790717, 0.19512266740788287, 0.5242498391424453, 0.47340533612588853, 0.5195125339183823, 0.5420033340384389, 0.5110275088429821, 0.547391944013649, 0.5115460624543309, 0.4506025998795069, 0.6073996937527735, 0.11872539881613142, 0.10171546269654486, 0.10285183447704749, 0.09182841172721923, 0.10400795694769516, 0.0946560902616217, 0.10285200709343112, 0.09487593742304512, 0.1080130322768651, 0.13363960470658764, 0.12640279123820708, 0.15763438806550856, 0.15027966686889782, 0.13113033262529694, 0.14702209599694993, 0.14474206135964107, 0.12721580128851706, 0.1292536717619589, 0.31909807270645607, 0.3355955656772941, 0.31948296549378896, 0.31737883610800766, 0.3181245996502702, 0.3521163108592176, 0.3062288922530756, 0.35138699956992914, 0.285209875070799, 0.22691334882794645, 0.28411235459193585, 0.24728213417336464, 0.24698970604764514, 0.2874126274438651, 0.2832245871302438, 0.21872143119047815, 0.25630199844922463, 0.21195212020365894, 0.18142558724279034, 0.18709403763180166, 0.2159344940013409, 0.19062128004584433, 0.21173144364781038, 0.1876311235414334, 0.19143490215008752, 0.20209389725426352, 0.20320924519421024, 0.1922474745165207, 0.18709493959436763, 0.19390554010833116, 0.18935993951905716, 0.19825116972676726, 0.17730050511479334, 0.1943130008334012, 0.18516808235995863, 0.17841635099819908, 0.17386799402416198, 0.17603203144461133, 0.17481957202950038, 0.6296222875768411, 0.65451696372933, 0.6505990886458399, 0.43602450115114766, 0.16545817987480282, 0.6582185527720805, 0.6574689680692922, 0.3840709469886765, 0.2012315135073488, 0.5221321825998828, 0.18545071327320062, 0.18826789670304211, 0.19143800856945992, 0.25780438872186384, 0.6481361736745586, 0.17337082036419416, 0.17345520784440271, 0.17793661999719512, 0.17474408633004423, 0.17362722473462433, 0.17327276153402904, 0.16928093617769335, 0.18340418212209098, 0.19076510026317073, 0.07554808008128022, 0.08821296310163285, 0.07595161916073812, 0.08036214716444734, 0.07661553974816293, 0.08366377783729262, 0.07616426557286615, 0.08795523711738074, 0.08659348794193722]}, "mutation_prompt": null}
{"id": "1faed835-6b7c-4ed0-9fc4-bd0d22124007", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n        self.success_rate_history = []\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:\n            adaptive_diff_weight *= 1.25\n        if self.success_rate_history:\n            historical_success_rate = np.mean(self.success_rate_history[-min(len(self.success_rate_history), 10):])\n            success_rate_variance = np.var(self.success_rate_history[-min(len(self.success_rate_history), 10):])\n            adaptive_diff_weight *= (1 + 0.2 * historical_success_rate + 0.1 * success_rate_variance)\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        adaptive_cross_prob = self.cross_prob * (0.8 + 0.2 * np.random.rand())\n        if self.success_rate_history:  # Adjust crossover probability based on historical variance\n            success_rate_variance = np.var(self.success_rate_history[-min(len(self.success_rate_history), 10):])\n            adaptive_cross_prob *= (1 + 0.1 * success_rate_variance)\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < adaptive_cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return adaptive_cross_prob * mutant + (1 - adaptive_cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n                self.success_rate_history.append(successes / self.population_size)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Enhance the crossover strategy by implementing a dynamic adjustment of crossover probability based on historical success variance.", "configspace": "", "generation": 83, "fitness": 0.274784417212975, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.20.", "error": "", "parent_id": "fdadc509-d0fb-4e18-9b1a-18f12f91cb6f", "metadata": {"aucs": [0.6223830930453029, 0.6485579793671631, 0.6137108573728705, 0.6019759776043904, 0.5954438466685574, 0.5080172411995229, 0.5794947944985775, 0.6028414584746384, 0.5688956165779406, 0.24856865198071743, 0.3419783034589764, 0.2695645413120509, 0.32085729051419964, 0.25275601562114725, 0.3358460240857173, 0.2895960240501092, 0.3388038294463156, 0.2997239305273448, 0.09121799573433309, 0.09196836334248837, 0.11757357281499103, 0.10759753944803929, 0.10688182668002177, 0.1048727944792176, 0.10386372304303682, 0.10869796107980911, 0.11372792033528911, 0.08474701929411654, 0.10359552867703714, 0.10524659248579304, 0.09049567167750228, 0.10221851968124085, 0.08871037840163043, 0.086595333857173, 0.09558373486095062, 0.10743138556137488, 0.8043567480313287, 0.8411258129412323, 0.8262975509141883, 0.8232579808062459, 0.8106646480395686, 0.8281211819621805, 0.8923384098028484, 0.819328877026331, 0.8182910735939233, 0.23411453658035142, 0.2752953291401601, 0.20089516882684033, 0.22475831376554456, 0.24924192064634676, 0.19785860874483785, 0.1945237457897736, 0.19319082776912466, 0.2062350695692048, 0.639902631026825, 0.6589685080506653, 0.5796177554176993, 0.681580982001053, 0.6994699328573637, 0.608638224694974, 0.5648019586347834, 0.6464978059184423, 0.6719588379971162, 0.2079367628884724, 0.12669655742834807, 0.2105446854805343, 0.12380274517376588, 0.1307778393040735, 0.1887692716596503, 0.13993578359546133, 0.20665946775014665, 0.13787111095797266, 0.1671394096911787, 0.1291788860261045, 0.14904494078009523, 0.14141349952377824, 0.1635142394116721, 0.15189854478590914, 0.1875799746209722, 0.15197271589904704, 0.16596384709960543, 0.22316021302295042, 0.1429739902693704, 0.10088676292733234, 0.25157621437997313, 0.10015500365810714, 0.06319006692934603, 0.11060608383167325, 0.23635967047729778, 0.21257597927460903, 0.2935543701868504, 0.46645007043886266, 0.2759765598395397, 0.2302188416994717, 0.2515800213391449, 0.2018157451758983, 0.32537810977799875, 0.4280110720635578, 0.283481988848445, 0.07578590718889222, 0.08039387758948124, 0.14421396524876873, 0.08903822844346254, 0.09703953632209417, 0.12430261876505788, 0.10164164575142098, 0.0734189337732889, 0.08869000168707841, 0.16523263101976915, 0.19462696276508007, 0.1738316738572161, 0.19105769951187357, 0.11968806153135214, 0.17181087921244576, 0.1699909353957939, 0.21055576673191867, 0.1780315526077395, 0.535918674608574, 0.547812566217907, 0.5229220525344453, 0.5314736817410788, 0.5198467682495607, 0.5514395493619524, 0.5101975819633078, 0.5817849440831446, 0.5609638040344223, 0.10115224834467607, 0.10626780206567821, 0.09720230167608623, 0.08887084228045117, 0.09963781451839482, 0.1041811856819651, 0.11615410862772535, 0.0925582787046425, 0.10077979084397559, 0.14407775853049154, 0.1357682017400359, 0.1671494995148407, 0.13515897605986338, 0.1418129095615388, 0.12730764843255948, 0.16419899785277192, 0.14900008670193254, 0.1600890497651999, 0.3144146097211318, 0.31852390452383017, 0.3056235910028531, 0.32434394485647955, 0.32713247282181546, 0.3722804676097007, 0.33116729644044385, 0.33112899581578836, 0.28481094793012673, 0.25101510248037584, 0.26843981664728866, 0.2828398000564235, 0.26621731302270746, 0.2913374058110437, 0.256902677325236, 0.2534677033312389, 0.2365400982086271, 0.2480886987717147, 0.23273421744825196, 0.19528350579134357, 0.1843095591578321, 0.21553204810648363, 0.18444580442268466, 0.19691319260381324, 0.20306671769051576, 0.19099715445579635, 0.2177155422324618, 0.18588215296610966, 0.1809710039428032, 0.18997220338690723, 0.18549588322973554, 0.18615412333074755, 0.18343610724706927, 0.19311167735030532, 0.17437298957752612, 0.1771257776047096, 0.17808185898797124, 0.17604676100240535, 0.17438495458312775, 0.43501427365700507, 0.5533337511114965, 0.6676013426476157, 0.15558589319640992, 0.1649743171245085, 0.639173507028596, 0.6462926302573574, 0.4332560960967933, 0.30487037718238275, 0.6026241665985518, 0.1925855815016766, 0.18748852191641996, 0.19172604940758797, 0.2616314272572806, 0.6676435301184592, 0.17415630942124594, 0.17688618255416788, 0.17034918852974457, 0.17769519641801346, 0.19031033422552768, 0.18477792689157535, 0.1709527244382565, 0.18501015691803668, 0.17006693511280135, 0.07176853344037648, 0.07316012828033269, 0.08287407460865359, 0.0799682352786587, 0.0709599553238901, 0.08312995319208527, 0.077873784733128, 0.0863456319432998, 0.0899364949695155]}, "mutation_prompt": null}
{"id": "c6b89e71-4860-4450-8049-8d26beb6f506", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n        self.success_rate_history = []  # New line for tracking success rates\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:\n            adaptive_diff_weight *= 1.25\n        if self.success_rate_history:  # Modified to adjust mutation weight based on success history\n            historical_success_rate = np.mean(self.success_rate_history[-min(len(self.success_rate_history), 10):])  # New line\n            success_rate_variance = np.var(self.success_rate_history[-min(len(self.success_rate_history), 10):])  # New line\n            adaptive_diff_weight *= (1 + 0.2 * historical_success_rate + 0.1 * success_rate_variance)  # Adjusted line\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        adaptive_cross_prob = self.cross_prob * (0.8 + 0.2 * np.random.rand())\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < adaptive_cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return adaptive_cross_prob * mutant + (1 - adaptive_cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        gradient_info = np.random.normal(0, 0.05, size=self.dim)  # Added line for using gradient-like information\n        candidate += gradient_info  # Line modified to apply gradient influence\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n                self.success_rate_history.append(successes / self.population_size)  # New line to track success rates\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Enhance the directional search component to exploit fitness gradient information for improved convergence.", "configspace": "", "generation": 84, "fitness": 0.27994726968378325, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.20.", "error": "", "parent_id": "fdadc509-d0fb-4e18-9b1a-18f12f91cb6f", "metadata": {"aucs": [0.6214997116003469, 0.5114110745835886, 0.5916126384803571, 0.5894494674103653, 0.6183621990215804, 0.6245497464758398, 0.562756193378043, 0.6201894912352781, 0.6002022817885863, 0.31552134347898486, 0.2882378675229357, 0.37190537945726787, 0.3144695863585689, 0.31265427626101383, 0.3674519229092388, 0.23617478903486366, 0.3426548761405367, 0.21214539851974612, 0.10517427138005764, 0.10185883879289126, 0.1005800358501836, 0.10720026898746304, 0.11021276280389214, 0.09743065919613347, 0.10043630427259576, 0.10934522794354273, 0.11114116046280975, 0.0911565820779533, 0.08288100509703833, 0.08653849929226942, 0.09673275181727026, 0.08860353423078793, 0.0864819251784309, 0.08713093249251325, 0.08930761625956751, 0.09979996359857124, 0.701000937771296, 0.8075169641587854, 0.6395610908047202, 0.8005427616672471, 0.7683173536946594, 0.7584070299954832, 0.8528465384189289, 0.7870505311417153, 0.6900352920634214, 0.2863817074998426, 0.20890192590097045, 0.22702052205741652, 0.20946922949086078, 0.22269316033469233, 0.20462819858070613, 0.23996031672144214, 0.23235633529821564, 0.1731858189579889, 0.6382826411720477, 0.5997157118394385, 0.6712554981995852, 0.6614528263501407, 0.575209247551393, 0.6817351825995804, 0.5981894526097813, 0.721103403705414, 0.6881477526701356, 0.13513213645341826, 0.3245552452525703, 0.10570262366781413, 0.1696426032532523, 0.13649664627585623, 0.14111792419104585, 0.1579347858560055, 0.1855142435131878, 0.1656982535957472, 0.20273612438084787, 0.15795864725688824, 0.17114925143426718, 0.1524967859453703, 0.12843551627703997, 0.13237124348550044, 0.1866739800656788, 0.14320635046227548, 0.15827691230807361, 0.22805809508365082, 0.22080609335194457, 0.18520867395176066, 0.2432906723210544, 0.1693061960948622, 0.12496029879130255, 0.22058354936799907, 0.20604271624036286, 0.267047982910249, 0.4151455111630171, 0.33025857125487856, 0.3271487981242269, 0.1956147164040717, 0.11029549584343656, 0.09000807271754074, 0.3554240135588378, 0.11298529328147544, 0.31247844138238, 0.06670936058127686, 0.1597727678580244, 0.1364542982048912, 0.059968836434029615, 0.10946774831843309, 0.08516001742016577, 0.11303400432780142, 0.09651556666943506, 0.07953584846131401, 0.21226355633945804, 0.17994766299660192, 0.19880542670500823, 0.15697221240042203, 0.22590419781450377, 0.15851806176848005, 0.1109719827180532, 0.16332558497915528, 0.1738861341515936, 0.5023638953445805, 0.5652622688762381, 0.44349378744656387, 0.5136801240880384, 0.4912556579523971, 0.5355928232291938, 0.48797726080511206, 0.5557210066577554, 0.4669122452888036, 0.08714455456631365, 0.10135731796439085, 0.09121714867353548, 0.09730112815115621, 0.09112838697914172, 0.11344010117046255, 0.08662160466044022, 0.10043756096958656, 0.09370647263293774, 0.1400086089681296, 0.16640056352866084, 0.1324371751952751, 0.15119560137244048, 0.15615002207641138, 0.14592832145033663, 0.13882587578842198, 0.1530005496730299, 0.1519407694359144, 0.3518175488835126, 0.36156199291113356, 0.3262009910352923, 0.34518929830574485, 0.3266957256657793, 0.3482993499946081, 0.3036973040200259, 0.3422346979936809, 0.32063905863288555, 0.2534629435503998, 0.25999807523237173, 0.23155838288545505, 0.2807518543908064, 0.2470252455749301, 0.29580452982102723, 0.26264393796259555, 0.2747206657449741, 0.27916846345352697, 0.18932291251249167, 0.24887106609069154, 0.17993437836106163, 0.17869236889957119, 0.17478096746949667, 0.17593024092092857, 0.1922915597607182, 0.19198136478405536, 0.2046973836459668, 0.17851890782591706, 0.1764097456845347, 0.1946207865321834, 0.19915664969542857, 0.1842540087440503, 0.26621822267645656, 0.18296195406096682, 0.2623816516309213, 0.18957695304714783, 0.1816007829364401, 0.38087760515389535, 0.681721611469104, 0.6023225807318437, 0.6286640912478911, 0.5869933724363097, 0.5709665228439704, 0.736414325174986, 0.6704778709427875, 0.6461653127922715, 0.4617735763259917, 0.3159192083685427, 0.37226804277067027, 0.3516141269324987, 0.20114433647671282, 0.42642767017963945, 0.31954510027186, 0.22468359886541767, 0.18012858351146732, 0.17280665241338133, 0.1757623507130236, 0.17487294542024667, 0.1782334500929259, 0.17315372879984903, 0.17387621264137, 0.17744528874386456, 0.1988342895303825, 0.09761306167475359, 0.0787331470755076, 0.07681793433421968, 0.07371406104842204, 0.07340500356316737, 0.07540870584860437, 0.07444001977563608, 0.08269168313263142, 0.07331762779673767]}, "mutation_prompt": null}
{"id": "26938b9c-99ab-4549-9ca3-bf21cd982d57", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n        self.success_rate_history = []  # New line for tracking success rates\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:\n            adaptive_diff_weight *= 1.25\n        if self.success_rate_history:  # Modified to adjust mutation weight based on success history\n            historical_success_rate = np.mean(self.success_rate_history[-min(len(self.success_rate_history), 10):])  # New line\n            success_rate_variance = np.var(self.success_rate_history[-min(len(self.success_rate_history), 10):])  # New line\n            adaptive_diff_weight *= (1 + 0.2 * historical_success_rate + 0.1 * success_rate_variance)  # Adjusted line\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        adaptive_cross_prob = self.cross_prob * (0.8 + 0.2 * np.random.rand())\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < adaptive_cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return adaptive_cross_prob * mutant + (1 - adaptive_cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.15 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))  # Modified step size\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        gradient_info = np.random.normal(0, 0.05, size=self.dim)  # Added line for using gradient-like information\n        candidate += gradient_info  # Line modified to apply gradient influence\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n                self.success_rate_history.append(successes / self.population_size)  # New line to track success rates\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Fine-tune the step size in directional search to better exploit local fitness landscapes for improved convergence.", "configspace": "", "generation": 85, "fitness": 0.268546177181197, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.20.", "error": "", "parent_id": "c6b89e71-4860-4450-8049-8d26beb6f506", "metadata": {"aucs": [0.6129195743832989, 0.6113614545455522, 0.6328221245566401, 0.5897038678303882, 0.6077674621441078, 0.5959030218975081, 0.561261764932026, 0.6785904475871634, 0.6529181080914035, 0.2864904226491457, 0.23421189158769828, 0.26943735713754136, 0.3423649678691171, 0.29117148988651564, 0.3734596289914416, 0.31442571925671137, 0.04853843352123166, 0.28287079319580566, 0.11099296032036621, 0.11054499619111757, 0.09348004885129635, 0.10877613938848318, 0.11129860533043134, 0.10830755102604084, 0.09471804583955545, 0.1257665240179272, 0.09074421476439876, 0.10630406011140936, 0.0923433606528622, 0.09318478400612351, 0.09207845874317011, 0.09629535011148416, 0.09679657553143428, 0.09240836511090289, 0.08438480677293969, 0.09222061696339856, 0.6879766743014615, 0.7512491257450608, 0.7729015033516784, 0.8180399860739085, 0.6217407248855913, 0.8669168729060673, 0.7034940280589005, 0.729837542404415, 0.6865910945816649, 0.20162746490811956, 0.1964836521268365, 0.2208586510235384, 0.20265727285287816, 0.1630072249474167, 0.24850420970435927, 0.15835074233567992, 0.20522037398275628, 0.1874652623010299, 0.578356446632174, 0.5333927031472113, 0.6412497019175363, 0.6447937018455899, 0.5501880432452211, 0.6937308244471831, 0.5925737633748154, 0.6278912076258822, 0.7441859149291715, 0.16703703431454942, 0.11347254618766478, 0.19353125314069908, 0.13052971431540206, 0.1306554299087851, 0.17001099741894654, 0.2793657764557992, 0.14606160964297343, 0.15706153029802405, 0.13551891493459456, 0.12353564369806058, 0.1589208284189333, 0.14987987500869826, 0.15872430500311907, 0.16693140298848508, 0.13761461944657039, 0.1930238511474951, 0.16130230333097317, 0.1021424147156178, 0.14558588057712096, 0.074727670270059, 0.20577915510729616, 0.1127627564021868, 0.06985240592455744, 0.2196687241547406, 0.15463412698010415, 0.0441041186536959, 0.199515115066619, 0.1767927672682308, 0.28194445491102016, 0.23053272572127959, 0.23131176406213094, 0.3060782460363962, 0.33258691131894924, 0.15608786567186084, 0.3310793696980907, 0.09649171864502437, 0.045025117748943244, 0.07845909676688412, 0.08523109316303346, 0.04814218823113692, 0.12009343557107821, 0.08891963336503195, 0.11803936924629999, 0.09064079701096539, 0.17552916313856404, 0.16383102337985544, 0.1644476831993319, 0.1889924421393393, 0.14578416262469018, 0.18146651877675046, 0.19256194819658823, 0.10941625485621387, 0.16994158252868763, 0.5542210474693939, 0.5505910203225436, 0.42637458313578147, 0.4870451232481954, 0.5071404101155962, 0.5155946870123442, 0.5368354723777942, 0.5741730246267226, 0.49099862018444895, 0.10316534936633182, 0.10184530619156174, 0.1081348247636501, 0.08625986389807039, 0.09396344042063898, 0.09658614441087099, 0.0901515175957025, 0.11294278378680467, 0.12933754228671646, 0.1315400526775966, 0.12936975810681195, 0.12340074263005119, 0.16290796175437028, 0.16487189131012003, 0.14030480667439837, 0.15334176652638887, 0.17475307059654754, 0.16927384240706, 0.30715049647718595, 0.33174843625268813, 0.3280315419177636, 0.331024944287167, 0.28109014262425214, 0.31427370232760066, 0.2941879114531989, 0.3456540145038368, 0.3415714155422428, 0.24873610759123976, 0.28287068833703244, 0.23428141331612906, 0.26202171435365695, 0.283827359106236, 0.2477885691835745, 0.2746236879349775, 0.19417236061946785, 0.24259863906299584, 0.18725770720115165, 0.17972951249210878, 0.18875275043952722, 0.18395365534322305, 0.1872614526744687, 0.17725096289073494, 0.2071870675230144, 0.1884210209660775, 0.20560301920004131, 0.18348990940622711, 0.18218926941504954, 0.23393732218038754, 0.1895582452466137, 0.1808619445445, 0.1813028292164801, 0.17534137850343956, 0.19769401367733985, 0.17985950788384708, 0.6421335024257002, 0.6008537948187442, 0.6053706568940277, 0.18072860635802512, 0.5948804880464381, 0.6453875751304676, 0.5333593977528703, 0.6558337728886838, 0.37342827996746397, 0.6477439988018281, 0.20029850252241277, 0.19042221952183214, 0.3564349494071798, 0.19055130023858502, 0.1920078190418274, 0.6606666467087355, 0.43467849123667324, 0.14858769031930097, 0.1804379596521115, 0.18244844676203387, 0.17273240502649756, 0.17980625217814217, 0.1776782474102172, 0.1958537951228143, 0.1891808524793197, 0.18292977168905677, 0.19104682510458504, 0.07684922137462014, 0.07780921753998449, 0.08894614485340457, 0.07689608724779151, 0.06976273220826135, 0.06950555012028103, 0.07104403702721485, 0.07976223154204876, 0.0919613898864533]}, "mutation_prompt": null}
{"id": "4a31a4ae-d893-4b1d-bf35-607849f316cb", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n        self.success_rate_history = []  # New line for tracking success rates\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:\n            adaptive_diff_weight *= 1.25\n        if self.success_rate_history:  # Modified to adjust mutation weight based on success history\n            historical_success_rate = np.mean(self.success_rate_history[-min(len(self.success_rate_history), 10):])  # New line\n            success_rate_variance = np.var(self.success_rate_history[-min(len(self.success_rate_history), 10):])  # New line\n            adaptive_diff_weight *= (1 + 0.2 * historical_success_rate + 0.1 * success_rate_variance)  # Adjusted line\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        adaptive_cross_prob = self.cross_prob * (0.8 + 0.2 * np.random.rand())\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < adaptive_cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return adaptive_cross_prob * mutant + (1 - adaptive_cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        gradient_info = np.random.normal(0, 0.05, size=self.dim)  # Added line for using gradient-like information\n        candidate += gradient_info  # Line modified to apply gradient influence\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n                self.success_rate_history.append(successes / self.population_size)  # New line to track success rates\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Enhance the directional search component to exploit fitness gradient information for improved convergence.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c6b89e71-4860-4450-8049-8d26beb6f506", "metadata": {"aucs": [0.6214997116003469, 0.5114110745835886, 0.5916126384803571, 0.5894494674103653, 0.6183621990215804, 0.6245497464758398, 0.562756193378043, 0.6201894912352781, 0.6002022817885863, 0.31552134347898486, 0.2882378675229357, 0.37190537945726787, 0.3144695863585689, 0.31265427626101383, 0.3674519229092388, 0.23617478903486366, 0.3426548761405367, 0.21214539851974612, 0.10517427138005764, 0.10185883879289126, 0.1005800358501836, 0.10720026898746304, 0.11021276280389214, 0.09743065919613347, 0.10043630427259576, 0.10934522794354273, 0.11114116046280975, 0.0911565820779533, 0.08288100509703833, 0.08653849929226942, 0.09673275181727026, 0.08860353423078793, 0.0864819251784309, 0.08713093249251325, 0.08930761625956751, 0.09979996359857124, 0.701000937771296, 0.8075169641587854, 0.6395610908047202, 0.8005427616672471, 0.7683173536946594, 0.7584070299954832, 0.8528465384189289, 0.7870505311417153, 0.6900352920634214, 0.2863817074998426, 0.20890192590097045, 0.22702052205741652, 0.20946922949086078, 0.22269316033469233, 0.20462819858070613, 0.23996031672144214, 0.23235633529821564, 0.1731858189579889, 0.6382826411720477, 0.5997157118394385, 0.6712554981995852, 0.6614528263501407, 0.575209247551393, 0.6817351825995804, 0.5981894526097813, 0.721103403705414, 0.6881477526701356, 0.13513213645341826, 0.3245552452525703, 0.10570262366781413, 0.1696426032532523, 0.13649664627585623, 0.14111792419104585, 0.1579347858560055, 0.1855142435131878, 0.1656982535957472, 0.20273612438084787, 0.15795864725688824, 0.17114925143426718, 0.1524967859453703, 0.12843551627703997, 0.13237124348550044, 0.1866739800656788, 0.14320635046227548, 0.15827691230807361, 0.22805809508365082, 0.22080609335194457, 0.18520867395176066, 0.2432906723210544, 0.1693061960948622, 0.12496029879130255, 0.22058354936799907, 0.20604271624036286, 0.267047982910249, 0.4151455111630171, 0.33025857125487856, 0.3271487981242269, 0.1956147164040717, 0.11029549584343656, 0.09000807271754074, 0.3554240135588378, 0.11298529328147544, 0.31247844138238, 0.06670936058127686, 0.1597727678580244, 0.1364542982048912, 0.059968836434029615, 0.10946774831843309, 0.08516001742016577, 0.11303400432780142, 0.09651556666943506, 0.07953584846131401, 0.21226355633945804, 0.17994766299660192, 0.19880542670500823, 0.15697221240042203, 0.22590419781450377, 0.15851806176848005, 0.1109719827180532, 0.16332558497915528, 0.1738861341515936, 0.5023638953445805, 0.5652622688762381, 0.44349378744656387, 0.5136801240880384, 0.4912556579523971, 0.5355928232291938, 0.48797726080511206, 0.5557210066577554, 0.4669122452888036, 0.08714455456631365, 0.10135731796439085, 0.09121714867353548, 0.09730112815115621, 0.09112838697914172, 0.11344010117046255, 0.08662160466044022, 0.10043756096958656, 0.09370647263293774, 0.1400086089681296, 0.16640056352866084, 0.1324371751952751, 0.15119560137244048, 0.15615002207641138, 0.14592832145033663, 0.13882587578842198, 0.1530005496730299, 0.1519407694359144, 0.3518175488835126, 0.36156199291113356, 0.3262009910352923, 0.34518929830574485, 0.3266957256657793, 0.3482993499946081, 0.3036973040200259, 0.3422346979936809, 0.32063905863288555, 0.2534629435503998, 0.25999807523237173, 0.23155838288545505, 0.2807518543908064, 0.2470252455749301, 0.29580452982102723, 0.26264393796259555, 0.2747206657449741, 0.27916846345352697, 0.18932291251249167, 0.24887106609069154, 0.17993437836106163, 0.17869236889957119, 0.17478096746949667, 0.17593024092092857, 0.1922915597607182, 0.19198136478405536, 0.2046973836459668, 0.17851890782591706, 0.1764097456845347, 0.1946207865321834, 0.19915664969542857, 0.1842540087440503, 0.26621822267645656, 0.18296195406096682, 0.2623816516309213, 0.18957695304714783, 0.1816007829364401, 0.38087760515389535, 0.681721611469104, 0.6023225807318437, 0.6286640912478911, 0.5869933724363097, 0.5709665228439704, 0.736414325174986, 0.6704778709427875, 0.6461653127922715, 0.4617735763259917, 0.3159192083685427, 0.37226804277067027, 0.3516141269324987, 0.20114433647671282, 0.42642767017963945, 0.31954510027186, 0.22468359886541767, 0.18012858351146732, 0.17280665241338133, 0.1757623507130236, 0.17487294542024667, 0.1782334500929259, 0.17315372879984903, 0.17387621264137, 0.17744528874386456, 0.1988342895303825, 0.09761306167475359, 0.0787331470755076, 0.07681793433421968, 0.07371406104842204, 0.07340500356316737, 0.07540870584860437, 0.07444001977563608, 0.08269168313263142, 0.07331762779673767]}, "mutation_prompt": null}
{"id": "2fd53f46-0255-4a8f-b47b-abcc5b15301b", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n        self.success_rate_history = []  # New line for tracking success rates\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:\n            adaptive_diff_weight *= 1.25\n        if self.success_rate_history:  # Modified to adjust mutation weight based on success history\n            historical_success_rate = np.mean(self.success_rate_history[-min(len(self.success_rate_history), 10):])  # New line\n            success_rate_variance = np.var(self.success_rate_history[-min(len(self.success_rate_history), 10):])  # New line\n            adaptive_diff_weight *= (1 + 0.2 * historical_success_rate + 0.1 * success_rate_variance)  # Adjusted line\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        adaptive_cross_prob = self.cross_prob * (0.8 + 0.2 * np.random.rand())\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < adaptive_cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return adaptive_cross_prob * mutant + (1 - adaptive_cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        gradient_info = np.random.normal(0, 0.05, size=self.dim)  # Added line for using gradient-like information\n        candidate += gradient_info  # Line modified to apply gradient influence\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n                self.success_rate_history.append(successes / self.population_size)  # New line to track success rates\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Enhance the directional search component to exploit fitness gradient information for improved convergence.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c6b89e71-4860-4450-8049-8d26beb6f506", "metadata": {"aucs": [0.6214997116003469, 0.5114110745835886, 0.5916126384803571, 0.5894494674103653, 0.6183621990215804, 0.6245497464758398, 0.562756193378043, 0.6201894912352781, 0.6002022817885863, 0.31552134347898486, 0.2882378675229357, 0.37190537945726787, 0.3144695863585689, 0.31265427626101383, 0.3674519229092388, 0.23617478903486366, 0.3426548761405367, 0.21214539851974612, 0.10517427138005764, 0.10185883879289126, 0.1005800358501836, 0.10720026898746304, 0.11021276280389214, 0.09743065919613347, 0.10043630427259576, 0.10934522794354273, 0.11114116046280975, 0.0911565820779533, 0.08288100509703833, 0.08653849929226942, 0.09673275181727026, 0.08860353423078793, 0.0864819251784309, 0.08713093249251325, 0.08930761625956751, 0.09979996359857124, 0.701000937771296, 0.8075169641587854, 0.6395610908047202, 0.8005427616672471, 0.7683173536946594, 0.7584070299954832, 0.8528465384189289, 0.7870505311417153, 0.6900352920634214, 0.2863817074998426, 0.20890192590097045, 0.22702052205741652, 0.20946922949086078, 0.22269316033469233, 0.20462819858070613, 0.23996031672144214, 0.23235633529821564, 0.1731858189579889, 0.6382826411720477, 0.5997157118394385, 0.6712554981995852, 0.6614528263501407, 0.575209247551393, 0.6817351825995804, 0.5981894526097813, 0.721103403705414, 0.6881477526701356, 0.13513213645341826, 0.3245552452525703, 0.10570262366781413, 0.1696426032532523, 0.13649664627585623, 0.14111792419104585, 0.1579347858560055, 0.1855142435131878, 0.1656982535957472, 0.20273612438084787, 0.15795864725688824, 0.17114925143426718, 0.1524967859453703, 0.12843551627703997, 0.13237124348550044, 0.1866739800656788, 0.14320635046227548, 0.15827691230807361, 0.22805809508365082, 0.22080609335194457, 0.18520867395176066, 0.2432906723210544, 0.1693061960948622, 0.12496029879130255, 0.22058354936799907, 0.20604271624036286, 0.267047982910249, 0.4151455111630171, 0.33025857125487856, 0.3271487981242269, 0.1956147164040717, 0.11029549584343656, 0.09000807271754074, 0.3554240135588378, 0.11298529328147544, 0.31247844138238, 0.06670936058127686, 0.1597727678580244, 0.1364542982048912, 0.059968836434029615, 0.10946774831843309, 0.08516001742016577, 0.11303400432780142, 0.09651556666943506, 0.07953584846131401, 0.21226355633945804, 0.17994766299660192, 0.19880542670500823, 0.15697221240042203, 0.22590419781450377, 0.15851806176848005, 0.1109719827180532, 0.16332558497915528, 0.1738861341515936, 0.5023638953445805, 0.5652622688762381, 0.44349378744656387, 0.5136801240880384, 0.4912556579523971, 0.5355928232291938, 0.48797726080511206, 0.5557210066577554, 0.4669122452888036, 0.08714455456631365, 0.10135731796439085, 0.09121714867353548, 0.09730112815115621, 0.09112838697914172, 0.11344010117046255, 0.08662160466044022, 0.10043756096958656, 0.09370647263293774, 0.1400086089681296, 0.16640056352866084, 0.1324371751952751, 0.15119560137244048, 0.15615002207641138, 0.14592832145033663, 0.13882587578842198, 0.1530005496730299, 0.1519407694359144, 0.3518175488835126, 0.36156199291113356, 0.3262009910352923, 0.34518929830574485, 0.3266957256657793, 0.3482993499946081, 0.3036973040200259, 0.3422346979936809, 0.32063905863288555, 0.2534629435503998, 0.25999807523237173, 0.23155838288545505, 0.2807518543908064, 0.2470252455749301, 0.29580452982102723, 0.26264393796259555, 0.2747206657449741, 0.27916846345352697, 0.18932291251249167, 0.24887106609069154, 0.17993437836106163, 0.17869236889957119, 0.17478096746949667, 0.17593024092092857, 0.1922915597607182, 0.19198136478405536, 0.2046973836459668, 0.17851890782591706, 0.1764097456845347, 0.1946207865321834, 0.19915664969542857, 0.1842540087440503, 0.26621822267645656, 0.18296195406096682, 0.2623816516309213, 0.18957695304714783, 0.1816007829364401, 0.38087760515389535, 0.681721611469104, 0.6023225807318437, 0.6286640912478911, 0.5869933724363097, 0.5709665228439704, 0.736414325174986, 0.6704778709427875, 0.6461653127922715, 0.4617735763259917, 0.3159192083685427, 0.37226804277067027, 0.3516141269324987, 0.20114433647671282, 0.42642767017963945, 0.31954510027186, 0.22468359886541767, 0.18012858351146732, 0.17280665241338133, 0.1757623507130236, 0.17487294542024667, 0.1782334500929259, 0.17315372879984903, 0.17387621264137, 0.17744528874386456, 0.1988342895303825, 0.09761306167475359, 0.0787331470755076, 0.07681793433421968, 0.07371406104842204, 0.07340500356316737, 0.07540870584860437, 0.07444001977563608, 0.08269168313263142, 0.07331762779673767]}, "mutation_prompt": null}
{"id": "5ca48880-034c-4fe3-a3e0-d1a099451c0c", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n        self.success_rate_history = []  # New line for tracking success rates\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:\n            adaptive_diff_weight *= 1.25\n        if self.success_rate_history:  # Modified to adjust mutation weight based on success history\n            historical_success_rate = np.mean(self.success_rate_history[-min(len(self.success_rate_history), 10):])  # New line\n            success_rate_variance = np.var(self.success_rate_history[-min(len(self.success_rate_history), 10):])  # New line\n            adaptive_diff_weight *= (1 + 0.2 * historical_success_rate + 0.1 * success_rate_variance)  # Adjusted line\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        adaptive_cross_prob = self.cross_prob * (0.8 + 0.25 * np.random.rand())  # Adjusted line for crossover probability\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < adaptive_cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return adaptive_cross_prob * mutant + (1 - adaptive_cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        gradient_info = np.random.normal(0, 0.05, size=self.dim)  # Added line for using gradient-like information\n        candidate += gradient_info  # Line modified to apply gradient influence\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n                self.success_rate_history.append(successes / self.population_size)  # New line to track success rates\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Fine-tune the adaptive crossover probability and the mutation strategy to enhance exploration and exploitation balance.", "configspace": "", "generation": 88, "fitness": 0.27310140690216056, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.20.", "error": "", "parent_id": "c6b89e71-4860-4450-8049-8d26beb6f506", "metadata": {"aucs": [0.6139733588361225, 0.6103052420527528, 0.6194780865050724, 0.5774871262267228, 0.5984581632373351, 0.5460243310563708, 0.5692371416459477, 0.5840934282550383, 0.6225881921262539, 0.2570427427301222, 0.33855282127889574, 0.3210448691229787, 0.3072969343359033, 0.300939593880894, 0.2097443073761196, 0.30079020066952056, 0.366124097250091, 0.19841624575932482, 0.1414385506780672, 0.09005903940026527, 0.0979278276758434, 0.09887236408260036, 0.11505737310766762, 0.10424286685020956, 0.11300161465889691, 0.10751665466188476, 0.11146794451038733, 0.09224959480469153, 0.10742457360831537, 0.1049229399433973, 0.08705652132276243, 0.08340238724619431, 0.08835315732818527, 0.09862216178217764, 0.07832389106884041, 0.10474905715551686, 0.6906627936441772, 0.7214666352134482, 0.7975125197068111, 0.793199098792466, 0.7160543194673776, 0.8046938351671713, 0.7459974098477782, 0.7436159454081848, 0.695224378475747, 0.19946364184351728, 0.19869146832664353, 0.22904880540131078, 0.20678311262854987, 0.19194027763439137, 0.15512367054771115, 0.22014519862285364, 0.22047903618506548, 0.19820536406182665, 0.5204568250125359, 0.6878465005997297, 0.618173226683073, 0.6800202115474412, 0.6529898019859648, 0.6744619758959856, 0.3366538573111153, 0.6864034820374783, 0.5930784701225007, 0.16031617829065037, 0.11539909183009278, 0.2785477990141816, 0.17471999516731196, 0.12099026621127018, 0.1334847471285, 0.28604395712112096, 0.16883013396560986, 0.16762328242284474, 0.1307440976483314, 0.1440887717617797, 0.120360178245427, 0.15268581410439275, 0.16112799570786374, 0.19246107716795702, 0.16021107986061756, 0.1799202793826915, 0.12466193301380668, 0.17891594622211737, 0.12692368107276575, 0.0864825784795541, 0.22508514242217637, 0.07850376516932733, 0.17167225692234156, 0.14631641089102398, 0.06058527197219721, 0.2700769418577773, 0.15983535324775444, 0.36038889154432263, 0.356681682965853, 0.36179041356440134, 0.2252604752466505, 0.09572056170088039, 0.4166603032913633, 0.33796286560236755, 0.4487512795695716, 0.06256460958882759, 0.09418905214342543, 0.038798607681954866, 0.08636215387167556, 0.1382095277867642, 0.0892614180791581, 0.09559637272110155, 0.08618475228061084, 0.08500591385615841, 0.17379706254251925, 0.2108233528955359, 0.1869865723974421, 0.18426038548631973, 0.19148113575205017, 0.1987836725225548, 0.19515259303678678, 0.2113688196889678, 0.1624608646214487, 0.5367388575895116, 0.44661273080402586, 0.5338221698811252, 0.5299619365853971, 0.5252691187886129, 0.5136869215062906, 0.5449353827280304, 0.47838800628558686, 0.48735151605335814, 0.09245225777932586, 0.10322710165616267, 0.10091233203779926, 0.08302784789880502, 0.1165687230253869, 0.10485185952880105, 0.0920919643203868, 0.07877126725643224, 0.11655549730463532, 0.14385553940149054, 0.1482832384349314, 0.1418771639266857, 0.14783957611849308, 0.13296947144635174, 0.14742071378666932, 0.14014200783096364, 0.14609578229206532, 0.14649270720512375, 0.2982790748123654, 0.3196577373493591, 0.33273439803961247, 0.2739463385284323, 0.3321297808908673, 0.2918753430537183, 0.2934065230755193, 0.2895649681093645, 0.3108835915146001, 0.25443134230494013, 0.26385276207467345, 0.2567980473711484, 0.26458961422684535, 0.24172758872683253, 0.2466996264354968, 0.2729945582832882, 0.25842545410486895, 0.2506540469332138, 0.18805516219708174, 0.20708580915127006, 0.1977978020345439, 0.19631616118866413, 0.202042341316379, 0.17601593210620525, 0.19549030993787342, 0.21603334404721664, 0.1969930895286448, 0.17882771553475119, 0.1826278133167768, 0.1839796780213201, 0.18816595306221084, 0.18423102347755704, 0.18688620580900783, 0.18493800714771447, 0.18809252966716483, 0.181909438176866, 0.18056606772253403, 0.1696501752957842, 0.6672977640992903, 0.40121190586653876, 0.5992880738034311, 0.6336061608177688, 0.5541632640528809, 0.6397164207764534, 0.6151264640716199, 0.7267310035741537, 0.5207552681249776, 0.1969653873013859, 0.5380970935134799, 0.1995972651381761, 0.3276896893966439, 0.4728179611617561, 0.4261790978047204, 0.14993546467920282, 0.17703492402918797, 0.1881120604405322, 0.19148258629716142, 0.17586395991950465, 0.18577041298825792, 0.1790541178297259, 0.1911398749364387, 0.18243540260723567, 0.19628820047882245, 0.08793900233274721, 0.08150303546357196, 0.07591407156132157, 0.07282385115138257, 0.08060013556935919, 0.08134791596782065, 0.07935868960561854, 0.08346221798872833, 0.07624347032720946]}, "mutation_prompt": null}
{"id": "71642f4f-796a-4f62-be7a-5671c5fcdeb8", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n        self.success_rate_history = []  # New line for tracking success rates\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:\n            adaptive_diff_weight *= 1.25\n        if self.success_rate_history:  # Modified to adjust mutation weight based on success history\n            historical_success_rate = np.mean(self.success_rate_history[-min(len(self.success_rate_history), 10):])  # New line\n            success_rate_variance = np.var(self.success_rate_history[-min(len(self.success_rate_history), 10):])  # New line\n            adaptive_diff_weight *= (1 + 0.2 * historical_success_rate + 0.1 * success_rate_variance)  # Adjusted line\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        adaptive_cross_prob = self.cross_prob * (0.8 + 0.2 * np.random.rand())\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < adaptive_cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return adaptive_cross_prob * mutant + (1 - adaptive_cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        budget_ratio = self.current_budget / self.budget\n        # Updated step size with fitness improvement rate integration\n        fitness_improvement_rate = max(0.1, np.mean(self.success_rate_history[-min(len(self.success_rate_history), 5):])) * 0.5  # New line\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + fitness_improvement_rate * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))  # Modified line\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        gradient_info = np.random.normal(0, 0.05, size=self.dim)  # Added line for using gradient-like information\n        candidate += gradient_info  # Line modified to apply gradient influence\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n                self.success_rate_history.append(successes / self.population_size)  # New line to track success rates\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Introduce adaptive step size modulation based on the fitness improvement rate for enhanced exploration and exploitation balance.", "configspace": "", "generation": 89, "fitness": 0.27333737490511634, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.20.", "error": "", "parent_id": "c6b89e71-4860-4450-8049-8d26beb6f506", "metadata": {"aucs": [0.6470665343709896, 0.6153362370869178, 0.6286124740133293, 0.5976277551183604, 0.6750916629712459, 0.61826979808617, 0.5530532560939364, 0.5870692507940733, 0.6318848866304683, 0.24768620803353647, 0.3342102471255014, 0.32546077664480877, 0.35925325346448334, 0.3639605604259286, 0.10750667178853723, 0.2970073095540503, 0.3565597052401991, 0.27774282113278737, 0.1028126390897931, 0.1038889267775367, 0.1368807124076462, 0.10051070592318267, 0.11994549540391108, 0.09814701523683811, 0.1099649305840994, 0.10906048788603362, 0.11294712370858728, 0.09036219358746345, 0.08417344526619619, 0.09861909629528764, 0.09436402180116277, 0.12140935849795953, 0.08726576942094011, 0.10265208578874552, 0.09253911049530328, 0.09181233043086756, 0.7997361684550484, 0.744421742519138, 0.7820878820564218, 0.8236263299750257, 0.8193290568374949, 0.8004782999856347, 0.6903147802173195, 0.608598907532083, 0.9184659505451775, 0.19625581397725933, 0.1867812820524799, 0.18431246531421408, 0.17115225197793538, 0.18829603064341882, 0.1692957334732753, 0.2584990484529771, 0.17278838200724844, 0.1790978808286785, 0.6769373550785307, 0.5975586894854079, 0.7020152208775503, 0.346595300462061, 0.6335841712168502, 0.6506213621378509, 0.6646624046916565, 0.29233756016633705, 0.6762691020692326, 0.12281933638743026, 0.19672206053973473, 0.13229173042575149, 0.14048243500033353, 0.16378519108726508, 0.13648924015899666, 0.1328302142896799, 0.12142699851139627, 0.1878866892638058, 0.17268802176120934, 0.14871237337148868, 0.14964856054705, 0.16583584350147829, 0.21868411548533873, 0.13727884463151985, 0.31638359597687193, 0.14683458192423604, 0.12844629776741823, 0.19940192821862235, 0.10167367747492517, 0.20139684927369494, 0.16917797852353256, 0.09593789898098071, 0.1602180131211156, 0.07947307560126571, 0.11705621305593816, 0.028221884916620588, 0.3602064008842576, 0.41259470378936947, 0.28691123510648486, 0.07998263982305176, 0.0824973598391383, 0.18383958924722332, 0.3689769977389763, 0.33804109715291286, 0.25702414477654745, 0.09474863904326392, 0.10627278994720002, 0.07775094209720779, 0.09247603796818604, 0.07705950919566695, 0.11397839024564038, 0.12010904485461782, 0.10031390242219862, 0.11112544039157712, 0.182877903710701, 0.1702178531114118, 0.15478261310525399, 0.17139762373415268, 0.21297796975491767, 0.16254630300788908, 0.14551049715059583, 0.18313287066185213, 0.16230421671571893, 0.5193684317964582, 0.5779734753562079, 0.5365563933499067, 0.5107960209300728, 0.49760642600606464, 0.5091384241792875, 0.5988413354780672, 0.45586083818443635, 0.5508113318053944, 0.09752669829496374, 0.10019852254738382, 0.09293165773758205, 0.10269145744441999, 0.12696833543017272, 0.12231465998687108, 0.09572864048161422, 0.11957644027426084, 0.10012666204471765, 0.12212518898416924, 0.13715700216214322, 0.1506854162791348, 0.14372863003350322, 0.19713375741154826, 0.17772811407512856, 0.14621755581346185, 0.13771372845298724, 0.12111077291069283, 0.29503369926062883, 0.3382309709319615, 0.3368438056973798, 0.3302505528142561, 0.3439293573429719, 0.31406635856224485, 0.2932119544057168, 0.33053315565467745, 0.29565903916402114, 0.24867170024895346, 0.28931715537179603, 0.20507021391141356, 0.24078316406844003, 0.2564200376059931, 0.2743368090325513, 0.21527953516487097, 0.22614832384547845, 0.23782422534730652, 0.1981547172860988, 0.23684068226087363, 0.19233904055682938, 0.21890765832654813, 0.1996945018633216, 0.17969573467713618, 0.19239011367339076, 0.18694865773982028, 0.19459767963525842, 0.21906154065716277, 0.19027040040034882, 0.18938338529527143, 0.17211324096270508, 0.1970370970624663, 0.21242676056395937, 0.19089377833765597, 0.19672314959038917, 0.19209518620864297, 0.17998933987066468, 0.5689216674715275, 0.6519274820520411, 0.49096618340958986, 0.7339826975551715, 0.559896238955198, 0.5285669678496006, 0.6576489151596775, 0.16407097927066572, 0.6315142004455399, 0.4271972011403714, 0.19029892605112786, 0.4677791115255021, 0.4621649172335681, 0.24379536759520504, 0.4496081047369226, 0.4074177703003725, 0.3263593174846634, 0.18880266745659313, 0.1785795714144166, 0.1773121279223927, 0.18206695810524587, 0.1741717346853653, 0.17083947612788397, 0.17796409207745678, 0.18108840327315745, 0.1735140574172871, 0.08099211130162054, 0.07493601014926388, 0.06559092076548734, 0.08128795332574557, 0.07854571275719102, 0.08536842455544413, 0.09758215860660024, 0.07352998118203335, 0.08046153380844356]}, "mutation_prompt": null}
{"id": "d690de41-c469-4b7d-9d6f-4febf10acd0d", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n        self.success_rate_history = []  # New line for tracking success rates\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:\n            adaptive_diff_weight *= 1.25\n        if self.success_rate_history:  # Modified to adjust mutation weight based on success history\n            historical_success_rate = np.mean(self.success_rate_history[-min(len(self.success_rate_history), 10):])  # New line\n            success_rate_variance = np.var(self.success_rate_history[-min(len(self.success_rate_history), 10):])  # New line\n            adaptive_diff_weight *= (1 + 0.2 * historical_success_rate + 0.1 * success_rate_variance)  # Adjusted line\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        adaptive_cross_prob = self.cross_prob * (0.8 + 0.2 * np.random.rand())\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < adaptive_cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return adaptive_cross_prob * mutant + (1 - adaptive_cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        gradient_info = np.random.normal(0, 0.05, size=self.dim)  # Added line for using gradient-like information\n        candidate += gradient_info  # Line modified to apply gradient influence\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n                self.success_rate_history.append(successes / self.population_size)  # New line to track success rates\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Enhance the directional search component to exploit fitness gradient information for improved convergence.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c6b89e71-4860-4450-8049-8d26beb6f506", "metadata": {"aucs": [0.6214997116003469, 0.5114110745835886, 0.5916126384803571, 0.5894494674103653, 0.6183621990215804, 0.6245497464758398, 0.562756193378043, 0.6201894912352781, 0.6002022817885863, 0.31552134347898486, 0.2882378675229357, 0.37190537945726787, 0.3144695863585689, 0.31265427626101383, 0.3674519229092388, 0.23617478903486366, 0.3426548761405367, 0.21214539851974612, 0.10517427138005764, 0.10185883879289126, 0.1005800358501836, 0.10720026898746304, 0.11021276280389214, 0.09743065919613347, 0.10043630427259576, 0.10934522794354273, 0.11114116046280975, 0.0911565820779533, 0.08288100509703833, 0.08653849929226942, 0.09673275181727026, 0.08860353423078793, 0.0864819251784309, 0.08713093249251325, 0.08930761625956751, 0.09979996359857124, 0.701000937771296, 0.8075169641587854, 0.6395610908047202, 0.8005427616672471, 0.7683173536946594, 0.7584070299954832, 0.8528465384189289, 0.7870505311417153, 0.6900352920634214, 0.2863817074998426, 0.20890192590097045, 0.22702052205741652, 0.20946922949086078, 0.22269316033469233, 0.20462819858070613, 0.23996031672144214, 0.23235633529821564, 0.1731858189579889, 0.6382826411720477, 0.5997157118394385, 0.6712554981995852, 0.6614528263501407, 0.575209247551393, 0.6817351825995804, 0.5981894526097813, 0.721103403705414, 0.6881477526701356, 0.13513213645341826, 0.3245552452525703, 0.10570262366781413, 0.1696426032532523, 0.13649664627585623, 0.14111792419104585, 0.1579347858560055, 0.1855142435131878, 0.1656982535957472, 0.20273612438084787, 0.15795864725688824, 0.17114925143426718, 0.1524967859453703, 0.12843551627703997, 0.13237124348550044, 0.1866739800656788, 0.14320635046227548, 0.15827691230807361, 0.22805809508365082, 0.22080609335194457, 0.18520867395176066, 0.2432906723210544, 0.1693061960948622, 0.12496029879130255, 0.22058354936799907, 0.20604271624036286, 0.267047982910249, 0.4151455111630171, 0.33025857125487856, 0.3271487981242269, 0.1956147164040717, 0.11029549584343656, 0.09000807271754074, 0.3554240135588378, 0.11298529328147544, 0.31247844138238, 0.06670936058127686, 0.1597727678580244, 0.1364542982048912, 0.059968836434029615, 0.10946774831843309, 0.08516001742016577, 0.11303400432780142, 0.09651556666943506, 0.07953584846131401, 0.21226355633945804, 0.17994766299660192, 0.19880542670500823, 0.15697221240042203, 0.22590419781450377, 0.15851806176848005, 0.1109719827180532, 0.16332558497915528, 0.1738861341515936, 0.5023638953445805, 0.5652622688762381, 0.44349378744656387, 0.5136801240880384, 0.4912556579523971, 0.5355928232291938, 0.48797726080511206, 0.5557210066577554, 0.4669122452888036, 0.08714455456631365, 0.10135731796439085, 0.09121714867353548, 0.09730112815115621, 0.09112838697914172, 0.11344010117046255, 0.08662160466044022, 0.10043756096958656, 0.09370647263293774, 0.1400086089681296, 0.16640056352866084, 0.1324371751952751, 0.15119560137244048, 0.15615002207641138, 0.14592832145033663, 0.13882587578842198, 0.1530005496730299, 0.1519407694359144, 0.3518175488835126, 0.36156199291113356, 0.3262009910352923, 0.34518929830574485, 0.3266957256657793, 0.3482993499946081, 0.3036973040200259, 0.3422346979936809, 0.32063905863288555, 0.2534629435503998, 0.25999807523237173, 0.23155838288545505, 0.2807518543908064, 0.2470252455749301, 0.29580452982102723, 0.26264393796259555, 0.2747206657449741, 0.27916846345352697, 0.18932291251249167, 0.24887106609069154, 0.17993437836106163, 0.17869236889957119, 0.17478096746949667, 0.17593024092092857, 0.1922915597607182, 0.19198136478405536, 0.2046973836459668, 0.17851890782591706, 0.1764097456845347, 0.1946207865321834, 0.19915664969542857, 0.1842540087440503, 0.26621822267645656, 0.18296195406096682, 0.2623816516309213, 0.18957695304714783, 0.1816007829364401, 0.38087760515389535, 0.681721611469104, 0.6023225807318437, 0.6286640912478911, 0.5869933724363097, 0.5709665228439704, 0.736414325174986, 0.6704778709427875, 0.6461653127922715, 0.4617735763259917, 0.3159192083685427, 0.37226804277067027, 0.3516141269324987, 0.20114433647671282, 0.42642767017963945, 0.31954510027186, 0.22468359886541767, 0.18012858351146732, 0.17280665241338133, 0.1757623507130236, 0.17487294542024667, 0.1782334500929259, 0.17315372879984903, 0.17387621264137, 0.17744528874386456, 0.1988342895303825, 0.09761306167475359, 0.0787331470755076, 0.07681793433421968, 0.07371406104842204, 0.07340500356316737, 0.07540870584860437, 0.07444001977563608, 0.08269168313263142, 0.07331762779673767]}, "mutation_prompt": null}
{"id": "ee3b018a-a1c8-4564-8614-eef4a1294532", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n        self.success_rate_history = []  # New line for tracking success rates\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:\n            adaptive_diff_weight *= 1.25\n        if self.success_rate_history:  # Modified to adjust mutation weight based on success history\n            historical_success_rate = np.mean(self.success_rate_history[-min(len(self.success_rate_history), 10):])  # New line\n            success_rate_variance = np.var(self.success_rate_history[-min(len(self.success_rate_history), 10):])  # New line\n            adaptive_diff_weight *= (1 + 0.2 * historical_success_rate + 0.1 * success_rate_variance)  # Adjusted line\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        adaptive_cross_prob = self.cross_prob * (0.8 + 0.2 * np.random.rand())\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < adaptive_cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return adaptive_cross_prob * mutant + (1 - adaptive_cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        gradient_info = np.random.normal(0, 0.05, size=self.dim)  # Added line for using gradient-like information\n        candidate += gradient_info  # Line modified to apply gradient influence\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n                self.success_rate_history.append(successes / self.population_size)  # New line to track success rates\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Enhance the directional search component to exploit fitness gradient information for improved convergence.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c6b89e71-4860-4450-8049-8d26beb6f506", "metadata": {"aucs": [0.6214997116003469, 0.5114110745835886, 0.5916126384803571, 0.5894494674103653, 0.6183621990215804, 0.6245497464758398, 0.562756193378043, 0.6201894912352781, 0.6002022817885863, 0.31552134347898486, 0.2882378675229357, 0.37190537945726787, 0.3144695863585689, 0.31265427626101383, 0.3674519229092388, 0.23617478903486366, 0.3426548761405367, 0.21214539851974612, 0.10517427138005764, 0.10185883879289126, 0.1005800358501836, 0.10720026898746304, 0.11021276280389214, 0.09743065919613347, 0.10043630427259576, 0.10934522794354273, 0.11114116046280975, 0.0911565820779533, 0.08288100509703833, 0.08653849929226942, 0.09673275181727026, 0.08860353423078793, 0.0864819251784309, 0.08713093249251325, 0.08930761625956751, 0.09979996359857124, 0.701000937771296, 0.8075169641587854, 0.6395610908047202, 0.8005427616672471, 0.7683173536946594, 0.7584070299954832, 0.8528465384189289, 0.7870505311417153, 0.6900352920634214, 0.2863817074998426, 0.20890192590097045, 0.22702052205741652, 0.20946922949086078, 0.22269316033469233, 0.20462819858070613, 0.23996031672144214, 0.23235633529821564, 0.1731858189579889, 0.6382826411720477, 0.5997157118394385, 0.6712554981995852, 0.6614528263501407, 0.575209247551393, 0.6817351825995804, 0.5981894526097813, 0.721103403705414, 0.6881477526701356, 0.13513213645341826, 0.3245552452525703, 0.10570262366781413, 0.1696426032532523, 0.13649664627585623, 0.14111792419104585, 0.1579347858560055, 0.1855142435131878, 0.1656982535957472, 0.20273612438084787, 0.15795864725688824, 0.17114925143426718, 0.1524967859453703, 0.12843551627703997, 0.13237124348550044, 0.1866739800656788, 0.14320635046227548, 0.15827691230807361, 0.22805809508365082, 0.22080609335194457, 0.18520867395176066, 0.2432906723210544, 0.1693061960948622, 0.12496029879130255, 0.22058354936799907, 0.20604271624036286, 0.267047982910249, 0.4151455111630171, 0.33025857125487856, 0.3271487981242269, 0.1956147164040717, 0.11029549584343656, 0.09000807271754074, 0.3554240135588378, 0.11298529328147544, 0.31247844138238, 0.06670936058127686, 0.1597727678580244, 0.1364542982048912, 0.059968836434029615, 0.10946774831843309, 0.08516001742016577, 0.11303400432780142, 0.09651556666943506, 0.07953584846131401, 0.21226355633945804, 0.17994766299660192, 0.19880542670500823, 0.15697221240042203, 0.22590419781450377, 0.15851806176848005, 0.1109719827180532, 0.16332558497915528, 0.1738861341515936, 0.5023638953445805, 0.5652622688762381, 0.44349378744656387, 0.5136801240880384, 0.4912556579523971, 0.5355928232291938, 0.48797726080511206, 0.5557210066577554, 0.4669122452888036, 0.08714455456631365, 0.10135731796439085, 0.09121714867353548, 0.09730112815115621, 0.09112838697914172, 0.11344010117046255, 0.08662160466044022, 0.10043756096958656, 0.09370647263293774, 0.1400086089681296, 0.16640056352866084, 0.1324371751952751, 0.15119560137244048, 0.15615002207641138, 0.14592832145033663, 0.13882587578842198, 0.1530005496730299, 0.1519407694359144, 0.3518175488835126, 0.36156199291113356, 0.3262009910352923, 0.34518929830574485, 0.3266957256657793, 0.3482993499946081, 0.3036973040200259, 0.3422346979936809, 0.32063905863288555, 0.2534629435503998, 0.25999807523237173, 0.23155838288545505, 0.2807518543908064, 0.2470252455749301, 0.29580452982102723, 0.26264393796259555, 0.2747206657449741, 0.27916846345352697, 0.18932291251249167, 0.24887106609069154, 0.17993437836106163, 0.17869236889957119, 0.17478096746949667, 0.17593024092092857, 0.1922915597607182, 0.19198136478405536, 0.2046973836459668, 0.17851890782591706, 0.1764097456845347, 0.1946207865321834, 0.19915664969542857, 0.1842540087440503, 0.26621822267645656, 0.18296195406096682, 0.2623816516309213, 0.18957695304714783, 0.1816007829364401, 0.38087760515389535, 0.681721611469104, 0.6023225807318437, 0.6286640912478911, 0.5869933724363097, 0.5709665228439704, 0.736414325174986, 0.6704778709427875, 0.6461653127922715, 0.4617735763259917, 0.3159192083685427, 0.37226804277067027, 0.3516141269324987, 0.20114433647671282, 0.42642767017963945, 0.31954510027186, 0.22468359886541767, 0.18012858351146732, 0.17280665241338133, 0.1757623507130236, 0.17487294542024667, 0.1782334500929259, 0.17315372879984903, 0.17387621264137, 0.17744528874386456, 0.1988342895303825, 0.09761306167475359, 0.0787331470755076, 0.07681793433421968, 0.07371406104842204, 0.07340500356316737, 0.07540870584860437, 0.07444001977563608, 0.08269168313263142, 0.07331762779673767]}, "mutation_prompt": null}
{"id": "b121b6a0-3aa0-4f16-ac79-eef4cbbc7cf0", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n        self.success_rate_history = []  # New line for tracking success rates\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:\n            adaptive_diff_weight *= 1.2  # Slightly decrease the inflation factor from 1.25 to 1.2\n        if self.success_rate_history:  # Modified to adjust mutation weight based on success history\n            historical_success_rate = np.mean(self.success_rate_history[-min(len(self.success_rate_history), 10):])  # New line\n            success_rate_variance = np.var(self.success_rate_history[-min(len(self.success_rate_history), 10):])  # New line\n            adaptive_diff_weight *= (1 + 0.2 * historical_success_rate + 0.05 * success_rate_variance)  # Slightly reduce variance influence from 0.1 to 0.05\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        adaptive_cross_prob = self.cross_prob * (0.8 + 0.2 * np.random.rand())\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < adaptive_cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return adaptive_cross_prob * mutant + (1 - adaptive_cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.9 ** (self.current_budget / self.budget)  # Slightly increase decay factor from 0.85 to 0.9\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        gradient_info = np.random.normal(0, 0.05, size=self.dim)  # Added line for using gradient-like information\n        candidate += gradient_info  # Line modified to apply gradient influence\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n                self.success_rate_history.append(successes / self.population_size)  # New line to track success rates\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Slightly adjust both mutation weight adaptation factors and step size decay for better balance between exploration and exploitation.", "configspace": "", "generation": 92, "fitness": 0.2746589612399197, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.20.", "error": "", "parent_id": "c6b89e71-4860-4450-8049-8d26beb6f506", "metadata": {"aucs": [0.6522228695538255, 0.60520323487217, 0.6616515850317761, 0.6077822186904192, 0.5909639469184873, 0.6163398465699129, 0.5960198318960956, 0.6601695264318077, 0.6342885914745239, 0.22725248088625638, 0.2526975960907014, 0.34426651632957084, 0.2909227428750978, 0.2369480460009964, 0.3695169377519595, 0.3357979946298799, 0.19909578030917097, 0.38662488667627226, 0.09316516840210276, 0.1135258385088278, 0.11239032804219384, 0.11236496773672244, 0.10896725034527266, 0.09814964408687643, 0.09856368205252897, 0.128112473417342, 0.10453367144147341, 0.09806258461409578, 0.089844233352805, 0.0914395040609356, 0.08389811744020026, 0.09063931391371771, 0.08981272107811777, 0.0739621960755994, 0.08037200364493968, 0.08613564619058778, 0.8420402464969005, 0.7467691430912181, 0.7433252548071996, 0.809082804597475, 0.7693506095579881, 0.7838364533672313, 0.7281442819853212, 0.7668762965036735, 0.7171591788615523, 0.2247977850773455, 0.27892389204971435, 0.19107343298915924, 0.20045010550440434, 0.24387795052467187, 0.19863897137066366, 0.23299312709306763, 0.2289179515601485, 0.16551415663539537, 0.625909020333116, 0.5920350948594428, 0.7585422940521345, 0.6363441204751863, 0.6807984614031494, 0.6644736847178965, 0.6900248950590777, 0.6020914070648028, 0.619651959471801, 0.13748844252620307, 0.3122959324479264, 0.25654126842586444, 0.13928317636214638, 0.14407272510982772, 0.13372737296903248, 0.11197212121080447, 0.1360452212121479, 0.13025477516878714, 0.15006366148999373, 0.1329511564573881, 0.21382292936063563, 0.23917180975337327, 0.15421045383159304, 0.14742718234129337, 0.14105831200642804, 0.18302230181382673, 0.15291385908374433, 0.07195757784239054, 0.10746312212564102, 0.14517446452692262, 0.17307257715566926, 0.14191822631972373, 0.12626601579342167, 0.10495102697229142, 0.0631665597410156, 0.09450803032139232, 0.38112753932989585, 0.15408435563939005, 0.34785386441321053, 0.26783608495773836, 0.1397752564797714, 0.19084692875063125, 0.3687330357804006, 0.22069757313015292, 0.3613302006768776, 0.07108097175166406, 0.06919851957069967, 0.09596505339087702, 0.1146858254799199, 0.12137103906902902, 0.11313824874421685, 0.11231142558666929, 0.09238060825750094, 0.15711669332519163, 0.18185618754737953, 0.18042306231581984, 0.18654338530305836, 0.15358196669482227, 0.21673764883812785, 0.11944787580137839, 0.11012372816272986, 0.19999002591299964, 0.15475261352336145, 0.5239441770490089, 0.5171740127094391, 0.5212666098117964, 0.5447646207625461, 0.5015867734379833, 0.5661338940219552, 0.427103684197672, 0.5334459075338447, 0.49299442616980627, 0.10381750844507698, 0.10292344407332088, 0.10395003739749409, 0.09958506058249972, 0.08716243977649119, 0.14011101098863143, 0.10759541077950274, 0.09784690573951571, 0.09848003665664506, 0.14106269401250315, 0.14644215942167937, 0.14140199947843068, 0.16683226339771173, 0.1521677021598371, 0.14119783745362946, 0.15650723353537688, 0.1411179432278472, 0.16507388900170294, 0.29153739720132255, 0.32320636735795216, 0.34082492342692217, 0.3629642879973869, 0.35225317877465334, 0.3311403862880379, 0.32563604590471007, 0.3119079159980175, 0.3205384333142589, 0.2544421313012837, 0.26286661826020086, 0.27379951899789634, 0.251961258273233, 0.27776371966162927, 0.23959440278647137, 0.2546969870456496, 0.22635729259816328, 0.24947782091740334, 0.19550374901444167, 0.17911899991230917, 0.19393527570933378, 0.19118773058365834, 0.20625359966138535, 0.1931792122878958, 0.18592141182189903, 0.18724760893999914, 0.20206563724297189, 0.18336638030714225, 0.18691565044884773, 0.2047619170878031, 0.18057580483402713, 0.1720903102661665, 0.20169738281559402, 0.174996730515667, 0.19921438905264766, 0.17753478043850723, 0.18013838496119128, 0.18077307240013396, 0.6350568885381039, 0.5503472102883766, 0.39790880023663044, 0.561603343449967, 0.580563540708724, 0.6908942476678697, 0.6650590826198397, 0.5752120213665199, 0.4540612800924325, 0.2555336250025231, 0.3805146619666534, 0.29581720560912084, 0.19684696846327798, 0.29817917959174434, 0.6362445213643999, 0.14858230805608819, 0.17732493257342485, 0.1818726508984575, 0.1831803546352604, 0.18794463926744842, 0.17772098074744047, 0.19974884298808093, 0.18760747947445366, 0.18874887056329148, 0.1773521402849375, 0.08333180907647075, 0.0774209332854463, 0.07985316565325451, 0.07207623221687931, 0.0886004259738582, 0.07367671698701939, 0.07784234915145005, 0.07199715548509811, 0.07733808960334321]}, "mutation_prompt": null}
{"id": "2fb24ccc-4216-4708-8d19-32a090af64f2", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n        self.success_rate_history = []  # New line for tracking success rates\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:\n            adaptive_diff_weight *= 1.25\n        if self.success_rate_history:  # Modified to adjust mutation weight based on success history\n            historical_success_rate = np.mean(self.success_rate_history[-min(len(self.success_rate_history), 10):])  # New line\n            success_rate_variance = np.var(self.success_rate_history[-min(len(self.success_rate_history), 10):])  # New line\n            adaptive_diff_weight *= (1 + 0.2 * historical_success_rate + 0.1 * success_rate_variance)  # Adjusted line\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.55  # Slight increase in binomial crossover usage\n        adaptive_cross_prob = self.cross_prob * (0.8 + 0.2 * np.random.rand())\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < adaptive_cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return adaptive_cross_prob * mutant + (1 - adaptive_cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        gradient_info = np.random.normal(0, 0.05, size=self.dim)  # Added line for using gradient-like information\n        candidate += gradient_info  # Line modified to apply gradient influence\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n                self.success_rate_history.append(successes / self.population_size)  # New line to track success rates\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Refine success rate adaptation in mutation and adjust crossover balance based on past performance for improved exploration.", "configspace": "", "generation": 93, "fitness": 0.2712524701037638, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.19.", "error": "", "parent_id": "c6b89e71-4860-4450-8049-8d26beb6f506", "metadata": {"aucs": [0.619167860788647, 0.5970208437112215, 0.5999418548065376, 0.6053210205980114, 0.6145006345550142, 0.6154949543800428, 0.599279920216307, 0.5754052849467313, 0.6722153613993251, 0.2623021514659174, 0.292243716238741, 0.35758581621242425, 0.33678092700481055, 0.3339229879277398, 0.3306122991242656, 0.3063044893744855, 0.29139538839161594, 0.24644538476935618, 0.11520632266027042, 0.0943933403309406, 0.1140761141635207, 0.10770925617182003, 0.12010288764152732, 0.12138431849403863, 0.11787240110038189, 0.09704357518355677, 0.1002548011957819, 0.09597944558724536, 0.08879062383882486, 0.09256996131233919, 0.08505037991295428, 0.10364341217383977, 0.0974264630978563, 0.08673900386113143, 0.08615715608371233, 0.10806217924711692, 0.8884746545613913, 0.7339177807952884, 0.8170170706104991, 0.7580094738171324, 0.5301612444004389, 0.7659751614288345, 0.7549123902910166, 0.5972622952942304, 0.6832172007665538, 0.21837718923037397, 0.2382745426043099, 0.18482626994024953, 0.22225109618850913, 0.16974770087463276, 0.20859261320557032, 0.20077984855856168, 0.23240148190267162, 0.22842844085697311, 0.634822774928235, 0.6235106079254618, 0.6381692649247466, 0.7149106942900575, 0.7019868732008374, 0.701630959387914, 0.6621923772022147, 0.5977349771266885, 0.600915916691728, 0.13989470041182228, 0.14153060355443026, 0.16466939149900006, 0.29664637962012796, 0.13061387206532904, 0.117248788236337, 0.13845033877387236, 0.15286374627966415, 0.14391770393996106, 0.3244091047064319, 0.12718001196171203, 0.1741773210839156, 0.1230086516630512, 0.1605708620585663, 0.13577381949679934, 0.1317465171813883, 0.2086556151276675, 0.11965642740450588, 0.12508428281938633, 0.24940596806813653, 0.17305367135098693, 0.21597981618365925, 0.21389078321786303, 0.06609388910843339, 0.22348878455676924, 0.1653868962808629, 0.19248926099456998, 0.18545823342724388, 0.3901005864311252, 0.2038465892417225, 0.0888279107963541, 0.24744123002823093, 0.20777273654549666, 0.3531884498578739, 0.2162289595710435, 0.22651759923641912, 0.09555011556036441, 0.12748193161028942, 0.08701578398435672, 0.10388974718815402, 0.06037970684585303, 0.10076198454792762, 0.09688508835286624, 0.10785064726391591, 0.07942614762564137, 0.18209338635581374, 0.13375651731021299, 0.18022762353337207, 0.18307250598570313, 0.20123707086008513, 0.2021443822293051, 0.16524516487516705, 0.18741288534597456, 0.1982255981845782, 0.5192963296771949, 0.5592600647780488, 0.5381799343974694, 0.5242558563757198, 0.5218509770359687, 0.5188410521534177, 0.5248094980328104, 0.5756583731570799, 0.4887300113498032, 0.08527663525992357, 0.1229266173610627, 0.08758162575687634, 0.10533068752695784, 0.1475570838033149, 0.09808672627136461, 0.08950097939418955, 0.0959752244016705, 0.09340962655574092, 0.13989905829482396, 0.146839558994718, 0.13874799125971726, 0.1625992758529765, 0.12863301788508086, 0.14750881638781632, 0.14002920800392005, 0.14375897746038213, 0.12670612231571032, 0.3363098674984245, 0.35406119422266846, 0.31157028138003484, 0.29279839806666974, 0.33858265113078767, 0.33531265994407566, 0.2988047443276216, 0.33224550710513345, 0.3096663076696683, 0.2759656867804615, 0.2524137642063914, 0.2202835431495187, 0.2676589004972454, 0.2570007021570858, 0.2503475372929552, 0.24050653400721034, 0.24668987793124142, 0.2773991916972611, 0.2021697570577473, 0.20902652752160167, 0.19545789910844957, 0.18479732261882187, 0.21193251785556855, 0.19001627949309008, 0.18206083087401603, 0.1982597714239407, 0.18836546740684346, 0.19436962638602961, 0.17400643068581834, 0.19288472025006742, 0.17597450294376726, 0.18591761611121627, 0.2618016721636013, 0.1977486999540572, 0.18843108506684658, 0.18939061014409997, 0.41592881204978216, 0.18636955247401643, 0.18153599802725084, 0.413031591533612, 0.30178509031010303, 0.4594474141077146, 0.5999486247792818, 0.6185553182143202, 0.37564089039756976, 0.6456828020805179, 0.2055597298006785, 0.2739604835683529, 0.25500633418441043, 0.53217238531445, 0.1923207747599942, 0.6821103219224522, 0.4339970788528945, 0.19951056185019456, 0.18358798897046458, 0.18264092968230994, 0.1734231556749286, 0.17920189981018453, 0.20121675353298218, 0.18279978145057607, 0.17899662437533914, 0.1910416878031137, 0.17065878434187287, 0.08513952801463931, 0.07352921918334343, 0.07085260431376261, 0.07845330661239658, 0.07659256456038366, 0.08442325231471837, 0.08923661049198728, 0.08100102026948774, 0.07886682149558089]}, "mutation_prompt": null}
{"id": "dafe7623-22fb-466f-85e3-b9c4fc28fd03", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n        self.success_rate_history = []  # New line for tracking success rates\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:\n            adaptive_diff_weight *= 1.25\n        if self.success_rate_history:  # Modified to adjust mutation weight based on success history\n            historical_success_rate = np.mean(self.success_rate_history[-min(len(self.success_rate_history), 10):])  # New line\n            success_rate_variance = np.var(self.success_rate_history[-min(len(self.success_rate_history), 10):])  # New line\n            adaptive_diff_weight *= (1 + 0.2 * historical_success_rate + 0.1 * success_rate_variance)  # Adjusted line\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        adaptive_cross_prob = self.cross_prob * (0.8 + 0.2 * np.random.rand())\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < adaptive_cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return adaptive_cross_prob * mutant + (1 - adaptive_cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        gradient_info = np.random.normal(0, 0.05, size=self.dim)  # Added line for using gradient-like information\n        candidate += gradient_info  # Line modified to apply gradient influence\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n                self.success_rate_history.append(successes / self.population_size)  # New line to track success rates\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Enhance the directional search component to exploit fitness gradient information for improved convergence.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c6b89e71-4860-4450-8049-8d26beb6f506", "metadata": {"aucs": [0.6214997116003469, 0.5114110745835886, 0.5916126384803571, 0.5894494674103653, 0.6183621990215804, 0.6245497464758398, 0.562756193378043, 0.6201894912352781, 0.6002022817885863, 0.31552134347898486, 0.2882378675229357, 0.37190537945726787, 0.3144695863585689, 0.31265427626101383, 0.3674519229092388, 0.23617478903486366, 0.3426548761405367, 0.21214539851974612, 0.10517427138005764, 0.10185883879289126, 0.1005800358501836, 0.10720026898746304, 0.11021276280389214, 0.09743065919613347, 0.10043630427259576, 0.10934522794354273, 0.11114116046280975, 0.0911565820779533, 0.08288100509703833, 0.08653849929226942, 0.09673275181727026, 0.08860353423078793, 0.0864819251784309, 0.08713093249251325, 0.08930761625956751, 0.09979996359857124, 0.701000937771296, 0.8075169641587854, 0.6395610908047202, 0.8005427616672471, 0.7683173536946594, 0.7584070299954832, 0.8528465384189289, 0.7870505311417153, 0.6900352920634214, 0.2863817074998426, 0.20890192590097045, 0.22702052205741652, 0.20946922949086078, 0.22269316033469233, 0.20462819858070613, 0.23996031672144214, 0.23235633529821564, 0.1731858189579889, 0.6382826411720477, 0.5997157118394385, 0.6712554981995852, 0.6614528263501407, 0.575209247551393, 0.6817351825995804, 0.5981894526097813, 0.721103403705414, 0.6881477526701356, 0.13513213645341826, 0.3245552452525703, 0.10570262366781413, 0.1696426032532523, 0.13649664627585623, 0.14111792419104585, 0.1579347858560055, 0.1855142435131878, 0.1656982535957472, 0.20273612438084787, 0.15795864725688824, 0.17114925143426718, 0.1524967859453703, 0.12843551627703997, 0.13237124348550044, 0.1866739800656788, 0.14320635046227548, 0.15827691230807361, 0.22805809508365082, 0.22080609335194457, 0.18520867395176066, 0.2432906723210544, 0.1693061960948622, 0.12496029879130255, 0.22058354936799907, 0.20604271624036286, 0.267047982910249, 0.4151455111630171, 0.33025857125487856, 0.3271487981242269, 0.1956147164040717, 0.11029549584343656, 0.09000807271754074, 0.3554240135588378, 0.11298529328147544, 0.31247844138238, 0.06670936058127686, 0.1597727678580244, 0.1364542982048912, 0.059968836434029615, 0.10946774831843309, 0.08516001742016577, 0.11303400432780142, 0.09651556666943506, 0.07953584846131401, 0.21226355633945804, 0.17994766299660192, 0.19880542670500823, 0.15697221240042203, 0.22590419781450377, 0.15851806176848005, 0.1109719827180532, 0.16332558497915528, 0.1738861341515936, 0.5023638953445805, 0.5652622688762381, 0.44349378744656387, 0.5136801240880384, 0.4912556579523971, 0.5355928232291938, 0.48797726080511206, 0.5557210066577554, 0.4669122452888036, 0.08714455456631365, 0.10135731796439085, 0.09121714867353548, 0.09730112815115621, 0.09112838697914172, 0.11344010117046255, 0.08662160466044022, 0.10043756096958656, 0.09370647263293774, 0.1400086089681296, 0.16640056352866084, 0.1324371751952751, 0.15119560137244048, 0.15615002207641138, 0.14592832145033663, 0.13882587578842198, 0.1530005496730299, 0.1519407694359144, 0.3518175488835126, 0.36156199291113356, 0.3262009910352923, 0.34518929830574485, 0.3266957256657793, 0.3482993499946081, 0.3036973040200259, 0.3422346979936809, 0.32063905863288555, 0.2534629435503998, 0.25999807523237173, 0.23155838288545505, 0.2807518543908064, 0.2470252455749301, 0.29580452982102723, 0.26264393796259555, 0.2747206657449741, 0.27916846345352697, 0.18932291251249167, 0.24887106609069154, 0.17993437836106163, 0.17869236889957119, 0.17478096746949667, 0.17593024092092857, 0.1922915597607182, 0.19198136478405536, 0.2046973836459668, 0.17851890782591706, 0.1764097456845347, 0.1946207865321834, 0.19915664969542857, 0.1842540087440503, 0.26621822267645656, 0.18296195406096682, 0.2623816516309213, 0.18957695304714783, 0.1816007829364401, 0.38087760515389535, 0.681721611469104, 0.6023225807318437, 0.6286640912478911, 0.5869933724363097, 0.5709665228439704, 0.736414325174986, 0.6704778709427875, 0.6461653127922715, 0.4617735763259917, 0.3159192083685427, 0.37226804277067027, 0.3516141269324987, 0.20114433647671282, 0.42642767017963945, 0.31954510027186, 0.22468359886541767, 0.18012858351146732, 0.17280665241338133, 0.1757623507130236, 0.17487294542024667, 0.1782334500929259, 0.17315372879984903, 0.17387621264137, 0.17744528874386456, 0.1988342895303825, 0.09761306167475359, 0.0787331470755076, 0.07681793433421968, 0.07371406104842204, 0.07340500356316737, 0.07540870584860437, 0.07444001977563608, 0.08269168313263142, 0.07331762779673767]}, "mutation_prompt": null}
{"id": "243228ec-7edc-4996-8591-6abf5d569ccd", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n        self.success_rate_history = []  # New line for tracking success rates\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:\n            adaptive_diff_weight *= 1.25\n        if self.success_rate_history:  # Modified to adjust mutation weight based on success history\n            historical_success_rate = np.mean(self.success_rate_history[-min(len(self.success_rate_history), 10):])  # New line\n            success_rate_variance = np.var(self.success_rate_history[-min(len(self.success_rate_history), 10):])  # New line\n            adaptive_diff_weight *= (1 + 0.2 * historical_success_rate + 0.1 * success_rate_variance)  # Adjusted line\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        adaptive_cross_prob = self.cross_prob * (0.8 + 0.2 * np.random.rand())\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < adaptive_cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            historical_success_adjustment = np.mean(self.success_rate_history[-min(len(self.success_rate_history), 10):]) if self.success_rate_history else 0  # Modified line\n            adaptive_cross_prob *= (1 + 0.1 * historical_success_adjustment)  # New line to adjust crossover probability\n            return adaptive_cross_prob * mutant + (1 - adaptive_cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        gradient_info = np.random.normal(0, 0.05, size=self.dim)  # Added line for using gradient-like information\n        candidate += gradient_info  # Line modified to apply gradient influence\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n                self.success_rate_history.append(successes / self.population_size)  # New line to track success rates\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Incorporate historical success information to adapt crossover probability for enhanced exploration.", "configspace": "", "generation": 95, "fitness": 0.2689668104737205, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.20.", "error": "", "parent_id": "c6b89e71-4860-4450-8049-8d26beb6f506", "metadata": {"aucs": [0.5924143054597237, 0.6169267709226196, 0.6107788227566895, 0.5515378488176408, 0.6068688705851346, 0.6024546264792021, 0.6111126044070131, 0.6153680513403598, 0.6238093352643348, 0.27509313014218195, 0.31817192714695486, 0.3394213492554512, 0.3034768378958269, 0.2210062882874687, 0.27604616491420697, 0.33087625305585733, 0.2742460588657625, 0.17244216815148428, 0.1059614253875718, 0.11355660561956227, 0.11277065326817415, 0.125889746645943, 0.09538704765948447, 0.09494099548405388, 0.10869409962781429, 0.11346405528823178, 0.09594397442287284, 0.0848657193424831, 0.08503082654760585, 0.09672646121496686, 0.09413398154869079, 0.08545608246062653, 0.09191500997432867, 0.07819315997024656, 0.08795006589600596, 0.10328774187438139, 0.6927846835827829, 0.7267516387644919, 0.6506979327673197, 0.7934771743088559, 0.7805450896761391, 0.7988668348823031, 0.7623708316221436, 0.5997261204530603, 0.6973619209724202, 0.22115972918623983, 0.2162832622820401, 0.22802564986241303, 0.19738929606811773, 0.2523860100884896, 0.23625804701247477, 0.2638079481472916, 0.17055955741748186, 0.19304898006252647, 0.6213964952911016, 0.6360975246943613, 0.6184023620032497, 0.615357597884262, 0.7313331758813637, 0.6425614419979118, 0.7653744029627783, 0.6641656919083259, 0.6077251658701288, 0.12844193023714656, 0.1203868286642884, 0.12416455739023835, 0.17016248414937185, 0.1324836846741695, 0.13600215713530306, 0.2485661518031731, 0.12947612093143612, 0.14589148842254618, 0.13429219715056007, 0.12830320293596564, 0.11515405300743553, 0.1647390483376332, 0.14376357441773013, 0.13257578170159756, 0.1313570372947972, 0.1411650519452341, 0.13378461782020845, 0.14223373422761088, 0.23786668886470586, 0.15083240701745848, 0.23732338578766887, 0.15201252890853645, 0.0524913839088913, 0.23669893555020705, 0.11299072117580833, 0.24238062077639633, 0.3524385940665631, 0.2551460085216295, 0.2800931562299136, 0.32705270517608487, 0.16313650310958017, 0.10065009162643945, 0.3742992254730486, 0.18656788939538715, 0.35402124929581624, 0.030864685790619517, 0.06330915919208124, 0.03015472539307973, 0.10375094032394627, 0.07102559510791884, 0.09101411628745193, 0.0968939349321265, 0.059502094874648526, 0.07089229235893912, 0.16643717652464962, 0.1470827410656983, 0.14416696017545705, 0.17103897086351194, 0.15877783163785675, 0.1872578026262136, 0.14898522907529077, 0.13157764568825459, 0.1445987524605411, 0.5161775764576197, 0.4698866662361083, 0.47740363525795526, 0.5242312391940724, 0.5040829089592979, 0.42413623181120197, 0.528057149182746, 0.5096703620423746, 0.547323883007374, 0.09215673598724916, 0.10197321438552098, 0.11103426561822471, 0.11742726445653262, 0.09329423883749655, 0.11049795577727017, 0.12248284575493185, 0.11428529742133053, 0.14093494101295545, 0.13555036290192823, 0.14282501551953541, 0.1384437809336314, 0.14748779580081428, 0.15088039924542807, 0.14069447714443217, 0.1512071243169536, 0.12793314688980173, 0.1269637363844549, 0.30544997645881244, 0.33046555190408977, 0.3153908271410978, 0.32203610013282435, 0.33906664671355435, 0.31702028069776256, 0.31831791291150024, 0.32438630011006675, 0.31607275422174685, 0.23157049452201617, 0.24167845059667015, 0.24370278873638773, 0.27283611989701184, 0.25552755291394946, 0.22710489525296773, 0.23622901703509358, 0.28951868613171117, 0.2596389998275689, 0.18405506449514808, 0.2351356920921993, 0.20050865027411602, 0.17468121671545978, 0.18877802839576496, 0.2050833643403892, 0.18328339654850367, 0.19867275219396896, 0.20047757005464117, 0.20648141952025634, 0.18977120578912332, 0.202249122053472, 0.19395514999723673, 0.2054468499836286, 0.19065929152665617, 0.18644808288037773, 0.19737093072512657, 0.1958172449355262, 0.5894057243315685, 0.18715719145391663, 0.6950107272655406, 0.4642704902908745, 0.6746834853531125, 0.6274521286761514, 0.1536726641862577, 0.5626125401728075, 0.5624438062809289, 0.5982708485317292, 0.4555563978399325, 0.24429094848110033, 0.33426336643551147, 0.20504015802530506, 0.19891157326417375, 0.46967164969662667, 0.205942554986407, 0.3883889441457743, 0.188429742210507, 0.17465001783152134, 0.21942797423907345, 0.19085913078413097, 0.19859893400260886, 0.19972159500090259, 0.1787381023968826, 0.1794926616683875, 0.1692852216882137, 0.08346267911049421, 0.08263570826561029, 0.08460882946293025, 0.06777900507867451, 0.07191308767377191, 0.07178231528902801, 0.08226400242651088, 0.07584823972352772, 0.07194789464957196]}, "mutation_prompt": null}
{"id": "dfba0e3f-fc5d-4ecb-aaf9-786e735d4d84", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n        self.success_rate_history = []\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:\n            adaptive_diff_weight *= 1.25\n        if self.success_rate_history:\n            historical_success_rate = np.mean(self.success_rate_history[-min(len(self.success_rate_history), 10):])\n            success_rate_variance = np.var(self.success_rate_history[-min(len(self.success_rate_history), 10):])\n            adaptive_diff_weight *= (1 + 0.2 * historical_success_rate + 0.1 * success_rate_variance)\n        fitness_diversity = np.std([func(ind) for ind in population])  # Added line for fitness diversity\n        adaptive_diff_weight *= (1 + 0.1 * fitness_diversity)  # Adjusted line\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        adaptive_cross_prob = self.cross_prob * (0.8 + 0.2 * np.random.rand())\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < adaptive_cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return adaptive_cross_prob * mutant + (1 - adaptive_cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        gradient_info = np.random.normal(0, 0.05, size=self.dim)\n        candidate += gradient_info\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n                self.success_rate_history.append(successes / self.population_size)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Integrate a fitness diversity measure to adaptively adjust mutation strategies, enhancing exploration and preventing premature convergence.", "configspace": "", "generation": 96, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "c6b89e71-4860-4450-8049-8d26beb6f506", "metadata": {}, "mutation_prompt": null}
{"id": "6df38240-4b51-4927-a049-1ac216925496", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n        self.success_rate_history = []  # New line for tracking success rates\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:\n            adaptive_diff_weight *= 1.25\n        if self.success_rate_history:  # Modified to adjust mutation weight based on success history\n            historical_success_rate = np.mean(self.success_rate_history[-min(len(self.success_rate_history), 10):])  # New line\n            success_rate_variance = np.var(self.success_rate_history[-min(len(self.success_rate_history), 10):])  # New line\n            improvement_factor = np.clip(np.mean(self.success_rate_history[-5:]), 0.5, 1.5) # New change\n            adaptive_diff_weight *= (1 + 0.2 * historical_success_rate + 0.1 * success_rate_variance) * improvement_factor  # Adjusted line\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        adaptive_cross_prob = self.cross_prob * (0.8 + 0.2 * np.random.rand())\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < adaptive_cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return adaptive_cross_prob * mutant + (1 - adaptive_cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        gradient_info = np.random.normal(0, 0.05, size=self.dim)  # Added line for using gradient-like information\n        candidate += gradient_info  # Line modified to apply gradient influence\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n                self.success_rate_history.append(successes / self.population_size)  # New line to track success rates\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Enhance the adaptive mutation mechanism by incorporating fitness improvement feedback to guide exploration more effectively.", "configspace": "", "generation": 97, "fitness": 0.22638373830588446, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.17.", "error": "", "parent_id": "c6b89e71-4860-4450-8049-8d26beb6f506", "metadata": {"aucs": [0.6991314092869803, 0.49840015804646254, 0.5907758519122648, 0.3986291304515749, 0.5542850283699938, 0.4929922147845637, 0.5403870085977096, 0.5594551685648511, 0.7010095595786947, 0.039774402095323236, 0.09173598983137488, 0.13964445862655195, 0.25092624020262533, 0.13433229974527494, 0.057718205802854916, 0.3679881789168997, 9.999999999998899e-05, 0.059430424054981446, 0.11857026793526582, 0.11568779800207318, 0.11551937248688882, 0.1471596375426628, 0.10684070511565424, 0.1154529925094937, 0.1126552887155492, 0.12673161025055202, 0.10986958597758367, 0.09822148635517591, 0.11222757830016705, 0.11169646810275413, 0.10797834706921294, 0.09207676641800078, 0.10422638604651835, 0.1127527091261119, 0.12666882029022164, 0.09176525782700906, 0.6922447464110526, 0.7362022426817505, 0.47025369820773244, 0.7979986322992668, 0.5235872764894975, 0.6383681711576061, 0.6882441074908894, 0.4810960932088715, 0.694038801978472, 0.1624879428709346, 0.16886695602681667, 0.1563270020570886, 0.14801236231407233, 0.14377009442166366, 0.13069772524707446, 0.1634191502805986, 0.1630282984099778, 0.16177048316159293, 0.27026116189942295, 0.2988364379643441, 0.34304276666693034, 0.8124812618134899, 0.33859167140458657, 0.2695514250038519, 0.22546260821599884, 0.3564604912728413, 0.19957739341471448, 0.12022894578892251, 0.1298261188757217, 0.13945050222319388, 0.16326285339214974, 0.18149179408480287, 0.13349372163745743, 0.20264911273186859, 0.12608511002350353, 0.32079874793679775, 0.13788563634392792, 0.11911251571694248, 0.1229836834634791, 0.12328659294929845, 0.12092678296107784, 0.12027257340383346, 0.22299143407185784, 0.1650580058060328, 0.14270343771249117, 0.024652279409048017, 0.05921624332965236, 0.009748849570860307, 0.03301341559425042, 0.07118615268718964, 0.06415494701187363, 0.06453121854620536, 0.04785297738053218, 0.060566982283376425, 0.16860495870055237, 0.12651521087675688, 0.11681239375045371, 0.11040641540528817, 0.08921733558060929, 0.12213277653009702, 0.19859732282851228, 0.1380288298498954, 0.11958361979913201, 0.048545824190580955, 0.10514951768063929, 0.049306003548932886, 0.040088039238924456, 0.07688237079721372, 0.050645637459475035, 0.14441028329215755, 0.11428039661410383, 0.05954343589792721, 0.09050891592494859, 0.07170858443025374, 0.14523249897081436, 0.1558308837893846, 0.15081596687751586, 0.13797800679264804, 0.07151225273472372, 0.09167377675081423, 0.17397403041711912, 0.4628383621412234, 0.40562194658778183, 0.45190695426262084, 0.39235163774150095, 0.3965894931197589, 0.403581322837953, 0.3710826279580448, 0.3487475536616036, 0.42908487216794766, 0.09801380590393494, 0.11106665462603782, 0.10880377888233583, 0.11845740513284508, 0.11766854838459206, 0.1100371746366845, 0.13146261950719162, 0.10549626599665085, 0.11801943700275097, 0.19458368207198717, 0.15827055876741802, 0.1769948233888421, 0.20019587013407003, 0.17802951974855274, 0.13885376581920095, 0.1432627863954885, 0.1854859191579299, 0.1554137636509626, 0.34244030720897756, 0.2951442333593949, 0.350791456740691, 0.32467264227802695, 0.38763252308586893, 0.267258877038001, 0.2923536332352671, 0.2831313541217415, 0.2656439136469777, 0.3094192714926782, 0.28513742100019857, 0.2541587043899389, 0.24796686939294343, 0.2461011357505024, 0.2741128440197852, 0.17851194627393308, 0.22167115097165035, 0.21519295818848216, 0.18457323861230357, 0.19404807574524652, 0.19086406619844087, 0.21284165764590446, 0.19149673499393227, 0.20825565794280887, 0.19882560528621906, 0.20281733001746038, 0.19145573651726022, 0.19345750330330236, 0.2424729754238164, 0.20052290754593594, 0.18076986808100104, 0.2194958522166377, 0.18923262243595562, 0.18305058347221814, 0.19219778511639773, 0.20102592499459893, 0.18368500994504966, 0.4059843881975864, 0.18370474301995143, 0.414073823195229, 0.37155106718537123, 0.4202133905177772, 0.6391137309505948, 0.7852540784386608, 0.6504233070480376, 0.5149451703973478, 0.38697868866964014, 0.3522731182458835, 0.371533332442158, 0.19641111843252412, 0.2029824190026781, 0.3825459931614622, 0.34641020265473277, 0.22773683250041954, 0.17557984168674157, 0.17800245168350848, 0.18106957444805094, 0.17685223380644854, 0.19499448317603352, 0.17684369689983248, 0.1851644408144968, 0.1768759376722222, 0.17907760093516467, 0.0874879429824843, 0.08296655786930673, 0.07711141054654946, 0.1088900361618853, 0.07960541970621271, 0.08683982133611623, 0.08517410295212335, 0.0777163369709919, 0.08923692001052563]}, "mutation_prompt": null}
{"id": "1584a46e-e363-4d0e-8c55-5f7c258f2af1", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n        self.success_rate_history = []  # New line for tracking success rates\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:\n            adaptive_diff_weight *= 1.25\n        if self.success_rate_history:  # Modified to adjust mutation weight based on success history\n            historical_success_rate = np.mean(self.success_rate_history[-min(len(self.success_rate_history), 10):])  # New line\n            success_rate_variance = np.var(self.success_rate_history[-min(len(self.success_rate_history), 10):])  # New line\n            adaptive_diff_weight *= (1 + 0.2 * historical_success_rate + 0.1 * success_rate_variance)  # Adjusted line\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        adaptive_cross_prob = self.cross_prob * (0.8 + 0.2 * np.random.rand())\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < adaptive_cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return adaptive_cross_prob * mutant + (1 - adaptive_cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        gradient_info = np.random.normal(0, 0.05, size=self.dim)  # Added line for using gradient-like information\n        candidate += gradient_info  # Line modified to apply gradient influence\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n                self.success_rate_history.append(successes / self.population_size)  # New line to track success rates\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Enhance the directional search component to exploit fitness gradient information for improved convergence.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c6b89e71-4860-4450-8049-8d26beb6f506", "metadata": {"aucs": [0.6214997116003469, 0.5114110745835886, 0.5916126384803571, 0.5894494674103653, 0.6183621990215804, 0.6245497464758398, 0.562756193378043, 0.6201894912352781, 0.6002022817885863, 0.31552134347898486, 0.2882378675229357, 0.37190537945726787, 0.3144695863585689, 0.31265427626101383, 0.3674519229092388, 0.23617478903486366, 0.3426548761405367, 0.21214539851974612, 0.10517427138005764, 0.10185883879289126, 0.1005800358501836, 0.10720026898746304, 0.11021276280389214, 0.09743065919613347, 0.10043630427259576, 0.10934522794354273, 0.11114116046280975, 0.0911565820779533, 0.08288100509703833, 0.08653849929226942, 0.09673275181727026, 0.08860353423078793, 0.0864819251784309, 0.08713093249251325, 0.08930761625956751, 0.09979996359857124, 0.701000937771296, 0.8075169641587854, 0.6395610908047202, 0.8005427616672471, 0.7683173536946594, 0.7584070299954832, 0.8528465384189289, 0.7870505311417153, 0.6900352920634214, 0.2863817074998426, 0.20890192590097045, 0.22702052205741652, 0.20946922949086078, 0.22269316033469233, 0.20462819858070613, 0.23996031672144214, 0.23235633529821564, 0.1731858189579889, 0.6382826411720477, 0.5997157118394385, 0.6712554981995852, 0.6614528263501407, 0.575209247551393, 0.6817351825995804, 0.5981894526097813, 0.721103403705414, 0.6881477526701356, 0.13513213645341826, 0.3245552452525703, 0.10570262366781413, 0.1696426032532523, 0.13649664627585623, 0.14111792419104585, 0.1579347858560055, 0.1855142435131878, 0.1656982535957472, 0.20273612438084787, 0.15795864725688824, 0.17114925143426718, 0.1524967859453703, 0.12843551627703997, 0.13237124348550044, 0.1866739800656788, 0.14320635046227548, 0.15827691230807361, 0.22805809508365082, 0.22080609335194457, 0.18520867395176066, 0.2432906723210544, 0.1693061960948622, 0.12496029879130255, 0.22058354936799907, 0.20604271624036286, 0.267047982910249, 0.4151455111630171, 0.33025857125487856, 0.3271487981242269, 0.1956147164040717, 0.11029549584343656, 0.09000807271754074, 0.3554240135588378, 0.11298529328147544, 0.31247844138238, 0.06670936058127686, 0.1597727678580244, 0.1364542982048912, 0.059968836434029615, 0.10946774831843309, 0.08516001742016577, 0.11303400432780142, 0.09651556666943506, 0.07953584846131401, 0.21226355633945804, 0.17994766299660192, 0.19880542670500823, 0.15697221240042203, 0.22590419781450377, 0.15851806176848005, 0.1109719827180532, 0.16332558497915528, 0.1738861341515936, 0.5023638953445805, 0.5652622688762381, 0.44349378744656387, 0.5136801240880384, 0.4912556579523971, 0.5355928232291938, 0.48797726080511206, 0.5557210066577554, 0.4669122452888036, 0.08714455456631365, 0.10135731796439085, 0.09121714867353548, 0.09730112815115621, 0.09112838697914172, 0.11344010117046255, 0.08662160466044022, 0.10043756096958656, 0.09370647263293774, 0.1400086089681296, 0.16640056352866084, 0.1324371751952751, 0.15119560137244048, 0.15615002207641138, 0.14592832145033663, 0.13882587578842198, 0.1530005496730299, 0.1519407694359144, 0.3518175488835126, 0.36156199291113356, 0.3262009910352923, 0.34518929830574485, 0.3266957256657793, 0.3482993499946081, 0.3036973040200259, 0.3422346979936809, 0.32063905863288555, 0.2534629435503998, 0.25999807523237173, 0.23155838288545505, 0.2807518543908064, 0.2470252455749301, 0.29580452982102723, 0.26264393796259555, 0.2747206657449741, 0.27916846345352697, 0.18932291251249167, 0.24887106609069154, 0.17993437836106163, 0.17869236889957119, 0.17478096746949667, 0.17593024092092857, 0.1922915597607182, 0.19198136478405536, 0.2046973836459668, 0.17851890782591706, 0.1764097456845347, 0.1946207865321834, 0.19915664969542857, 0.1842540087440503, 0.26621822267645656, 0.18296195406096682, 0.2623816516309213, 0.18957695304714783, 0.1816007829364401, 0.38087760515389535, 0.681721611469104, 0.6023225807318437, 0.6286640912478911, 0.5869933724363097, 0.5709665228439704, 0.736414325174986, 0.6704778709427875, 0.6461653127922715, 0.4617735763259917, 0.3159192083685427, 0.37226804277067027, 0.3516141269324987, 0.20114433647671282, 0.42642767017963945, 0.31954510027186, 0.22468359886541767, 0.18012858351146732, 0.17280665241338133, 0.1757623507130236, 0.17487294542024667, 0.1782334500929259, 0.17315372879984903, 0.17387621264137, 0.17744528874386456, 0.1988342895303825, 0.09761306167475359, 0.0787331470755076, 0.07681793433421968, 0.07371406104842204, 0.07340500356316737, 0.07540870584860437, 0.07444001977563608, 0.08269168313263142, 0.07331762779673767]}, "mutation_prompt": null}
{"id": "82e9a9f9-74b2-4f85-9044-6d494a6ea96b", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cross_prob = 0.9 + 0.1 / dim\n        self.diff_weight = 0.5 + np.random.rand() * 0.5\n        self.current_budget = 0\n        self.success_rate_history = []\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, population):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = population[idxs]\n        success_rate = np.random.rand()\n        adaptive_diff_weight = self.diff_weight * (1 - success_rate)\n        if success_rate > 0.5:\n            adaptive_diff_weight *= 1.25\n        if self.success_rate_history:\n            historical_success_rate = np.mean(self.success_rate_history[-min(len(self.success_rate_history), 10):])\n            success_rate_variance = np.var(self.success_rate_history[-min(len(self.success_rate_history), 10):])\n            adaptive_diff_weight *= (1 + 0.2 * historical_success_rate + 0.1 * success_rate_variance)\n        mutant = a + adaptive_diff_weight * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        use_binomial = np.random.rand() < 0.5\n        adaptive_cross_prob = self.cross_prob * (0.8 + 0.2 * np.random.rand())\n        if use_binomial:\n            crossover_mask = np.random.rand(self.dim) < adaptive_cross_prob\n            return np.where(crossover_mask, mutant, target)\n        else:\n            return adaptive_cross_prob * mutant + (1 - adaptive_cross_prob) * target\n\n    def _directional_search(self, current, func):\n        direction = np.random.normal(size=self.dim)\n        direction /= np.linalg.norm(direction)\n        decay_factor = 0.85 ** (self.current_budget / self.budget)\n        secondary_decay = (1 - self.current_budget/self.budget) ** 2\n        budget_ratio = self.current_budget / self.budget\n        step_size = (self.upper_bound - self.lower_bound) * (0.1 + 0.1 * (1 - budget_ratio) * decay_factor * secondary_decay * (0.8 + 0.4 * budget_ratio))\n        candidate = np.clip(current + step_size * direction, self.lower_bound, self.upper_bound)\n        gradient_info = np.random.normal(0, 0.05, size=self.dim)\n        candidate += gradient_info\n        adaptive_step_size = step_size * (1 + 0.15 * np.random.normal())  # Added line for adaptive learning rate\n        candidate = np.clip(current + adaptive_step_size * direction, self.lower_bound, self.upper_bound)  # Modified line\n        return candidate if func(candidate) < func(current) else current\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_budget += self.population_size\n\n        while self.current_budget < self.budget:\n            successes = 0\n            for i in range(self.population_size):\n                mutant = self._mutate(population)\n                trial = self._crossover(population[i], mutant)\n                trial = self._directional_search(trial, func)\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successes += 1\n\n                if self.current_budget >= self.budget:\n                    break\n\n            if successes > 0:\n                self.cross_prob = min(1.0, self.cross_prob + 0.01 * (successes / self.population_size))\n                self.success_rate_history.append(successes / self.population_size)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMetaheuristic", "description": "Introduce adaptive learning rate in directional search to enhance exploration-exploitation balance.", "configspace": "", "generation": 99, "fitness": 0.26403340565464356, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.19.", "error": "", "parent_id": "c6b89e71-4860-4450-8049-8d26beb6f506", "metadata": {"aucs": [0.6189931290318087, 0.5882158151152055, 0.6065993246258848, 0.6335887124433701, 0.6341638030000403, 0.6115503179891033, 0.5830755303399683, 0.645724941171663, 0.5922784555767208, 0.24093885354899192, 0.3214548304851532, 0.2876194966809821, 0.27475729398280524, 0.2795794021749519, 0.32483136635810195, 0.34912816294280724, 0.4106089898245049, 0.22037859168041873, 0.09909575659727032, 0.10517897640696139, 0.105342775953994, 0.09156181891828796, 0.10829402555598466, 0.11304498312840461, 0.10752021520717225, 0.10273685188367887, 0.09054589754409192, 0.09853721837588947, 0.094744708823156, 0.11191628556929012, 0.08950056046623289, 0.08780245759589778, 0.10277633490857097, 0.0940162667923421, 0.07922771601943279, 0.09681889638070684, 0.8530455618074576, 0.7089524235852385, 0.7854876212221419, 0.78188216961561, 0.7590470797489365, 0.8531334286006056, 0.798854081205906, 0.8076664001681455, 0.7220524511145574, 0.1955067354443507, 0.21918013016864524, 0.20651090112910775, 0.15778799143119937, 0.18875786695242291, 0.20193519008190686, 0.2559465435725553, 0.17226180134932223, 0.2523060772920096, 0.5012955923258304, 0.6139238118384065, 0.2154671429118704, 0.6653846563736185, 0.6552303503846821, 0.5598270721627039, 0.6751373643735314, 0.3059089859827081, 0.21723978046497727, 0.11541017403283682, 0.14478860575156383, 0.12914651208216765, 0.12158037954733414, 0.18825739700450272, 0.13168327154997983, 0.13552269534117944, 0.13321009285973973, 0.12480253931272423, 0.11673969702889408, 0.14586733735466917, 0.15566231630375404, 0.12344432065545552, 0.13100986558457228, 0.23763189269804053, 0.14108865488793254, 0.13833793167957487, 0.1266954171534197, 0.1817453502238453, 0.10980080455002739, 0.21811420177799545, 0.22105919934264406, 0.013698302904763149, 0.11608007818688859, 0.06188340477671117, 0.07085174887924806, 0.06404318932586861, 0.26864783590064967, 0.3603891986359208, 0.398886087630683, 0.22361164025132763, 0.29751363959138366, 0.3355045808023811, 0.3833090282033367, 0.3632799388586343, 0.13255198935937973, 0.10040021155979939, 0.1393836610417729, 0.10334991335509236, 0.05799998285766883, 0.08826166484837827, 0.10482534330993398, 0.07154736103152792, 0.0935269073221896, 0.1230065132626067, 0.14127900670534888, 0.21343232592690842, 0.16538572969546694, 0.17488838972305532, 0.21225903531028922, 0.21845172231407906, 0.16760409452692893, 0.18520410535365206, 0.18045832405301243, 0.4990967009706756, 0.508025357576585, 0.49179438484757976, 0.4795082644992371, 0.5472475432975525, 0.47731209937644015, 0.4299379247332533, 0.5084615428213084, 0.515651334126451, 0.09294604338101964, 0.09348983842881209, 0.0867945766527386, 0.11674701328522785, 0.09837748223951204, 0.09562919942084902, 0.09133132268225164, 0.08876402780698844, 0.10235023015408462, 0.15420637461533737, 0.15494982075302488, 0.13083038746429287, 0.12439533534337643, 0.13566252015071512, 0.13958467134574493, 0.12594632498638236, 0.13636660429842928, 0.1330295899593863, 0.30254017418070045, 0.35188468031183484, 0.33687376943578584, 0.3128066965829196, 0.35980551019398166, 0.3518303531380944, 0.33613795104992805, 0.32087215573657657, 0.31712583742907385, 0.24729889355301882, 0.29116490669054307, 0.25200089956112137, 0.24040232820095353, 0.2764275985854957, 0.26280942735141366, 0.24971284736665422, 0.258895173098587, 0.31090813145613394, 0.18475966536260569, 0.21407219373328934, 0.19784152113935005, 0.19003187361570217, 0.19629113728609404, 0.20570039909331572, 0.20865781916174542, 0.19453721792232614, 0.1873728279514405, 0.1787537250150204, 0.18799000019229162, 0.1908181396344264, 0.17321627486252633, 0.19333793717715897, 0.19521640155497344, 0.17862138344766298, 0.18238128329880887, 0.19571306650708598, 0.4937525018664429, 0.18051412009234158, 0.6787989458893514, 0.3904776753211945, 0.5595924835941495, 0.581620083487593, 0.5659394078356486, 0.6068485083532229, 0.6877656488562984, 0.17100863830932522, 0.19550469025003714, 0.19370538174430718, 0.22796527924104104, 0.19060235057930208, 0.19934861035438012, 0.2027153269090457, 0.3609997201127533, 0.5584368059201195, 0.18685229654079127, 0.19018070803873433, 0.17251477737167364, 0.19147465636028405, 0.17883472429601466, 0.17067767965511216, 0.1877514246987393, 0.17561434122952146, 0.18199867408220927, 0.07794339876172285, 0.08452983018171778, 0.07415160428405398, 0.0794382046783303, 0.07401611117354878, 0.09038356227492128, 0.07667999490252153, 0.08865494907403082, 0.0756842023505967]}, "mutation_prompt": null}
